filename,contest_id,contract_name,input_token,completion_token,total_token,execution_time,cost,contract_content,contract_size
RealWorld_BA_100_WithdrawHook_RealWord_20240827081330.log,100,WithdrawHook,6888,5014,11902,79.0,0.13472,"// SPDX-License-Identifier: UNLICENSED
import ""./interfaces/IHook.sol"";
import ""./interfaces/ICollateralDepositRecord.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

pragma solidity =0.8.7;

contract WithdrawHook is IHook, Ownable {
    address private _vault;
    ICollateralDepositRecord private _depositRecord;

    constructor(address _newDepositRecord) {
        _depositRecord = ICollateralDepositRecord(_newDepositRecord);
    }

    modifier onlyVault() {
        require(msg.sender == _vault, ""Caller is not the vault"");
        _;
    }

    function hook(
        address _sender,
        uint256 _initialAmount,
        uint256 _finalAmount
    ) external override onlyVault {
        _depositRecord.recordWithdrawal(_sender, _finalAmount);
    }

    function setVault(address _newVault) external override onlyOwner {
        _vault = _newVault;
        emit VaultChanged(_newVault);
    }

    function getVault() external view returns (address) {
        return _vault;
    }

    function getDepositRecord()
        external
        view
        returns (ICollateralDepositRecord)
    {
        return _depositRecord;
    }
}",257
RealWorld_BA_101_PCLClosedStage.t_RealWord_20240827094608.log,101,PCLClosedStage.t,14190,5258,19448,88.0,0.17611,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '../PCLClosedStage.t.sol';

contract PCLClosedStageCollateralNoYieldBorrowCompound is PCLClosedStage {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    function setUp() public override {
        PCLParent.setUp();

        request.borrowLimit = uint128(1_000_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * 1e18) / 1e2);
        request.collateralRatio = 1e18;
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * 1e18) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = compoundYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        // The below function will create the PCL request and then lenders lend the entire requested amount
        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        // Now we assert that we are in the ACTIVE state
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), 2);

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);
        borrower.depositCollateral(requestId, _requiredCollateral, false);

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);
        // And borrows the borrowable amount
        borrower.borrow(requestId, borrowableAmount);

        // Borrower decides to repay everything at mid-duration

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 2);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay the entire debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt);
        borrower.repay(requestId, currentDebt);

        // Now the PCL should be in the CLOSED state
        borrower.close(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }
}",684
RealWorld_BA_101_PCLLiquidatedStage.t_RealWord_20240827100812.log,101,PCLLiquidatedStage.t,16282,5963,22245,84.0,0.20067,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '../../PCLStageTests/PCLLiquidatedStage.t.sol';

contract PCLLiquidatedStageZeroCollateralBorrowCompound is PCLLiquidatedStage {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    function setUp() public override {
        PCLParent.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = 0;
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 5000 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = compoundYieldAddress;
        request.collateralAssetStrategy = compoundYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);
        lender_0 = lenders[0].lenderAddress;

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, type(uint256).max);
        if (request.collateralRatio != 0) {
            borrower.depositCollateral(requestId, _requiredCollateral, false);
        }

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);
        // and borrows the borrowable amount
        borrower.borrow(requestId, borrowableAmount);

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 10);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, currentDebt / 200);

        // Now we travel past the expiration date
        vm.warp(block.timestamp + request.duration + request.defaultGracePeriod);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');

        // Now the PCL should be in the LIQUIDATED state
        PCLUser(lender_0).liquidate(requestId, false);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED, '!LIQUIDATED');
    }
}",800
RealWorld_BA_101_Math_RealWord_20240827084740.log,101,Math,3778,3754,7532,59.0,0.09397,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

library Math {
    function min(uint256 a, uint256 b) internal pure returns (uint256) {
        return a < b ? a : b;
    }
}",51
RealWorld_BA_101_PCLExpiredStage.t_RealWord_20240827094738.log,101,PCLExpiredStage.t,15048,6125,21173,97.0,0.19774,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '../PCLExpiredStage.t.sol';

contract PCLExpiredStageCollateralNoYieldBorrowCompound is PCLExpiredStage {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    function setUp() public override {
        PCLParent.setUp();

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 5000 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 3650 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = compoundYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, type(uint256).max);
        borrower.depositCollateral(requestId, _requiredCollateral, false);

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);
        // and borrows the borrowable amount
        borrower.borrow(requestId, borrowableAmount);

        // Borrower decides to repay everything at mid-duration

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 2);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, currentDebt / 2);

        // Now we travel past the duration to the expiration period
        vm.warp(block.timestamp + 100 + request.duration / 2);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');
    }
}",705
RealWorld_BA_101_PCLAdmin.t_RealWord_20240827101525.log,101,PCLAdmin.t,24455,5566,30021,81.0,0.233595,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/utils/ReentrancyGuard.sol';
import '@openzeppelin/contracts-upgradeable/proxy/Initializable.sol';
import '@openzeppelin/contracts-upgradeable/token/ERC20/ERC20PausableUpgradeable.sol';

import '../../ProtocolFeeCollector.sol';
import '../../roles/Admin.sol';
import '../../../SublimeProxy.sol';
import '../../../PriceOracle.sol';
import '../../../CreditLine/CreditLine.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../yield/CompoundYield.sol';
import '../Helpers/PCLConstants.t.sol';
import './PCLUser.t.sol';
import '../../../PooledCreditLine/LimitsManager.sol';
import '../../../interfaces/ILimitsManager.sol';

contract PCLAdmin is PCLUser, Admin {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    bytes emptyBytes;

    constructor(address _pclAddress, address _lpAddress) PCLUser(_pclAddress, _lpAddress) {}

    function deployLimitsManager(
        address _proxyAdmin,
        address _usdc,
        address _priceOracle
    ) public returns (address) {
        LimitsManager _limitsManagerImpl = new LimitsManager(_usdc, _priceOracle);
        address sublimeProxy = address(new SublimeProxy(address(_limitsManagerImpl), _proxyAdmin, emptyBytes));
        LimitsManager limitsManager = LimitsManager(sublimeProxy);
        limitsManager.initialize(address(this));
        limitsManager.updateBorrowAmountUSDCLimits(PCLConstants.minBorrowLimit, PCLConstants.maxBorrowLimit);
        limitsManager.updateBorrowRateLimits(PCLConstants.minBorrowRate, PCLConstants.maxBorrowRate);
        limitsManager.updateCollectionPeriodLimits(PCLConstants.minCollectionPeriod, PCLConstants.maxCollectionPeriod);
        limitsManager.updateDefaultGracePeriodLimits(PCLConstants.minDefaultGraceDuration, PCLConstants.maxDefaultGraceDuration);
        limitsManager.updateDurationLimits(PCLConstants.minDuration, PCLConstants.maxDuration);
        limitsManager.updateGracePenaltyRateLimits(PCLConstants.minGracePenaltyRate, PCLConstants.maxGracePenaltyRate);
        limitsManager.updateIdealCollateralRatioLimits(PCLConstants.minCollateralRatio, PCLConstants.maxCollateralRatio);
        return sublimeProxy;
    }

    function deployPCLContracts(
        address _proxyAdmin,
        address _savingsAccount,
        address _verification,
        address _priceOracle,
        address _strategyRegistry,
        address _limitsManager,
        address _mockProtocolFeeCollector
    ) public returns (address, address) {
        //address _placeHolder = address(this);
        // use any address and latter change to, here used _placeHolder

        {
            address _lenderPoolProxyAddress = address(new SublimeProxy(address(this), _proxyAdmin, emptyBytes));
            PooledCreditLine pclImplementation = new PooledCreditLine(
                _lenderPoolProxyAddress,
                _priceOracle,
                _savingsAccount,
                _strategyRegistry,
                _verification,
                _limitsManager,
                1e18 / 10
            );
            address sublimeProxy = address(new SublimeProxy(address(pclImplementation), _proxyAdmin, emptyBytes));
            pcl = PooledCreditLine(sublimeProxy);
            //emit log_named_address('pooledcreditline address', address(pcl));

            LenderPool _lenderPoolImplementation = new LenderPool(address(pcl), _savingsAccount, _verification);
            lp = LenderPool(payable(_lenderPoolProxyAddress));

            Admin(_proxyAdmin).changeImplementationAddressOfProxy(_lenderPoolProxyAddress, address(_lenderPoolImplementation));
            //emit log_named_address('lender pool1', address(_lenderPool));
            //emit log_named_address('lender pool2', address(_lenderPoolProxyAddress));
        }

        lp.initialize();

        pcl.initialize(address(this), PCLConstants.protocolFeeFraction, _mockProtocolFeeCollector);
        return (address(pcl), address(lp));
    }

    function updateBorrowLimitLimits(uint256 _min, uint256 _max) public {
        ILimitsManager _limitsManager = pcl.LIMITS_MANAGER();
        LimitsManager(address(_limitsManager)).updateBorrowAmountUSDCLimits(_min, _max);
    }

    function updateIdealCollateralRatioLimits(uint256 _min, uint256 _max) public {
        ILimitsManager _limitsManager = pcl.LIMITS_MANAGER();
        LimitsManager(address(_limitsManager)).updateIdealCollateralRatioLimits(_min, _max);
    }

    function updateBorrowRateLimits(uint256 _min, uint256 _max) public {
        ILimitsManager _limitsManager = pcl.LIMITS_MANAGER();
        LimitsManager(address(_limitsManager)).updateBorrowRateLimits(_min, _max);
    }

    function updateCollectionPeriodLimits(uint256 _min, uint256 _max) public {
        ILimitsManager _limitsManager = pcl.LIMITS_MANAGER();
        LimitsManager(address(_limitsManager)).updateCollectionPeriodLimits(_min, _max);
    }

    function updateDurationLimits(uint256 _min, uint256 _max) public {
        ILimitsManager _limitsManager = pcl.LIMITS_MANAGER();
        LimitsManager(address(_limitsManager)).updateDurationLimits(_min, _max);
    }

    function updateDefaultGracePeriodLimits(uint256 _min, uint256 _max) public {
        ILimitsManager _limitsManager = pcl.LIMITS_MANAGER();
        LimitsManager(address(_limitsManager)).updateDefaultGracePeriodLimits(_min, _max);
    }

    function updateGracePenaltyRateLimits(uint256 _min, uint256 _max) public {
        ILimitsManager _limitsManager = pcl.LIMITS_MANAGER();
        LimitsManager(address(_limitsManager)).updateGracePenaltyRateLimits(_min, _max);
    }

    function updateProtocolFeeFraction(uint256 _protocolFeeFraction) public {
        pcl.updateProtocolFeeFraction(_protocolFeeFraction);
    }

    function updateProtocolFeeCollector(address _protocolFeeCollector) public {
        pcl.updateProtocolFeeCollector(_protocolFeeCollector);
    }
}",1341
RealWorld_BA_101_PCLLiquidatedStage.t_RealWord_20240827094447.log,101,PCLLiquidatedStage.t,15952,5813,21765,78.0,0.19602,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '../PCLLiquidatedStage.t.sol';

contract PCLLiquidatedStageCollateralNoYieldBorrowCompound is PCLLiquidatedStage {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    function setUp() public override {
        PCLParent.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 5000 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = compoundYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);
        lender_0 = lenders[0].lenderAddress;

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, type(uint256).max);
        borrower.depositCollateral(requestId, _requiredCollateral, false);

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);
        // and borrows the borrowable amount
        borrower.borrow(requestId, borrowableAmount);

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 10);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, currentDebt / 200);

        // Now we travel past the expiration date
        vm.warp(block.timestamp + request.duration + request.defaultGracePeriod);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');

        // Now the PCL should be in the LIQUIDATED state
        PCLUser(lender_0).liquidate(requestId, false);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
    }
}",781
RealWorld_BA_101_PCL_AdminUpdates.t_RealWord_20240827103520.log,101,PCL,0,0,0,,0.0,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '../../roles/User.sol';
import '../../../SublimeProxy.sol';
import '../../../mocks/Paused.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; // Required to check ERC20 balances of different actors

import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import './../../roles/Admin.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../Constants.sol';

import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/utils/ReentrancyGuard.sol';
import '@openzeppelin/contracts-upgradeable/proxy/Initializable.sol';
import '@openzeppelin/contracts-upgradeable/token/ERC20/ERC20PausableUpgradeable.sol';

import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../Roles/PCLAdmin.t.sol';
import '../Helpers/PCLConstants.t.sol';
import '../../../SublimeProxy.sol';
import 'forge-std/Test.sol';

contract PCLAdminUpdateTests is IPooledCreditLineDeclarations, Test {
    using SafeMath for uint256;
    using SafeMath for uint128;

    PriceOracle priceOracle;
    SavingsAccount savingsAccount;
    NoYield noYield;
    CompoundYield compoundYield;
    StrategyRegistry strategyRegistry;
    PooledCreditLine pooledCreditLine;
    LenderPool lenderPool;
    MockVerification2 verification;
    MockV3Aggregator aggregator1;
    MockV3Aggregator aggregator2;
    MockV3Aggregator aggregator3;
    MockToken collateralAsset;
    MockToken borrowAsset;
    MockToken USDC;
    MockWETH WETH;
    MockCToken cToken1;
    MockCToken cToken2;
    Paused pausedContract;
    PCLAdmin proxyAdmin;
    PCLAdmin admin;
    User user;
    User protocolFeeCollector;
    PCLUser pooledCreditLineBorrower;
    PCLUser pooledCreditLineLender_1;
    PCLUser pooledCreditLineLender_2;
    PCLUser pooledCreditLineLender_3;
    PCLUser pooledCreditLineLender_4;
    SublimeProxy sublimeProxyInstance;
    SublimeProxy priceOracleProxyInstance;
    SublimeProxy strategyRegistryProxyInstance;
    SublimeProxy compoundYieldProxyInstance;
    SublimeProxy pooledCreditLineProxyInstance;
    SublimeProxy lenderPoolProxyInstance;
    uint256 pooledCreditLineID;
    PooledCreditLineStatus status;
    uint256 lendAmount;
    uint256 minimumCollateralRequired;
    uint256 collateralToDeposit;
    uint256 borrowableAmount;
    uint256 amountToBorrow;
    uint256 protocolFeeFraction;
    uint256 protocolFee_1;
    uint256 protocolFee_2;
    uint256 protocolFeeCollectorBalance_1;
    uint256 protocolFeeCollectorBalance_2;
    address protocolFeeCollectorNew;
    IPooledCreditLineDeclarations.Request request;

    address pooledCreditLineAddress;
    address lenderPoolAddress;

    function setUp() public {
        // This is for the price oracle to get a non-zero timestamp
        vm.warp(block.timestamp + 10);

        proxyAdmin = new PCLAdmin(pooledCreditLineAddress, lenderPoolAddress);
        admin = new PCLAdmin(pooledCreditLineAddress, lenderPoolAddress);
        user = new User();
        protocolFeeCollector = new User();
        pausedContract = new Paused();

        collateralAsset = new MockToken('MockToken1', 'MT1', 18, 10e40, address(admin));
        borrowAsset = new MockToken('MockToken2', 'MT2', 18, 10e40, address(admin));
        USDC = new MockToken('MockUSDC', 'USDC', 6, 10e20, address(admin));
        WETH = new MockWETH();

        verification = new MockVerification2();
        aggregator1 = new MockV3Aggregator(18, 12876423400040030304304);
        aggregator2 = new MockV3Aggregator(8, 92392394976);
        aggregator3 = new MockV3Aggregator(6, 1000000);

        bytes4 functionSig;
        address sublimeProxy;
        bytes memory emptyBytes;

        PriceOracle _priceOracleImplementation = new PriceOracle(Constants.CHAINLINK_HEARTBEAT);
        priceOracleProxyInstance = new SublimeProxy(address(_priceOracleImplementation), address(proxyAdmin), emptyBytes);
        sublimeProxy = address(priceOracleProxyInstance);
        priceOracle = PriceOracle(payable(sublimeProxy));
        functionSig = admin.getFunctionSignature('initialize(address,uint32)');
        admin.execute(
            address(priceOracle),
            0,
            abi.encodePacked(functionSig, abi.encode(address(admin), address(WETH), PCLConstants.uniswapPriceAveragingPeriod))
        );

        StrategyRegistry _strategyRegistry = new StrategyRegistry();
        strategyRegistryProxyInstance = new SublimeProxy(address(_strategyRegistry), address(proxyAdmin), emptyBytes);
        sublimeProxy = address(strategyRegistryProxyInstance);
        strategyRegistry = StrategyRegistry(sublimeProxy);
        functionSig = admin.getFunctionSignature('initialize(address,uint256)');
        admin.execute(address(strategyRegistry), 0, abi.encodePacked(functionSig, abi.encode(address(admin), 10)));

        SavingsAccount _savingsAccount = new SavingsAccount(address(strategyRegistry));
        sublimeProxyInstance = new SublimeProxy(address(_savingsAccount), address(proxyAdmin), emptyBytes);
        sublimeProxy = address(sublimeProxyInstance);
        savingsAccount = SavingsAccount(sublimeProxy);
        functionSig = admin.getFunctionSignature('initialize(address)');
        admin.execute(address(savingsAccount), 0, abi.encodePacked(functionSig, abi.encode(address(admin))));

        NoYield _noYield = new NoYield(Constants._treasuryAddress, address(savingsAccount));
        sublimeProxy = address(new SublimeProxy(address(_noYield), address(proxyAdmin), emptyBytes));
        noYield = NoYield(sublimeProxy);
        functionSig = admin.getFunctionSignature('initialize(address)');
        admin.execute(address(noYield), 0, abi.encodePacked(functionSig, abi.encode(address(admin))));

        CompoundYield _compoundYield = new CompoundYield(address(WETH), Constants._treasuryAddress, address(savingsAccount));
        compoundYieldProxyInstance = new SublimeProxy(address(_compoundYield), address(proxyAdmin), emptyBytes);
        sublimeProxy = address(compoundYieldProxyInstance);
        compoundYield = CompoundYield(payable(sublimeProxy));
        functionSig = admin.getFunctionSignature('initialize(address)');
        admin.execute(address(compoundYield), 0, abi.encodePacked(functionSig, abi.encode(address(admin))));

        cToken1 = new MockCToken(address(collateralAsset));
        admin.forceUpdateTokenAddressForCompoundYield(address(compoundYield), address(collateralAsset), address(cToken1));
        admin.setDepositLimitForCompoundYield(address(compoundYield), address(collateralAsset), type(uint256).max);
        admin.transferOwnership(address(collateralAsset), address(cToken1));

        cToken2 = new MockCToken(address(borrowAsset));
        admin.forceUpdateTokenAddressForCompoundYield(address(compoundYield), address(borrowAsset), address(cToken2));
        admin.setDepositLimitForCompoundYield(address(compoundYield), address(borrowAsset), type(uint256).max);
        admin.transferOwnership(address(borrowAsset), address(cToken2));

        functionSig = admin.getFunctionSignature('addStrategy(address)');
        admin.execute(address(strategyRegistry), 0, abi.encodePacked(functionSig, abi.encode(address(noYield), 1782)));

        // Adding compoundYield to the strategy
        functionSig = admin.getFunctionSignature('addStrategy(address)');
        admin.execute(address(strategyRegistry), 0, abi.encodePacked(functionSig, abi.encode(address(compoundYield), 1782)));

        LimitsManager _limitsManager;
        {
            LimitsManager _limitsManagerImpl = new LimitsManager(address(USDC), address(priceOracle));
            sublimeProxy = address(new SublimeProxy(address(_limitsManagerImpl), address(proxyAdmin), emptyBytes));
            _limitsManager = LimitsManager(sublimeProxy);
            functionSig = admin.getFunctionSignature('initialize(address)');
            admin.execute(address(_limitsManager), 0, abi.encodePacked(functionSig, abi.encode(address(admin))));
        }

        lenderPoolProxyInstance = new SublimeProxy(address(strategyRegistry), address(proxyAdmin), emptyBytes);
        address lenderPoolProxyAddress = address(lenderPoolProxyInstance); // use any address and latter change to, here used strategyRegistry
        PooledCreditLine _pooledCreditLine = new PooledCreditLine(
            lenderPoolProxyAddress,
            address(priceOracle),
            address(savingsAccount),
            address(strategyRegistry),
            address(verification),
            address(_limitsManager),
            1e18 / 10
        );
        pooledCreditLineProxyInstance = new SublimeProxy(address(_pooledCreditLine), address(proxyAdmin), emptyBytes);
        sublimeProxy = address(pooledCreditLineProxyInstance);
        pooledCreditLine = PooledCreditLine(sublimeProxy);

        LenderPool _lenderPool = new LenderPool(address(pooledCreditLine), address(savingsAccount), address(verification));
        lenderPool = LenderPool(lenderPoolProxyAddress);
        proxyAdmin.changeImplementationAddressOfProxy(address(lenderPool), address(_lenderPool));
        functionSig = admin.getFunctionSignature('initialize()');
        admin.execute(address(lenderPool), 0, abi.encodePacked(functionSig));

        functionSig = admin.getFunctionSignature('initialize(address,uint256,address)');
        admin.execute(
            address(pooledCreditLine),
            0,
            abi.encodePacked(functionSig, abi.encode(address(admin), 10e16, address(protocolFeeCollector)))
        );

        pooledCreditLineAddress = address(pooledCreditLine);
        lenderPoolAddress = address(lenderPool);

        pooledCreditLineBorrower = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        pooledCreditLineLender_1 = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        pooledCreditLineLender_2 = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        pooledCreditLineLender_3 = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        pooledCreditLineLender_4 = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);

        admin.setChainlinkFeedAddress(address(priceOracle), address(collateralAsset), address(aggregator1), Constants.CHAINLINK_HEARTBEAT);
        admin.setChainlinkFeedAddress(address(priceOracle), address(borrowAsset), address(aggregator2), Constants.CHAINLINK_HEARTBEAT);
        admin.setChainlinkFeedAddress(address(priceOracle), address(USDC), address(aggregator3), Constants.CHAINLINK_HEARTBEAT);

        // Adding the verifiers to the verifiers mapping
        verification.whitelistVerifier(PCLConstants._borrowerVerifier);
        verification.whitelistVerifier(PCLConstants._lenderVerifier);

        // Verifying the users
        verification.verifyUser(address(pooledCreditLineBorrower), address(PCLConstants._borrowerVerifier));
        verification.verifyUser(address(pooledCreditLineLender_1), address(PCLConstants._lenderVerifier));
        verification.verifyUser(address(pooledCreditLineLender_2), address(PCLConstants._lenderVerifier));
        verification.verifyUser(address(pooledCreditLineLender_3), address(PCLConstants._lenderVerifier));
        verification.verifyUser(address(pooledCreditLineLender_4), address(PCLConstants._lenderVerifier));

        admin.updateLP(lenderPoolAddress);
        admin.updatePCL(pooledCreditLineAddress);

        // Setting limits for the pooledCreditLine
        admin.updateBorrowRateLimits(PCLConstants.minBorrowRate, PCLConstants.maxBorrowRate);
        admin.updateBorrowLimitLimits(PCLConstants.minBorrowLimit, PCLConstants.maxBorrowLimit);

        admin.updateIdealCollateralRatioLimits(PCLConstants.minCollateralRatio, PCLConstants.maxCollateralRatio);

        admin.updateCollectionPeriodLimits(PCLConstants.minCollectionPeriod, PCLConstants.maxCollectionPeriod);

        admin.updateDurationLimits(PCLConstants.minDuration, PCLConstants.maxDuration);

        admin.updateDefaultGracePeriodLimits(PCLConstants.minDefaultGraceDuration, PCLConstants.maxDefaultGraceDuration);

        admin.updateGracePenaltyRateLimits(PCLConstants.minGracePenaltyRate, PCLConstants.maxGracePenaltyRate);

        // Setting up the request parameteres for creating a PCL
        request.borrowLimit = uint128(1_000_000 * 1e18);
        request.borrowRate = uint128((5 * 1e18) / 1e2);
        request.collateralRatio = 1e18;
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = address(PCLConstants._lenderVerifier);
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * 1e18) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 1e18;
        request.borrowAssetStrategy = address(compoundYield);
        request.collateralAssetStrategy = address(compoundYield);
        request.borrowerVerifier = address(PCLConstants._borrowerVerifier);
        request.areTokensTransferable = true;
    }

    // Test1: Admin increases ideal collateral ratio limits
    function test_increaseCollateralRatioLimit() public {
        request.collateralRatio = PCLConstants.maxCollateralRatio.mul(100);
        try pooledCreditLineBorrower.createRequest(request) {
            revert('Borrower cannot increase collateral ratio limit');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:R8');
        }

        admin.updateIdealCollateralRatioLimits(PCLConstants.minCollateralRatio, PCLConstants.maxCollateralRatio.mul(100));
        pooledCreditLineID = pooledCreditLineBorrower.createRequest(request);
        status = pooledCreditLine.getStatusAndUpdate(pooledCreditLineID);
        assertTrue(status == PooledCreditLineStatus.REQUESTED);
    }

    // Test2: Admin decreases the ideal collateral ratio limit
    function test_decreaseCollateralRatioLimit() public {
        request.collateralRatio = PCLConstants.minCollateralRatio.div(100);
        try pooledCreditLineBorrower.createRequest(request) {
            revert('Borrower cannot change the collateral ratio limit ');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:R8');
        }

        admin.updateIdealCollateralRatioLimits(PCLConstants.minCollateralRatio.div(100), PCLConstants.maxCollateralRatio);

        pooledCreditLineID = pooledCreditLineBorrower.createRequest(request);
        status = pooledCreditLine.getStatusAndUpdate(pooledCreditLineID);
        assertTrue(status == PooledCreditLineStatus.REQUESTED);
    }

    // Test3: Increase borrow Rate Limits
    function test_increaseBorrowRateLimit() public {
        request.borrowRate = uint128(PCLConstants.maxBorrowRate.mul(100));
        try pooledCreditLineBorrower.createRequest(request) {
            revert('Borrower cannot change the Borrow Rate Limits');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:R7');
        }

        admin.updateBorrowRateLimits(PCLConstants.minBorrowRate, PCLConstants.maxBorrowRate.mul(100));
        pooledCreditLineID = pooledCreditLineBorrower.createRequest(request);
        status = pooledCreditLine.getStatusAndUpdate(pooledCreditLineID);
        assertTrue(status == PooledCreditLineStatus.REQUESTED);
    }

    // Test4: Decrease borrow rate limits
    function test_decreaseBorrowRateLimit() public {
        request.borrowRate = uint128(PCLConstants.minBorrowRate.div(100));
        try pooledCreditLineBorrower.createRequest(request) {
            revert('Borrower cannot change the Borrow Rate Limits');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:R7');
        }

        admin.updateBorrowRateLimits(PCLConstants.minBorrowRate.div(100), PCLConstants.maxBorrowRate);
        pooledCreditLineID = pooledCreditLineBorrower.createRequest(request);
        status = pooledCreditLine.getStatusAndUpdate(pooledCreditLineID);
        assertTrue(status == PooledCreditLineStatus.REQUESTED);
    }

    // Test5: Increase collection Limits
    function test_increaseCollectionPeriodLimit() public {
        request.collectionPeriod = PCLConstants.maxCollectionPeriod.mul(10);
        try pooledCreditLineBorrower.createRequest(request) {
            revert('Borrower cannot change the Collection Period Limits');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:R9');
        }

        admin.updateCollectionPeriodLimits(PCLConstants.minCollectionPeriod, PCLConstants.maxCollectionPeriod.mul(10));
        pooledCreditLineID = pooledCreditLineBorrower.createRequest(request);
        status = pooledCreditLine.getStatusAndUpdate(pooledCreditLineID);
        assertTrue(status == PooledCreditLineStatus.REQUESTED);
    }

    // Test6: Decrease collection Limits
    function test_decreaseCollectionPeriodLimit() public {
        request.collectionPeriod = PCLConstants.minCollectionPeriod.div(10);
        try pooledCreditLineBorrower.createRequest(request) {
            revert('Borrower cannot change the Borrow Rate Limits');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:R9');
        }

        admin.updateCollectionPeriodLimits(PCLConstants.minCollectionPeriod.div(10), PCLConstants.maxCollectionPeriod);
        pooledCreditLineID = pooledCreditLineBorrower.createRequest(request);
        status = pooledCreditLine.getStatusAndUpdate(pooledCreditLineID);
        assertTrue(status == PooledCreditLineStatus.REQUESTED);
    }

    // Test7: Decrease duration Limits
    function test_decreaseDurationLimits() public {
        request.duration = PCLConstants.minDuration.div(100);
        try pooledCreditLineBorrower.createRequest(request) {
            revert('Borrower cannot change the Duration Limits');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:R10');
        }
        admin.updateDurationLimits(PCLConstants.minDuration.div(100), PCLConstants.maxDuration);
        pooledCreditLineID = pooledCreditLineBorrower.createRequest(request);
        status = pooledCreditLine.getStatusAndUpdate(pooledCreditLineID);
        assertTrue(status == PooledCreditLineStatus.REQUESTED);
    }

    // Test8: Increase duration Limits
    function test_increaseDurationLimits() public {
        request.duration = PCLConstants.maxDuration.mul(100);
        try pooledCreditLineBorrower.createRequest(request) {
            revert('Borrower should not be able to change duration limits');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:R10');
        }
        admin.updateDurationLimits(PCLConstants.minDuration, PCLConstants.maxDuration.mul(100));
        pooledCreditLineID = pooledCreditLineBorrower.createRequest(request);
        status = pooledCreditLine.getStatusAndUpdate(pooledCreditLineID);
        assertTrue(status == PooledCreditLineStatus.REQUESTED);
    }

    // Test9: Increase Default Grace Period Limits
    function test_increaseDefaultGracePeriodLimits() public {
        request.defaultGracePeriod = PCLConstants.maxDefaultGraceDuration.mul(100);
        try pooledCreditLineBorrower.createRequest(request) {
            revert('Borrower cannot change default grace period limits');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:R11');
        }
        admin.updateDefaultGracePeriodLimits(PCLConstants.minDefaultGraceDuration, PCLConstants.maxDefaultGraceDuration.mul(100));
        pooledCreditLineID = pooledCreditLineBorrower.createRequest(request);
        status = pooledCreditLine.getStatusAndUpdate(pooledCreditLineID);
        assertTrue(status == PooledCreditLineStatus.REQUESTED);
    }

    // Test10: Decrease Default Grace Period Limits
    function test_decreaseDefaultGracePeriodLimits() public {
        request.defaultGracePeriod = PCLConstants.minDefaultGraceDuration.div(100);
        try pooledCreditLineBorrower.createRequest(request) {
            revert('Borrower cannot change default grace period limits');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:R11');
        }
        admin.updateDefaultGracePeriodLimits(PCLConstants.minDefaultGraceDuration.div(100), PCLConstants.maxDefaultGraceDuration);
        pooledCreditLineID = pooledCreditLineBorrower.createRequest(request);
        status = pooledCreditLine.getStatusAndUpdate(pooledCreditLineID);
        assertTrue(status == PooledCreditLineStatus.REQUESTED);
    }

    // Test11 Increase Grace Penalty Rate Limits
    function test_increaseGracePenaltyRateLimits() public {
        request.gracePenaltyRate = PCLConstants.maxGracePenaltyRate.mul(100);
        try pooledCreditLineBorrower.createRequest(request) {
            revert('Borrower cannot change grace penalty rates');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:R12');
        }
        admin.updateGracePenaltyRateLimits(PCLConstants.minGracePenaltyRate, PCLConstants.maxGracePenaltyRate.mul(100));
        pooledCreditLineID = pooledCreditLineBorrower.createRequest(request);
        status = pooledCreditLine.getStatusAndUpdate(pooledCreditLineID);
        assertTrue(status == PooledCreditLineStatus.REQUESTED);
    }

    // Test12 Decrease Grace Penalty Rate Limits
    function test_decreaseGracePenaltyRateLimits() public {
        request.gracePenaltyRate = PCLConstants.minGracePenaltyRate.div(100);
        try pooledCreditLineBorrower.createRequest(request) {
            revert('Borrower cannot change grace penalty rate');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:R12');
        }

        admin.updateGracePenaltyRateLimits(PCLConstants.minGracePenaltyRate.div(100), PCLConstants.maxGracePenaltyRate);
        pooledCreditLineID = pooledCreditLineBorrower.createRequest(request);
        status = pooledCreditLine.getStatusAndUpdate(pooledCreditLineID);
        assertTrue(status == PooledCreditLineStatus.REQUESTED);
    }

    function test_cannotUpdateBorrowLimitLimitsWithMinMoreThanMax() public {
        try admin.updateBorrowLimitLimits(PCLConstants.maxBorrowLimit, PCLConstants.minBorrowLimit) {
            revert('Admin cannot decrease the borrow limit less than minimum');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:UBLL1');
        }
    }

    function test_cannotUpdateBorrowLimitLimitsSameAsPrevious() public {
        try admin.updateBorrowLimitLimits(PCLConstants.minBorrowLimit, PCLConstants.maxBorrowLimit) {
            revert('Admin cannot increase the borrow limit more than maximum');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:UBLL2');
        }
    }

    function test_cannotUpdateIdealCollateralRatioLimitsWithMinMoreThanMax() public {
        try admin.updateIdealCollateralRatioLimits(PCLConstants.maxCollateralRatio, PCLConstants.minCollateralRatio) {
            revert('Admin cannot set minimum ideal collateral ratio more than the max permissible');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:UICRL1');
        }
    }

    function test_cannotUpdateIdealCollateralRatioLimitsSameAsPrevious() public {
        try admin.updateIdealCollateralRatioLimits(PCLConstants.minCollateralRatio, PCLConstants.maxCollateralRatio) {
            revert('Admin cannot update ideal collateral ratio limits same as previous');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:UICRL2');
        }
    }

    function test_cannotUpdateBorrowRateLimitsWithMinMoreThanMax() public {
        try admin.updateBorrowRateLimits(PCLConstants.maxBorrowRate, PCLConstants.minBorrowRate) {
            revert('Cannot update borrow rate limits as min more than max');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:UBRL1');
        }
    }

    function test_cannotUpdateBorrowRateLimitsSameAsPrevious() public {
        try admin.updateBorrowRateLimits(PCLConstants.minBorrowRate, PCLConstants.maxBorrowRate) {
            revert(' ');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:UBRL2');
        }
    }

    function test_cannotUpdateCollectionPeriodLimitsWithMinMoreThanMax() public {
        try admin.updateCollectionPeriodLimits(PCLConstants.maxCollectionPeriod, PCLConstants.minCollectionPeriod) {
            revert('Cannot set the min collection period as more than the max permissible');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:UCPL1');
        }
    }

    function test_cannotUpdateCollectionPeriodLimitsSameAsPrevious() public {
        try admin.updateCollectionPeriodLimits(PCLConstants.minCollectionPeriod, PCLConstants.maxCollectionPeriod) {
            revert(' Admin cannot set the collection period the same as current value');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:UCPL2');
        }
    }

    function test_cannotUpdateDurationLimitsWithMinMoreThanMax() public {
        try admin.updateDurationLimits(PCLConstants.maxDuration, PCLConstants.minDuration) {
            revert('Cannot set min duration more than the max permissible');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:UDL1');
        }
    }

    function test_cannotUpdateDurationLimitsSameAsPrevious() public {
        try admin.updateDurationLimits(PCLConstants.minDuration, PCLConstants.maxDuration) {
            revert('Admin cannot set the duration limits the same as current values');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:UDL2');
        }
    }

    function test_cannotUpdateDefaultGracePeriodLimitsWithMinMoreThanMax() public {
        try admin.updateDefaultGracePeriodLimits(PCLConstants.maxDefaultGraceDuration, PCLConstants.minDefaultGraceDuration) {
            revert('Cannot set min default grace period more than the max permissible');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:UDGPL1');
        }
    }

    function test_cannotUpdateDefaultGracePeriodLimitsSameAsPrevious() public {
        try admin.updateDefaultGracePeriodLimits(PCLConstants.minDefaultGraceDuration, PCLConstants.maxDefaultGraceDuration) {
            revert('Admin cannot set the default grace period limits the same as current values');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:UDGPL2');
        }
    }

    function test_cannotUpdateGracePenaltyRateLimitsWithMinMoreThanMax() public {
        try admin.updateGracePenaltyRateLimits(PCLConstants.maxGracePenaltyRate, PCLConstants.minGracePenaltyRate) {
            revert('Admin cannot set minimum grace penalty rate limit than the max permissible');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:UGPRL1');
        }
    }

    function test_cannotUpdateGracePenaltyRateLimitsSameAsPrevious() public {
        try admin.updateGracePenaltyRateLimits(PCLConstants.minGracePenaltyRate, PCLConstants.maxGracePenaltyRate) {
            revert('Cannot update the protocol fee fraction to be lower than min');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:UGPRL2');
        }
    }

    function test_cannotUpdateProtocolFeeFractionMoreThanMax() public {
        try admin.updateProtocolFeeFraction(PCLConstants.protocolFeeFraction + 1) {
            revert('Cannot update the protocol fee fraction to be higher than max');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:IUPFF1');
        }
    }

    function test_cannotUpdateProtocolFeeFractionSameAsPrevious() public {
        try admin.updateProtocolFeeFraction(PCLConstants.protocolFeeFraction) {
            revert('Cannot update the protocol fee fraction the same as before');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:UPFF1');
        }
    }

    function test_cannotUpdateProtocolFeeCollectorWithZeroAddress() public {
        try admin.updateProtocolFeeCollector(address(0)) {
            revert('Cannot set the protocolFeeCollector as address(0)');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:IUPFC1');
        }
    }

    function test_cannotUpdateProtocolFeeCollectorSameAsPrevious() public {
        try admin.updateProtocolFeeCollector(address(protocolFeeCollector)) {
            revert('Cannot update the protocolFeeCollector address same as before');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:UPFC1');
        }
    }

    // Test15: Change the protocol fee collector address in the middle of a working PCL
    function test_changeProtocolFeeCollectorAddress() public {
        address protocolFeeCollectorOld = pooledCreditLine.protocolFeeCollector();

        pooledCreditLineID = pooledCreditLineBorrower.createRequest(request);
        status = pooledCreditLine.getStatusAndUpdate(pooledCreditLineID);
        assertTrue(status == PooledCreditLineStatus.REQUESTED); //Status should change to REQUESTED

        // Transferring borrow tokens to the lender
        lendAmount = request.borrowLimit;
        admin.transferToken(address(borrowAsset), address(pooledCreditLineLender_1), lendAmount);
        pooledCreditLineLender_1.setAllowance(address(lenderPool), address(borrowAsset), type(uint256).max);
        pooledCreditLineLender_1.lend(pooledCreditLineID, lendAmount);

        // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
        minimumCollateralRequired = pooledCreditLineBorrower.getRequiredCollateral(pooledCreditLineID, lendAmount);

        // Transferring collateral tokens to the borrower
        collateralToDeposit = minimumCollateralRequired.mul(2);
        admin.transferToken(address(collateralAsset), address(pooledCreditLineBorrower), collateralToDeposit);
        pooledCreditLineBorrower.setAllowance(address(pooledCreditLine), address(collateralAsset), type(uint256).max);

        // Since borrow can only be done after the collection period,
        vm.warp(block.timestamp + request.collectionPeriod);
        pooledCreditLineBorrower.start(pooledCreditLineID);

        // We want to deposit collateral now
        pooledCreditLineBorrower.depositCollateral(pooledCreditLineID, collateralToDeposit, false);

        // Calculating the borrowable amount:
        borrowableAmount = pooledCreditLineBorrower.calculateBorrowableAmount(pooledCreditLineID);
        amountToBorrow = borrowableAmount.div(4);

        //Trying to borrow the borrowable amount:
        pooledCreditLineBorrower.borrow(pooledCreditLineID, amountToBorrow);

        // Calculating the protocolFee on amountToBorrow
        protocolFeeFraction = pooledCreditLine.protocolFeeFraction();
        protocolFee_1 = (amountToBorrow.mul(protocolFeeFraction)).div(1e18);

        // Asserting that protocolFeeCollector got the correct amount of fee
        protocolFeeCollectorBalance_1 = IERC20(address(borrowAsset)).balanceOf(address(protocolFeeCollector));
        assertApproxEqAbs(protocolFee_1, protocolFeeCollectorBalance_1, 2);

        // Update the address of protocolFeeCollector
        admin.updateProtocolFeeCollector(address(pooledCreditLineLender_3));
        protocolFeeCollectorNew = pooledCreditLine.protocolFeeCollector();

        // Assert that the protocolFeeCollector address indeed got updated.
        assertEq(protocolFeeCollectorNew, address(pooledCreditLineLender_3));
        assertTrue(protocolFeeCollectorOld != protocolFeeCollectorNew);

        // Finding the initial balance of the new protocolFeeCollector before second withdrawal
        uint256 protocolFeeCollectorBalance_2Initial = IERC20(address(borrowAsset)).balanceOf(protocolFeeCollectorNew);
        log_uint(protocolFeeCollectorBalance_2Initial);

        // Borrowing some more money so that the protocol fee gets deducted
        amountToBorrow = borrowableAmount.div(2);
        pooledCreditLineBorrower.borrow(pooledCreditLineID, amountToBorrow);

        // Balance of protocolFeeCollector after the second withdrawal
        uint256 protocolFeeCollectorBalance_2Final = IERC20(address(borrowAsset)).balanceOf(protocolFeeCollectorNew);

        // Since the protocolFeeCollector address has changed, now their balance should be equal to the newly calculated protocolFee
        protocolFee_2 = (amountToBorrow.mul(protocolFeeFraction)).div(1e18);
        protocolFeeCollectorBalance_2 = protocolFeeCollectorBalance_2Final.sub(protocolFeeCollectorBalance_2Initial);
        assertApproxEqAbs(protocolFee_2, protocolFeeCollectorBalance_2, 2);
        assertApproxEqAbs(protocolFeeCollectorBalance_1, IERC20(address(borrowAsset)).balanceOf(address(protocolFeeCollectorOld)), 2);
    }

    // Test16: Change the protocolFeeFraction
    function test_changeProtocolFeeFraction() public {
        uint256 protocolFeeFractionOld = pooledCreditLine.protocolFeeFraction();

        pooledCreditLineID = pooledCreditLineBorrower.createRequest(request);

        status = pooledCreditLine.getStatusAndUpdate(pooledCreditLineID);
        assertTrue(status == PooledCreditLineStatus.REQUESTED); //Status should change to REQUESTED

        // Transferring borrow tokens to the lender
        lendAmount = request.borrowLimit;
        admin.transferToken(address(borrowAsset), address(pooledCreditLineLender_1), lendAmount);
        pooledCreditLineLender_1.setAllowance(address(lenderPool), address(borrowAsset), type(uint256).max);
        pooledCreditLineLender_1.lend(pooledCreditLineID, lendAmount);

        // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
        minimumCollateralRequired = pooledCreditLineBorrower.getRequiredCollateral(pooledCreditLineID, lendAmount);

        // Transferring collateral tokens to the borrower
        collateralToDeposit = minimumCollateralRequired.mul(2);
        admin.transferToken(address(collateralAsset), address(pooledCreditLineBorrower), collateralToDeposit);
        pooledCreditLineBorrower.setAllowance(address(pooledCreditLine), address(collateralAsset), type(uint256).max);

        // Since borrow can only be done after the collection period,
        vm.warp(block.timestamp + request.collectionPeriod);
        pooledCreditLineBorrower.start(pooledCreditLineID);

        // We want to deposit collateral now
        pooledCreditLineBorrower.depositCollateral(pooledCreditLineID, collateralToDeposit, false);

        // Calculating the borrowable amount:
        borrowableAmount = pooledCreditLineBorrower.calculateBorrowableAmount(pooledCreditLineID);
        amountToBorrow = borrowableAmount.div(2);

        //Trying to borrow half the borrowable amount:
        pooledCreditLineBorrower.borrow(pooledCreditLineID, amountToBorrow);

        // Calculating the protocol fee on the amountToBorrow
        protocolFeeFraction = pooledCreditLine.protocolFeeFraction();
        protocolFee_1 = (amountToBorrow.mul(protocolFeeFraction)).div(1e18);
        uint256 protocolFeeCollectorBalanceInitial = IERC20(address(borrowAsset)).balanceOf(address(protocolFeeCollector));

        // Update the protocolFeeFraction
        admin.updateProtocolFeeFraction(1e16);
        uint256 protocolFeeFractionNew = pooledCreditLine.protocolFeeFraction();

        // Now the borrowable amount should be equal to the earlier amountToBorrow
        borrowableAmount = pooledCreditLineBorrower.calculateBorrowableAmount(pooledCreditLineID);
        assertApproxEqAbs(borrowableAmount, amountToBorrow, 2);

        //Trying to borrow the borrowable amount:
        pooledCreditLineBorrower.borrow(pooledCreditLineID, amountToBorrow);

        // Calculating the protocol fee after the second borrow
        protocolFee_2 = (amountToBorrow.mul(protocolFeeFractionNew)).div(1e18);
        uint256 protocolFeeCollectorBalanceFinal = IERC20(address(borrowAsset)).balanceOf(address(protocolFeeCollector));
        uint256 protocolFeeCollectorBalanceAfter2ndBorrow = protocolFeeCollectorBalanceFinal.sub(protocolFeeCollectorBalanceInitial);

        // Asserting that the protocol fee for both borrowals was different even though the amount was same
        assertTrue(!(protocolFeeCollectorBalanceInitial == protocolFeeCollectorBalanceAfter2ndBorrow));
        assertEq(protocolFeeFractionNew, 1e16);
        assertTrue(protocolFeeFractionOld != protocolFeeFractionNew);
    }

    // Test18: Test the pause and upgrade functionality as the admin
    function test_pauseAndUpgradeContractsWhenSomethingBadHappens() public {
        pooledCreditLineID = pooledCreditLineBorrower.createRequest(request);

        status = pooledCreditLine.getStatusAndUpdate(pooledCreditLineID);
        assertTrue(status == PooledCreditLineStatus.REQUESTED); //Status should change to REQUESTED

        // Transferring borrow tokens to the lender
        lendAmount = request.borrowLimit;
        admin.transferToken(address(borrowAsset), address(pooledCreditLineLender_1), lendAmount);
        pooledCreditLineLender_1.setAllowance(address(lenderPool), address(borrowAsset), type(uint256).max);
        pooledCreditLineLender_1.lend(pooledCreditLineID, lendAmount);

        // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
        minimumCollateralRequired = pooledCreditLineBorrower.getRequiredCollateral(pooledCreditLineID, lendAmount);

        // Transferring collateral tokens to the borrower
        collateralToDeposit = minimumCollateralRequired.mul(2);
        admin.transferToken(address(collateralAsset), address(pooledCreditLineBorrower), collateralToDeposit);
        pooledCreditLineBorrower.setAllowance(address(pooledCreditLine), address(collateralAsset), type(uint256).max);

        // Since borrow can only be done after the collection period,
        vm.warp(block.timestamp + request.collectionPeriod);
        pooledCreditLineBorrower.start(pooledCreditLineID);

        // We want to deposit collateral now
        pooledCreditLineBorrower.depositCollateral(pooledCreditLineID, collateralToDeposit, false);

        // Calculating the borrowable amount:
        borrowableAmount = pooledCreditLineBorrower.calculateBorrowableAmount(pooledCreditLineID);
        amountToBorrow = borrowableAmount.div(4);

        //Trying to borrow the borrowable amount:
        pooledCreditLineBorrower.borrow(pooledCreditLineID, amountToBorrow);

        // Something went terribly wrong and noew we want to pause all interactions with the savings account.
        // Setting the new savings account address to address(0) or 0xffff....ff doesn't work. This error is thrown:
        // Revert (""UpgradeableProxy: new implementation is not a contract""
        log_address(address(pausedContract));

        address pcl_savingsAccount_old = address(pooledCreditLine.SAVINGS_ACCOUNT());
        address savingsAccount_impl = proxyAdmin.getImplementationAddressOfProxy(sublimeProxyInstance);
        log_named_address('Old Savings Account', savingsAccount_impl);

        proxyAdmin.changeImplementationAddressOfProxy(address(sublimeProxyInstance), address(pausedContract));

        address pausedContractAddress = proxyAdmin.getImplementationAddressOfProxy(sublimeProxyInstance);
        log_named_address('Paused Contract Address', pausedContractAddress);
        address pcl_savingsAccount_new = address(pooledCreditLine.SAVINGS_ACCOUNT());

        // assert that the savings account address for the pcl should not change
        assertEq(pcl_savingsAccount_new, pcl_savingsAccount_old);

        // Assert that the implementation addresses of the savings account changed to a paused contract
        assertTrue(savingsAccount_impl != pausedContractAddress);

        // Now that the savingsAccount is paused, let's change the proxyImplementation to a patched savingsAccount
        SavingsAccount patchedSavingsAccount = new SavingsAccount(address(strategyRegistry));
        proxyAdmin.changeImplementationAddressOfProxy(address(sublimeProxyInstance), address(patchedSavingsAccount));

        // Now comparing the address of the patchedSavingsAccount with pausedContract
        address patchedSavingsAccountAddress = proxyAdmin.getImplementationAddressOfProxy(sublimeProxyInstance);
        log_named_address('New Saving Account', patchedSavingsAccountAddress);

        assertTrue(patchedSavingsAccountAddress != pausedContractAddress);
    }

    // Test19: Test the pause functionality as the admin
    function testFail_stopSavingsAccountInteraction() public {
        pooledCreditLineID = pooledCreditLineBorrower.createRequest(request);

        status = pooledCreditLine.getStatusAndUpdate(pooledCreditLineID);
        assertTrue(status == PooledCreditLineStatus.REQUESTED); //Status should change to REQUESTED

        // Transferring borrow tokens to the lender
        lendAmount = request.borrowLimit;
        admin.transferToken(address(borrowAsset), address(pooledCreditLineLender_1), lendAmount);
        pooledCreditLineLender_1.setAllowance(address(lenderPool), address(borrowAsset), type(uint256).max);
        pooledCreditLineLender_1.lend(pooledCreditLineID, lendAmount);

        // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
        minimumCollateralRequired = pooledCreditLineBorrower.getRequiredCollateral(pooledCreditLineID, lendAmount);

        // Transferring collateral tokens to the borrower
        collateralToDeposit = minimumCollateralRequired.mul(2);
        admin.transferToken(address(collateralAsset), address(pooledCreditLineBorrower), collateralToDeposit);
        pooledCreditLineBorrower.setAllowance(address(pooledCreditLine), address(collateralAsset), type(uint256).max);

        // Since borrow can only be done after the collection period,
        vm.warp(block.timestamp + request.collectionPeriod);

        // We want to deposit collateral now
        pooledCreditLineBorrower.depositCollateral(pooledCreditLineID, collateralToDeposit, false);

        // Calculating the borrowable amount:
        borrowableAmount = pooledCreditLineBorrower.calculateBorrowableAmount(pooledCreditLineID);
        amountToBorrow = borrowableAmount.div(4);

        //Trying to borrow the borrowable amount:
        pooledCreditLineBorrower.borrow(pooledCreditLineID, amountToBorrow);

        // Something went terribly wrong and noew we want to pause all interactions with the savings account.
        // Setting the new savings account address to address(0) doesn't work. This error is thrown:
        // Revert (""UpgradeableProxy: new implementation is not a contract""
        log_address(address(pausedContract));

        address pcl_savingsAccount_old = address(pooledCreditLine.SAVINGS_ACCOUNT());
        address savingsAccount_impl = proxyAdmin.getImplementationAddressOfProxy(sublimeProxyInstance);
        log_named_address('Old Savings Account', savingsAccount_impl);

        proxyAdmin.changeImplementationAddressOfProxy(address(sublimeProxyInstance), address(pausedContract));

        address pausedContractAddress = proxyAdmin.getImplementationAddressOfProxy(sublimeProxyInstance);
        log_named_address('Paused Contract Address', pausedContractAddress);
        address pcl_savingsAccount_new = address(pooledCreditLine.SAVINGS_ACCOUNT());

        // assert that the savings account address for the pcl should not change
        assertEq(pcl_savingsAccount_new, pcl_savingsAccount_old);

        // Assert that the implementation addresses of the savings account changed to a paused contract
        assertTrue(savingsAccount_impl != pausedContractAddress);

        // This call should break and testFail should succeed
        savingsAccount.getTotalTokens(address(pooledCreditLineBorrower), request.borrowAsset);
    }

    // Test20: Test the pause and upgrade functionality of price oracle as the admin
    function test_pauseAndUpgradePriceOracleContract() public {
        // Create your PCL request
        pooledCreditLineID = pooledCreditLineBorrower.createRequest(request);

        // The status of the PCL request should be in REQUESTED state
        status = pooledCreditLine.getStatusAndUpdate(pooledCreditLineID);
        assertTrue(status == PooledCreditLineStatus.REQUESTED);

        // Transferring borrow tokens to the lender, and then lender lends to the PCL
        lendAmount = request.borrowLimit;
        admin.transferToken(address(borrowAsset), address(pooledCreditLineLender_1), lendAmount);
        pooledCreditLineLender_1.setAllowance(address(lenderPool), address(borrowAsset), type(uint256).max);
        pooledCreditLineLender_1.lend(pooledCreditLineID, lendAmount);

        // The collection period gets over
        vm.warp(block.timestamp + request.collectionPeriod);

        // Borrower signs the required documents and then calls the start function
        pooledCreditLineBorrower.start(pooledCreditLineID);

        // Since the borrowLimit is met, the status should change to ACTIVE state
        status = pooledCreditLine.getStatusAndUpdate(pooledCreditLineID);
        assertTrue(status == PooledCreditLineStatus.ACTIVE);

        // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
        minimumCollateralRequired = pooledCreditLineBorrower.getRequiredCollateral(pooledCreditLineID, lendAmount);

        // Transferring collateral tokens to the borrower
        collateralToDeposit = minimumCollateralRequired.mul(2);
        admin.transferToken(address(collateralAsset), address(pooledCreditLineBorrower), collateralToDeposit);
        pooledCreditLineBorrower.setAllowance(address(pooledCreditLine), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        pooledCreditLineBorrower.depositCollateral(pooledCreditLineID, collateralToDeposit, false);

        // Since borrow can only be done after the collection period,
        vm.warp(block.timestamp + request.collectionPeriod);

        // Calculating the borrowable amount:
        borrowableAmount = pooledCreditLineBorrower.calculateBorrowableAmount(pooledCreditLineID);
        amountToBorrow = borrowableAmount.div(4);

        // Trying to borrow the a fourth of the borrowable amount:
        pooledCreditLineBorrower.borrow(pooledCreditLineID, amountToBorrow);

        // Finding out whether the feed exist (in the current price oracle implementation)
        bool doesFeedExistInitial = priceOracle.doesFeedExist(address(request.borrowAsset), address(request.collateralAsset));
        // Something went terribly wrong and now we want to pause all interactions with the price oracle.
        // Setting the new price oracle address to address(0) or 0xffff....ff doesn't work. This error is thrown:
        // Revert (""UpgradeableProxy: new implementation is not a contract"")
        log_address(address(pausedContract));

        address pcl_priceOracle_old = address(pooledCreditLine.PRICE_ORACLE());
        address priceOracle_impl = proxyAdmin.getImplementationAddressOfProxy(priceOracleProxyInstance);
        log_named_address('Old Price Oracle', priceOracle_impl);

        proxyAdmin.changeImplementationAddressOfProxy(address(priceOracleProxyInstance), address(pausedContract));

        address pausedContractAddress = proxyAdmin.getImplementationAddressOfProxy(priceOracleProxyInstance);
        log_named_address('Paused Contract Address', pausedContractAddress);
        address pcl_priceOracle_new = address(pooledCreditLine.PRICE_ORACLE());

        // assert that the price oracle address for the pcl should not change
        assertEq(pcl_priceOracle_new, pcl_priceOracle_old);

        // Assert that the implementation addresses of the price oracle changed to a paused contract
        assertTrue(priceOracle_impl != pausedContractAddress);

        // Now that the priceOracle is paused, let's change the proxyImplementation to a patched priceOracle
        PriceOracle patchedPriceOracle = new PriceOracle(type(uint128).max);
        proxyAdmin.changeImplementationAddressOfProxy(address(priceOracleProxyInstance), address(patchedPriceOracle));

        // Now comparing the address of the patchedPriceOracle with pausedContract
        address patchedPriceOracleAddress = proxyAdmin.getImplementationAddressOfProxy(priceOracleProxyInstance);
        log_named_address('New Price Oracle', patchedPriceOracleAddress);

        bool doesFeedExistFinal = priceOracle.doesFeedExist(address(request.borrowAsset), address(request.collateralAsset));

        assertTrue(patchedPriceOracleAddress != pausedContractAddress);
        assertTrue(doesFeedExistFinal == doesFeedExistInitial);
    }

    // Test21: Test the pause functionality of price oracle as the admin
    function testFail_stopPriceOracleInteraction() public {
        // Create your PCL request
        pooledCreditLineID = pooledCreditLineBorrower.createRequest(request);

        // The status of the PCL request should be in REQUESTED state
        status = pooledCreditLine.getStatusAndUpdate(pooledCreditLineID);
        assertTrue(status == PooledCreditLineStatus.REQUESTED);

        // Transferring borrow tokens to the lender, and then lender lends to the PCL
        lendAmount = request.borrowLimit;
        admin.transferToken(address(borrowAsset), address(pooledCreditLineLender_1), lendAmount);
        pooledCreditLineLender_1.setAllowance(address(lenderPool), address(borrowAsset), type(uint256).max);
        pooledCreditLineLender_1.lend(pooledCreditLineID, lendAmount);

        // The collection period gets over
        vm.warp(block.timestamp + request.collectionPeriod);

        // Borrower signs the required documents and then calls the start function
        pooledCreditLineBorrower.start(pooledCreditLineID);

        // Since the borrowLimit is met, the status should change to ACTIVE state
        status = pooledCreditLine.getStatusAndUpdate(pooledCreditLineID);
        assertTrue(status == PooledCreditLineStatus.ACTIVE);

        // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
        minimumCollateralRequired = pooledCreditLineBorrower.getRequiredCollateral(pooledCreditLineID, lendAmount);

        // Transferring collateral tokens to the borrower
        collateralToDeposit = minimumCollateralRequired.mul(2);
        admin.transferToken(address(collateralAsset), address(pooledCreditLineBorrower), collateralToDeposit);
        pooledCreditLineBorrower.setAllowance(address(pooledCreditLine), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        pooledCreditLineBorrower.depositCollateral(pooledCreditLineID, collateralToDeposit, false);

        // Since borrow can only be done after the collection period,
        vm.warp(block.timestamp + request.collectionPeriod);

        // Calculating the borrowable amount:
        borrowableAmount = pooledCreditLineBorrower.calculateBorrowableAmount(pooledCreditLineID);
        amountToBorrow = borrowableAmount.div(4);

        // Trying to borrow the a fourth of the borrowable amount:
        pooledCreditLineBorrower.borrow(pooledCreditLineID, amountToBorrow);

        // Finding out whether the feed exist (in the current price oracle implementation)
        bool doesFeedExistInitial = priceOracle.doesFeedExist(address(request.borrowAsset), address(request.collateralAsset));
        assertTrue(doesFeedExistInitial);

        // Something went terribly wrong and now we want to pause all interactions with the price oracle.
        // Setting the new price oracle address to address(0) or 0xffff....ff doesn't work. This error is thrown:
        // Revert (""UpgradeableProxy: new implementation is not a contract"")
        log_address(address(pausedContract));

        address pcl_priceOracle_old = address(pooledCreditLine.PRICE_ORACLE());
        address priceOracle_impl = proxyAdmin.getImplementationAddressOfProxy(priceOracleProxyInstance);
        log_named_address('Old Price Oracle', priceOracle_impl);

        proxyAdmin.changeImplementationAddressOfProxy(address(priceOracleProxyInstance), address(pausedContract));

        address pausedContractAddress = proxyAdmin.getImplementationAddressOfProxy(priceOracleProxyInstance);
        log_named_address('Paused Contract Address', pausedContractAddress);
        address pcl_priceOracle_new = address(pooledCreditLine.PRICE_ORACLE());

        // assert that the price oracle address for the pcl should not change
        assertEq(pcl_priceOracle_new, pcl_priceOracle_old);

        // Assert that the implementation addresses of the price oracle changed to a paused contract
        assertTrue(priceOracle_impl != pausedContractAddress);

        // Now that the price oracle contract is essentially paused, we should not be able to call priceOracle functions
        // This call should fail
        bool doesFeedExistFinal = priceOracle.doesFeedExist(address(request.borrowAsset), address(request.collateralAsset));
    }

    // Test22: Test the pause and upgrade functionality of Strategy Registry
    function test_pauseAndUpgradeStrategyRegistryContract() public {
        // Create your PCL request
        pooledCreditLineID = pooledCreditLineBorrower.createRequest(request);

        // The status of the PCL request should be in REQUESTED state
        status = pooledCreditLine.getStatusAndUpdate(pooledCreditLineID);
        assertTrue(status == PooledCreditLineStatus.REQUESTED);

        // Transferring borrow tokens to the lender, and then lender lends to the PCL
        lendAmount = request.borrowLimit;
        admin.transferToken(address(borrowAsset), address(pooledCreditLineLender_1), lendAmount);
        pooledCreditLineLender_1.setAllowance(address(lenderPool), address(borrowAsset), type(uint256).max);
        pooledCreditLineLender_1.lend(pooledCreditLineID, lendAmount);

        // The collection period gets over
        vm.warp(block.timestamp + request.collectionPeriod);

        // Borrower signs the required documents and then calls the start function
        pooledCreditLineBorrower.start(pooledCreditLineID);

        // Since the borrowLimit is met, the status should change to ACTIVE state
        status = pooledCreditLine.getStatusAndUpdate(pooledCreditLineID);
        assertTrue(status == PooledCreditLineStatus.ACTIVE);

        // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
        minimumCollateralRequired = pooledCreditLineBorrower.getRequiredCollateral(pooledCreditLineID, lendAmount);

        // Transferring collateral tokens to the borrower
        collateralToDeposit = minimumCollateralRequired.mul(2);
        admin.transferToken(address(collateralAsset), address(pooledCreditLineBorrower), collateralToDeposit);
        pooledCreditLineBorrower.setAllowance(address(pooledCreditLine), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        pooledCreditLineBorrower.depositCollateral(pooledCreditLineID, collateralToDeposit, false);

        // Since borrow can only be done after the collection period,
        vm.warp(block.timestamp + request.collectionPeriod);

        // Calculating the borrowable amount:
        borrowableAmount = pooledCreditLineBorrower.calculateBorrowableAmount(pooledCreditLineID);
        amountToBorrow = borrowableAmount.div(4);

        // Trying to borrow the a fourth of the borrowable amount:
        pooledCreditLineBorrower.borrow(pooledCreditLineID, amountToBorrow);

        // Finding the number of strategies in the strategy registry
        address[] memory strategyList = strategyRegistry.getStrategies();
        uint256 noOfStrategies = strategyList.length;

        // The number of strategies should be 2 (Compound Yield and No Yield)
        assertEq(noOfStrategies, 2);

        // Something went terribly wrong and now we want to pause all interactions with the strategy registry.
        // Setting the new strategy registry address to address(0) or 0xffff....ff doesn't work. This error is thrown:
        // Revert (""UpgradeableProxy: new implementation is not a contract"")
        address pcl_strategyRegistry_old = address(pooledCreditLine.STRATEGY_REGISTRY());
        address strategyRegistry_impl = proxyAdmin.getImplementationAddressOfProxy(strategyRegistryProxyInstance);

        // Changing the implementation contract for the strategy registry proxy
        proxyAdmin.changeImplementationAddressOfProxy(address(strategyRegistryProxyInstance), address(pausedContract));

        // Now the implementation contract has been changed to the Paused contract
        address pausedContractAddress = proxyAdmin.getImplementationAddressOfProxy(strategyRegistryProxyInstance);
        address pcl_strategyRegistry_new = address(pooledCreditLine.STRATEGY_REGISTRY());

        // assert that the strategy registry address for the pcl should not change
        assertEq(pcl_strategyRegistry_new, pcl_strategyRegistry_old);

        // Assert that the implementation addresses of the strategy registry changed to a paused contract
        assertTrue(strategyRegistry_impl != pausedContractAddress);

        // Now that the strategyRegistry is paused, let's change the proxyImplementation to a patched strategyRegistry
        StrategyRegistry patchedStrategyRegistry = new StrategyRegistry();
        proxyAdmin.changeImplementationAddressOfProxy(address(strategyRegistryProxyInstance), address(patchedStrategyRegistry));

        // Now comparing the address of the patchedStrategyRegistry with pausedContract
        address patchedStrategyRegistryAddress = proxyAdmin.getImplementationAddressOfProxy(strategyRegistryProxyInstance);

        // Checking whether the state of the StrategyRegistry contract was maintained after the upgrade or not
        strategyList = strategyRegistry.getStrategies();
        uint256 noOfStrategiesFinal = strategyList.length;

        assertTrue(patchedStrategyRegistryAddress != pausedContractAddress); // This asserts that the implementation contract did change
        assertTrue(noOfStrategiesFinal == noOfStrategies);
    }

    // Test23: Test the pause functionality of Strategy Registry as the admin
    function testFail_stopStrategyRegistryContract() public {
        // Create your PCL request
        pooledCreditLineID = pooledCreditLineBorrower.createRequest(request);

        // The status of the PCL request should be in REQUESTED state
        status = pooledCreditLine.getStatusAndUpdate(pooledCreditLineID);
        assertTrue(status == PooledCreditLineStatus.REQUESTED);

        // Transferring borrow tokens to the lender, and then lender lends to the PCL
        lendAmount = request.borrowLimit;
        admin.transferToken(address(borrowAsset), address(pooledCreditLineLender_1), lendAmount);
        pooledCreditLineLender_1.setAllowance(address(lenderPool), address(borrowAsset), type(uint256).max);
        pooledCreditLineLender_1.lend(pooledCreditLineID, lendAmount);

        // The collection period gets over
        vm.warp(block.timestamp + request.collectionPeriod);

        // Borrower signs the required documents and then calls the start function
        pooledCreditLineBorrower.start(pooledCreditLineID);

        // Since the borrowLimit is met, the status should change to ACTIVE state
        status = pooledCreditLine.getStatusAndUpdate(pooledCreditLineID);
        assertTrue(status == PooledCreditLineStatus.ACTIVE);

        // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
        minimumCollateralRequired = pooledCreditLineBorrower.getRequiredCollateral(pooledCreditLineID, lendAmount);

        // Transferring collateral tokens to the borrower
        collateralToDeposit = minimumCollateralRequired.mul(2);
        admin.transferToken(address(collateralAsset), address(pooledCreditLineBorrower), collateralToDeposit);
        pooledCreditLineBorrower.setAllowance(address(pooledCreditLine), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        pooledCreditLineBorrower.depositCollateral(pooledCreditLineID, collateralToDeposit, false);

        // Since borrow can only be done after the collection period,
        vm.warp(block.timestamp + request.collectionPeriod);

        // Calculating the borrowable amount:
        borrowableAmount = pooledCreditLineBorrower.calculateBorrowableAmount(pooledCreditLineID);
        amountToBorrow = borrowableAmount.div(4);

        // Trying to borrow the a fourth of the borrowable amount:
        pooledCreditLineBorrower.borrow(pooledCreditLineID, amountToBorrow);

        // Finding the number of strategies in the strategy registry
        address[] memory strategyList = strategyRegistry.getStrategies();
        uint256 noOfStrategies = strategyList.length;

        // The number of strategies should be 2 (Compound Yield and No Yield)
        assertEq(noOfStrategies, 2);

        // Something went terribly wrong and now we want to pause all interactions with the strategy registry.
        // Setting the new strategy registry address to address(0) or 0xffff....ff doesn't work. This error is thrown:
        // Revert (""UpgradeableProxy: new implementation is not a contract"")
        address pcl_strategyRegistry_old = address(pooledCreditLine.STRATEGY_REGISTRY());
        address strategyRegistry_impl = proxyAdmin.getImplementationAddressOfProxy(strategyRegistryProxyInstance);

        // Changing the implementation contract for the strategy registry proxy
        proxyAdmin.changeImplementationAddressOfProxy(address(strategyRegistryProxyInstance), address(pausedContract));

        // Now the implementation contract has been changed to the Paused contract
        address pausedContractAddress = proxyAdmin.getImplementationAddressOfProxy(strategyRegistryProxyInstance);
        address pcl_strategyRegistry_new = address(pooledCreditLine.STRATEGY_REGISTRY());

        // assert that the strategy registry address for the pcl should not change
        assertEq(pcl_strategyRegistry_new, pcl_strategyRegistry_old);

        // Assert that the implementation addresses of the strategy registry changed to a paused contract
        assertTrue(strategyRegistry_impl != pausedContractAddress);

        // Checking whether the state of the StrategyRegistry contract was maintained after the upgrade or not
        // This call should break (since we cannot call these functions from the Paused contract)
        strategyList = strategyRegistry.getStrategies();
    }

    // Test24: Test the pause and upgrade functionality of Compound Yield Contract
    function test_pauseAndUpgradeCompoundYieldContract() public {
        // Create the request
        pooledCreditLineID = pooledCreditLineBorrower.createRequest(request);

        // The status of the PCL request should be in REQUESTED state
        status = pooledCreditLine.getStatusAndUpdate(pooledCreditLineID);
        assertTrue(status == PooledCreditLineStatus.REQUESTED);

        // Transferring borrow tokens to the lender, and then lender lends to the PCL
        lendAmount = request.borrowLimit;
        admin.transferToken(address(borrowAsset), address(pooledCreditLineLender_1), lendAmount);
        pooledCreditLineLender_1.setAllowance(address(lenderPool), address(borrowAsset), type(uint256).max);
        pooledCreditLineLender_1.lend(pooledCreditLineID, lendAmount);

        // The collection period gets over
        vm.warp(block.timestamp + request.collectionPeriod);

        // Borrower signs the required documents and then calls the start function
        pooledCreditLineBorrower.start(pooledCreditLineID);

        // Since the borrowLimit is met, the status should change to ACTIVE state
        status = pooledCreditLine.getStatusAndUpdate(pooledCreditLineID);
        assertTrue(status == PooledCreditLineStatus.ACTIVE);

        // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
        minimumCollateralRequired = pooledCreditLineBorrower.getRequiredCollateral(pooledCreditLineID, lendAmount);

        // Transferring collateral tokens to the borrower
        collateralToDeposit = minimumCollateralRequired.mul(2);
        admin.transferToken(address(collateralAsset), address(pooledCreditLineBorrower), collateralToDeposit);
        pooledCreditLineBorrower.setAllowance(address(pooledCreditLine), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        pooledCreditLineBorrower.depositCollateral(pooledCreditLineID, collateralToDeposit, false);

        // Since borrow can only be done after the collection period,
        vm.warp(block.timestamp + request.collectionPeriod);

        // Calculating the borrowable amount:
        borrowableAmount = pooledCreditLineBorrower.calculateBorrowableAmount(pooledCreditLineID);
        amountToBorrow = borrowableAmount.div(4);

        // Trying to borrow the a fourth of the borrowable amount:
        pooledCreditLineBorrower.borrow(pooledCreditLineID, amountToBorrow);

        uint256 balanceInShares = savingsAccount.balanceInShares(
            address(pooledCreditLine),
            address(request.collateralAsset),
            address(compoundYield)
        );
        assertTrue(balanceInShares > 0);
        uint256 depositLimit = compoundYield.depositLimit(request.collateralAsset);

        // Some bug is discovered in the NoYield contract and we want to pause all interactions with the NoYield contract now.
        address compoundYieldAddressInPCL = strategyRegistry.getStrategies()[1];
        address compoundYieldImplementation = proxyAdmin.getImplementationAddressOfProxy(compoundYieldProxyInstance);

        proxyAdmin.changeImplementationAddressOfProxy(address(compoundYieldProxyInstance), address(pausedContract));

        // The implementation contract has changed but the proxy address should remain the same for PCL
        address compoundYieldAddressInPCLWhenPaused = strategyRegistry.getStrategies()[1];
        address compoundYieldImplementationWhenPaused = proxyAdmin.getImplementationAddressOfProxy(compoundYieldProxyInstance);

        assertTrue(compoundYieldAddressInPCL == compoundYieldAddressInPCLWhenPaused);
        assertTrue(compoundYieldImplementation != compoundYieldImplementationWhenPaused);

        // Now we assume that we patched the CompoundYield contract
        CompoundYield patchedCompoundYield = new CompoundYield(address(WETH), Constants._treasuryAddress, address(savingsAccount));
        proxyAdmin.changeImplementationAddressOfProxy(address(compoundYieldProxyInstance), address(patchedCompoundYield));

        // Let's see if the implementation address changed or not
        address compoundYieldImplementationPatched = proxyAdmin.getImplementationAddressOfProxy(compoundYieldProxyInstance);

        assertTrue(compoundYieldImplementationWhenPaused != compoundYieldImplementationPatched);
        assertTrue(compoundYieldImplementation != compoundYieldImplementationPatched);

        address compoundYieldAddressInPCLPatched = strategyRegistry.getStrategies()[1];
        assertTrue(compoundYieldAddressInPCLWhenPaused == compoundYieldAddressInPCLPatched);

        // Let us see if the state was maintained or not
        uint256 balanceInSharesFinal = savingsAccount.balanceInShares(
            address(pooledCreditLine),
            address(request.collateralAsset),
            address(compoundYield)
        );
        assertTrue(balanceInShares == balanceInSharesFinal);
        uint256 depositLimitFinal = compoundYield.depositLimit(request.collateralAsset);
        assertTrue(depositLimit == depositLimitFinal);
    }

    // Test24: Test the pause functionality of Compound Yield Contract. No interaction is possible with Compound yield contract.
    function testFail_pauseCompoundYieldContract() public {
        // Create the request
        pooledCreditLineID = pooledCreditLineBorrower.createRequest(request);

        // The status of the PCL request should be in REQUESTED state
        status = pooledCreditLine.getStatusAndUpdate(pooledCreditLineID);
        assertTrue(status == PooledCreditLineStatus.REQUESTED);

        // Transferring borrow tokens to the lender, and then lender lends to the PCL
        lendAmount = request.borrowLimit;
        admin.transferToken(address(borrowAsset), address(pooledCreditLineLender_1), lendAmount);
        pooledCreditLineLender_1.setAllowance(address(lenderPool), address(borrowAsset), type(uint256).max);
        pooledCreditLineLender_1.lend(pooledCreditLineID, lendAmount);

        // The collection period gets over
        vm.warp(block.timestamp + request.collectionPeriod);

        // Borrower signs the required documents and then calls the start function
        pooledCreditLineBorrower.start(pooledCreditLineID);

        // Since the borrowLimit is met, the status should change to ACTIVE state
        status = pooledCreditLine.getStatusAndUpdate(pooledCreditLineID);
        assertTrue(status == PooledCreditLineStatus.ACTIVE);

        // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
        minimumCollateralRequired = pooledCreditLineBorrower.getRequiredCollateral(pooledCreditLineID, lendAmount);

        // Transferring collateral tokens to the borrower
        collateralToDeposit = minimumCollateralRequired.mul(2);
        admin.transferToken(address(collateralAsset), address(pooledCreditLineBorrower), collateralToDeposit);
        pooledCreditLineBorrower.setAllowance(address(pooledCreditLine), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        pooledCreditLineBorrower.depositCollateral(pooledCreditLineID, collateralToDeposit, false);

        // Since borrow can only be done after the collection period,
        vm.warp(block.timestamp + request.collectionPeriod);

        // Calculating the borrowable amount:
        borrowableAmount = pooledCreditLineBorrower.calculateBorrowableAmount(pooledCreditLineID);
        amountToBorrow = borrowableAmount.div(4);

        // Trying to borrow the a fourth of the borrowable amount:
        pooledCreditLineBorrower.borrow(pooledCreditLineID, amountToBorrow);

        uint256 balanceInShares = savingsAccount.balanceInShares(
            address(pooledCreditLine),
            address(request.collateralAsset),
            address(compoundYield)
        );
        assertTrue(balanceInShares > 0);
        uint256 depositLimit = compoundYield.depositLimit(request.collateralAsset);

        // Some bug is discovered in the NoYield contract and we want to pause all interactions with the NoYield contract now.
        address compoundYieldAddressInPCL = strategyRegistry.getStrategies()[1];
        address compoundYieldImplementation = proxyAdmin.getImplementationAddressOfProxy(compoundYieldProxyInstance);

        proxyAdmin.changeImplementationAddressOfProxy(address(compoundYieldProxyInstance), address(pausedContract));

        // The implementation contract has changed but the proxy address should remain the same for PCL
        address compoundYieldAddressInPCLWhenPaused = strategyRegistry.getStrategies()[1];
        address compoundYieldImplementationWhenPaused = proxyAdmin.getImplementationAddressOfProxy(compoundYieldProxyInstance);

        assertTrue(compoundYieldAddressInPCL == compoundYieldAddressInPCLWhenPaused);
        assertTrue(compoundYieldImplementation != compoundYieldImplementationWhenPaused);

        uint256 depositLimitFinal = compoundYield.depositLimit(request.collateralAsset);
    }

    // Test25: Pause and upgrade the PooledCreditLine contract
    function test_pauseAndUpgradePCLContract() public {
        // Create the request
        pooledCreditLineID = pooledCreditLineBorrower.createRequest(request);

        // The status of the PCL request should be in REQUESTED state
        status = pooledCreditLine.getStatusAndUpdate(pooledCreditLineID);
        assertTrue(status == PooledCreditLineStatus.REQUESTED);

        // Transferring borrow tokens to the lender, and then lender lends to the PCL
        lendAmount = request.borrowLimit;
        admin.transferToken(address(borrowAsset), address(pooledCreditLineLender_1), lendAmount);
        pooledCreditLineLender_1.setAllowance(address(lenderPool), address(borrowAsset), type(uint256).max);
        pooledCreditLineLender_1.lend(pooledCreditLineID, lendAmount);

        // The collection period gets over
        vm.warp(block.timestamp + request.collectionPeriod);

        // Borrower signs the required documents and then calls the start function
        pooledCreditLineBorrower.start(pooledCreditLineID);

        // Since the borrowLimit is met, the status should change to ACTIVE state
        status = pooledCreditLine.getStatusAndUpdate(pooledCreditLineID);
        assertTrue(status == PooledCreditLineStatus.ACTIVE);

        // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
        minimumCollateralRequired = pooledCreditLineBorrower.getRequiredCollateral(pooledCreditLineID, lendAmount);

        // Transferring collateral tokens to the borrower
        collateralToDeposit = minimumCollateralRequired.mul(2);
        admin.transferToken(address(collateralAsset), address(pooledCreditLineBorrower), collateralToDeposit);
        pooledCreditLineBorrower.setAllowance(address(pooledCreditLine), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        pooledCreditLineBorrower.depositCollateral(pooledCreditLineID, collateralToDeposit, false);

        // Since borrow can only be done after the collection period,
        vm.warp(block.timestamp + request.collectionPeriod);

        // Calculating the borrowable amount:
        borrowableAmount = pooledCreditLineBorrower.calculateBorrowableAmount(pooledCreditLineID);
        amountToBorrow = borrowableAmount.div(4);

        // Trying to borrow the a fourth of the borrowable amount:
        pooledCreditLineBorrower.borrow(pooledCreditLineID, amountToBorrow);

        // Checking the state with the current implementation
        uint256 protocolFeeFractionCurrent = pooledCreditLine.protocolFeeFraction();
        uint256 depositedCollateralCurrent = pooledCreditLine.depositedCollateralInShares(pooledCreditLineID);

        // Some bug is discovered in the PCL contract and we want to pause all interactions with the PCL contract now
        address pclAddressCurrent = address(pooledCreditLine);
        address pclImplementationCurrent = proxyAdmin.getImplementationAddressOfProxy(pooledCreditLineProxyInstance);

        proxyAdmin.changeImplementationAddressOfProxy(address(pooledCreditLineProxyInstance), address(pausedContract));

        // The implementation contract has changed but the proxy address itself should remain the same
        address pclAddressPaused = address(pooledCreditLine);
        address pclImplementationPaused = proxyAdmin.getImplementationAddressOfProxy(pooledCreditLineProxyInstance);

        assertTrue(pclAddressCurrent == pclAddressPaused);
        assertTrue(pclImplementationCurrent != pclImplementationPaused);

        // Now we assume we patched the PCL contract
        PooledCreditLine patchedPCL = new PooledCreditLine(
            address(lenderPool),
            address(USDC),
            address(priceOracle),
            address(savingsAccount),
            address(strategyRegistry),
            address(verification),
            1e18 / 10
        );
        proxyAdmin.changeImplementationAddressOfProxy(address(pooledCreditLineProxyInstance), address(patchedPCL));

        // Let's see if the implementation address changed or not
        address pclImplementationPatched = proxyAdmin.getImplementationAddressOfProxy(pooledCreditLineProxyInstance);
        address pclAddressPatched = address(pooledCreditLine);

        assertTrue(pclImplementationPaused != pclImplementationPatched);
        assertTrue(pclImplementationCurrent != pclImplementationPatched);
        assertTrue(pclAddressPaused == pclAddressPatched);

        // Checking the state with the patched implementation
        uint256 protocolFeeFractionPatched = pooledCreditLine.protocolFeeFraction();
        uint256 depositedCollateralPatched = pooledCreditLine.depositedCollateralInShares(pooledCreditLineID);

        assertTrue(protocolFeeFractionPatched == protocolFeeFractionCurrent);
        assertTrue(depositedCollateralPatched == depositedCollateralCurrent);
    }

    // Test26: No interaction with the PCL is possible when the contract is paused
    function testFail_stopPCLContract() public {
        // Create the request
        pooledCreditLineID = pooledCreditLineBorrower.createRequest(request);

        // The status of the PCL request should be in REQUESTED state
        status = pooledCreditLine.getStatusAndUpdate(pooledCreditLineID);
        assertTrue(status == PooledCreditLineStatus.REQUESTED);

        // Transferring borrow tokens to the lender, and then lender lends to the PCL
        lendAmount = request.borrowLimit;
        admin.transferToken(address(borrowAsset), address(pooledCreditLineLender_1), lendAmount);
        pooledCreditLineLender_1.setAllowance(address(lenderPool), address(borrowAsset), type(uint256).max);
        pooledCreditLineLender_1.lend(pooledCreditLineID, lendAmount);

        // The collection period gets over
        vm.warp(block.timestamp + request.collectionPeriod);

        // Borrower signs the required documents and then calls the start function
        pooledCreditLineBorrower.start(pooledCreditLineID);

        // Since the borrowLimit is met, the status should change to ACTIVE state
        status = pooledCreditLine.getStatusAndUpdate(pooledCreditLineID);
        assertTrue(status == PooledCreditLineStatus.ACTIVE);

        // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
        minimumCollateralRequired = pooledCreditLineBorrower.getRequiredCollateral(pooledCreditLineID, lendAmount);

        // Transferring collateral tokens to the borrower
        collateralToDeposit = minimumCollateralRequired.mul(2);
        admin.transferToken(address(collateralAsset), address(pooledCreditLineBorrower), collateralToDeposit);
        pooledCreditLineBorrower.setAllowance(address(pooledCreditLine), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        pooledCreditLineBorrower.depositCollateral(pooledCreditLineID, collateralToDeposit, false);

        // Checking the state with the current implementation
        uint256 protocolFeeFractionCurrent = pooledCreditLine.protocolFeeFraction();
        uint256 depositedCollateralCurrent = pooledCreditLine.depositedCollateralInShares(pooledCreditLineID);

        // Some bug is discovered in the PCL contract and we want to pause all interactions with the PCL contract now
        address pclAddressCurrent = address(pooledCreditLine);
        address pclImplementationCurrent = proxyAdmin.getImplementationAddressOfProxy(pooledCreditLineProxyInstance);

        proxyAdmin.changeImplementationAddressOfProxy(address(pooledCreditLineProxyInstance), address(pausedContract));

        // The implementation contract has changed but the proxy address itself should remain the same
        address pclAddressPaused = address(pooledCreditLine);
        address pclImplementationPaused = proxyAdmin.getImplementationAddressOfProxy(pooledCreditLineProxyInstance);

        assertTrue(pclAddressCurrent == pclAddressPaused);
        assertTrue(pclImplementationCurrent != pclImplementationPaused);

        uint256 protocolFeeFractionPatched = pooledCreditLine.protocolFeeFraction();
        uint256 depositedCollateralPatched = pooledCreditLine.depositedCollateralInShares(pooledCreditLineID);

        assertTrue(protocolFeeFractionPatched == protocolFeeFractionCurrent);
        assertTrue(depositedCollateralPatched == depositedCollateralCurrent);
    }

    // Test27: Pause and upgrade the LenderPool contract
    function test_pauseAndUpgradeLPContract() public {
        // Create the request
        pooledCreditLineID = pooledCreditLineBorrower.createRequest(request);

        // The status of the PCL request should be in REQUESTED state
        status = pooledCreditLine.getStatusAndUpdate(pooledCreditLineID);
        assertTrue(status == PooledCreditLineStatus.REQUESTED);

        // Transferring borrow tokens to the lender, and then lender lends (half of the borrowLimit) to the PCL
        lendAmount = request.borrowLimit;
        admin.transferToken(address(borrowAsset), address(pooledCreditLineLender_1), lendAmount);
        pooledCreditLineLender_1.setAllowance(address(lenderPool), address(borrowAsset), type(uint256).max);
        pooledCreditLineLender_1.lend(pooledCreditLineID, lendAmount / 2);

        // Since the borrowLimit is not met, the status should remain in REQUESTED state
        status = pooledCreditLine.getStatusAndUpdate(pooledCreditLineID);
        assertTrue(status == PooledCreditLineStatus.REQUESTED);

        uint256 totalSupplyCurrent = lenderPool.totalSupply(pooledCreditLineID);
        (, , , , uint256 collateralHeldCurrent) = lenderPool.pooledCLVariables(pooledCreditLineID);
        (uint256 startTimeCurrent, , , , , , , ) = lenderPool.pooledCLConstants(pooledCreditLineID);

        // Some bug is discovered in the LP contract and we want to pause all interactions with the LP contract now
        address lpAddressCurrent = address(lenderPool);
        address lpImplementationCurrent = proxyAdmin.getImplementationAddressOfProxy(lenderPoolProxyInstance);

        proxyAdmin.changeImplementationAddressOfProxy(address(lenderPoolProxyInstance), address(pausedContract));

        // The implementation contract has changed but the proxy address itself should remain the same
        address lpAddressPaused = address(lenderPool);
        address lpImplementationPaused = proxyAdmin.getImplementationAddressOfProxy(lenderPoolProxyInstance);

        assertTrue(lpAddressCurrent == lpAddressPaused);
        assertTrue(lpImplementationCurrent != lpImplementationPaused);

        // Now we assume we patched the LP contract
        LenderPool patchedLP = new LenderPool(address(pooledCreditLine), address(savingsAccount), address(verification));
        proxyAdmin.changeImplementationAddressOfProxy(address(lenderPoolProxyInstance), address(patchedLP));

        // Let's see if the implementation address changed or not
        address lpImplementationPatched = proxyAdmin.getImplementationAddressOfProxy(lenderPoolProxyInstance);
        address lpAddressPatched = address(lenderPool);

        assertTrue(lpImplementationPaused != lpImplementationPatched);
        assertTrue(lpImplementationCurrent != lpImplementationPatched);
        assertTrue(lpAddressPaused == lpAddressPatched);

        // Checking the state with the patched implementation
        uint256 totalSupplyPatched = lenderPool.totalSupply(pooledCreditLineID);
        (, , , , uint256 collateralHeldPatched) = lenderPool.pooledCLVariables(pooledCreditLineID);
        (uint256 startTimePatched, , , , , , , ) = lenderPool.pooledCLConstants(pooledCreditLineID);

        assertTrue(totalSupplyCurrent == totalSupplyPatched);
        assertTrue(collateralHeldCurrent == collateralHeldPatched);
        assertTrue(startTimeCurrent == startTimePatched);
    }

    // Test28: No interaction with the LP is possible when the contract is paused
    function testFail_stopLPContracts() public {
        // Create the request
        pooledCreditLineID = pooledCreditLineBorrower.createRequest(request);

        // The status of the PCL request should be in REQUESTED state
        status = pooledCreditLine.getStatusAndUpdate(pooledCreditLineID);
        assertTrue(status == PooledCreditLineStatus.REQUESTED);

        // Transferring borrow tokens to the lender, and then lender lends (half of the borrowLimit) to the PCL
        lendAmount = request.borrowLimit;
        admin.transferToken(address(borrowAsset), address(pooledCreditLineLender_1), lendAmount);
        pooledCreditLineLender_1.setAllowance(address(lenderPool), address(borrowAsset), type(uint256).max);
        pooledCreditLineLender_1.lend(pooledCreditLineID, lendAmount / 2);

        // Since the borrowLimit is not met, the status should remain in REQUESTED state
        status = pooledCreditLine.getStatusAndUpdate(pooledCreditLineID);
        assertTrue(status == PooledCreditLineStatus.REQUESTED);

        // Calling these functions from the correct implementation contract of the LenderPool to see if they are working or not
        uint256 totalSupplyCurrent = lenderPool.totalSupply(pooledCreditLineID);
        (, , , , uint256 collateralHeldCurrent) = lenderPool.pooledCLVariables(pooledCreditLineID);
        (uint256 startTimeCurrent, , , , , , , ) = lenderPool.pooledCLConstants(pooledCreditLineID);

        // Some bug is discovered in the LP contract and we want to pause all interactions with the LP contract now
        address lpAddressCurrent = address(lenderPool);
        address lpImplementationCurrent = proxyAdmin.getImplementationAddressOfProxy(lenderPoolProxyInstance);

        proxyAdmin.changeImplementationAddressOfProxy(address(lenderPoolProxyInstance), address(pausedContract));

        // The implementation contract has changed but the proxy address itself should remain the same
        address lpAddressPaused = address(lenderPool);
        address lpImplementationPaused = proxyAdmin.getImplementationAddressOfProxy(lenderPoolProxyInstance);

        assertTrue(lpAddressCurrent == lpAddressPaused);
        assertTrue(lpImplementationCurrent != lpImplementationPaused);

        // These calls should fail (since the implementation contract does not contain this function)
        pooledCreditLineLender_1.lend(pooledCreditLineID, lendAmount / 4);
    }
}",17904
RealWorld_BA_101_PCLClosedState.t_RealWord_20240827091418.log,101,PCLClosedState.t,98525,5471,103996,84.0,0.602045,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';

import '../Helpers/PCLParent.t.sol';

contract PCLClosedStateCToken is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 _borrowAssetDecimals;
    uint256 _collateralAssetDecimals;
    uint128 _collateralAssetPriceMin;
    uint128 _borrowAssetPriceMin;
    uint128 _collateralAssetPriceMax;
    uint128 _borrowAssetPriceMax;
    uint256 requestId;
    uint256 _fromUserPoolTokenSupply;
    uint256 _toUserPoolTokenSupply;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;
    uint256 _calculatedCurrentDebt;
    uint256 _fetchedCurrentDebt;

    address lender_0;

    function setUp() public override {
        super.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();
        _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));
        _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));

        _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();
        _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));
        _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 5000 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = compoundYieldAddress;
        request.collateralAssetStrategy = compoundYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);
        lender_0 = lenders[0].lenderAddress;

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);
        borrower.depositCollateral(requestId, _requiredCollateral, false);

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);
        // and borrows the borrowable amount
        borrower.borrow(requestId, borrowableAmount);

        // Borrower decides to repay everything at mid-duration

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 10);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay the entire debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt);
        borrower.repay(requestId, currentDebt);

        // Now the PCL should be in the CLOSED state
        borrower.close(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    // Test 0: Test SetUp
    function test_setUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed');

        uint256 _borrowCTokenExchangeRate = MockCToken(borrowCTokenAddress).exchangeRateCurrent();
        uint256 _collateralCTokenExchangeRate = MockCToken(collateralCTokenAddress).exchangeRateCurrent();

        // Checking out what are the exchange rates
        log_named_int('Borrow CToken Exchange Rate', int256(_borrowCTokenExchangeRate));
        log_named_int('Collateral CToken Exchange Rate', int256(_collateralCTokenExchangeRate));

        // Check the exchange rates of the borrow and collateral CTokens are non-zero
        assertGt(_borrowCTokenExchangeRate, 0);
        assertGt(_collateralCTokenExchangeRate, 0);
    }

    // Test 1: A closed PCL cannot be started even with exchange rate fluctuations
    function test_pclCannotBeStarted() public {
        helper_exchangeRateChanges();

        try borrower.start(requestId) {
            revert('Cannot start a closed PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S1');
        }
    }

    // Test 2: Collateral cannot be deposited
    function test_collateralCannotBeDeposited() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        helper_exchangeRateChanges();
        try borrower.depositCollateral(requestId, _minimumCollateralRequired, false) {
            revert('Collateral cannot be deposited');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:DC2');
        }
    }

    // Test 3: Withdrawable collateral remains zero
    function test_withdrawableCollateralIsZero() public {
        helper_exchangeRateChanges();
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);

        assertApproxEqAbs(_withdrawableCollateral, 0, 2);
    }

    // Test 4: Balance remains same after withdrawing collateral
    function test_balanceRemainsSameAfterWithdrawCollateral() public {
        helper_exchangeRateChanges();
        uint256 _borrowerBalanceBefore = collateralAsset.balanceOf(address(borrower));
        uint256 _tokens = (pcl.depositedCollateralInShares(requestId) * ICToken(collateralCTokenAddress).exchangeRateCurrent()) / 1e18;
        if (_tokens > 0) {
            borrower.withdrawCollateral(requestId, 1, false);
        } else {
            try borrower.withdrawCollateral(requestId, 1, false) {
                revert('Collateral cannot be withdrawn');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:WC1');
            }
        }
        uint256 _borrowerBalanceAfter = collateralAsset.balanceOf(address(borrower));
        assertApproxEqAbs(_borrowerBalanceAfter, _borrowerBalanceBefore, 2);
    }

    // Test 5: Balance remains same after withdrawing all collateral
    function test_balanceRemainsSameAfterWithdrawAllCollateral() public {
        helper_exchangeRateChanges();
        uint256 _borrowerBalanceBefore = collateralAsset.balanceOf(address(borrower));
        uint256 _tokens = (pcl.depositedCollateralInShares(requestId) * ICToken(collateralCTokenAddress).exchangeRateCurrent()) / 1e18;
        if (_tokens > 0) {
            borrower.withdrawAllCollateral(requestId, false);
        } else {
            try borrower.withdrawAllCollateral(requestId, false) {
                revert('All Collateral cannot be withdrawn');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:WAC1');
            }
        }
        uint256 _borrowerBalanceAfter = collateralAsset.balanceOf(address(borrower));
        assertApproxEqAbs(_borrowerBalanceAfter, _borrowerBalanceBefore, 2);
    }

    // Test 6: A closed PCL cannot be closed
    function test_pclCannotBeClosed() public {
        helper_exchangeRateChanges();

        try borrower.close(requestId) {
            revert('PCL cannot be closed');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C1');
        }
    }

    // Test 7: Required collateral remains same if collateral CToken exchange rate increases steeply
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.1: Required collateral remains same if borrow CToken exchange rate increases steeply
    function test_requiredCollateralRemainsSameIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.2: Required collateral remains same if borrow CToken exchange rate decreases to zero
    function test_requiredCollateralRemainSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.3: Required collateral remains same if collateral CToken exchange rate decreases to zero
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.4: Required collateral remains same if collateral CToken exchange rate increases very slowly
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 8: Collateral tokens remains zero if collateral CToken exchange rate increases steeply
    function test_totalCollateralTokensRemainsZeroIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);
        assertApproxEqAbs(_collateralTokens, 0, 2);
    }

    // Test 8.1: Collateral tokens may revert if collateral CToken exchange rate decreases to zero
    function test_totalCollateralTokensMayRevertIfCollateralCTokenExchangeRateDecreasesToZero() public {
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);

        uint256 _shares = pcl.depositedCollateralInShares(requestId);
        if (_shares > 0) {
            try pcl.calculateTotalCollateralTokens(requestId) {
                revert('Total collateral tokens should revert');
            } catch Error(string memory reason) {
                assertEq(reason, 'CY:GTFS1');
            }
        } else {
            uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);
            assertEq(_collateralTokens, 0);
        }
    }

    // Test 9: Collateral ratio remains infinite
    function test_collateralRatioIsInfinite() public {
        helper_exchangeRateChanges();
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);

        assertEq(_collateralRatio, type(uint256).max);
    }

    // Test 10: A Closed PCL cannot be cancelled
    function test_pclCannotBeCancelled() public {
        helper_exchangeRateChanges();

        try borrower.cancelRequest(requestId) {
            revert('PCL cannot be cancelled');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    // Test 11: Admin can terminate pcl
    function test_adminCanTerminatePCL() public {
        helper_exchangeRateChanges();

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        admin.terminate(requestId);
        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertGe((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0);
        assertGt(_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate, 0);
    }

    // Test 12: Borrowable amount remains zero
    function test_borrowableAmountIsZero() public {
        helper_exchangeRateChanges();

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        assertEq(_borrowableAmount, 0);
    }

    // Test 13: Borrower cannot repay
    function test_borrowerCannotRepay() public {
        helper_exchangeRateChanges();
        admin.transferToken(address(borrowAsset), address(borrower), 1);
        borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);
        try borrower.repay(requestId, 1) {
            revert('Borrower cannot repay');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:REP2');
        }
    }

    // Test 14: A requested PCL cannot be liquidated
    function test_lendersCannotLiquidate(bool _withdraw) public {
        helper_exchangeRateChanges();

        // lender_0 tries to liquidate the PCL
        try PCLUser(lender_0).liquidate(requestId, _withdraw) {
            revert('Cannot liquidate a closed PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L1');
        }
    }

    // Test 15: Lenders cannot withdraw liquidated collateral tokens
    function test_lendersCannotWithdrawLiquidation() public {
        helper_exchangeRateChanges();

        // lender_0 tries to withdraw the liquidated collateral tokens
        try PCLUser(lender_0).withdrawTokensAfterLiquidation(requestId) {
            revert('Cannot withdraw liquidation from a closed PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    // Test 16: Lenders can withdraw liquidity
    function test_lendersCanWithdrawLiquidity() public {
        helper_exchangeRateChanges();

        uint256 _userPoolTokenBalance = lp.balanceOf(lender_0, requestId);
        uint256 _userInterestOwed = lp.getLenderInterestWithdrawable(requestId, lender_0);

        uint256 _userBorrowTokenBalanceBefore = IERC20(request.borrowAsset).balanceOf(lender_0);
        PCLUser(lender_0).withdrawLiquidity(requestId);
        uint256 _userBorrowTokenBalanceAfter = IERC20(request.borrowAsset).balanceOf(lender_0);
        assertApproxEqRel(
            _userPoolTokenBalance + _userInterestOwed,
            _userBorrowTokenBalanceAfter - _userBorrowTokenBalanceBefore,
            0.0001e18
        );

        _userPoolTokenBalance = lp.balanceOf(lender_0, requestId);
        _userInterestOwed = lp.getLenderInterestWithdrawable(requestId, lender_0);
        assertEq(_userPoolTokenBalance, 0);
        assertEq(_userInterestOwed, 0);
    }

    // Test 17: Pool token transfers should be possible in a closed PCL
    function test_poolTokenTransfersShouldBePossibleEntireBalance() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, 0);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == 0);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));
    }

    // Test 17.1: Pool token transfers should be possible in a closed PCL
    function test_poolTokenTransfersShouldBePossiblePartialBalance() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 18: Interest can be withdrawn amidst price fluctuations
    function test_lendersCanWithdrawInterest() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender0Balance = borrowAsset.balanceOf(address(lender0));

        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender1Balance = borrowAsset.balanceOf(address(lender1));

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender0));
        uint256 lender1InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender1));

        lender0.withdrawInterest(requestId);

        uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(lender0));
        assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);

        helper_exchangeRateChanges();

        lender1.withdrawInterest(requestId);

        uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(lender1));
        assertGt((lender1BalanceFinal - lender1Balance), lender1InterestOwed);
    }

    // Test 18.1: Interest that can be withdrawn increases
    function test_lenderInterestIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender0));
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);

        uint256 lender0InterestOwedNew = lp.getLenderInterestWithdrawable(requestId, address(lender0));
        assertLt(lender0InterestOwed, lender0InterestOwedNew);
    }

    uint256 _principal;
    uint256 _currentCR1;
    uint256 _currentCR2;
    uint256 _currentCR3;
    uint256 _principalWithdrawable;
    uint256 _withdrawableCollateral;
    uint256 _currentDebt;
    uint256 _borrowable;
    uint256 _totalCollateral;
    uint256 _equivalentCollateral;
    uint256 _interestAccrued;

    uint256 collateralToDeposit;

    function assert_helperFunctionalitiesInClosedState(uint256 _id) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.CLOSED);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 1. calculateCurrentCollateralRatio
        _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);
        assertEq(_currentCR1, uint256(-1));

        helper_exchangeRateChanges();

        // 2. calculatePrincipalWithdrawable
        _principalWithdrawable = lp.calculatePrincipalWithdrawable(_id, address(_lender));
        assertEq(_principalWithdrawable, lp.balanceOf(address(_lender), requestId));

        helper_exchangeRateChanges();

        // 3. withdrawableCollateral
        _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertApproxEqAbs(_withdrawableCollateral, 0, 2);

        helper_exchangeRateChanges();

        // 4. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        assertEq(_currentDebt, 0);

        helper_exchangeRateChanges();

        // 5. calculateBorrowableAmount
        _borrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_borrowable, 0);

        helper_exchangeRateChanges();

        // 6. calculateTotalCollateralTokens
        _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertApproxEqAbs(_totalCollateral, 0, 2);

        helper_exchangeRateChanges();

        // 7. collateralTokensToLiquidate
        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
        assertGt(_equivalentCollateral, 0);

        helper_exchangeRateChanges();

        // 8. calculateInterestAccrued
        _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGt(_interestAccrued, 0);

        helper_exchangeRateChanges();
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.CLOSED);
    }

    function test_helperFunctionsInClosedState() public {
        assert_helperFunctionalitiesInClosedState(requestId);
    }
}",6095
RealWorld_BA_101_PCLActiveStateCompoundYield.t_RealWord_20240827103053.log,101,PCLActiveStateCompoundYield.t,12607,5384,17991,89.0,0.170715,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '../PCLActiveState.t.sol';
import '../../Helpers/PCLParent.t.sol';

contract PCLActiveStatePriceOracleCompoundYield is PCLActiveStatePriceOracle {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    function setUp() public override {
        PCLParent.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();
        _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));
        _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));

        _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();
        _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));
        _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = compoundYieldAddress;
        request.collateralAssetStrategy = compoundYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');
    }
}",533
RealWorld_BA_101_PCLParent.t_RealWord_20240827103724.log,101,PCLParent.t,97936,5414,103350,100.0,0.59796,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/utils/ReentrancyGuard.sol';
import '@openzeppelin/contracts-upgradeable/proxy/Initializable.sol';
import '@openzeppelin/contracts-upgradeable/token/ERC20/ERC20PausableUpgradeable.sol';
import '@openzeppelin/contracts/token/ERC20/ERC20.sol';
import '@chainlink/contracts/src/v0.7/interfaces/AggregatorV3Interface.sol';

import '../../roles/User.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../PriceOracle.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../SavingsAccount/SavingsAccountUtil.sol';
import '../../../Verification/Verification.sol';
import '../../../Verification/twitterVerifier.sol';
import '../../Constants.sol';
import '../../../mocks/MockToken.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockVerification.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../..//interfaces/IWETH9.sol';
import '../../ProtocolFeeCollector.sol';
import '../../roles/CompoundUser.sol';
import '../Roles/PCLAdmin.t.sol';
import './PCLConstants.t.sol';
import 'forge-std/Test.sol';

contract PCLParent is IPooledCreditLineDeclarations, Test {
    using stdStorage for StdStorage;

    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for ERC20;

    uint256 constant BLOCK_TIME = 20;

    bool isForked;

    address public priceOracleAddress;
    address public collateralCTokenAddress;
    address public borrowCTokenAddress;

    address public collateralAssetAggregatorAddress;
    address public borrowAssetAggregatorAddress;
    address public usdcAggregatorAddress;

    IERC20 public collateralAsset;
    IERC20 public borrowAsset;
    IERC20 public usdc;
    IWETH9 public weth;

    address public mockAdminVerifier1;
    address public mockAdminVerifier2;

    address public savingsAccountAddress;
    address public noYieldAddress;
    address public compoundYieldAddress;
    address public limitsManagerAddress;
    address public pooledCreditLineAddress;
    address public lenderPoolAddress;

    LenderPool lp;
    PooledCreditLine pcl;

    PCLAdmin public proxyAdmin;
    PCLAdmin public admin;
    address public protocolFeeCollectorAddress;

    PCLUser public borrower;
    CompoundUser public compoundUser;

    struct LenderInfo {
        address lenderAddress;
        uint256 amount;
    }

    mapping(uint256 => LenderInfo) public lenders;
    uint256 numLenders;

    Request request;

    function setCollateralAsset() public virtual {
        if (isForked) {
            collateralAsset = ERC20(Constants.WBTC);
            collateralAssetAggregatorAddress = Constants.WBTC_priceFeedChainlink;
            collateralCTokenAddress = Constants.cWBTC;
        } else {
            collateralAsset = new MockToken('CollateralAsset', 'MT1', 18, 1e40, address(admin));
            collateralAssetAggregatorAddress = address(new MockV3Aggregator(18, 12876423400040030304304));
        }
    }

    function setBorrowAsset() public virtual {
        if (isForked) {
            borrowAsset = ERC20(Constants.DAI);
            borrowAssetAggregatorAddress = Constants.DAI_priceFeedChainlink;
            borrowCTokenAddress = Constants.cDAI;
        } else {
            borrowAsset = new MockToken('BorrowAsset', 'MT2', 8, 1e40, address(admin));
            borrowAssetAggregatorAddress = address(new MockV3Aggregator(8, 195040576));
        }
    }

    function setUp() public virtual {
        uint256 _chainId = getChainID();
        if (_chainId == 1) {
            isForked = true;
        }

        // setting global actors
        proxyAdmin = new PCLAdmin(pooledCreditLineAddress, lenderPoolAddress);
        admin = new PCLAdmin(pooledCreditLineAddress, lenderPoolAddress);
        compoundUser = new CompoundUser();

        /* --- deploying contracts ----*/

        // deploying  mock protocol fee collector
        protocolFeeCollectorAddress = address(new ProtocolFeeCollector());

        /***** set up verification *****/
        // deploy verification related contracts
        address verificationAddress = admin.deployVerification(address(proxyAdmin));

        // deploy mock admin verifier
        mockAdminVerifier1 = admin.deployMockAdminVerifier(verificationAddress);
        mockAdminVerifier2 = admin.deployMockAdminVerifier(verificationAddress);

        // whitelist mockAdminVerifier
        admin.addVerifier(verificationAddress, mockAdminVerifier1);
        admin.addVerifier(verificationAddress, mockAdminVerifier2);

        /***** set up savings account *****/
        // deploy strategy registry
        address strategyRegistryAddress = admin.deployStrategyRegistry(PCLConstants.maxStrategies);
        // deploy savings account
        savingsAccountAddress = admin.deploySavingsAccount(strategyRegistryAddress);
        // deploy no yield
        noYieldAddress = admin.deployNoYield(address(admin), savingsAccountAddress, protocolFeeCollectorAddress);
        // add savings strategies to savings account
        admin.addSavingsAccountStrategy(strategyRegistryAddress, noYieldAddress);

        setCollateralAsset();
        setBorrowAsset();

        if (isForked) {
            // forked mode
            usdc = ERC20(Constants.USDC);
            weth = IWETH9(Constants.WETH);

            writeTokenBalance(address(admin), address(collateralAsset), collateralAsset.totalSupply());
            writeTokenBalance(address(admin), address(borrowAsset), borrowAsset.totalSupply());
            writeTokenBalance(address(admin), Constants.USDC, usdc.totalSupply());
            // weth.deposit{value: 1e30}();
            // IERC20(Constants.WETH).transfer(address(admin), 1e30);

            // deploy aggregators
            usdcAggregatorAddress = Constants.USDC_priceFeedChainlink;

            // deploy compound yield
            compoundYieldAddress = admin.deployCompoundYield(
                address(admin),
                savingsAccountAddress,
                address(weth),
                protocolFeeCollectorAddress
            );
            admin.addSavingsAccountStrategy(strategyRegistryAddress, compoundYieldAddress);
            admin.addTokenAddressForCompoundYield(payable(compoundYieldAddress), address(collateralAsset), collateralCTokenAddress);
            admin.addTokenAddressForCompoundYield(payable(compoundYieldAddress), address(borrowAsset), borrowCTokenAddress);
            admin.addTokenAddressForNoYield(noYieldAddress, address(borrowAsset));
            admin.addTokenAddressForNoYield(noYieldAddress, address(collateralAsset));
        } else {
            // standard mode

            vm.warp(block.timestamp + 10);

            usdc = new MockToken('USDC', 'USDC', 6, 1e20, address(admin));
            weth = new MockWETH();

            // deploy aggregators
            usdcAggregatorAddress = address(new MockV3Aggregator(6, 1000000));

            // deploy compound yield
            compoundYieldAddress = admin.deployCompoundYield(
                address(admin),
                savingsAccountAddress,
                address(weth),
                protocolFeeCollectorAddress
            );
            admin.addSavingsAccountStrategy(strategyRegistryAddress, compoundYieldAddress);

            // adding cToken for collateralAsset
            collateralCTokenAddress = admin.deployMockCToken(address(collateralAsset), compoundYieldAddress, noYieldAddress);
            admin.transferOwnership(address(collateralAsset), collateralCTokenAddress);

            // adding cToken for borrowAsset
            borrowCTokenAddress = admin.deployMockCToken(address(borrowAsset), compoundYieldAddress, noYieldAddress);
            admin.transferOwnership(address(borrowAsset), borrowCTokenAddress);
        }

        /***** set up price oracles *****/
        // deploy price oracle contract
        priceOracleAddress = admin.deployPriceOracle(address(admin), PCLConstants.uniswapPriceAveragingPeriod);

        // add aggregators to the oracle
        admin.setChainlinkFeedAddress(
            priceOracleAddress,
            address(collateralAsset),
            collateralAssetAggregatorAddress,
            Constants.CHAINLINK_HEARTBEAT
        );
        admin.setChainlinkFeedAddress(
            priceOracleAddress,
            address(borrowAsset),
            borrowAssetAggregatorAddress,
            Constants.CHAINLINK_HEARTBEAT
        );
        admin.setChainlinkFeedAddress(priceOracleAddress, address(usdc), usdcAggregatorAddress, Constants.CHAINLINK_HEARTBEAT);

        limitsManagerAddress = admin.deployLimitsManager(address(proxyAdmin), address(usdc), priceOracleAddress);

        {
            (pooledCreditLineAddress, lenderPoolAddress) = admin.deployPCLContracts(
                address(proxyAdmin), //proxyAdmin
                savingsAccountAddress, //savingsAccount
                verificationAddress, //verification
                priceOracleAddress, //priceOracle
                strategyRegistryAddress, //strategyRegistry
                limitsManagerAddress,
                protocolFeeCollectorAddress //protocolFeeCollector
            );
        }

        pcl = PooledCreditLine(pooledCreditLineAddress);
        lp = LenderPool(lenderPoolAddress);

        // setting PCL actors
        borrower = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        //emit log_named_address('borrower', address(borrower));
        //emit log_named_address('pcl in pclparent', pooledCreditLineAddress);
        // Verifying the borrower
        borrower.registerSelf(mockAdminVerifier2);
        // this is done to activate the registered user
        vm.warp(block.timestamp + Verification(verificationAddress).activationDelay());
    }

    function randomAmountToLend(uint256 _seed, uint256 _maxVal) public view returns (uint256) {
        // _amountToLend will only be 0 if the random number is a multiple of _maxVal
        // in this case we add a 1 to it.
        uint256 _amountToLend = uint256(keccak256(abi.encodePacked(block.timestamp, _seed))) % _maxVal;
        if (_amountToLend == 0) {
            _amountToLend = _amountToLend.add(1);
        }
        return _amountToLend;
    }

    /**
     * @dev Helper function used within generalizedLender to create a single lender and lend
     * @param _pooledCreditLineID Pooled credit line ID
     * @param _amountToLend Amount to lend
     * @param _asset Asset to be lent
     * @return address of the lender created
     */
    function createLender(
        uint256 _pooledCreditLineID,
        uint256 _amountToLend,
        address _asset
    ) public returns (address) {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(_asset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(_asset), type(uint256).max);
        _pooledCreditLineLender.lend(_pooledCreditLineID, _amountToLend);

        return address(_pooledCreditLineLender);
    }

    /**
     * @dev used to lend into a PCL in collection stage. lenders.lenderAddress & lenders.amount store details of every lender
     * @param _pooledCreditLineID id of the PCL to lend into
     * @param _nLenders number of lenders that must be created. If 0, it'll create random number of lenders
     * @param _amountToLend cumulative amount that all lenders must lend
     * @param _asset to be lent
     * @return the final number of lenders created by the function.
     */
    function createMultipleLenders(
        uint256 _pooledCreditLineID,
        uint256 _nLenders,
        uint128 _amountToLend,
        address _asset
    ) public returns (uint256) {
        if (_amountToLend < _nLenders) {
            address _lender = createLender(_pooledCreditLineID, _amountToLend, _asset);
            lenders[0].lenderAddress = _lender;
            lenders[0].amount = _amountToLend;

            return 1;
        }

        if (_nLenders != 0) {
            uint256 _maxAmountPerLender = _amountToLend / _nLenders;
            require(_maxAmountPerLender != 0, '_amountToLend is too small');
            uint256 _penultimateCumulativeAmountSupplied = 0;
            address _lender;

            for (uint256 i; i < _nLenders - 1; ++i) {
                uint256 _amountLent = randomAmountToLend(_penultimateCumulativeAmountSupplied, _maxAmountPerLender);

                // executing lend, and getting address of lender
                _lender = createLender(_pooledCreditLineID, _amountLent, _asset);

                // updating state mapping for address of lender and amount lent
                lenders[i].lenderAddress = _lender;
                lenders[i].amount = _amountLent;

                _penultimateCumulativeAmountSupplied += _amountLent;
            }

            uint256 _amountLeft = _amountToLend - _penultimateCumulativeAmountSupplied;

            // executing lend, and getting address of lender
            _lender = createLender(_pooledCreditLineID, _amountLeft, _asset);

            // updating state mapping for address of lender and amount lent
            lenders[_nLenders - 1].lenderAddress = _lender;
            lenders[_nLenders - 1].amount = _amountLeft;

            return _nLenders;
        } else {
            uint256 _cumAmountLent = 0;
            uint256 _lenderCounter = 0;
            address _lender;
            while (_cumAmountLent < _amountToLend) {
                uint256 _maxLendableAmount = _amountToLend - _cumAmountLent;
                uint256 _amountLent;
                _amountLent = randomAmountToLend(_cumAmountLent, _maxLendableAmount);
                _lender = createLender(_pooledCreditLineID, _amountLent, _asset);
                _cumAmountLent += _amountLent;
                lenders[_lenderCounter].lenderAddress = _lender;
                lenders[_lenderCounter].amount = _amountLent;

                _lenderCounter += 1;
            }

            return _lenderCounter + 1;
        }
    }

    /**
     * @dev helper function used to reset arguments used by the generalized lender
     * @param _nLenders number of lenders created by generalizedLender
     */
    function resetLenders(uint256 _nLenders) public {
        for (uint256 i; i <= _nLenders; ++i) {
            lenders[i].lenderAddress = address(0);
            lenders[i].amount = 0;
        }
    }

    function goToActiveStage(uint256 _numLenders, uint128 _amountToLend) public returns (uint256, uint256) {
        require(
            _amountToLend <= request.borrowLimit && _amountToLend >= request.minBorrowAmount,
            'Cannot go to active stage with given params'
        );
        uint256 _id = borrower.createRequest(request);
        uint256 _finalNumLenders = createMultipleLenders(_id, _numLenders, _amountToLend, request.borrowAsset);

        vm.warp(block.timestamp + request.collectionPeriod);

        borrower.start(_id);

        uint256 _status = uint256(PooledCreditLine(pooledCreditLineAddress).getStatusAndUpdate(_id));
        assertEq(_status, 2);

        return (_id, _finalNumLenders);
    }

    function scaleToRange256(
        uint256 value,
        uint256 min,
        uint256 max
    ) internal pure returns (uint256) {
        require(max != 0 && max >= min, 'wrong input');
        if (max == min) return max;
        return min + (value % (max - min));
    }

    function scaleToRange128(
        uint128 value,
        uint128 min,
        uint128 max
    ) internal pure returns (uint128) {
        require(max != 0 && max >= min, 'wrong input');
        if (max == min) return max;
        return min + (value % (max - min));
    }

    function getChainID() internal pure returns (uint256) {
        uint256 id;
        assembly {
            id := chainid()
        }
        return id;
    }

    function writeTokenBalance(
        address who,
        address token,
        uint256 amt
    ) internal {
        if (token != Constants.WETH) {
            uint256 _totalSupply = IERC20(token).totalSupply();
            uint256 _curBalance = IERC20(token).balanceOf(who);
            stdstore.target(token).sig(IERC20(token).balanceOf.selector).with_key(who).checked_write(amt + _curBalance);
            stdstore.target(token).sig(IERC20(token).totalSupply.selector).checked_write(_totalSupply + amt);
        } else {
            token.call{value: amt}('');
            IWETH9(token).transfer(who, amt);
        }
    }

    function borrowFromCompound(
        address _cToken,
        uint256 _collateralAmount,
        uint256 _borrowAmount
    ) public returns (uint256) {
        // borrowing from compound
        address(compoundUser).call{value: _collateralAmount}('');
        // emit log_named_uint(""ether balance"", address(compoundUser).balance);
        compoundUser.mintCETH(Constants.cETH, _collateralAmount);
        // emit log_named_uint(""cEther Balance"", IERC20(Constants.cETH).balanceOf(address(compoundUser)));
        address[] memory _cTokens = new address[](1);
        _cTokens[0] = Constants.cETH;
        compoundUser.enterMarkets(Constants.COMPTROLLER, _cTokens);
        // (, uint256 _liquidity, ) = IComptroller(Constants.COMPTROLLER).getAccountLiquidity(address(compoundUser));
        // emit log_named_uint(""account liquidity"", _liquidity);
        return compoundUser.borrow(_cToken, _borrowAmount);
        // emit log_named_uint(""borrow result"", _result);
        // emit log_named_uint(""compoundUser balance"", borrowAsset.balanceOf(address(compoundUser)));
    }

    function _increaseBlock(uint256 _time) public {
        vm.warp(_time);
        vm.roll(_time.div(BLOCK_TIME));
    }

    modifier clearMockedCalls() {
        vm.clearMockedCalls();
        _;
    }

    function helper_exchangeRateChanges() public {
        console.log(MockCToken(borrowCTokenAddress).exchangeRateCurrent());
        console.log(MockCToken(collateralCTokenAddress).exchangeRateCurrent());

        uint256 _blockDelta = 1_000_000;
        _increaseBlock(block.timestamp + _blockDelta);

        console.log(MockCToken(borrowCTokenAddress).exchangeRateCurrent());
        console.log(MockCToken(collateralCTokenAddress).exchangeRateCurrent());
    }

    function helper_increaseExchangeRateSlowly(address _assetCTokenAddress) public {
        console.log(MockCToken(_assetCTokenAddress).exchangeRateCurrent());
        uint256 _exchangeRateCurrent = MockCToken(_assetCTokenAddress).exchangeRateCurrent();
        uint256 _blockDelta = 1_000_000;
        _increaseBlock(block.timestamp + _blockDelta);
        uint256 _exchangeRateMocked = (_exchangeRateCurrent * (1e18 + (_blockDelta * 1e4))) / 1e18;
        if (isForked) {
            vm.mockCall(
                _assetCTokenAddress,
                abi.encodeWithSelector(MockCToken.exchangeRateCurrent.selector),
                abi.encode(_exchangeRateMocked)
            );
        } else {
            MockCToken(_assetCTokenAddress).mockExchangeRateStored(_exchangeRateMocked);
        }

        console.log(MockCToken(_assetCTokenAddress).exchangeRateCurrent());
    }

    function helper_increaseExchangeRateSteeply(address _assetCTokenAddress) public {
        console.log(MockCToken(_assetCTokenAddress).exchangeRateCurrent());
        uint256 _exchangeRateCurrent = MockCToken(_assetCTokenAddress).exchangeRateCurrent();
        uint256 _blockDelta = 1_000_000;
        _increaseBlock(block.timestamp + _blockDelta);
        if (isForked) {
            vm.mockCall(
                _assetCTokenAddress,
                abi.encodeWithSelector(MockCToken.exchangeRateCurrent.selector),
                abi.encode(_exchangeRateCurrent * 2)
            );
        } else {
            MockCToken(_assetCTokenAddress).mockExchangeRateStored(_exchangeRateCurrent * 2);
        }

        console.log(MockCToken(_assetCTokenAddress).exchangeRateCurrent());
    }

    function helper_decreaseExchangeRateToZero(address _assetCTokenAddress) public {
        if (isForked) {
            vm.mockCall(_assetCTokenAddress, abi.encodeWithSelector(MockCToken.exchangeRateCurrent.selector), abi.encode(0));
        } else {
            MockCToken(_assetCTokenAddress).mockExchangeRateStored(0);
        }
    }

    function helper_priceChanges(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public clearMockedCalls {
        (
            uint80 _borrowAssetRoundId,
            int256 _borrowAssetPrice,
            uint256 _borrowAssetStartedAt,
            uint256 _borrowAssetUpdatedAt,
            uint80 _borrowAssetAnsweredInRound
        ) = MockV3Aggregator(borrowAssetAggregatorAddress).latestRoundData();
        (
            uint80 _collateralAssetRoundId,
            int256 _collateralAssetPrice,
            uint256 _collateralAssetStartedAt,
            uint256 _collateralAssetUpdatedAt,
            uint80 _collateralAssetAnsweredInRound
        ) = MockV3Aggregator(collateralAssetAggregatorAddress).latestRoundData();

        _borrowAssetPriceSeed = scaleToRange256(_borrowAssetPriceSeed, 1, 10000);
        _collateralAssetPriceSeed = scaleToRange256(_collateralAssetPriceSeed, 1, 10000);

        log_named_int('Borrow asset price', _borrowAssetPrice);
        log_named_int('Collateral asset price', _collateralAssetPrice);
        log_named_uint('Borrow asset seed', _borrowAssetPriceSeed);
        log_named_uint('Collateral asset seed', _collateralAssetPriceSeed);

        _borrowAssetPrice = (_borrowAssetPrice * int256(_borrowAssetPriceSeed)) / 100;
        _collateralAssetPrice = (_collateralAssetPrice * int256(_collateralAssetPriceSeed)) / 100;

        log_named_int('Borrow asset price', _borrowAssetPrice);
        log_named_int('Collateral asset price', _collateralAssetPrice);

        vm.mockCall(
            borrowAssetAggregatorAddress,
            abi.encodeWithSelector(MockV3Aggregator.latestRoundData.selector),
            abi.encode(_borrowAssetRoundId, _borrowAssetPrice, _borrowAssetStartedAt, _borrowAssetUpdatedAt, _borrowAssetAnsweredInRound)
        );
        vm.mockCall(
            collateralAssetAggregatorAddress,
            abi.encodeWithSelector(MockV3Aggregator.latestRoundData.selector),
            abi.encode(
                _collateralAssetRoundId,
                _collateralAssetPrice,
                _collateralAssetStartedAt,
                _collateralAssetUpdatedAt,
                _collateralAssetAnsweredInRound
            )
        );
    }

    function helper_decreaseAssetPrice(address _assetAggregatorAddress, uint256 _seed) public clearMockedCalls {
        (
            uint80 _assetRoundId,
            int256 _assetPrice,
            uint256 _assetStartedAt,
            uint256 _assetUpdatedAt,
            uint80 _assetAnsweredInRound
        ) = MockV3Aggregator(_assetAggregatorAddress).latestRoundData();

        _seed = scaleToRange256(_seed, 1, 95);
        _assetPrice = (_assetPrice * int256(_seed)) / 100;

        vm.mockCall(
            _assetAggregatorAddress,
            abi.encodeWithSelector(MockV3Aggregator.latestRoundData.selector),
            abi.encode(_assetRoundId, _assetPrice, _assetStartedAt, _assetUpdatedAt, _assetAnsweredInRound)
        );
    }

    function helper_increaseAssetPrice(address _assetAggregatorAddress, uint256 _seed) public clearMockedCalls {
        (
            uint80 _assetRoundId,
            int256 _assetPrice,
            uint256 _assetStartedAt,
            uint256 _assetUpdatedAt,
            uint80 _assetAnsweredInRound
        ) = MockV3Aggregator(_assetAggregatorAddress).latestRoundData();

        _seed = scaleToRange256(_seed, 105, 10000);
        _assetPrice = (_assetPrice * int256(_seed)) / 100;

        vm.mockCall(
            _assetAggregatorAddress,
            abi.encodeWithSelector(MockV3Aggregator.latestRoundData.selector),
            abi.encode(_assetRoundId, _assetPrice, _assetStartedAt, _assetUpdatedAt, _assetAnsweredInRound)
        );
    }

    function helper_decreaseAssetPriceToZero(address _assetAggregatorAddress) public clearMockedCalls {
        (
            uint80 _assetRoundId,
            int256 _assetPrice,
            uint256 _assetStartedAt,
            uint256 _assetUpdatedAt,
            uint80 _assetAnsweredInRound
        ) = MockV3Aggregator(_assetAggregatorAddress).latestRoundData();
        vm.mockCall(
            _assetAggregatorAddress,
            abi.encodeWithSelector(MockV3Aggregator.latestRoundData.selector),
            abi.encode(_assetRoundId, 0, _assetStartedAt, _assetUpdatedAt, _assetAnsweredInRound)
        );
    }

    function helper_smallPriceChanges(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public clearMockedCalls {
        (
            uint80 _borrowAssetRoundId,
            int256 _borrowAssetPrice,
            uint256 _borrowAssetStartedAt,
            uint256 _borrowAssetUpdatedAt,
            uint80 _borrowAssetAnsweredInRound
        ) = MockV3Aggregator(borrowAssetAggregatorAddress).latestRoundData();
        (
            uint80 _collateralAssetRoundId,
            int256 _collateralAssetPrice,
            uint256 _collateralAssetStartedAt,
            uint256 _collateralAssetUpdatedAt,
            uint80 _collateralAssetAnsweredInRound
        ) = MockV3Aggregator(collateralAssetAggregatorAddress).latestRoundData();
        {
            _borrowAssetPriceSeed = scaleToRange256(_borrowAssetPriceSeed, 95, 105);
            _collateralAssetPriceSeed = scaleToRange256(_collateralAssetPriceSeed, 95, 105);

            _borrowAssetPrice = (_borrowAssetPrice * int256(_borrowAssetPriceSeed)) / 100;
            _collateralAssetPrice = (_collateralAssetPrice * int256(_collateralAssetPriceSeed)) / 100;
        }
        vm.mockCall(
            borrowAssetAggregatorAddress,
            abi.encodeWithSelector(MockV3Aggregator.latestRoundData.selector),
            abi.encode(_borrowAssetRoundId, _borrowAssetPrice, _borrowAssetStartedAt, _borrowAssetUpdatedAt, _borrowAssetAnsweredInRound)
        );
        vm.mockCall(
            collateralAssetAggregatorAddress,
            abi.encodeWithSelector(MockV3Aggregator.latestRoundData.selector),
            abi.encode(
                _collateralAssetRoundId,
                _collateralAssetPrice,
                _collateralAssetStartedAt,
                _collateralAssetUpdatedAt,
                _collateralAssetAnsweredInRound
            )
        );
    }
}",6067
RealWorld_BA_101_SublimeProxy_RealWord_20240827084842.log,101,SublimeProxy,3973,4052,8025,82.0,0.100905,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

import '@openzeppelin/contracts/proxy/TransparentUpgradeableProxy.sol';

contract SublimeProxy is TransparentUpgradeableProxy {
    constructor(
        address logic,
        address admin,
        bytes memory data
    ) payable TransparentUpgradeableProxy(logic, admin, data) {}
}",74
RealWorld_BA_101_Admin_RealWord_20240827104200.log,101,Admin,0,0,0,,0.0,"// SPDX-License-Identifier: MIT
pragma solidity ^0.7.6;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/utils/ReentrancyGuard.sol';
import '@openzeppelin/contracts-upgradeable/proxy/Initializable.sol';
import '@openzeppelin/contracts-upgradeable/token/ERC20/ERC20PausableUpgradeable.sol';

import '../ProtocolFeeCollector.sol';
import '../../PriceOracle.sol';
import '../../CreditLine/CreditLine.sol';
import '../../yield/StrategyRegistry.sol';
import '../../SublimeProxy.sol';
import '../../CreditLine/CreditLine.sol';
import '../../yield/NoYield.sol';
import '../../yield/CompoundYield.sol';
import '../../Verification/Verification.sol';
import '../../SavingsAccount/SavingsAccount.sol';
import '../Constants.sol';
import '../../mocks/MockCToken.sol';
import '../../mocks/MockToken.sol';
import '../../mocks/MockAdminVerifier.sol';
import '../interfaces/IProxyUpgrade.sol';
import '../../Verification/twitterVerifier.sol';
import '../../Verification/adminVerifier.sol';

contract Admin {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    function changeImplementationAddressOfProxy(address proxy, address newImplementation) public {
        ProxyUpgrade(proxy).upgradeTo(newImplementation);
    }

    function getImplementationAddressOfProxy(SublimeProxy sublimeProxyInstance) public returns (address) {
        address implAddress = sublimeProxyInstance.implementation();
        return implAddress;
    }

    /******************************************************************************
     ******* SavingsAccount specific functions ************************************
     ******************************************************************************/

    function initSavingsAccount(address savingsAccount, address _owner) public {
        SavingsAccount(savingsAccount).initialize(_owner);
    }

    function addSavingsAccountStrategy(address _strategyRegistry, address _strategyAddress) public {
        StrategyRegistry(_strategyRegistry).addStrategy(_strategyAddress);
    }

    function updateMaxStrategies(address _strategyRegistry, uint256 _maxStrategies) public {
        StrategyRegistry(_strategyRegistry).updateMaxStrategies(_maxStrategies);
    }

    function removeStrategy(
        address _strategyRegistry,
        uint256 _strategyIndex,
        address _strategyAddress
    ) public {
        StrategyRegistry(_strategyRegistry).removeStrategy(_strategyIndex, _strategyAddress);
    }

    function updateStrategy(
        address _strategyRegistry,
        uint256 _strategyIndex,
        address _oldStrategy,
        address _newStrategy
    ) public {
        StrategyRegistry(_strategyRegistry).updateStrategy(_strategyIndex, _oldStrategy, _newStrategy);
    }

    function updateProtocolFeeFraction(address creditLine, uint256 protocolFee) public {
        CreditLine(creditLine).updateProtocolFeeFraction(protocolFee);
    }

    function setDepositLimitForCompoundYield(
        address payable _compound,
        address _asset,
        uint256 _limit
    ) public {
        CompoundYield(_compound).setDepositLimit(_asset, _limit);
    }

    function addTokenAddressForCompoundYield(
        address payable yield,
        address _asset,
        address _liquidityToken
    ) public {
        CompoundYield(yield).addTokenAddress(_asset, _liquidityToken);
        setDepositLimitForCompoundYield(yield, _asset, type(uint256).max);
    }

    function addTokenAddressForNoYield(address yield, address _asset) public {
        NoYield(yield).addTokenAddress(_asset);
    }

    function transferOwnership(address _contract, address _to) public {
        MockToken(_contract).transferOwnership(_to);
    }

    function emergencyWithdrawFromCompoundYield(
        address payable yield,
        address _asset,
        address _wallet
    ) public {
        CompoundYield(yield).emergencyWithdraw(_asset, _wallet);
    }

    function forceUpdateTokenAddressForCompoundYield(
        address payable yield,
        address _asset,
        address _liquidityToken
    ) public {
        CompoundYield(yield).forceUpdateTokenAddress(_asset, _liquidityToken);
    }

    function emergencyWithdrawFromNoYield(
        address yield,
        address _asset,
        uint256 _amount
    ) public {
        NoYield(yield).emergencyWithdraw(_asset, _amount);
    }

    /******************************************************************************
     ******* END SavingsAccount specific functions ************************************
     ******************************************************************************/

    /******************************************************************************
     ******* PriceOracle specific functions ***************************************
     ******************************************************************************/

    function deployPriceOracle(address _admin, uint32 _uniswapPriceAvgPeriod) public returns (address) {
        PriceOracle _priceOracle = new PriceOracle(Constants.CHAINLINK_HEARTBEAT);
        _priceOracle.initialize(_admin, _uniswapPriceAvgPeriod);

        return address(_priceOracle);
    }

    function setChainlinkFeedAddress(
        address priceOracle,
        address token,
        address aggregator,
        uint128 heartbeat
    ) public {
        PriceOracle(priceOracle).setChainlinkFeedAddress(token, aggregator, heartbeat);
    }

    // NEEDS FORKING
    function setUpAllOracles(address priceOracleAddress) public {
        PriceOracle priceOracle = PriceOracle(priceOracleAddress);

        priceOracle.setChainlinkFeedAddress(Constants.WETH, Constants.ETH_priceFeedChainlink, Constants.CHAINLINK_HEARTBEAT);
        priceOracle.setChainlinkFeedAddress(Constants.DAI, Constants.DAI_priceFeedChainlink, Constants.CHAINLINK_HEARTBEAT);
        priceOracle.setChainlinkFeedAddress(Constants.USDC, Constants.USDC_priceFeedChainlink, Constants.CHAINLINK_HEARTBEAT);
        priceOracle.setChainlinkFeedAddress(Constants.WBTC, Constants.WBTC_priceFeedChainlink, Constants.CHAINLINK_HEARTBEAT);

        priceOracle.setUniswapFeedAddress(Constants.USDC, Constants.WETH, Constants.USDC_ETH_priceFeedUniswap);
        priceOracle.setUniswapFeedAddress(Constants.WBTC, Constants.WETH, Constants.WBTC_WETH_priceFeedUniswap);
        priceOracle.setUniswapFeedAddress(Constants.WBTC, Constants.DAI, Constants.WBTC_DAI_priceFeedUniswap);
    }

    /******************************************************************************
     ******* END PriceOracle specific functions ***************************************
     ******************************************************************************/

    /******************************************************************************
     ******* Verification specific functions ***************************************
     ******************************************************************************/

    function initializeVerification(
        Verification verification,
        address _admin,
        uint256 _activationDelay
    ) public {
        verification.initialize(_admin, _activationDelay);
    }

    /******************************************************************************
     ******* End Verification specific functions ***************************************
     ******************************************************************************/

    /******************************************************************************
     ******* Verifier specific functions ***************************************
     ******************************************************************************/

    function initializeTwitterVerifier(
        TwitterVerifier twitterVerifier,
        address _admin,
        address _signerAddress,
        uint256 _signValidity,
        string calldata _name,
        string calldata _version
    ) public {
        twitterVerifier.initialize(_admin, _signerAddress, _signValidity, _name, _version);
    }

    function addVerifier(address _verification, address _verifier) public {
        Verification(_verification).addVerifier(_verifier);
    }

    function removeVerifier(address _verification, address _verifier) public {
        Verification(_verification).removeVerifier(_verifier);
    }

    function verifyUser(address _user, address _verifier) public {
        MockAdminVerifier verifier = MockAdminVerifier(payable(_verifier));
        verifier.registerUserViaOwner(_user);
    }

    function blacklistDigestInTwitterVerifier(TwitterVerifier verifier, bytes32 digest) public {
        verifier.blackListDigest(digest);
    }

    function blacklistDigestInAdminVerifier(AdminVerifier verifier, bytes32 digest) public {
        verifier.blackListDigest(digest);
    }

    function updateSignerInTwitterVerifier(TwitterVerifier verifier, address newSigner) public {
        verifier.updateSignerAddress(newSigner);
    }

    function updateSignerInAdminVerifier(AdminVerifier verifier, address newSigner) public {
        verifier.updateSignerAddress(newSigner);
    }

    function updateSignValidityInTwitterVerifier(TwitterVerifier verifier, uint256 signValidity) public {
        verifier.updateSignValidity(signValidity);
    }

    function updateSignValidityInAdminVerifier(AdminVerifier verifier, uint256 signValidity) public {
        verifier.updateSignValidity(signValidity);
    }

    function unregisterUserByAdminInAdminVerifier(AdminVerifier verifier, address user) public {
        verifier.unregisterUser(user);
    }

    function unregisterUserByAdminInTwitterVerifier(TwitterVerifier verifier, address user) public {
        verifier.unregisterUser(user);
    }

    function initializeAdminVerifier(
        AdminVerifier adminVerifier,
        address _admin,
        address _signerAddress,
        uint256 _signValidity,
        string calldata _name,
        string calldata _version
    ) public {
        adminVerifier.initialize(_admin, _signerAddress, _signValidity, _name, _version);
    }

    /******************************************************************************
     ******* END Verifier specific functions ***************************************
     ******************************************************************************/

    /******************************************************************************
     ******* Verification specific functions ***************************************
     ******************************************************************************/

    function registerMasterAddressInVerificaction(
        Verification verification,
        address _masterAddress,
        bool _isMasterLinked
    ) public {
        verification.registerMasterAddress(_masterAddress, _isMasterLinked);
    }

    function unregisterMasterAddressInVerification(
        Verification verification,
        address _masterAddress,
        address _verifier
    ) public {
        verification.unregisterMasterAddress(_masterAddress, _verifier);
    }

    function updateActivationDelayInVerification(Verification verification, uint256 _activationDelay) public {
        verification.updateActivationDelay(_activationDelay);
    }

    /******************************************************************************
     ******* End Verification specific functions ***************************************
     ******************************************************************************/

    /******************************************************************************
     ******* DEPLOYEMNT specific functions ***************************************
     ******************************************************************************/

    function deployVerification(address) public returns (address) {
        Verification _verification = new Verification();
        _verification.initialize(address(this), 0);

        return address(_verification);
    }

    function deployMockAdminVerifier(address _verification) public returns (address) {
        MockAdminVerifier _mockAdminVerifier = new MockAdminVerifier();
        _mockAdminVerifier.initialize(address(this), _verification, 'MockAdminVerifier', '1.0');

        return address(_mockAdminVerifier);
    }

    function deployStrategyRegistry(uint256 _maxStrategies) public returns (address) {
        StrategyRegistry _strategyRegistry = new StrategyRegistry();
        _strategyRegistry.initialize(address(this), _maxStrategies);

        return address(_strategyRegistry);
    }

    function deploySavingsAccount(address _strategyRegistry) public returns (address) {
        SavingsAccount _savingsAccount = new SavingsAccount(_strategyRegistry);
        _savingsAccount.initialize(address(this));

        return address(_savingsAccount);
    }

    function deployNoYield(
        address _admin,
        address _savingsAccount,
        address _treasury
    ) public returns (address) {
        NoYield _noYield = new NoYield(_treasury, _savingsAccount);
        _noYield.initialize(_admin);

        return address(_noYield);
    }

    function deployCompoundYield(
        address _admin,
        address _savingsAccount,
        address _mockWETH,
        address _treasury
    ) public returns (address) {
        CompoundYield _compoundYield = new CompoundYield(_mockWETH, _treasury, _savingsAccount);
        _compoundYield.initialize(_admin);

        return address(_compoundYield);
    }

    function deployMockCToken(
        address _underlying,
        address _compoundYield,
        address _noYield
    ) public returns (address) {
        MockCToken _mockCToken = new MockCToken(address(_underlying));
        addTokenAddressForCompoundYield(payable(_compoundYield), _underlying, address(_mockCToken));
        addTokenAddressForNoYield(_noYield, _underlying);
        return address(_mockCToken);
    }

    /******************************************************************************
     ******* END DEPLOYEMNT specific functions ***************************************
     ******************************************************************************/

    function transferToken(
        address token,
        address recipient,
        uint256 amount
    ) public {
        IERC20(token).safeTransfer(recipient, amount);
    }

    function getFunctionSignature(string memory signature) public pure returns (bytes4) {
        return bytes4(keccak256(bytes(signature)));
    }

    function execute(
        address target,
        uint256 value,
        bytes calldata callData
    ) public {
        (bool success, ) = target.call{value: value}(callData);
        require(success, 'Transaction execution reverted.');
    }

    function executeFuncSig(
        address target,
        uint256 value,
        string memory signature,
        bytes calldata callData
    ) public {
        (bool success, ) = target.call{value: value}(abi.encodePacked(getFunctionSignature(signature), callData));
        require(success, 'Transaction execution reverted.');
    }
}",2716
RealWorld_BA_101_MaliciousLender_RealWord_20240827101245.log,101,MaliciousLender,5369,4613,9982,67.0,0.119105,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import './PCLUser.t.sol';

contract MaliciousLender is PCLUser {
    constructor(address _pclAddress, address _lpAddress) PCLUser(_pclAddress, _lpAddress) {}

    function onERC1155Received(
        address,
        address,
        uint256 id,
        uint256,
        bytes calldata
    ) external override returns (bytes4) {
        // any code can be executed here
        ILenderPool(msg.sender).start(id);
        return bytes4(keccak256('onERC1155Received(address,address,uint256,uint256,bytes)'));
    }
}",149
RealWorld_BA_101_PCLRequestedStateCompoundYield.t_RealWord_20240827103225.log,101,PCLRequestedStateCompoundYield.t,10942,5083,16025,76.0,0.15637,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '../PCLRequestedState.t.sol';
import '../../Helpers/PCLParent.t.sol';

contract PCLRequestedStatePriceOracleCompoundYield is PCLRequestedStatePriceOracle {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    function setUp() public override {
        PCLParent.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();
        _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));
        _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));

        _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();
        _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));
        _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = compoundYieldAddress;
        request.collateralAssetStrategy = compoundYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.REQUESTED, '!Requested');
    }
}",496
RealWorld_BA_101_MockCEther_RealWord_20240827085754.log,101,MockCEther,10137,5346,15483,78.0,0.157605,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

import '@openzeppelin/contracts/token/ERC20/ERC20.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import '../interfaces/Invest/ICEther.sol';

// @dev This contract should be able to mint underlying tokens to work
contract MockCEther is ERC20, ICEther {
    uint256 exchangeRateStored;
    uint256 lastExchangeRateAt;

    constructor() ERC20('CEther', 'cETH') {
        exchangeRateStored = 1e18;
        lastExchangeRateAt = block.timestamp;
    }

    function mint() external payable override {
        uint256 _shares = (msg.value * 1e18) / _exchangeRateCurrent();
        _mint(msg.sender, _shares);
    }

    function redeem(uint256 redeemTokens) external override returns (uint256) {
        uint256 _amount = (redeemTokens * _exchangeRateCurrent()) / 1e18;
        _burn(msg.sender, redeemTokens);

        payable(msg.sender).transfer(_amount);
        return 0;
    }

    function balanceOfUnderlying(address account) external returns (uint256) {
        return (balanceOf(account) * _exchangeRateCurrent()) / 1e18;
    }

    function exchangeRateCurrent() external returns (uint256) {
        return _exchangeRateCurrent();
    }

    function _exchangeRateCurrent() internal returns (uint256) {
        uint256 _currentExchangeRate = (exchangeRateStored * (1e18 + ((block.timestamp - lastExchangeRateAt) * 1e8))) / 1e18;
        exchangeRateStored = _currentExchangeRate;
        lastExchangeRateAt = block.timestamp;
        return _currentExchangeRate;
    }

    function getCash() external override returns (uint256) {
        return (90 * totalSupply()) / 100;
    }
}",406
RealWorld_BA_101_PCLActiveStage.t_RealWord_20240827093222.log,101,PCLActiveStage.t,8206,5068,13274,67.0,0.14239,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '../PCLActiveStage.t.sol';

contract PCLActiveStageCollateralCompoundBorrowNoYield is PCLActiveStage {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    function setUp() public override {
        PCLParent.setUp();

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * (10**ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = compoundYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);
    }
}",324
RealWorld_BA_101_PCLCancelledStage.t_RealWord_20240827095420.log,101,PCLCancelledStage.t,10482,5222,15704,69.0,0.15685,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '../PCLStageTests/PCLCancelledStage.t.sol';

contract PCLCancelledStageZeroCollateral is PCLCancelledStage {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    function setUp() public override {
        PCLParent.setUp();

        request.borrowLimit = uint128(1_000_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * 1e18) / 1e2);
        request.collateralRatio = 0;
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * 1e18) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        // Lend any amount lesser than the borrowLimit
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);

        lender_0 = lenders[0].lenderAddress;

        // Let's travel a few days, but stay within the collection period
        vm.warp(block.timestamp + request.collectionPeriod / 2);

        // Borrower tries to cancel the PCL
        borrower.cancelRequest(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CANCELLED, '!CANCELLED');
    }
}",441
RealWorld_BA_101_PCLExpiredStage.t_RealWord_20240827101121.log,101,PCLExpiredStage.t,14991,5809,20800,82.0,0.191135,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '../../PCLStageTests/PCLExpiredStage.t.sol';

contract PCLExpiredStageZeroCollateralBorrowCompound is PCLExpiredStage {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    function setUp() public override {
        PCLParent.setUp();

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = 0;
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 5000 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 3650 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = compoundYieldAddress;
        request.collateralAssetStrategy = compoundYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, type(uint256).max);
        if (request.collateralRatio != 0) {
            borrower.depositCollateral(requestId, _requiredCollateral, false);
        }
        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);
        // and borrows the borrowable amount
        borrower.borrow(requestId, borrowableAmount);

        // Borrower decides to repay everything at mid-duration

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 2);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, currentDebt / 2);

        // Now we travel past the duration to the expiration period
        vm.warp(block.timestamp + 100 + request.duration / 2);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');
    }
}",718
RealWorld_BA_101_PCLActiveState.t_RealWord_20240827091832.log,101,PCLActiveState.t,0,0,0,,0.0,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';

import '../Helpers/PCLParent.t.sol';

contract PCLActiveStateCToken is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 _borrowAssetDecimals;
    uint256 _collateralAssetDecimals;
    uint128 _collateralAssetPriceMin;
    uint128 _borrowAssetPriceMin;
    uint128 _collateralAssetPriceMax;
    uint128 _borrowAssetPriceMax;
    uint256 requestId;
    uint256 _fromUserPoolTokenSupply;
    uint256 _toUserPoolTokenSupply;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;
    uint256 _calculatedCurrentDebt;
    uint256 _fetchedCurrentDebt;

    function setUp() public override {
        super.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();
        _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));
        _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));

        _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();
        _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));
        _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 5000 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = compoundYieldAddress;
        request.collateralAssetStrategy = compoundYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');
    }

    // Test 0: Test SetUp
    function test_setUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        uint256 _borrowCTokenExchangeRate = MockCToken(borrowCTokenAddress).exchangeRateCurrent();
        uint256 _collateralCTokenExchangeRate = MockCToken(collateralCTokenAddress).exchangeRateCurrent();

        // Checking out what are the exchange rates
        log_named_int('Borrow CToken Exchange Rate', int256(_borrowCTokenExchangeRate));
        log_named_int('Collateral CToken Exchange Rate', int256(_collateralCTokenExchangeRate));

        // Check the exchange rates of the borrow and collateral CTokens are non-zero
        assertGt(_borrowCTokenExchangeRate, 0);
        assertGt(_collateralCTokenExchangeRate, 0);
    }

    // Test 1: An active PCL cannot be started even with exchange rate fluctuations
    function test_pclCannotBeStarted() public {
        helper_exchangeRateChanges();

        try borrower.start(requestId) {
            revert('Cannot start an Active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S1');
        }
    }

    // Test 2: Collateral can be deposited
    function test_collateralCanBeDeposited() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        helper_exchangeRateChanges();
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        assertGt(pcl.depositedCollateralInShares(requestId), 0);
    }

    // Test 3: Withdrawable collateral increases if collateral CToken exchange rate increases steeply
    function test_withdrawableCollateralIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertLt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.1: Withdrawable collateral decreases if collateral CToken exchange rate increases very slowly
    // increase slowly wrt to interest rate of the pcl
    function test_withdrawableCollateralDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertGt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.2: Withdrawable collateral remains unchanged if borrow CToken exchange rate decreases to zero
    function test_withdrawableCollateralRemainsSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertEq(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.3: Withdrawable collateral reverts if collateral CToken exchange rate decreases to zero
    function test_withdrawableCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try pcl.withdrawableCollateral(requestId) {
            revert('Withdrawable collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 4: Withdraw collateral works if collateral CToken exchange rate increases steeply
    function test_withdrawCollateralWorksIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);
    }

    // Test 4.1: Withdraw collateral works if borrow CToken exchange rate increases steeply
    function test_withdrawCollateralWorksIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);

        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);
        uint256 _additionalDebtCollateral = _interestAccrued.mul(request.collateralRatio).div(_ratioOfPrices).mul(10**_decimals).div(1e18);

        borrower.withdrawCollateral(requestId, _withdrawableCollateral - _additionalDebtCollateral, false);
    }

    // Test 4.2: Withdraw collateral works if borrow CToken exchange rate decreases to zero
    function test_withdrawCollateralWorksIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);
    }

    // Test 4.3: Withdraw collateral reverts if collateral CToken exchange rate decreases to zero
    function test_withdrawCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {
            revert('Withdrawable collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 5: Withdraw all collateral works if collateral CToken exchange rate increases steeply
    function test_withdrawAllCollateralWorksIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        borrower.withdrawAllCollateral(requestId, false);
    }

    // Test 5.1: Withdraw all collateral works if borrow CToken exchange rate increases steeply
    function test_withdrawAllCollateralWorksIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_increaseExchangeRateSteeply(borrowCTokenAddress);
        borrower.withdrawAllCollateral(requestId, false);
    }

    // Test 5.2: Withdraw all collateral works if borrow CToken exchange rate decreases to zero
    function test_withdrawAllCollateralWorksIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        borrower.withdrawAllCollateral(requestId, false);
    }

    // Test 5.3: Withdraw all collateral reverts if collateral CToken exchange rate decreases to zero
    function test_withdrawAllCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try borrower.withdrawAllCollateral(requestId, false) {
            revert('Withdrawable collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 6: An active PCL (with principal == 0) can be closed even with exchange rate fluctuations
    function test_pclCanBeClosedIfPrincipalIsZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        helper_exchangeRateChanges();
        borrower.close(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed');
    }

    // Test 6.1: An active PCL (with principal != 0) cannot be closed even with exchange rate fluctuations
    function test_pclCannotBeClosedPrincipalIsNonZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');

        // Now let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        // Exchange rate fluctuations take place
        helper_exchangeRateChanges();

        try borrower.close(requestId) {
            revert('Cannot close PCL when principal != 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C2');
        }
    }

    // Test 7: Required collateral remains same if collateral CToken exchange rate increases steeply
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.1: Required collateral remains same if borrow CToken exchange rate increases steeply
    function test_requiredCollateralRemainsSameIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.2: Required collateral remains same if borrow CToken exchange rate decreases to zero
    function test_requiredCollateralRemainSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.3: Required collateral remains same if collateral CToken exchange rate decreases to zero
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.4: Required collateral remains same if collateral CToken exchange rate increases very slowly
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 8: Collateral tokens increases if collateral CToken exchange rate increases steeply
    function test_totalCollateralTokensIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _collateralTokensNew = pcl.calculateTotalCollateralTokens(requestId);

        assertLt(_collateralTokens, _collateralTokensNew);
    }

    // Test 8.1: Collateral tokens reverts if collateral CToken exchange rate decreases to zero
    function test_totalCollateralTokensRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try pcl.calculateTotalCollateralTokens(requestId) {
            revert('Total collateral tokens should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 9: Collateral ratio increases if collateral CToken exchange rate increases steeply
    function test_collateralRatioIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, _collateralRatioNew);
    }

    // Test 9.1: Collateral ratio increases if borrow CToken exchange rate increases steeply
    function test_collateralRatioIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);

        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, (_collateralRatioNew * (_currentDebt + _interestAccrued)) / _currentDebt);
    }

    // Test 9.2: Collateral ratio remains same if borrow CToken exchange rate decreases to zero
    function test_collateralRatioRemaisSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertEq(_collateralRatio, _collateralRatioNew);
    }

    // Test 9.3: Collateral ratio reverts if collateral CToken exchange rate decreases to zero
    function test_collateralRatioRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try pcl.calculateCurrentCollateralRatio(requestId) {
            revert('Collateral ratio should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 9.4: Collateral ratio decreases if collateral CToken exchange rate increases very slowly
    function test_collateralRatioDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertGt(_collateralRatio, _collateralRatioNew);
    }

    // Test 10: An active PCL cannot be cancelled if principal == 0
    function test_borrowerCannotCancelActivePCLPrincipalIsZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        helper_exchangeRateChanges();

        try borrower.cancelRequest(requestId) {
            revert('Cannot cancel an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    // Test 10.1: An active PCL cannot be cancelled if principal != 0
    function test_borrowerCannotCancelActivePCLPrincipalIsNonZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_exchangeRateChanges();

        try borrower.cancelRequest(requestId) {
            revert('Cannot cancel an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    // Test 11: Admin should be able to terminate an ACTIVE PCL with principal == 0
    function test_adminCanTerminatePCLPrincipalIsZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        helper_exchangeRateChanges();

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        // Admin terminates the PCL
        admin.terminate(requestId);

        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertTrue((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate) == 0); // Since no collateral was ever deposited
        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0);
    }

    // Test 11.1: Admin should be able to terminate an ACTIVE PCL with principal != 0
    function test_adminCanTerminatePCLPrincipalIsNonZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_exchangeRateChanges();

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        // Admin terminates the PCL
        admin.terminate(requestId);

        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0); // Since collateral was also extracted
        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); // Since the lent amount (which was still in the PCL/LP contracts) were extracted
    }

    // Test 12: Borrowable amount increases if collateral CToken exchange rate increases steeply
    function test_borrowableAmountIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertLt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 12.1: Borrowable amount increases if borrow CToken exchange rate increases steeply
    function test_borrowableAmountIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);

        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertLt(_borrowableAmount, _borrowableAmountNew + _interestAccrued);
    }

    // Test 12.2: Borrowable amount remains same if borrow CToken exchange rate decreases to zero
    function test_borrowableAmountRemainsSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertEq(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 12.3: Borrowable amount reverts if collateral CToken exchange rate decreases to zero
    function test_borrowableAmountRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try pcl.calculateBorrowableAmount(requestId) {
            revert('Borrowable amount should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 12.4: Borrowable amount decreases if collateral CToken exchange rate increases very slowly
    function test_borrowableAmountDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertGt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 13: Borrower can repay
    function test_borrowerCanRepay() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_exchangeRateChanges();
        admin.transferToken(address(borrowAsset), address(borrower), 1);
        borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, 1);
    }

    // Test 14: An active PCL cannot be liquidated if principal == 0
    function test_lendersCannotLiquidateIfPrincipalIsZero(bool _withdraw) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_exchangeRateChanges();

        // _lender0 tries to liquidate the PCL
        try _lender0.liquidate(requestId, _withdraw) {
            revert('Cannot liquidate an Active PCL with principal == 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L1');
        }
    }

    // Test 14.1: An active PCL cannot be liquidated if collateral CToken exchange rate increases steeply
    function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an Active PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.2: An active PCL cannot be liquidated if borrow CToken exchange rate increases steeply
    function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_increaseExchangeRateSteeply(borrowCTokenAddress);
        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an Active PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.3: An active PCL cannot be liquidated if borrow CToken exchange rate decreases to zero
    function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateDecreasesToZero() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an Active PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.4: An active PCL cannot be liquidated if collateral CToken exchange rate decreases to zero
    function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateDecreasesToZero() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an Active PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 14.5: An active PCL can be liquidated if collateral CToken exchange rate increases very slowly
    function test_lendersCanLiquidateIfCollateralCTokenExchangeRateIncreasesVerySlowly() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, pcl.calculateBorrowableAmount(requestId));

        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        _lender0.liquidate(requestId, false);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
    }

    // Test 15: Lenders cannot withdraw liquidation from an ACTIVE pcl
    function test_lendersCannotWithdrawLiquidation() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_exchangeRateChanges();

        try _lender0.withdrawTokensAfterLiquidation(requestId) {
            revert('Cannot withdraw liquidation from an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    // Test 16: Lenders cannot withdraw liquidity from an ACTIVE pcl
    function test_lendersCannotWithdrawLiquidity() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_exchangeRateChanges();

        try _lender0.withdrawLiquidity(requestId) {
            revert('Cannot withdraw liquidity from an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL3');
        }
    }

    // Test 17: Pool token transfers should be possible in an Active PCL
    function test_poolTokenTransfersShouldBePossibleEntireBalance() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);

        //Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, 0);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == 0);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));
    }

    // Test 17.1: Pool token transfers should be possible in an Active PCL
    function test_poolTokenTransfersShouldBePossiblePartialBalance() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 17.2: Pool token transfers should be possible in an Active PCL and principal != 0
    function test_poolTokenTransfersShouldBePossiblePartialBalancePrincipalIsNonZero() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 18: Interest can be withdrawn amidst price fluctuations
    function test_lendersCanWithdrawInterest() public {
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 _collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), _collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, _collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        // Borrower makes their first repayment (Entire pending interest + part of principal)
        vm.warp(block.timestamp + 1000);
        {
            borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));
            uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);
            admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);
            borrower.repay(requestId, interestAccrued + 10);
        }

        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender0Balance = borrowAsset.balanceOf(address(lender0));

        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender1Balance = borrowAsset.balanceOf(address(lender1));

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender0));
        uint256 lender1InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender1));

        lender0.withdrawInterest(requestId);

        uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(lender0));
        assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);

        helper_exchangeRateChanges();

        lender1.withdrawInterest(requestId);

        uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(lender1));
        assertGt((lender1BalanceFinal - lender1Balance), lender1InterestOwed);
    }

    // Test 18.1: Interest that can be withdrawn increases
    function test_lenderInterestIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 _collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), _collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, _collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        vm.warp(block.timestamp + 1000);
        // Borrower makes their first repayment (Entire pending interest + part of principal)
        {
            borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));
            uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);
            admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);
            borrower.repay(requestId, interestAccrued + 10);
        }

        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender0));
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);

        uint256 lender0InterestOwedNew = lp.getLenderInterestWithdrawable(requestId, address(lender0));
        assertLt(lender0InterestOwed, lender0InterestOwedNew);
    }

    uint256 _principal;
    uint256 _currentCR1;
    uint256 _currentCR2;
    uint256 _currentCR3;
    uint256 _principalWithdrawable;
    uint256 _withdrawableCollateral;
    uint256 _currentDebt;
    uint256 _borrowable;
    uint256 _totalCollateral;
    uint256 _equivalentCollateral;
    uint256 _interestAccrued;

    uint256 collateralToDeposit;

    function assert_helperFunctionalitiesInActiveStateZeroPrincipal(uint256 _id) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 1. calculateCurrentCollateralRatio
        _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);
        assertEq(_currentCR1, uint256(-1)); // Since borrower has not yet borrowed anything

        helper_exchangeRateChanges();

        // 2. calculatePrincipalWithdrawable
        _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
        assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an active PCL

        helper_exchangeRateChanges();

        // 3. withdrawableCollateral
        _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertEq(_withdrawableCollateral, 0); // Since no collateral was deposited in the first place

        helper_exchangeRateChanges();

        // 4. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        assertEq(_currentDebt, 0); // Since nothing was borrowed

        helper_exchangeRateChanges();

        // 5. calculateBorrowableAmount
        _borrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_borrowable, 0); // Since collateral was not deposited

        helper_exchangeRateChanges();

        // 6. calculateTotalCollateralTokens
        _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertEq(_totalCollateral, 0); // Since no collateral was deposited

        helper_exchangeRateChanges();

        // 7. collateralTokensToLiquidate
        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
        assertGt(_equivalentCollateral, 0);

        helper_exchangeRateChanges();

        // 8. calculateInterestAccrued
        _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertEq(_interestAccrued, 0); // Since borrower did not borrow anything

        helper_exchangeRateChanges();
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
    }

    function assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(uint256 _id) public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);

        // 1. calculateCurrentCollateralRatio
        _currentCR2 = _borrower.calculateCurrentCollateralRatio(_id);
        assertLt(_currentCR2, uint256(-1));
        assertGt(_currentCR2, request.collateralRatio);

        helper_increaseExchangeRateSteeply(collateralCTokenAddress);

        _currentCR3 = _borrower.calculateCurrentCollateralRatio(_id);
        assertGt(_currentCR3, _currentCR2);

        helper_exchangeRateChanges();

        // 2. calculatePrincipalWithdrawable
        _principalWithdrawable = _borrower.calculatePrincipalWithdrawable(_id, address(_lender));
        assertEq(_principalWithdrawable, 0); // Since lenders cannot withdraw funds from an active PCL

        helper_exchangeRateChanges();

        // 3. withdrawableCollateral
        _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertGe(_withdrawableCollateral, 0); // Since we had deposited twice the reqired collateral

        helper_exchangeRateChanges();

        // 4. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        assertGt(_currentDebt, 0);

        helper_exchangeRateChanges();

        // 5. calculateBorrowableAmount
        _borrowable = _borrower.calculateBorrowableAmount(_id);
        assertGe(_borrowable, 0);

        helper_exchangeRateChanges();

        // 6. calculateTotalCollateralTokens
        _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertGt(_totalCollateral, 0);

        // 7. collateralTokensToLiquidate
        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
        assertGt(_equivalentCollateral, 0);

        helper_exchangeRateChanges();

        // 8. calculateInterestAccrued
        _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGt(_interestAccrued, 0); // Since borrower did borrow

        helper_exchangeRateChanges();
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
    }

    function test_helperFunctionsInActiveState() public {
        assert_helperFunctionalitiesInActiveStateZeroPrincipal(requestId);
    }

    function test_helperFunctionsInActiveStateNonZeroPrincipal() public {
        assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(requestId);
    }
}",15517
RealWorld_BA_101_PCLExpiredState.t_RealWord_20240827102151.log,101,PCLExpiredState.t,0,0,0,,0.0,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';

import '../Helpers/PCLParent.t.sol';

contract PCLExpiredStatePriceOracle is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 _borrowAssetDecimals;
    uint256 _collateralAssetDecimals;
    uint128 _collateralAssetPriceMin;
    uint128 _borrowAssetPriceMin;
    uint128 _collateralAssetPriceMax;
    uint128 _borrowAssetPriceMax;
    uint256 requestId;
    uint256 _fromUserPoolTokenSupply;
    uint256 _toUserPoolTokenSupply;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;
    uint256 _calculatedCurrentDebt;
    uint256 _fetchedCurrentDebt;

    function setUp() public virtual override {
        super.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();
        _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));
        _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));

        _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();
        _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));
        _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        // Now we assert that we are in the ACTIVE state
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), 2);

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);
        borrower.depositCollateral(requestId, _requiredCollateral, false);

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);
        // and borrows the borrowable amount
        borrower.borrow(requestId, borrowableAmount);

        // Borrower decides to repay everything at mid-duration

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 2);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt / 2);
        borrower.repay(requestId, currentDebt / 2);

        // Now we travel past the duration to the expiration period
        vm.warp(block.timestamp + 100 + request.duration / 2);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');
    }

    // Test 0: Test SetUp
    function test_setUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');

        (, int256 _borrowAssetPrice, , , ) = MockV3Aggregator(borrowAssetAggregatorAddress).latestRoundData();
        (, int256 _collateralAssetPrice, , , ) = MockV3Aggregator(collateralAssetAggregatorAddress).latestRoundData();

        // Checking out what are the prices
        log_named_int('Borrow Asset Price', _borrowAssetPrice);
        log_named_int('Collateral Asset Price', _collateralAssetPrice);

        // Check the prices of the borrowAsset and collateralAsset are non-zero
        assertGt(_borrowAssetPrice, 0);
        assertGt(_collateralAssetPrice, 0);
    }

    // Test 1: An expired PCL cannot be started even with price fluctuations
    function test_pclCannotBeStarted(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try borrower.start(requestId) {
            revert('Cannot start an expired PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S1');
        }
    }

    // Test 2: Collateral can be deposited
    function test_collateralCanBeDeposited(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        assertGt(pcl.depositedCollateralInShares(requestId), 0);
    }

    // Test 3: Withdrawable collateral remains zero
    function test_withdrawableCollateralRemainsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertEq(_withdrawableCollateralNew, 0);
    }

    // Test 4: Withdraw collateral should revert
    function test_withdrawCollateralShouldNotBePossible(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try borrower.withdrawCollateral(requestId, 1, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC1');
        }
    }

    // Test 4.1: Withdraw all collateral should revert
    function test_withdrawAllCollateralShouldNotBePossible(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try borrower.withdrawAllCollateral(requestId, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WAC1');
        }
    }

    // Test 4.2
    function test_withdrawAllCollateralIsPossibleAfterRepay(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');

        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay entire debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt);

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal == 0, 'Principal != 0');

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed');
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        uint256 balanceBefore = collateralAsset.balanceOf(address(borrower));
        borrower.withdrawAllCollateral(requestId, false);
        assertGt(collateralAsset.balanceOf(address(borrower)), balanceBefore);
    }

    // Test 5: An expired PCL (with principal == 0) can be closed even with price fluctuations
    function test_pclCanBeClosedIfPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');

        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay entire debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt);

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal == 0, 'Principal != 0');

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed');
    }

    // Test 5.1: An expired PCL (with principal != 0) cannot be closed even with price fluctuations
    function test_pclCannotBeClosedPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');

        // Price fluctuations take place
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try borrower.close(requestId) {
            revert('Cannot close PCL when principal != 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C2');
        }
    }

    // Test 6: Required collateral decreases if collateral asset price increases
    function test_requiredCollateralDecreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertGt(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 6.1: Required collateral increases if borrow asset price increases
    function test_requiredCollateralIncreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertLt(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 6.2: Required collateral increases if collateral asset price decreases
    function test_requiredCollateralIncreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertLt(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 6.3: Required collateral decreases if borrow asset price decreases
    function test_requiredCollateralDecreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertGt(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 6.4: Required collateral reverts if borrow asset price decreases to 0
    function test_requiredCollateralRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);

        try pcl.getRequiredCollateral(requestId, request.borrowLimit / 2) {
            revert('Required collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 6.5: Required collateral reverts if collateral asset price decreases to 0
    function test_requiredCollateralRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);

        try pcl.getRequiredCollateral(requestId, request.borrowLimit / 2) {
            revert('Required collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 7: Collateral ratio decreases if collateral asset price decreases
    function test_collateralRatioDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertGt(_collateralRatio, _collateralRatioNew);
    }

    // Test 7.1: Collateral ratio decreases if borrow asset price increases
    function test_collateralRatioDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertGt(_collateralRatio, _collateralRatioNew);
    }

    // Test 7.2: Collateral ratio increases if collateral asset price increases
    function test_collateralRatioIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, _collateralRatioNew);
    }

    // Test 7.3: Collateral ratio increases if borrow asset price decreases
    function test_collateralRatioIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, _collateralRatioNew);
    }

    // Test 7.4: Collateral ratio reverts if borrow asset price decreases to 0
    function test_collateralRatioRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);

        try pcl.calculateCurrentCollateralRatio(requestId) {
            revert('Collateral ratio should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 7.5: Collateral ratio reverts if collateral asset price decreases to 0
    function test_collateralRatioRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);

        try pcl.calculateCurrentCollateralRatio(requestId) {
            revert('Collateral ratio should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 8: Lenders cannot withdraw liquidation from an expired pcl
    function test_lendersCannotWithdrawLiquidation(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try _lender0.withdrawLiquidation(requestId) {
            revert('Cannot withdraw liquidation from an expired PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    // Test 9: Lenders cannot withdraw liquidity from an expired pcl
    function test_lendersCannotWithdrawLiquidity(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try _lender0.withdrawLiquidity(requestId) {
            revert('Cannot withdraw liquidity from an expired PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL3');
        }
    }

    // Test 10: An expired  PCL cannot be liquidated if principal == 0
    function test_lendersCannotLiquidateIfPrincipalIsZero(
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed,
        bool _withdraw
    ) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');

        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay entire debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt);

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal == 0, 'Principal != 0');

        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // _lender0 tries to liquidate the PCL
        try _lender0.liquidate(requestId, _withdraw) {
            revert('Cannot liquidate an expired PCL with principal == 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L1');
        }
    }

    // Test 10.1: An expired PCL with principal != 0 can or cannot be liquidated
    function test_lendersCanOrCannotLiquidate(
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed,
        bool _withdraw
    ) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        // Relative price fluctuations
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
        uint256 _currentCollateralRatio = pcl.calculateTotalCollateralTokens(requestId).mul(_ratioOfPrices).div(_currentDebt).mul(1e18).div(
            10**_decimals
        );

        if (_currentCollateralRatio < request.collateralRatio) {
            // assert liquidated
            _lender0.liquidate(requestId, false);
            assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
        } else {
            // asset not liquidated
            try _lender0.liquidate(requestId, _withdraw) {
                revert('Cannot liquidate an expired PCL with CR >= ICR');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:L3');
            }
        }
    }

    // Test 10.2: An expired PCL cannot be liquidated if principal != 0 but CR >= ICR
    function test_lendersCannotLiquidateIfIdealCollateralRatioIsNotBreached(
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed,
        bool _withdraw
    ) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');

        // Small price fluctuations
        helper_smallPriceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // _lender0 tries to liquidate the PCL
        try _lender0.liquidate(requestId, _withdraw) {
            revert('Cannot liquidate an expired PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 10.3: An expired PCL can be liquidated if principal != 0 and CR < ICR
    function test_lendersCanLiquidateIfCollateralAssetPriceDecreasesSteeply() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');

        helper_decreaseCollateralAssetPriceSteeply();
        _lender0.liquidate(requestId, false);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
    }

    // Test 10.4: An expired PCL can be liquidated if principal != 0 and CR < ICR
    function test_lendersCanLiquidateIfBorrowAssetPriceIncreasesSteeply() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');

        helper_increaseBorrowAssetPriceSteeply();
        _lender0.liquidate(requestId, false);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
    }

    // Test 11.2: Admin should be able to terminate an expired PCL
    function test_adminCanTerminatePCL(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        // Admin terminates the PCL
        admin.terminate(requestId);

        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0); // Since collateral was also extracted
        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); // Since the lent amount (which was still in the PCL/LP contracts) were extracted
    }

    // Test 12.1: Pool token transfers should be possible in an expired PCL
    function test_poolTokenTransfersShouldBePossibleEntireBalance(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);

        //Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, 0);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == 0);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));
    }

    // Test 12.2: Pool token transfers should be possible in an expired PCL
    function test_poolTokenTransfersShouldBePossiblePartialBalance(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed)
        public
    {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == (3 * lender2PoolTokenBalance) / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 13: Interest can be withdrawn amidst price fluctuations
    function test_lendersCanWithdrawInterest(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender0Balance = borrowAsset.balanceOf(address(lender0));

        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender1Balance = borrowAsset.balanceOf(address(lender1));

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lender0.getLenderInterest(requestId, address(lender0));
        uint256 lender1InterestOwed = lender1.getLenderInterest(requestId, address(lender1));

        lender0.withdrawInterest(requestId);

        uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(lender0));
        assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        lender1.withdrawInterest(requestId);

        uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(lender1));
        assertEq((lender1BalanceFinal - lender1Balance), lender1InterestOwed);
    }

    // Test 14: An expired PCL cannot be cancelled
    function test_borrowerCannotCancel(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try borrower.cancelRequest(requestId) {
            revert('Cannot cancel an expired PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    // Test 15: Borrowable amount remains zero
    function test_borrowableAmountRemainsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        assertEq(_borrowableAmount, 0);
    }

    // Test 16: Borrower can repay
    function test_borrowerCanRepay(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        admin.transferToken(address(borrowAsset), address(borrower), 1);
        borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, 1);
    }

    function assert_helperFunctionalitiesInExpiredState(
        uint256 _id,
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed
    ) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 1. calculateCurrentCollateralRatio
        {
            uint256 _currentCR2 = _borrower.calculateCurrentCollateralRatio(_id);
            assertLt(_currentCR2, uint256(-1));
            assertGt(_currentCR2, request.collateralRatio);

            helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _collateralAssetPriceSeed);

            uint256 _currentCR3 = _borrower.calculateCurrentCollateralRatio(_id);
            assertLt(_currentCR3, _currentCR2);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 2. calculatePrincipalWithdrawable
        {
            uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
            assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an expired PCL
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 3. withdrawableCollateral
        {
            uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
            assertEq(_withdrawableCollateral, 0); // Since no collateral can be withdrawn in the expired state
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 4. calculateCurrentDebt
        {
            uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);
            assertGt(_currentDebt, 0);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 5. calculateBorrowableAmount
        {
            uint256 _borrowable = _borrower.calculateBorrowableAmount(_id);
            assertEq(_borrowable, 0); // Since the state is expired
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 6. calculateTotalCollateralTokens
        {
            uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
            assertGt(_totalCollateral, 0);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 7. collateralTokensToLiquidate
        {
            uint256 _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
            assertGt(_equivalentCollateral, 0);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 8. calculateInterestAccrued
        {
            uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
            assertGt(_interestAccrued, 0);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
    }

    function test_helperFunctionsInExpiredState(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        assert_helperFunctionalitiesInExpiredState(requestId, _borrowAssetPriceSeed, _collateralAssetPriceSeed);
    }

    function helper_decreaseCollateralAssetPriceSteeply() public clearMockedCalls {
        (
            uint80 _assetRoundId,
            int256 _assetPrice,
            uint256 _assetStartedAt,
            uint256 _assetUpdatedAt,
            uint80 _assetAnsweredInRound
        ) = MockV3Aggregator(collateralAssetAggregatorAddress).latestRoundData();

        vm.mockCall(
            collateralAssetAggregatorAddress,
            abi.encodeWithSelector(MockV3Aggregator.latestRoundData.selector),
            abi.encode(_assetRoundId, int256(_collateralAssetPriceMin / 2), _assetStartedAt, _assetUpdatedAt, _assetAnsweredInRound)
        );
    }

    function helper_increaseBorrowAssetPriceSteeply() public clearMockedCalls {
        (
            uint80 _assetRoundId,
            int256 _assetPrice,
            uint256 _assetStartedAt,
            uint256 _assetUpdatedAt,
            uint80 _assetAnsweredInRound
        ) = MockV3Aggregator(borrowAssetAggregatorAddress).latestRoundData();

        vm.mockCall(
            borrowAssetAggregatorAddress,
            abi.encodeWithSelector(MockV3Aggregator.latestRoundData.selector),
            abi.encode(_assetRoundId, int256(_borrowAssetPriceMax * 2), _assetStartedAt, _assetUpdatedAt, _assetAnsweredInRound)
        );
    }
}",8615
RealWorld_BA_101_PCLExpiredState.t_RealWord_20240827091739.log,101,PCLExpiredState.t,0,0,0,,0.0,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';

import '../Helpers/PCLParent.t.sol';

contract PCLExpiredStateCToken is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 _borrowAssetDecimals;
    uint256 _collateralAssetDecimals;
    uint128 _collateralAssetPriceMin;
    uint128 _borrowAssetPriceMin;
    uint128 _collateralAssetPriceMax;
    uint128 _borrowAssetPriceMax;
    uint256 requestId;
    uint256 _fromUserPoolTokenSupply;
    uint256 _toUserPoolTokenSupply;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;
    uint256 _calculatedCurrentDebt;
    uint256 _fetchedCurrentDebt;

    function setUp() public override {
        super.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();
        _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));
        _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));

        _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();
        _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));
        _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 5000 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 50 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = compoundYieldAddress;
        request.collateralAssetStrategy = compoundYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);
        borrower.depositCollateral(requestId, _requiredCollateral, false);

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);
        // and borrows the borrowable amount
        borrower.borrow(requestId, borrowableAmount);

        // Borrower decides to repay everything at mid-duration

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 2);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt / 2);
        borrower.repay(requestId, currentDebt / 2);

        // Now we travel past the duration to the expiration period
        vm.warp(block.timestamp + 100 + request.duration / 2);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');
    }

    // Test 0: Test SetUp
    function test_setUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');

        uint256 _borrowCTokenExchangeRate = MockCToken(borrowCTokenAddress).exchangeRateCurrent();
        uint256 _collateralCTokenExchangeRate = MockCToken(collateralCTokenAddress).exchangeRateCurrent();

        // Checking out what are the exchange rates
        log_named_int('Borrow CToken Exchange Rate', int256(_borrowCTokenExchangeRate));
        log_named_int('Collateral CToken Exchange Rate', int256(_collateralCTokenExchangeRate));

        // Check the exchange rates of the borrow and collateral CTokens are non-zero
        assertGt(_borrowCTokenExchangeRate, 0);
        assertGt(_collateralCTokenExchangeRate, 0);
    }

    // Test 1: An expired PCL cannot be started even with exchange rate fluctuations
    function test_pclCannotBeStarted() public {
        helper_exchangeRateChanges();

        try borrower.start(requestId) {
            revert('Cannot start an expired PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S1');
        }
    }

    // Test 2: Collateral can be deposited
    function test_collateralCanBeDeposited() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        helper_exchangeRateChanges();
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        assertGt(pcl.depositedCollateralInShares(requestId), 0);
    }

    // Test 3: Withdrawable collateral remains zero
    function test_withdrawableCollateralIsZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        assertEq(_withdrawableCollateral, 0);
    }

    // Test 4: Withdraw collateral should revert
    function test_withdrawCollateralShouldNotBePossible() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        try borrower.withdrawCollateral(requestId, 1, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC1');
        }
    }

    // Test 5: Withdraw all collateral should revert
    function test_withdrawAllCollateralShouldNotBePossible() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        try borrower.withdrawAllCollateral(requestId, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WAC1');
        }
    }

    // Test 6: An expired PCL (with principal == 0) can be closed even with exchange rate fluctuations
    function test_pclCanBeClosedIfPrincipalIsZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');

        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay entire debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt);

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal == 0, 'Principal != 0');

        helper_exchangeRateChanges();
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed');
    }

    // Test 6.1: An expired PCL (with principal != 0) cannot be closed even with exchange rate fluctuations
    function test_pclCannotBeClosedPrincipalIsNonZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');

        // Exchange rate fluctuations take place
        helper_exchangeRateChanges();

        try borrower.close(requestId) {
            revert('Cannot close PCL when principal != 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C2');
        }
    }

    // Test 7: Required collateral remains same if collateral CToken exchange rate increases steeply
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.1: Required collateral remains same if borrow CToken exchange rate increases steeply
    function test_requiredCollateralRemainsSameIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.2: Required collateral remains same if borrow CToken exchange rate decreases to zero
    function test_requiredCollateralRemainSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.3: Required collateral remains same if collateral CToken exchange rate decreases to zero
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.4: Required collateral remains same if collateral CToken exchange rate increases very slowly
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 8: Collateral tokens increases if collateral CToken exchange rate increases steeply
    function test_totalCollateralTokensIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);

        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _collateralTokensNew = pcl.calculateTotalCollateralTokens(requestId);

        assertLt(_collateralTokens, _collateralTokensNew);
    }

    // Test 8.1: Collateral tokens reverts if collateral CToken exchange rate decreases to zero
    function test_totalCollateralTokensRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);

        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try pcl.calculateTotalCollateralTokens(requestId) {
            revert('Total collateral tokens should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 9: Collateral ratio increases if collateral CToken exchange rate increases steeply
    function test_collateralRatioIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, _collateralRatioNew);
    }

    // Test 9.1: Collateral ratio increases if borrow CToken exchange rate increases steeply
    function test_collateralRatioIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);

        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, (_collateralRatioNew * (_currentDebt + _interestAccrued)) / _currentDebt);
    }

    // Test 9.2: Collateral ratio remains same if borrow CToken exchange rate decreases to zero
    function test_collateralRatioRemaisSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertEq(_collateralRatio, _collateralRatioNew);
    }

    // Test 9.3: Collateral ratio reverts if collateral CToken exchange rate decreases to zero
    function test_collateralRatioRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);

        try pcl.calculateCurrentCollateralRatio(requestId) {
            revert('Collateral ratio should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 9.4: Collateral ratio decreases if collateral CToken exchange rate increases very slowly
    function test_collateralRatioDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertGt(_collateralRatio, _collateralRatioNew);
    }

    // Test 10: An expired PCL cannot be cancelled
    function test_borrowerCannotCancel() public {
        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');

        helper_exchangeRateChanges();

        try borrower.cancelRequest(requestId) {
            revert('Cannot cancel an expired PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    // Test 11: Admin should be able to terminate an expired PCL
    function test_adminCanTerminatePCL() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED);

        helper_exchangeRateChanges();

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        // Admin terminates the PCL
        admin.terminate(requestId);

        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0);
        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0);
    }

    // Test 12: Borrowable amount remains zero
    function test_borrowableAmountIsZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);

        assertEq(_borrowableAmount, 0);
    }

    // Test 13: Borrower can repay
    function test_borrowerCanRepay() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        admin.transferToken(address(borrowAsset), address(borrower), 1);
        borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, 1);
    }

    // Test 14: An expired PCL cannot be liquidated if principal == 0
    function test_lendersCannotLiquidateIfPrincipalIsZero(bool _withdraw) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');

        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay entire debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt);

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal == 0, 'Principal != 0');

        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_exchangeRateChanges();

        // _lender0 tries to liquidate the PCL
        try _lender0.liquidate(requestId, _withdraw) {
            revert('Cannot liquidate an expired PCL with principal == 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L1');
        }
    }

    // Test 14.1: An expired PCL cannot be liquidated if collateral CToken exchange rate increases steeply
    function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt / 2);

        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);

        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an expired PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.2: An expired PCL cannot be liquidated if borrow CToken exchange rate increases steeply
    function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt - 10000);

        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);

        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an expired PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.3: An expired PCL cannot be liquidated if borrow CToken exchange rate decreases to zero
    function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt / 2);

        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);

        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an expired PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.4: An expired PCL cannot be liquidated if collateral CToken exchange rate decreases to zero
    function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt / 2);

        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);

        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an expired PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 14.5: An expired PCL can be liquidated if collateral CToken exchange rate increases very slowly
    function test_lendersCanLiquidateIfCollateralCTokenExchangeRateIncreasesVerySlowly() public {
        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);
        borrower.depositCollateral(_requestId, _requiredCollateral, false);

        uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);
        borrower.borrow(_requestId, borrowableAmount);

        vm.warp(block.timestamp + request.duration / 2);
        uint256 currentDebt = borrower.calculateCurrentDebt(_requestId);
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt / 2);
        borrower.repay(_requestId, currentDebt / 100);

        vm.warp(block.timestamp + 100 + request.duration / 2);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        _lender0.liquidate(_requestId, false);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.LIQUIDATED);
    }

    // Test 15: Lenders cannot withdraw liquidation from an expired pcl
    function test_lendersCannotWithdrawLiquidation() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_exchangeRateChanges();

        try _lender0.withdrawTokensAfterLiquidation(requestId) {
            revert('Cannot withdraw liquidation from an expired PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    // Test 16: Lenders cannot withdraw liquidity from an expired pcl
    function test_lendersCannotWithdrawLiquidity() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_exchangeRateChanges();

        try _lender0.withdrawLiquidity(requestId) {
            revert('Cannot withdraw liquidity from an expired PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL3');
        }
    }

    // Test 17: Pool token transfers should be possible in an expired PCL
    function test_poolTokenTransfersShouldBePossibleEntireBalance() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);

        //Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, 0);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == 0);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));
    }

    // Test 17.1: Pool token transfers should be possible in an expired PCL
    function test_poolTokenTransfersShouldBePossiblePartialBalance() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 18: Interest can be withdrawn amidst exchange rate fluctuations
    function test_lendersCanWithdrawInterest() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser _lender1 = PCLUser(lenders[1].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(_lender0), requestId);
        uint256 lender0Balance = borrowAsset.balanceOf(address(_lender0));

        uint256 lender1PoolTokenBalance = lp.balanceOf(address(_lender1), requestId);
        uint256 lender1Balance = borrowAsset.balanceOf(address(_lender1));

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender0));
        uint256 lender1InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender1));

        _lender0.withdrawInterest(requestId);

        uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(_lender0));
        assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);

        helper_exchangeRateChanges();

        _lender1.withdrawInterest(requestId);

        uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(_lender1));
        assertGt((lender1BalanceFinal - lender1Balance), lender1InterestOwed);
    }

    // Test 18.1: Interest that can be withdrawn increases
    function test_lenderInterestIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender0));
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);

        uint256 lender0InterestOwedNew = lp.getLenderInterestWithdrawable(requestId, address(_lender0));
        assertLt(lender0InterestOwed, lender0InterestOwedNew);
    }

    uint256 _principal;
    uint256 _currentCR1;
    uint256 _currentCR2;
    uint256 _currentCR3;
    uint256 _principalWithdrawable;
    uint256 _withdrawableCollateral;
    uint256 _currentDebt;
    uint256 _borrowable;
    uint256 _totalCollateral;
    uint256 _equivalentCollateral;
    uint256 _interestAccrued;

    uint256 collateralToDeposit;

    function assert_helperFunctionalitiesInExpiredState(uint256 _id) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 1. calculateCurrentCollateralRatio
        _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);
        assertLt(_currentCR2, uint256(-1));

        helper_exchangeRateChanges();

        // 2. calculatePrincipalWithdrawable
        _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
        assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an expired PCL

        helper_exchangeRateChanges();

        // 3. withdrawableCollateral
        _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertEq(_withdrawableCollateral, 0); // Since no collateral can be withdrawn in the expired state

        helper_exchangeRateChanges();

        // 4. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        assertGt(_currentDebt, 0);

        helper_exchangeRateChanges();

        // 5. calculateBorrowableAmount
        _borrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_borrowable, 0); // Since the state is expired

        helper_exchangeRateChanges();

        // 6. calculateTotalCollateralTokens
        _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertGt(_totalCollateral, 0);

        helper_exchangeRateChanges();

        // 7. collateralTokensToLiquidate
        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
        assertGt(_equivalentCollateral, 0);

        helper_exchangeRateChanges();

        // 8. calculateInterestAccrued
        _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGt(_interestAccrued, 0);

        helper_exchangeRateChanges();
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
    }

    function test_helperFunctionalitiesInExpiredState() public {
        assert_helperFunctionalitiesInExpiredState(requestId);
    }
}",8576
RealWorld_BA_101_PCLNotCreatedStage.t_RealWord_20240827092430.log,101,PCLNotCreatedStage.t,111984,5936,117920,97.0,0.67864,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';
import '../Helpers/PCLParent.t.sol';

contract PCLNotCreatedStage is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 requestId;
    uint256 notCreatedRequestId;

    function setUp() public virtual override {
        super.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * (10**ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);

        // Create a few lenders
        createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount + 1), request.borrowAsset);

        notCreatedRequestId = requestId + 1;
        assertTrue(pcl.getStatusAndUpdate(notCreatedRequestId) == PooledCreditLineStatus.NOT_CREATED);
    }

    // Test1: Test setup
    function test_setUp() public {
        assertTrue(pcl.getStatusAndUpdate(notCreatedRequestId) == PooledCreditLineStatus.NOT_CREATED);
    }

    /*************************************************************************************************************************************
    START function calls
    *************************************************************************************************************************************/

    function assert_start_functionality_in_notCreated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.start(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.NOT_CREATED);
    }

    function test_adminCannotStartANotCreatedPCL() public {
        assert_start_functionality_in_notCreated_state(notCreatedRequestId, admin, 'Admin cannot start a PCL in notCreated state', 'LP:S1');
    }

    function test_borrowerCannotStartANotCreatedPCL() public {
        assert_start_functionality_in_notCreated_state(
            notCreatedRequestId,
            borrower,
            'Borrower cannot start a PCL in notCreated state',
            'LP:S1'
        );
    }

    function test_lenderCannotStartANotCreatedPCL() public {
        assert_start_functionality_in_notCreated_state(
            notCreatedRequestId,
            PCLUser(lenders[0].lenderAddress), // This lender is from a different PCL with requestId, since lenders for PCL with notCreatedRequestId do not exist
            'Lender cannot start a PCL in notCreated state',
            'LP:S1'
        );
    }

    /**************************************************************************************************************************************
    CANCEL function tests
    **************************************************************************************************************************************/

    function assert_cancel_functionality_in_notCreated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.cancelRequest(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.NOT_CREATED);
    }

    function test_adminCannotCancelANotCreatedPCL() public {
        assert_cancel_functionality_in_notCreated_state(
            notCreatedRequestId,
            admin,
            'Admin cannot Cancel a PCL in notCreated state',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotCancelANotCreatedPCL() public {
        assert_cancel_functionality_in_notCreated_state(
            notCreatedRequestId,
            borrower,
            'Borrower cannot Cancel a PCL in notCreated state',
            'PCL:OCLB1'
        );
    }

    function test_lenderCannotCancelANotCreatedPCL() public {
        assert_cancel_functionality_in_notCreated_state(
            notCreatedRequestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot Cancel a PCL in notCreated state',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    CLOSE function calls
    *************************************************************************************************************************************/

    function assert_close_functionality_in_notCreated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.close(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.NOT_CREATED);
    }

    function test_adminCannotCloseANotCreatedPCL() public {
        assert_close_functionality_in_notCreated_state(notCreatedRequestId, admin, 'Admin cannot close a notCreated PCL', 'PCL:OCLB1');
    }

    function test_borrowerCannotCloseANotCreatedPCL() public {
        assert_close_functionality_in_notCreated_state(
            notCreatedRequestId,
            borrower,
            'Borrower cannot close a notCreated PCL',
            'PCL:OCLB1'
        );
    }

    function test_lenderCannotCloseANotCreatedPCL() public {
        assert_close_functionality_in_notCreated_state(
            notCreatedRequestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot close a notCreated PCL',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    Deposit collateral function calls
    *************************************************************************************************************************************/

    function assert_collateralCannotBeDepositedInNotCreatedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _depositor,
        bool _isDepositorLender
    ) public {
        if (_isDepositorLender) {
            _depositor = PCLUser(lenders[0].lenderAddress);
        }

        admin.transferToken(address(collateralAsset), address(_depositor), _amount);
        _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);

        try _depositor.depositCollateral(_id, _amount, false) {
            revert('Collateral cannot be deposited in the NotCreated state');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:DC2');
        }
    }

    function test_borrowerCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInNotCreatedState(notCreatedRequestId, _amountToDeposit, borrower, true);
    }

    function test_lenderCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInNotCreatedState(notCreatedRequestId, _amountToDeposit, PCLUser(address(0)), true);
    }

    function test_adminCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInNotCreatedState(notCreatedRequestId, _amountToDeposit, admin, false);
    }

    /*************************************************************************************************************************************
    Borrow function tests
    *************************************************************************************************************************************/

    function assertBorrowFunctionalityInNotCreatedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.borrow(_id, _amount) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotBorrow() public {
        assertBorrowFunctionalityInNotCreatedState(
            notCreatedRequestId,
            1,
            admin,
            uint256(PooledCreditLineStatus.NOT_CREATED),
            'Admin cannot borrow a PCL in NotCreated state',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotBorrowANotCreatedPCL() public {
        assertBorrowFunctionalityInNotCreatedState(
            notCreatedRequestId,
            1,
            borrower,
            uint256(PooledCreditLineStatus.NOT_CREATED),
            'Borrower cannot borrow a PCL in NotCreated state',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotBorrowZeroAmount() public {
        assertBorrowFunctionalityInNotCreatedState(
            notCreatedRequestId,
            0,
            borrower,
            uint256(PooledCreditLineStatus.NOT_CREATED),
            'Borrower cannot borrow a PCL in NotCreated state',
            'PCL:OCLB1'
        );
    }

    function test_lenderCannotBorrow() public {
        assertBorrowFunctionalityInNotCreatedState(
            notCreatedRequestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.NOT_CREATED),
            'Lender cannot borrow a PCL in NotCreated state',
            'PCL:OCLB1'
        );
    }

    /**************************************************************************************************************************************
    Repay function tests
    **************************************************************************************************************************************/

    function assertRepayFunctionalityInNotCreatedState(
        uint256 _id,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        admin.transferToken(address(borrowAsset), address(_user), 100);
        _user.setAllowance(address(pcl), address(borrowAsset), 100);

        try _user.repay(_id, 1) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotRepayANotCreatedPCL() public {
        assertRepayFunctionalityInNotCreatedState(
            notCreatedRequestId,
            admin,
            uint256(PooledCreditLineStatus.NOT_CREATED),
            'Admin cannot repay a NotCreated PCL',
            'PCL:REP2'
        );
    }

    function test_borrowerCannotRepayANotCreatedPCL() public {
        assertRepayFunctionalityInNotCreatedState(
            notCreatedRequestId,
            borrower,
            uint256(PooledCreditLineStatus.NOT_CREATED),
            'Borrower cannot repay a NotCreated PCL',
            'PCL:REP2'
        );
    }

    function test_lenderCannotRepayANotCreatedPCL() public {
        assertRepayFunctionalityInNotCreatedState(
            notCreatedRequestId,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.NOT_CREATED),
            'Lender cannot repay a NotCreated PCL',
            'PCL:REP2'
        );
    }

    /*************************************************************************************************************************************
    Withdraw collateral function tests
    *************************************************************************************************************************************/

    function assertWithdrawCollateralFunctionalityInNotCreatedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage,
        string memory _errorMessageAll
    ) public {
        try _user.withdrawAllCollateral(_id, false) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessageAll);
        }

        try _user.withdrawCollateral(_id, _amount, false) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    function test_adminCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInNotCreatedState(
            notCreatedRequestId,
            1,
            admin,
            uint256(PooledCreditLineStatus.NOT_CREATED),
            'Admin cannot withdraw collateral in NotCreated state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInNotCreatedState(
            notCreatedRequestId,
            1,
            borrower,
            uint256(PooledCreditLineStatus.NOT_CREATED),
            'Borrower cannot withdraw collateral in NotCreated state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotWithdrawZeroCollateral() public {
        assertWithdrawCollateralFunctionalityInNotCreatedState(
            notCreatedRequestId,
            0,
            borrower,
            uint256(PooledCreditLineStatus.NOT_CREATED),
            'Borrower cannot withdraw zero collateral in NotCreated state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    function test_lenderCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInNotCreatedState(
            notCreatedRequestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.NOT_CREATED),
            'Lender cannot withdraw collateral in NotCreated state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    WithdrawLiquidity function calls
    **************************************************************************************************************************************/

    function assert_withdraw_liquidity_functionality_in_NotCreated_state(
        uint256 _id,
        PCLUser _user,
        uint256 _stateToAssert,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_positiveCase) {
            uint256 _poolTokenBalanceOld = lp.balanceOf(address(_user), _id);
            uint256 _borrowTokenBalanceOld = IERC20(request.borrowAsset).balanceOf(address(_user));
            _user.withdrawLiquidity(_id);
            uint256 _poolTokenBalanceNew = lp.balanceOf(address(_user), _id);
            uint256 _borrowTokenBalanceNew = IERC20(request.borrowAsset).balanceOf(address(_user));

            assertGe((_borrowTokenBalanceNew - _borrowTokenBalanceOld), _poolTokenBalanceOld);
            assertEq(_poolTokenBalanceNew, 0);
        } else {
            try _user.withdrawLiquidity(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotWithdrawLiquidityFromANotCreatedPCL() public {
        assert_withdraw_liquidity_functionality_in_NotCreated_state(
            notCreatedRequestId,
            admin,
            uint256(PooledCreditLineStatus.NOT_CREATED),
            false,
            'Admin cannot withdraw liquidity a PCL in NotCreated state',
            'LP:IWL1'
        );
    }

    function test_borrowerCannotWithdrawLiquidityFromANotCreatedPCL() public {
        assert_withdraw_liquidity_functionality_in_NotCreated_state(
            notCreatedRequestId,
            borrower,
            uint256(PooledCreditLineStatus.NOT_CREATED),
            false,
            'Borrower cannot withdraw liquidity a PCL in NotCreated state',
            'LP:IWL1'
        );
    }

    function test_lenderCannotWithdrawLiquidityFromANotCreatedPCL() public virtual {
        assert_withdraw_liquidity_functionality_in_NotCreated_state(
            notCreatedRequestId,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.NOT_CREATED),
            false,
            'Lender cannot withdraw liquidity a PCL in NotCreated state',
            'LP:IWL1'
        );
    }

    /**************************************************************************************************************************************
    Liquidate function tests
    **************************************************************************************************************************************/

    function assert_liquidate_functionality_in_notCreated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.liquidate(_id, true) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            console.log(reason);
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.NOT_CREATED);
    }

    function test_adminCannotLiquidateANotCreatedPCL() public {
        assert_liquidate_functionality_in_notCreated_state(
            notCreatedRequestId,
            admin,
            'Admin cannot liquidate a notCreated PCL',
            'LP:LIQ1'
        );
    }

    function test_borrowerCannotLiquidateANotCreatedPCL() public {
        assert_liquidate_functionality_in_notCreated_state(
            notCreatedRequestId,
            borrower,
            'Borrower cannot liquidate a notCreated PCL',
            'LP:LIQ1'
        );
    }

    function test_lenderCannotLiquidateANotCreatedPCL() public virtual {
        assert_liquidate_functionality_in_notCreated_state(
            notCreatedRequestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot liquidate a notCreated PCL',
            'LP:LIQ1'
        );
    }

    /*************************************************************************************************************************************
    WithdrawInterest function calls
    **************************************************************************************************************************************/

    function assert_withdraw_interest_functionality_in_notCreated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.withdrawInterest(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.NOT_CREATED);
    }

    function test_adminCannotWithdrawInterestFromANotCreatedPCL() public {
        assert_withdraw_interest_functionality_in_notCreated_state(
            notCreatedRequestId,
            admin,
            'No interest can be withdrawn in a not-created PCL',
            'LP:IWI1'
        );
    }

    function test_borrowerCannotWithdrawInterestFromANotCreatedPCL() public {
        assert_withdraw_interest_functionality_in_notCreated_state(
            notCreatedRequestId,
            borrower,
            'No interest can be withdrawn in a not-created PCL',
            'LP:IWI1'
        );
    }

    function test_lenderCannotWithdrawInterestFromANotCreatedPCL() public {
        assert_withdraw_interest_functionality_in_notCreated_state(
            notCreatedRequestId,
            PCLUser(lenders[0].lenderAddress),
            'No interest can be withdrawn in a not-created PCL',
            'LP:IWI1'
        );
    }

    /**************************************************************************************************************************************
    Terminate function tests 
    **************************************************************************************************************************************/

    function assert_terminate_functionality_in_notCreated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.terminate(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.NOT_CREATED);
    }

    function test_adminCannotTerminateANotCreatedPCL() public {
        assert_terminate_functionality_in_notCreated_state(
            notCreatedRequestId,
            admin,
            'Cannot terminate a PCL that is not created',
            'PCL:CTCT1'
        );
    }

    function test_borrowerCannotTerminateANotCreatedPCL() public {
        assert_terminate_functionality_in_notCreated_state(
            notCreatedRequestId,
            borrower,
            'Cannot terminate a PCL that is not created',
            'Ownable: caller is not the owner'
        );
    }

    function test_lenderCannotTerminateANotCreatedPCL() public {
        assert_terminate_functionality_in_notCreated_state(
            notCreatedRequestId,
            PCLUser(lenders[0].lenderAddress),
            'Cannot terminate a PCL that is not created',
            'Ownable: caller is not the owner'
        );
    }

    /**************************************************************************************************************************************
    Pool Token Transfer function tests 
    **************************************************************************************************************************************/

    function assert_pool_token_transfer_in_notCreated_stage(
        uint256 _id,
        PCLUser _fromUser,
        address _toUser,
        uint256 _fractionOfPTSupply,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        uint256 _fromUserPoolTokenSupply = lp.balanceOf(address(_fromUser), _id);
        try _fromUser.transferLPTokens(_toUser, _id, (_fromUserPoolTokenSupply / _fractionOfPTSupply)) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    function test_poolTokenTransferComplete() public {
        assert_pool_token_transfer_in_notCreated_stage(
            notCreatedRequestId,
            PCLUser(lenders[0].lenderAddress),
            lenders[1].lenderAddress,
            1,
            'Should not have gone through',
            'LP:IT3'
        );
    }

    function test_poolTokenTransferPartial() public {
        assert_pool_token_transfer_in_notCreated_stage(
            notCreatedRequestId,
            PCLUser(lenders[0].lenderAddress),
            lenders[1].lenderAddress,
            2,
            'Should not have gone through',
            'LP:IT3'
        );
    }

    function test_poolTokenTransferToNonVerifiedUser() public {
        assert_pool_token_transfer_in_notCreated_stage(
            notCreatedRequestId,
            PCLUser(lenders[0].lenderAddress),
            address(admin),
            4,
            'Non-verified user should not be able to receive pool tokens',
            'LP:IT3'
        );
    }

    function test_cannotBurnPoolToken() public {
        assert_pool_token_transfer_in_notCreated_stage(
            notCreatedRequestId,
            PCLUser(lenders[0].lenderAddress),
            address(0),
            1,
            'Should not have gone through',
            'ERC1155: transfer to the zero address'
        );
    }

    function test_cannotTransferPoolTokensToSelf() public {
        assert_pool_token_transfer_in_notCreated_stage(
            notCreatedRequestId,
            PCLUser(lenders[0].lenderAddress),
            lenders[0].lenderAddress,
            1,
            'Should not have gone through',
            'LP:IT1'
        );
    }

    function test_externalUserCannotCreate() public {
        try
            lp.create(
                notCreatedRequestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_externalUserCannotTerminate() public {
        try lp.terminate(notCreatedRequestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_cannotLendZeroAmount() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(notCreatedRequestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }

    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(notCreatedRequestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }

    function test_lenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(notCreatedRequestId, _amountToLend) {
            revert('Lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Withdraw Liquidation function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_withdraw_liquidation_in_notcreated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.withdrawTokensAfterLiquidation(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    function test_adminCannotWithdrawLiquidation_notcreatedState() public {
        assert_withdraw_liquidation_in_notcreated_state(
            notCreatedRequestId,
            admin,
            'Cannot withdraw liquidation/liquidity from a notcreated PCL',
            'LP:WLC1'
        );
    }

    function test_borrowerCannotWithdrawLiquidation_notcreatedState() public {
        assert_withdraw_liquidation_in_notcreated_state(
            notCreatedRequestId,
            borrower,
            'Cannot withdraw liquidation/liquidity from a notcreated PCL',
            'LP:WLC1'
        );
    }

    function test_lenderCannotWithdrawLiquidation_notcreatedState() public virtual {
        assert_withdraw_liquidation_in_notcreated_state(
            notCreatedRequestId,
            PCLUser(lenders[0].lenderAddress),
            'Cannot withdraw liquidation/liquidity from a notcreated PCL',
            'LP:WLC1'
        );
    }

    /**************************************************************************************************************************************
    View/calculation function tests 
    **************************************************************************************************************************************/

    function assert_helper_functionalities_in_notCreated_state(uint256 _id) public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 1. calculatePrincipalWithdrawable
        uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
        assertEq(_principalWithdrawable, 0);

        // 2. withdrawableCollateral
        try _borrower.withdrawableCollateral(_id) {
            revert('withdrawable collateral cannot be called in a not created PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CTCT1');
        }

        // 3. calculateTotalCollateralTokens
        try _borrower.calculateTotalCollateralTokens(_id) {
            revert('Total collateral tokens cannot be calculated for a not created PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CTCT1');
        }

        // 4. calculateBorrowableAmount
        uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_totalBorrowable, 0);

        // 5. calculateInterestAccrued
        uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertEq(_interestAccrued, 0);

        // 6. calculateCurrentDebt
        uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);
        assertEq(_currentDebt, 0);

        // Test Number 7 should ideally have been returning a revert string, but right now they return PO:IGUPT1

        // 7. calculateCurrentCollateralRatio
        try _borrower.calculateCurrentCollateralRatio(_id) {
            uint256 _currentCR = _borrower.calculateCurrentCollateralRatio(_id);
            assertEq(_currentCR, uint256(-1));
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:IGUPT1');
        }

        // 8. collateralTokensToLiquidate
        try _borrower.collateralTokensToLiquidate(_id, 0) {
            uint256 _collateralTokensToLiquidate = _borrower.collateralTokensToLiquidate(_id, 0);
            assertEq(_collateralTokensToLiquidate, 0);
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CTTL1');
        }
    }

    function test_helperFunctionInNotCreatedState() public {
        assert_helper_functionalities_in_notCreated_state(notCreatedRequestId);
    }

    function helper_timeWarp(uint256 _time) public {
        vm.warp(_time);
        vm.roll(_time.div(20));
    }
}",6804
RealWorld_BA_101_PCLClosedStage.t_RealWord_20240827100938.log,101,PCLClosedStage.t,14763,5926,20689,101.0,0.192335,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '../../PCLStageTests/PCLClosedStage.t.sol';

contract PCLClosedStageZeroCollateralBorrowCompound is PCLClosedStage {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    function setUp() public override {
        PCLParent.setUp();

        request.borrowLimit = uint128(1_000_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * 1e18) / 1e2);
        request.collateralRatio = 0;
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * 1e18) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = compoundYieldAddress;
        request.collateralAssetStrategy = compoundYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        // The below function will create the PCL request and then lenders lend the entire requested amount
        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        // Now we assert that we are in the ACTIVE state
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), 2);

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);
        if (request.collateralRatio != 0) {
            borrower.depositCollateral(requestId, _requiredCollateral, false);
        }

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);
        // And borrows the borrowable amount
        borrower.borrow(requestId, borrowableAmount);

        // Borrower decides to repay everything at mid-duration

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 2);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay the entire debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt);
        borrower.repay(requestId, currentDebt);

        // Now the PCL should be in the CLOSED state
        borrower.close(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!CLOSED');
    }
}",702
RealWorld_BA_101_PCLLiquidatedStage.t_RealWord_20240827092651.log,101,PCLLiquidatedStage.t,0,0,0,,0.0,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';
import '../Helpers/PCLParent.t.sol';

contract PCLLiquidatedStage is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 requestId;
    address lender_0;

    function setUp() public virtual override {
        super.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 5000 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);
        lender_0 = lenders[0].lenderAddress;

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, type(uint256).max);
        borrower.depositCollateral(requestId, _requiredCollateral, false);

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);
        // and borrows the borrowable amount
        borrower.borrow(requestId, borrowableAmount);

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 10);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, currentDebt / 200);

        // Now we travel past the expiration date
        vm.warp(block.timestamp + request.duration + request.defaultGracePeriod);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');

        // Now the PCL should be in the LIQUIDATED state
        PCLUser(lender_0).liquidate(requestId, false);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
    }

    // Test0: Test SetUp
    function test_SetUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED, '!Liquidated');
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // START function calls
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    // Test1: Liquidated PCL cannot be started
    function assert_start_functionality_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertString,
        string memory _errorString
    ) public {
        try _user.start(_id) {
            revert(_revertString);
        } catch Error(string memory reason) {
            assertEq(reason, _errorString);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }

    function test_adminCannotStartALiquidatedPCL() public {
        assert_start_functionality_in_liquidated_state(requestId, admin, 'Admin cannot start a PCL in liquidated state', 'LP:S1');
    }

    function test_borrowerCannotStartALiquidatedPCL() public {
        assert_start_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot start a PCL in liquidated state', 'LP:S1');
    }

    function test_lenderCannotStartALiquidatedPCL() public {
        assert_start_functionality_in_liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot start a PCL in liquidated state',
            'LP:S1'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // CANCEL function calls
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_cancel_functionality_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.cancelRequest(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }

    function test_adminCannotCancelALiquidatedPCL() public {
        assert_cancel_functionality_in_liquidated_state(requestId, admin, 'Admin cannot Cancel a PCL in liquidated state', 'PCL:OCLB1');
    }

    function test_borrowerCannotCancelALiquidatedPCL() public {
        assert_cancel_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot Cancel a PCL in liquidated state', 'PCL:CR1');
    }

    function test_lenderCannotCancelALiquidatedPCL() public {
        assert_cancel_functionality_in_liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot Cancel a PCL in liquidated state',
            'PCL:OCLB1'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // CLOSE function calls
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_close_functionality_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.close(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }

    function test_adminCannotCloseALiquidatedPCL() public {
        assert_close_functionality_in_liquidated_state(requestId, admin, 'Admin cannot close a liquidated PCL', 'PCL:OCLB1');
    }

    function test_borrowerCannotCloseALiquidatedPCL() public {
        assert_close_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot close a liquidated PCL', 'PCL:C1');
    }

    function test_lenderCannotCloseALiquidatedPCL() public {
        assert_close_functionality_in_liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot close a liquidated PCL',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    Deposit collateral function calls
    *************************************************************************************************************************************/

    function assert_collateralCannotBeDepositedInLiquidatedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _depositor,
        bool _isDepositorLender
    ) public {
        if (_isDepositorLender) {
            _depositor = PCLUser(lenders[0].lenderAddress);
        }

        admin.transferToken(address(collateralAsset), address(_depositor), _amount);
        if (_depositor != borrower) {
            _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);
        }

        try _depositor.depositCollateral(_id, _amount, false) {
            revert('Collateral cannot be deposited in the Liquidated state');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:DC2');
        }
    }

    function test_borrowerCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, borrower, true);
    }

    function test_lenderCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, PCLUser(address(0)), true);
    }

    function test_adminCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInLiquidatedState(requestId, _amountToDeposit, admin, false);
    }

    /*************************************************************************************************************************************
    Borrow function tests
    *************************************************************************************************************************************/

    function assertBorrowFunctionalityInLiquidatedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.borrow(_id, _amount) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotBorrow() public {
        assertBorrowFunctionalityInLiquidatedState(
            requestId,
            1,
            admin,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Admin cannot borrow a PCL in Liquidated state',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotBorrowALiquidatedPCL() public {
        assertBorrowFunctionalityInLiquidatedState(
            requestId,
            1,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot borrow a PCL in Liquidated state',
            'PCL:IB3'
        );
    }

    function test_borrowerCannotBorrowZeroAmount() public {
        assertBorrowFunctionalityInLiquidatedState(
            requestId,
            0,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot borrow a PCL in Liquidated state',
            'PCL:IB1'
        );
    }

    function test_lenderCannotBorrow() public {
        assertBorrowFunctionalityInLiquidatedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Lender cannot borrow a PCL in Liquidated state',
            'PCL:OCLB1'
        );
    }

    /**************************************************************************************************************************************
    Repay function tests
    **************************************************************************************************************************************/

    function assertRepayFunctionalityInLiquidatedState(
        uint256 _id,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        admin.transferToken(address(borrowAsset), address(_user), 100);
        if (_user != borrower) {
            _user.setAllowance(address(pcl), address(borrowAsset), 100);
        }

        try _user.repay(_id, 1) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotRepayALiquidatedPCL() public {
        assertRepayFunctionalityInLiquidatedState(
            requestId,
            admin,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Admin cannot repay a Liquidated PCL',
            'PCL:REP2'
        );
    }

    function test_borrowerCannotRepayALiquidatedPCL() public {
        assertRepayFunctionalityInLiquidatedState(
            requestId,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot repay a Liquidated PCL',
            'PCL:REP2'
        );
    }

    function test_lenderCannotRepayALiquidatedPCL() public {
        assertRepayFunctionalityInLiquidatedState(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Lender cannot repay a Liquidated PCL',
            'PCL:REP2'
        );
    }

    /*************************************************************************************************************************************
    Withdraw collateral function tests
    *************************************************************************************************************************************/

    function assertWithdrawCollateralFunctionalityInLiquidatedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage,
        string memory _errorMessageAll
    ) public {
        if (pcl.withdrawableCollateral(_id) > 0 && _user == borrower) {
            uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));
            _user.withdrawAllCollateral(_id, false);
            uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));
            assertGe(_balanceAfter, _balanceBefore);
        } else {
            try _user.withdrawAllCollateral(_id, false) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessageAll);
            }
        }

        if (pcl.withdrawableCollateral(_id) >= _amount && _user == borrower && _amount != 0) {
            uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));
            _user.withdrawCollateral(_id, _amount, false);
            uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));
            assertApproxEqAbs(_balanceAfter - _balanceBefore, _amount, 2);
        } else {
            try _user.withdrawCollateral(_id, _amount, false) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }
    }

    function test_adminCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInLiquidatedState(
            requestId,
            1,
            admin,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Admin cannot withdraw collateral in Liquidated state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInLiquidatedState(
            requestId,
            1,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot withdraw collateral in Liquidated state',
            'PCL:WC1',
            'PCL:WAC1'
        );
    }

    function test_borrowerCannotWithdrawZeroCollateral() public {
        assertWithdrawCollateralFunctionalityInLiquidatedState(
            requestId,
            0,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot withdraw zero collateral in Liquidated state',
            'PCL:WC2',
            'PCL:WAC1'
        );
    }

    function test_lenderCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInLiquidatedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Lender cannot withdraw collateral in Liquidated state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    WithdrawLiquidity function calls
    **************************************************************************************************************************************/

    function assert_withdraw_liquidity_functionality_in_Liquidated_state(
        uint256 _id,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.withdrawLiquidity(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotWithdrawLiquidityFromALiquidatedPCL() public {
        assert_withdraw_liquidity_functionality_in_Liquidated_state(
            requestId,
            admin,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Admin cannot withdraw liquidity a PCL in Liquidated state',
            'LP:IWL1'
        );
    }

    function test_borrowerCannotWithdrawLiquidityFromALiquidatedPCL() public {
        assert_withdraw_liquidity_functionality_in_Liquidated_state(
            requestId,
            borrower,
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Borrower cannot withdraw liquidity a PCL in Liquidated state',
            'LP:IWL1'
        );
    }

    function test_lenderCannotWithdrawLiquidityFromALiquidatedPCL() public {
        assert_withdraw_liquidity_functionality_in_Liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.LIQUIDATED),
            'Lender cannot withdraw liquidity a PCL in Liquidated state',
            'LP:IWL2'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // LIQUIDATE function calls
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_liquidate_functionality_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.liquidate(_id, true) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }

    function test_adminCannotLiquidateALiquidatedPCL() public {
        assert_liquidate_functionality_in_liquidated_state(requestId, admin, 'Admin cannot liquidate an liquidated PCL', 'LP:LIQ1');
    }

    function test_borrowerCannotLiquidateALiquidatedPCL() public {
        assert_liquidate_functionality_in_liquidated_state(requestId, borrower, 'Borrower cannot liquidate an liquidated PCL', 'LP:LIQ1');
    }

    function test_lenderCannotLiquidateALiquidatedPCL() public {
        assert_liquidate_functionality_in_liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Liquidated PCL cannot be liquidated',
            'PCL:L2'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Terminate function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_terminate_functionality_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        uint256 _userBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(_user));
        uint256 _userCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(_user));

        try _user.terminate(_id) {
            uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));
            uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));

            if (_user == admin) {
                assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.NOT_CREATED);
                assertTrue((_userBorrowTokenBalancePreTerminate < _userBorrowTokenBalancePostTerminate) == true);
                if (request.collateralRatio != 0) {
                    assertTrue((_userCollateralTokenBalancePreTerminate < _userCollateralTokenBalancePostTerminate) == true);
                }
            } else {
                assertTrue(
                    (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==
                        (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==
                        true
                );
                revert(_revertMessage);
            }
        } catch Error(string memory reason) {
            uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));
            uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));

            assertTrue(
                (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==
                    (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==
                    true
            );

            assertEq(reason, _errorMessage);
            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
        }
    }

    function test_adminCanTerminateALiquidatedPCL() public {
        assert_terminate_functionality_in_liquidated_state(requestId, admin, '', '');
    }

    function test_borrowerCannotTerminateALiquidatedPCL() public {
        assert_terminate_functionality_in_liquidated_state(
            requestId,
            borrower,
            'Cannot terminate a PCL that is liquidated',
            'Ownable: caller is not the owner'
        );
    }

    function test_lenderCannotTerminateALiquidatedPCL() public {
        assert_terminate_functionality_in_liquidated_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Cannot terminate a PCL that is liquidated',
            'Ownable: caller is not the owner'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Pool Token Transfer function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    uint256 lender0PoolTokenBalance;
    uint256 lender1PoolTokenBalance;
    uint256 lender2PoolTokenBalance;
    uint256 lender3PoolTokenBalance;
    uint256 _from1BalancePostBurn;
    uint256 lender0PoolTokenBalanceFinal;
    uint256 lender1PoolTokenBalanceFinal;
    uint256 lender2PoolTokenBalanceFinal;
    uint256 lender3PoolTokenBalanceFinal;
    uint256 _defaultTimeStamp;

    PCLUser _from1;
    PCLUser _from2;
    PCLUser _to1;
    PCLUser _to2;

    function assert_pool_token_transfer_in_liquidated_stage(
        uint256 _id,
        uint256 _fractionOfPTSupply,
        bool _positiveCase,
        address _From1,
        address _From2,
        address _To1,
        address _To2,
        string memory _errorString
    ) public {
        _from1 = PCLUser(_From1);
        _from2 = PCLUser(_From2);
        _to1 = PCLUser(_To1);
        _to2 = PCLUser(_To2);

        if (_positiveCase) {
            // Ensuring that these lenders indeed had lent something
            lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);
            lender1PoolTokenBalance = lp.balanceOf(address(_to1), _id);
            lender2PoolTokenBalance = lp.balanceOf(address(_from2), _id);
            lender3PoolTokenBalance = lp.balanceOf(address(_to2), _id);

            assertGt(lender0PoolTokenBalance, 0);
            assertGt(lender1PoolTokenBalance, 0);
            assertGt(lender2PoolTokenBalance, 0);
            assertGt(lender3PoolTokenBalance, 0);

            // Lender0 transfers pool tokens to lender1
            _from1.transferLPTokens(address(_to1), _id, (lender0PoolTokenBalance / _fractionOfPTSupply));

            //Checking the transfer took place or not
            lender0PoolTokenBalanceFinal = lp.balanceOf(address(_from1), _id);
            lender1PoolTokenBalanceFinal = lp.balanceOf(address(_to1), _id);

            assertTrue(lender0PoolTokenBalanceFinal == (lender0PoolTokenBalance - (lender0PoolTokenBalance / _fractionOfPTSupply)));
            assertTrue(lender1PoolTokenBalanceFinal == ((lender0PoolTokenBalance / _fractionOfPTSupply) + lender1PoolTokenBalance));

            vm.warp(block.timestamp + request.defaultGracePeriod);

            // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(_id);

            // assertTrue(block.timestamp >= _defaultTimeStamp, '!Still not past default time');

            // Lender2 transfers pool tokens to lender3
            _from2.transferLPTokens(address(_to2), _id, lender2PoolTokenBalance);

            lender2PoolTokenBalanceFinal = lp.balanceOf(address(_from2), _id);
            lender3PoolTokenBalanceFinal = lp.balanceOf(address(_to2), _id);

            // Checking whether the transfer took place or not
            assertTrue(lender2PoolTokenBalanceFinal == 0);
            assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));

            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
        } else {
            lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);
            try _from1.transferLPTokens(_To1, _id, lender0PoolTokenBalance) {
                if (_To1 == address(0)) {
                    _from1BalancePostBurn = lp.balanceOf(_From1, _id);
                    assertEq(_from1BalancePostBurn, 0);
                } else {
                    revert('REVERT');
                }
            } catch Error(string memory reason) {
                assertEq(reason, _errorString);
            }
        }
    }

    function test_poolTokenTransferComplete_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            1,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_poolTokenTransferPartial_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            2,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_poolTokenTransferPartialByFour_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            4,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_cannotBurnPoolToken_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            address(0),
            address(0),
            'ERC1155: transfer to the zero address'
        );
    }

    function test_cannotTransferPoolTokensToSelf_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            lenders[0].lenderAddress,
            address(0),
            'LP:IT1'
        );
    }

    function test_cannotTransferPoolTokensToNonVerified_liquidatedState() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            protocolFeeCollectorAddress,
            address(0),
            'LP:IT3'
        );
    }

    function test_cannotTransferLPTokensToBorrower() public {
        assert_pool_token_transfer_in_liquidated_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            address(borrower),
            address(0),
            'LP:IT2'
        );
    }

    function test_cannotTransferNonTransferableLPTokens() public {
        request.areTokensTransferable = false;
        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        if (request.collateralRatio != 0) {
            borrower.depositCollateral(_requestId, _requiredCollateral, false);
        }

        uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);
        borrower.borrow(_requestId, borrowableAmount);

        vm.warp(block.timestamp + request.duration / 10);
        uint256 currentDebt = borrower.calculateCurrentDebt(_requestId);
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.repay(_requestId, currentDebt / 200);

        vm.warp(block.timestamp + request.duration + request.defaultGracePeriod);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');

        PCLUser(lenders[0].lenderAddress).liquidate(_requestId, false);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.LIQUIDATED);

        assert_pool_token_transfer_in_liquidated_stage(
            _requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            lenders[1].lenderAddress,
            address(0),
            'LP:IT5'
        );
    }

    function test_externalUserCannotCreate() public {
        try
            lp.create(
                requestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_externalUserCannotTerminate() public {
        try lp.terminate(requestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_cannotLendZeroAmount() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }

    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }

    function test_lenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Withdraw Interest function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_withdraw_interest_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _errorMessage
    ) public {
        uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));
        uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));
        uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);

        uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));

        try _user.withdrawInterest(_id) {
            uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));
            uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));
            uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);

            if (_userPoolTokenBalancePreWithdraw == 0) {
                assertEq(_lenderInterest, 0);
                assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);
            } else {
                assertTrue(_lenderInterest != 0);
                assertEq((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest);
            }

            assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);
            assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    function test_adminCannotWithdrawInterest_liquidatedState() public {
        assert_withdraw_interest_in_liquidated_state(requestId, admin, 'LP:WI1');
    }

    function test_borrowerCannotWithdrawInterest_liquidatedState() public {
        assert_withdraw_interest_in_liquidated_state(requestId, borrower, 'LP:WI1');
    }

    function test_lendersCanWithdrawInterest_liquidatedState() public {
        assert_withdraw_interest_in_liquidated_state(requestId, PCLUser(lenders[0].lenderAddress), '');
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Withdraw Liquidation function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_withdraw_liquidation_in_liquidated_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_user == PCLUser(lenders[1].lenderAddress)) {
            uint256 _lenderBorrowTokenBalancePreLiquidation = borrowAsset.balanceOf(address(_user));
            uint256 _lenderCollateralTokenBalancePreLiquidation = collateralAsset.balanceOf(address(_user));
            _user.withdrawTokensAfterLiquidation(_id);
            uint256 _lenderBorrowTokenBalancePostLiquidation = borrowAsset.balanceOf(address(_user));
            uint256 _lenderCollateralTokenBalancePostLiquidation = collateralAsset.balanceOf(address(_user));
            assertGt(_lenderBorrowTokenBalancePostLiquidation, _lenderBorrowTokenBalancePreLiquidation);
            if (request.collateralRatio != 0) {
                assertGt(_lenderCollateralTokenBalancePostLiquidation, _lenderCollateralTokenBalancePreLiquidation);
            }
        } else {
            try _user.withdrawTokensAfterLiquidation(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }
    }

    function test_adminCannotWithdrawLiquidation_liquidatedState() public {
        assert_withdraw_liquidation_in_liquidated_state(
            requestId,
            admin,
            'Admin cannot withdraw liquidation/liquidity from an liquidated PCL',
            'LP:WLC1'
        );
    }

    function test_borrowerCannotWithdrawLiquidation_liquidatedState() public {
        assert_withdraw_liquidation_in_liquidated_state(
            requestId,
            borrower,
            'Admin cannot withdraw liquidation/liquidity from an liquidated PCL',
            'LP:WLC1'
        );
    }

    function test_lenderCanWithdrawLiquidation_liquidatedState() public {
        assert_withdraw_liquidation_in_liquidated_state(requestId, PCLUser(lenders[1].lenderAddress), '', '');
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // View/calculation function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    uint256 _currentCR;
    uint256 _totalInterestPending;
    uint256 _totalInterestRepaid;
    uint256 _principal;
    uint256 _currentDebt;
    uint256 collateralHeld;

    function assert_helper_functionalities_in_liquidated_state(uint256 _id) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 0. collateralTokensToLiquidate
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        uint256 _equivalentCollateralTokens = _borrower.collateralTokensToLiquidate(_id, _currentDebt);

        log_named_uint('CD', _currentDebt);
        log_named_uint('Equivalent Collateral Tokens', _equivalentCollateralTokens);

        if (request.collateralRatio != 0) {
            (, , , , collateralHeld) = lp.pooledCLVariables(_id);

            log_named_uint('Collateral Held', collateralHeld);

            if (request.collateralAssetStrategy == compoundYieldAddress) {
                assertGt(_equivalentCollateralTokens, collateralHeld); // Since currentDebt is equivalentCollateralHeld + interest generated from the point of last repayment to the point of liquidation)
            } else {
                // assertApproxEqAbs(_equivalentCollateralTokens, collateralHeld, 1, 'Collateral Tokens to liquidate');
            }
        } else {
            log_named_uint('CD', _currentDebt); // Considerable number since debt cannot be recovered by liquidating a PCL with 0 collateral
            assertGt(_equivalentCollateralTokens, 0);
        }

        // The currentCr is coming to be more than idealCR. Discuss.

        // 0. calculateCurrentCollateralRatio
        _currentCR = _borrower.calculateCurrentCollateralRatio(_id);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
        if (request.collateralRatio != 0) {
            // assertEq(request.collateralRatio, _currentCR, 'Current Collateral Ratio'); // Since a lot of collateral was taken away
        } else {
            assertTrue(true);
        }

        // 1. calculatePrincipalWithdrawable
        try _lender.withdrawLiquidity(_id) {
            revert('Cannot be called without withdrawnLiquidation');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL2');
        }

        // 2. withdrawableCollateral
        (, , , , collateralHeld) = lp.pooledCLVariables(_id); // This is the collateral that is transferred to the LenderPool contract after liquidation
        uint256 _remainingCollateralInShares = pcl.depositedCollateralInShares(_id);
        uint256 _remainingCollateral = IYield(request.collateralAssetStrategy).getTokensForShares(
            _remainingCollateralInShares,
            address(collateralAsset)
        );
        uint256 withdrawableCollateral = _borrower.withdrawableCollateral(_id);

        assertApproxEqAbs(withdrawableCollateral, _remainingCollateral, 5, 'Withdrawable Collateral');

        // 3.calculateTotalCollateralTokens
        uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertEq(_totalCollateral, withdrawableCollateral, 'Total Collateral Tokens');

        // 4. calculateBorrowableAmount
        uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_totalBorrowable, 0, 'Borrowable Amount'); // Since PCL is liquidated now

        // 5. calculateInterestAccrued
        uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGt(_interestAccrued, 0, 'Interest Accrued'); // Should be non-zero, since it calculates interest accrued since last repayment
        // doesn't matter whether the PCL has been liquidated or not

        // 6. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        (, _principal, _totalInterestRepaid, , ) = pcl.pooledCreditLineVariables(_id);
        _totalInterestPending = _borrower.calculateInterestAccrued(_id);
        log_named_uint('First Interest Repaid', _totalInterestRepaid);
        uint256 calculatedCurrentDebt = _totalInterestPending + _principal - _totalInterestRepaid;
        assertApproxEqRel(_currentDebt, calculatedCurrentDebt, 1e14, 'Current Debt');
    }

    function test_helperFunctionsInLiquidatedState() public {
        assert_helper_functionalities_in_liquidated_state(requestId);
    }
}",9533
RealWorld_BA_101_PCLTerminatedStage.t_RealWord_20240827100503.log,101,PCLTerminatedStage.t,17140,5776,22916,86.0,0.20122,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '../PCLStageTests/PCLTerminatedStage.t.sol';

contract PCLTerminatedStageZeroCollateral is PCLTerminatedStage {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    function setUp() public override {
        PCLParent.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = 0;
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * (10**ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');

        // Now let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), collateralToDeposit);

            // We want to deposit collateral now
            if (request.collateralRatio != 0) {
                borrower.depositCollateral(requestId, collateralToDeposit, false);
            }
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_timeWarp(block.timestamp + request.duration / 2);

        // Borrower makes their first repayment (Entire pending interest + part of principal)
        {
            uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);
            admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);
            borrower.setAllowance(address(pcl), address(borrowAsset), interestAccrued + 10);
            borrower.repay(requestId, interestAccrued + 10);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        admin.terminate(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED, '!Terminated');
        notCreatedRequestId = requestId;
    }
}",841
RealWorld_BA_101_MockVerification2_RealWord_20240827085914.log,101,MockVerification2,6885,5512,12397,74.0,0.144665,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

contract MockVerification2 {
    mapping(address => bool) public verifiers;
    mapping(address => mapping(address => bool)) public verifiedUsers;

    function isUser(address _user, address _verifier) public view returns (bool) {
        return verifiedUsers[_verifier][_user];
    }

    function verifyUser(address _user, address _verifier) public {
        if (verifiers[_verifier]) {
            verifiedUsers[_verifier][_user] = true;
        } else {
            verifiedUsers[_verifier][_user] = false;
        }
    }

    function unverifyUser(address _user) public {
        require(verifiers[msg.sender], 'Only authorized verifiers can unverify users');
        require(verifiedUsers[msg.sender][_user] == false, 'User either already unverified or was not verified by you');
        verifiedUsers[msg.sender][_user] = false;
    }

    function whitelistVerifier(address _verifier) public {
        verifiers[_verifier] = true;
    }
}",224
RealWorld_BA_101_PCLClosedStage.t_RealWord_20240827100009.log,101,PCLClosedStage.t,14765,6006,20771,118.0,0.193945,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '../PCLStageTests/PCLClosedStage.t.sol';

contract PCLClosedStageZeroCollateral is PCLClosedStage {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    function setUp() public override {
        PCLParent.setUp();

        request.borrowLimit = uint128(1_000_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * 1e18) / 1e2);
        request.collateralRatio = 0;
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * 1e18) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        // The below function will create the PCL request and then lenders lend the entire requested amount
        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        // Now we assert that we are in the ACTIVE state
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), 2);

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);
        if (request.collateralRatio != 0) {
            borrower.depositCollateral(requestId, _requiredCollateral, false);
        }

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);
        // And borrows the borrowable amount
        borrower.borrow(requestId, borrowableAmount);

        // Borrower decides to repay everything at mid-duration

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 2);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay the entire debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt);
        borrower.repay(requestId, currentDebt);

        // Now the PCL should be in the CLOSED state
        borrower.close(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!CLOSED');
    }
}",699
RealWorld_BA_101_PCLActiveStage.t_RealWord_20240827094338.log,101,PCLActiveStage.t,8124,4937,13061,67.0,0.13936,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '../PCLActiveStage.t.sol';

contract PCLActiveStageCollateralNoYieldBorrowCompound is PCLActiveStage {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    function setUp() public override {
        PCLParent.setUp();

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * (10**ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = compoundYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);
    }
}",324
RealWorld_BA_101_PCLLiquidatedStage.t_RealWord_20240827095840.log,101,PCLLiquidatedStage.t,16590,5710,22300,87.0,0.19715,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '../PCLStageTests/PCLLiquidatedStage.t.sol';

contract PCLLiquidatedStageZeroCollateral is PCLLiquidatedStage {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    function setUp() public override {
        PCLParent.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = 0;
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 5000 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);
        lender_0 = lenders[0].lenderAddress;

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, type(uint256).max);
        if (request.collateralRatio != 0) {
            borrower.depositCollateral(requestId, _requiredCollateral, false);
        }

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);
        // and borrows the borrowable amount
        borrower.borrow(requestId, borrowableAmount);

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 10);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, currentDebt / 200);

        // Now we travel past the expiration date
        vm.warp(block.timestamp + request.duration + request.defaultGracePeriod);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');

        // Now the PCL should be in the LIQUIDATED state
        PCLUser(lender_0).liquidate(requestId, false);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED, '!LIQUIDATED');
    }
}",797
RealWorld_BA_101_PCLActiveStage.t_RealWord_20240827093734.log,101,PCLActiveStage.t,9019,5885,14904,88.0,0.162795,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '../PCLActiveStage.t.sol';

contract PCLActiveStageCollateralCompoundBorrowCompound is PCLActiveStage {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    function setUp() public override {
        PCLParent.setUp();

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * (10**ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = compoundYieldAddress;
        request.collateralAssetStrategy = compoundYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);
    }
}",322
RealWorld_BA_101_CompoundUser_RealWord_20240827103906.log,101,CompoundUser,8090,5472,13562,80.0,0.14989,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';

import '../../interfaces/Invest/ICToken.sol';
import '../../interfaces/Invest/ICEther.sol';
import '../../interfaces/Invest/IComptroller.sol';

contract CompoundUser {
    using SafeERC20 for IERC20;

    function mintCETH(address _cTokenAddress, uint256 _amount) public {
        ICEther(_cTokenAddress).mint{value: _amount}();
    }

    function mint(address _cTokenAddress, uint256 _amount) public returns (uint256) {
        return ICToken(_cTokenAddress).mint(_amount);
    }

    function borrow(address _cTokenAddress, uint256 _amount) public returns (uint256) {
        return ICToken(_cTokenAddress).borrow(_amount);
    }

    function repayBorrow(address _cTokenAddress, uint256 _amount) public returns (uint256) {
        return ICToken(_cTokenAddress).repayBorrow(_amount);
    }

    function setAllowance(
        address approvedAddress,
        address token,
        uint256 amount
    ) public {
        IERC20(token).approve(approvedAddress, amount);
    }

    function enterMarkets(address _comptroller, address[] calldata cTokens) public {
        IComptroller(_comptroller).enterMarkets(cTokens);
    }

    receive() external payable {}
}",312
RealWorld_BA_101_PCLActiveStage.t_RealWord_20240827092610.log,101,PCLActiveStage.t,0,0,0,,0.0,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/math/SafeMath.sol';

import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../mocks/MockToken.sol';
import '../Helpers/PCLParent.t.sol';

contract PCLActiveStage is PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;

    uint256 requestId;

    // enum PooledCreditLineStatus {
    //     NOT_CREATED,
    //     REQUESTED,
    //     ACTIVE,
    //     CLOSED,
    //     EXPIRED,
    //     LIQUIDATED,
    //     CANCELLED
    // }

    function setUp() public virtual override {
        super.setUp();

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);
    }

    function test_cannotStartActivePCL() public {
        try borrower.start(requestId) {
            revert('cannot start active pcl');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S1');
        }
    }

    function test_externalUserCannotCreate() public {
        try
            lp.create(
                requestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_externalUserCannotTerminate() public {
        try lp.terminate(requestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_cannotLendZeroAmount() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        try _pooledCreditLineLender.lend(requestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }

    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        // verified using the borrower verifier instead of lender verifier
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }

    function test_nonLenderCannotWithdrawLiquidity() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);
        try _pooledCreditLineLender.withdrawLiquidity(requestId) {
            revert('Lender cannot withdraw liquidity');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL1');
        }
    }

    function test_lenderCannotWithdrawLiquidity() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.withdrawLiquidity(requestId) {
            revert('Lender cannot withdraw liquidity');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL3');
        }
    }

    function test_nonLenderCannotWithdrawLiquidationTokens() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {
            revert('Non lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WLC1');
        }
    }

    function test_lenderCannotWithdrawLiquidationTokens() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        try _lender.withdrawTokensAfterLiquidation(requestId) {
            revert('Lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    function test_cannotTransferLPTokensToSameAddress() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to itself');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT1');
        }
    }

    function test_cannotBurnPoolTokens() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(0), requestId, _balanceLender) {
            revert('Lender cannot burn LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'ERC1155: transfer to the zero address');
        }
    }

    function test_cannotLendToActivePCL() public {
        LenderInfo memory info = lenders[0];
        PCLUser lender = PCLUser(info.lenderAddress);
        try lender.lend(requestId, 100_000) {
            revert('cannot lend to active pcl');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    function test_cannotLendToActivePCLNewLender() public {
        // Creating a new lender for lending
        PCLUser lender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        lender.registerSelf(mockAdminVerifier1);
        admin.transferToken(request.borrowAsset, address(lender), 100_000);
        lender.setAllowance(lenderPoolAddress, request.borrowAsset, type(uint256).max);
        try lender.lend(requestId, 100_000) {
            revert('cannot lend to active pcl');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    function test_lenderCannotBorrow() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_borrowByInvalidActor(_id, _amountToBorrow, lenders[0].lenderAddress);
    }

    function test_adminCannotBorrow() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_borrowByInvalidActor(_id, _amountToBorrow, address(admin));
    }

    function test_onlyBorrowerCanBorrow() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;
        PCLUser _attacker = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_borrowByInvalidActor(_id, _amountToBorrow, address(_attacker));
    }

    function assert_borrowByInvalidActor(
        uint256 _id,
        uint256 _amountToBorrow,
        address _actor
    ) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        PCLUser _user = PCLUser(_actor);
        if (_actor == address(admin)) {
            admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

            _helperDepositCollateral(admin, _id, _collateralRequired, false);

            uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
                _collateralRequired,
                address(collateralAsset)
            );
            uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
            assertEq(_expectedCollateralShares, _actualCollateralShares);

            try admin.borrow(_id, _amountToBorrow) {
                revert('Invalid user should not be able to borrow');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        } else {
            admin.transferToken(address(collateralAsset), address(_user), _collateralRequired);
            _user.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

            _helperDepositCollateral(_user, _id, _collateralRequired, false);

            uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
                _collateralRequired,
                address(collateralAsset)
            );
            uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
            assertEq(_expectedCollateralShares, _actualCollateralShares);

            try _user.borrow(_id, _amountToBorrow) {
                revert('Invalid user should not be able to borrow');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        }
    }

    function test_borrowerCannotBorrowMoreThanPossible() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotBorrowMoreThanPossible(_id, _amountToBorrow);
    }

    function assert_borrowerCannotBorrowMoreThanPossible(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _amountBorrowable = pcl.calculateBorrowableAmount(_id);

        try borrower.borrow(_id, _amountBorrowable + 1) {
            revert('Borrower should not be able to borrow more than possible');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:IB3');
        }
    }

    function test_borrowerCannotBorrowZeroAmount() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotBorrowZeroAmount(_id, _amountToBorrow);
    }

    function assert_borrowerCannotBorrowZeroAmount(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        try borrower.borrow(_id, 0) {
            revert('Borrower should not be able to borrow zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:IB1');
        }
    }

    function test_lenderDepositsAndCannotWithdrawCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, lenders[0].lenderAddress, lenders[0].lenderAddress);
    }

    function test_borrowerDepositsAndLenderCannotWithdrawCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(borrower), lenders[0].lenderAddress);
    }

    function test_adminDepositsAndCannotWithdrawCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(admin), address(admin));
    }

    function test_borrowerDepositsAndAdminCannotWithdrawCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_DepositAndCannotWithdrawCollateral_InvalidActor(_id, _amountToBorrow, address(borrower), address(admin));
    }

    function assert_DepositAndCannotWithdrawCollateral_InvalidActor(
        uint256 _id,
        uint256 _amountToBorrow,
        address _depositor,
        address _withdrawer
    ) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        // Depositing into PCL
        if (_depositor == address(admin)) {
            admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

            _helperDepositCollateral(admin, _id, _collateralRequired, false);

            uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
                _collateralRequired,
                address(collateralAsset)
            );
            uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
            assertEq(_expectedCollateralShares, _actualCollateralShares);
        } else {
            PCLUser _user = PCLUser(_depositor);

            admin.transferToken(address(collateralAsset), address(_user), _collateralRequired);
            _user.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

            _helperDepositCollateral(_user, _id, _collateralRequired, false);

            uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
                _collateralRequired,
                address(collateralAsset)
            );
            uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
            assertEq(_expectedCollateralShares, _actualCollateralShares);
        }

        // withdrawing from PCL
        if (_withdrawer == address(admin)) {
            try admin.withdrawCollateral(_id, _collateralRequired, false) {
                revert('Admin should not be able to withdraw collateral');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        } else {
            PCLUser _user = PCLUser(_withdrawer);

            try _user.withdrawCollateral(_id, _collateralRequired, false) {
                revert('Invalid actor should not be able to withdraw collateral');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        }
    }

    function test_borrowerCanWithdrawCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCanWithdrawCollateral(_id, _amountToBorrow);
    }

    function assert_borrowerCanWithdrawCollateral(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        uint256 _borrowerCollateralBalanceBefore = MockToken(address(collateralAsset)).balanceOf(address(borrower));
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(_id);
        if (request.collateralRatio != 0) {
            borrower.withdrawCollateral(_id, _withdrawableCollateral, false);
        }
        uint256 _borrowerCollateralBalanceAfter = MockToken(address(collateralAsset)).balanceOf(address(borrower));
        assertApproxEqRel(_borrowerCollateralBalanceAfter - _borrowerCollateralBalanceBefore, _collateralRequired, 1e14);
    }

    function test_lenderDepositsAndCannotWithdrawAllCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_lenderDepositsAndCannotWithdrawAllCollateral(_id, _amountToBorrow);
    }

    function assert_lenderDepositsAndCannotWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        admin.transferToken(address(collateralAsset), address(_lender), _collateralRequired);
        _lender.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(_lender, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        try _lender.withdrawAllCollateral(_id, false) {
            revert('lender should not be able to withdraw all collateral');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:OCLB1');
        }
    }

    function test_adminDepositsAndCannotWithdrawAllCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_adminDepositsAndCannotWithdrawAllCollateral(_id, _amountToBorrow);
    }

    function assert_adminDepositsAndCannotWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(admin, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        try admin.withdrawAllCollateral(_id, false) {
            revert('admin should not be able to withdraw all collateral');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:OCLB1');
        }
    }

    function test_borrowerCannotWithdrawZeroAllCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotWithdrawZeroAllCollateral(_id, _amountToBorrow);
    }

    function assert_borrowerCannotWithdrawZeroAllCollateral(uint256 _id, uint256 _amountToBorrow) public {
        try borrower.withdrawAllCollateral(_id, false) {
            revert('borrower should not be able to withdraw zero all collateral');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WAC1');
        }
    }

    function test_borrowerCannotWithdrawZeroCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotWithdrawZeroCollateral(_id, _amountToBorrow);
    }

    function assert_borrowerCannotWithdrawZeroCollateral(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        try borrower.withdrawCollateral(_id, 0, false) {
            revert('Withdrawing zero collateral should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC2');
        }
    }

    function test_borrowerCannotWithdrawMoreCollateralThanWithdrawable() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotWithdrawMoreCollateralThanWithdrawable(_id, _amountToBorrow);
    }

    function assert_borrowerCannotWithdrawMoreCollateralThanWithdrawable(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        uint256 _withdrawableCollateral = borrower.withdrawableCollateral(_id);

        try borrower.withdrawCollateral(_id, _withdrawableCollateral + 1e3, false) {
            revert('Withdrawing more collateral than withdrawable should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC1');
        }
    }

    function test_borrowerCanWithdrawAllCollateral() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCanWithdrawAllCollateral(_id, _amountToBorrow);
    }

    function assert_borrowerCanWithdrawAllCollateral(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);

        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(_id);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        uint256 _borrowerCollateralBalanceBefore = MockToken(address(collateralAsset)).balanceOf(address(borrower));
        if (request.collateralRatio != 0) {
            borrower.withdrawAllCollateral(_id, false);
        }
        uint256 _borrowerCollateralBalanceAfter = MockToken(address(collateralAsset)).balanceOf(address(borrower));
        assertApproxEqRel(_borrowerCollateralBalanceAfter - _borrowerCollateralBalanceBefore, _collateralRequired, 1e14);
    }

    function test_cannotCloseIfDebtIsNonZero() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_cannotCloseIfDebtIsNonZero(_id, _amountToBorrow);
    }

    function assert_cannotCloseIfDebtIsNonZero(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        // uint256 _borrowerBorrowAssetBalanceBefore = MockToken(address(borrowAsset)).balanceOf(address(borrower));
        borrower.borrow(_id, 90_000 * (10**ERC20(address(borrowAsset)).decimals()));
        // uint256 _borrowerBorrowAssetBalanceAfter = MockToken(address(borrowAsset)).balanceOf(address(borrower));

        try borrower.close(_id) {
            revert('Borrower should not be able to close with non-zero debt');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C2');
        }
    }

    function test_lenderCannotClose() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_invalidActorCannotClose(_id, _amountToBorrow, lenders[0].lenderAddress);
    }

    function test_adminCannotClose() public {
        uint256 _amountToBorrow = request.borrowLimit / 2;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        assert_invalidActorCannotClose(_id, _amountToBorrow, address(admin));
    }

    function assert_invalidActorCannotClose(
        uint256 _id,
        uint256 _amountToBorrow,
        address _actor
    ) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        borrower.borrow(_id, request.minBorrowAmount);

        if (_actor == address(admin)) {
            try admin.close(_id) {
                revert('Admin should not be able to close PCL');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        } else {
            PCLUser _user = PCLUser(_actor);

            try _user.close(_id) {
                revert('Invalid actor should not be able to close PCL');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        }
    }

    function test_borrowerCanRepayAndClose() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCanRepayAndClose(_id, _amountToBorrow);
    }

    function assert_borrowerCanRepayAndClose(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        borrower.borrow(_id, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));

        vm.warp(block.timestamp + (request.duration / 2));

        uint256 _currentDebt = pcl.calculateCurrentDebt(_id);
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(_id, _currentDebt);

        _currentDebt = pcl.calculateCurrentDebt(_id);
        assertEq(_currentDebt, 0);

        borrower.close(_id);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.CLOSED);
    }

    function test_repayWithInsufficientBalance() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        borrower.borrow(_id, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));

        vm.warp(block.timestamp + (request.duration / 2));

        uint256 _currentDebt = pcl.calculateCurrentDebt(_id);
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt.sub(10));
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt.sub(10));
        try borrower.repay(_id, _currentDebt) {
            revert('REVERT: Insufficient Balance');
        } catch Error(string memory reason) {
            if (!isForked) {
                assertEq(reason, 'ERC20: transfer amount exceeds allowance');
            } else {
                assertEq(reason, 'Dai/insufficient-allowance');
            }
        }
    }

    function test_borrowerCannotLiquidate() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_InvalidActorCannotLiquidate(_id, _amountToBorrow, address(borrower));
    }

    function test_adminCannotLiquidate() public {
        uint256 _amountToBorrow = request.borrowLimit;
        emit log_named_uint('request.borrowLimit', request.borrowLimit);
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_InvalidActorCannotLiquidate(_id, _amountToBorrow, address(admin));
    }

    function assert_InvalidActorCannotLiquidate(
        uint256 _id,
        uint256 _amountToBorrow,
        address _actor
    ) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        uint256 _borrowable = pcl.calculateBorrowableAmount(_id);
        borrower.borrow(_id, _borrowable);

        vm.warp(block.timestamp + (request.duration / 2));

        if (!isForked) {
            MockV3Aggregator(collateralAssetAggregatorAddress).updateAnswer(60000000000000000000);
        }

        if (_actor == address(admin)) {
            try admin.liquidate(_id, true) {
                revert('admin liquidating should revert');
            } catch Error(string memory reason) {
                assertEq(reason, 'LP:LIQ1');
            }
        } else {
            PCLUser _user = PCLUser(_actor);

            try _user.liquidate(_id, true) {
                revert('Invalid actor liquidating should revert');
            } catch Error(string memory reason) {
                assertEq(reason, 'LP:LIQ1');
            }
        }
    }

    function test_onlyLendersCanLiquidate() public {
        uint256 _amountToBorrow = request.borrowLimit / 3;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_onlyLendersCanLiquidate(_id, _amountToBorrow);
    }

    function assert_onlyLendersCanLiquidate(uint256 _id, uint256 _amountToBorrow) public {
        if (request.collateralRatio == 0) return;
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);
        uint256 _borrowable = pcl.calculateBorrowableAmount(_id);
        borrower.borrow(_id, _borrowable);

        vm.warp(block.timestamp + (request.duration / 2));

        if (!isForked) {
            MockV3Aggregator(collateralAssetAggregatorAddress).updateAnswer(60000000000000000000);
        }

        PCLUser _lender = PCLUser(lenders[1].lenderAddress);
        uint256 _amountLent = lenders[1].amount;
        _lender.liquidate(_id, true);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }

    function test_lenderCannotLiquidateZeroPrincipal() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_lenderCannotLiquidateZeroPrincipal(_id, _amountToBorrow);
    }

    function assert_lenderCannotLiquidateZeroPrincipal(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        vm.warp(block.timestamp + (request.duration / 2));
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.liquidate(_id, true) {
            revert('Lender liquidating should revert with zero principal');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L1');
        }
    }

    function test_lenderCannotLiquidateIfCollateralRatioExceedsIdeal() public {
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_lenderCannotLiquidateIfCollateralRatioExceedsIdeal(_id, _amountToBorrow);
    }

    function assert_lenderCannotLiquidateIfCollateralRatioExceedsIdeal(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);
        borrower.borrow(_id, _amountToBorrow / 2);

        vm.warp(block.timestamp + (request.duration / 2));
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.liquidate(_id, true) {
            revert('Lender liquidating should revert with if collateral ratio is more than ideal');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    function test_borrowerCannotTerminate() public {
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_borrowerCannotTerminate(_id);
    }

    function assert_borrowerCannotTerminate(uint256 _id) public {
        try borrower.terminate(_id) {
            revert('Borrower terminating PCL should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'Ownable: caller is not the owner');
        }
    }

    function test_lenderCannotTerminate() public {
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_lenderCannotTerminate(_id);
    }

    function assert_lenderCannotTerminate(uint256 _id) public {
        PCLUser _lender = PCLUser(address(lenders[0].lenderAddress));
        try _lender.terminate(_id) {
            revert('Lender terminating PCL should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'Ownable: caller is not the owner');
        }
    }

    function test_onlyAdminCanTerminate() public {
        uint256 _amountToBorrow = request.borrowLimit;
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_onlyAdminCanTerminate(_id, _amountToBorrow);
    }

    function assert_onlyAdminCanTerminate(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        borrower.borrow(_id, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));

        vm.warp(block.timestamp + (request.duration / 2));
        vm.roll(block.number + (request.duration / (2 * 20)));

        uint256 _adminCollateralAssetBalanceBefore = collateralAsset.balanceOf(address(admin));
        uint256 _adminBorrowAssetBalanceBefore = borrowAsset.balanceOf(address(admin));
        admin.terminate(_id);
        uint256 _adminCollateralAssetBalanceAfter = collateralAsset.balanceOf(address(admin));
        uint256 _adminBorrowAssetBalanceAfter = borrowAsset.balanceOf(address(admin));
        if (request.collateralAssetStrategy == compoundYieldAddress) {
            assertGe(_adminCollateralAssetBalanceAfter - _adminCollateralAssetBalanceBefore, _collateralRequired);
        } else {
            assertEq(_adminCollateralAssetBalanceAfter - _adminCollateralAssetBalanceBefore, _collateralRequired);
        }
        if (request.borrowAssetStrategy == compoundYieldAddress) {
            assertGe(
                _adminBorrowAssetBalanceAfter - _adminBorrowAssetBalanceBefore,
                (request.borrowLimit / 2) - 90_000 * 10**(ERC20(address(borrowAsset)).decimals())
            );
        } else {
            assertEq(
                _adminBorrowAssetBalanceAfter - _adminBorrowAssetBalanceBefore,
                (request.borrowLimit / 2) - 90_000 * 10**(ERC20(address(borrowAsset)).decimals())
            );
        }
    }

    function test_depositCollateral() public {
        uint256 _amount = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_depositCollateral(_id, _amount);
    }

    function assert_depositCollateral(uint256 _id, uint256 _amount) public {
        // lender.lend(_id, _amount);
        _amount = scaleToRange256(_amount, ERC20(address(collateralAsset)).decimals(), collateralAsset.totalSupply());
        admin.transferToken(address(collateralAsset), address(borrower), _amount);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _amount);
        borrower.depositCollateral(_id, _amount, false);
        uint256 _shares = IYield(request.collateralAssetStrategy).getSharesForTokens(_amount, address(collateralAsset));
        assertEq(pcl.depositedCollateralInShares(_id), _shares);
    }

    function test_depositCollateral_insufficientBalance() public {
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);

        admin.transferToken(address(collateralAsset), address(borrower), 10);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), 10);
        try borrower.depositCollateral(_id, 100, false) {
            revert('Insufficient Balance of collateral tokens');
        } catch Error(string memory reason) {
            if (!isForked) {
                assertEq(reason, 'ERC20: transfer amount exceeds balance');
            } else {
                assertEq(reason, 'SafeERC20: low-level call failed');
            }
        }
    }

    function test_depositZeroCollateral() public {
        uint256 _amount = 0;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / 2);
        assert_depositZeroCollateral(_id, _amount);
    }

    function assert_depositZeroCollateral(uint256 _id, uint256 _amount) public {
        // lender.lend(_id, _amount);
        admin.transferToken(address(collateralAsset), address(borrower), 100_000 * (10**ERC20(address(collateralAsset)).decimals()));
        borrower.setAllowance(
            pooledCreditLineAddress,
            address(collateralAsset),
            100_000 * (10**ERC20(address(collateralAsset)).decimals())
        );
        try borrower.depositCollateral(_id, _amount, false) {
            revert('Depositing zero collateral should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:DC1');
        }
    }

    function test_depositCollateralFromSavingsAccount() public {
        request.collateralAssetStrategy = compoundYieldAddress;
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, request.borrowLimit.div(2));
        emit log_named_decimal_uint('_collateralRequired', _collateralRequired, ERC20(address(collateralAsset)).decimals());
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(compoundYieldAddress, address(collateralAsset), _collateralRequired);
        if (request.collateralRatio != 0) {
            borrower.depositToSavingsAccount(
                savingsAccountAddress,
                _collateralRequired,
                address(collateralAsset),
                compoundYieldAddress,
                address(borrower)
            );
        }
        uint256 _totalTokens = SavingsAccount(savingsAccountAddress).getTotalTokens(address(borrower), address(collateralAsset));
        emit log_named_uint('total tokens: ', _totalTokens);
        uint256 _curBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(
            address(borrower),
            address(collateralAsset),
            address(compoundYieldAddress)
        );
        emit log_named_uint('_curBalanceInShares: ', _curBalanceInShares);
        emit log_named_uint('required collateral: ', _collateralRequired);
        borrower.setAllowanceForSavingsAccount(
            savingsAccountAddress,
            _collateralRequired,
            address(collateralAsset),
            pooledCreditLineAddress
        );
        _helperDepositCollateral(borrower, _id, _collateralRequired, true);
        uint256 _borrowAbleAmount = pcl.calculateBorrowableAmount(_id);
        emit log_named_uint('_borrowAbleAmount: ', _borrowAbleAmount);
        // assertEq(_borrowAbleAmount, _amountToBorrow);
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(_id);
        emit log_named_uint('_withdrawableCollateral: ', _withdrawableCollateral);
        if (request.collateralRatio != 0) {
            borrower.withdrawAllCollateral(_id, true);
        }
        uint256 _finalBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(
            address(borrower),
            address(collateralAsset),
            address(compoundYieldAddress)
        );
        emit log_named_uint('_finalBalanceInShares: ', _finalBalanceInShares);
        uint256 _pclBalanceInShares = SavingsAccount(savingsAccountAddress).balanceInShares(
            pooledCreditLineAddress,
            address(collateralAsset),
            address(compoundYieldAddress)
        );
        emit log_named_uint('_pclBalanceInShares: ', _pclBalanceInShares);
        assertApproxEqRel(_withdrawableCollateral + _pclBalanceInShares, _collateralRequired, 1e14);
    }

    function test_adminCannotCancelRequest() public {
        assert_CannotCancelRequest_InvalidActor(requestId, address(admin));
    }

    function test_lenderCannotCancelRequest() public {
        assert_CannotCancelRequest_InvalidActor(requestId, lenders[0].lenderAddress);
    }

    function assert_CannotCancelRequest_InvalidActor(uint256 _id, address _actor) public {
        if (_actor == address(admin)) {
            try admin.cancelRequest(_id) {
                revert('Admin cannot cancel PCL');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        } else {
            PCLUser _user = PCLUser(_actor);
            try _user.cancelRequest(_id) {
                revert('Invalid actor cannot cancel PCL');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:OCLB1');
            }
        }
    }

    function test_borrowerCannotCancelRequest() public {
        assert_borrowerCannotCancelRequest(requestId);
    }

    function assert_borrowerCannotCancelRequest(uint256 _id) public {
        try borrower.cancelRequest(_id) {
            revert('Canceling a PCL in active stage should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    function test_borrowerCannotRepayZeroCurrentDebt(uint128 _seed) public {
        _seed = scaleToRange128(_seed, 1, 10);
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / _seed);
        assert_borrowerCannotRepayZeroCurrentDebt(_id, _amountToBorrow);
    }

    function assert_borrowerCannotRepayZeroCurrentDebt(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);

        try borrower.repay(_id, 1) {
            revert('Borrower should not be able to repay zero current debt');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:REP3');
        }
    }

    function test_borrowerCannotRepayIfInterestIsZero(uint128 _seed) public {
        _seed = scaleToRange128(_seed, 1, 10);
        uint256 _amountToBorrow = request.borrowLimit;

        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit / _seed);
        assert_borrowerCannotRepayIfInterestIsZero(_id, _amountToBorrow);
    }

    function assert_borrowerCannotRepayIfInterestIsZero(uint256 _id, uint256 _amountToBorrow) public {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
        uint256 _borrowAssetDecimalScaling = 10**(ERC20(address(borrowAsset)).decimals());

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, _id, _collateralRequired, false);
        borrower.borrow(_id, 90_000 * _borrowAssetDecimalScaling);

        try borrower.repay(_id, 1) {
            revert('Borrower should not be able to repay if interest is zero');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:REP4');
        }
    }

    function assert_borrowerCannotReceivePoolTokens(uint256 _id) public {
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _id);
        log_named_uint('lender lp balance: ', _balance);
        try _lender.transferLPTokens(address(borrower), _id, _balance) {
            revert('should not have been possible to send LP tokens to the borrower');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT2');
        }
    }

    function test_borrowerCannotReceivePoolTokens() public {
        assert_borrowerCannotReceivePoolTokens(requestId);
        request.borrowerVerifier = mockAdminVerifier1;
        borrower.registerSelf(mockAdminVerifier1);
        (uint256 _id, ) = goToActiveStage(5, request.borrowLimit);
        assert_borrowerCannotReceivePoolTokens(_id);
    }

    function assert_canTransferPoolTokensToVerifiedUser(
        uint256 _id,
        address _recevingAddress,
        uint256 _amount
    ) public {
        // borrowing some tokens
        {
            uint256 _borrowAssetDecimalScaling = 10**(ERC20(address(borrowAsset)).decimals());
            uint256 _amountToBorrow = 100_000 * _borrowAssetDecimalScaling;
            uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);
            admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
            borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
            _helperDepositCollateral(borrower, _id, _collateralRequired, false);
            borrower.borrow(_id, 90_000 * _borrowAssetDecimalScaling);

            // going ahead in time to generate interest
            vm.warp(block.timestamp + 6 days);
            // repaying the interest and some principal back
            borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), 10_000 * _borrowAssetDecimalScaling);
            borrower.repay(_id, 10_000 * _borrowAssetDecimalScaling);
        }

        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        // withdrawing interest to set borrowerInterestSharesWithdrawn (BISW) for the lender
        _lender.withdrawInterest(_id);

        uint256 prevLenderBISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).borrowerInterestSharesWithdrawn;
        uint256 prevLenderYISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).yieldInterestWithdrawnShares;
        // calculating the receivers interest in shares
        uint256 receiverInterestInTokens = lp.getLenderInterestWithdrawable(_id, _recevingAddress);
        uint256 receiverInterestInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(
            receiverInterestInTokens,
            address(borrowAsset)
        );

        uint256 _prevBalance = lp.balanceOf(_recevingAddress, _id);
        _lender.transferLPTokens(_recevingAddress, _id, _amount);

        uint256 _finalBalance = lp.balanceOf(_recevingAddress, _id);
        assertEq(_finalBalance - _prevBalance, _amount);

        uint256 curLenderISW = lp.getLenderInfo(_id, _lenderInfo.lenderAddress).borrowerInterestSharesWithdrawn;
        curLenderISW = curLenderISW + lp.getLenderInfo(_id, _lenderInfo.lenderAddress).yieldInterestWithdrawnShares;
        uint256 curReceiverISW = lp.getLenderInfo(_id, _recevingAddress).borrowerInterestSharesWithdrawn;
        curReceiverISW = curReceiverISW + lp.getLenderInfo(_id, _recevingAddress).yieldInterestWithdrawnShares;
        assertApproxEqRel(curReceiverISW, prevLenderBISW + prevLenderYISW - curLenderISW + receiverInterestInShares, 1e14);
    }

    function assert_cannotTransferEcxessPoolTokens(
        uint256 _id,
        address _recevingAddress,
        uint256 _amount
    ) public {
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        try _lender.transferLPTokens(_recevingAddress, _id, _amount) {
            revert('balance less than the amount to transfer');
        } catch Error(string memory reason) {
            // assertEq(reason, 'ERC1155: insufficient balance for transfer');
            assertEq(reason, 'SafeMath: subtraction overflow');
        }
    }

    function assert_cannotTransferPoolTokensToNotVerifiedUser(uint256 _id, address _newUserAddress) public {
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _id);
        log_named_uint('lender lp balance: ', _balance);
        // testing when user is not verified
        try _lender.transferLPTokens(_newUserAddress, _id, _balance) {
            revert('should not have been possible to send LP tokens to not verified user');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT3');
        }
    }

    function test_lenderTransfersTokenToAnotherLender() public {
        LenderInfo memory _lenderInfo = lenders[0];
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);
        address _recevingAddress = lenders[1].lenderAddress;
        assert_canTransferPoolTokensToVerifiedUser(requestId, _recevingAddress, _balance / 3);
        assert_cannotTransferEcxessPoolTokens(requestId, _recevingAddress, _balance);
    }

    function test_lenderTransferTokenToNewUser() public {
        PCLUser _newUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        assert_cannotTransferPoolTokensToNotVerifiedUser(requestId, address(_newUser));

        // testing when user is verified
        _newUser.registerSelf(mockAdminVerifier1);

        LenderInfo memory _lenderInfo = lenders[0];
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);

        assert_canTransferPoolTokensToVerifiedUser(requestId, address(_newUser), _balance / 3);
    }

    function test_areTokensTransferable() public {
        request.areTokensTransferable = false;
        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);
        LenderInfo memory _lenderInfo = lenders[0];

        address _recevingAddress = lenders[1].lenderAddress;
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, _requestId);
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        try _lender.transferLPTokens(_recevingAddress, _requestId, _balance) {
            revert('should not have been possible to send LP tokens to the borrower');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT5');
        }
    }

    function test_canTransferPoolTokensWhenZeroInterest() public {
        PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);
        uint256 _startBalanceLenderFrom = lp.balanceOf(address(_lenderFrom), requestId);
        assertGe(_startBalanceLenderFrom, 0);
        assertEq(lp.getLenderInterestWithdrawable(requestId, address(_lenderFrom)), 0);

        PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);
        uint256 _startBalanceLenderTo = lp.balanceOf(address(_lenderTo), requestId);
        assertGe(_startBalanceLenderTo, 0);
        assertEq(lp.getLenderInterestWithdrawable(requestId, address(_lenderTo)), 0);

        _lenderFrom.transferLPTokens(address(_lenderTo), requestId, _startBalanceLenderFrom);
        assertEq(0, lp.balanceOf(address(_lenderFrom), requestId));
        assertEq(lp.balanceOf(address(_lenderTo), requestId), _startBalanceLenderFrom.add(_startBalanceLenderTo));
    }

    function test_cannotWithdrawZeroInterest() public {
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);

        // cannot withdraw zero interest
        vm.expectRevert(bytes('LP:WI1'));
        _lender.withdrawInterest(requestId);
    }

    function test_newPoolTokenHolderCanWithdrawInterest() public {
        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        PCLUser _newUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _newUser.registerSelf(mockAdminVerifier1);
        uint256 _balance = lp.balanceOf(_lenderInfo.lenderAddress, requestId);
        _lender.transferLPTokens(address(_newUser), requestId, _balance);
        uint256 _newUserBalance = lp.balanceOf(address(_newUser), requestId);
        assertEq(_newUserBalance, _balance);
        // borrowing some tokens
        uint256 _amountToBorrow = request.borrowLimit;
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);
        borrower.borrow(requestId, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        // going ahead in time to generate interest
        vm.warp(block.timestamp + 6 days);
        // repaying the interest and some principal back
        borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), 10_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        borrower.repay(requestId, 10_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        // fetch borrowerInterestSharesWithdrawn for new user
        uint256 _prevBISW = lp.getLenderInfo(requestId, address(_newUser)).borrowerInterestSharesWithdrawn;
        assertEq(_prevBISW, 0);
        // get the interest for the new user
        uint256 _interestInTokens = lp.getLenderInterestWithdrawable(requestId, address(_newUser));
        uint256 _interestInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(_interestInTokens, address(borrowAsset));
        // withdrawing interest to set borrowerInterestSharesWithdrawn (BISW) for the newUser
        _newUser.withdrawInterest(requestId);
        uint256 _curBISW = lp.getLenderInfo(requestId, address(_newUser)).borrowerInterestSharesWithdrawn;
        uint256 _curYISW = lp.getLenderInfo(requestId, address(_newUser)).yieldInterestWithdrawnShares;
        // match the interest shares withdrawn with the interest calculated
        assertApproxEqRel(_curBISW + _curYISW, _interestInShares, 1e14);
    }

    function test_stateAfterBorrow() public {
        admin.updateProtocolFeeFraction(0);

        uint256 _amountToBorrow = request.borrowLimit;
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);

        uint256 _expectedCollateralShares = IYield(request.collateralAssetStrategy).getSharesForTokens(
            _collateralRequired,
            address(collateralAsset)
        );
        uint256 _actualCollateralShares = pcl.depositedCollateralInShares(requestId);
        assertEq(_expectedCollateralShares, _actualCollateralShares);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        emit log_named_uint('borrowable amount', _borrowableAmount);
        assertApproxEqRel(_amountToBorrow, _borrowableAmount, 1e14);

        uint256 _borrowerBalanceBefore = borrowAsset.balanceOf(address(borrower));
        borrower.borrow(requestId, _borrowableAmount);
        uint256 _borrowerBalanceAfter = borrowAsset.balanceOf(address(borrower));

        assertApproxEqRel(_borrowerBalanceAfter - _borrowerBalanceBefore, _borrowableAmount, 1e14);
        assertApproxEqRel(pcl.calculateCurrentDebt(requestId), _amountToBorrow, 1e14);
    }

    function assert_calculateBorrowableAmountAndRequiredCollateral(uint128 _amountToBorrow, uint256 _borrowFraction) public {
        _borrowFraction = scaleToRange256(_borrowFraction, 1e16, pcl.SCALING_FACTOR());
        _amountToBorrow = scaleToRange128(_amountToBorrow, uint128(request.minBorrowAmount), request.borrowLimit);
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);
        emit log_named_uint('_collateralRequired: ', _collateralRequired);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);
        // borrow some amount
        uint256 _curBorrowAmount = _amountToBorrow.mul(_borrowFraction).div(pcl.SCALING_FACTOR());
        if (_curBorrowAmount == _amountToBorrow) {
            _curBorrowAmount = _curBorrowAmount.mul(90).div(100);
        }
        borrower.borrow(requestId, _curBorrowAmount);
        // check borrow able amount
        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        if (request.collateralRatio != 0) {
            assertApproxEqRel(_borrowableAmount, _amountToBorrow.sub(_curBorrowAmount), 1e14);
        } else {
            assertApproxEqRel(_borrowableAmount, request.borrowLimit.sub(_curBorrowAmount), 1e14);
        }
        // now check withdrawableCollateral
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        uint256 _curCollateralRequired = pcl.getRequiredCollateral(requestId, _curBorrowAmount);
        assertApproxEqRel(_withdrawableCollateral, _collateralRequired.sub(_curCollateralRequired), 1e14);
    }

    function test_calculateBorrowableAmountAndRequiredCollateral(uint128 _amountToBorrow, uint256 _borrowFraction) public {
        assert_calculateBorrowableAmountAndRequiredCollateral(_amountToBorrow, _borrowFraction);
    }

    function test_collateralTokensToLiquidate(uint128 _borrowAmount) public {
        _borrowAmount = scaleToRange128(_borrowAmount, 1e6, request.borrowLimit);
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 _calculatedTokensToLiquidate = _borrowAmount.mul(10**_decimals).div(_ratioOfPrices);
        assertEq(_calculatedTokensToLiquidate, pcl.getEquivalentCollateralTokens(requestId, _borrowAmount));
    }

    function test_calculateCurrentCollateralRatio(uint256 _collateralAmount, uint256 _collateralRatioToAchieve) public {
        if (request.collateralRatio == 0) return;
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 _maxCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit);
        uint256 _minCollateral = pcl.getRequiredCollateral(requestId, 1e3 * (10**ERC20(address(borrowAsset)).decimals()));
        emit log_named_uint('_maxCollateral: ', _maxCollateral);
        emit log_named_uint('_minCollateral: ', _minCollateral);
        _collateralAmount = scaleToRange256(_collateralAmount, _minCollateral, _maxCollateral);
        emit log_named_uint('_collateralAmount: ', _collateralAmount);
        _collateralRatioToAchieve = scaleToRange256(_collateralRatioToAchieve, request.collateralRatio, 1e22);
        emit log_named_uint('_collateralRatioToAchieve: ', _collateralRatioToAchieve);
        // calulating what should borrowed to achieve _collateralRatioToAchieve
        uint256 _amountToBorrow = _collateralAmount.mul(_ratioOfPrices).div(10**_decimals).mul(pcl.SCALING_FACTOR()).div(
            _collateralRatioToAchieve
        );
        emit log_named_uint('_amountToBorrow: ', _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralAmount);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralAmount);
        _helperDepositCollateral(borrower, requestId, _collateralAmount, false);
        assertApproxEqRel(_collateralAmount, pcl.calculateTotalCollateralTokens(requestId), 1e14);

        uint256 _maxBorrowable = pcl.calculateBorrowableAmount(requestId);
        emit log_named_uint('_maxBorrowable: ', _maxBorrowable);
        if (
            request.collateralRatio != 0 && ((_collateralRatioToAchieve - request.collateralRatio) * 1e18) / request.collateralRatio <= 1e14
        ) {
            assertApproxEqRel(_amountToBorrow, _maxBorrowable, 1e14);
            if (_amountToBorrow > _maxBorrowable) {
                _amountToBorrow = _maxBorrowable;
            }
        } else {
            assertLe(_amountToBorrow, _maxBorrowable);
        }

        borrower.borrow(requestId, _amountToBorrow);
        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
        assertApproxEqRel(_currentDebt, _amountToBorrow, 1e14);

        uint256 _curCollateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        emit log_named_uint('_curCollateralRatio: ', _curCollateralRatio);
        // 0.01% diff between _curCollateralRatio and _collateralRatioToAchieve
        assertApproxEqRel(_curCollateralRatio, _collateralRatioToAchieve, 1e14);
    }

    function test_closeActivePCLOncePrincipalPaidAndEnded() public {
        // borrowing some tokens
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, request.borrowLimit);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);
        borrower.borrow(requestId, 90_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        // going ahead in time to generate interest
        vm.warp(block.timestamp + 6 days);
        // repay everything back
        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
        uint256 _balance = borrowAsset.balanceOf(address(borrower));
        if (_currentDebt > _balance) {
            admin.transferToken(address(borrowAsset), address(borrower), _currentDebt.sub(_balance));
        }
        borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt);
        // go to end of pcl
        vm.warp(block.timestamp + request.collectionPeriod + request.duration);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
        assertEq(0, borrowAsset.balanceOf(address(borrower)));
    }

    event CollateralSharesWithdrawn(uint256 indexed id, uint256 amount);

    function test_closeWhenNoCollateral() public {
        vm.warp(block.timestamp + 6 days);
        // close
        borrower.close(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_closeWhenCollateral() public {
        uint256 _collateralAmount = 1e2 * 10**ERC20(address(collateralAsset)).decimals();
        admin.transferToken(address(collateralAsset), address(borrower), _collateralAmount);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralAmount);
        _helperDepositCollateral(borrower, requestId, _collateralAmount, false);
        uint256 _startBalance = collateralAsset.balanceOf(address(borrower));
        vm.warp(block.timestamp + 6 days);
        vm.roll(block.number + (6 * 86400) / 20);
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        uint256 _shares = IYield(request.collateralAssetStrategy).getSharesForTokens(_withdrawableCollateral, address(collateralAsset));
        vm.expectEmit(true, true, false, false);
        emit CollateralSharesWithdrawn(requestId, _shares);
        // close
        borrower.close(requestId);
        // this is equal only when no yield is used
        // with compund this should be assertLe becuase deposited collateral would earn yield
        if (request.collateralAssetStrategy == compoundYieldAddress) {
            assertLe(_startBalance.add(_collateralAmount), collateralAsset.balanceOf(address(borrower)));
        } else {
            assertEq(_startBalance.add(_collateralAmount), collateralAsset.balanceOf(address(borrower)));
        }
    }

    event LiquidationWithdrawn(uint256 indexed id, address indexed user, uint256 collateralShare);
    event WithdrawLiquidity(uint256 indexed id, address indexed user, uint256 shares);

    function test_withdrawLiquidatedCollateral() public {
        if (request.collateralRatio == 0) return;
        // borrowing some tokens
        uint256 _amountToBorrow = request.borrowLimit.mul(7).div(11);
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);
        uint256 _borrowable = pcl.calculateBorrowableAmount(requestId);
        borrower.borrow(requestId, _borrowable.sub(10));
        uint256 _sharesHeld = IYield(request.borrowAssetStrategy).getSharesForTokens(
            request.borrowLimit - _borrowable.sub(10),
            address(borrowAsset)
        );
        // going ahead in time to make liquidation possible
        vm.warp(block.timestamp + 50 days);
        assertLt(pcl.calculateCurrentCollateralRatio(requestId), request.collateralRatio);
        uint256 _principalBorowable = request.borrowLimit.sub(pcl.getPrincipal(requestId));

        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        uint256 _totalSupply = lp.totalSupply(requestId);
        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);

        uint256 _lenderCollateralShare = _collateralRequired.mul(_lenderLpBalance).div(_totalSupply);
        uint256 _lenderLiquidityShare = _principalBorowable.mul(_lenderLpBalance).div(_totalSupply);
        uint256 _principalBorowableInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(
            _principalBorowable,
            address(borrowAsset)
        );
        uint256 _lenderYieldShares = (_sharesHeld - _principalBorowableInShares).mul(_lenderLpBalance).div(_totalSupply);
        uint256 _shares = IYield(request.borrowAssetStrategy).getSharesForTokens(_lenderLiquidityShare, address(borrowAsset)) +
            _lenderYieldShares;

        vm.expectEmit(true, true, false, false);
        emit WithdrawLiquidity(requestId, _lenderInfo.lenderAddress, _shares);
        _lender.liquidate(requestId, true);
        if (request.collateralAssetStrategy == compoundYieldAddress) {
            assertLe(_lenderCollateralShare, collateralAsset.balanceOf(address(_lender)));
        } else {
            assertEq(_lenderCollateralShare, collateralAsset.balanceOf(address(_lender)));
        }
    }

    event PooledCreditLineTerminated(uint256 indexed id);

    function test_terminateAfterLiquidation() public {
        if (request.collateralRatio == 0) return;
        // borrowing some tokens
        uint256 _amountToBorrow = request.borrowLimit.mul(7).div(11);
        uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, _amountToBorrow);
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        _helperDepositCollateral(borrower, requestId, _collateralRequired, false);
        uint256 _borrowable = pcl.calculateBorrowableAmount(requestId);
        borrower.borrow(requestId, _borrowable);
        uint256 _sharesHeld = IYield(request.borrowAssetStrategy).getSharesForTokens(
            request.borrowLimit - _borrowable,
            address(borrowAsset)
        );

        // going ahead in time to make liquidation possible
        vm.warp(block.timestamp + request.duration.mul(7).div(11));
        vm.roll(block.number + request.duration.mul(7).div(11).div(20));
        assertLt(pcl.calculateCurrentCollateralRatio(requestId), request.collateralRatio);
        uint256 _principalBorowable = request.borrowLimit.sub(pcl.getPrincipal(requestId));

        LenderInfo memory _lenderInfo = lenders[0];
        PCLUser _lender = PCLUser(_lenderInfo.lenderAddress);
        uint256 _totalSupply = lp.totalSupply(requestId);
        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);
        uint256 _lenderCollateralShare = _collateralRequired.mul(_lenderLpBalance).div(_totalSupply);
        uint256 _lenderLiquidityShare = _principalBorowable.mul(_lenderLpBalance).div(_totalSupply);
        uint256 _principalBorowableInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(
            _principalBorowable,
            address(borrowAsset)
        );
        uint256 _lenderYieldShares = (_sharesHeld - _principalBorowableInShares).mul(_lenderLpBalance).div(_totalSupply);
        uint256 _shares = IYield(request.borrowAssetStrategy).getSharesForTokens(_lenderLiquidityShare, address(borrowAsset)) +
            _lenderYieldShares;
        vm.expectEmit(true, true, false, false);

        emit WithdrawLiquidity(requestId, _lenderInfo.lenderAddress, _shares);
        _lender.liquidate(requestId, true);

        uint256 _startBorrowAssetBalance = borrowAsset.balanceOf(address(admin));
        uint256 _startCollateralAssetBalance = collateralAsset.balanceOf(address(admin));

        uint256 _lenderPoolCollateralAssetBalance = collateralAsset.balanceOf(address(lp));
        emit log_named_uint('_lenderPoolCollateralAssetBalance: ', _lenderPoolCollateralAssetBalance);
        // for an active pcl borrowLimit == total amount lent
        _totalSupply = lp.totalSupply(requestId);
        // (uint256 _borrowLimit, , , , , , , , , , , ) = pcl.pooledCreditLineConstants(requestId);
        // uint256 _borrowAssetInLenderPool = _borrowLimit.sub(pcl.getPrincipal(requestId)).mul(_totalSupply).div(_borrowLimit);
        // emit log_named_uint('_borrowAssetInLenderPool: ', _borrowAssetInLenderPool);

        // now the admin terminates
        vm.expectEmit(true, true, false, true);
        emit PooledCreditLineTerminated(requestId);
        admin.terminate(requestId);

        assertEq(_startCollateralAssetBalance.add(_lenderPoolCollateralAssetBalance), collateralAsset.balanceOf(address(admin)));

        if (request.borrowAssetStrategy == compoundYieldAddress) {
            // assertLe(_startBorrowAssetBalance.add(_borrowAssetInLenderPool), borrowAsset.balanceOf(address(admin)));
        } else {
            // assertEq(_startBorrowAssetBalance.add(_borrowAssetInLenderPool), borrowAsset.balanceOf(address(admin)));
        }
    }

    function _helperDepositCollateral(
        PCLUser _user,
        uint256 _id,
        uint256 _amount,
        bool _fromSavingsAccount
    ) private {
        if (_amount != 0) {
            _user.depositCollateral(_id, _amount, _fromSavingsAccount);
        }
    }
}",17882
RealWorld_BA_101_MockV3Aggregator_RealWord_20240827085340.log,101,MockV3Aggregator,12692,4426,17118,65.0,0.15198,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

import '@chainlink/contracts/src/v0.7/interfaces/AggregatorV3Interface.sol';

/**
 * @title MockV3Aggregator
 * @notice Based on the FluxAggregator contract
 * @notice Use this contract when you need to test
 * other contract's ability to read data from an
 * aggregator contract, but how the aggregator got
 * its answer is unimportant
 */
contract MockV3Aggregator is AggregatorV3Interface {
    uint256 public constant override version = 0;

    uint8 public override decimals;
    int256 public latestAnswer;
    uint256 public latestTimestamp;
    uint256 public latestRound;

    mapping(uint256 => int256) public getAnswer;
    mapping(uint256 => uint256) public getTimestamp;
    mapping(uint256 => uint256) private getStartedAt;

    constructor(uint8 _decimals, int256 _initialAnswer) {
        decimals = _decimals;
        updateAnswer(_initialAnswer);
    }

    function updateAnswer(int256 _answer) public {
        latestAnswer = _answer;
        latestTimestamp = block.timestamp;
        latestRound++;
        getAnswer[latestRound] = _answer;
        getTimestamp[latestRound] = block.timestamp;
        getStartedAt[latestRound] = block.timestamp;
    }

    function updateRoundData(
        uint80 _roundId,
        int256 _answer,
        uint256 _timestamp,
        uint256 _startedAt
    ) public {
        latestRound = _roundId;
        latestAnswer = _answer;
        latestTimestamp = _timestamp;
        getAnswer[latestRound] = _answer;
        getTimestamp[latestRound] = _timestamp;
        getStartedAt[latestRound] = _startedAt;
    }

    function getRoundData(uint80 _roundId)
        external
        view
        override
        returns (
            uint80 roundId,
            int256 answer,
            uint256 startedAt,
            uint256 updatedAt,
            uint80 answeredInRound
        )
    {
        return (_roundId, getAnswer[_roundId], getStartedAt[_roundId], getTimestamp[_roundId], _roundId);
    }

    function latestRoundData()
        external
        view
        override
        returns (
            uint80 roundId,
            int256 answer,
            uint256 startedAt,
            uint256 updatedAt,
            uint80 answeredInRound
        )
    {
        return (uint80(latestRound), getAnswer[latestRound], getStartedAt[latestRound], getTimestamp[latestRound], uint80(latestRound));
    }

    function setAnswer(int256 _answer) public {
        updateAnswer(_answer);
    }

    function description() external view override returns (string memory) {
        return 'v0.6/tests/MockV3Aggregator.sol';
    }
}",603
RealWorld_BA_101_Paused_RealWord_20240827090445.log,101,Paused,3178,3563,6741,60.0,0.08715,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

contract Paused {}",20
RealWorld_BA_101_PCLLifecycleTestLowBorrowRate.t_RealWord_20240827095148.log,101,PCLLifecycleTestLowBorrowRate.t,5219,4979,10198,81.0,0.125675,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import './PCLLifecycleTest.t.sol';

contract PCLLifecycleTestLowBorrowRate is PCLLifecycleTest {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    function setUp() public override {
        super.setUp();
        request.borrowRate = uint128(PCLConstants.minBorrowRate);
        request.borrowAssetStrategy = compoundYieldAddress;
        request.collateralAssetStrategy = compoundYieldAddress;
    }
}",125
RealWorld_BA_101_PCLERC1155HooksTest.t_RealWord_20240827090926.log,101,PCLERC1155HooksTest.t,28827,5716,34543,81.0,0.258455,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../SublimeProxy.sol';
import '../../PooledCreditLine/PooledCreditLine.sol';
import '../../PooledCreditLine/LenderPool.sol';
import '../../PriceOracle.sol';
import '../../interfaces/IPriceOracle.sol';
import '../../SavingsAccount/SavingsAccount.sol';
import '../../yield/StrategyRegistry.sol';
import '../../yield/NoYield.sol';
import '../../yield/CompoundYield.sol';
import '../../mocks/MockV3Aggregator.sol';
import '../../mocks/MockToken.sol';
import '../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../interfaces/ISavingsAccount.sol';
import './Helpers/PCLParent.t.sol';

contract MaliciousLenderStart is PCLUser {
    constructor(address _pclAddress, address _lpAddress) PCLUser(_pclAddress, _lpAddress) {}

    function onERC1155Received(
        address,
        address,
        uint256 id,
        uint256,
        bytes calldata
    ) external override returns (bytes4) {
        // any code can be executed here
        LenderPool(msg.sender).start(id);
        return bytes4(keccak256('onERC1155Received(address,address,uint256,uint256,bytes)'));
    }
}

contract MaliciousLenderLiquidate is PCLUser {
    constructor(address _pclAddress, address _lpAddress) PCLUser(_pclAddress, _lpAddress) {}

    function onERC1155Received(
        address,
        address,
        uint256 id,
        uint256,
        bytes calldata
    ) external override returns (bytes4) {
        // any code can be executed here
        LenderPool(msg.sender).liquidate(id, true);
        return bytes4(keccak256('onERC1155Received(address,address,uint256,uint256,bytes)'));
    }
}

contract MaliciousLenderWithdrawInterest is PCLUser {
    constructor(address _pclAddress, address _lpAddress) PCLUser(_pclAddress, _lpAddress) {}

    function onERC1155Received(
        address,
        address,
        uint256 id,
        uint256,
        bytes calldata
    ) external override returns (bytes4) {
        // any code can be executed here
        LenderPool(msg.sender).withdrawInterest(id);
        return bytes4(keccak256('onERC1155Received(address,address,uint256,uint256,bytes)'));
    }
}

contract PCLERC1155HooksTest is PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 requestId;

    // enum PooledCreditLineStatus {
    //     NOT_CREATED,
    //     REQUESTED,
    //     ACTIVE,
    //     CLOSED,
    //     EXPIRED,
    //     LIQUIDATED,
    //     CANCELLED
    // }

    function setUp() public override {
        super.setUp();

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;
    }

    function test_lendERC1155Hook() public {
        requestId = borrower.createRequest(request);
        PCLUser _pooledCreditLineLender = new MaliciousLenderStart(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(request.borrowAsset), address(_pooledCreditLineLender), request.borrowLimit);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(request.borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, request.borrowLimit) {
            revert('REVERT: should have reverted');
        } catch Error(string memory reason) {
            assertEq(reason, 'ReentrancyGuard: reentrant call');
        }
    }

    function test_withdrawInterestERC1155Hook() public {
        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit);
        admin.transferToken(address(collateralAsset), address(borrower), _requiredCollateral);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _requiredCollateral);
        borrower.depositCollateral(requestId, _requiredCollateral, false);
        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        borrower.borrow(requestId, _borrowableAmount);

        _increaseBlock(block.timestamp + request.duration.div(2));

        PCLUser _pooledCreditLineLender = new MaliciousLenderWithdrawInterest(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        try _lender.transferLPTokens(address(_pooledCreditLineLender), requestId, lp.balanceOf(address(_lender), requestId)) {
            revert('should throw LP:WI1');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WI1');
        }
    }

    function test_liquidateERC1155Hook() public {
        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit);
        admin.transferToken(address(collateralAsset), address(borrower), _requiredCollateral);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _requiredCollateral);
        borrower.depositCollateral(requestId, _requiredCollateral, false);
        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        borrower.borrow(requestId, _borrowableAmount);

        PCLUser _pooledCreditLineLender = new MaliciousLenderLiquidate(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        _increaseBlock(block.timestamp + request.duration);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        _lender.transferLPTokens(address(_pooledCreditLineLender), requestId, lp.balanceOf(address(_lender), requestId));
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
    }
}",1599
RealWorld_BA_101_PCLCancelledStateCompoundYield.t_RealWord_20240827103343.log,101,PCLCancelledStateCompoundYield.t,12904,5580,18484,95.0,0.17612,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '../PCLCancelledState.t.sol';
import '../../Helpers/PCLParent.t.sol';

contract PCLCancelledStatePriceOracleCompoundYield is PCLCancelledStatePriceOracle {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    function setUp() public override {
        PCLParent.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();
        _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));
        _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));

        _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();
        _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));
        _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = compoundYieldAddress;
        request.collateralAssetStrategy = compoundYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        lender_0 = lenders[0].lenderAddress;

        // Let's travel a few days, but stay within the collection period
        vm.warp(block.timestamp + request.collectionPeriod / 2);

        // Borrower tries to cancel the PCL
        borrower.cancelRequest(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CANCELLED, '!Cancelled');
    }
}",597
RealWorld_BA_101_PCLClosedStage.t_RealWord_20240827092752.log,101,PCLClosedStage.t,0,0,0,,0.0,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../mocks/MockToken.sol';
import '../Helpers/PCLParent.t.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';

contract PCLClosedStage is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;

    uint256 requestId;

    function setUp() public virtual override {
        super.setUp();

        request.borrowLimit = uint128(1_000_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * 1e18) / 1e2);
        request.collateralRatio = 1e18;
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * 1e18) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        // The below function will create the PCL request and then lenders lend the entire requested amount
        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        borrowAndRepay(requestId);

        // Now the PCL should be in the CLOSED state
        borrower.close(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function borrowAndRepay(uint256 _id) public {
        // Now we assert that we are in the ACTIVE state
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(_id, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);
        if (request.collateralRatio != 0) {
            borrower.depositCollateral(_id, _requiredCollateral, false);
        }

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(_id);
        // And borrows the borrowable amount
        borrower.borrow(_id, borrowableAmount);

        // Borrower decides to repay everything at mid-duration

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 2);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(_id);
        // Borrower decides to repay the entire debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt);
        borrower.repay(_id, currentDebt);
    }

    /*************************************************************************************************************************************
    Start function calls
    *************************************************************************************************************************************/

    function assert_start_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.start(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotStartAClosedPCL() public {
        assert_start_functionality_in_closed_state(requestId, admin, 'Admin cannot start a PCL in closed state', 'LP:S1');
    }

    function test_borrowerCannotStartAClosedPCL() public {
        assert_start_functionality_in_closed_state(requestId, borrower, 'Borrower cannot start a PCL in closed state', 'LP:S1');
    }

    function test_lenderCannotStartAClosedPCL() public {
        assert_start_functionality_in_closed_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot start a PCL in closed state',
            'LP:S1'
        );
    }

    /*************************************************************************************************************************************
    Cancel function calls
    *************************************************************************************************************************************/

    function assert_cancel_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.cancelRequest(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotCancelAClosedPCL() public {
        assert_cancel_functionality_in_closed_state(requestId, admin, 'Admin cannot cancel a PCL in closed state', 'PCL:OCLB1');
    }

    function test_borrowerCannotCancelAClosedPCL() public {
        assert_cancel_functionality_in_closed_state(requestId, borrower, 'Borrower cannot cancel a PCL in closed state', 'PCL:CR1');
    }

    function test_lenderCannotCancelAClosedPCL() public {
        assert_cancel_functionality_in_closed_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot cancel a PCL in closed state',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    Close function calls
    *************************************************************************************************************************************/

    function assert_close_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.close(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotCloseAClosedPCL() public {
        assert_close_functionality_in_closed_state(requestId, admin, 'Admin cannot close a closed PCL', 'PCL:OCLB1');
    }

    function test_borrowerCannotCloseAClosedPCL() public {
        assert_close_functionality_in_closed_state(requestId, borrower, 'Borrower cannot close a closed PCL', 'PCL:C1');
    }

    function test_lenderCannotCloseAClosedPCL() public {
        assert_close_functionality_in_closed_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot close a closed PCL',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    Deposit collateral function calls
    *************************************************************************************************************************************/

    function assert_collateralCannotBeDepositedInClosedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _depositor,
        bool _isDepositorLender
    ) public {
        if (_isDepositorLender) {
            _depositor = PCLUser(lenders[0].lenderAddress);
        }

        admin.transferToken(address(collateralAsset), address(_depositor), _amount);
        _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);

        try _depositor.depositCollateral(_id, _amount, false) {
            revert('Collateral cannot be deposited in the CLOSED state');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:DC2');
        }
    }

    function test_borrowerCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, borrower, true);
    }

    function test_lenderCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, PCLUser(address(0)), true);
    }

    function test_adminCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInClosedState(requestId, _amountToDeposit, admin, false);
    }

    /*************************************************************************************************************************************
    Borrow function tests
    *************************************************************************************************************************************/

    function assertBorrowFunctionalityInClosedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.borrow(_id, _amount) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotBorrow() public {
        assertBorrowFunctionalityInClosedState(requestId, 1, admin, 'Admin cannot borrow a PCL in closed state', 'PCL:OCLB1');
    }

    function test_borrowerCannotBorrowAClosedPCL() public {
        assertBorrowFunctionalityInClosedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in closed state', 'PCL:IB3');
    }

    function test_borrowerCannotBorrowZeroAmount() public {
        assertBorrowFunctionalityInClosedState(requestId, 0, borrower, 'Borrower cannot borrow a PCL in closed state', 'PCL:IB1');
    }

    function test_lenderCannotBorrow() public {
        assertBorrowFunctionalityInClosedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot borrow a PCL in closed state',
            'PCL:OCLB1'
        );
    }

    /**************************************************************************************************************************************
    Repay function tests
    **************************************************************************************************************************************/

    function assertRepayFunctionalityInClosedState(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.repay(_id, 1) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotRepayAClosedPCL() public {
        assertRepayFunctionalityInClosedState(requestId, admin, 'Admin cannot repay a closed PCL', 'PCL:REP2');
    }

    function test_borrowerCannotRepayAClosedPCL() public {
        assertRepayFunctionalityInClosedState(requestId, borrower, 'Borrower cannot repay a closed PCL', 'PCL:REP2');
    }

    function test_lenderCannotRepayAClosedPCL() public {
        assertRepayFunctionalityInClosedState(requestId, PCLUser(lenders[0].lenderAddress), 'Lender cannot repay a closed PCL', 'PCL:REP2');
    }

    /*************************************************************************************************************************************
    Withdraw collateral function tests
    *************************************************************************************************************************************/

    function assertWithdrawCollateralFunctionalityInClosedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage,
        string memory _errorMessageAll
    ) public virtual {
        if (pcl.withdrawableCollateral(_id) > 0 && _user == borrower) {
            uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));
            _user.withdrawAllCollateral(_id, false);
            uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));
            assertGe(_balanceAfter, _balanceBefore);
        } else {
            try _user.withdrawAllCollateral(_id, false) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessageAll);
            }
        }

        if (pcl.withdrawableCollateral(_id) >= _amount && _user == borrower && _amount != 0) {
            uint256 _balanceBefore = collateralAsset.balanceOf(address(_user));
            _user.withdrawCollateral(_id, _amount, false);
            uint256 _balanceAfter = collateralAsset.balanceOf(address(_user));
            assertApproxEqAbs(_balanceAfter - _balanceBefore, _amount, 2);
        } else {
            try _user.withdrawCollateral(_id, _amount, false) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInClosedState(
            requestId,
            1,
            admin,
            'Admin cannot withdraw collateral in closed state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInClosedState(
            requestId,
            1,
            borrower,
            'Borrower cannot withdraw collateral in closed state',
            'PCL:WC1',
            'PCL:WAC1'
        );
    }

    function test_borrowerCannotWithdrawZeroCollateral() public {
        assertWithdrawCollateralFunctionalityInClosedState(
            requestId,
            0,
            borrower,
            'Borrower cannot withdraw collateral in closed state',
            'PCL:WC2',
            'PCL:WAC1'
        );
    }

    function test_lenderCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInClosedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot withdraw collateral in closed state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCanWithdrawCollateral() public {
        // The below function will create the PCL request and then lenders lend the entire requested amount
        (uint256 _id, ) = goToActiveStage(10, request.borrowLimit);
        borrowAndRepay(_id);
        vm.warp(block.timestamp + request.duration.mul(110).div(100));
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);

        uint256 _withdrawableCollateral = borrower.withdrawableCollateral(_id);
        emit log_named_uint('_withdrawableCollateral', _withdrawableCollateral);
        uint256 _startBalance = collateralAsset.balanceOf(address(borrower));
        if (request.collateralRatio != 0) {
            assertGt(_withdrawableCollateral, 0);
            borrower.withdrawAllCollateral(_id, false);
        }
        uint256 _finalBalance = collateralAsset.balanceOf(address(borrower));
        assertApproxEqRel(_finalBalance.sub(_startBalance), _withdrawableCollateral, 1e14);
    }

    /*************************************************************************************************************************************
    WithdrawLiquidity function calls
    **************************************************************************************************************************************/

    function assert_withdraw_liquidity_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_positiveCase) {
            uint256 _poolTokenBalanceOld = lp.balanceOf(address(_user), _id);
            uint256 _borrowTokenBalanceOld = IERC20(request.borrowAsset).balanceOf(address(_user));
            _user.withdrawLiquidity(_id);
            uint256 _poolTokenBalanceNew = lp.balanceOf(address(_user), _id);
            uint256 _borrowTokenBalanceNew = IERC20(request.borrowAsset).balanceOf(address(_user));

            assertGe((_borrowTokenBalanceNew - _borrowTokenBalanceOld), _poolTokenBalanceOld);
            assertEq(_poolTokenBalanceNew, 0);
        } else {
            try _user.withdrawLiquidity(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotWithdrawLiquidityFromAClosedPCL() public {
        assert_withdraw_liquidity_functionality_in_closed_state(
            requestId,
            admin,
            false,
            'Admin cannot WithdrawLiquidity a PCL in closed state',
            'LP:IWL1'
        );
    }

    function test_borrowerCannotWithdrawLiquidityFromAClosedPCL() public {
        assert_withdraw_liquidity_functionality_in_closed_state(
            requestId,
            borrower,
            false,
            'Borrower cannot WithdrawLiquidity a PCL in closed state',
            'LP:IWL1'
        );
    }

    function test_lenderCanWithdrawLiquidityFromAClosedPCL() public {
        assert_withdraw_liquidity_functionality_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), true, '', '');
    }

    /**************************************************************************************************************************************
    Liquidate function tests
    **************************************************************************************************************************************/

    function assert_liquidate_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.liquidate(_id, true) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    function test_adminCannotLiquidateAClosedPCL() public {
        assert_liquidate_functionality_in_closed_state(requestId, admin, 'Admin cannot liquidate a closed PCL', 'LP:LIQ1');
    }

    function test_borrowerCannotLiquidateAClosedPCL() public {
        assert_liquidate_functionality_in_closed_state(requestId, borrower, 'Borrower cannot liquidate a closed PCL', 'LP:LIQ1');
    }

    function test_lenderCannotLiquidateAClosedPCL() public {
        assert_liquidate_functionality_in_closed_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot liquidate a closed PCL',
            'PCL:L1'
        );
    }

    /*************************************************************************************************************************************
    WithdrawInterest function calls
    **************************************************************************************************************************************/

    function assert_withdraw_interest_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _errorMessage
    ) public {
        uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));
        uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));
        uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);

        uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));

        try _user.withdrawInterest(_id) {
            uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));
            uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));
            uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);

            if (_userPoolTokenBalancePreWithdraw == 0) {
                assertEq(_lenderInterest, 0);
                assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);
            } else {
                assertTrue(_lenderInterest != 0);
                assertApproxEqAbs((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest, 2);
            }

            assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);
            assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    function test_adminCannotWithdrawInterestFromAClosedPCL() public {
        assert_withdraw_interest_functionality_in_closed_state(requestId, admin, 'LP:WI1');
    }

    function test_borrowerCannotWithdrawInterestFromAClosedPCL() public {
        assert_withdraw_interest_functionality_in_closed_state(requestId, borrower, 'LP:WI1');
    }

    function test_lenderCanWithdrawInterestFromAClosedPCL() public {
        assert_withdraw_interest_functionality_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), '');
    }

    /**************************************************************************************************************************************
    Terminate function tests
    **************************************************************************************************************************************/

    function assert_terminate_functionality_in_closed_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_user != admin) {
            try _user.terminate(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        } else {
            _user.terminate(_id);
            assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        }
    }

    function test_adminCanTerminateAClosedPCL() public {
        assert_terminate_functionality_in_closed_state(requestId, admin, '', '');
    }

    function test_borrowerCannotTerminateAClosedPCL() public {
        assert_terminate_functionality_in_closed_state(
            requestId,
            borrower,
            'Should not be able to terminate a closed PCL',
            'Ownable: caller is not the owner'
        );
    }

    function test_lenderCannotTerminateAClosedPCL() public {
        assert_terminate_functionality_in_closed_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Should not be able to terminate a closed PCL',
            'Ownable: caller is not the owner'
        );
    }

    uint256 _fromUserPoolTokenSupplyOld;
    uint256 _toUserPoolTokenSupplyOld;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;
    uint256 _toInterestOwed;
    uint256 _fromInterestOwed;
    uint256 _fromBorrowTokenBalanceInitial;
    uint256 _toBorrowTokenBalanceInitial;

    /**************************************************************************************************************************************
    Pool MockToken Transfer function tests
    **************************************************************************************************************************************/

    function assert_pool_token_transfer_in_closed_stage(
        uint256 _id,
        PCLUser _fromUser,
        PCLUser _toUser,
        bool _positiveCase,
        uint256 _fractionOfPTSupply,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);

        _fromUserPoolTokenSupplyOld = lp.balanceOf(address(_fromUser), _id);
        _toUserPoolTokenSupplyOld = lp.balanceOf(address(_toUser), _id);

        if (_positiveCase) {
            _fromInterestOwed = lp.getLenderInterestWithdrawable(_id, address(_fromUser));
            _toInterestOwed = lp.getLenderInterestWithdrawable(_id, address(_toUser));

            _fromBorrowTokenBalanceInitial = borrowAsset.balanceOf(address(_fromUser));
            _toBorrowTokenBalanceInitial = borrowAsset.balanceOf(address(_toUser));

            _fromUser.transferLPTokens(address(_toUser), _id, (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply));

            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);
            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);

            assertEq(_fromUserPoolTokenSupplyNew, (_fromUserPoolTokenSupplyOld - (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply)));
            assertEq(_toUserPoolTokenSupplyNew, ((_fromUserPoolTokenSupplyOld / _fractionOfPTSupply) + _toUserPoolTokenSupplyOld));

            assertEq((borrowAsset.balanceOf(address(_toUser)) - _toBorrowTokenBalanceInitial), _toInterestOwed);
            assertEq((borrowAsset.balanceOf(address(_fromUser)) - _fromBorrowTokenBalanceInitial), _fromInterestOwed);
        } else {
            try _fromUser.transferLPTokens(address(_toUser), _id, _fromUserPoolTokenSupplyOld) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }

            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);
            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);

            assertEq(_fromUserPoolTokenSupplyOld, _fromUserPoolTokenSupplyNew);
            assertEq((_toUserPoolTokenSupplyNew - _toUserPoolTokenSupplyOld), 0);
        }
    }

    function test_poolTokenTransferComplete() public {
        assert_pool_token_transfer_in_closed_stage(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            PCLUser(lenders[1].lenderAddress),
            true,
            1,
            '',
            ''
        );
    }

    function test_poolTokenTransferPartial() public {
        assert_pool_token_transfer_in_closed_stage(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            PCLUser(lenders[1].lenderAddress),
            true,
            4,
            '',
            ''
        );
    }

    function test_poolTokenTransferToNonVerifiedUser() public {
        assert_pool_token_transfer_in_closed_stage(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            admin,
            false,
            4,
            'Non-verified user should not be able to receive pool tokens',
            'LP:IT3'
        );
    }

    function test_externalUserCannotCreate() public {
        try
            lp.create(
                requestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_externalUserCannotTerminate() public {
        try lp.terminate(requestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_cannotLendZeroAmount() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }

    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }

    function test_lenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    function test_lenderCannotWithdrawZeroInterest() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        uint256 _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));
        assertGt(_lenderInterestOwed, 0);

        uint256 _startBalance = borrowAsset.balanceOf(address(_lender));
        _lender.withdrawInterest(requestId);
        uint256 _finalBalance = borrowAsset.balanceOf(address(_lender));
        assertEq(_finalBalance.sub(_startBalance), _lenderInterestOwed);
        _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));
        assertEq(_lenderInterestOwed, 0);

        try _lender.withdrawInterest(requestId) {
            revert('Lender cannot withdraw zero interest');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WI1');
        }
    }

    function test_nonLenderCannotWithdrawLiquidationTokens() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {
            revert('Non lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WLC1');
        }
    }

    function test_lenderCannotWithdrawLiquidationTokens() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.withdrawTokensAfterLiquidation(requestId) {
            revert('Lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    function test_cannotTransferLPTokensToSameAddress() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to itself');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT1');
        }
    }

    function test_cannotTransferLPTokensToBorrower() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(borrower), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to borrower');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT2');
        }
    }

    function test_cannotBurnPoolTokens() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(0), requestId, _balanceLender) {
            revert('Lender cannot burn LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'ERC1155: transfer to the zero address');
        }
    }

    function test_cannotTransferNonTransferableLPTokens() public {
        request.areTokensTransferable = false;
        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);

        vm.warp(block.timestamp + request.duration);
        borrower.close(_requestId);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.CLOSED);

        PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lenderFrom), _requestId);
        PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);

        try _lenderFrom.transferLPTokens(address(_lenderTo), _requestId, _balanceLender) {
            revert('Lender cannot transfer non transferable LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT5');
        }
    }

    /**************************************************************************************************************************************
    View/calculation function tests
    **************************************************************************************************************************************/

    function assert_helper_functionalities_in_closed_state(
        uint256 _id,
        PCLUser _lender,
        PCLUser _borrower
    ) public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);

        // 1. calculatePrincipalWithdrawable
        uint256 _userLiquidity = lp.balanceOf(address(_lender), _id);
        uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
        assertGe(_principalWithdrawable, _userLiquidity);
        _lender.withdrawLiquidity(_id);
        uint256 newBalance = IERC20(request.borrowAsset).balanceOf(address(_lender));
        assertGe(newBalance, _userLiquidity);

        // 2. withdrawableCollateral
        uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        uint256 _oneUnitOfCollateral = 10**(ERC20(address(collateralAsset)).decimals());
        assertLe(_withdrawableCollateral, _oneUnitOfCollateral / 1e6);

        // 3.calculateTotalCollateralTokens
        uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertLe(_totalCollateral, _oneUnitOfCollateral / 1e6);

        // 4. calculateBorrowableAmount
        uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_totalBorrowable, 0); // Since PCL is closed now

        // 5. calculateInterestAccrued
        uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGe(_interestAccrued, 0); // Should be non-zero, since it calculates interest accrued since last repayment

        // 6. calculateCurrentDebt
        uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);
        assertEq(_currentDebt, 0); // Should be zero, since PCL is completely paid off

        // Test Number 7 and 8 should ideally have been returning a revert string, but right now they return PO:IGUPT1
        // and that is because since all pclConstants are deleted, address(tokens) == address(0) which throws

        // 7. calculateCurrentCollateralRatio
        try _borrower.calculateCurrentCollateralRatio(_id) {
            uint256 _currentCR = _borrower.calculateCurrentCollateralRatio(_id);
            assertEq(_currentCR, uint256(-1)); // infinite since no collateral present in the PCL
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:IGUPT1');
        }

        // 8. collateralTokensToLiquidate
        try _borrower.collateralTokensToLiquidate(_id, 0) {
            uint256 _collateralTokensToLiquidate = _borrower.collateralTokensToLiquidate(_id, 0);
            assertEq(_collateralTokensToLiquidate, 0); // should be zero, since this PCL cannot be liquidated now
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:IGUPT1');
        }
    }

    function test_helperFunctionInClosedState() public {
        assert_helper_functionalities_in_closed_state(requestId, PCLUser(lenders[0].lenderAddress), borrower);
    }
}",8140
RealWorld_BA_101_PCLCancelledState.t_RealWord_20240827091941.log,101,PCLCancelledState.t,76185,5576,81761,91.0,0.492445,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';

import '../Helpers/PCLParent.t.sol';

contract PCLCancelledStateCToken is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 _borrowAssetDecimals;
    uint256 _collateralAssetDecimals;
    uint128 _collateralAssetPriceMin;
    uint128 _borrowAssetPriceMin;
    uint128 _collateralAssetPriceMax;
    uint128 _borrowAssetPriceMax;
    uint256 requestId;
    uint256 _fromUserPoolTokenSupply;
    uint256 _toUserPoolTokenSupply;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;
    uint256 _calculatedCurrentDebt;
    uint256 _fetchedCurrentDebt;
    address lender_0;

    function setUp() public override {
        super.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();
        _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));
        _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));

        _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();
        _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));
        _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 5000 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5000 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = compoundYieldAddress;
        request.collateralAssetStrategy = compoundYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.REQUESTED, '!Requested');

        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        lender_0 = lenders[0].lenderAddress;

        // Borrower tries to cancel the PCL
        borrower.cancelRequest(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CANCELLED, '!Cancelled');
    }

    // Test 0: Test SetUp
    function test_setUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CANCELLED, '!Cancelled');

        uint256 _borrowCTokenExchangeRate = MockCToken(borrowCTokenAddress).exchangeRateCurrent();
        uint256 _collateralCTokenExchangeRate = MockCToken(collateralCTokenAddress).exchangeRateCurrent();

        // Checking out what are the exchange rates
        log_named_int('Borrow CToken Exchange Rate', int256(_borrowCTokenExchangeRate));
        log_named_int('Collateral CToken Exchange Rate', int256(_collateralCTokenExchangeRate));

        // Check the exchange rates of the borrow and collateral CTokens are non-zero
        assertGt(_borrowCTokenExchangeRate, 0);
        assertGt(_collateralCTokenExchangeRate, 0);
    }

    // Test 1: A cancelled PCL cannot be started even with exchange rate fluctuations
    function test_pclCannotBeStarted() public {
        helper_exchangeRateChanges();

        try borrower.start(requestId) {
            revert('Cannot start a cancelled PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S1');
        }
    }

    // Test 2: Collateral cannot be deposited
    function test_collateralCannotBeDeposited() public {
        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), 100);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        helper_exchangeRateChanges();
        try borrower.depositCollateral(requestId, 100, false) {
            revert('Collateral cannot be deposited');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:DC2');
        }
    }

    // Test 3: Withdrawable collateral remains zero
    function test_withdrawableCollateralIsZero() public {
        helper_exchangeRateChanges();
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);

        assertEq(_withdrawableCollateral, 0);
    }

    // Test 4: Collateral cannot be withdrawn
    function test_collateralCannotBeWithdrawn() public {
        helper_exchangeRateChanges();

        try borrower.withdrawCollateral(requestId, 1, false) {
            revert('Collateral cannot be withdrawn');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:OCLB1');
        }
    }

    // Test 5: All Collateral cannot be withdrawn
    function test_allCollateralCannotBeWithdrawn() public {
        helper_exchangeRateChanges();

        try borrower.withdrawAllCollateral(requestId, false) {
            revert('All collateral cannot be withdrawn');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:OCLB1');
        }
    }

    // Test 6: A cancelled PCL cannot be closed
    function test_pclCannotBeClosed() public {
        helper_exchangeRateChanges();

        try borrower.close(requestId) {
            revert('PCL cannot be closed');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:OCLB1');
        }
    }

    // Test 7: Required collateral should not work
    function test_requiredCollateralReverts() public {
        helper_exchangeRateChanges();

        try pcl.getRequiredCollateral(requestId, request.borrowLimit / 2) {
            revert('Required collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:IGUPT1');
        }
    }

    // Test 8: Collateral tokens calculation should not work
    function test_totalCollateralTokensReverts() public {
        helper_exchangeRateChanges();

        try pcl.calculateTotalCollateralTokens(requestId) {
            revert('Total collateral tokens should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CTCT1');
        }
    }

    // Test 9: Collateral ratio should not work
    function test_collateralRatioReverts() public {
        helper_exchangeRateChanges();

        try pcl.calculateCurrentCollateralRatio(requestId) {
            revert('Calculate collateral ratio should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:IGUPT1');
        }
    }

    // Test 10: A cancelled PCL cannnot be cancelled
    function test_pclCannotBeCancelled() public {
        helper_exchangeRateChanges();

        try borrower.cancelRequest(requestId) {
            revert('PCL cannot be cancelled');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:OCLB1');
        }
    }

    // Test 11: Admin should not be able to terminate
    function test_adminCannotTerminatePCL() public {
        helper_exchangeRateChanges();

        // Admin terminates the PCL
        try admin.terminate(requestId) {
            revert('Admin cannot terminate a cancelled PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CTCT1');
        }
    }

    // Test 12: Borrowable amount remains zero
    function test_borrowableAmountIsZero() public {
        helper_exchangeRateChanges();

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        assertEq(_borrowableAmount, 0);
    }

    // Test 13: Borrower cannot repay
    function test_borrowerCannotRepay() public {
        helper_exchangeRateChanges();

        admin.transferToken(address(borrowAsset), address(borrower), 1);
        borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);
        try borrower.repay(requestId, 1) {
            revert('Borrower cannot repay');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:REP2');
        }
    }

    // Test 14: A cancelled PCL cannot be liquidated
    function test_lendersCannotLiquidate(bool _withdraw) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_exchangeRateChanges();

        // _lender0 tries to liquidate the PCL
        try _lender0.liquidate(requestId, _withdraw) {
            revert('Cannot liquidate a cancelled PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L1');
        }
    }

    // Test 15: Lenders cannot withdraw liquidation
    function test_lendersCannotWithdrawLiquidation() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_exchangeRateChanges();

        try _lender0.withdrawTokensAfterLiquidation(requestId) {
            revert('Cannot withdraw liquidation from a cancelled PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    // Test 16: Lenders can withdraw liquidity
    function test_lendersCanWithdrawLiquidity() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _userPoolTokenBalance = lp.balanceOf(address(_lender0), requestId);

        helper_exchangeRateChanges();

        uint256 _userBorrowTokenBalanceBefore = IERC20(request.borrowAsset).balanceOf(address(_lender0));
        _lender0.withdrawLiquidity(requestId);
        uint256 _userBorrowTokenBalanceAfter = IERC20(request.borrowAsset).balanceOf(address(_lender0));
        assertEq(_userPoolTokenBalance, _userBorrowTokenBalanceAfter - _userBorrowTokenBalanceBefore);

        _userPoolTokenBalance = lp.balanceOf(address(_lender0), requestId);
        assertEq(_userPoolTokenBalance, 0);
    }

    // Test 17: Pool token transfers should be possible
    function test_poolTokenTransfersShouldBePossibleEntireBalance() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);

        //Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, 0);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == 0);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));
    }

    // Test 17.1: Pool token transfers should be possible
    function test_poolTokenTransfersShouldBePossiblePartialBalance() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 18: Interest cannot be withdrawn amidst exchange rate fluctuations
    function test_lendersCannotWithdrawInterest() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender0Balance = borrowAsset.balanceOf(address(lender0));

        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender1Balance = borrowAsset.balanceOf(address(lender1));

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender0));
        uint256 lender1InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender1));

        helper_exchangeRateChanges();

        try lender1.withdrawInterest(requestId) {
            revert('Interest cannot be withdrawn');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WI1');
        }
    }

    uint256 _principal;
    uint256 _currentCR1;
    uint256 _currentCR2;
    uint256 _currentCR3;
    uint256 _principalWithdrawable;
    uint256 _withdrawableCollateral;
    uint256 _currentDebt;
    uint256 _borrowable;
    uint256 _totalCollateral;
    uint256 _equivalentCollateral;
    uint256 _interestAccrued;

    uint256 collateralToDeposit;

    function assert_helperFunctionalities(uint256 _id) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.CANCELLED);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 1. calculateCurrentCollateralRatio
        try _borrower.calculateCurrentCollateralRatio(_id) {
            revert('Collateral ratio should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:IGUPT1');
        }

        helper_exchangeRateChanges();

        // 2. calculatePrincipalWithdrawable
        _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
        assertEq(_principalWithdrawable, lp.balanceOf(address(_lender), requestId));

        helper_exchangeRateChanges();

        // 3. withdrawableCollateral
        _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertEq(_withdrawableCollateral, 0);

        helper_exchangeRateChanges();

        // 4. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        assertEq(_currentDebt, 0); // Since nothing was borrowed

        helper_exchangeRateChanges();

        // 5. calculateBorrowableAmount
        _borrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_borrowable, 0); // Since collateral was not deposited

        helper_exchangeRateChanges();

        // 6. calculateTotalCollateralTokens
        try _borrower.calculateTotalCollateralTokens(_id) {
            revert('Total collateral tokens should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CTCT1');
        }

        helper_exchangeRateChanges();

        // 7. collateralTokensToLiquidate
        try _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id)) {
            revert('Collateral tokens to liquidate should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CTTL1');
        }

        helper_exchangeRateChanges();

        // 8. calculateInterestAccrued
        _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertEq(_interestAccrued, 0); // Since borrower did not borrow anything

        helper_exchangeRateChanges();
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.CANCELLED);
    }

    function test_helperFunctions() public {
        assert_helperFunctionalities(requestId);
    }
}",4554
RealWorld_BA_101_PCLActiveStage.t_RealWord_20240827100631.log,101,PCLActiveStage.t,9713,6289,16002,99.0,0.174345,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '../../PCLStageTests/PCLActiveStage.t.sol';

contract PCLActiveStageZeroCollateralBorrowCompound is PCLActiveStage {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    function setUp() public override {
        PCLParent.setUp();

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = 0;
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * (10**ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = compoundYieldAddress;
        request.collateralAssetStrategy = compoundYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!ACTIVE');
    }
}",344
RealWorld_BA_101_User_RealWord_20240827104028.log,101,User,36655,5825,42480,90.0,0.299775,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '../../SavingsAccount/SavingsAccount.sol';
import '../../interfaces/IYield.sol';
import '../../yield/CompoundYield.sol';
import '../../yield/NoYield.sol';
import '../../PriceOracle.sol';
import '../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../interfaces/ILenderPool.sol';
import '../../PooledCreditLine/PooledCreditLine.sol';
import '../../PooledCreditLine/LenderPool.sol';
import '../../mocks/MockToken.sol';
import '../../Verification/twitterVerifier.sol';
import '../../Verification/adminVerifier.sol';
import '../../Verification/Verification.sol';

import '@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155ReceiverUpgradeable.sol';
import '@openzeppelin/contracts/token/ERC1155/IERC1155.sol';
import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';

contract User is IERC1155ReceiverUpgradeable, IPooledCreditLineDeclarations {
    using SafeERC20 for IERC20;

    /******************************************************************************
     ******* Savings account specific functions ***********************************
     ******************************************************************************/

    function depositToSavingsAccount(
        address savingsAccount,
        uint256 _amount,
        address _token,
        address _strategy,
        address _to
    ) public {
        SavingsAccount(savingsAccount).deposit(_token, _strategy, _to, _amount);
    }

    function switchStrategyInSavingsAccount(
        address savingsAccount,
        address _currentStrategy,
        address _newStrategy,
        address _token,
        uint256 _amount
    ) public {
        SavingsAccount(savingsAccount).switchStrategy(_currentStrategy, _newStrategy, _token, _amount);
    }

    function approveToSavingsAccount(
        address savingsAccount,
        address _token,
        address _to,
        uint256 _amount
    ) public {
        SavingsAccount(savingsAccount).approve(_token, _to, _amount);
    }

    function withdrawFromSavingsAccount(
        address savingsAccount,
        address _token,
        address _strategy,
        address _from,
        address _to,
        uint256 _amount,
        bool _receiveShares
    ) public {
        SavingsAccount(savingsAccount).withdrawFrom(_token, _strategy, _from, _to, _amount, _receiveShares);
    }

    function withdrawAllSavingsAccount(address savingsAccount, address _token) public {
        SavingsAccount(savingsAccount).withdrawAll(_token);
    }

    function withdrawAllTokenFromStrategySavingsAccount(
        address savingsAccount,
        address _token,
        address _strategy
    ) public {
        SavingsAccount(savingsAccount).withdrawAll(_token, _strategy);
    }

    function transferFromSavingsAccount(
        address savingsAccount,
        address _token,
        address _strategy,
        address _from,
        address _to,
        uint256 _amount
    ) public {
        SavingsAccount(savingsAccount).transferFrom(_token, _strategy, _from, _to, _amount);
    }

    function transferSavingsAccount(
        address savingsAccount,
        address _token,
        address _strategy,
        address _to,
        uint256 _amount
    ) public {
        SavingsAccount(savingsAccount).transfer(_token, _strategy, _to, _amount);
    }

    function lockTokensForCompoundYield(
        address payable yield,
        address user,
        address asset,
        uint256 amount
    ) public {
        CompoundYield(yield).lockTokens(user, asset, amount);
    }

    function unlockTokensForCompoundYield(
        address payable yield,
        address asset,
        address to,
        uint256 amount
    ) public {
        CompoundYield(yield).unlockTokens(asset, to, amount);
    }

    function lockTokensForNoYield(
        address yield,
        address user,
        address asset,
        uint256 amount
    ) public {
        NoYield(yield).lockTokens(user, asset, amount);
    }

    function unlockTokensForNoYield(
        address yield,
        address asset,
        address to,
        uint256 amount
    ) public {
        NoYield(yield).unlockTokens(asset, to, amount);
    }

    function setAllowanceForSavingsAccount(
        address savingsAccountAddress,
        uint256 amount,
        address token,
        address spender
    ) public {
        ISavingsAccount savingsAccount = ISavingsAccount(savingsAccountAddress);

        savingsAccount.approve(token, spender, amount);
    }

    function savingsAccountWithdraw(
        address savingsAccountAddress,
        address _token,
        address _strategy,
        address _to,
        uint256 _amount,
        bool _receiveShares
    ) public {
        ISavingsAccount savingsAccount = ISavingsAccount(savingsAccountAddress);

        savingsAccount.withdraw(_token, _strategy, _to, _amount, _receiveShares);
    }

    /*****************************************************************************
     ******* END of Savings account specific functions ****************************
     ******************************************************************************/

    function approveToken(
        address token,
        address spender,
        uint256 amount
    ) public {
        IERC20(token).safeApprove(spender, 0);
        IERC20(token).safeApprove(spender, amount);
    }

    // ----- ierc receiver implmentation --------//
    function onERC1155Received(
        address,
        address,
        uint256,
        uint256,
        bytes calldata
    ) external virtual override returns (bytes4) {
        return bytes4(keccak256('onERC1155Received(address,address,uint256,uint256,bytes)'));
    }

    function onERC1155BatchReceived(
        address,
        address,
        uint256[] calldata,
        uint256[] calldata,
        bytes calldata
    ) external pure override returns (bytes4) {
        return bytes4(keccak256('onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)'));
    }

    function supportsInterface(bytes4) external pure override returns (bool) {
        return true;
    }

    /*****************************************************************************
     ******* Start of twitter verifier specific functions ****************************
     ******************************************************************************/

    function registerUserUsingTwitterVerifier(
        TwitterVerifier twitterVerifier,
        bool _isMasterLinked,
        uint8 _v,
        bytes32 _r,
        bytes32 _s,
        string memory _twitterId,
        string memory _tweetId,
        uint256 _timestamp
    ) public {
        twitterVerifier.registerSelf(_isMasterLinked, _v, _r, _s, _twitterId, _tweetId, _timestamp);
    }

    function unregisterUserFromTwitterVerifier(TwitterVerifier twitterVerifier) public {
        twitterVerifier.unregisterSelf();
    }

    /*****************************************************************************
     ******* END of twitter verifier specific functions ****************************
     ******************************************************************************/

    /*****************************************************************************
     ******* Strat of admin verifier specific functions ****************************
     ******************************************************************************/

    function registerUserUsingAdminVerifier(
        AdminVerifier adminVerifier,
        bool _isMasterLinked,
        uint8 _v,
        bytes32 _r,
        bytes32 _s,
        string memory _userData,
        uint256 _timestamp
    ) public {
        adminVerifier.registerSelf(_isMasterLinked, _v, _r, _s, _userData, _timestamp);
    }

    function unregisterUserFromAdminVerifier(AdminVerifier adminVerifier) public {
        adminVerifier.unregisterSelf();
    }

    /*****************************************************************************
     ******* END of admin verifier specific functions ****************************
     ******************************************************************************/

    /********************************************************************************************************************************
    Generic User functions. Callable by anyone. Mostly view function. Written to avoid stack too deep in test contracts
    *********************************************************************************************************************************/

    function fetchCreditLineVariable(
        address pooledCreditLineAddress,
        uint256 pooledCreditLineID,
        string memory variable
    ) public view returns (uint256) {
        PooledCreditLine pooledCreditLine = PooledCreditLine(pooledCreditLineAddress);
        (
            ,
            uint256 creditLineVariablePrincipal,
            uint256 creditLineVariableTotalInterestRepaid,
            uint256 creditLineVariableLastPrincipalUpdateTime,
            uint256 creditLineVariableInterestAccruedTillLastPrincipalUpdate
        ) = pooledCreditLine.pooledCreditLineVariables(pooledCreditLineID);
        if (keccak256(abi.encodePacked(variable)) == keccak256(abi.encodePacked('principal'))) {
            return creditLineVariablePrincipal;
        } else if (keccak256(abi.encodePacked(variable)) == keccak256(abi.encodePacked('totalInterestRepaid'))) {
            return creditLineVariableTotalInterestRepaid;
        } else if (keccak256(abi.encodePacked(variable)) == keccak256(abi.encodePacked('lastPrincipalUpdateTime'))) {
            return creditLineVariableLastPrincipalUpdateTime;
        } else if (keccak256(abi.encodePacked(variable)) == keccak256(abi.encodePacked('interestAccruedTillLastPrincipalUpdate'))) {
            return creditLineVariableInterestAccruedTillLastPrincipalUpdate;
        } else {
            revert('Incorrect credit line variable entered');
        }
    }

    function setAllowance(
        address approvedAddress,
        address token,
        uint256 amount
    ) public {
        IERC20(token).approve(approvedAddress, amount);
    }

    function increaseAllowance(
        address approvedAddress,
        address token,
        uint256 amount
    ) public {
        ERC20(token).increaseAllowance(approvedAddress, amount);
    }

    function requestAddressLinkingInVerifier(Verification verification, address _linkedAddress) public {
        verification.requestAddressLinking(_linkedAddress);
    }

    function cancelAddressLinkingRequestInVerification(Verification verification, address _linkedAddress) public {
        verification.cancelAddressLinkingRequest(_linkedAddress);
    }

    function linkAddressInVerification(Verification verification, address _masterAddress) public {
        verification.linkAddress(_masterAddress);
    }

    function unlinkAddressInVerification(Verification verification, address _linkedAddress) public {
        verification.unlinkAddress(_linkedAddress);
    }
}",2118
RealWorld_BA_101_MockTwitterVerifier_RealWord_20240827085447.log,101,MockTwitterVerifier,27888,5914,33802,93.0,0.25772,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

import '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';
import '@openzeppelin/contracts-upgradeable/drafts/EIP712Upgradeable.sol';
import '@openzeppelin/contracts/cryptography/ECDSA.sol';
import '../interfaces/IVerification.sol';
import '../interfaces/IVerifier.sol';

contract MockTwitterVerifier is Initializable, IVerifier, OwnableUpgradeable, EIP712Upgradeable {
    /**
     * @notice stores the verification contract instance
     */
    IVerification public verification;
    /**
     * @notice Structure for the user data
     */
    struct UserStructData {
        string twitterId;
        string tweetId;
    }

    /**
     * @notice stores the user metadata against their address
     */
    mapping(address => UserStructData) public userData;
    /**
     * @notice stores the user address against twitterId
     */
    mapping(string => address) public twitterIdMap;
    mapping(bytes32 => address) private hashAddressMap;
    /**
     * @notice stores the signer address
     */
    address public signerAddress;

    /**
     * @notice emitted when verification contract address is updated
     * @param verification address of the updated verification contract
     */
    event VerificationUpdated(address indexed verification);
    /**
     * @notice emitted when Signer address is updated
     * @param signerAddress address of the updated verification contract
     */
    event SignerUpdated(address indexed signerAddress);

    /// @notice Initializes the variables of the contract
    /// @dev Contract follows proxy pattern and this function is used to initialize the variables for the contract in the proxy
    /// @param _admin Admin of the verification contract who can add verifiers and remove masterAddresses deemed invalid
    /// @param _verification Verification contract address
    /// @param _signerAddress Address of the signer bot verifying users and signing off-chain messages
    /// @param _name name of the verifier (used in domain seperator)
    /// @param _version version of the verifier (used in domain seperator)
    function initialize(
        address _admin,
        address _verification,
        address _signerAddress,
        string memory _name,
        string memory _version
    ) external initializer {
        super.__Ownable_init();
        super.transferOwnership(_admin);
        _updateVerification(_verification);
        _updateSignerAddress(_signerAddress);
        __EIP712_init(_name, _version);
    }

    /**
     * @notice used to register user
     * @dev only owner can register users
     * @param _v int v
     * @param _r part signed message hash
     * @param _s part signed message hash
     * @param _timestamp timestamp for the signed message
     * @param _twitterId metadata related to user :  here ""twitterId""
     * @param _tweetId metadata related to user :  here ""tweetId""
     * @param _isMasterLinked should master address be linked to itself
     */

    function registerSelf(
        bool _isMasterLinked,
        uint8 _v,
        bytes32 _r,
        bytes32 _s,
        string memory _twitterId,
        string memory _tweetId,
        uint256 _timestamp
    ) external {
        require(bytes(userData[msg.sender].twitterId).length == 0, 'User already exists');
        require(twitterIdMap[_twitterId] == address(0), 'Signed message already used');
        require(block.timestamp < _timestamp + 86400, 'Signed transaction expired');

        bytes32 digest = keccak256(
            abi.encode(
                keccak256('set(string twitterId,string tweetId,address userAddr,uint256 timestamp)'),
                keccak256(bytes(_twitterId)),
                keccak256(bytes(_tweetId)),
                msg.sender,
                _timestamp
            )
        );
        require(hashAddressMap[digest] == address(0), 'Hash Already Used');

        bytes32 hash = _hashTypedDataV4(digest);
        address signer = ECDSA.recover(hash, _v, _r, _s);
        require(signer == signerAddress, 'Invalid signature');

        verification.registerMasterAddress(msg.sender, _isMasterLinked);
        userData[msg.sender] = UserStructData(_twitterId, _tweetId);
        twitterIdMap[_twitterId] = msg.sender;
        hashAddressMap[digest] = msg.sender;
        emit UserRegistered(msg.sender, _isMasterLinked, _twitterId);
    }

    function registerUserViaOwner(
        bool _isMasterLinked,
        address _user,
        string memory _twitterId,
        string memory _tweetId
    ) external onlyOwner {
        bytes32 digest = keccak256(
            abi.encode(
                keccak256('set(string twitterId,string tweetId,address userAddr,uint256 timestamp)'),
                keccak256(bytes(_twitterId)),
                keccak256(bytes(_tweetId)),
                _user,
                block.timestamp
            )
        );

        require(hashAddressMap[digest] == address(0), 'Hash Already Used');

        verification.registerMasterAddress(_user, _isMasterLinked);
        userData[_user] = UserStructData(_twitterId, _tweetId);
        twitterIdMap[_twitterId] = _user;
        hashAddressMap[digest] = _user;
        emit UserRegistered(_user, _isMasterLinked, _twitterId);
    }

    /**
     * @notice used to unregister self
     * @dev users themselves can unregister themself
     */
    function unregisterSelf() external {
        string memory _userdata = userData[msg.sender].twitterId;
        require(bytes(_userdata).length != 0, 'User doesnt exists');
        delete twitterIdMap[_userdata];
        delete userData[msg.sender];
        verification.unregisterMasterAddress(msg.sender, address(this));
        emit UserUnregistered(msg.sender);
    }

    /**
     * @notice used to unregister user
     * @dev owners can unregister users
     */
    function unregisterUser(address _user) external onlyOwner {
        string memory _userdata = userData[_user].twitterId;
        require(bytes(_userdata).length != 0, 'User does not exists');
        delete twitterIdMap[_userdata];
        delete userData[_user];
        verification.unregisterMasterAddress(_user, address(this));
        emit UserUnregistered(_user);
    }

    /**
     * @notice used to update verification contract address
     * @dev only owner can update
     * @param _verification address of the verification contract
     */
    function updateVerification(address _verification) external onlyOwner {
        _updateVerification(_verification);
    }

    function _updateVerification(address _verification) internal {
        verification = IVerification(_verification);
        emit VerificationUpdated(_verification);
    }

    /**
     * @notice used to update signer address
     * @dev only owner can update
     * @param _signerAddress address of the verification contract
     */
    function updateSignerAddress(address _signerAddress) external onlyOwner {
        _updateSignerAddress(_signerAddress);
    }

    function _updateSignerAddress(address _signerAddress) internal {
        signerAddress = _signerAddress;
        emit SignerUpdated(signerAddress);
    }
}",1524
RealWorld_BA_101_PCLExpiredStage.t_RealWord_20240827093003.log,101,PCLExpiredStage.t,0,0,0,,0.0,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';

import '../Helpers/PCLParent.t.sol';

contract PCLExpiredStage is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 requestId;

    function setUp() public virtual override {
        super.setUp();

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 5000 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 3650 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, type(uint256).max);
        borrower.depositCollateral(requestId, _requiredCollateral, false);

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);
        // and borrows the borrowable amount
        borrower.borrow(requestId, borrowableAmount);

        // Borrower decides to repay everything at mid-duration

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 2);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, currentDebt / 2);

        // Now we travel past the duration to the expiration period
        vm.warp(block.timestamp + 100 + request.duration / 2);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');
    }

    // Test0: Test SetUp
    function test_SetUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // START function calls
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    // Test1: Expired PCL cannot be started
    function assert_start_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertString,
        string memory _errorString
    ) public {
        try _user.start(_id) {
            revert(_revertString);
        } catch Error(string memory reason) {
            assertEq(reason, _errorString);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
    }

    function test_adminCannotStartAnExpiredPCL() public {
        assert_start_functionality_in_expired_state(requestId, admin, 'Admin cannot start a PCL in expired state', 'LP:S1');
    }

    function test_borrowerCannotStartAnExpiredPCL() public {
        assert_start_functionality_in_expired_state(requestId, borrower, 'Borrower cannot start a PCL in expired state', 'LP:S1');
    }

    function test_lenderCannotStartAnExpiredPCL() public {
        assert_start_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot start a PCL in expired state',
            'LP:S1'
        );
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // CANCEL function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_cancel_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.cancelRequest(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
    }

    function test_adminCannotCancelAnExpiredPCL() public {
        assert_cancel_functionality_in_expired_state(requestId, admin, 'Admin cannot Cancel a PCL in expired state', 'PCL:OCLB1');
    }

    function test_borrowerCannotCancelAnExpiredPCL() public {
        assert_cancel_functionality_in_expired_state(requestId, borrower, 'Borrower cannot Cancel a PCL in expired state', 'PCL:CR1');
    }

    function test_lenderCannotCancelAnExpiredPCL() public {
        assert_cancel_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot Cancel a PCL in expired state',
            'PCL:OCLB1'
        );
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // CLOSE function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_close_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.close(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
    }

    function assert_close_functionality_in_expired_state_zero_debt(uint256 _id, PCLUser _user) public {
        (, _principal, , , ) = pcl.pooledCreditLineVariables(_id);
        assertTrue(_principal != 0);

        _currentDebt = borrower.calculateCurrentDebt(_id);
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt * 10);

        // Borrower wants to repay everything now
        borrower.repay(_id, _currentDebt);

        (, _principal, , , ) = pcl.pooledCreditLineVariables(_id);
        assertTrue(_principal == 0, 'principal != 0');
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.CLOSED, '!Closed');

        try _user.close(_id) {
            revert('Cannot go through when entire debt is repaid');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C1');
        }
    }

    function test_adminCannotCloseAnExpiredPCL() public {
        assert_close_functionality_in_expired_state(requestId, admin, 'Admin cannot close a expired PCL', 'PCL:OCLB1');
    }

    // If the principal != 0
    function test_borrowerCannotCloseAnExpiredPCL() public {
        assert_close_functionality_in_expired_state(requestId, borrower, 'Borrower cannot close a expired PCL', 'PCL:C2');
    }

    // If the principal == 0
    function test_borrowerCanCloseAnExpiredPCL_principalIsZero() public {
        assert_close_functionality_in_expired_state_zero_debt(requestId, borrower);
    }

    function test_lenderCannotCloseAnExpiredPCL() public {
        assert_close_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot close a expired PCL',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    Deposit collateral function calls
    *************************************************************************************************************************************/

    function assert_collateralCanBeDepositedInExpiredState(
        uint256 _id,
        uint256 _amount,
        PCLUser _depositor,
        bool _isDepositorLender
    ) public {
        if (_isDepositorLender) {
            _depositor = PCLUser(lenders[0].lenderAddress);
        }

        admin.transferToken(address(collateralAsset), address(_depositor), _amount);
        if (_depositor != borrower) {
            _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);
        }
        uint256 _collateralShares = pcl.depositedCollateralInShares(_id);
        _depositor.depositCollateral(_id, _amount, false);
        assertGt(pcl.depositedCollateralInShares(_id), _collateralShares);
    }

    function test_borrowerCanDepositCollateral() public {
        uint256 _amountToDeposit = 100 * (10**ERC20(address(collateralAsset)).decimals());
        assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, borrower, true);
    }

    function test_lenderCanDepositCollateral() public {
        uint256 _amountToDeposit = 100 * (10**ERC20(address(collateralAsset)).decimals());
        assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, PCLUser(address(0)), true);
    }

    function test_adminCanDepositCollateral() public {
        uint256 _amountToDeposit = 100 * (10**ERC20(address(collateralAsset)).decimals());
        assert_collateralCanBeDepositedInExpiredState(requestId, _amountToDeposit, admin, false);
    }

    /*************************************************************************************************************************************
    Borrow function tests
    *************************************************************************************************************************************/

    function assertBorrowFunctionalityInExpiredState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.borrow(_id, _amount) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotBorrow() public {
        assertBorrowFunctionalityInExpiredState(
            requestId,
            1,
            admin,
            uint256(PooledCreditLineStatus.EXPIRED),
            'Admin cannot borrow a PCL in expired state',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotBorrow() public {
        assertBorrowFunctionalityInExpiredState(
            requestId,
            1,
            borrower,
            uint256(PooledCreditLineStatus.EXPIRED),
            'Borrower cannot borrow a PCL in expired state',
            'PCL:IB3'
        );
    }

    function test_lenderCannotBorrow() public {
        assertBorrowFunctionalityInExpiredState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.EXPIRED),
            'Lender cannot borrow a PCL in expired state',
            'PCL:OCLB1'
        );
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Repayment function tests
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_repayment_functionality_in_expired_state(
        uint256 _id,
        uint256 _repaymentAmount,
        string memory _errorMessage,
        PCLUser _user
    ) public {
        // Admin transfers some borrow token to the _user for repayment
        uint256 _adminBorrowAssetBalance = borrowAsset.balanceOf(address(admin));

        log_named_uint('Admin Borrow Asset Balance', _adminBorrowAssetBalance);
        log_named_address('borrower', address(borrower));

        admin.transferToken(address(borrowAsset), address(_user), (_adminBorrowAssetBalance / 10));
        if (_user != borrower) {
            _user.setAllowance(address(pcl), address(borrowAsset), uint256(-1));
        }
        try _user.repay(_id, _repaymentAmount) {
            log_string('Repayment successful');
        } catch Error(string memory reason) {
            log_named_string('Error', reason);
            assertEq(reason, _errorMessage);
        }
    }

    function test_borrowerCannotRepayZeroAmount() public {
        assert_repayment_functionality_in_expired_state(requestId, 0, 'PCL:REP1', borrower);
    }

    function test_borrowerCannotRepayIfDebtIsZero() public {
        // Repaying the remaining debt so that current debt == 0
        _currentDebt = pcl.calculateCurrentDebt(requestId);
        log_named_uint('Current debt', _currentDebt);

        admin.transferToken(address(borrowAsset), address(borrower), (_currentDebt));
        borrower.repay(requestId, _currentDebt);

        // Travelling some more so that interest gets accrued and we do not get PCL:REP3
        helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);

        // Now since the entire repayment is done in the EXPIRED state, the PCL goes into CLOSED state.
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);

        // Admin transfers some borrow token to the _user for repayment
        uint256 _adminBorrowAssetBalance = borrowAsset.balanceOf(address(admin));
        admin.transferToken(address(borrowAsset), address(borrower), (_adminBorrowAssetBalance / 10));

        try borrower.repay(requestId, 10**4) {
            log_string('Repayment successful');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:REP2');
        }
    }

    function test_borrowerCannotRepayIfInterestAccruedIsZero() public {
        uint256 _interestRemaining = pcl.calculateInterestAccrued(requestId);

        admin.transferToken(address(borrowAsset), address(borrower), (_interestRemaining));
        borrower.repay(requestId, _interestRemaining);

        assert_repayment_functionality_in_expired_state(requestId, 10**10, 'PCL:REP4', borrower);
    }

    function test_adminCanRepay() public {
        // Travelling so that some interest gets accrued
        helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);

        // Repaying the remaining debt so that current debt == 0
        _currentDebt = pcl.calculateCurrentDebt(requestId);
        log_named_uint('Current debt', _currentDebt);

        assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', admin);
    }

    function test_lenderCanRepay() public {
        // Travelling so that some interest gets accrued
        helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);

        // Repaying the remaining debt so that current debt == 0
        _currentDebt = pcl.calculateCurrentDebt(requestId);
        log_named_uint('Current debt', _currentDebt);

        assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', PCLUser(lenders[0].lenderAddress));
    }

    function test_borrowerCanRepay() public {
        // Travelling so that some interest gets accrued
        helper_timeWarp(block.timestamp + request.defaultGracePeriod / 2);

        // Repaying the remaining debt so that current debt == 0
        _currentDebt = pcl.calculateCurrentDebt(requestId);
        log_named_uint('Current debt', _currentDebt);

        assert_repayment_functionality_in_expired_state(requestId, _currentDebt, '', borrower);
    }

    /*************************************************************************************************************************************
    Withdraw collateral function tests
    *************************************************************************************************************************************/

    function assertWithdrawCollateralFunctionalityInExpiredState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        uint256 _stateToAssert,
        string memory _revertMessage,
        string memory _errorMessage,
        string memory _errorMessageAll
    ) public {
        try _user.withdrawAllCollateral(_id, false) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessageAll);
        }

        try _user.withdrawCollateral(_id, _amount, false) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInExpiredState(
            requestId,
            1,
            admin,
            uint256(PooledCreditLineStatus.EXPIRED),
            'Admin cannot withdraw collateral in expired state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInExpiredState(
            requestId,
            1,
            borrower,
            uint256(PooledCreditLineStatus.EXPIRED),
            'Borrower cannot withdraw collateral in expired state',
            'PCL:WC1',
            'PCL:WAC1'
        );
    }

    function test_borrowerCannotWithdrawZeroCollateral() public {
        assertWithdrawCollateralFunctionalityInExpiredState(
            requestId,
            0,
            borrower,
            uint256(PooledCreditLineStatus.EXPIRED),
            'Borrower cannot withdraw zero collateral in expired state',
            'PCL:WC2',
            'PCL:WAC1'
        );
    }

    function test_lenderCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInExpiredState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.EXPIRED),
            'Lender cannot withdraw collateral in expired state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    WithdrawLiquidity function calls
    **************************************************************************************************************************************/

    function assert_withdraw_liquidity_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        uint256 _stateToAssert,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_positiveCase) {
            uint256 _poolTokenBalanceOld = lp.balanceOf(address(_user), _id);
            uint256 _borrowTokenBalanceOld = IERC20(request.borrowAsset).balanceOf(address(_user));
            _user.withdrawLiquidity(_id);
            uint256 _poolTokenBalanceNew = lp.balanceOf(address(_user), _id);
            uint256 _borrowTokenBalanceNew = IERC20(request.borrowAsset).balanceOf(address(_user));

            assertGe((_borrowTokenBalanceNew - _borrowTokenBalanceOld), _poolTokenBalanceOld);
            assertEq(_poolTokenBalanceNew, 0);
        } else {
            try _user.withdrawLiquidity(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }

        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert);
    }

    function test_adminCannotWithdrawLiquidity() public {
        assert_withdraw_liquidity_functionality_in_expired_state(
            requestId,
            admin,
            uint256(PooledCreditLineStatus.EXPIRED),
            false,
            'Admin cannot withdraw liquidity a PCL in expired state',
            'LP:IWL1'
        );
    }

    function test_borrowerCannotWithdrawLiquidity() public {
        assert_withdraw_liquidity_functionality_in_expired_state(
            requestId,
            borrower,
            uint256(PooledCreditLineStatus.EXPIRED),
            false,
            'Borrower cannot withdraw liquidity a PCL in expired state',
            'LP:IWL1'
        );
    }

    function test_lenderCannotWithdrawLiquidity() public {
        assert_withdraw_liquidity_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.EXPIRED),
            false,
            'Lender cannot withdraw liquidity a PCL in expired state',
            'LP:IWL3'
        );
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // LIQUIDATE function calls
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_liquidate_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_positiveCase) {
            _user.liquidate(_id, true);
            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
        } else {
            try _user.liquidate(_id, true) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
                assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
            }
        }
    }

    function test_adminCannotLiquidateAnExpiredPCL() public {
        assert_liquidate_functionality_in_expired_state(requestId, admin, false, 'Admin cannot liquidate an expired PCL', 'LP:LIQ1');
    }

    function test_borrowerCannotLiquidateAnExpiredPCL() public {
        assert_liquidate_functionality_in_expired_state(requestId, borrower, false, 'Borrower cannot liquidate an expired PCL', 'LP:LIQ1');
    }

    function test_lenderCannotLiquidateAnExpiredPCL_underDefaultsAtTimePeriod() public {
        assert_liquidate_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            false,
            'If under defaultsAt time period, must not go through',
            'PCL:L3'
        );
    }

    function test_lenderCanLiquidateAnExpiredPCL_afterDefaultsAtTimePeriod() public {
        helper_timeWarp(block.timestamp + request.defaultGracePeriod);
        // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(requestId);
        // assertTrue(block.timestamp >= _defaultTimeStamp, '!Still not past default time');

        assert_liquidate_functionality_in_expired_state(requestId, PCLUser(lenders[0].lenderAddress), true, '', '');
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Terminate function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_terminate_functionality_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        uint256 _userBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(_user));
        uint256 _userCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(_user));

        try _user.terminate(_id) {
            uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));
            uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));

            if (_user == admin) {
                assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.NOT_CREATED);
                assertTrue((_userBorrowTokenBalancePreTerminate < _userBorrowTokenBalancePostTerminate) == true);
                if (request.collateralRatio != 0) {
                    assertTrue((_userCollateralTokenBalancePreTerminate < _userCollateralTokenBalancePostTerminate) == true);
                }
            } else {
                assertTrue(
                    (_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) ==
                        (_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) ==
                        true
                );
                revert(_revertMessage);
            }
        } catch Error(string memory reason) {
            uint256 _userBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(_user));
            uint256 _userCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(_user));

            assertTrue((_userBorrowTokenBalancePreTerminate == _userBorrowTokenBalancePostTerminate) == true);
            assertTrue((_userCollateralTokenBalancePreTerminate == _userCollateralTokenBalancePostTerminate) == true);

            assertEq(reason, _errorMessage);
            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
        }
    }

    function test_adminCanTerminateAnExpiredPCL() public {
        assert_terminate_functionality_in_expired_state(requestId, admin, '', '');
    }

    function test_adminCanTerminateAnExpiredPCL_beyondDefaultTimeStamp() public {
        helper_timeWarp(block.timestamp + request.defaultGracePeriod);

        // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(requestId);

        // assertTrue(block.timestamp >= _defaultTimeStamp, '!Still not past default time');

        assert_terminate_functionality_in_expired_state(requestId, admin, '', '');
    }

    function test_borrowerCannotTerminateAnExpiredPCL() public {
        assert_terminate_functionality_in_expired_state(
            requestId,
            borrower,
            'Cannot terminate a PCL that is expired',
            'Ownable: caller is not the owner'
        );
    }

    function test_lenderCannotTerminateAnExpiredPCL() public {
        assert_terminate_functionality_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Cannot terminate a PCL that is expired',
            'Ownable: caller is not the owner'
        );
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Pool Token Transfer function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    uint256 lender0PoolTokenBalance;
    uint256 lender1PoolTokenBalance;
    uint256 lender2PoolTokenBalance;
    uint256 lender3PoolTokenBalance;
    uint256 _from1BalancePostBurn;
    uint256 lender0PoolTokenBalanceFinal;
    uint256 lender1PoolTokenBalanceFinal;
    uint256 lender2PoolTokenBalanceFinal;
    uint256 lender3PoolTokenBalanceFinal;
    uint256 _defaultTimeStamp;
    uint256 _originalPrice;
    uint256 _modifiedPrice;

    PCLUser _from1;
    PCLUser _from2;
    PCLUser _to1;
    PCLUser _to2;

    function assert_pool_token_transfer_in_expired_stage(
        uint256 _id,
        uint256 _fractionOfPTSupply,
        bool _positiveCase,
        address _From1,
        address _From2,
        address _To1,
        address _To2,
        string memory _errorString
    ) public {
        _from1 = PCLUser(_From1);
        _from2 = PCLUser(_From2);
        _to1 = PCLUser(_To1);
        _to2 = PCLUser(_To2);

        if (_positiveCase) {
            // Ensuring that these lenders indeed had lent something
            lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);
            lender1PoolTokenBalance = lp.balanceOf(address(_to1), _id);
            lender2PoolTokenBalance = lp.balanceOf(address(_from2), _id);
            lender3PoolTokenBalance = lp.balanceOf(address(_to2), _id);

            assertGt(lender0PoolTokenBalance, 0);
            assertGt(lender1PoolTokenBalance, 0);
            assertGt(lender2PoolTokenBalance, 0);
            assertGt(lender3PoolTokenBalance, 0);

            // Lender0 transfers pool tokens to lender1
            _from1.transferLPTokens(address(_to1), _id, (lender0PoolTokenBalance / _fractionOfPTSupply));

            // Checking the transfer took place or not
            lender0PoolTokenBalanceFinal = lp.balanceOf(address(_from1), _id);
            lender1PoolTokenBalanceFinal = lp.balanceOf(address(_to1), _id);

            assertTrue(lender0PoolTokenBalanceFinal == (lender0PoolTokenBalance - (lender0PoolTokenBalance / _fractionOfPTSupply)));
            assertTrue(lender1PoolTokenBalanceFinal == ((lender0PoolTokenBalance / _fractionOfPTSupply) + lender1PoolTokenBalance));

            helper_timeWarp(block.timestamp + request.defaultGracePeriod);

            // (, , , , , , , , _defaultTimeStamp, , , ) = pcl.pooledCreditLineConstants(_id);

            // assertTrue(block.timestamp >= _defaultTimeStamp, '!Still not past default time');

            // Lender2 transfers pool tokens to lender3
            _from2.transferLPTokens(address(_to2), _id, lender2PoolTokenBalance);

            lender2PoolTokenBalanceFinal = lp.balanceOf(address(_from2), _id);
            lender3PoolTokenBalanceFinal = lp.balanceOf(address(_to2), _id);

            // Checking whether the transfer took place or not
            assertTrue(lender2PoolTokenBalanceFinal == 0);
            assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));

            assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
        } else {
            lender0PoolTokenBalance = lp.balanceOf(address(_from1), _id);
            try _from1.transferLPTokens(_To1, _id, lender0PoolTokenBalance) {
                if (_To1 == address(0)) {
                    _from1BalancePostBurn = lp.balanceOf(_From1, _id);
                    assertEq(_from1BalancePostBurn, 0);
                } else {
                    revert('REVERT');
                }
            } catch Error(string memory reason) {
                assertEq(reason, _errorString);
            }
        }
    }

    function test_poolTokenTransferComplete_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            1,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_poolTokenTransferPartial_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            2,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_poolTokenTransferPartialByFour_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            4,
            true,
            lenders[0].lenderAddress,
            lenders[1].lenderAddress,
            lenders[2].lenderAddress,
            lenders[3].lenderAddress,
            ''
        );
    }

    function test_cannotBurnPoolToken_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            address(0),
            address(0),
            'ERC1155: transfer to the zero address'
        );
    }

    function test_cannotTransferPoolTokensToSelf_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            lenders[0].lenderAddress,
            address(0),
            'LP:IT1'
        );
    }

    function test_cannotTransferPoolTokensToNonVerified_expiredState() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            protocolFeeCollectorAddress,
            address(0),
            'LP:IT3'
        );
    }

    function test_cannotTransferLPTokensToBorrower() public {
        assert_pool_token_transfer_in_expired_stage(
            requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            address(borrower),
            address(0),
            'LP:IT2'
        );
    }

    function test_cannotTransferNonTransferableLPTokens() public {
        request.areTokensTransferable = false;
        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        if (request.collateralRatio != 0) {
            borrower.depositCollateral(_requestId, _requiredCollateral, false);
        }

        uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);
        borrower.borrow(_requestId, borrowableAmount / 10);

        vm.warp(block.timestamp + 100 + request.duration);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');

        assert_pool_token_transfer_in_expired_stage(
            _requestId,
            1,
            false,
            lenders[0].lenderAddress,
            address(0),
            lenders[1].lenderAddress,
            address(0),
            'LP:IT5'
        );
    }

    function test_externalUserCannotCreate() public {
        try
            lp.create(
                requestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_externalUserCannotTerminate() public {
        try lp.terminate(requestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_cannotLendZeroAmount() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }

    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }

    function test_lenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Withdraw Interest function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_withdraw_interest_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _errorMessage
    ) public {
        uint256 _userBorrowTokenBalancePreWithdraw = borrowAsset.balanceOf(address(_user));
        uint256 _userCollateralTokenBalancePreWithdraw = collateralAsset.balanceOf(address(_user));
        uint256 _userPoolTokenBalancePreWithdraw = lp.balanceOf(address(_user), _id);

        uint256 _lenderInterest = _user.getLenderInterest(_id, address(_user));

        try _user.withdrawInterest(_id) {
            uint256 _userCollateralTokenBalancePostWithdraw = collateralAsset.balanceOf(address(_user));
            uint256 _userBorrowTokenBalancePostWithdraw = borrowAsset.balanceOf(address(_user));
            uint256 _userPoolTokenBalancePostWithdraw = lp.balanceOf(address(_user), _id);

            if (_userPoolTokenBalancePreWithdraw == 0) {
                assertEq(_lenderInterest, 0);
                assertEq(_userBorrowTokenBalancePreWithdraw, _userBorrowTokenBalancePostWithdraw);
            } else {
                assertTrue(_lenderInterest != 0);
                assertEq((_userBorrowTokenBalancePostWithdraw - _userBorrowTokenBalancePreWithdraw), _lenderInterest);
            }

            assertEq(_userPoolTokenBalancePreWithdraw, _userPoolTokenBalancePostWithdraw);
            assertEq(_userCollateralTokenBalancePostWithdraw, _userCollateralTokenBalancePreWithdraw);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    function test_adminCannotWithdrawInterest_expiredState() public {
        assert_withdraw_interest_in_expired_state(requestId, admin, 'LP:WI1');
    }

    function test_borrowerCannotWithdrawInterest_expiredState() public {
        assert_withdraw_interest_in_expired_state(requestId, borrower, 'LP:WI1');
    }

    function test_lendersCanWithdrawInterest_expiredState() public {
        assert_withdraw_interest_in_expired_state(requestId, PCLUser(lenders[0].lenderAddress), '');
    }

    function test_lenderCannotWithdrawZeroInterest() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        uint256 _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));
        assertGt(_lenderInterestOwed, 0);

        _lender.withdrawInterest(requestId);
        _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender));
        assertEq(_lenderInterestOwed, 0);

        try _lender.withdrawInterest(requestId) {
            revert('Lender cannot withdraw zero interest');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WI1');
        }
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Withdraw Liquidation function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function assert_withdraw_liquidation_in_expired_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.withdrawTokensAfterLiquidation(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    function test_adminCannotWithdrawLiquidation_expiredState() public {
        assert_withdraw_liquidation_in_expired_state(
            requestId,
            admin,
            'Cannot withdraw liquidation/liquidity from an expired PCL',
            'LP:WLC1'
        );
    }

    function test_borrowerCannotWithdrawLiquidation_expiredState() public {
        assert_withdraw_liquidation_in_expired_state(
            requestId,
            borrower,
            'Cannot withdraw liquidation/liquidity from an expired PCL',
            'LP:WLC1'
        );
    }

    function test_lenderCannotWithdrawLiquidation_expiredState() public {
        assert_withdraw_liquidation_in_expired_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Cannot withdraw liquidation/liquidity from an expired PCL',
            'LP:IWLC1'
        );
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // View/calculation function tests
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    uint256 _currentDebt;
    uint256 _currentCR;
    uint256 _equivalentCollateral;
    uint256 _totalInterestPending;
    uint256 _totalInterestRepaid;
    uint256 _principal;

    // Test8: Helper Functionalities
    function assert_helper_functionalities_in_expired_state_when_price_fluctuates(uint256 _id) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 0. collateralTokensToLiquidate
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, _currentDebt);
        assertGt(_equivalentCollateral, 0);

        // 1. calculateCurrentCollateralRatio
        _currentCR = _borrower.calculateCurrentCollateralRatio(_id);
        if (request.collateralRatio != 0) {
            assertGt(_currentCR, request.collateralRatio);
        } // Since a lot of extra collateral was deposited

        // 2. calculatePrincipalWithdrawable
        try _lender.withdrawLiquidity(_id) {
            revert('Cannot be called without liquidating the borrower');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL3');
        }

        // 3. withdrawableCollateral
        uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertEq(_withdrawableCollateral, 0); //Since the PCL has already gone into the EXPIRED state

        // 4. calculateTotalCollateralTokens
        uint256 _totalCollateral = pcl.calculateTotalCollateralTokens(_id);
        if (request.collateralRatio != 0) {
            assertGt(_totalCollateral, 0);
        } // Since a lot of extra collateral was deposited

        // 5. calculateBorrowableAmount
        uint256 _borrowableAmount = _borrower.calculateBorrowableAmount(_id);
        assertEq(_borrowableAmount, 0); // Since the PCL is already EXPIRED

        // 6. calculateInterestAccrued
        uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGt(_interestAccrued, 0); // Should be non-zero, since it calculates interest accrued since last repayment
        // doesn't matter whether the PCL has been expired or not

        // 7. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        (, _principal, _totalInterestRepaid, , ) = pcl.pooledCreditLineVariables(_id);
        _totalInterestPending = _borrower.calculateInterestAccrued(_id);
        uint256 calculatedCurrentDebt = _totalInterestPending + _principal - _totalInterestRepaid;
        assertEq(_currentDebt, calculatedCurrentDebt);
    }

    function test_helperFunctionsInExpiredState() public {
        assert_helper_functionalities_in_expired_state_when_price_fluctuates(requestId);
    }

    function helper_timeWarp(uint256 _time) public {
        vm.warp(_time);
        vm.roll(_time.div(20));
    }
}",9817
RealWorld_BA_101_PCLExpiredStage.t_RealWord_20240827094220.log,101,PCLExpiredStage.t,14502,5320,19822,75.0,0.17891,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '../PCLExpiredStage.t.sol';

contract PCLExpiredStageCollateralCompoundBorrowCompound is PCLExpiredStage {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    function setUp() public override {
        PCLParent.setUp();

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 5000 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 3650 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = compoundYieldAddress;
        request.collateralAssetStrategy = compoundYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, type(uint256).max);
        borrower.depositCollateral(requestId, _requiredCollateral, false);

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);
        // and borrows the borrowable amount
        borrower.borrow(requestId, borrowableAmount);

        // Borrower decides to repay everything at mid-duration

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 2);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, currentDebt / 2);

        // Now we travel past the duration to the expiration period
        vm.warp(block.timestamp + 100 + request.duration / 2);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');
    }
}",703
RealWorld_BA_101_PCLLiquidatedStateCompoundYield.t_RealWord_20240827102910.log,101,PCLLiquidatedStateCompoundYield.t,19014,6082,25096,100.0,0.21671,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '../PCLLiquidatedState.t.sol';
import '../../Helpers/PCLParent.t.sol';

contract PCLLiquidatedStatePriceOracleCompoundYield is PCLLiquidatedStatePriceOracle {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    function setUp() public override {
        PCLParent.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();
        _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));
        _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));

        _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();
        _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));
        _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = compoundYieldAddress;
        request.collateralAssetStrategy = compoundYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);
        lender_0 = lenders[0].lenderAddress;

        // Now we assert that we are in the ACTIVE state
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), 2);

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);
        borrower.depositCollateral(requestId, _requiredCollateral, false);

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);
        // and borrows the borrowable amount
        borrower.borrow(requestId, borrowableAmount);

        // Borrower decides to repay everything at mid-duration

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 2);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay the entire debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt / 200);
        borrower.repay(requestId, currentDebt / 200);

        // Now we travel past the expiration date
        vm.warp(block.timestamp + request.duration + request.defaultGracePeriod);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');

        // Now the PCL should be in the LIQUIDATED state
        PCLUser(lender_0).liquidate(requestId, false);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED, '!Liquidated');
    }
}",918
RealWorld_BA_101_PCLLiquidatedState.t_RealWord_20240827091212.log,101,PCLLiquidatedState.t,116378,5837,122215,123.0,0.69863,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';

import '../Helpers/PCLParent.t.sol';

contract PCLLiquidatedStateCToken is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 _collateralAssetDecimals;
    uint128 _collateralAssetPriceMin;
    uint128 _borrowAssetPriceMin;
    uint128 _collateralAssetPriceMax;
    uint128 _borrowAssetPriceMax;
    uint256 requestId;
    uint256 _fromUserPoolTokenSupply;
    uint256 _toUserPoolTokenSupply;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;
    uint256 _calculatedCurrentDebt;
    uint256 _fetchedCurrentDebt;

    address lender_0;

    function setUp() public override {
        super.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        uint256 _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();
        _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));
        _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));

        _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();
        _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));
        _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 5000 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = compoundYieldAddress;
        request.collateralAssetStrategy = compoundYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);
        lender_0 = lenders[0].lenderAddress;

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);
        borrower.depositCollateral(requestId, _requiredCollateral, false);

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);
        // and borrows the borrowable amount
        borrower.borrow(requestId, borrowableAmount);

        // Borrower decides to repay everything at mid-duration

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 10);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay the entire debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt);
        borrower.repay(requestId, currentDebt / 200);

        // Now we travel past the expiration date
        vm.warp(block.timestamp + request.duration + request.defaultGracePeriod);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');

        // Now the PCL should be in the LIQUIDATED state
        PCLUser(lender_0).liquidate(requestId, false);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
    }

    // Test 0: Test SetUp
    function test_setUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED, '!Liquidated');

        uint256 _borrowCTokenExchangeRate = MockCToken(borrowCTokenAddress).exchangeRateCurrent();
        uint256 _collateralCTokenExchangeRate = MockCToken(collateralCTokenAddress).exchangeRateCurrent();

        // Checking out what are the exchange rates
        log_named_int('Borrow CToken Exchange Rate', int256(_borrowCTokenExchangeRate));
        log_named_int('Collateral CToken Exchange Rate', int256(_collateralCTokenExchangeRate));

        // Check the exchange rates of the borrow and collateral CTokens are non-zero
        assertGt(_borrowCTokenExchangeRate, 0);
        assertGt(_collateralCTokenExchangeRate, 0);
    }

    // Test 1: A liquidated PCL cannot be started even with exchange rate fluctuations
    function test_pclCannotBeStarted() public {
        helper_exchangeRateChanges();

        try borrower.start(requestId) {
            revert('Cannot start a liquidated PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S1');
        }
    }

    // Test 2: Collateral cannot be deposited
    function test_collateralCannotBeDeposited() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        helper_exchangeRateChanges();
        try borrower.depositCollateral(requestId, _minimumCollateralRequired, false) {
            revert('Collateral cannot be deposited');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:DC2');
        }
    }

    // Test 3: Withdrawable collateral remains zero
    function test_withdrawableCollateralIsZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        console.log(_withdrawableCollateral);
        assertApproxEqAbs(_withdrawableCollateral, 0, 2);
    }

    // Test 4: Collateral can or cannot be withdrawn
    function test_collateralCanOrCannotBeWithdrawn() public {
        helper_exchangeRateChanges();

        uint256 _tokens = (pcl.depositedCollateralInShares(requestId) * ICToken(collateralCTokenAddress).exchangeRateCurrent()) / 1e18;
        if (_tokens > 0) {
            uint256 _borrowerBalanceBefore = collateralAsset.balanceOf(address(borrower));
            borrower.withdrawCollateral(requestId, 1, false);
            uint256 _borrowerBalanceAfter = collateralAsset.balanceOf(address(borrower));
            assertGe(_borrowerBalanceAfter, _borrowerBalanceBefore);
        } else {
            try borrower.withdrawCollateral(requestId, 1, false) {
                revert('Collateral cannot be withdrawn');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:WC1');
            }
        }
    }

    // Test 5: All Collateral can or cannot be withdrawn
    function test_allCollateralCanOrCannotBeWithdrawn() public {
        helper_exchangeRateChanges();

        uint256 _tokens = (pcl.depositedCollateralInShares(requestId) * ICToken(collateralCTokenAddress).exchangeRateCurrent()) / 1e18;
        if (_tokens > 0) {
            uint256 _borrowerBalanceBefore = collateralAsset.balanceOf(address(borrower));
            borrower.withdrawCollateral(requestId, 1, false);
            uint256 _borrowerBalanceAfter = collateralAsset.balanceOf(address(borrower));
            assertGe(_borrowerBalanceAfter, _borrowerBalanceBefore);
        } else {
            try borrower.withdrawAllCollateral(requestId, false) {
                revert('All Collateral cannot be withdrawn');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:WAC1');
            }
        }
    }

    // Test 6: A liquidated PCL cannot be closed
    function test_pclCannotBeClosed() public {
        helper_exchangeRateChanges();

        try borrower.close(requestId) {
            revert('PCL cannot be closed');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C1');
        }
    }

    // Test 7: Required collateral remains same if collateral CToken exchange rate increases steeply
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.1: Required collateral remains same if borrow CToken exchange rate increases steeply
    function test_requiredCollateralRemainsSameIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.2: Required collateral remains same if borrow CToken exchange rate decreases to zero
    function test_requiredCollateralRemainsSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.3: Required collateral remains same if collateral CToken exchange rate decreases to zero
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.4: Required collateral remains same if collateral CToken exchange rate increases very slowly
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 8: Collateral tokens remains zero if collateral CToken exchange rate increases steeply
    function test_totalCollateralTokensRemainsZeroIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);

        assertApproxEqAbs(_collateralTokens, 0, 2);
    }

    // Test 8.1: Collateral tokens may revert if collateral CToken exchange rate decreases to zero
    function test_totalCollateralTokensMayRevertIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_decreaseExchangeRateToZero(collateralCTokenAddress);

        uint256 _shares = pcl.depositedCollateralInShares(requestId);
        if (_shares > 0) {
            try pcl.calculateTotalCollateralTokens(requestId) {
                revert('Total collateral tokens should revert');
            } catch Error(string memory reason) {
                assertEq(reason, 'CY:GTFS1');
            }
        } else {
            uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);
            assertEq(_collateralTokens, 0);
        }
    }

    // Test 9: Collateral ratio remains zero if collateral CToken exchange rate increases steeply
    function test_collateralRatioRemainsZeroIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, 1e9);
    }

    // Test 9.1: Collateral ratio remains zero if borrow CToken exchange rate increases steeply
    function test_collateralRatioRemainsZeroIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_increaseExchangeRateSteeply(borrowCTokenAddress);
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, 1e9);
    }

    // Test 9.2: Collateral ratio remains zero if borrow CToken exchange rate decreases to zero
    function test_collateralRatioRemainsZeroIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, 1e9);
    }

    // Test 9.3: Collateral ratio may revert if collateral CToken exchange rate decreases to zero
    function test_collateralRatioMayRevertIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        uint256 _shares = pcl.depositedCollateralInShares(requestId);
        if (_shares > 0) {
            try pcl.calculateCurrentCollateralRatio(requestId) {
                revert('Collateral ratio should revert');
            } catch Error(string memory reason) {
                assertEq(reason, 'CY:GTFS1');
            }
        } else {
            uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);

            assertLt(_collateralRatio, 1e9);
        }
    }

    // Test 9.4: Collateral ratio remains zero if collateral CToken exchange rate increases very slowly
    function test_collateralRatioRemainsZeroIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, 1e9);
    }

    // Test 10: A liquidated PCL cannot be cancelled
    function test_pclCannotBeCancelled() public {
        helper_exchangeRateChanges();

        try borrower.cancelRequest(requestId) {
            revert('PCL cannot be cancelled');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    // Test 11: Admin should be able to terminate
    function test_adminCanTerminatePCL() public {
        helper_exchangeRateChanges();

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        admin.terminate(requestId);
        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0);
        assertGt(_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate, 0);
    }

    // Test 12: Borrowable amount remains zero
    function test_borrowableAmountIsZero() public {
        helper_exchangeRateChanges();

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        assertEq(_borrowableAmount, 0);
    }

    // Test 13: Borrower cannot repay
    function test_borrowerCannotRepay() public {
        helper_exchangeRateChanges();

        try borrower.repay(requestId, 1) {
            revert('Borrower cannot repay');
        } catch Error(string memory reason) {
            console.log(reason);
            assertEq(reason, 'PCL:REP2');
        }
    }

    // Test 14: A liquidated PCL cannot be liquidated
    function test_lendersCannotLiquidate(bool _withdraw) public {
        helper_exchangeRateChanges();

        // lender_0 tries to liquidate the PCL
        try PCLUser(lender_0).liquidate(requestId, _withdraw) {
            revert('Cannot liquidate a liquidated PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L2');
        }
    }

    // Test 15: Lenders can withdraw liquidated collateral tokens
    function test_lendersCanWithdrawLiquidation() public {
        helper_exchangeRateChanges();

        uint256 _userPoolTokenBalance = lp.balanceOf(address(lender_0), requestId);
        uint256 _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, lender_0);

        uint256 _userBorrowTokenBalanceBefore = IERC20(request.borrowAsset).balanceOf(address(lender_0));
        uint256 _userCollateralTokenBalanceBefore = IERC20(request.collateralAsset).balanceOf(address(lender_0));
        PCLUser(lender_0).withdrawTokensAfterLiquidation(requestId);
        uint256 _userBorrowTokenBalanceAfter = IERC20(request.borrowAsset).balanceOf(address(lender_0));
        uint256 _userCollateralTokenBalanceAfter = IERC20(request.collateralAsset).balanceOf(address(lender_0));

        assertGt(_userPoolTokenBalance + _lenderInterestOwed, _userBorrowTokenBalanceAfter - _userBorrowTokenBalanceBefore);
        assertGt(_userCollateralTokenBalanceAfter - _userCollateralTokenBalanceBefore, 0);

        _userPoolTokenBalance = lp.balanceOf(address(lender_0), requestId);
        _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, lender_0);
        assertEq(_userPoolTokenBalance, 0);
        assertEq(_lenderInterestOwed, 0);
    }

    // Test 16: Lenders cannot withdraw liquidity
    function test_lendersCannotWithdrawLiquidity() public {
        helper_exchangeRateChanges();

        try PCLUser(lender_0).withdrawLiquidity(requestId) {
            revert('Lender cannot withdraw liquidity');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL2');
        }
    }

    // Test 17: Pool token transfers should be possible in a liquidated PCL
    function test_poolTokenTransfersShouldBePossibleEntireBalance() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, 0);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == 0);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));
    }

    // Test 17.1: Pool token transfers should be possible in a liquidated PCL
    function test_poolTokenTransfersShouldBePossiblePartialBalance() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 18: Interest can be withdrawn amidst price fluctuations
    function test_lendersCanWithdrawInterest() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender0Balance = borrowAsset.balanceOf(address(lender0));

        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender1Balance = borrowAsset.balanceOf(address(lender1));

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender0));
        uint256 lender1InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender1));

        lender0.withdrawInterest(requestId);

        uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(lender0));
        assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);

        helper_exchangeRateChanges();

        lender1.withdrawInterest(requestId);

        uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(lender1));
        assertGt((lender1BalanceFinal - lender1Balance), lender1InterestOwed);
    }

    // Test 18.1: Interest that can be withdrawn increases
    function test_lenderInterestIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender0));
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);

        uint256 lender0InterestOwedNew = lp.getLenderInterestWithdrawable(requestId, address(lender0));
        assertLt(lender0InterestOwed, lender0InterestOwedNew);
    }

    uint256 _principal;
    uint256 _currentCR1;
    uint256 _currentCR2;
    uint256 _currentCR3;
    uint256 _principalWithdrawable;
    uint256 _withdrawableCollateral;
    uint256 _currentDebt;
    uint256 _borrowable;
    uint256 _totalCollateral;
    uint256 _equivalentCollateral;
    uint256 _interestAccrued;

    uint256 collateralToDeposit;

    function assert_helperFunctionalitiesInLiquidatedState(uint256 _id) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 1. calculateCurrentCollateralRatio
        _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);
        assertLt(_currentCR1, 1e9);

        helper_exchangeRateChanges();

        // 2. calculatePrincipalWithdrawable
        _principalWithdrawable = lp.calculatePrincipalWithdrawable(_id, address(_lender));
        assertLt(_principalWithdrawable, lp.balanceOf(address(_lender), requestId));

        helper_exchangeRateChanges();

        // 3. withdrawableCollateral
        _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertApproxEqAbs(_withdrawableCollateral, 0, 2);

        helper_exchangeRateChanges();

        // 4. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        assertGt(_currentDebt, 0);

        helper_exchangeRateChanges();

        // 5. calculateBorrowableAmount
        _borrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_borrowable, 0);

        helper_exchangeRateChanges();

        // 6. calculateTotalCollateralTokens
        _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertApproxEqAbs(_totalCollateral, 0, 2);

        helper_exchangeRateChanges();

        // 7. collateralTokensToLiquidate
        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
        assertGt(_equivalentCollateral, 0);

        helper_exchangeRateChanges();

        // 8. calculateInterestAccrued
        _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGt(_interestAccrued, 0);

        helper_exchangeRateChanges();
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }

    function test_helperFunctionsInLiquidatedState() public {
        assert_helperFunctionalitiesInLiquidatedState(requestId);
    }
}",7240
RealWorld_BA_101_PCLExpiredStateCompoundYield.t_RealWord_20240827102552.log,101,PCLExpiredStateCompoundYield.t,16351,5523,21874,92.0,0.192215,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '../PCLExpiredState.t.sol';
import '../../Helpers/PCLParent.t.sol';

contract PCLExpiredStatePriceOracleCompoundYield is PCLExpiredStatePriceOracle {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    function setUp() public override {
        PCLParent.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();
        _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));
        _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));

        _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();
        _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));
        _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = compoundYieldAddress;
        request.collateralAssetStrategy = compoundYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        // Now we assert that we are in the ACTIVE state
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), 2);

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);
        borrower.depositCollateral(requestId, _requiredCollateral, false);

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);
        // and borrows the borrowable amount
        borrower.borrow(requestId, borrowableAmount);

        // Borrower decides to repay everything at mid-duration

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 2);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt / 2);
        borrower.repay(requestId, currentDebt / 2);

        // Now we travel past the duration to the expiration period
        vm.warp(block.timestamp + 100 + request.duration / 2);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');
    }
}",848
RealWorld_BA_101_PCLConstants.t_RealWord_20240827103558.log,101,PCLConstants.t,12071,5517,17588,84.0,0.170695,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/utils/ReentrancyGuard.sol';
import '@openzeppelin/contracts-upgradeable/proxy/Initializable.sol';
import '@openzeppelin/contracts-upgradeable/token/ERC20/ERC20PausableUpgradeable.sol';

library PCLConstants {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;
    using SafeMath for uint128;

    uint256 public constant maxCollateralRatio = (10**18) * 200;
    uint256 public constant minCollateralRatio = (10**16);

    uint256 public constant maxDuration = 7500 days; // in days
    uint256 public constant minDuration = 1 days; // in days

    uint256 public constant maxDefaultGraceDuration = 3650 days; // in days
    uint256 public constant minDefaultGraceDuration = 1 days; // in days

    uint256 public constant maxGracePenaltyRate = 10e18 - 1;
    uint256 public constant minGracePenaltyRate = 1;

    uint256 public constant maxCollectionPeriod = 7500 days; // in days
    uint256 public constant minCollectionPeriod = 1 days; // in days

    uint256 public constant maxBorrowLimit = 1e15; // ($1,000,000,000)
    uint256 public constant minBorrowLimit = 1e10; //($10000)

    uint128 public constant maxBorrowRate = (10**18) * 200;
    uint128 public constant minBorrowRate = 10**16;

    address public constant hevmAddress = 0x7109709ECfa91a80626fF3989D68f67F5b1DD12D;

    uint256 public constant maxStrategies = 10;

    uint256 public constant protocolFeeFraction = 10e16;

    uint256 public constant startFeeFraction = 1e16;

    uint32 public constant uniswapPriceAveragingPeriod = 10;

    // Random addresses used as borrower/lender verifiers addresses
    address public constant _borrowerVerifier = 0xDeaDbeefdEAdbeefdEadbEEFdeadbeEFdEaDbeeF;
    address public constant _lenderVerifier = 0xDEADbEEfDeAdBeeFdeAdbeefDEADbEEFDeaDBeeC;
}",562
RealWorld_BA_101_PCLExpiredStage.t_RealWord_20240827093610.log,101,PCLExpiredStage.t,15124,5437,20561,82.0,0.18436,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '../PCLExpiredStage.t.sol';

contract PCLExpiredStageCollateralCompoundBorrowNoYield is PCLExpiredStage {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    function setUp() public override {
        PCLParent.setUp();

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 5000 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 3650 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = compoundYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, type(uint256).max);
        borrower.depositCollateral(requestId, _requiredCollateral, false);

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);
        // and borrows the borrowable amount
        borrower.borrow(requestId, borrowableAmount);

        // Borrower decides to repay everything at mid-duration

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 2);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, currentDebt / 2);

        // Now we travel past the duration to the expiration period
        vm.warp(block.timestamp + 100 + request.duration / 2);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');
    }
}",705
RealWorld_BA_101_PCLClosedState.t_RealWord_20240827101840.log,101,PCLClosedState.t,103059,5612,108671,88.0,0.627535,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';

import '../Helpers/PCLParent.t.sol';

contract PCLClosedStatePriceOracle is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 _borrowAssetDecimals;
    uint256 _collateralAssetDecimals;
    uint128 _collateralAssetPriceMin;
    uint128 _borrowAssetPriceMin;
    uint128 _collateralAssetPriceMax;
    uint128 _borrowAssetPriceMax;
    uint256 requestId;
    uint256 _fromUserPoolTokenSupply;
    uint256 _toUserPoolTokenSupply;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;
    uint256 _calculatedCurrentDebt;
    uint256 _fetchedCurrentDebt;
    address lender_0;

    function setUp() public virtual override {
        super.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();
        _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));
        _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));

        _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();
        _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));
        _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        //The below function will create the PCL request and then lenders lend the entire requested amount
        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);
        lender_0 = lenders[0].lenderAddress;

        // Now we assert that we are in the ACTIVE state
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), 2);

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);
        borrower.depositCollateral(requestId, _requiredCollateral, false);

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);
        // and borrows the borrowable amount
        borrower.borrow(requestId, borrowableAmount);

        // Borrower decides to repay everything at mid-duration

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 2);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay the entire debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt);
        borrower.repay(requestId, currentDebt);

        // Now the PCL should be in the CLOSED state
        borrower.close(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }

    // Test 0: Test SetUp
    function test_setUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed');

        (, int256 _borrowAssetPrice, , , ) = MockV3Aggregator(borrowAssetAggregatorAddress).latestRoundData();
        (, int256 _collateralAssetPrice, , , ) = MockV3Aggregator(collateralAssetAggregatorAddress).latestRoundData();

        // Checking out what are the prices
        log_named_int('Borrow Asset Price', _borrowAssetPrice);
        log_named_int('Collateral Asset Price', _collateralAssetPrice);

        // Check the prices of the borrowAsset and collateralAsset are non-zero
        assertGt(_borrowAssetPrice, 0);
        assertGt(_collateralAssetPrice, 0);
    }

    // Test 1: A Closed PCL cannot be started even with price fluctuations
    function test_pclCannotBeStarted(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try borrower.start(requestId) {
            revert('Cannot start a PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S1');
        }
    }

    // Test 2: Collateral cannot be deposited
    function test_collateralCannotBeDeposited(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        try borrower.depositCollateral(requestId, _minimumCollateralRequired, false) {
            revert('Collateral cannot be deposited');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:DC2');
        }
    }

    // Test 3: Withdrawable collateral remains zero
    function test_withdrawableCollateralIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);

        assertApproxEqAbs(_withdrawableCollateral, 0, 2);
    }

    // Test 3.1: Collateral can or cannot be withdrawn
    function test_collateralCanOrCannotBeWithdrawn(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        uint256 _tokens = (pcl.depositedCollateralInShares(requestId) * ICToken(collateralCTokenAddress).exchangeRateCurrent()) / 1e18;
        if (_tokens > 0) {
            uint256 _borrowerBalanceBefore = collateralAsset.balanceOf(address(borrower));
            borrower.withdrawCollateral(requestId, 1, false);
            uint256 _borrowerBalanceAfter = collateralAsset.balanceOf(address(borrower));
            assertGe(_borrowerBalanceAfter, _borrowerBalanceBefore);
        } else {
            try borrower.withdrawCollateral(requestId, 1, false) {
                revert('Collateral cannot be withdrawn');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:WC1');
            }
        }
    }

    // Test 3.2: All collateral can or cannot be withdrawn
    function test_allCollateralCanOrCannotBeWithdrawn(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        uint256 _tokens = (pcl.depositedCollateralInShares(requestId) * ICToken(collateralCTokenAddress).exchangeRateCurrent()) / 1e18;
        if (_tokens > 0) {
            uint256 _borrowerBalanceBefore = collateralAsset.balanceOf(address(borrower));
            borrower.withdrawAllCollateral(requestId, false);
            uint256 _borrowerBalanceAfter = collateralAsset.balanceOf(address(borrower));
            assertGe(_borrowerBalanceAfter, _borrowerBalanceBefore);
        } else {
            try borrower.withdrawAllCollateral(requestId, false) {
                revert('All collateral cannot be withdrawn');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:WAC1');
            }
        }
    }

    // Test 4: Required collateral decreases if collateral asset price increases
    function test_requiredCollateralDecreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertGt(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 4.1: Required collateral increases if borrow asset price increases
    function test_requiredCollateralIncreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertLt(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 4.2: Required collateral increases if collateral asset price decreases
    function test_requiredCollateralIncreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertLt(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 4.3: Required collateral decreases if borrow asset price decreases
    function test_requiredCollateralDecreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertGt(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 4.4: Required collateral reverts if borrow asset price decreases to 0
    function test_requiredCollateralRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try pcl.getRequiredCollateral(requestId, request.borrowLimit / 2) {
            revert('Required collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 4.5: Required collateral reverts if collateral asset price decreases to 0
    function test_requiredCollateralRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try pcl.getRequiredCollateral(requestId, request.borrowLimit / 2) {
            revert('Required collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 5: Borrowable amount remains zero
    function test_borrowableAmountIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        assertEq(_borrowableAmount, 0);
    }

    // Test 6: A Closed PCL cannot be closed
    function test_pclCannotBeClosed(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        try borrower.close(requestId) {
            revert('PCL cannot be closed');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C1');
        }
    }

    // Test 7: Collateral ratio remains infinite
    function test_collateralRatioIsInfinite(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);

        assertEq(_collateralRatio, type(uint256).max);
    }

    // Test 7.1: Collateral ratio reverts if borrow asset price decreases to 0
    function test_collateralRatioRevertsIfBorrowAssetPriceDecreasesToZero() public {
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try pcl.calculateCurrentCollateralRatio(requestId) {
            revert('Collateral ratio should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 7.2: Collateral ratio reverts if collateral asset price decreases to 0
    function test_collateralRatioRevertsIfCollateralAssetPriceDecreasesToZero() public {
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try pcl.calculateCurrentCollateralRatio(requestId) {
            revert('Collateral ratio should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 8: Lenders cannot withdraw liquidation
    function test_lendersCannotWithdrawLiquidation(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try PCLUser(lender_0).withdrawLiquidation(requestId) {
            revert('Lender cannot withdraw liquidation tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    // Test 9: Lenders can withdraw liquidity
    function test_lendersCanWithdrawLiquidity(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        uint256 _userPoolTokenBalance = lp.balanceOf(lender_0, requestId);
        uint256 _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, lender_0);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        uint256 _userBorrowTokenBalanceBefore = IERC20(request.borrowAsset).balanceOf(lender_0);
        PCLUser(lender_0).withdrawLiquidity(requestId);
        uint256 _userBorrowTokenBalanceAfter = IERC20(request.borrowAsset).balanceOf(lender_0);
        assertApproxEqRel(_userPoolTokenBalance + _lenderInterestOwed, _userBorrowTokenBalanceAfter - _userBorrowTokenBalanceBefore, 1e16);

        _userPoolTokenBalance = lp.balanceOf(lender_0, requestId);
        _lenderInterestOwed = lp.getLenderInterestWithdrawable(requestId, lender_0);
        assertEq(_userPoolTokenBalance, 0);
        assertEq(_lenderInterestOwed, 0);
    }

    // Test 10: A Closed PCL cannot be liquidated
    function test_lendersCannotLiquidate(
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed,
        bool _withdraw
    ) public {
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // lender_0 tries to liquidate the PCL
        try PCLUser(lender_0).liquidate(requestId, _withdraw) {
            revert('Cannot liquidate a Closed PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L1');
        }
    }

    // Test 11: Admin can terminate pcl
    function test_adminCanTerminatePCL(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        admin.terminate(requestId);
        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertGe((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0);
        assertGt(_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate, 0);
    }

    // Test 12: Pool token transfers should be possible
    function test_poolTokenTransfersShouldBePossibleEntireBalance(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);

        //Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, 0);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == 0);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));
    }

    // Test 12.1: Pool token transfers should be possible
    function test_poolTokenTransfersShouldBePossiblePartialBalance(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed)
        public
    {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 13: Interest can be withdrawn amidst price fluctuations
    function test_lendersCanWithdrawInterest(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender0Balance = borrowAsset.balanceOf(address(lender0));

        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender1Balance = borrowAsset.balanceOf(address(lender1));

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender0));
        uint256 lender1InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender1));

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        lender1.withdrawInterest(requestId);
        uint256 lender1BalanceAfter = borrowAsset.balanceOf(address(lender1));
        assertEq(lender1BalanceAfter, lender1Balance + lender1InterestOwed);
        assertEq(lp.getLenderInterestWithdrawable(requestId, address(lender1)), 0);
    }

    // Test 14: A Closed PCL cannot be cancelled
    function test_pclCannotBeCancelled(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        try borrower.cancelRequest(requestId) {
            revert('PCL cannot be cancelled');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    function assert_helperFunctionalitiesInClosedState(
        uint256 _id,
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed
    ) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.CLOSED);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 1. calculateCurrentCollateralRatio
        {
            uint256 _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);
            assertEq(_currentCR1, uint256(-1));
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 2. calculatePrincipalWithdrawable
        {
            uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
            assertGt(_principalWithdrawable, 0);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 3. withdrawableCollateral
        {
            uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
            assertApproxEqAbs(_withdrawableCollateral, 0, 2);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 4. calculateCurrentDebt
        {
            uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);
            assertEq(_currentDebt, 0);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 5. calculateBorrowableAmount
        {
            uint256 _borrowable = _borrower.calculateBorrowableAmount(_id);
            assertEq(_borrowable, 0);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 6. calculateTotalCollateralTokens
        {
            uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
            assertApproxEqAbs(_totalCollateral, 0, 2);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 7. collateralTokensToLiquidate
        {
            uint256 _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
            assertGt(_equivalentCollateral, 0);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 8. calculateInterestAccrued
        {
            uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
            assertGt(_interestAccrued, 0);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.CLOSED);
    }

    function test_helperFunctionsInClosedState(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        assert_helperFunctionalitiesInClosedState(requestId, _borrowAssetPriceSeed, _collateralAssetPriceSeed);
    }
}",6391
RealWorld_BA_101_MockAdminVerifier_RealWord_20240827085622.log,101,MockAdminVerifier,16019,6070,22089,90.0,0.201495,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

import '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';
import '@openzeppelin/contracts-upgradeable/drafts/EIP712Upgradeable.sol';
import '@openzeppelin/contracts/cryptography/ECDSA.sol';
import '../interfaces/IVerification.sol';
import '../interfaces/IVerifier.sol';

contract MockAdminVerifier is Initializable, IVerifier, OwnableUpgradeable, EIP712Upgradeable {
    /**
     * @notice stores the verification contract instance
     */
    IVerification public verification;

    /**
     * @notice emitted when verification contract address is updated
     * @param verification address of the updated verification contract
     */
    event VerificationUpdated(address indexed verification);
    /**
     * @notice emitted when Signer address is updated
     * @param signerAddress address of the updated verification contract
     */
    event SignerUpdated(address indexed signerAddress);

    /// @notice Initializes the variables of the contract
    /// @dev Contract follows proxy pattern and this function is used to initialize the variables for the contract in the proxy
    /// @param _admin Admin of the verification contract who can add verifiers and remove masterAddresses deemed invalid
    /// @param _verification Verification contract address
    /// @param _name name of the verifier (used in domain seperator)
    /// @param _version version of the verifier (used in domain seperator)
    function initialize(
        address _admin,
        address _verification,
        string memory _name,
        string memory _version
    ) external initializer {
        super.__Ownable_init();
        super.transferOwnership(_admin);
        _updateVerification(_verification);
        __EIP712_init(_name, _version);
    }

    /**
     * @notice used to register user
     * @dev only owner can register users
     */

    function registerSelf() external {
        require(!verification.isUser(msg.sender, address(this)), 'User already exists');
        verification.registerMasterAddress(msg.sender, true); // true because we'll always link address here

        emit UserRegistered(msg.sender, true, 'none');
    }

    function registerUserViaOwner(address _user) external onlyOwner {
        require(!verification.isUser(_user, address(this)), 'User already exists');
        verification.registerMasterAddress(_user, true); // true because we'll always link address here

        emit UserRegistered(_user, true, 'none');
    }

    /**
     * @notice used to unregister self
     * @dev users themselves can unregister themself
     */
    function unregisterSelf() external {
        require(verification.isUser(msg.sender, address(this)), 'User does not exist');
        verification.unregisterMasterAddress(msg.sender, address(this));

        emit UserUnregistered(msg.sender);
    }

    /**
     * @notice used to unregister user
     * @dev owners can unregister users
     */
    function unregisterUser(address _user) external onlyOwner {
        require(verification.isUser(_user, address(this)), 'User does not exist');
        verification.unregisterMasterAddress(_user, address(this));
        emit UserUnregistered(_user);
    }

    /**
     * @notice used to update verification contract address
     * @dev only owner can update
     * @param _verification address of the verification contract
     */
    function updateVerification(address _verification) external onlyOwner {
        _updateVerification(_verification);
    }

    function _updateVerification(address _verification) internal {
        verification = IVerification(_verification);
        emit VerificationUpdated(_verification);
    }
}",742
RealWorld_BA_101_BeforeLiquidationFailureCases.t_RealWord_20240827092114.log,101,BeforeLiquidationFailureCases.t,79607,5855,85462,95.0,0.515135,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';

import '../Helpers/PCLParent.t.sol';

contract BeforeLiquidationFailureCases is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    uint256 requestId;

    function setUp() public override {
        super.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        request.borrowLimit = uint128(1_000_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * 1e18) / 1e2);
        request.collateralRatio = 1e18;
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * 1e18) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);
    }

    function test_noLiquidationIfCollateralRatioIsFineAndNotExpired1() public {
        assert_noLiquidationIfCollateralRatioIsFineAndNotExpired(requestId, uint128(request.minBorrowAmount), 0);
    }

    function test_noLiquidationIfCollateralRatioIsFineAndNotExpired2() public {
        assert_noLiquidationIfCollateralRatioIsFineAndNotExpired(requestId, request.borrowLimit, request.duration - 1);
    }

    function test_noLiquidationIfCollateralRatioIsFineAndNotExpired3() public {
        assert_noLiquidationIfCollateralRatioIsFineAndNotExpired(requestId, uint128(request.minBorrowAmount), request.duration - 1);
    }

    function test_noLiquidationIfCollateralRatioIsFineAndNotExpired4() public {
        assert_noLiquidationIfCollateralRatioIsFineAndNotExpired(requestId, uint128(request.minBorrowAmount), 0);
    }

    function assert_noLiquidationIfCollateralRatioIsFineAndNotExpired(
        uint256 _pclId,
        uint256 _amountToBorrow,
        uint256 _warpTime
    ) internal {
        uint256 _collateralRequired = pcl.getRequiredCollateral(_pclId, _amountToBorrow) + 1;

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        borrower.depositCollateral(_pclId, _collateralRequired, false);

        borrower.borrow(requestId, _amountToBorrow.mul(90).div(100));

        vm.warp(block.timestamp + _warpTime);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.liquidate(_pclId, true) {
            revert('Borrower liquidating should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    function test_noLiquidationIfCollateralRatioIsFineAtExpirationTimestamp1() public {
        assert_noLiquidationIfCollateralRatioIsFineAtExpirationTimestamp(requestId, uint128(request.minBorrowAmount));
    }

    function test_noLiquidationIfCollateralRatioIsFineAtExpirationTimestamp2() public {
        assert_noLiquidationIfCollateralRatioIsFineAtExpirationTimestamp(requestId, request.borrowLimit);
    }

    function assert_noLiquidationIfCollateralRatioIsFineAtExpirationTimestamp(uint256 _pclId, uint256 _amountToBorrow) internal {
        // adding 1 to ensure that any diff due to imprecision issues is covered
        uint256 _collateralRequired = pcl.getRequiredCollateral(_pclId, _amountToBorrow) + 1;
        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        borrower.depositCollateral(_pclId, _collateralRequired, false);
        borrower.borrow(_pclId, _amountToBorrow.mul(90).div(100));

        vm.warp(block.timestamp + request.duration);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.liquidate(_pclId, true) {
            revert('Borrower liquidating should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    function test_noLiquidateIfInGracePeriod1() public {
        assert_noLiquidateIfInGracePeriod(requestId, request.borrowLimit, request.duration + 1);
    }

    function test_noLiquidateIfInGracePeriod2() public {
        assert_noLiquidateIfInGracePeriod(requestId, request.borrowLimit, request.duration + request.defaultGracePeriod - 1);
    }

    function test_noLiquidateIfInGracePeriod3() public {
        assert_noLiquidateIfInGracePeriod(requestId, uint128(request.minBorrowAmount), request.duration + 1);
    }

    function test_noLiquidateIfInGracePeriod4() public {
        assert_noLiquidateIfInGracePeriod(requestId, uint128(request.minBorrowAmount), request.duration + request.defaultGracePeriod - 1);
    }

    function assert_noLiquidateIfInGracePeriod(
        uint256 _pclId,
        uint256 _amountToBorrow,
        uint256 _warpTime
    ) internal {
        // adding 1 to ensure that any diff due to imprecision issues is covered
        uint256 _collateralRequired = pcl.getRequiredCollateral(_pclId, _amountToBorrow);

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        borrower.depositCollateral(_pclId, _collateralRequired, false);

        borrower.borrow(_pclId, _amountToBorrow.mul(90).div(100));

        vm.warp(block.timestamp + _warpTime);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.liquidate(_pclId, true) {
            revert('Borrower liquidating should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    function test_noLiquidationIfBorrowPriceDropsToZero(uint128 _amountToBorrow) public {
        _amountToBorrow = scaleToRange128(_amountToBorrow, uint128(request.minBorrowAmount), request.borrowLimit);
        uint128 _warpTime = uint128(request.duration + request.defaultGracePeriod + 1);
        assert_noLiquidationIfBorrowPriceDropsToZero(requestId, _amountToBorrow, _warpTime);
    }

    function assert_noLiquidationIfBorrowPriceDropsToZero(
        uint256 _pclId,
        uint256 _amountToBorrow,
        uint256 _warpTime
    ) internal {
        // adding 1 to ensure that any diff due to imprecision issues is covered
        uint256 _collateralRequired = pcl.getRequiredCollateral(_pclId, _amountToBorrow) + 1;

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        borrower.depositCollateral(_pclId, _collateralRequired, false);

        borrower.borrow(requestId, _amountToBorrow.mul(90).div(100));

        vm.warp(block.timestamp + _warpTime);

        vm.mockCall(
            priceOracleAddress,
            abi.encodeWithSelector(IPriceOracle.getLatestPrice.selector, address(collateralAsset), address(borrowAsset)),
            abi.encode(0, 0) // price, decimals
        );

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        try _lender.liquidate(_pclId, true) {
            revert('Borrower liquidating should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'SafeMath: division by zero');
        }
    }

    function test_noLiquidationIfBorrowerTries(uint128 _amountToBorrow) public {
        _amountToBorrow = scaleToRange128(_amountToBorrow, uint128(request.minBorrowAmount), request.borrowLimit);
        uint128 _warpTime = uint128(request.duration + request.defaultGracePeriod + 1);
        assert_noLiquidationIfBorrowerTries(requestId, _amountToBorrow, _warpTime);
    }

    function assert_noLiquidationIfBorrowerTries(
        uint256 _pclId,
        uint256 _amountToBorrow,
        uint256 _warpTime
    ) internal {
        // adding 1 to ensure that any diff due to imprecision issues is covered
        uint256 _collateralRequired = pcl.getRequiredCollateral(_pclId, _amountToBorrow) + 1;

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        borrower.depositCollateral(_pclId, _collateralRequired, false);

        borrower.borrow(requestId, _amountToBorrow.mul(90).div(100));

        vm.warp(block.timestamp + _warpTime);

        if (!isForked) {
            MockV3Aggregator(collateralAssetAggregatorAddress).updateAnswer(1);
        }

        try borrower.liquidate(_pclId, true) {
            revert('Borrower liquidating should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:LIQ1');
        }
    }

    function test_noLiquidateIfAdminTries(uint128 _amountToBorrow, uint128 _warpTime) public {
        _amountToBorrow = scaleToRange128(_amountToBorrow, 1, request.borrowLimit);
        _warpTime = scaleToRange128(_warpTime, 1, uint128(request.duration + request.defaultGracePeriod + request.duration));
        assert_noLiquidateIfAdminTries(requestId, _amountToBorrow, _warpTime);
    }

    function assert_noLiquidateIfAdminTries(
        uint256 _pclId,
        uint256 _amountToBorrow,
        uint256 _warpTime
    ) internal {
        // adding 1 to ensure that any diff due to imprecision issues is covered
        uint256 _collateralRequired = pcl.getRequiredCollateral(_pclId, _amountToBorrow) + 1;

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        borrower.depositCollateral(_pclId, _collateralRequired, false);

        borrower.borrow(requestId, _amountToBorrow);

        vm.warp(block.timestamp + _warpTime);

        if (!isForked) {
            MockV3Aggregator(collateralAssetAggregatorAddress).updateAnswer(1);
        }

        try admin.liquidate(_pclId, true) {
            revert('Borrower liquidating should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:LIQ1');
        }
    }

    function test_noLiquidateIfNotLenderButWasOnceTries(
        uint128 _amountToBorrow,
        uint128 _warpTime,
        uint128 _lenderIndex
    ) public {
        _amountToBorrow = scaleToRange128(_amountToBorrow, 1, request.borrowLimit);
        _warpTime = scaleToRange128(_warpTime, 0, uint128(request.duration + request.defaultGracePeriod + request.duration));
        // this pool has 10 lenders and 0th lender is the one who receives the tokens
        _lenderIndex = scaleToRange128(_lenderIndex, 1, 9);
        assert_noLiquidateIfNotLenderButWasOnceTries(requestId, _amountToBorrow, _warpTime, _lenderIndex);
    }

    function assert_noLiquidateIfNotLenderButWasOnceTries(
        uint256 _pclId,
        uint256 _amountToBorrow,
        uint256 _warpTime,
        uint256 _lenderIndex
    ) internal {
        // adding 1 to ensure that any diff due to imprecision issues is covered
        uint256 _collateralRequired = pcl.getRequiredCollateral(_pclId, _amountToBorrow) + 1;

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        borrower.depositCollateral(_pclId, _collateralRequired, false);

        borrower.borrow(requestId, _amountToBorrow);

        vm.warp(block.timestamp + _warpTime);
        if (!isForked) {
            MockV3Aggregator(collateralAssetAggregatorAddress).updateAnswer(1);
        }

        PCLUser _lender = PCLUser(lenders[_lenderIndex].lenderAddress);

        _lender.transferLPTokens(lenders[0].lenderAddress, _pclId, lenders[_lenderIndex].amount);

        try _lender.liquidate(_pclId, true) {
            revert('Borrower liquidating should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:LIQ1');
        }
    }

    function test_noLiquidateIfPrincipalZero(
        uint128 _amountToBorrow,
        uint128 _warpTime,
        uint128 _lenderIndex
    ) public {
        _amountToBorrow = scaleToRange128(_amountToBorrow, 1, request.borrowLimit);
        _warpTime = scaleToRange128(_warpTime, 0, uint128(request.duration + request.defaultGracePeriod + request.duration));
        _lenderIndex = scaleToRange128(_lenderIndex, 0, 9);
        assert_noLiquidateIfPrincipalZero(requestId, _amountToBorrow, _warpTime, _lenderIndex);
    }

    function assert_noLiquidateIfPrincipalZero(
        uint256 _pclId,
        uint256 _amountToBorrow,
        uint256 _warpTime,
        uint256 _lenderIndex
    ) internal {
        // adding 1 to ensure that any diff due to imprecision issues is covered
        uint256 _collateralRequired = pcl.getRequiredCollateral(_pclId, _amountToBorrow) + 1;

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        borrower.depositCollateral(_pclId, _collateralRequired, false);

        vm.warp(block.timestamp + _warpTime);

        if (!isForked) {
            MockV3Aggregator(collateralAssetAggregatorAddress).updateAnswer(1);
        }

        PCLUser _lender = PCLUser(lenders[_lenderIndex].lenderAddress);
        try _lender.liquidate(_pclId, true) {
            revert('Borrower liquidating should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L1');
        }
    }

    function test_noLiquidateIfPCLContractLiquidateMethodIsCalledByAdmin(uint128 _amountToBorrow, uint128 _warpTime) public {
        _amountToBorrow = scaleToRange128(_amountToBorrow, 1, request.borrowLimit);
        _warpTime = scaleToRange128(_warpTime, 0, uint128(request.duration + request.defaultGracePeriod + request.duration));
        assert_noLiquidateIfPCLContractLiquidateMethodIsCalledByAdmin(requestId, _amountToBorrow, _warpTime);
    }

    function assert_noLiquidateIfPCLContractLiquidateMethodIsCalledByAdmin(
        uint256 _pclId,
        uint256 _amountToBorrow,
        uint256 _warpTime
    ) internal {
        // adding 1 to ensure that any diff due to imprecision issues is covered
        uint256 _collateralRequired = pcl.getRequiredCollateral(_pclId, _amountToBorrow) + 1;

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        borrower.depositCollateral(_pclId, _collateralRequired, false);

        borrower.borrow(requestId, _amountToBorrow);

        vm.warp(block.timestamp + _warpTime);

        if (!isForked) {
            MockV3Aggregator(collateralAssetAggregatorAddress).updateAnswer(1);
        }

        try admin.noAccessLiquidate(_pclId) {
            revert('Borrower liquidating should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:OLP1');
        }
    }

    function test_noLiquidateIfPCLContractLiquidateMethodIsCalledByLender(
        uint128 _amountToBorrow,
        uint128 _warpTime,
        uint128 _lenderIndex
    ) public {
        _amountToBorrow = scaleToRange128(_amountToBorrow, 1, request.borrowLimit);
        _warpTime = scaleToRange128(_warpTime, 0, uint128(request.duration + request.defaultGracePeriod + request.duration));
        _lenderIndex = scaleToRange128(_lenderIndex, 0, 9);
        PCLUser _lender = PCLUser(lenders[_lenderIndex].lenderAddress);
        assert_noLiquidateIfPCLContractLiquidateMethodIsCalledByAnyUser(requestId, _amountToBorrow, _warpTime, _lender);
    }

    function test_noLiquidateIfPCLContractLiquidateMethodIsCalledByBorrower(uint128 _amountToBorrow, uint128 _warpTime) public {
        _amountToBorrow = scaleToRange128(_amountToBorrow, 1, request.borrowLimit);
        _warpTime = scaleToRange128(_warpTime, 0, uint128(request.duration + request.defaultGracePeriod + request.duration));

        assert_noLiquidateIfPCLContractLiquidateMethodIsCalledByAnyUser(requestId, _amountToBorrow, _warpTime, borrower);
    }

    function test_noLiquidateIfPCLContractLiquidateMethodIsCalledByOthers(uint128 _amountToBorrow, uint128 _warpTime) public {
        _amountToBorrow = scaleToRange128(_amountToBorrow, 1, request.borrowLimit);
        _warpTime = scaleToRange128(_warpTime, 0, uint128(request.duration + request.defaultGracePeriod + request.duration));

        PCLUser _randomUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        assert_noLiquidateIfPCLContractLiquidateMethodIsCalledByAnyUser(requestId, _amountToBorrow, _warpTime, _randomUser);
    }

    function assert_noLiquidateIfPCLContractLiquidateMethodIsCalledByAnyUser(
        uint256 _pclId,
        uint256 _amountToBorrow,
        uint256 _warpTime,
        PCLUser _user
    ) internal {
        // adding 1 to ensure that any diff due to imprecision issues is covered
        uint256 _collateralRequired = pcl.getRequiredCollateral(_pclId, _amountToBorrow) + 1;

        admin.transferToken(address(collateralAsset), address(borrower), _collateralRequired);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralRequired);
        borrower.depositCollateral(_pclId, _collateralRequired, false);

        borrower.borrow(requestId, _amountToBorrow);

        vm.warp(block.timestamp + _warpTime);

        if (!isForked) {
            MockV3Aggregator(collateralAssetAggregatorAddress).updateAnswer(1);
        }

        try _user.noAccessLiquidate(_pclId) {
            revert('Borrower liquidating should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:OLP1');
        }
    }

    function test_noLiquidateIfZeroCollateral(uint128 _amountToBorrow, uint128 _warpTime) public {
        _amountToBorrow = scaleToRange128(_amountToBorrow, uint128(request.minBorrowAmount), request.borrowLimit);
        _warpTime = scaleToRange128(_warpTime, 0, uint128(request.duration + request.defaultGracePeriod + request.duration));
        request.collateralRatio = 0;
        goToActiveStage(10, uint128(_amountToBorrow));
    }

    function assert_noLiquidateIfZeroCollateral(
        uint256 _pclId,
        uint256 _amountToBorrow,
        uint256 _warpTime
    ) internal {
        borrower.borrow(requestId, _amountToBorrow);

        vm.warp(block.timestamp + _warpTime);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        try _lender.liquidate(_pclId, true) {
            revert('Borrower liquidating should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:LIQ1');
        }
    }
}",4854
RealWorld_BA_101_PriceOracleTest.t_RealWord_20240827090547.log,101,PriceOracleTest.t,37091,5401,42492,78.0,0.293475,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

import 'forge-std/Test.sol';
import '../PriceOracle.sol';
import './Constants.sol';
import '../mocks/MockToken.sol';
import '../mocks/MockV3Aggregator.sol';
import './roles/Admin.sol';

contract PriceOracleTest is Test {
    PriceOracle priceOracle;
    bool isForked;
    IERC20 public collateralAsset;
    IERC20 public borrowAsset;
    address public collateralAssetAggregatorAddress;
    address public borrowAssetAggregatorAddress;
    address uniswapPoolAddress;
    uint32 uniswapPriceAveragingPeriod;

    function setCollateralAsset() public {
        if (isForked) {
            collateralAsset = ERC20(Constants.WBTC);
            collateralAssetAggregatorAddress = Constants.WBTC_priceFeedChainlink;
        } else {
            collateralAsset = new MockToken('CollateralAsset', 'MT1', 18, 1e40, address(this));
            collateralAssetAggregatorAddress = address(new MockV3Aggregator(18, 12876423400040030304304));
        }
    }

    function setBorrowAsset() public {
        if (isForked) {
            borrowAsset = ERC20(Constants.DAI);
            borrowAssetAggregatorAddress = Constants.DAI_priceFeedChainlink;
        } else {
            borrowAsset = new MockToken('BorrowAsset', 'MT2', 8, 1e40, address(this));
            borrowAssetAggregatorAddress = address(new MockV3Aggregator(8, 195040576));
        }
    }

    function setUp() public {
        uint256 _chainId = getChainID();
        if (_chainId == 1) {
            isForked = true;
        }
        priceOracle = new PriceOracle(1 days);
        uniswapPriceAveragingPeriod = 10;
        priceOracle.initialize(address(this), uniswapPriceAveragingPeriod);
        assertTrue(address(priceOracle) != address(0));
        setBorrowAsset();
        setCollateralAsset();
        uniswapPoolAddress = Constants.WBTC_DAI_priceFeedUniswap;
    }

    function test_fail_doesFeedExist_chainLink() public {
        assertFalse(priceOracle.doesFeedExist(address(borrowAsset), address(collateralAsset)));
        assertFalse(priceOracle.doesFeedExist(address(collateralAsset), address(borrowAsset)));
    }

    function test_doesFeedExist_chainLink() public {
        priceOracle.setChainlinkFeedAddress(address(collateralAsset), collateralAssetAggregatorAddress, 1 days);
        priceOracle.setChainlinkFeedAddress(address(borrowAsset), borrowAssetAggregatorAddress, 1 days);
        assertTrue(priceOracle.doesFeedExist(address(borrowAsset), address(collateralAsset)));
        assertTrue(priceOracle.doesFeedExist(address(collateralAsset), address(borrowAsset)));
    }

    function test_doesFeedExist_uniswap() public {
        priceOracle.setUniswapFeedAddress(address(borrowAsset), address(collateralAsset), uniswapPoolAddress);
        assertTrue(priceOracle.doesFeedExist(address(borrowAsset), address(collateralAsset)));
        assertTrue(priceOracle.doesFeedExist(address(collateralAsset), address(borrowAsset)));
    }

    function test_setUniswapFeedAddress() public {
        try priceOracle.setUniswapFeedAddress(address(borrowAsset), address(borrowAsset), address(0)) {
            revert('setUniswapFeedAddress should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:SUFA1');
        }
    }

    function test_setChainlinkFeedAddress_fail_1() public {
        try priceOracle.setChainlinkFeedAddress(address(0), collateralAssetAggregatorAddress, 1 days) {
            revert('setChainlinkFeedAddress should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:IGD1');
        }
    }

    function test_setChainlinkFeedAddress_fail_2() public {
        try priceOracle.setChainlinkFeedAddress(address(collateralAsset), collateralAssetAggregatorAddress, 2 days) {
            revert('setChainlinkFeedAddress should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:SCFA1');
        }
    }

    event UniswapPriceAveragingPeriodUpdated(uint32 uniswapPriceAveragingPeriod);

    function test_setUniswapPriceAveragingPeriod() public {
        vm.expectEmit(true, true, true, true);
        emit UniswapPriceAveragingPeriodUpdated(uniswapPriceAveragingPeriod + 100);
        priceOracle.setUniswapPriceAveragingPeriod(uniswapPriceAveragingPeriod + 100);
    }

    function test_fail_setUniswapPriceAveragingPeriod() public {
        try priceOracle.setUniswapPriceAveragingPeriod(0) {
            revert('setUniswapPriceAveragingPeriod should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:ISUPAP1');
        }
        try priceOracle.setUniswapPriceAveragingPeriod(uniswapPriceAveragingPeriod) {
            revert('setUniswapPriceAveragingPeriod should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:ISUPAP2');
        }
    }

    function test_getLatestPrice_chainLink() public {
        priceOracle.setChainlinkFeedAddress(address(collateralAsset), collateralAssetAggregatorAddress, 1 days);
        priceOracle.setChainlinkFeedAddress(address(borrowAsset), borrowAssetAggregatorAddress, 1 days);

        (uint256 _price, uint256 _decimals) = priceOracle.getLatestPrice(address(borrowAsset), address(collateralAsset));
        assertTrue(_decimals == 18);
        assertTrue(_price > 0);
    }

    function test_getLatestPrice_uniswap() public {
        if (isForked) {
            priceOracle.setUniswapFeedAddress(address(borrowAsset), address(collateralAsset), uniswapPoolAddress);
            (uint256 _price, uint256 _decimals) = priceOracle.getLatestPrice(address(borrowAsset), address(collateralAsset));
            assertTrue(_decimals == 18);
            assertTrue(_price > 0);
        }
    }

    function test_getLatestPrice_uniswap_2() public {
        (uint256 _price, uint256 _decimals) = priceOracle.getUniswapLatestPrice(address(borrowAsset), address(collateralAsset));
        assertTrue(_price == 0);
        assertTrue(_decimals == 0);
    }

    function test_fail_getLatestPrice_1() public {
        priceOracle.setUniswapFeedAddress(address(borrowAsset), address(collateralAsset), address(0));
        try priceOracle.getLatestPrice(address(borrowAsset), address(collateralAsset)) {
            revert('getLatestPrice should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    function test_fail_getLatestPrice_2() public {
        priceOracle.setChainlinkFeedAddress(address(collateralAsset), collateralAssetAggregatorAddress, 1 days);
        priceOracle.setChainlinkFeedAddress(address(borrowAsset), borrowAssetAggregatorAddress, 1 days);

        vm.mockCall(
            address(borrowAssetAggregatorAddress),
            abi.encodeWithSelector(AggregatorV3Interface.latestRoundData.selector),
            abi.encode(1, 0, block.timestamp, block.timestamp, 2)
        );

        try priceOracle.getLatestPrice(address(borrowAsset), address(collateralAsset)) {
            revert('getLatestPrice should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    function test_fail_getLatestPrice_3() public {
        priceOracle.setChainlinkFeedAddress(address(collateralAsset), collateralAssetAggregatorAddress, 1 days);
        priceOracle.setChainlinkFeedAddress(address(borrowAsset), borrowAssetAggregatorAddress, 1 days);

        vm.mockCall(
            address(borrowAssetAggregatorAddress),
            abi.encodeWithSelector(AggregatorV3Interface.latestRoundData.selector),
            abi.encode(4, 10, block.timestamp, block.timestamp, 1)
        );

        try priceOracle.getLatestPrice(address(borrowAsset), address(collateralAsset)) {
            revert('getLatestPrice should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    function test_fail_getLatestPrice_4() public {
        priceOracle.setChainlinkFeedAddress(address(collateralAsset), collateralAssetAggregatorAddress, 1 days);
        priceOracle.setChainlinkFeedAddress(address(borrowAsset), borrowAssetAggregatorAddress, 1 days);

        vm.mockCall(
            address(collateralAssetAggregatorAddress),
            abi.encodeWithSelector(AggregatorV3Interface.latestRoundData.selector),
            abi.encode(1, 0, block.timestamp, block.timestamp, 2)
        );

        try priceOracle.getLatestPrice(address(borrowAsset), address(collateralAsset)) {
            revert('getLatestPrice should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    function test_fail_getLatestPrice_5() public {
        priceOracle.setChainlinkFeedAddress(address(collateralAsset), collateralAssetAggregatorAddress, 1 days);
        priceOracle.setChainlinkFeedAddress(address(borrowAsset), borrowAssetAggregatorAddress, 1 days);

        vm.mockCall(
            address(collateralAssetAggregatorAddress),
            abi.encodeWithSelector(AggregatorV3Interface.latestRoundData.selector),
            abi.encode(4, 10, block.timestamp, block.timestamp, 2)
        );

        try priceOracle.getLatestPrice(address(borrowAsset), address(collateralAsset)) {
            revert('getLatestPrice should fail');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    function getChainID() internal pure returns (uint256) {
        uint256 id;
        assembly {
            id := chainid()
        }
        return id;
    }
}",2169
RealWorld_BA_101_FluxAggregator_RealWord_20240827085227.log,101,FluxAggregator,6286,4363,10649,71.0,0.11869,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

contract FluxAggregator {
    uint256 public version = 3;
    uint8 public decimals;
    string public description;

    int256 public value = 1;
    uint80 latestRoundId = 5;

    function setValue(int256 newVal) public {
        value = newVal;
    }

    function getRoundData(uint80)
        external
        view
        returns (
            uint80,
            int256,
            uint256,
            uint256,
            uint80
        )
    {
        return (0, value, 0, 0, 0);
    }

    function latestRoundData()
        external
        view
        returns (
            uint80 roundId,
            int256 answer,
            uint256 startedAt,
            uint256 updatedAt,
            uint80 answeredInRound
        )
    {
        return (0, value, 0, 0, 0);
    }
}",202
RealWorld_BA_101_PCLClosedStage.t_RealWord_20240827094102.log,101,PCLClosedStage.t,14342,5595,19937,76.0,0.18361,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '../PCLClosedStage.t.sol';

contract PCLClosedStageCollateralCompoundBorrowCompound is PCLClosedStage {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    function setUp() public override {
        PCLParent.setUp();

        request.borrowLimit = uint128(1_000_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * 1e18) / 1e2);
        request.collateralRatio = 1e18;
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * 1e18) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = compoundYieldAddress;
        request.collateralAssetStrategy = compoundYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        // The below function will create the PCL request and then lenders lend the entire requested amount
        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        // Now we assert that we are in the ACTIVE state
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), 2);

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);
        borrower.depositCollateral(requestId, _requiredCollateral, false);

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);
        // And borrows the borrowable amount
        borrower.borrow(requestId, borrowableAmount);

        // Borrower decides to repay everything at mid-duration

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 2);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay the entire debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt);
        borrower.repay(requestId, currentDebt);

        // Now the PCL should be in the CLOSED state
        borrower.close(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }
}",682
RealWorld_BA_101_PriceOracle_RealWord_20240827084601.log,101,PriceOracle,43636,5597,49233,97.0,0.33012,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

import '@chainlink/contracts/src/v0.7/interfaces/AggregatorV3Interface.sol';
import '@uniswap/v3-periphery/contracts/libraries/OracleLibrary.sol';
import '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';
import '@openzeppelin/contracts/token/ERC20/ERC20.sol';

import './interfaces/IPriceOracle.sol';

contract PriceOracle is Initializable, OwnableUpgradeable, IPriceOracle {
    using SafeMath for uint256;

    //-------------------------------- Constants start --------------------------------/

    uint256 constant SCALING_EXPONENT = 18;
    uint256 constant SCALING_FACTOR = 10**(SCALING_EXPONENT);

    uint128 public immutable MAX_CHAINLINK_HEARTBEAT;

    //-------------------------------- Constants end --------------------------------/

    //-------------------------------- Global vars start --------------------------------/

    /**
     * @notice Struct that stores the chainlink price oracle and decimals related to the token
     * @param oracle address of price oracle of token against USD
     * @param decimals no of decimals for the price from oracle
     * @param heartbeat the time delta after which the price from the feed is discarded
     **/
    struct PriceData {
        address oracle;
        uint8 decimals;
        uint128 heartbeat;
    }
    /**
     * @notice stores the price oracle and its decimals for chainlink feeds
     **/
    mapping(address => PriceData) public chainlinkFeedAddresses;

    // stores the decimals for the token against the address
    mapping(address => uint256) decimals;

    /**
     * @notice stores the addresses of price feeds for uniswap token pairs
     **/
    mapping(bytes32 => address) public uniswapPools;

    // price averaging period for uniswap
    uint32 uniswapPriceAveragingPeriod;

    //-------------------------------- Global vars end --------------------------------/

    //-------------------------------- Init start --------------------------------/

    /**
     * @notice Used to initialize param during deployment
     * @dev invoked on deployment
     * @param _maxChainlinkHeartbeat max interval between within which chainlink oracle data is updated
     **/
    constructor(uint128 _maxChainlinkHeartbeat) {
        MAX_CHAINLINK_HEARTBEAT = _maxChainlinkHeartbeat;
    }

    /**
     * @notice Used to initialize the price oracle contract
     * @dev can only be invoked once
     * @param _admin owner of the price oracle
     * @param _uniswapPriceAveragingPeriod period for uniswap price averaging
     **/
    function initialize(address _admin, uint32 _uniswapPriceAveragingPeriod) external initializer {
        OwnableUpgradeable.__Ownable_init();
        OwnableUpgradeable.transferOwnership(_admin);
        _setUniswapPriceAveragingPeriod(_uniswapPriceAveragingPeriod);
    }

    //-------------------------------- Init end --------------------------------/

    //-------------------------------- price start --------------------------------/
    /**
     * @notice Used to get price of the num vs den token from chainlink
     * @param num the address of the token for which price in queried
     * @param den the address of the token in which price is queried
     * @return price of the num in terms of den
     * @return no of decimals for the price
     **/
    function getChainlinkLatestPrice(address num, address den) public view returns (uint256, uint256) {
        PriceData memory _feedData1 = chainlinkFeedAddresses[num];
        PriceData memory _feedData2 = chainlinkFeedAddresses[den];

        if (_feedData1.oracle == address(0) || _feedData2.oracle == address(0)) return (0, 0);

        int256 price1;
        int256 price2;
        {
            uint80 roundID1;
            uint256 timeStamp1;
            uint80 answeredInRound1;
            (roundID1, price1, , timeStamp1, answeredInRound1) = AggregatorV3Interface(_feedData1.oracle).latestRoundData();
            if ((price1 == 0) || block.timestamp > timeStamp1 + _feedData1.heartbeat || answeredInRound1 < roundID1) return (0, 0);
        }
        {
            uint80 roundID2;
            uint256 timeStamp2;
            uint80 answeredInRound2;
            (roundID2, price2, , timeStamp2, answeredInRound2) = AggregatorV3Interface(_feedData2.oracle).latestRoundData();
            if ((price2 == 0) || block.timestamp > timeStamp2 + _feedData2.heartbeat || answeredInRound2 < roundID2) return (0, 0);
        }
        uint256 price = uint256(price1)
            .mul(10**_feedData2.decimals)
            .mul(SCALING_FACTOR)
            .div(uint256(price2))
            .div(10**_feedData1.decimals)
            .mul(10**decimals[den])
            .div(10**decimals[num]);
        return (price, SCALING_EXPONENT);
    }

    /**
     * @notice Used to get price of the num vs den token from uniswap
     * @param num the address of the token for which price in queried
     * @param den the address of the token in which price is queried
     * @return price of the num in terms of wei for num and denom tokens
     * @return no of decimals for the price
     **/
    function getUniswapLatestPrice(address num, address den) public view returns (uint256, uint256) {
        bytes32 _poolTokensId = getUniswapPoolTokenId(num, den);
        address _pool = uniswapPools[_poolTokensId];
        if (_pool == address(0)) return (0, 0);

        (int24 _twapTick, ) = OracleLibrary.consult(_pool, uniswapPriceAveragingPeriod);
        uint256 _price = OracleLibrary.getQuoteAtTick(_twapTick, uint128(SCALING_FACTOR), num, den);
        return (_price, SCALING_EXPONENT);
    }

    /**
     * @notice Used to get price of the num vs den token
     * @param num the address of the token for which price in queried
     * @param den the address of the token in which price is queried
     * @return price of the num in terms of den
     * @return no of decimals for the price
     **/
    function getLatestPrice(address num, address den) external view override returns (uint256, uint256) {
        uint256 _price;
        uint256 _decimals;
        (_price, _decimals) = getChainlinkLatestPrice(num, den);
        if (_price != 0) return (_price, _decimals);

        (_price, _decimals) = getUniswapLatestPrice(num, den);
        if (_price != 0) return (_price, _decimals);
        revert('PO:GLP1');
    }

    //-------------------------------- price end --------------------------------/

    //-------------------------------- Global var setters start --------------------------------/

    /**
     * @notice Used to set the price feed address for a token in chainlink
     * @dev only owner can set
     * @param _token address of token for which price feed is added
     * @param _priceFeed address of the price feed for the token
     * @param _heartbeat the time delta after which the price from the feed is discarded
     **/
    function setChainlinkFeedAddress(
        address _token,
        address _priceFeed,
        uint128 _heartbeat
    ) external onlyOwner {
        require(_heartbeat <= MAX_CHAINLINK_HEARTBEAT, 'PO:SCFA1');
        uint8 priceOracleDecimals = AggregatorV3Interface(_priceFeed).decimals();
        chainlinkFeedAddresses[_token] = PriceData(_priceFeed, priceOracleDecimals, _heartbeat);
        decimals[_token] = getDecimals(_token);
        emit ChainlinkFeedUpdated(_token, _priceFeed, _heartbeat);
    }

    /**
     * @notice Used to set the price feed address for a token pair in uniswap
     * @dev only owner can set
     * @param token1 address of one of the tokens for which price feed is added
     * @param token2 address of other token for which price feed is added
     * @param pool addrewss of the price feed for the token pair
     **/
    function setUniswapFeedAddress(
        address token1,
        address token2,
        address pool
    ) external onlyOwner {
        require(token1 != token2, 'PO:SUFA1');
        bytes32 _poolTokensId = getUniswapPoolTokenId(token1, token2);
        uniswapPools[_poolTokensId] = pool;
        emit UniswapFeedUpdated(token1, token2, _poolTokensId, pool);
    }

    /**
     * @notice Used to set the period in which uniswap price is averaged
     * @dev only owner can set. This is used to prevent attacks to control price feed
     * @param _uniswapPriceAveragingPeriod period for uniswap price averaging
     **/
    function setUniswapPriceAveragingPeriod(uint32 _uniswapPriceAveragingPeriod) external onlyOwner {
        _setUniswapPriceAveragingPeriod(_uniswapPriceAveragingPeriod);
    }

    function _setUniswapPriceAveragingPeriod(uint32 _uniswapPriceAveragingPeriod) private {
        require(_uniswapPriceAveragingPeriod != 0, 'PO:ISUPAP1');
        require(_uniswapPriceAveragingPeriod != uniswapPriceAveragingPeriod, 'PO:ISUPAP2');
        uniswapPriceAveragingPeriod = _uniswapPriceAveragingPeriod;
        emit UniswapPriceAveragingPeriodUpdated(_uniswapPriceAveragingPeriod);
    }

    //-------------------------------- Global var setters end --------------------------------/

    //-------------------------------- Utils start --------------------------------/

    /**
     * @notice Used to get decimals for a token
     * @param _token address of the token
     * @return number of decimals for the token
     **/
    function getDecimals(address _token) private view returns (uint8) {
        require(AddressUpgradeable.isContract(_token), 'PO:IGD1');

        try ERC20(_token).decimals() returns (uint8 v) {
            return v;
        } catch Error(string memory) {
            return 0;
        } catch (bytes memory) {
            return 0;
        }
    }

    // gets the token id for a pair of tokens irrespective of the order
    function getUniswapPoolTokenId(address num, address den) private pure returns (bytes32) {
        require(num != address(0) && den != address(0), 'PO:IGUPT1');

        if (uint256(num) < uint256(den)) {
            return keccak256(abi.encodePacked(num, den));
        } else {
            return keccak256(abi.encodePacked(den, num));
        }
    }

    /**
     * @notice used to check if price feed exists between 2 tokens
     * @param token1 one of the token for which price feed is to be checked
     * @param token2 other token for which price feed is to be checked
     * @return if price feed exists for the token pair
     **/
    function doesFeedExist(address token1, address token2) external view override returns (bool) {
        if (chainlinkFeedAddresses[token1].oracle != address(0) && chainlinkFeedAddresses[token2].oracle != address(0)) {
            return true;
        }

        bytes32 _poolTokensId = getUniswapPoolTokenId(token1, token2);

        if (uniswapPools[_poolTokensId] != address(0)) return true;

        return false;
    }

    //-------------------------------- Utils end --------------------------------/
}",2556
RealWorld_BA_101_PCLRequestedStage.t_RealWord_20240827092905.log,101,PCLRequestedStage.t,0,0,0,,0.0,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../mocks/MockToken.sol';
import '../Helpers/PCLParent.t.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../Roles/MaliciousLender.sol';

contract PCLRequestedStage is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;

    uint256 requestId;
    uint256 _fromUserPoolTokenSupplyOld;
    uint256 _toUserPoolTokenSupplyOld;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;

    function setUp() public virtual override {
        super.setUp();

        request.borrowLimit = uint128(1_000_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * 1e18) / 1e2);
        request.collateralRatio = 1e18;
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * 1e18) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.REQUESTED);
    }

    function test_cannotStartAfterEndsAt() public {
        createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount), request.borrowAsset);
        vm.warp(block.timestamp + request.collectionPeriod + request.duration);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        try _lender.start(requestId) {
            revert('Cannot start PCL once it has ended');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S3');
        }
    }

    /**************************************************************************************************************************************
    Deposit collateral function tests
    **************************************************************************************************************************************/

    function assert_collateralCannotBeDepositedInRequestedState(
        uint256 _id,
        uint256 _amountToBorrow,
        PCLUser _depositor,
        bool _isDepositorLender
    ) public {
        // Since the PCL is in the REQUESTED state, let us start some lending
        createMultipleLenders(_id, 5, request.borrowLimit / 2, request.borrowAsset);

        uint256 _collateralRequired = pcl.getRequiredCollateral(_id, _amountToBorrow);

        if (_isDepositorLender) {
            _depositor = PCLUser(lenders[0].lenderAddress);
        }

        admin.transferToken(address(collateralAsset), address(_depositor), _collateralRequired);
        _depositor.setAllowance(address(pcl), address(collateralAsset), _collateralRequired);

        try _depositor.depositCollateral(_id, _collateralRequired, false) {
            revert('Collateral cannot be deposited in the REQUESTED state');
        } catch Error(string memory reason) {
            if (request.collateralRatio == 0) {
                assertEq(reason, 'PCL:DC1');
            } else {
                assertEq(reason, 'PCL:DC2');
            }
        }
    }

    function test_borrowerCannotDepositCollateral() public {
        uint256 _amountToBorrow = 100_000 * 1e18;
        assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, borrower, true);
    }

    function test_lenderCannotDepositCollateral() public {
        uint256 _amountToBorrow = 100_000 * 1e18;
        assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, PCLUser(address(0)), true);
    }

    function test_adminCannotDepositCollateral() public {
        uint256 _amountToBorrow = 100_000 * 1e18;
        assert_collateralCannotBeDepositedInRequestedState(requestId, _amountToBorrow, admin, false);
    }

    /**************************************************************************************************************************************
    Start/proceed to Active state function tests
    **************************************************************************************************************************************/

    function assert_start_functionality_in_requested_state(
        uint256 _id,
        uint256 _numOfLenders,
        uint128 _lendAmount,
        uint256 _travelDuration,
        PooledCreditLineStatus _stateToAssert,
        PCLUser _starter,
        bool _positiveCase,
        string memory _revertStatement,
        string memory _errorMessage
    ) public {
        // complex test - code can be simplified

        createMultipleLenders(_id, _numOfLenders, _lendAmount, request.borrowAsset);

        vm.warp(block.timestamp + _travelDuration);

        if (_lendAmount >= request.borrowLimit) {
            borrower.start(_id);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert);

        if (!_positiveCase) {
            try _starter.start(_id) {
                revert(_revertStatement);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        } else {
            _starter.start(_id);
        }
    }

    // Test 3.1
    function test_cannotStartAlreadyActivePCL() public {
        assert_start_functionality_in_requested_state(
            requestId,
            4,
            request.borrowLimit + 10,
            request.collectionPeriod,
            PooledCreditLineStatus.ACTIVE,
            borrower,
            false,
            'PCL cannot be started again',
            'LP:S1'
        );
    }

    // Test 3.2
    function test_cannotStartPCLInCollectionPeriod() public {
        assert_start_functionality_in_requested_state(
            requestId,
            2,
            request.borrowLimit - 1,
            0,
            PooledCreditLineStatus.REQUESTED,
            admin,
            false,
            'PCL cannot be started in collection period',
            'LP:S2'
        );
    }

    // Test 3.3
    function test_cannotProceedIntoActiveStateWithoutMinBorrowAmount() public {
        assert_start_functionality_in_requested_state(
            requestId,
            5,
            uint128(request.minBorrowAmount - 1),
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            borrower,
            false,
            'PCL cannot be started for an amount less than minBorrowAmount',
            'LP:S4'
        );
    }

    // Test 3.4
    function test_startPCLPositiveCase() public {
        assert_start_functionality_in_requested_state(
            requestId,
            5,
            uint128(request.minBorrowAmount + 1),
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            borrower,
            true,
            '',
            ''
        );
    }

    function test_lenderCannotStart() public {
        createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);

        vm.warp(block.timestamp + request.collectionPeriod);

        PCLUser lender = PCLUser(lenders[0].lenderAddress);

        try lender.start(requestId) {
            revert(""Lender shouldn't be able to start PCL"");
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:A2');
        }
    }

    function test_adminCannotStart() public {
        createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);

        vm.warp(block.timestamp + request.collectionPeriod);

        PCLUser admin = PCLUser(admin);

        try admin.start(requestId) {
            revert(""Admin shouldn't be able to start PCL"");
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:A2');
        }
    }

    function test_randomUserCannotStart() public {
        createMultipleLenders(requestId, 2, request.borrowLimit - 1, request.borrowAsset);

        vm.warp(block.timestamp + request.collectionPeriod);

        PCLUser randomUser = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);

        try randomUser.start(requestId) {
            revert(""Random user shouldn't be able to start PCL"");
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:A2');
        }
    }

    /**************************************************************************************************************************************
    Cancel function tests
    **************************************************************************************************************************************/

    function assert_cancel_functionality_in_requested_state(
        uint256 _id,
        uint256 _noOfLenders,
        uint128 _amountToLend,
        uint256 _travelDuration,
        PooledCreditLineStatus _stateToAssert_1,
        bool _isLender,
        PCLUser _user,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage,
        PooledCreditLineStatus _stateToAssert_2
    ) public {
        // complex test - code can be simplified

        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);

        vm.warp(block.timestamp + _travelDuration);

        if (_amountToLend >= request.borrowLimit) {
            borrower.start(_id);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_1);

        if (_isLender) {
            _user = PCLUser(lenders[0].lenderAddress);
        }

        if (!_positiveCase) {
            try _user.cancelRequest(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        } else {
            _user.cancelRequest(_id);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2);
    }

    // Test 4.1
    function test_borrowerCannotCancelActivePCL() public {
        assert_cancel_functionality_in_requested_state(
            requestId,
            4,
            request.borrowLimit + 10,
            request.collectionPeriod,
            PooledCreditLineStatus.ACTIVE,
            false,
            borrower,
            false,
            'PCL can be cancelled only in the REQUESTED state',
            'PCL:CR1',
            PooledCreditLineStatus.ACTIVE
        );
    }

    // Test 4.2
    function test_borrowerCannotCancelPostCollectionPeriod() public {
        assert_cancel_functionality_in_requested_state(
            requestId,
            6,
            uint128(request.minBorrowAmount - 1),
            (request.collectionPeriod + 2 days),
            PooledCreditLineStatus.REQUESTED,
            false,
            borrower,
            false,
            'PCL can be cancelled only in the REQUESTED state',
            'PCL:CR2',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 4.3
    function test_lenderCannotCancelPCL() public {
        assert_cancel_functionality_in_requested_state(
            requestId,
            5,
            uint128(request.borrowLimit - 100),
            (request.collectionPeriod / 2),
            PooledCreditLineStatus.REQUESTED,
            true,
            PCLUser(address(0)),
            false,
            'Only borrower can cancel PCL',
            'PCL:OCLB1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 4.4
    function test_adminCannotCancelPCL() public {
        assert_cancel_functionality_in_requested_state(
            requestId,
            5,
            uint128(request.borrowLimit - 100),
            (request.collectionPeriod / 2),
            PooledCreditLineStatus.REQUESTED,
            false,
            admin,
            false,
            'Only borrower can cancel PCL',
            'PCL:OCLB1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 4.5
    function test_cancelPCLPositiveCase() public {
        assert_cancel_functionality_in_requested_state(
            requestId,
            5,
            uint128(request.borrowLimit - 100),
            (request.collectionPeriod / 2),
            PooledCreditLineStatus.REQUESTED,
            false,
            borrower,
            true,
            '',
            '',
            PooledCreditLineStatus.CANCELLED
        );
    }

    /**************************************************************************************************************************************
    Liquidity Withdrawal function tests
    **************************************************************************************************************************************/

    function assert_withdraw_liquidity_functionality_in_request_state(
        uint256 _id,
        bool _isLender,
        PCLUser _user,
        PooledCreditLineStatus _stateToAssert_1,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage,
        PooledCreditLineStatus _stateToAssert_2
    ) public {
        // complex test - code can be simplified
        createMultipleLenders(_id, 6, uint128(request.minBorrowAmount - 1), request.borrowAsset);

        if (_isLender) {
            _user = PCLUser(lenders[0].lenderAddress);
        }

        uint256 _userPoolTokenBalance = lp.balanceOf(address(_user), _id);

        vm.warp(block.timestamp + (request.collectionPeriod + 2 days));

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_1);

        if (!_positiveCase) {
            try admin.withdrawLiquidity(requestId) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        } else {
            // the pcl will get cancelled because of low collection
            _user.withdrawLiquidity(_id);
            uint256 _userBorrowTokenBalance = IERC20(request.borrowAsset).balanceOf(address(_user));
            assertEq(_userPoolTokenBalance, _userBorrowTokenBalance);

            _userPoolTokenBalance = lp.balanceOf(address(_user), _id);
            assertEq(_userPoolTokenBalance, 0);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2);
    }

    // Test 5.1
    function test_lenderWithdrawsLiquidityInRequestedStatePositiveCase() public {
        assert_withdraw_liquidity_functionality_in_request_state(
            requestId,
            true,
            PCLUser(lenders[0].lenderAddress),
            PooledCreditLineStatus.REQUESTED,
            true,
            '',
            '',
            PooledCreditLineStatus.CANCELLED
        );
    }

    // Test 5.2
    function test_adminCannotWithdrawLiquidityInRequestedState() public {
        assert_withdraw_liquidity_functionality_in_request_state(
            requestId,
            false,
            admin,
            PooledCreditLineStatus.REQUESTED,
            false,
            'Admin withdrew liquidity',
            'LP:IWL1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    /**************************************************************************************************************************************
    Close function tests
    **************************************************************************************************************************************/

    function assert_close_functionality_in_requested_state(
        uint256 _id,
        uint256 _noOfLenders,
        uint128 _amountToLend,
        bool _isLender,
        PCLUser _user,
        uint256 _travelDuration,
        PooledCreditLineStatus _stateToAssert_1,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage,
        PooledCreditLineStatus _stateToAssert_2
    ) public {
        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);

        vm.warp(block.timestamp + _travelDuration);

        if (_positiveCase) {
            _user.start(_id);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert_1);

        if (_isLender) {
            _user = PCLUser(lenders[0].lenderAddress);
        }

        if (_positiveCase) {
            _user.close(_id);
        } else {
            try _user.close(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2);
    }

    // Test 6.1
    function test_borrowerCannotCloseRequestedPCL() public {
        assert_close_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 1),
            false,
            borrower,
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            false,
            'PCL cannot be closed in the ACTIVE state',
            'PCL:C1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 6.2
    function test_borrowerCanCloseActivePCLPositiveCase() public {
        assert_close_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.borrowLimit + 1),
            false,
            borrower,
            (request.collectionPeriod),
            PooledCreditLineStatus.ACTIVE,
            true,
            '',
            '',
            PooledCreditLineStatus.CLOSED
        );
    }

    // Test 6.3
    function test_lenderCannotClosePCL() public {
        assert_close_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 100),
            true,
            PCLUser(address(0)),
            0,
            PooledCreditLineStatus.REQUESTED,
            false,
            'PCL cannot be closed by a lender',
            'PCL:OCLB1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 6.4
    function test_adminCannotClosePCL() public {
        assert_close_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 100),
            false,
            admin,
            0,
            PooledCreditLineStatus.REQUESTED,
            false,
            'PCL cannot be closed by admin',
            'PCL:OCLB1',
            PooledCreditLineStatus.REQUESTED
        );
    }

    /**************************************************************************************************************************************
    Liquidate function tests
    **************************************************************************************************************************************/

    function assert_liquidate_functionality_in_requested_state(
        uint256 _id,
        uint256 _noOfLenders,
        uint128 _amountToLend,
        uint256 _travelDuration,
        bool _isLender,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);

        vm.warp(block.timestamp + _travelDuration);

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);

        if (_isLender) {
            _user = PCLUser(lenders[0].lenderAddress);
        }

        try _user.liquidate(_id, true) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    // Test 7.1: Call Liquidate function in REQUESTED state
    function test_callLiquidateInRequestedState() public {
        assert_liquidate_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 100),
            request.collectionPeriod,
            true,
            PCLUser(address(0)),
            'Borrower cannot be liquidated without borrowing first',
            'PCL:L1'
        );
    }

    // Test 7.2: Borrower calls liquidate function in the REQUESTED state
    function test_borrowerCallsLiquidateInRequestedState() public {
        assert_liquidate_functionality_in_requested_state(
            requestId,
            3,
            uint128(request.minBorrowAmount - 100),
            request.collectionPeriod,
            false,
            borrower,
            'Borrower cannot liquidate a PCL',
            'LP:LIQ1'
        );
    }

    // Test 7.3: Admin calls liquidate function in the REQUESTED state
    function test_adminCallsLiquidateInRequestedState() public {
        assert_liquidate_functionality_in_requested_state(
            requestId,
            3,
            uint128(request.minBorrowAmount - 100),
            request.collectionPeriod,
            false,
            admin,
            'Admin cannot liquidate a PCL',
            'LP:LIQ1'
        );
    }

    function test_callLiquidateAfterTransferringPoolTokens() public {
        // Lend any amount lower than the minBorrowAmount, so that PCL does not go into active state
        createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);

        // Warping past the collection period
        vm.warp(block.timestamp + request.collectionPeriod);

        // Check whether the PCL went into the ACTIVE state
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.REQUESTED);

        // Picking out two lenders from the list of 4 lenders
        PCLUser lender_0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender_1 = PCLUser(lenders[1].lenderAddress);

        uint256 lender_0_pool_token_balance = lp.balanceOf(address(lender_0), requestId);

        log_named_uint('Lender_0 Pool MockToken Balance-1', lender_0_pool_token_balance);

        // lender_0 tries to transfer their pool tokens to lender_1
        lender_0.transferLPTokens(address(lender_1), requestId, lender_0_pool_token_balance);

        // Lender_0 calls the liquidate function
        try lender_0.liquidate(requestId, false) {
            revert('Lender with 0 pool tokens cannot liquidate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:LIQ1');
        }
    }

    /**************************************************************************************************************************************
    Repay function tests
    **************************************************************************************************************************************/

    function assertRepayFunctionalityInRequestedState(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.repay(_id, 1) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);
    }

    function test_adminCannotRepay() public {
        assertRepayFunctionalityInRequestedState(requestId, admin, 'Admin cannot repay a requested PCL', 'PCL:REP2');
    }

    function test_borrowerCannotRepay() public {
        assertRepayFunctionalityInRequestedState(requestId, borrower, 'Borrower cannot repay a requested PCL', 'PCL:REP2');
    }

    function test_lenderCannotRepay() public {
        createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);
        assertRepayFunctionalityInRequestedState(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot repay a requested PCL',
            'PCL:REP2'
        );
    }

    /*************************************************************************************************************************************
    Borrow function tests
    *************************************************************************************************************************************/

    function assertBorrowFunctionalityInRequestedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.borrow(_id, _amount) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);
    }

    function test_adminCannotBorrow() public {
        assertBorrowFunctionalityInRequestedState(requestId, 1, admin, 'Admin cannot borrow a PCL in requested state', 'PCL:OCLB1');
    }

    function test_borrowerCannotBorrowAfterStartTimestamp() public {
        vm.warp(block.timestamp + request.collectionPeriod);
        assertBorrowFunctionalityInRequestedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in requested state', 'PCL:IB3');
    }

    function test_borrowerCannotBorrow() public {
        assertBorrowFunctionalityInRequestedState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in requested state', 'PCL:IB2');
    }

    function test_borrowerCannotBorrowZeroAmount() public {
        assertBorrowFunctionalityInRequestedState(requestId, 0, borrower, 'Borrower cannot borrow a PCL in requested state', 'PCL:IB1');
    }

    function test_lenderCannotBorrow() public {
        createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);
        assertBorrowFunctionalityInRequestedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot borrow a PCL in requested state',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    Withdraw collateral function tests
    *************************************************************************************************************************************/

    function assertWithdrawCollateralFunctionalityInRequestedState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage,
        string memory _errorMessageAll
    ) public {
        try _user.withdrawAllCollateral(_id, false) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessageAll);
        }

        try _user.withdrawCollateral(_id, _amount, false) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
    }

    function test_adminCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInRequestedState(
            requestId,
            1,
            admin,
            'Admin cannot withdraw collateral in requested state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInRequestedState(
            requestId,
            1,
            borrower,
            'Borrower cannot withdraw collateral in requested state',
            'PCL:WC1',
            'PCL:WAC1'
        );
    }

    function test_borrowerCannotWithdrawZeroCollateral() public {
        assertWithdrawCollateralFunctionalityInRequestedState(
            requestId,
            0,
            borrower,
            'Borrower cannot withdraw collateral in requested state',
            'PCL:WC2',
            'PCL:WAC1'
        );
    }

    function test_lenderCannotWithdrawCollateral() public {
        createMultipleLenders(requestId, 4, uint128(request.minBorrowAmount - 100), request.borrowAsset);
        assertWithdrawCollateralFunctionalityInRequestedState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot withdraw collateral in requested state',
            'PCL:OCLB1',
            'PCL:OCLB1'
        );
    }

    /**************************************************************************************************************************************
    Terminate function tests
    **************************************************************************************************************************************/

    function assert_terminate_functionality_in_requested_state(
        uint256 _id,
        uint256 _noOfLenders,
        uint128 _amountToLend,
        uint256 _travelDuration,
        PooledCreditLineStatus _stateToAssert_1,
        bool _isLender,
        PCLUser _user,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage,
        PooledCreditLineStatus _stateToAssert_2
    ) public {
        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);

        vm.warp(block.timestamp + _travelDuration);

        assertTrue(pcl.getStatusAndUpdate(requestId) == _stateToAssert_1);

        if (_isLender) {
            _user = PCLUser(lenders[0].lenderAddress);
        }

        if (_positiveCase) {
            _user.terminate(_id);
            // PooledCreditLine.PooledCreditLineConstants memory _params = pcl.getpooledCreditLineConstant(requestId);
            // assertEq(_params.borrowAsset, address(0));
        } else {
            try _user.terminate(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }

        assertTrue(pcl.getStatusAndUpdate(_id) == _stateToAssert_2);
    }

    // Test 8.1: Admin can terminate the PCL in requested state
    function test_terminationInRequestedState() public {
        assert_terminate_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 1),
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            false,
            admin,
            true,
            '',
            '',
            PooledCreditLineStatus.NOT_CREATED // Final state. Since everything gets deleted.
        );
    }

    // Test 8.2: Lender cannot terminate the PCL in REQUESTED state
    function test_terminationInRequestedStateByLender() public {
        assert_terminate_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 1),
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            true,
            PCLUser(address(0)),
            false,
            'Lender cannot terminate PCLs',
            'Ownable: caller is not the owner',
            PooledCreditLineStatus.REQUESTED
        );
    }

    // Test 8.3: Borrower cannot terminate the PCL in REQUESTED state
    function test_terminationInRequestedStateByBorrower() public {
        assert_terminate_functionality_in_requested_state(
            requestId,
            4,
            uint128(request.minBorrowAmount - 1),
            request.collectionPeriod,
            PooledCreditLineStatus.REQUESTED,
            false,
            borrower,
            false,
            'Borrower cannot terminate PCLs',
            'Ownable: caller is not the owner',
            PooledCreditLineStatus.REQUESTED
        );
    }

    /**************************************************************************************************************************************
    View/Calculation function tests
    **************************************************************************************************************************************/

    uint256 _currentCR;
    uint256 _collateralTokensToLiquidate;

    function assert_helper_functionalities_in_request_state(
        uint256 _id,
        uint256 _noOfLenders,
        uint128 _amountToLend,
        uint256 _travelDuration
    ) public {
        createMultipleLenders(_id, _noOfLenders, _amountToLend, request.borrowAsset);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;
        vm.warp(block.timestamp + _travelDuration);

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);

        // 1. calculatePrincipalWithdrawable
        uint256 _userLiquidity = lp.balanceOf(address(_lender), _id);
        emit log_named_uint('_userLiquidity: ', _userLiquidity);
        uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
        if (_amountToLend < request.minBorrowAmount) {
            assertEq(_principalWithdrawable, _userLiquidity);
        } else {
            assertEq(_principalWithdrawable, 0);
        }

        // 2. withdrawableCollateral
        uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertEq(_withdrawableCollateral, 0);

        // 3. calculateTotalCollateralTokens
        uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertEq(_totalCollateral, 0);

        // 4. calculateBorrowableAmount
        uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_totalBorrowable, 0);

        {
            // 5. calculateInterestAccrued
            assertEq(_borrower.calculateInterestAccrued(_id), 0);
        }

        {
            // 6. calculateCurrentDebt
            assertEq(_borrower.calculateCurrentDebt(_id), 0);
        }

        // 7. calculateCurrentCollateralRatio
        _currentCR = _borrower.calculateCurrentCollateralRatio(_id);
        assertEq(_currentCR, uint256(-1));

        // 8. collateralTokensToLiquidate
        _collateralTokensToLiquidate = _borrower.collateralTokensToLiquidate(_id, 0);
        assertEq(_collateralTokensToLiquidate, 0);
    }

    function test_helperFunctionsInRequestedState(uint128 _amountToLend) public {
        _amountToLend = scaleToRange128(_amountToLend, 1, uint128(request.borrowLimit - 1));

        assert_helper_functionalities_in_request_state(requestId, 6, _amountToLend, request.collectionPeriod + 2 days);
    }

    /**************************************************************************************************************************************
    Pool MockToken Transfer tests
    **************************************************************************************************************************************/

    function assert_pool_transfers_in_requested_state(
        uint256 _id,
        PCLUser _fromUser,
        PCLUser _toUser,
        bool _positiveCase,
        uint256 _fractionOfPTSupply,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        uint256 _fromUserPoolTokenSupply;
        uint256 _toUserPoolTokenSupply;
        uint256 _fromUserPoolTokenSupplyNew;
        uint256 _toUserPoolTokenSupplyNew;

        createMultipleLenders(_id, 4, uint128(request.minBorrowAmount + 10), request.borrowAsset);

        vm.warp(block.timestamp + request.collectionPeriod + 2 days);

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);

        if (address(_fromUser) == address(0)) {
            _fromUser = PCLUser(lenders[0].lenderAddress);
        }
        if (address(_toUser) == address(0)) {
            _toUser = PCLUser(lenders[1].lenderAddress);
        }

        _fromUserPoolTokenSupplyOld = lp.balanceOf(address(_fromUser), _id);
        _toUserPoolTokenSupplyOld = lp.balanceOf(address(_toUser), _id);

        if (_positiveCase) {
            _fromUser.transferLPTokens(address(_toUser), _id, (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply));

            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);
            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);

            assertEq(_fromUserPoolTokenSupplyNew, (_fromUserPoolTokenSupplyOld - (_fromUserPoolTokenSupplyOld / _fractionOfPTSupply)));
            assertEq(_toUserPoolTokenSupplyNew, ((_fromUserPoolTokenSupplyOld / _fractionOfPTSupply) + _toUserPoolTokenSupplyOld));
        } else {
            try _fromUser.transferLPTokens(address(_toUser), _id, _fromUserPoolTokenSupplyOld) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }

            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);
            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);

            assertEq(_fromUserPoolTokenSupplyOld, _fromUserPoolTokenSupplyNew);
            assertEq((_toUserPoolTokenSupplyNew - _toUserPoolTokenSupplyOld), 0);
        }
    }

    // Test 10.1:
    function test_poolTokenTransferToNonVerifiedUsersNotPossible() public {
        assert_pool_transfers_in_requested_state(
            requestId,
            PCLUser(address(0)),
            admin,
            false,
            1,
            'Admin should not be able to recieve pool tokens',
            'LP:IT3'
        );
    }

    // Test 10.2:
    function test_poolTokenTransferInRequestedStatePossible() public {
        assert_pool_transfers_in_requested_state(requestId, PCLUser(address(0)), PCLUser(address(0)), true, 1, '', '');
    }

    // Test 10.3:
    function test_partialPoolTokenTransferPossible() public {
        assert_pool_transfers_in_requested_state(requestId, PCLUser(address(0)), PCLUser(address(0)), true, 2, '', '');
    }

    function test_pooledCreditLine_onERC1155ReceivedHook() public {
        PCLUser _pooledCreditLineLender = new MaliciousLender(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(request.borrowAsset), address(_pooledCreditLineLender), request.borrowLimit);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(request.borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, request.borrowLimit) {
            revert('REVERT: should have reverted');
        } catch Error(string memory reason) {
            assertEq(reason, 'ReentrancyGuard: reentrant call');
        }
    }

    event PooledCreditLineCancelled(uint256 indexed id, CancellationStatus indexed reason);
    event WithdrawLiquidityOnCancel(uint256 indexed id, address indexed user, uint256 amount);

    function test_withdrawLiquidityAfterPclHasEnded() public {
        createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount), request.borrowAsset);
        vm.warp(block.timestamp + request.collectionPeriod + request.duration);

        // make sure pcl cannot be started
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        vm.expectRevert(bytes('LP:S3'));
        _lender.start(requestId);

        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);
        assertGe(_lenderLpBalance, 0);

        assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), _lenderLpBalance);

        vm.expectEmit(true, true, false, true);
        emit PooledCreditLineCancelled(requestId, CancellationStatus.LENDER_NOT_STARTED_AT_END);
        vm.expectEmit(true, true, true, true);
        emit WithdrawLiquidityOnCancel(requestId, address(_lender), _lenderLpBalance);
        // liquidate
        _lender.withdrawLiquidity(requestId);
    }

    function test_withdrawLiquidityOnLowCollection() public {
        // lend less than minBorrowAmount
        createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount) - 100, request.borrowAsset);
        // go to start time
        vm.warp(block.timestamp + request.collectionPeriod);

        // make sure pcl cannot be started
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        vm.expectRevert(bytes('LP:S4'));
        _lender.start(requestId);

        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);
        assertGe(_lenderLpBalance, 0);
        assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), _lenderLpBalance);

        vm.expectEmit(true, true, false, true);
        emit PooledCreditLineCancelled(requestId, CancellationStatus.LENDER_LOW_COLLECTION);
        vm.expectEmit(true, true, true, true);
        emit WithdrawLiquidityOnCancel(requestId, address(_lender), _lenderLpBalance);
        // liquidate
        _lender.withdrawLiquidity(requestId);
    }

    function test_withdrawLiquidityReverted() public {
        createMultipleLenders(requestId, 5, request.borrowLimit, request.borrowAsset);
        vm.warp(block.timestamp + request.collectionPeriod);

        // make sure pcl has not been started
        assertTrue(uint256(pcl.getStatusAndUpdate(requestId)) == 1);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _lenderLpBalance = lp.balanceOf(address(_lender), requestId);
        assertGe(_lenderLpBalance, 0);
        assertEq(lp.calculatePrincipalWithdrawable(requestId, address(_lender)), 0);

        vm.expectRevert(bytes('LP:IWL3'));
        _lender.withdrawLiquidity(requestId);
    }

    function test_externalUserCannotCreate() public {
        try
            lp.create(
                requestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_externalUserCannotTerminate() public {
        try lp.terminate(requestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_cannotLendZeroAmount() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }

    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }

    function test_cannotLendAfterCollectionPeriod() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        vm.warp(block.timestamp + request.collectionPeriod);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Lender cannot lend after collection period');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    function test_cannotLendIfBorrowLimitReached() public {
        createMultipleLenders(requestId, 5, request.borrowLimit, request.borrowAsset);

        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Lender cannot lend if borrow limit is reached');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L4');
        }
    }

    function test_lenderCannotWithdrawInterest() public {
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.withdrawInterest(requestId) {
            revert('Lender cannot withdraw interest');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WI1');
        }
    }

    function test_nonLenderCannotWithdrawLiquidationTokens() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {
            revert('Non lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WLC1');
        }
    }

    function test_lenderCannotWithdrawLiquidationTokens() public {
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.withdrawTokensAfterLiquidation(requestId) {
            revert('Lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    function test_cannotTransferLPTokensToSameAddress() public {
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to itself');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT1');
        }
    }

    function test_cannotTransferLPTokensToBorrower() public {
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(borrower), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to borrower');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT2');
        }
    }

    function test_cannotBurnPoolTokens() public {
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(0), requestId, _balanceLender) {
            revert('Lender cannot burn LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'ERC1155: transfer to the zero address');
        }
    }

    function test_cannotTransferNonTransferableLPTokens() public {
        request.areTokensTransferable = false;
        uint256 _requestId = borrower.createRequest(request);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.REQUESTED);

        createMultipleLenders(_requestId, 5, request.borrowLimit - 100, request.borrowAsset);

        PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lenderFrom), _requestId);
        PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);

        try _lenderFrom.transferLPTokens(address(_lenderTo), _requestId, _balanceLender) {
            revert('Lender cannot transfer non transferable LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT5');
        }
    }
}",10686
RealWorld_BA_101_MockCToken_RealWord_20240827090030.log,101,MockCToken,13867,5890,19757,78.0,0.187135,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

import '@openzeppelin/contracts/token/ERC20/ERC20.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import '../interfaces/Invest/ICToken.sol';

interface IERC20Minter is IERC20 {
    function mint(address to, uint256 amount) external;
}

// @dev This contract should be able to mint underlying tokens to work
contract MockCToken is ERC20, ICToken {
    address public override underlying;

    uint256 exchangeRateStored;
    uint256 lastExchangeRateAt;

    constructor(address _underlying) ERC20('CToken', 'CT') {
        underlying = _underlying;
        exchangeRateStored = 1e18;
        lastExchangeRateAt = block.timestamp;
    }

    function mint(uint256 mintAmount) external override returns (uint256) {
        uint256 _shares = (mintAmount * 1e18) / _exchangeRateCurrent();
        IERC20(underlying).transferFrom(msg.sender, address(this), mintAmount);
        _mint(msg.sender, _shares);
        return 0;
    }

    function redeem(uint256 redeemTokens) external override returns (uint256) {
        uint256 _amount = (redeemTokens * _exchangeRateCurrent()) / 1e18;
        _burn(msg.sender, redeemTokens);
        uint256 _balance = IERC20(underlying).balanceOf(msg.sender);
        if (_amount > _balance) {
            IERC20Minter(underlying).mint(address(this), _amount - _balance);
        }
        IERC20(underlying).transfer(msg.sender, _amount);
        return 0;
    }

    function balanceOfUnderlying(address account) external override returns (uint256) {
        return (balanceOf(account) * _exchangeRateCurrent()) / 1e18;
    }

    function exchangeRateCurrent() external override returns (uint256) {
        return _exchangeRateCurrent();
    }

    function _exchangeRateCurrent() internal returns (uint256) {
        uint256 _currentExchangeRate = (exchangeRateStored * (1e18 + ((block.timestamp - lastExchangeRateAt) * 1e8))) / 1e18;
        exchangeRateStored = _currentExchangeRate;
        lastExchangeRateAt = block.timestamp;
        return _currentExchangeRate;
    }

    function getCash() external override returns (uint256) {
        return (90 * totalSupply()) / 100;
    }

    function comptroller() external view override returns (address) {
        return address(0);
    }

    function borrow(uint256 borrowAmount) external override returns (uint256) {
        return 0;
    }

    function repayBorrow(uint256 repayAmount) external override returns (uint256) {
        return 0;
    }

    function mockExchangeRateStored(uint256 _mockedExchangeRate) external returns (uint256) {
        exchangeRateStored = _mockedExchangeRate;
        lastExchangeRateAt = block.timestamp;
        return 0;
    }
}",652
RealWorld_BA_101_PCLCancelledStage.t_RealWord_20240827092251.log,101,PCLCancelledStage.t,120959,5478,126437,96.0,0.714355,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../mocks/MockToken.sol';
import '../Helpers/PCLParent.t.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';

contract PCLCancelledStage is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;

    uint256 requestId;
    address lender_0;

    function setUp() public virtual override {
        super.setUp();

        request.borrowLimit = uint128(1_000_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * 1e18) / 1e2);
        request.collateralRatio = 1e18;
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * 1e18) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.REQUESTED);

        // Lend any amount lesser than the borrowLimit
        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);

        // Let's travel a few days, but stay within the collection period
        vm.warp(block.timestamp + request.collectionPeriod / 2);

        // Borrower tries to cancel the PCL
        borrower.cancelRequest(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CANCELLED);
    }

    /*************************************************************************************************************************************
    Start function calls
    *************************************************************************************************************************************/

    function assert_start_functionality_in_cancelled_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.start(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CANCELLED);
    }

    function test_adminCannotStartACancelledPCL() public {
        assert_start_functionality_in_cancelled_state(requestId, admin, 'Admin cannot start a PCL in cancelled state', 'LP:S1');
    }

    function test_borrowerCannotStartACancelledPCL() public {
        assert_start_functionality_in_cancelled_state(requestId, borrower, 'Borrower cannot start a PCL in cancelled state', 'LP:S1');
    }

    function test_lenderCannotStartACancelledPCL() public {
        assert_start_functionality_in_cancelled_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot start a PCL in cancelled state',
            'LP:S1'
        );
    }

    /**************************************************************************************************************************************
    Cancel function tests
    **************************************************************************************************************************************/

    function assert_cancel_functionality_in_cancelled_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.cancelRequest(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CANCELLED);
    }

    function test_adminCannotCancelACancelledPCL() public {
        assert_cancel_functionality_in_cancelled_state(requestId, admin, 'Admin cannot Cancel a PCL in cancelled state', 'PCL:OCLB1');
    }

    // The Borrower is trying to cancel a cancelled PCL, but cannot because address(borrower) is now address(0).
    // And therefore, he gets the OCLB1 error.
    // Discuss.
    function test_borrowerCannotCancelACancelledPCL() public {
        assert_cancel_functionality_in_cancelled_state(requestId, borrower, 'Borrower cannot Cancel a PCL in cancelled state', 'PCL:OCLB1');
    }

    // The Lender is trying to cancel a cancelled PCL, but cannot because address(lenders[0].lenderAddress) is now address(0).
    // And therefore, he gets the OCLB1 error.
    // Discuss.
    function test_lenderCannotCancelACancelledPCL() public {
        assert_cancel_functionality_in_cancelled_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot Cancel a PCL in cancelled state',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    Close function calls
    *************************************************************************************************************************************/

    function assert_close_functionality_in_cancelled_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.close(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CANCELLED);
    }

    function test_adminCannotCloseACancelledPCL() public {
        assert_close_functionality_in_cancelled_state(requestId, admin, 'Admin cannot close a cancelled PCL', 'PCL:OCLB1');
    }

    // The Borrower is trying to close a cancelled PCL, but cannot because address(borrower) is now address(0).
    // And therefore, he gets the OCLB1 error.
    // Discuss.
    function test_borrowerCannotCloseACancelledPCL() public {
        assert_close_functionality_in_cancelled_state(requestId, borrower, 'Borrower cannot close a cancelled PCL', 'PCL:OCLB1');
    }

    // The Lender is trying to close a cancelled PCL, but cannot because address(lenders[0].lenderAddress) is now address(0).
    // And therefore, he gets the OCLB1 error.
    // Discuss.
    function test_lenderCannotCloseACancelledPCL() public {
        assert_close_functionality_in_cancelled_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot close a cancelled PCL',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    WithdrawLiquidity function calls
    **************************************************************************************************************************************/

    function assert_withdraw_liquidity_functionality_in_cancelled_state(
        uint256 _id,
        PCLUser _user,
        bool _positiveCase,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_positiveCase) {
            uint256 _poolTokenBalanceOld = lp.balanceOf(address(_user), _id);
            uint256 _borrowTokenBalanceOld = IERC20(request.borrowAsset).balanceOf(address(_user));
            _user.withdrawLiquidity(_id);
            uint256 _poolTokenBalanceNew = lp.balanceOf(address(_user), _id);
            uint256 _borrowTokenBalanceNew = IERC20(request.borrowAsset).balanceOf(address(_user));

            assertEq(_poolTokenBalanceOld, (_borrowTokenBalanceNew - _borrowTokenBalanceOld));
            assertEq(_poolTokenBalanceNew, 0);
        } else {
            try _user.withdrawLiquidity(_id) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CANCELLED);
    }

    function test_adminCannotWithdrawLiquidity() public {
        assert_withdraw_liquidity_functionality_in_cancelled_state(
            requestId,
            admin,
            false,
            'Admin cannot WithdrawLiquidity a PCL in cancelled state',
            'LP:IWL1'
        );
    }

    function test_borrowerCannotWithdrawLiquidity() public {
        assert_withdraw_liquidity_functionality_in_cancelled_state(
            requestId,
            borrower,
            false,
            'Borrower cannot WithdrawLiquidity a PCL in cancelled state',
            'LP:IWL1'
        );
    }

    function test_lenderCanWithdrawLiquidity() public {
        assert_withdraw_liquidity_functionality_in_cancelled_state(requestId, PCLUser(lenders[0].lenderAddress), true, '', '');
    }

    /**************************************************************************************************************************************
    Liquidate function tests
    **************************************************************************************************************************************/

    function assert_liquidate_functionality_in_cancelled_state(
        uint256 _id,
        bool _isLender,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        if (_isLender) {
            _user = PCLUser(lenders[0].lenderAddress);
        }

        try _user.liquidate(_id, true) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CANCELLED);
    }

    function test_adminCannotLiquidateACancelledPCL() public {
        assert_liquidate_functionality_in_cancelled_state(requestId, false, admin, 'Admin cannot liquidate a cancelled PCL', 'LP:LIQ1');
    }

    function test_borrowerCannotLiquidateACancelledPCL() public {
        assert_liquidate_functionality_in_cancelled_state(
            requestId,
            false,
            borrower,
            'Borrower cannot liquidate a cancelled PCL',
            'LP:LIQ1'
        );
    }

    function test_lenderCannotLiquidateACancelledPCL() public {
        assert_liquidate_functionality_in_cancelled_state(
            requestId,
            true,
            PCLUser(address(0)),
            'Lender cannot liquidate a cancelled PCL',
            'PCL:L1'
        );
    }

    /**************************************************************************************************************************************
    Repay function tests
    **************************************************************************************************************************************/

    function assertRepayFunctionalityInCancelledState(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.repay(_id, 1) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CANCELLED);
    }

    function test_adminCannotRepayACancelledPCL() public {
        assertRepayFunctionalityInCancelledState(requestId, admin, 'Admin cannot repay a cancelled PCL', 'PCL:REP2');
    }

    function test_borrowerCannotRepayACancelledPCL() public {
        assertRepayFunctionalityInCancelledState(requestId, borrower, 'Borrower cannot repay a cancelled PCL', 'PCL:REP2');
    }

    function test_lenderCannotRepayACancelledPCL() public {
        assertRepayFunctionalityInCancelledState(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot repay a cancelled PCL',
            'PCL:REP2'
        );
    }

    /**************************************************************************************************************************************
    Terminate function tests
    **************************************************************************************************************************************/

    function assert_terminate_functionality_in_cancelled_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.terminate(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CANCELLED);
    }

    function test_adminCannotTerminateACancelledPCL() public {
        assert_terminate_functionality_in_cancelled_state(requestId, admin, 'Cannot terminate a cancelled PCL', 'PCL:CTCT1');
    }

    function test_borrowerCannotTerminateACancelledPCL() public {
        assert_terminate_functionality_in_cancelled_state(
            requestId,
            borrower,
            'Cannot terminate a cancelled PCL',
            'Ownable: caller is not the owner'
        );
    }

    function test_lenderCannotTerminateACancelledPCL() public {
        assert_terminate_functionality_in_cancelled_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Cannot terminate a cancelled PCL',
            'Ownable: caller is not the owner'
        );
    }

    /**************************************************************************************************************************************
    Deposit collateral function tests
    **************************************************************************************************************************************/

    function assert_collateralCannotBeDepositedInCancelledState(
        uint256 _id,
        uint256 _amount,
        PCLUser _depositor,
        bool _isDepositorLender
    ) public {
        if (_isDepositorLender) {
            _depositor = PCLUser(lenders[0].lenderAddress);
        }

        admin.transferToken(address(collateralAsset), address(_depositor), _amount);
        _depositor.setAllowance(address(pcl), address(collateralAsset), _amount);

        try _depositor.depositCollateral(_id, _amount, false) {
            revert('Collateral cannot be deposited in the CANCELLED state');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:DC2');
        }
    }

    function test_borrowerCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInCancelledState(requestId, _amountToDeposit, borrower, true);
    }

    function test_lenderCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInCancelledState(requestId, _amountToDeposit, PCLUser(address(0)), true);
    }

    function test_adminCannotDepositCollateral() public {
        uint256 _amountToDeposit = 100_000 * ERC20(address(collateralAsset)).decimals();
        assert_collateralCannotBeDepositedInCancelledState(requestId, _amountToDeposit, admin, false);
    }

    /*************************************************************************************************************************************
    Borrow function tests
    *************************************************************************************************************************************/

    function assertBorrowFunctionalityInCancelledState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.borrow(_id, _amount) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CANCELLED);
    }

    function test_adminCannotBorrow() public {
        assertBorrowFunctionalityInCancelledState(requestId, 1, admin, 'Admin cannot borrow a PCL in cancelled state', 'PCL:OCLB1');
    }

    function test_borrowerCannotBorrow() public {
        assertBorrowFunctionalityInCancelledState(requestId, 1, borrower, 'Borrower cannot borrow a PCL in cancelled state', 'PCL:OCLB1');
    }

    function test_lenderCannotBorrow() public {
        assertBorrowFunctionalityInCancelledState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot borrow a PCL in cancelled state',
            'PCL:OCLB1'
        );
    }

    /*************************************************************************************************************************************
    Withdraw collateral function tests
    *************************************************************************************************************************************/

    function assertWithdrawCollateralFunctionalityInCancelledState(
        uint256 _id,
        uint256 _amount,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        try _user.withdrawAllCollateral(_id, false) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        try _user.withdrawCollateral(_id, _amount, false) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CANCELLED);
    }

    function test_adminCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInCancelledState(
            requestId,
            1,
            admin,
            'Admin cannot withdraw collateral in cancelled state',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInCancelledState(
            requestId,
            1,
            borrower,
            'Borrower cannot withdraw collateral in cancelled state',
            'PCL:OCLB1'
        );
    }

    function test_borrowerCannotWithdrawZeroCollateral() public {
        assertWithdrawCollateralFunctionalityInCancelledState(
            requestId,
            0,
            borrower,
            'Borrower cannot withdraw collateral in cancelled state',
            'PCL:OCLB1'
        );
    }

    function test_lenderCannotWithdrawCollateral() public {
        assertWithdrawCollateralFunctionalityInCancelledState(
            requestId,
            1,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot withdraw collateral in cancelled state',
            'PCL:OCLB1'
        );
    }

    /**************************************************************************************************************************************
    View/calculation function tests
    **************************************************************************************************************************************/

    function assert_helper_functionalities_in_cancelled_state(
        uint256 _id,
        PCLUser,
        PCLUser _borrower
    ) public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CANCELLED);

        // 1. calculatePrincipalWithdrawable
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _userLiquidity = lp.balanceOf(address(_lender), _id);
        uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
        assertEq(_userLiquidity, _principalWithdrawable);

        // 2. withdrawableCollateral
        uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertEq(_withdrawableCollateral, 0);

        // 3. calculateTotalCollateralTokens (testFail passes for this. This call breaks. Discuss.)
        try _borrower.calculateTotalCollateralTokens(_id) {
            revert('This call should not be working in CANCELLED state');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CTCT1');
        }

        // 4. calculateBorrowableAmount
        uint256 _totalBorrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_totalBorrowable, 0);

        // 5. calculateInterestAccrued
        uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertEq(_interestAccrued, 0);

        // 6. calculateCurrentDebt
        uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);
        assertEq(_currentDebt, 0);

        // Test Number 7 and 8 should ideally have been returning a revert string, but right now they return PO:IGUPT1
        // and that is because since all pclConstants are deleted, address(tokens) == address(0) which throws

        // 7. calculateCurrentCollateralRatio
        try _borrower.calculateCurrentCollateralRatio(_id) {
            revert('This call should not be working in CANCELLED state');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:IGUPT1');
        }

        // 8. collateralTokensToLiquidate
        try _borrower.collateralTokensToLiquidate(_id, 0) {
            revert('This call should not be working in CANCELLED state');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CTTL1');
        }

        // 9. calculateTotalCollateralTokens
        try _borrower.calculateTotalCollateralTokens(_id) {
            revert('This call should not be working in CANCELLED state');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CTCT1');
        }
    }

    function test_helperFunctionInCancelledState() public {
        assert_helper_functionalities_in_cancelled_state(requestId, PCLUser(lenders[0].lenderAddress), borrower);
    }

    /*************************************************************************************************************************************
    WithdrawInterest function calls
    **************************************************************************************************************************************/

    function assert_withdraw_interest_functionality_in_cancelled_state(
        uint256 _id,
        PCLUser _user,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.CANCELLED);

        uint256 _poolTokenBalanceOld = lp.balanceOf(address(_user), _id);
        uint256 _borrowTokenBalanceOld = borrowAsset.balanceOf(address(_user));

        try _user.withdrawInterest(_id) {
            revert(_revertMessage);
        } catch Error(string memory reason) {
            assertEq(reason, _errorMessage);
        }

        uint256 _poolTokenBalanceNew = lp.balanceOf(address(_user), _id);
        uint256 _borrowTokenBalanceNew = borrowAsset.balanceOf(address(_user));

        assertEq(_poolTokenBalanceOld, _poolTokenBalanceNew);
        assertEq(_borrowTokenBalanceNew, _borrowTokenBalanceOld);

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.CANCELLED);
    }

    function test_adminCannotWithdrawInterestFromACancelledPCL() public {
        assert_withdraw_interest_functionality_in_cancelled_state(
            requestId,
            admin,
            'Should not have been able to withdraw interest',
            'LP:WI1'
        );
    }

    function test_borrowerCannotWithdrawInterestFromACancelledPCL() public {
        assert_withdraw_interest_functionality_in_cancelled_state(
            requestId,
            borrower,
            'Should not have been able to withdraw interest',
            'LP:WI1'
        );
    }

    function test_lenderCannotWithdrawInterestFromACancelledPCL() public {
        assert_withdraw_interest_functionality_in_cancelled_state(
            requestId,
            PCLUser(lenders[0].lenderAddress),
            'Should not have been able to withdraw interest',
            'LP:WI1'
        );
    }

    /**************************************************************************************************************************************
    Pool MockToken Transfer function tests
    **************************************************************************************************************************************/

    uint256 _fromUserPoolTokenSupply;
    uint256 _toUserPoolTokenSupply;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;
    uint256 _toInterestOwed;
    uint256 _fromInterestOwed;
    uint256 _fromBorrowTokenBalanceInitial;
    uint256 _toBorrowTokenBalanceInitial;

    function assert_pool_token_transfer_in_cancelled_stage(
        uint256 _id,
        uint256 _stateToAssert_1,
        PCLUser _fromUser,
        PCLUser _toUser,
        bool _positiveCase,
        uint256 _fractionOfPTSupply,
        string memory _revertMessage,
        string memory _errorMessage
    ) public {
        assertEq(uint256(pcl.getStatusAndUpdate(_id)), _stateToAssert_1);
        _fromUserPoolTokenSupply = lp.balanceOf(address(_fromUser), _id);
        _toUserPoolTokenSupply = lp.balanceOf(address(_toUser), _id);

        if (_positiveCase) {
            _fromInterestOwed = lp.getLenderInterestWithdrawable(_id, address(_fromUser));
            _toInterestOwed = lp.getLenderInterestWithdrawable(_id, address(_toUser));

            _fromBorrowTokenBalanceInitial = borrowAsset.balanceOf(address(_fromUser));
            _toBorrowTokenBalanceInitial = borrowAsset.balanceOf(address(_toUser));

            log_named_uint('From User Pool MockToken Supply', _fromUserPoolTokenSupply);
            log_named_uint('To User Pool MockToken Supply', _toUserPoolTokenSupply);
            log_named_uint('Amount to transfer', (_fromUserPoolTokenSupply / _fractionOfPTSupply));

            _fromUser.transferLPTokens(address(_toUser), _id, (_fromUserPoolTokenSupply / _fractionOfPTSupply));

            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);
            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);

            assertEq(_fromUserPoolTokenSupplyNew, (_fromUserPoolTokenSupply - (_fromUserPoolTokenSupply / _fractionOfPTSupply)));
            assertEq(_toUserPoolTokenSupplyNew, ((_fromUserPoolTokenSupply / _fractionOfPTSupply) + _toUserPoolTokenSupply));

            assertEq((borrowAsset.balanceOf(address(_toUser)) - _toBorrowTokenBalanceInitial), _toInterestOwed);
            assertEq((borrowAsset.balanceOf(address(_fromUser)) - _fromBorrowTokenBalanceInitial), _fromInterestOwed);
        } else {
            try _fromUser.transferLPTokens(address(_toUser), _id, _fromUserPoolTokenSupply) {
                revert(_revertMessage);
            } catch Error(string memory reason) {
                assertEq(reason, _errorMessage);
            }

            _fromUserPoolTokenSupplyNew = lp.balanceOf(address(_fromUser), _id);
            _toUserPoolTokenSupplyNew = lp.balanceOf(address(_toUser), _id);

            assertEq(_fromUserPoolTokenSupply, _fromUserPoolTokenSupplyNew);
            assertEq((_toUserPoolTokenSupplyNew - _toUserPoolTokenSupply), 0);
        }
    }

    function test_externalUserCannotCreate() public {
        try
            lp.create(
                requestId,
                mockAdminVerifier1,
                address(borrowAsset),
                noYieldAddress,
                request.borrowLimit,
                request.minBorrowAmount,
                request.collectionPeriod,
                true
            )
        {
            revert('External user cannot create');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_externalUserCannotTerminate() public {
        try lp.terminate(requestId, address(admin)) {
            revert('External user cannot terminate');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:OPCL1');
        }
    }

    function test_cannotLendZeroAmount() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, 0) {
            revert('Lender cannot lend zero amount');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L1');
        }
    }

    function test_unverifiedLenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Unverified lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L2');
        }
    }

    function test_lenderCannotLend() public {
        uint256 _amountToLend = 100;
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        admin.transferToken(address(borrowAsset), address(_pooledCreditLineLender), _amountToLend);
        _pooledCreditLineLender.setAllowance(lenderPoolAddress, address(borrowAsset), type(uint256).max);

        try _pooledCreditLineLender.lend(requestId, _amountToLend) {
            revert('Lender cannot lend');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:L3');
        }
    }

    function test_nonLenderCannotWithdrawLiquidationTokens() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier1);

        try _pooledCreditLineLender.withdrawTokensAfterLiquidation(requestId) {
            revert('Non lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WLC1');
        }
    }

    function test_lenderCannotWithdrawLiquidationTokens() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        try _lender.withdrawTokensAfterLiquidation(requestId) {
            revert('Lender cannot withdraw liquidated collateral tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    function test_cannotTransferLPTokensToSameAddress() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(_lender), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to itself');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT1');
        }
    }

    function test_cannotTransferLPTokensToNonVerifiedUser() public {
        PCLUser _pooledCreditLineLender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
        _pooledCreditLineLender.registerSelf(mockAdminVerifier2);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(_pooledCreditLineLender), requestId, _balanceLender) {
            revert('Lender cannot transfer LP tokens to borrower');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT3');
        }
    }

    function test_cannotBurnPoolTokens() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lender), requestId);

        try _lender.transferLPTokens(address(0), requestId, _balanceLender) {
            revert('Lender cannot burn LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'ERC1155: transfer to the zero address');
        }
    }

    function test_cannotTransferNonTransferableLPTokens() public {
        request.areTokensTransferable = false;
        uint256 _requestId = borrower.createRequest(request);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.REQUESTED);

        createMultipleLenders(_requestId, 5, request.borrowLimit - 100, request.borrowAsset);

        PCLUser _lenderFrom = PCLUser(lenders[0].lenderAddress);
        uint256 _balanceLender = lp.balanceOf(address(_lenderFrom), _requestId);
        PCLUser _lenderTo = PCLUser(lenders[1].lenderAddress);

        try _lenderFrom.transferLPTokens(address(_lenderTo), _requestId, _balanceLender) {
            revert('Lender cannot transfer non transferable LP tokens');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IT5');
        }
    }

    function test_poolTokenTransferComplete() public {
        assert_pool_token_transfer_in_cancelled_stage(
            requestId,
            6,
            PCLUser(lenders[0].lenderAddress),
            PCLUser(lenders[1].lenderAddress),
            true,
            1,
            '',
            ''
        );
    }

    function test_poolTokenTransferPartial() public {
        assert_pool_token_transfer_in_cancelled_stage(
            requestId,
            6,
            PCLUser(lenders[0].lenderAddress),
            PCLUser(lenders[1].lenderAddress),
            true,
            4,
            '',
            ''
        );
    }

    function test_poolTokenTransferToNonVerifiedUser() public {
        assert_pool_token_transfer_in_cancelled_stage(
            requestId,
            6,
            PCLUser(lenders[0].lenderAddress),
            admin,
            false,
            4,
            'Non-verified user should not be able to receive pool tokens',
            'LP:IT3'
        );
    }
}",7378
RealWorld_BA_101_PCLRequestedState.t_RealWord_20240827091544.log,101,PCLRequestedState.t,97012,5964,102976,112.0,0.60434,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';

import '../Helpers/PCLParent.t.sol';

contract PCLRequestedStateCToken is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 _borrowAssetDecimals;
    uint256 _collateralAssetDecimals;
    uint128 _collateralAssetPriceMin;
    uint128 _borrowAssetPriceMin;
    uint128 _collateralAssetPriceMax;
    uint128 _borrowAssetPriceMax;
    uint256 requestId;
    uint256 _fromUserPoolTokenSupply;
    uint256 _toUserPoolTokenSupply;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;
    uint256 _calculatedCurrentDebt;
    uint256 _fetchedCurrentDebt;

    function setUp() public override {
        super.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();
        _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));
        _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));

        _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();
        _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));
        _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 5000 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5000 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = compoundYieldAddress;
        request.collateralAssetStrategy = compoundYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.REQUESTED, '!Requested');
    }

    // Test 0: Test SetUp
    function test_setUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.REQUESTED, '!Requested');

        uint256 _borrowCTokenExchangeRate = MockCToken(borrowCTokenAddress).exchangeRateCurrent();
        uint256 _collateralCTokenExchangeRate = MockCToken(collateralCTokenAddress).exchangeRateCurrent();

        // Checking out what are the exchange rates
        log_named_int('Borrow CToken Exchange Rate', int256(_borrowCTokenExchangeRate));
        log_named_int('Collateral CToken Exchange Rate', int256(_collateralCTokenExchangeRate));

        // Check the exchange rates of the borrow and collateral CTokens are non-zero
        assertGt(_borrowCTokenExchangeRate, 0);
        assertGt(_collateralCTokenExchangeRate, 0);
    }

    // Test 1: A requested PCL cannot be started even with exchange rate fluctuations
    function test_pclCannotBeStarted() public {
        helper_exchangeRateChanges();

        try borrower.start(requestId) {
            revert('Cannot start a requested PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S2');
        }
    }

    // Test 2: Collateral cannot be deposited
    function test_collateralCannotBeDeposited() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        helper_exchangeRateChanges();
        try borrower.depositCollateral(requestId, _minimumCollateralRequired, false) {
            revert('Collateral cannot be deposited');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:DC2');
        }
    }

    // Test 3: Withdrawable collateral remains zero
    function test_withdrawableCollateralIsZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);

        assertEq(_withdrawableCollateral, 0);
    }

    // Test 4: Collateral cannot be withdrawn
    function test_collateralCannotBeWithdrawn() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        try borrower.withdrawCollateral(requestId, 1, false) {
            revert('Collateral cannot be withdrawn');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC1');
        }
    }

    // Test 5: All Collateral cannot be withdrawn
    function test_allCollateralCannotBeWithdrawn() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        try borrower.withdrawAllCollateral(requestId, false) {
            revert('All collateral cannot be withdrawn');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WAC1');
        }
    }

    // Test 6: A requested PCL cannot be closed
    function test_pclCannotBeClosed() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        try borrower.close(requestId) {
            revert('PCL cannot be closed');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C1');
        }
    }

    // Test 7: Required collateral remains same if collateral CToken exchange rate increases steeply
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.1: Required collateral remains same if borrow CToken exchange rate increases steeply
    function test_requiredCollateralRemainsSameIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.2: Required collateral remains same if borrow CToken exchange rate decreases to zero
    function test_requiredCollateralRemainSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.3: Required collateral remains same if collateral CToken exchange rate decreases to zero
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.4: Required collateral remains same if collateral CToken exchange rate increases very slowly
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 8: Collateral tokens remains zero if collateral CToken exchange rate increases steeply
    function test_totalCollateralTokensRemainsZeroIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);

        assertEq(_collateralTokens, 0);
    }

    // Test 8.1: Collateral tokens remains zero if collateral CToken exchange rate decreases to zero
    function test_totalCollateralTokensRemainsZeroIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);

        assertEq(_collateralTokens, 0);
    }

    // Test 9: Collateral ratio remains infinite
    function test_collateralRatioIsInfinite() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);

        assertEq(_collateralRatio, type(uint256).max);
    }

    // Test 10: A requested PCL can be cancelled
    function test_pclCanBeCancelled() public {
        createMultipleLenders(requestId, 5, uint128(request.borrowLimit - 10), request.borrowAsset);

        helper_exchangeRateChanges();
        borrower.cancelRequest(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CANCELLED);
    }

    // Test 11: Admin should be able to terminate
    function test_adminCanTerminatePCL() public {
        createMultipleLenders(requestId, 6, uint128(request.minBorrowAmount - 1), request.borrowAsset);
        helper_exchangeRateChanges();

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        // Admin terminates the PCL
        admin.terminate(requestId);

        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertTrue((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate) == 0); // Since no collateral was ever deposited
        assertTrue((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate) == 0);
    }

    // Test 12: Borrowable amount remains zero
    function test_borrowableAmountIsZero() public {
        helper_exchangeRateChanges();
        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        assertEq(_borrowableAmount, 0);
    }

    // Test 13: Borrower cannot repay
    function test_borrowerCannotRepay() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        admin.transferToken(address(borrowAsset), address(borrower), 1);
        borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);
        try borrower.repay(requestId, 1) {
            revert('Borrower cannot repay');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:REP2');
        }
    }

    // Test 14: A requested PCL cannot be liquidated
    function test_lendersCannotLiquidate(bool _withdraw) public {
        createMultipleLenders(requestId, 6, uint128(request.minBorrowAmount - 1), request.borrowAsset);
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_exchangeRateChanges();

        // _lender0 tries to liquidate the PCL
        try _lender0.liquidate(requestId, _withdraw) {
            revert('Cannot liquidate a requested PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L1');
        }
    }

    // Test 15: Lenders cannot withdraw liquidation
    function test_lendersCannotWithdrawLiquidation() public {
        createMultipleLenders(requestId, 6, uint128(request.minBorrowAmount - 1), request.borrowAsset);
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_exchangeRateChanges();

        try _lender0.withdrawTokensAfterLiquidation(requestId) {
            revert('Cannot withdraw liquidation from an requested PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    // Test 16: Lenders can withdraw liquidity
    function test_lendersCanWithdrawLiquidity() public {
        createMultipleLenders(requestId, 6, uint128(request.minBorrowAmount - 1), request.borrowAsset);
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        vm.warp(block.timestamp + (request.collectionPeriod + 2 days));
        uint256 _userPoolTokenBalance = lp.balanceOf(address(_lender0), requestId);

        helper_exchangeRateChanges();

        uint256 _userBorrowTokenBalanceBefore = IERC20(request.borrowAsset).balanceOf(address(_lender0));
        _lender0.withdrawLiquidity(requestId);
        uint256 _userBorrowTokenBalanceAfter = IERC20(request.borrowAsset).balanceOf(address(_lender0));
        assertEq(_userPoolTokenBalance, _userBorrowTokenBalanceAfter - _userBorrowTokenBalanceBefore);

        _userPoolTokenBalance = lp.balanceOf(address(_lender0), requestId);
        assertEq(_userPoolTokenBalance, 0);
    }

    // Test 17: Pool token transfers should be possible
    function test_poolTokenTransfersShouldBePossibleEntireBalance() public {
        createMultipleLenders(requestId, 6, uint128(request.minBorrowAmount - 1), request.borrowAsset);
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);

        //Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, 0);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == 0);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));
    }

    // Test 17.1: Pool token transfers should be possible
    function test_poolTokenTransfersShouldBePossiblePartialBalance() public {
        createMultipleLenders(requestId, 6, uint128(request.minBorrowAmount - 1), request.borrowAsset);
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 18: Interest cannot be withdrawn amidst exchange rate fluctuations
    function test_lendersCannotWithdrawInterest() public {
        createMultipleLenders(requestId, 6, uint128(request.minBorrowAmount - 1), request.borrowAsset);
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender0Balance = borrowAsset.balanceOf(address(lender0));

        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender1Balance = borrowAsset.balanceOf(address(lender1));

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender0));
        uint256 lender1InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender1));

        helper_exchangeRateChanges();

        try lender1.withdrawInterest(requestId) {
            revert('Interest cannot be withdrawn');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WI1');
        }
    }

    uint256 _principal;
    uint256 _currentCR1;
    uint256 _currentCR2;
    uint256 _currentCR3;
    uint256 _principalWithdrawable;
    uint256 _withdrawableCollateral;
    uint256 _currentDebt;
    uint256 _borrowable;
    uint256 _totalCollateral;
    uint256 _equivalentCollateral;
    uint256 _interestAccrued;

    uint256 collateralToDeposit;

    function assert_helperFunctionalities(uint256 _id) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);

        createMultipleLenders(requestId, 6, uint128(request.minBorrowAmount - 1), request.borrowAsset);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 1. calculateCurrentCollateralRatio
        _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);
        assertEq(_currentCR1, uint256(-1)); // Since borrower has not yet borrowed anything

        helper_exchangeRateChanges();

        // 2. calculatePrincipalWithdrawable
        _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
        assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from a requested PCL

        helper_exchangeRateChanges();

        // 3. withdrawableCollateral
        _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertEq(_withdrawableCollateral, 0); // Since no collateral was deposited in the first place

        helper_exchangeRateChanges();

        // 4. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        assertEq(_currentDebt, 0); // Since nothing was borrowed

        helper_exchangeRateChanges();

        // 5. calculateBorrowableAmount
        _borrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_borrowable, 0); // Since collateral was not deposited

        helper_exchangeRateChanges();

        // 6. calculateTotalCollateralTokens
        _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertEq(_totalCollateral, 0); // Since no collateral was deposited

        helper_exchangeRateChanges();

        // 7. collateralTokensToLiquidate
        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
        assertGt(_equivalentCollateral, 0);

        helper_exchangeRateChanges();

        // 8. calculateInterestAccrued
        _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertEq(_interestAccrued, 0); // Since borrower did not borrow anything

        helper_exchangeRateChanges();
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);
    }

    function test_helperFunctions() public {
        assert_helperFunctionalities(requestId);
    }
}",6014
RealWorld_BA_101_PCLLifecycleTest.t_RealWord_20240827094917.log,101,PCLLifecycleTest.t,0,0,0,,0.0,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/math/SafeMath.sol';

import '../Helpers/PCLParent.t.sol';

/*

possible paths:
- not created -> requested
- requested -> cancelled
- requested -> terminated
- requested -> active
- active -> closed
- active -> expired
- active -> liquidated
- active -> terminated
- liquidated -> terminated
- closed -> terminated
- expired -> terminated
- expired -> liquidated
- expired -> closed

enum PooledCreditLineStatus {
     NOT_CREATED,
     REQUESTED,
     ACTIVE,
     CLOSED,
     EXPIRED,
     LIQUIDATED,
     CANCELLED
     TERMINATED
}

*/

contract PCLLifecycleTest is PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;

    event PooledCreditLineAccepted(uint256 indexed id, uint256 amount);

    uint256 t0;
    uint256 requestId;
    uint128 amountToLend;
    uint256 randomNumber1;
    uint256 randomNumber2;
    uint256 randomNumber3;
    uint256 actualBorrowLimit;

    function setUp() public virtual override {
        super.setUp();

        t0 = block.timestamp;
        // fuzzed
        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128(PCLConstants.minBorrowRate.mul(5));
        // fuzzed
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = PCLConstants.maxDuration;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = PCLConstants.minDefaultGraceDuration;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = PCLConstants.minCollectionPeriod;
        // fuzzed
        request.minBorrowAmount = 90_000 * (10**ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;
    }

    function goToRequestedStageFuzzed(
        uint256 _borrowLimitInUsd,
        uint256 _collateralRatio,
        uint128 _amountToLend,
        uint256 _randomNumber1,
        uint256 _randomNumber2,
        uint256 _randomNumber3
    ) public {
        randomNumber1 = scaleToRange256(_randomNumber1, 1, 10);
        randomNumber2 = scaleToRange256(_randomNumber2, 2, 10);
        randomNumber3 = scaleToRange256(_randomNumber3, 3, 10);

        request.borrowRate = scaleToRange128(_amountToLend, PCLConstants.minBorrowRate, uint128(PCLConstants.maxBorrowRate.div(20)));
        emit log_named_uint('borrowRate', request.borrowRate);
        request.duration = PCLConstants.maxDuration.div(randomNumber3);
        request.collectionPeriod = PCLConstants.minCollectionPeriod.mul(randomNumber2);
        request.defaultGracePeriod = PCLConstants.minDefaultGraceDuration.mul(randomNumber1);

        {
            _borrowLimitInUsd = scaleToRange256(_borrowLimitInUsd, PCLConstants.minBorrowLimit, PCLConstants.maxBorrowLimit);
            emit log_named_uint('_borrowLimitInUsd', _borrowLimitInUsd);
            request.collateralRatio = scaleToRange256(_collateralRatio, PCLConstants.minCollateralRatio, PCLConstants.maxCollateralRatio);
            emit log_named_uint('request.collateralRatio', request.collateralRatio);

            if (_borrowLimitInUsd <= PCLConstants.minBorrowLimit.mul(110).div(100)) {
                request.collateralRatio = pcl.SCALING_FACTOR();
            }

            (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
                address(borrowAsset),
                address(usdc)
            );
            emit log_named_decimal_uint('_ratioOfPrices', _ratioOfPrices, _decimals);
            // adding 1 because of rounding down by division with _ratioOfPrices
            request.borrowLimit = uint128(_borrowLimitInUsd.mul(10**_decimals).div(_ratioOfPrices).add(1));
            emit log_named_uint('request.borrowLimit', request.borrowLimit);
            uint256 _minBorrowAmount;
            if (randomNumber3 < randomNumber2) {
                _minBorrowAmount = request.borrowLimit.mul(randomNumber3).div(randomNumber2);
            } else {
                _minBorrowAmount = request.borrowLimit.mul(randomNumber2).div(randomNumber3 + 1);
            }
            // convert _minBorrowAmount to usdc and compare with min in pcl constants
            if (_minBorrowAmount.mul(_ratioOfPrices).div(10**_decimals) < PCLConstants.minBorrowLimit) {
                _minBorrowAmount = PCLConstants.minBorrowLimit.mul(10**_decimals).div(_ratioOfPrices);
            }
            // adding 1 because of rounding down by division with _ratioOfPrices
            request.minBorrowAmount = _minBorrowAmount.add(1);
            emit log_named_uint('request.minBorrowAmount', request.minBorrowAmount);
        }

        // taking enough to go into active stage
        amountToLend = scaleToRange128(_amountToLend, uint128(request.minBorrowAmount), request.borrowLimit);
        emit log_named_uint('amountToLend', amountToLend);

        requestId = borrower.createRequest(request);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.REQUESTED);

        // move a bit ahead in time
        _increaseBlock(t0 + (request.collectionPeriod.div(randomNumber2)));

        numLenders = createMultipleLenders(requestId, randomNumber3, amountToLend, request.borrowAsset);
        emit log_named_uint('numLenders', numLenders);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.REQUESTED);
        // check total supply
        assertEq(amountToLend, lp.totalSupply(requestId));
    }

    function test_requestToActiveToLiquidatePCL(
        uint256 _borrowLimitInUsd,
        uint256 _collateralRatio,
        uint128 _amountToLend,
        uint256 _randomNumber1,
        uint256 _randomNumber2,
        uint256 _randomNumber3
    ) public {
        goToRequestedStageFuzzed(_borrowLimitInUsd, _collateralRatio, _amountToLend, _randomNumber1, _randomNumber2, _randomNumber3);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);

        {
            vm.expectRevert(bytes('PCL:IB2'));
            borrower.borrow(requestId, request.borrowLimit.div(randomNumber3));

            vm.expectRevert(bytes('LP:WI1'));
            _lender.withdrawInterest(requestId);

            vm.expectRevert(bytes('LP:IWL3'));
            _lender.withdrawLiquidity(requestId);

            vm.expectRevert(bytes('PCL:L1'));
            _lender.liquidate(requestId, false);

            vm.expectRevert(bytes('LP:IWLC1'));
            _lender.withdrawTokensAfterLiquidation(requestId);
        }

        // start the pcl
        {
            // go head in time
            _increaseBlock(t0 + request.collectionPeriod);
            vm.expectEmit(true, true, false, true);
            emit PooledCreditLineAccepted(requestId, amountToLend);
            borrower.start(requestId);
            // check status
            assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);
        }

        {
            (, , , actualBorrowLimit, , , , ) = lp.pooledCLConstants(requestId);
        }

        uint256 _requiredCollateral;

        {
            // try to borrow some tokens
            uint256 _amountToBorrow = amountToLend.mul(randomNumber2).div(11);
            emit log_named_uint('_amountToBorrow', _amountToBorrow);
            bool isOverLimit;
            vm.expectRevert(bytes('PCL:IB3'));
            borrower.borrow(requestId, _amountToBorrow);
            // decide how much collateral is needed
            _requiredCollateral = pcl.getRequiredCollateral(requestId, _amountToBorrow);
            emit log_named_uint('_requiredCollateral', _requiredCollateral);
            if (_requiredCollateral > collateralAsset.balanceOf(address(admin))) {
                _requiredCollateral = collateralAsset.balanceOf(address(admin)).div(randomNumber3);
                isOverLimit = true;
            }
            admin.transferToken(address(collateralAsset), address(borrower), _requiredCollateral);
            borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _requiredCollateral);
            borrower.depositCollateral(requestId, _requiredCollateral, false);
            uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
            emit log_named_uint('_borrowableAmount', _borrowableAmount);
            if (!isOverLimit) {
                // adding 1 for precision errors
                if (stdMath.delta(_amountToBorrow, _borrowableAmount) > 2 && _requiredCollateral > 1e3) {
                    assertApproxEqRel(_amountToBorrow, _borrowableAmount, 1e16);
                }
            }
            // borrow the required amount
            uint256 _startBalance = borrowAsset.balanceOf(address(borrower));
            borrower.borrow(requestId, _borrowableAmount);
            assertApproxEqRel(
                _borrowableAmount.mul(pcl.SCALING_FACTOR().sub(pcl.protocolFeeFraction())).div(pcl.SCALING_FACTOR()),
                borrowAsset.balanceOf(address(borrower)).sub(_startBalance),
                1e14
            );
        }

        {
            // verify current collateral ratio
            emit log_named_uint('_curCollateralRatio', pcl.calculateCurrentCollateralRatio(requestId));
            assertApproxEqRel(pcl.calculateCurrentCollateralRatio(requestId), request.collateralRatio, 1e14);
        }

        // go ahead in time to accrue interest
        _increaseBlock(t0 + request.collectionPeriod + request.duration.div(randomNumber3));

        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);
        emit log_named_uint('_interestAccrued', _interestAccrued);

        {
            if (_interestAccrued > borrowAsset.balanceOf(address(borrower))) {
                if (_interestAccrued > borrowAsset.balanceOf(address(admin))) {
                    writeTokenBalance(address(admin), request.borrowAsset, _interestAccrued);
                }
                admin.transferToken(request.borrowAsset, address(borrower), _interestAccrued.sub(borrowAsset.balanceOf(address(borrower))));
            }
            // repay the interest only
            borrower.setAllowance(pooledCreditLineAddress, address(borrowAsset), _interestAccrued);
            borrower.repay(requestId, _interestAccrued);
        }

        uint256 _totalLenderInterest;

        {
            // get total lender interest
            for (uint256 i; i < numLenders; ++i) {
                _totalLenderInterest = _totalLenderInterest.add(lp.getLenderInterestWithdrawable(requestId, lenders[i].lenderAddress));
            }
            emit log_named_uint('_totalLenderInterest', _totalLenderInterest);

            (
                uint256 _sharesHeld,
                uint256 _borrowerInterestShares,
                uint256 _borrowerInterestSharesWithdrawn,
                uint256 _yieldInterestWithdrawnShares,

            ) = lp.pooledCLVariables(requestId);
            emit log_named_uint('_sharesHeld', _sharesHeld);
            emit log_named_uint('_borrowerInterestShares', _borrowerInterestShares);
            emit log_named_uint('_borrowerInterestSharesWithdrawn', _borrowerInterestSharesWithdrawn);
            emit log_named_uint('_yieldInterestWithdrawnShares', _yieldInterestWithdrawnShares);
            uint256 _notBorrowedInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(
                actualBorrowLimit.sub(pcl.getPrincipal(requestId)),
                request.borrowAsset
            );
            emit log_named_uint('_notBorrowedInShares', _notBorrowedInShares);

            uint256 _expectedYieldInterestShares = _sharesHeld
                .sub(_notBorrowedInShares)
                .sub(_borrowerInterestShares)
                .sub(_borrowerInterestSharesWithdrawn)
                .sub(_yieldInterestWithdrawnShares);
            uint256 _expectedYieldInterest = IYield(request.borrowAssetStrategy).getTokensForShares(
                _expectedYieldInterestShares,
                request.borrowAsset
            );
            emit log_named_uint('_expectedYieldInterest', _expectedYieldInterest);
            assertApproxEqRel(_interestAccrued, _totalLenderInterest.sub(_expectedYieldInterest), 1e16);
        }

        {
            uint256 _totalWithdrawn;
            // lender withdraws interest
            uint256 _prevBalance = borrowAsset.balanceOf(address(_lender));
            uint256 _lenderInterest = lp.getLenderInterestWithdrawable(requestId, address(_lender));
            _lender.withdrawInterest(requestId);
            _totalWithdrawn = borrowAsset.balanceOf(address(_lender)).sub(_prevBalance);
            assertApproxEqRel(borrowAsset.balanceOf(address(_lender)).sub(_prevBalance), _lenderInterest, 1e16);

            uint256 _prevBalanceI;
            for (uint256 i = 1; i < numLenders; ++i) {
                _prevBalanceI = borrowAsset.balanceOf(lenders[i].lenderAddress);
                PCLUser(lenders[i].lenderAddress).withdrawInterest(requestId);
                _totalWithdrawn = _totalWithdrawn.add(borrowAsset.balanceOf(lenders[i].lenderAddress).sub(_prevBalanceI));
            }
            emit log_named_uint('_totalWithdrawn', _totalWithdrawn);
            assertApproxEqRel(_totalWithdrawn, _totalLenderInterest, 1e16);
        }

        {
            // borrow again
            vm.expectRevert(bytes('PCL:IB3'));
            borrower.borrow(requestId, amountToLend.div(randomNumber3));

            // go ahead in time a bit for more interest to accrued
            _increaseBlock(block.timestamp + request.duration.div(randomNumber3));
        }

        {
            emit log_named_uint('_curCollateralRatio', pcl.calculateCurrentCollateralRatio(requestId));
            if (pcl.calculateCurrentCollateralRatio(requestId) > request.collateralRatio) {
                // amount of collateral deposited has grown because of yield interest
                assertTrue(_requiredCollateral < pcl.calculateTotalCollateralTokens(requestId));
                _increaseBlock(t0 + request.collectionPeriod + request.duration + request.defaultGracePeriod);
            } else {
                assertLe(pcl.calculateCurrentCollateralRatio(requestId), request.collateralRatio);
            }
        }

        uint256 _startBalanceBorrowAssetLender = borrowAsset.balanceOf(address(_lender));
        uint256 _collateralTokensLiquidated = pcl.calculateTotalCollateralTokens(requestId);
        emit log_named_uint('_collateralTokensLiquidated', _collateralTokensLiquidated);
        uint256 _principalWithdrawable = actualBorrowLimit
            .sub(pcl.getPrincipal(requestId))
            .mul(lp.balanceOf(address(_lender), requestId))
            .div(lp.totalSupply(requestId));
        emit log_named_uint('_principalWithdrawable', _principalWithdrawable);
        uint256 _interestWithdrawable = lp.getLenderInterestWithdrawable(requestId, address(_lender));
        emit log_named_uint('_interestWithdrawable', _interestWithdrawable);

        // pcl can be liquidated
        {
            _lender.liquidate(requestId, true);
            assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
            uint256 _totalCollateral = pcl.calculateTotalCollateralTokens(requestId);
            emit log_named_uint('_totalCollateral', _totalCollateral);
            uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
            emit log_named_uint('_withdrawableCollateral', _withdrawableCollateral);

            assertEq(_withdrawableCollateral, _totalCollateral);

            if (_totalCollateral != 0) {
                _collateralTokensLiquidated = _collateralTokensLiquidated.sub(_withdrawableCollateral);
            }
        }

        // borrower still has borrowed assets minnus the paid interest
        // principal * (1 - protocal_fee) - interest paid == borrow asset balance of the borrower
        // not borrower balance of borrowAsset is 0 initially
        {
            uint256 _expectedBorrowAmountReceived = pcl
                .getPrincipal(requestId)
                .mul(pcl.SCALING_FACTOR().sub(pcl.protocolFeeFraction()))
                .div(pcl.SCALING_FACTOR());
            uint256 _expectedBorrowerBalance;
            if (_interestAccrued <= _expectedBorrowAmountReceived) {
                _expectedBorrowerBalance = _expectedBorrowAmountReceived.sub(_interestAccrued);
            } else {
                _expectedBorrowerBalance = 0;
            }
            emit log_named_uint('_expectedBorrowerBalance', _expectedBorrowerBalance);
            assertApproxEqAbs(_expectedBorrowerBalance, borrowAsset.balanceOf(address(borrower)), 2);
        }

        {
            // lender has the got back the principal left
            uint256 _expectedBorrowAssetWithdrawn = _principalWithdrawable.add(_interestWithdrawable);
            emit log_named_uint('_expectedBorrowAssetWithdrawn', _expectedBorrowAssetWithdrawn);
            assertApproxEqRel(
                _expectedBorrowAssetWithdrawn,
                borrowAsset.balanceOf(address(_lender)).sub(_startBalanceBorrowAssetLender),
                1e15
            );
        }
        {
            // lender has the got their share of the collateral
            // collateral_liquidated * lenders_lent_amount / total_lent_amount == collateral asset balance of the lender
            uint256 _lenderCollateral = _collateralTokensLiquidated.mul(lenders[0].amount).div(amountToLend);
            uint256 _collateralAssetBalance = collateralAsset.balanceOf(address(_lender));
            emit log_named_uint('_lenderCollateral', _lenderCollateral);
            emit log_named_uint('_collateralAssetBalance', _collateralAssetBalance);
            if (stdMath.delta(_lenderCollateral, _collateralAssetBalance) > 2) {
                assertApproxEqRel(_lenderCollateral, _collateralAssetBalance, 1e16);
            }
        }

        {
            PCLUser _lastLender = PCLUser(lenders[numLenders - 1].lenderAddress);
            uint256 _startCollateralBalance = collateralAsset.balanceOf(address(_lastLender));
            uint256 _startBorrowAssetBalance = borrowAsset.balanceOf(address(_lastLender));
            emit log_named_uint('pcl.getPrincipal', pcl.getPrincipal(requestId));
            emit log_named_uint('lp balance', lp.balanceOf(address(_lastLender), requestId));
            uint256 _principalWithdrawable = lp.calculatePrincipalWithdrawable(requestId, address(_lastLender));
            emit log_named_uint('_principalWithdrawable', _principalWithdrawable);
            uint256 _interestWithdrawable = lp.getLenderInterestWithdrawable(requestId, address(_lastLender));
            emit log_named_uint('_interestWithdrawable', _interestWithdrawable);
            emit log_named_uint('borrow asset withdrawable of lender', _principalWithdrawable.add(_interestWithdrawable));
            // we cannot use lp balances because total supply is now not equal to amount lent
            uint256 _expectedCollateralWithdrawn = _collateralTokensLiquidated.mul(lenders[numLenders - 1].amount).div(amountToLend);
            emit log_named_uint('_expectedCollateralWithdrawn', _expectedCollateralWithdrawn);
            _lastLender.withdrawTokensAfterLiquidation(requestId);
            if (
                stdMath.delta(_startCollateralBalance.add(_expectedCollateralWithdrawn), collateralAsset.balanceOf(address(_lastLender))) >
                2
            ) {
                assertApproxEqRel(
                    _startCollateralBalance.add(_expectedCollateralWithdrawn),
                    collateralAsset.balanceOf(address(_lastLender)),
                    1e15
                );
            }

            emit log_named_uint('_expectedBorrowAssetWithdrawn', _principalWithdrawable.add(_interestWithdrawable));
            assertApproxEqRel(
                _startBorrowAssetBalance.add(_principalWithdrawable.add(_interestWithdrawable)),
                borrowAsset.balanceOf(address(_lastLender)),
                1e15
            );
        }
    }

    event Lend(uint256 indexed id, address indexed user, uint256 amount);
    event BorrowedFromPooledCreditLine(uint256 indexed id, uint256 borrowAmount);
    event AccrueInterest(uint256 cashPrior, uint256 interestAccumulated, uint256 borrowIndexNew, uint256 totalBorrowsNew);

    function test_requestToActiveToClosedPCL(
        uint256 _randomAmount,
        uint256 _collateralRatio,
        uint128 _amountToLend,
        uint256 _randomNumber1,
        uint256 _randomNumber2,
        uint256 _randomNumber3
    ) public {
        goToRequestedStageFuzzed(_randomAmount, _collateralRatio, _amountToLend, _randomNumber1, _randomNumber2, _randomNumber3);

        {
            if (request.borrowLimit > amountToLend) {
                PCLUser _lender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
                vm.expectRevert(bytes('LP:L1'));
                _lender.lend(requestId, 0);
                vm.expectRevert(bytes('LP:L2'));
                _lender.lend(requestId, 1e2);

                address _lenderAddress = createLender(requestId, request.borrowLimit - amountToLend, request.borrowAsset);
                lenders[numLenders] = LenderInfo(_lenderAddress, request.borrowLimit - amountToLend);
                amountToLend = request.borrowLimit;
                assertEq(request.borrowLimit, lp.totalSupply(requestId));
            } else {
                assertEq(request.borrowLimit, lp.totalSupply(requestId));
                PCLUser _lender = new PCLUser(pooledCreditLineAddress, lenderPoolAddress);
                _lender.registerSelf(mockAdminVerifier1);
                vm.expectRevert(bytes('LP:L4'));
                _lender.lend(requestId, amountToLend.div(randomNumber3));
            }
        }

        // start the pcl
        {
            // go head in time
            _increaseBlock(t0 + request.collectionPeriod);
            vm.expectEmit(true, true, false, true);
            emit PooledCreditLineAccepted(requestId, amountToLend);
            borrower.start(requestId);
            // check status
            assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);
        }

        {
            (, , , actualBorrowLimit, , , , ) = lp.pooledCLConstants(requestId);
        }

        {
            // deposit collateral
            uint256 _maxCollateral = pcl.getRequiredCollateral(requestId, actualBorrowLimit);
            if (_maxCollateral > collateralAsset.balanceOf(address(admin))) {
                _maxCollateral = collateralAsset.balanceOf(address(admin));
            }
            uint256 _collateralAmount = scaleToRange256(_randomAmount, _maxCollateral.div(100), _maxCollateral);
            admin.transferToken(request.collateralAsset, address(borrower), _collateralAmount);
            borrower.setAllowance(pooledCreditLineAddress, request.collateralAsset, _collateralAmount);
            borrower.depositCollateral(requestId, _collateralAmount, false);
            emit log_named_uint('_collateralAmount', _collateralAmount);
        }

        {
            uint256 _expectedBorrowedAmount = pcl
                .calculateBorrowableAmount(requestId)
                .mul(pcl.SCALING_FACTOR().sub(pcl.protocolFeeFraction()))
                .div(pcl.SCALING_FACTOR());
            borrower.borrow(requestId, pcl.calculateBorrowableAmount(requestId));
            emit log_named_uint('_expectedBorrowedAmount', _expectedBorrowedAmount);
            assertApproxEqRel(_expectedBorrowedAmount, borrowAsset.balanceOf(address(borrower)), 1e14);
        }

        // go ahead in time to accrue interest
        _increaseBlock(block.timestamp + request.duration.div(randomNumber3));

        {
            // check cur collateral ratio
            uint256 _curCollateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
            uint256 _moreCollateralRequired;
            if (pcl.getRequiredCollateral(requestId, pcl.calculateCurrentDebt(requestId)) > pcl.calculateTotalCollateralTokens(requestId)) {
                _moreCollateralRequired = pcl.getRequiredCollateral(requestId, pcl.calculateCurrentDebt(requestId)).sub(
                    pcl.calculateTotalCollateralTokens(requestId)
                );
            }
            if (_moreCollateralRequired > 0) {
                emit log_named_uint('_moreCollateralRequired', _moreCollateralRequired);
                if (_moreCollateralRequired > collateralAsset.balanceOf(address(admin))) {
                    writeTokenBalance(address(admin), request.collateralAsset, _moreCollateralRequired);
                }
                admin.transferToken(request.collateralAsset, address(borrower), _moreCollateralRequired);
                borrower.setAllowance(pooledCreditLineAddress, request.collateralAsset, _moreCollateralRequired);
                borrower.depositCollateral(requestId, _moreCollateralRequired, false);
                // check cur collateral ratio
                if (_moreCollateralRequired > 1e3) {
                    // this condition is because otherwise the error is high
                    assertApproxEqRel(pcl.calculateCurrentCollateralRatio(requestId), request.collateralRatio, 1e16);
                }
            } else {
                // check how much more can be borrowed
                // the borrow rate is too low the yield is more nd the collateral ratio has increased
                uint256 _collateralRequired = pcl.getRequiredCollateral(requestId, pcl.calculateCurrentDebt(requestId));
                assertLe(_collateralRequired, pcl.calculateTotalCollateralTokens(requestId));
            }
        }

        // go ahead in time to accrue interest
        {
            emit log_named_uint('before warp borrowCTokenAddress exchange rate', ICToken(borrowCTokenAddress).exchangeRateCurrent());
            _increaseBlock(block.timestamp + request.duration.div(randomNumber3));
            emit log_named_uint('after warp borrowCTokenAddress exchange rate', ICToken(borrowCTokenAddress).exchangeRateCurrent());
        }

        {
            // pay back interest
            uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);
            uint256 _toRepay = _interestAccrued;
            if (borrowAsset.balanceOf(address(borrower)) < _interestAccrued) {
                _toRepay = borrowAsset.balanceOf(address(borrower));
            }
            borrower.setAllowance(pooledCreditLineAddress, request.borrowAsset, _toRepay);
            borrower.repay(requestId, _toRepay);
            emit log_named_uint('pcl.withdrawableCollateral(requestId)', pcl.withdrawableCollateral(requestId));
            emit log_named_uint('pcl.calculateTotalCollateralTokens(requestId)', pcl.calculateTotalCollateralTokens(requestId));
            emit log_named_uint('pcl.getRequiredCollateral', pcl.getRequiredCollateral(requestId, pcl.calculateCurrentDebt(requestId)));
            // check withdrawable collateral
            if (pcl.withdrawableCollateral(requestId) > 1e3) {
                assertApproxEqRel(
                    pcl.withdrawableCollateral(requestId),
                    pcl.calculateTotalCollateralTokens(requestId).sub(
                        pcl.getRequiredCollateral(requestId, pcl.calculateCurrentDebt(requestId))
                    ),
                    1e16
                );
            }
        }

        {
            (, , uint256 _totalInterestRepaid, , ) = pcl.pooledCreditLineVariables(requestId);
            PCLUser _lender = PCLUser(lenders[0].lenderAddress);
            uint256 _startBalance = borrowAsset.balanceOf(address(_lender));
            uint256 _expectedBorrowInterestForLender = _totalInterestRepaid.mul(lp.balanceOf(address(_lender), requestId)).div(
                lp.totalSupply(requestId)
            );
            emit log_named_uint('_expectedBorrowInterestForLender', _expectedBorrowInterestForLender);
            (uint256 _sharesHeld, uint256 _borrowerInterestShares, , , ) = lp.pooledCLVariables(requestId);
            uint256 _notBorrowedInShares = IYield(request.borrowAssetStrategy).getSharesForTokens(
                actualBorrowLimit.sub(pcl.getPrincipal(requestId)),
                request.borrowAsset
            );
            // assuming no interest has been withdrawn by any lender yet
            uint256 _expectedYieldInterestShares = _sharesHeld.sub(_notBorrowedInShares).sub(_borrowerInterestShares);
            uint256 _expectedYieldInterestForBorrower = IYield(request.borrowAssetStrategy)
                .getTokensForShares(_expectedYieldInterestShares, request.borrowAsset)
                .mul(lp.balanceOf(address(_lender), requestId))
                .div(lp.totalSupply(requestId));
            emit log_named_uint('_expectedYieldInterestForBorrower', _expectedYieldInterestForBorrower);
            _lender.withdrawInterest(requestId);
            uint256 _borrowerInterestSharesWithdrawn = lp.getLenderInfo(requestId, address(_lender)).borrowerInterestSharesWithdrawn;
            emit log_named_uint('_borrowerInterestSharesWithdrawn', _borrowerInterestSharesWithdrawn);
            if (_borrowerInterestSharesWithdrawn > 100) {
                assertApproxEqRel(
                    _startBalance.add(_expectedBorrowInterestForLender).add(_expectedYieldInterestForBorrower),
                    borrowAsset.balanceOf(address(_lender)),
                    1e16
                );
                assertApproxEqRel(
                    _expectedBorrowInterestForLender,
                    IYield(request.borrowAssetStrategy).getTokensForShares(_borrowerInterestSharesWithdrawn, request.borrowAsset),
                    1e16
                );
            }
        }

        {
            // withdraw collateral
            uint256 _collateralToWithdraw = pcl.withdrawableCollateral(requestId).div(randomNumber2);
            if (_collateralToWithdraw != 0) {
                borrower.withdrawCollateral(requestId, _collateralToWithdraw, false);
                assertApproxEqAbs(collateralAsset.balanceOf(address(borrower)), _collateralToWithdraw, 3);
            }
        }

        {
            (, , uint256 _totalInterestRepaid, , ) = pcl.pooledCreditLineVariables(requestId);
            emit log_named_uint('pcl.calculateInterestAccrued(requestId)', pcl.calculateInterestAccrued(requestId));
            emit log_named_uint('_totalInterestRepaid', _totalInterestRepaid);
            if (pcl.calculateInterestAccrued(requestId).sub(_totalInterestRepaid) == 0) {
                // cannot replay unless there is interest accrued

                // vm.expectRevert not working
                // vm.expectRevert(bytes('PCL:REP4'));
                // borrower.repay(requestId, borrowAsset.balanceOf(address(borrower)).div(randomNumber3));

                try borrower.repay(requestId, borrowAsset.balanceOf(address(borrower)).div(randomNumber3)) {
                    revert('cannot repay when interest is zero');
                } catch Error(string memory reason) {
                    assertEq(reason, 'PCL:REP4');
                }
            }
        }

        // go ahead in time to accrue interest
        _increaseBlock(block.timestamp + request.duration.div(randomNumber3));

        // repay
        {
            uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
            if (_currentDebt > borrowAsset.balanceOf(address(borrower))) {
                uint256 _delta = _currentDebt.sub(borrowAsset.balanceOf(address(borrower)));
                if (_delta > borrowAsset.balanceOf(address(admin))) {
                    writeTokenBalance(address(admin), request.borrowAsset, _delta);
                }
                admin.transferToken(request.borrowAsset, address(borrower), _delta);
            }
            borrower.setAllowance(pooledCreditLineAddress, request.borrowAsset, _currentDebt);
            borrower.repay(requestId, _currentDebt);
            assertEq(0, pcl.calculateCurrentDebt(requestId));
        }

        // go to end and verify if pcl is closed
        _increaseBlock(t0 + request.collectionPeriod + request.duration);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);

        {
            uint256 _startBalance = collateralAsset.balanceOf(address(borrower));
            uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
            borrower.withdrawAllCollateral(requestId, false);
            assertApproxEqAbs(_withdrawableCollateral.add(_startBalance), collateralAsset.balanceOf(address(borrower)), 3);
        }

        // go forward to avoid sub overflow error in _calculateLenderInterest
        _increaseBlock(block.timestamp + request.duration.div(randomNumber3));

        {
            PCLUser _lender = PCLUser(lenders[numLenders - 1].lenderAddress);
            _lender.withdrawInterest(requestId);
        }

        {
            PCLUser _lender = PCLUser(lenders[numLenders - 1].lenderAddress);
            uint256 _startBalance = borrowAsset.balanceOf(address(_lender));
            uint256 _expectedLiquidityWithdrawn = lp.balanceOf(address(_lender), requestId).add(
                lp.getLenderInterestWithdrawable(requestId, address(_lender))
            );
            emit log_named_uint('_expectedLiquidityWithdrawn', _expectedLiquidityWithdrawn);
            _lender.withdrawLiquidity(requestId);
            uint256 _actualLiquidityWithdrawn = borrowAsset.balanceOf(address(_lender)).sub(_startBalance);
            emit log_named_uint('_actualLiquidityWithdrawn', _actualLiquidityWithdrawn);
            assertApproxEqRel(_expectedLiquidityWithdrawn, _actualLiquidityWithdrawn, 1e15);
        }
    }

    function test_requestToActiveToExpiredPCL(
        uint256 _randomAmount,
        uint256 _collateralRatio,
        uint128 _amountToLend,
        uint256 _randomNumber1,
        uint256 _randomNumber2,
        uint256 _randomNumber3
    ) public {
        goToRequestedStageFuzzed(_randomAmount, _collateralRatio, _amountToLend, _randomNumber1, _randomNumber2, _randomNumber3);

        // start the pcl
        {
            // go head in time
            _increaseBlock(t0 + request.collectionPeriod);
            vm.expectEmit(true, true, false, true);
            emit PooledCreditLineAccepted(requestId, amountToLend);
            borrower.start(requestId);
            // check status
            assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);
        }

        {
            (, , , actualBorrowLimit, , , , ) = lp.pooledCLConstants(requestId);
        }

        {
            // borrow tokens
            // try to borrow some tokens
            uint256 _amountToBorrow = actualBorrowLimit.mul(randomNumber2).div(11);
            emit log_named_uint('_amountToBorrow', _amountToBorrow);
            bool isOverLimit;
            // decide how much collateral is needed
            uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, _amountToBorrow);
            emit log_named_uint('_requiredCollateral', _requiredCollateral);
            if (_requiredCollateral > collateralAsset.balanceOf(address(admin))) {
                _requiredCollateral = collateralAsset.balanceOf(address(admin)).div(randomNumber3);
                isOverLimit = true;
            }
            // deposit collateral
            admin.transferToken(address(collateralAsset), address(borrower), _requiredCollateral);
            borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _requiredCollateral);
            borrower.depositCollateral(requestId, _requiredCollateral, false);
            // calculateBorrowableAmount
            uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
            emit log_named_uint('_borrowableAmount', _borrowableAmount);
            if (!isOverLimit) {
                if (stdMath.delta(_amountToBorrow, _borrowableAmount) > 2 && _requiredCollateral > 1e3) {
                    assertApproxEqRel(_amountToBorrow, _borrowableAmount, 1e16);
                }
            }
            // borrow the required amount
            borrower.borrow(requestId, _borrowableAmount);
        }

        // go ahead in time to expire the pcl
        _increaseBlock(t0 + request.collectionPeriod + request.duration);

        uint256 _interestAccruedTillExpiry = pcl.calculateInterestAccrued(requestId);
        emit log_named_uint('_interestAccruedTillExpiry', _interestAccruedTillExpiry);

        // the grace period has started
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED);

        {
            uint256 _collateralRequired;
            if (pcl.getRequiredCollateral(requestId, pcl.calculateCurrentDebt(requestId)) > pcl.calculateTotalCollateralTokens(requestId)) {
                _collateralRequired = pcl.getRequiredCollateral(requestId, pcl.calculateCurrentDebt(requestId)).sub(
                    pcl.calculateTotalCollateralTokens(requestId)
                );
            }
            if (_collateralRequired > 0) {
                // because of precision errors
                _collateralRequired = _collateralRequired.mul(110).div(100);
            } else if (pcl.calculateCurrentCollateralRatio(requestId) < request.collateralRatio) {
                // take a random amount
                _collateralRequired = 1e2;
            }
            if (_collateralRequired > 0) {
                if (_collateralRequired > collateralAsset.balanceOf(address(admin))) {
                    writeTokenBalance(address(admin), request.collateralAsset, _collateralRequired);
                }
                emit log_named_uint('_collateralRequired', _collateralRequired);
                admin.transferToken(request.collateralAsset, address(borrower), _collateralRequired);
                borrower.setAllowance(pooledCreditLineAddress, request.collateralAsset, _collateralRequired);
                borrower.depositCollateral(requestId, _collateralRequired, false);
                emit log_named_uint('current Collateral Ratio', pcl.calculateCurrentCollateralRatio(requestId));
                emit log_named_uint('request.collateralRatio', request.collateralRatio);
                assertGe(pcl.calculateCurrentCollateralRatio(requestId), request.collateralRatio);
            }
        }

        {
            // (, , uint256 _idealCollateralRatio, , , , , , , , , ) = pcl.pooledCreditLineConstants(requestId);
            emit log_named_uint('current Collateral Ratio', pcl.calculateCurrentCollateralRatio(requestId));
            // emit log_named_uint('_idealCollateralRatio', _idealCollateralRatio);
            PCLUser _lender = PCLUser(lenders[numLenders - 1].lenderAddress);
            vm.expectRevert(bytes('PCL:L3'));
            _lender.liquidate(requestId, true);
            assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED);
            vm.expectRevert(bytes('LP:IWL3'));
            _lender.withdrawLiquidity(requestId);
        }

        _increaseBlock(t0 + request.collectionPeriod + request.duration + request.defaultGracePeriod);

        {
            uint256 _interestAccruedTillEndOfGracePeriod = pcl.calculateInterestAccrued(requestId);
            emit log_named_uint('_interestAccruedTillEndOfGracePeriod', _interestAccruedTillEndOfGracePeriod);
            uint256 _expectedPenaltyInterest = pcl
                .getPrincipal(requestId)
                .mul(request.gracePenaltyRate)
                .mul(request.defaultGracePeriod)
                .div(365 days)
                .div(pcl.SCALING_FACTOR());
            uint256 _expectedPrincipalInterest = pcl
                .getPrincipal(requestId)
                .mul(request.borrowRate)
                .mul(request.defaultGracePeriod)
                .div(365 days)
                .div(pcl.SCALING_FACTOR());
            assertApproxEqRel(
                _expectedPenaltyInterest,
                _interestAccruedTillEndOfGracePeriod.sub(_interestAccruedTillExpiry).sub(_expectedPrincipalInterest),
                1e14
            );
        }

        // can either go for close, liquidation or terminate
    }

    function test_requestToActiveToTerminatedPCL(
        uint256 _randomAmount,
        uint256 _collateralRatio,
        uint128 _amountToLend,
        uint256 _randomNumber1,
        uint256 _randomNumber2,
        uint256 _randomNumber3
    ) public {
        goToRequestedStageFuzzed(_randomAmount, _collateralRatio, _amountToLend, _randomNumber1, _randomNumber2, _randomNumber3);

        // start the pcl
        {
            // go head in time
            _increaseBlock(t0 + request.collectionPeriod);
            vm.expectEmit(true, true, false, true);
            emit PooledCreditLineAccepted(requestId, amountToLend);
            borrower.start(requestId);
            // check status
            assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);
        }

        {
            // borrow tokens
            // try to borrow some tokens
            uint256 _amountToBorrow = amountToLend.mul(randomNumber2).div(11);
            emit log_named_uint('_amountToBorrow', _amountToBorrow);
            bool isOverLimit;
            // decide how much collateral is needed
            uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, _amountToBorrow);
            emit log_named_uint('_requiredCollateral', _requiredCollateral);
            if (_requiredCollateral > collateralAsset.balanceOf(address(admin))) {
                _requiredCollateral = collateralAsset.balanceOf(address(admin)).div(randomNumber3);
                isOverLimit = true;
            }
            // deposit collateral
            admin.transferToken(address(collateralAsset), address(borrower), _requiredCollateral);
            borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _requiredCollateral);
            borrower.depositCollateral(requestId, _requiredCollateral, false);
            // calculateBorrowableAmount
            uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
            emit log_named_uint('_borrowableAmount', _borrowableAmount);
            if (!isOverLimit) {
                // adding 1 for precision errors
                if (stdMath.delta(_amountToBorrow, _borrowableAmount) > 2 && _requiredCollateral > 1e3) {
                    assertApproxEqRel(_amountToBorrow, _borrowableAmount, 1e16);
                }
            }
            // borrow the required amount
            borrower.borrow(requestId, _borrowableAmount);
        }

        // go ahead in time
        _increaseBlock(t0 + request.collectionPeriod + request.duration.div(randomNumber3));

        {
            // pay some interest
            uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);
            uint256 _interestToPay = _interestAccrued.div(randomNumber2);
            if (_interestAccrued > borrowAsset.balanceOf(address(borrower))) {
                uint256 _delta = _interestAccrued.sub(borrowAsset.balanceOf(address(borrower)));
                if (_delta > borrowAsset.balanceOf(address(admin))) {
                    writeTokenBalance(address(admin), request.borrowAsset, _delta);
                }
                admin.transferToken(request.borrowAsset, address(borrower), _delta);
            }
            emit log_named_uint('_interestToPay', _interestToPay);
            borrower.setAllowance(pooledCreditLineAddress, request.borrowAsset, _interestToPay);
            borrower.repay(requestId, _interestToPay);

            assertTrue(lp.getLenderInterestWithdrawable(requestId, lenders[0].lenderAddress) > 0);
        }

        // go ahead in time
        _increaseBlock(block.timestamp + request.duration.div(randomNumber3));

        {
            // lender withdraws interest
            PCLUser _lender = PCLUser(lenders[numLenders - 1].lenderAddress);
            _lender.withdrawInterest(requestId);
        }

        {
            // pay back interest plus some principal
            (, , uint256 _totalInterestRepaid, , ) = pcl.pooledCreditLineVariables(requestId);
            uint256 _toRepay = pcl.calculateInterestAccrued(requestId).sub(_totalInterestRepaid).add(
                pcl.getPrincipal(requestId).div(randomNumber2)
            );
            emit log_named_uint('_toRepay', _toRepay);
            if (borrowAsset.balanceOf(address(borrower)) < _toRepay) {
                uint256 _delta = _toRepay.sub(borrowAsset.balanceOf(address(borrower)));
                if (_delta > borrowAsset.balanceOf(address(admin))) {
                    writeTokenBalance(address(admin), request.borrowAsset, _delta);
                }
                admin.transferToken(request.borrowAsset, address(borrower), _delta);
            }
            borrower.setAllowance(pooledCreditLineAddress, request.borrowAsset, _toRepay);
            borrower.repay(requestId, _toRepay);
        }

        {
            // withdraw some collateral
            uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
            emit log_named_uint('_withdrawableCollateral', _withdrawableCollateral);
            assertTrue(_withdrawableCollateral > 0);
            borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);
        }

        // go ahead in time
        _increaseBlock(block.timestamp + request.duration.div(randomNumber3));

        {
            uint256 _startBalanceBorrowAsset = borrowAsset.balanceOf(address(admin));
            uint256 _startBalanceCollateralAsset = collateralAsset.balanceOf(address(admin));
            uint256 _collateralTransferred = pcl.calculateTotalCollateralTokens(requestId);
            emit log_named_uint('_collateralTransferred', _collateralTransferred);

            // borrow tokens transferred calculation
            // NOTE: below calculation works only when totalSupply == borrowLimit
            // (uint256 _borrowLimit, , , , , , , , , , , ) = pcl.pooledCreditLineConstants(requestId);
            // assertEq(lp.totalSupply(requestId), _borrowLimit);
            (uint256 _sharesHeld, , , , ) = lp.pooledCLVariables(requestId);
            uint256 _expectedBorrowAssetTransferred = IYield(request.borrowAssetStrategy).getTokensForShares(
                _sharesHeld,
                request.borrowAsset
            );
            emit log_named_uint('_expectedBorrowAssetTransferred', _expectedBorrowAssetTransferred);

            admin.terminate(requestId);

            uint256 _endBalanceBorrowAsset = borrowAsset.balanceOf(address(admin));
            uint256 _endBalanceCollateralAsset = collateralAsset.balanceOf(address(admin));
            assertApproxEqAbs(_collateralTransferred, _endBalanceCollateralAsset.sub(_startBalanceCollateralAsset), 3);
            assertEq(_expectedBorrowAssetTransferred, _endBalanceBorrowAsset.sub(_startBalanceBorrowAsset));
        }
    }

    function test_requestToExpiredToLiquidatedPCL(
        uint256 _randomAmount,
        uint256 _collateralRatio,
        uint128 _amountToLend,
        uint256 _randomNumber1,
        uint256 _randomNumber2,
        uint256 _randomNumber3
    ) public {
        goToRequestedStageFuzzed(_randomAmount, _collateralRatio, _amountToLend, _randomNumber1, _randomNumber2, _randomNumber3);

        // start the pcl
        {
            // go head in time
            _increaseBlock(t0 + request.collectionPeriod);
            vm.expectEmit(true, true, false, true);
            emit PooledCreditLineAccepted(requestId, amountToLend);
            borrower.start(requestId);
            // check status
            assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);
        }

        {
            (, , , actualBorrowLimit, , , , ) = lp.pooledCLConstants(requestId);
        }

        {
            uint256 _collateralAmount = pcl.getRequiredCollateral(requestId, actualBorrowLimit).div(randomNumber2);
            if (_collateralAmount > collateralAsset.balanceOf(address(admin))) {
                _collateralAmount = collateralAsset.balanceOf(address(admin)).div(randomNumber3);
            }
            emit log_named_uint('_collateralAmount', _collateralAmount);
            admin.transferToken(address(collateralAsset), address(borrower), _collateralAmount);
            borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralAmount);
            borrower.depositCollateral(requestId, _collateralAmount, false);
            // calculateBorrowableAmount
            uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, _borrowableAmount);
        }

        // go ahead in time
        _increaseBlock(t0 + request.collectionPeriod + request.duration.div(randomNumber3));

        {
            // pay some amount
            uint256 _toPay = pcl.calculateInterestAccrued(requestId).div(randomNumber2);
            emit log_named_uint('_toPay', _toPay);
            if (borrowAsset.balanceOf(address(borrower)) < _toPay) {
                uint256 _delta = _toPay.sub(borrowAsset.balanceOf(address(borrower)));
                if (_delta > borrowAsset.balanceOf(address(admin))) {
                    writeTokenBalance(address(admin), request.borrowAsset, _delta);
                }
                admin.transferToken(request.borrowAsset, address(borrower), _delta);
            }
            borrower.setAllowance(pooledCreditLineAddress, request.borrowAsset, _toPay);
            borrower.repay(requestId, _toPay);
            assertTrue(lp.getLenderInterestWithdrawable(requestId, lenders[0].lenderAddress) > 0);
        }

        // withdraw interest
        {
            (, , uint256 _totalInterestRepaid, , ) = pcl.pooledCreditLineVariables(requestId);
            PCLUser _lender = PCLUser(lenders[0].lenderAddress);
            uint256 _prevBalance = borrowAsset.balanceOf(address(_lender));
            _lender.withdrawInterest(requestId);
            uint256 _finalBalance = borrowAsset.balanceOf(address(_lender));
            uint256 _yieldInterestWithdrawnShares = lp.getLenderInfo(requestId, address(_lender)).yieldInterestWithdrawnShares;
            emit log_named_uint('_yieldInterestWithdrawnShares', _yieldInterestWithdrawnShares);
            uint256 _yieldInterest = IYield(request.borrowAssetStrategy).getTokensForShares(
                _yieldInterestWithdrawnShares,
                request.borrowAsset
            );
            uint256 _borrowerInterestWithdrawn = _totalInterestRepaid.mul(lp.balanceOf(address(_lender), requestId)).div(
                lp.totalSupply(requestId)
            );
            if (_yieldInterestWithdrawnShares > 100) {
                assertApproxEqRel(_yieldInterest.add(_borrowerInterestWithdrawn), _finalBalance.sub(_prevBalance), 1e16);
            }
        }

        // repay again
        {
            // pay some amount
            uint256 _toPay = pcl.calculateInterestAccrued(requestId).div(randomNumber2);
            emit log_named_uint('_toPay', _toPay);
            if (borrowAsset.balanceOf(address(borrower)) < _toPay) {
                uint256 _delta = _toPay.sub(borrowAsset.balanceOf(address(borrower)));
                if (_delta > borrowAsset.balanceOf(address(admin))) {
                    writeTokenBalance(address(admin), request.borrowAsset, _delta);
                }
                admin.transferToken(request.borrowAsset, address(borrower), _delta);
            }
            borrower.setAllowance(pooledCreditLineAddress, request.borrowAsset, _toPay);
            borrower.repay(requestId, _toPay);
            assertTrue(lp.getLenderInterestWithdrawable(requestId, lenders[0].lenderAddress) > 0);
        }

        // go ahead in time by 2 blocks
        _increaseBlock(block.timestamp + BLOCK_TIME.mul(2));

        {
            (, , uint256 _totalInterestRepaid, , ) = pcl.pooledCreditLineVariables(requestId);
            PCLUser _lender = PCLUser(lenders[numLenders - 1].lenderAddress);
            uint256 _prevBalance = borrowAsset.balanceOf(address(_lender));
            _lender.withdrawInterest(requestId);
            uint256 _finalBalance = borrowAsset.balanceOf(address(_lender));
            uint256 _yieldInterestWithdrawnShares = lp.getLenderInfo(requestId, address(_lender)).yieldInterestWithdrawnShares;
            emit log_named_uint('_yieldInterestWithdrawnShares', _yieldInterestWithdrawnShares);
            uint256 _yieldInterest = IYield(request.borrowAssetStrategy).getTokensForShares(
                _yieldInterestWithdrawnShares,
                request.borrowAsset
            );
            uint256 _borrowerInterestWithdrawn = _totalInterestRepaid.mul(lp.balanceOf(address(_lender), requestId)).div(
                lp.totalSupply(requestId)
            );
            emit log_named_uint('_finalBalance', _finalBalance);
            emit log_named_uint('_prevBalance', _prevBalance);
            if (_yieldInterestWithdrawnShares > 100) {
                assertApproxEqRel(_yieldInterest.add(_borrowerInterestWithdrawn), _finalBalance.sub(_prevBalance), 1e15);
            }
        }

        _increaseBlock(t0 + request.collectionPeriod + request.duration + request.defaultGracePeriod.div(randomNumber3));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED);

        {
            // cannot borrow
            vm.expectRevert(bytes('PCL:IB3'));
            borrower.borrow(requestId, actualBorrowLimit.div(randomNumber3));
            emit log('cannot borrow');
        }

        // cannot withdraw collateral
        {
            // vm.expectRevert not working
            try borrower.withdrawCollateral(requestId, pcl.calculateTotalCollateralTokens(requestId), false) {
                revert('should have thrown error that cannot withdrawCollateral');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:WC1');
            }
            emit log('cannot withdrawCollateral');
        }

        {
            // can deposit collateral
            uint256 _prevCollateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
            uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, pcl.calculateCurrentDebt(requestId));
            if (_requiredCollateral <= pcl.calculateTotalCollateralTokens(requestId)) {
                _increaseBlock(t0 + request.collectionPeriod + request.duration + request.defaultGracePeriod);
            } else {
                uint256 _collateralToDeposit = _requiredCollateral.sub(pcl.calculateTotalCollateralTokens(requestId));
                _collateralToDeposit = _collateralToDeposit.div(randomNumber3);
                emit log_named_uint('_collateralToDeposit', _collateralToDeposit);
                if (_collateralToDeposit > 0) {
                    if (_collateralToDeposit > collateralAsset.balanceOf(address(admin))) {
                        _collateralToDeposit = collateralAsset.balanceOf(address(admin));
                    }
                    admin.transferToken(address(collateralAsset), address(borrower), _collateralToDeposit);
                    borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _collateralToDeposit);
                    borrower.depositCollateral(requestId, _collateralToDeposit, false);
                    uint256 _curCollateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
                    emit log_named_uint('_curCollateralRatio', _curCollateralRatio);
                    emit log_named_uint('_prevCollateralRatio', _prevCollateralRatio);
                    assertTrue(_curCollateralRatio >= _prevCollateralRatio);
                }
            }
        }

        {
            // liquidate
            PCLUser _lender = PCLUser(lenders[numLenders - 1].lenderAddress);
            _lender.liquidate(requestId, true);
            emit log_named_uint('pcl.getStatusAndUpdate(requestId)', uint256(pcl.getStatusAndUpdate(requestId)));
            assertTrue(PooledCreditLineStatus.LIQUIDATED == pcl.getStatusAndUpdate(requestId));
        }

        {
            // withdraw liquidated tokens
            PCLUser _lender = PCLUser(lenders[0].lenderAddress);
            uint256 _prevBalance = lp.balanceOf(address(_lender), requestId);
            emit log_named_uint('_prevBalance', _prevBalance);
            assertTrue(_prevBalance > 0);
            _lender.withdrawTokensAfterLiquidation(requestId);
            uint256 _finalBalance = lp.balanceOf(address(_lender), requestId);
            emit log_named_uint('_finalBalance', _finalBalance);
            assertEq(_finalBalance, 0);
        }

        {
            // borrower can withdraw any collateral left
            uint256 _collateralLeft = pcl.calculateTotalCollateralTokens(requestId);
            if (_collateralLeft > 0) {
                emit log_named_uint('_collateralLeft', _collateralLeft);
                uint256 _prevBalance = collateralAsset.balanceOf(address(borrower));
                borrower.withdrawAllCollateral(requestId, false);
                uint256 _finalBalance = collateralAsset.balanceOf(address(borrower));
                emit log_named_uint('balance delta', _finalBalance.sub(_prevBalance));
                if (stdMath.delta(_collateralLeft, _finalBalance.sub(_prevBalance)) > 2) {
                    assertApproxEqRel(_collateralLeft, _finalBalance.sub(_prevBalance), 1e15);
                }
            }
        }
    }

    function test_requestToExpiredToTerminatedPCL(
        uint256 _randomAmount,
        uint256 _collateralRatio,
        uint128 _amountToLend,
        uint256 _randomNumber1,
        uint256 _randomNumber2,
        uint256 _randomNumber3
    ) public {
        goToRequestedStageFuzzed(_randomAmount, _collateralRatio, _amountToLend, _randomNumber1, _randomNumber2, _randomNumber3);

        // start the pcl
        {
            // go head in time
            _increaseBlock(t0 + request.collectionPeriod);
            vm.expectEmit(true, true, false, true);
            emit PooledCreditLineAccepted(requestId, amountToLend);
            borrower.start(requestId);
            // check status
            assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);
        }

        {
            (, , , actualBorrowLimit, , , , ) = lp.pooledCLConstants(requestId);
        }

        {
            // try to borrow some tokens
            bool isOverLimit;
            uint256 _amountToBorrow = amountToLend.div(randomNumber3);
            emit log_named_uint('_amountToBorrow', _amountToBorrow);

            uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, _amountToBorrow);
            emit log_named_uint('_requiredCollateral', _requiredCollateral);
            if (_requiredCollateral > collateralAsset.balanceOf(address(admin))) {
                _requiredCollateral = collateralAsset.balanceOf(address(admin)).div(randomNumber3);
                isOverLimit = true;
            }
            admin.transferToken(address(collateralAsset), address(borrower), _requiredCollateral);
            borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _requiredCollateral);
            borrower.depositCollateral(requestId, _requiredCollateral, false);
            uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
            emit log_named_uint('_borrowableAmount', _borrowableAmount);
            // borrow the required amount
            uint256 _startBalance = borrowAsset.balanceOf(address(borrower));
            borrower.borrow(requestId, _borrowableAmount);
            assertApproxEqRel(
                _borrowableAmount.mul(pcl.SCALING_FACTOR().sub(pcl.protocolFeeFraction())).div(pcl.SCALING_FACTOR()),
                borrowAsset.balanceOf(address(borrower)).sub(_startBalance),
                1e14
            );
        }

        // go ahead in time to accrue interest
        _increaseBlock(t0 + request.collectionPeriod + request.duration.div(randomNumber3));

        {
            // pay some amount
            uint256 _toPay = pcl.calculateInterestAccrued(requestId).div(10);
            emit log_named_uint('_toPay', _toPay);
            if (borrowAsset.balanceOf(address(borrower)) < _toPay) {
                uint256 _delta = _toPay.sub(borrowAsset.balanceOf(address(borrower)));
                if (_delta > borrowAsset.balanceOf(address(admin))) {
                    writeTokenBalance(address(admin), request.borrowAsset, _delta);
                }
                admin.transferToken(request.borrowAsset, address(borrower), _delta);
            }
            borrower.setAllowance(pooledCreditLineAddress, request.borrowAsset, _toPay);
            borrower.repay(requestId, _toPay);
            assertTrue(lp.getLenderInterestWithdrawable(requestId, lenders[0].lenderAddress) > 0);
        }

        {
            (, , uint256 _totalInterestRepaid, , ) = pcl.pooledCreditLineVariables(requestId);
            PCLUser _lender = PCLUser(lenders[numLenders - 1].lenderAddress);
            uint256 _prevBalance = borrowAsset.balanceOf(address(_lender));
            _lender.withdrawInterest(requestId);
            uint256 _finalBalance = borrowAsset.balanceOf(address(_lender));
            uint256 _yieldInterestWithdrawnShares = lp.getLenderInfo(requestId, address(_lender)).yieldInterestWithdrawnShares;
            emit log_named_uint('_yieldInterestWithdrawnShares', _yieldInterestWithdrawnShares);
            uint256 _yieldInterest = IYield(request.borrowAssetStrategy).getTokensForShares(
                _yieldInterestWithdrawnShares,
                request.borrowAsset
            );
            uint256 _borrowerInterestWithdrawn = _totalInterestRepaid.mul(lp.balanceOf(address(_lender), requestId)).div(
                lp.totalSupply(requestId)
            );
            if (_yieldInterestWithdrawnShares > 100) {
                // otherwise the delta is too large
                assertApproxEqRel(_yieldInterest.add(_borrowerInterestWithdrawn), _finalBalance.sub(_prevBalance), 1e16);
            }
        }

        // go ahead in time to accrue interest
        _increaseBlock(block.timestamp + BLOCK_TIME.mul(2));

        {
            PCLUser _lender = PCLUser(lenders[0].lenderAddress);
            uint256 _prevBalance = borrowAsset.balanceOf(address(_lender));
            _lender.withdrawInterest(requestId);
            uint256 _curBalance = borrowAsset.balanceOf(address(_lender));
            LenderPool.LenderInfo memory _info = lp.getLenderInfo(requestId, address(_lender));
            uint256 _interest = IYield(request.borrowAssetStrategy).getTokensForShares(
                _info.borrowerInterestSharesWithdrawn.add(_info.yieldInterestWithdrawnShares),
                address(borrowAsset)
            );
            assertApproxEqRel(_interest, _curBalance.sub(_prevBalance), 1e14);
        }

        // go ahead in time to accrue interest
        _increaseBlock(block.timestamp + request.duration.div(randomNumber3));

        // terminate
        {
            uint256 _startBalanceBorrowAsset = borrowAsset.balanceOf(address(admin));
            uint256 _startBalanceCollateralAsset = collateralAsset.balanceOf(address(admin));
            uint256 _collateralTransferred = pcl.calculateTotalCollateralTokens(requestId);
            emit log_named_uint('_collateralTransferred', _collateralTransferred);

            // borrow tokens transferred calculation
            // NOTE: below calculation works only when totalSupply == borrowLimit
            // {
            //     (uint256 _borrowLimit, , , , , , , , , , , ) = pcl.pooledCreditLineConstants(requestId);
            //     assertEq(lp.totalSupply(requestId), _borrowLimit);
            // }
            uint256 _expectedBorrowAssetTransferred;
            {
                (uint256 _sharesHeld, , , , ) = lp.pooledCLVariables(requestId);
                _expectedBorrowAssetTransferred = IYield(request.borrowAssetStrategy).getTokensForShares(_sharesHeld, request.borrowAsset);
            }
            emit log_named_uint('_expectedBorrowAssetTransferred', _expectedBorrowAssetTransferred);

            admin.terminate(requestId);

            //uint256 _endBalanceBorrowAsset = borrowAsset.balanceOf(address(admin));
            //uint256 _endBalanceCollateralAsset = collateralAsset.balanceOf(address(admin));
            assertApproxEqAbs(_collateralTransferred, (collateralAsset.balanceOf(address(admin))).sub(_startBalanceCollateralAsset), 3);
            assertEq(_expectedBorrowAssetTransferred, (borrowAsset.balanceOf(address(admin))).sub(_startBalanceBorrowAsset));
        }

        {
            // token transfer not possible
            PCLUser _lender = PCLUser(lenders[0].lenderAddress);
            // vm.expectRevert not working
            try
                _lender.transferLPTokens(
                    address(lenders[numLenders - 1].lenderAddress),
                    requestId,
                    lp.balanceOf(address(_lender), requestId)
                )
            {
                revert('cannot transfer tokens');
            } catch Error(string memory reason) {
                assertEq(reason, 'LP:IT3');
            }
        }
    }
}",14108
RealWorld_BA_101_PCLNotCreatedStage.t_RealWord_20240827095532.log,101,PCLNotCreatedStage.t,9864,5489,15353,100.0,0.1591,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '../PCLStageTests/PCLNotCreatedStage.t.sol';

contract PCLNotCreatedStageZeroCollateral is PCLNotCreatedStage {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    function setUp() public virtual override {
        PCLParent.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = 0;
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * (10**ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);

        // Create a few lenders
        createMultipleLenders(requestId, 5, uint128(request.minBorrowAmount + 1), request.borrowAsset);

        notCreatedRequestId = requestId + 1;
        assertTrue(pcl.getStatusAndUpdate(notCreatedRequestId) == PooledCreditLineStatus.NOT_CREATED, 'Not Created');
    }
}",402
RealWorld_BA_101_PCLClosedStateCompoundYield.t_RealWord_20240827102726.log,101,PCLClosedStateCompoundYield.t,17127,6057,23184,102.0,0.206775,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '../PCLClosedState.t.sol';
import '../../Helpers/PCLParent.t.sol';

contract PCLClosedStatePriceOracleCompoundYield is PCLClosedStatePriceOracle {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    function setUp() public override {
        PCLParent.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();
        _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));
        _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));

        _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();
        _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));
        _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = compoundYieldAddress;
        request.collateralAssetStrategy = compoundYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        //The below function will create the PCL request and then lenders lend the entire requested amount
        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);
        lender_0 = lenders[0].lenderAddress;

        // Now we assert that we are in the ACTIVE state
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), 2);

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);
        borrower.depositCollateral(requestId, _requiredCollateral, false);

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);
        // and borrows the borrowable amount
        borrower.borrow(requestId, borrowableAmount);

        // Borrower decides to repay everything at mid-duration

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 2);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay the entire debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt);
        borrower.repay(requestId, currentDebt);

        // Now the PCL should be in the CLOSED state
        borrower.close(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed');
    }
}",866
RealWorld_BA_101_MockWETH_RealWord_20240827090316.log,101,MockWETH,10724,4999,15723,87.0,0.1536,"// SPDX-License-Identifier: GNU V3

// Thanks to https://etherscan.io/address/0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2#code for the code

pragma solidity 0.7.6;

import '../interfaces/IWETH9.sol';

contract MockWETH is IWETH9 {
    string public name = 'Wrapped Ether';
    string public symbol = 'WETH';
    uint8 public decimals = 18;

    event Approval(address indexed src, address indexed guy, uint256 wad);
    event Transfer(address indexed src, address indexed dst, uint256 wad);
    event Deposit(address indexed dst, uint256 wad);
    event Withdrawal(address indexed src, uint256 wad);

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    constructor() payable {
        deposit();
    }

    function deposit() public payable override {
        balanceOf[msg.sender] += msg.value;
        emit Deposit(msg.sender, msg.value);
    }

    function withdraw(uint256 wad) public override {
        require(balanceOf[msg.sender] >= wad);
        balanceOf[msg.sender] -= wad;
        msg.sender.transfer(wad);
        emit Withdrawal(msg.sender, wad);
    }

    function totalSupply() public view returns (uint256) {
        return address(this).balance;
    }

    function approve(address guy, uint256 wad) public override returns (bool) {
        allowance[msg.sender][guy] = wad;
        emit Approval(msg.sender, guy, wad);
        return true;
    }

    function transfer(address dst, uint256 wad) public override returns (bool) {
        return transferFrom(msg.sender, dst, wad);
    }

    function transferFrom(
        address src,
        address dst,
        uint256 wad
    ) public returns (bool) {
        require(balanceOf[src] >= wad);

        if (src != msg.sender && allowance[src][msg.sender] != uint256(-1)) {
            require(allowance[src][msg.sender] >= wad);
            allowance[src][msg.sender] -= wad;
        }

        balanceOf[src] -= wad;
        balanceOf[dst] += wad;

        emit Transfer(src, dst, wad);

        return true;
    }
}",499
RealWorld_BA_101_PCLExpiredStage.t_RealWord_20240827100335.log,101,PCLExpiredStage.t,15072,5824,20896,85.0,0.19184,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '../PCLStageTests/PCLExpiredStage.t.sol';

contract PCLExpiredStageZeroCollateral is PCLExpiredStage {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    function setUp() public override {
        PCLParent.setUp();

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = 0;
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 5000 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 3650 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, type(uint256).max);
        if (request.collateralRatio != 0) {
            borrower.depositCollateral(requestId, _requiredCollateral, false);
        }
        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);
        // and borrows the borrowable amount
        borrower.borrow(requestId, borrowableAmount);

        // Borrower decides to repay everything at mid-duration

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 2);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, currentDebt / 2);

        // Now we travel past the duration to the expiration period
        vm.warp(block.timestamp + 100 + request.duration / 2);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');
    }
}",715
RealWorld_BA_101_PCLMaxBorrow.t_RealWord_20240827091049.log,101,PCLMaxBorrow.t,40465,5510,45975,81.0,0.312525,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../SublimeProxy.sol';
import '../../PooledCreditLine/PooledCreditLine.sol';
import '../../PooledCreditLine/LenderPool.sol';
import '../../PriceOracle.sol';
import '../../interfaces/IPriceOracle.sol';
import '../../SavingsAccount/SavingsAccount.sol';
import '../../yield/StrategyRegistry.sol';
import '../../yield/NoYield.sol';
import '../../yield/CompoundYield.sol';
import '../../mocks/MockV3Aggregator.sol';
import '../../mocks/MockToken.sol';
import '../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../interfaces/ISavingsAccount.sol';
import './Helpers/PCLParent.t.sol';

contract PCLMaxBorrow is PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 requestId;

    // enum PooledCreditLineStatus {
    //     NOT_CREATED,
    //     REQUESTED,
    //     ACTIVE,
    //     CLOSED,
    //     EXPIRED,
    //     LIQUIDATED,
    //     CANCELLED
    // }

    function setUp() public override {
        super.setUp();

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = compoundYieldAddress;
        request.collateralAssetStrategy = compoundYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit);
        // increasing by 2% because of precision errors
        //_requiredCollateral = _requiredCollateral.mul(101).div(100);
        admin.transferToken(address(collateralAsset), address(borrower), _requiredCollateral);
        borrower.setAllowance(pooledCreditLineAddress, address(collateralAsset), _requiredCollateral);
        borrower.depositCollateral(requestId, _requiredCollateral, false);
        // calculateBorrowableAmount
        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        // emit log_named_uint('_borrowableAmount', _borrowableAmount);
        // borrow the required amount
        borrower.borrow(requestId, _borrowableAmount);
        // emit log_named_uint('current debt', pcl.calculateCurrentDebt(requestId));
        // emit log_named_uint('principal', pcl.getPrincipal(requestId));
    }

    function test_calculateCurrentRatio() public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        emit log_named_uint('request.collateralRatio', request.collateralRatio);
        emit log_named_uint('_collateralRatio', _collateralRatio);
        assertApproxEqRel(request.collateralRatio, _collateralRatio, 1e16);
    }

    function test_borrowAbleAmount() public {
        uint256 _borrowAble = pcl.calculateBorrowableAmount(requestId);
        // pcl always has 1 unit borrow able even after borrowing everything
        assertTrue(_borrowAble >= 1);
        emit log_named_uint('_borrowAble', _borrowAble);
    }

    function test_borrowOneUint() public {
        uint256 _borrowAble = pcl.calculateBorrowableAmount(requestId);
        vm.expectRevert(bytes('PCL:IWBA1'));
        borrower.borrow(requestId, _borrowAble);
    }

    function test_withdrawableCollateral() public {
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        // because not all tokens were borrowed
        assertTrue(_withdrawableCollateral > 0);
        emit log_named_uint('withdrawableCollateral', _withdrawableCollateral);
    }

    event CollateralSharesWithdrawn(uint256 indexed id, uint256 shares);

    function test_withdrawCollateral() public {
        uint256 _amount = pcl.withdrawableCollateral(requestId);
        uint256 _amountInShares = IYield(request.collateralAssetStrategy).getSharesForTokens(_amount, request.collateralAsset);
        emit log_named_uint('_amountInShares', _amountInShares);
        uint256 _prevBalance = collateralAsset.balanceOf(address(borrower));
        vm.expectEmit(true, true, true, true);
        emit CollateralSharesWithdrawn(requestId, _amountInShares);
        borrower.withdrawCollateral(requestId, _amount, false);
        uint256 _curBalance = collateralAsset.balanceOf(address(borrower));
        emit log_named_uint('withdrawableCollateral', pcl.withdrawableCollateral(requestId));
        assertTrue(pcl.withdrawableCollateral(requestId) <= 1);
    }

    function test_repay() public {
        _increaseBlock(block.timestamp + 1 days);
        borrower.setAllowance(pooledCreditLineAddress, request.borrowAsset, 1);
        uint256 _prevDebt = pcl.calculateCurrentDebt(requestId);
        emit log_named_uint('_prevDebt', _prevDebt);
        borrower.repay(requestId, 1);
        uint256 _curDebt = pcl.calculateCurrentDebt(requestId);
        emit log_named_uint('_curDebt', _curDebt);
        assertTrue(_prevDebt.sub(_curDebt) == 1);
    }

    function test_liquidate() public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        _increaseBlock(block.timestamp + request.duration + request.defaultGracePeriod);
        uint256 _lpBalanceBorrowAsset = ISavingsAccount(savingsAccountAddress).getTotalTokens(lenderPoolAddress, request.borrowAsset);
        uint256 _expectedBorrowAssetTransferred = _lpBalanceBorrowAsset.mul(lp.balanceOf(address(_lender), requestId)).div(
            lp.totalSupply(requestId)
        );
        emit log_named_uint('_expectedBorrowAssetTransferred', _expectedBorrowAssetTransferred);
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        emit log_named_uint('_withdrawableCollateral', _withdrawableCollateral);
        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);
        emit log_named_uint('_collateralTokens', _collateralTokens);
        uint256 _maxCollateralTransferred = _collateralTokens.mul(lp.balanceOf(address(_lender), requestId)).div(lp.totalSupply(requestId));
        emit log_named_uint('_maxCollateralTransferred', _maxCollateralTransferred);
        uint256 _prevBalanceBorrowAsset = borrowAsset.balanceOf(address(_lender));
        uint256 _prevBalanceCollateralAsset = collateralAsset.balanceOf(address(_lender));
        _lender.liquidate(requestId, true);
        uint256 _finalBalanceBorrowAsset = borrowAsset.balanceOf(address(_lender));
        uint256 _finalBalanceCollateralAsset = collateralAsset.balanceOf(address(_lender));
        // no principal left to withdraw
        emit log_named_uint('_prevBalanceBorrowAsset', _prevBalanceBorrowAsset);
        emit log_named_uint('_finalBalanceBorrowAsset', _finalBalanceBorrowAsset);
        assertApproxEqRel(_finalBalanceBorrowAsset.sub(_prevBalanceBorrowAsset), _expectedBorrowAssetTransferred, 1e14);
        emit log_named_uint('actual collateral transferred', _finalBalanceCollateralAsset.sub(_prevBalanceCollateralAsset));
        assertTrue(_finalBalanceCollateralAsset.sub(_prevBalanceCollateralAsset) <= _maxCollateralTransferred);
    }

    event InterestWithdrawn(uint256 indexed id, address indexed user, uint256 shares);

    function test_withdrawInterest(uint256 fractionOfRepaymentAmount) public {
        uint256 size = 10000;
        if (fractionOfRepaymentAmount == 0) {
            fractionOfRepaymentAmount = size - 1;
        }
        PCLUser _lender1 = PCLUser(lenders[0].lenderAddress);
        PCLUser _lender2 = PCLUser(lenders[1].lenderAddress);
        PCLUser _lender3 = PCLUser(lenders[3].lenderAddress);
        fractionOfRepaymentAmount = fractionOfRepaymentAmount % size;
        _increaseBlock(block.timestamp + BLOCK_TIME * 10);

        uint256 _interestAmount = pcl.calculateInterestAccrued(requestId);
        uint256 _toRepay = _interestAmount.mul(fractionOfRepaymentAmount).div(size);
        if (_toRepay == 0) return;
        borrower.setAllowance(pooledCreditLineAddress, request.borrowAsset, _toRepay);
        borrower.repay(requestId, _toRepay);
        vm.expectEmit(true, true, false, false);
        emit InterestWithdrawn(requestId, address(_lender1), 0);
        _lender1.withdrawInterest(requestId);

        _increaseBlock(block.timestamp + BLOCK_TIME);
        vm.expectEmit(true, true, false, false);
        emit InterestWithdrawn(requestId, address(_lender2), 0);
        _lender2.withdrawInterest(requestId);

        _increaseBlock(block.timestamp + BLOCK_TIME);
        vm.expectEmit(true, true, false, false);
        emit InterestWithdrawn(requestId, address(_lender3), 0);
        _lender3.withdrawInterest(requestId);
    }

    function test_terminate() public {
        uint256 _startBalanceBorrowAsset = borrowAsset.balanceOf(address(admin));
        uint256 _startBalanceCollateralAsset = collateralAsset.balanceOf(address(admin));
        uint256 _collateralTransferred = pcl.calculateTotalCollateralTokens(requestId);
        emit log_named_uint('_collateralTransferred', _collateralTransferred);
        admin.terminate(requestId);
        uint256 _endBalanceBorrowAsset = borrowAsset.balanceOf(address(admin));
        uint256 _endBalanceCollateralAsset = collateralAsset.balanceOf(address(admin));
        assertApproxEqRel(_collateralTransferred, _endBalanceCollateralAsset.sub(_startBalanceCollateralAsset), 1e16);
        assertTrue(_endBalanceBorrowAsset.sub(_startBalanceBorrowAsset) >= 1);
    }
}",2359
RealWorld_BA_101_ProtocolFeeCollector_RealWord_20240827090826.log,101,ProtocolFeeCollector,5350,4311,9661,58.0,0.11297,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

import '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';
import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/utils/ReentrancyGuard.sol';
import '@openzeppelin/contracts-upgradeable/proxy/Initializable.sol';
import '@openzeppelin/contracts-upgradeable/token/ERC20/ERC20PausableUpgradeable.sol';

contract ProtocolFeeCollector is ReentrancyGuard, OwnableUpgradeable {
    function initialize(address _owner) external initializer {
        OwnableUpgradeable.__Ownable_init();
        OwnableUpgradeable.transferOwnership(_owner);
    }
}",168
RealWorld_BA_101_Constants_RealWord_20240827090707.log,101,Constants,26679,5590,32269,77.0,0.245195,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/utils/ReentrancyGuard.sol';
import '@openzeppelin/contracts-upgradeable/proxy/Initializable.sol';
import '@openzeppelin/contracts-upgradeable/token/ERC20/ERC20PausableUpgradeable.sol';

library Constants {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    address constant wethGateway = 0xcc9a0B7c43DC2a5F023Bb9b738E45B0Ef6B06E04;
    address constant aaveProtocolDataProvider = 0x057835Ad21a177dbdd3090bB1CAE03EaCF78Fc6d;
    address constant aaveLendingPoolAddressesProvider = 0xB53C1a33016B2DC2fF3653530bfF1848a515c8c5;

    // Price feed addresses
    // We'll be creating price feeds for:-
    // 1. WETH / USDC
    // 2. WBTC / WETH
    // 3. WBTC / DAI
    address constant DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;
    address constant USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;
    address constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
    address constant WBTC = 0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599;
    address constant SHIB = 0x95aD61b0a150d79219dCF64E1E6Cc01f0B64C4cE;
    address constant BAT = 0x0D8775F648430679A709E98d2b0Cb6250d2887EF;

    // Chainlink base feeds against USD
    address constant ETH_priceFeedChainlink = 0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419;
    address constant WBTC_priceFeedChainlink = 0xF4030086522a5bEEa4988F8cA5B36dbC97BeE88c;
    address constant DAI_priceFeedChainlink = 0xAed0c38402a5d19df6E4c03F4E2DceD6e29c1ee9;
    address constant USDC_priceFeedChainlink = 0x8fFfFfd4AfB6115b954Bd326cbe7B4BA576818f6;

    address constant USDC_ETH_priceFeedUniswap = 0x88e6A0c2dDD26FEEb64F039a2c41296FcB3f5640;
    address constant WBTC_WETH_priceFeedUniswap = 0xCBCdF9626bC03E24f779434178A73a0B4bad62eD;
    address constant WBTC_DAI_priceFeedUniswap = 0x391E8501b626C623d39474AfcA6f9e46c2686649; //has low liquidity

    address public constant ethUsdcPool = 0x8ad599c3A0ff1De082011EFDDc58f1908eb6e6D8;

    IERC20 constant dai = IERC20(DAI);
    IERC20 constant usdc = IERC20(USDC);
    IERC20 constant weth = IERC20(WETH);
    IERC20 constant wbtc = IERC20(WBTC);
    IERC20 constant shib = IERC20(SHIB);

    uint256 constant USD_decimals = 10**6; // USDC precision decimals
    uint256 constant BTC_decimals = 10**8; // WBTC precision decimals
    uint256 constant DAI_decimals = 10**18; // DAI precision decimals
    uint256 constant WETH_decimals = 10**18; // WETH precision decimals
    uint256 constant SHIB_decimals = 10**18; // SHIB precision decimals

    uint256 constant WAD = 10**18;
    uint256 constant RAY = 10**27;

    uint256 constant verificationActivationDelay = 0;
    uint256 public constant maxStrategies = 10;

    address public constant COMPTROLLER = 0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B;
    address public constant cETH = 0x4Ddc2D193948926D02f9B1fE9e1daa0718270ED5;
    address public constant cUSDC = 0x39AA39c021dfbaE8faC545936693aC917d5E7563;
    address public constant cDAI = 0x5d3a536E4D6DbD6114cc1Ead35777bAB948E3643;
    address public constant cWBTC = 0xccF4429DB6322D5C611ee964527D42E5d685DD6a;

    address public constant weth9 = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
    address public constant _wethGateway = 0xcc9a0B7c43DC2a5F023Bb9b738E45B0Ef6B06E04;
    address public constant _protocolDataProvider = 0x057835Ad21a177dbdd3090bB1CAE03EaCF78Fc6d;
    address public constant _lendingPoolAddressesProvider = 0xB53C1a33016B2DC2fF3653530bfF1848a515c8c5;
    address public constant _treasuryAddress = 0xC055b964a32B8275F41A1521fA9A4AbfE0eC5F09;

    uint128 public constant CHAINLINK_HEARTBEAT = type(uint128).max;
}",1445
RealWorld_BA_101_PCLTerminatedStage.t_RealWord_20240827093102.log,101,PCLTerminatedStage.t,23144,5580,28724,77.0,0.22732,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';

import '../Helpers/PCLParent.t.sol';
import './PCLNotCreatedStage.t.sol';

contract PCLTerminatedStage is PCLNotCreatedStage {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    function setUp() public virtual override {
        PCLParent.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * (10**ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');

        // Now let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), collateralToDeposit);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_timeWarp(block.timestamp + request.duration / 2);

        // Borrower makes their first repayment (Entire pending interest + part of principal)
        {
            uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);
            admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);
            borrower.setAllowance(address(pcl), address(borrowAsset), interestAccrued + 10);
            borrower.repay(requestId, interestAccrued + 10);
        }

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        admin.terminate(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED, '!Terminated');
        notCreatedRequestId = requestId;
    }

    function test_lenderCannotLiquidateANotCreatedPCL() public override {
        assert_liquidate_functionality_in_notCreated_state(
            notCreatedRequestId,
            PCLUser(lenders[0].lenderAddress),
            'Lender cannot liquidate a notCreated PCL',
            'PCL:L1'
        );
    }

    function test_lenderCannotWithdrawLiquidation_notcreatedState() public override {
        assert_withdraw_liquidation_in_notcreated_state(
            notCreatedRequestId,
            PCLUser(lenders[0].lenderAddress),
            'Cannot withdraw liquidation/liquidity from a notcreated PCL',
            'LP:IWLC1'
        );
    }

    function test_lenderCannotWithdrawLiquidityFromANotCreatedPCL() public override {
        assert_withdraw_liquidity_functionality_in_NotCreated_state(
            notCreatedRequestId,
            PCLUser(lenders[0].lenderAddress),
            uint256(PooledCreditLineStatus.NOT_CREATED),
            false,
            'Lender cannot withdraw liquidity a PCL in NotCreated state',
            'LP:IWL3'
        );
    }
}",1274
RealWorld_BA_101_PCLActiveStage.t_RealWord_20240827095715.log,101,PCLActiveStage.t,9421,5792,15213,83.0,0.162945,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '../PCLStageTests/PCLActiveStage.t.sol';

contract PCLActiveStageZeroCollateral is PCLActiveStage {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    function setUp() public override {
        PCLParent.setUp();

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = 0;
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * (10**ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!ACTIVE');
    }
}",341
RealWorld_BA_101_PCLClosedStage.t_RealWord_20240827093436.log,101,PCLClosedStage.t,14502,5831,20333,92.0,0.18913,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '../PCLClosedStage.t.sol';

contract PCLClosedStageCollateralCompoundBorrowNoYield is PCLClosedStage {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    function setUp() public override {
        PCLParent.setUp();

        request.borrowLimit = uint128(1_000_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * 1e18) / 1e2);
        request.collateralRatio = 1e18;
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * 1e18) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = compoundYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        // The below function will create the PCL request and then lenders lend the entire requested amount
        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        // Now we assert that we are in the ACTIVE state
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), 2);

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);
        borrower.depositCollateral(requestId, _requiredCollateral, false);

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);
        // And borrows the borrowable amount
        borrower.borrow(requestId, borrowableAmount);

        // Borrower decides to repay everything at mid-duration

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 2);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay the entire debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt);
        borrower.repay(requestId, currentDebt);

        // Now the PCL should be in the CLOSED state
        borrower.close(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED);
    }
}",684
RealWorld_BA_101_PCLLiquidatedState.t_RealWord_20240827101648.log,101,PCLLiquidatedState.t,113050,6083,119133,110.0,0.68691,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';

import '../Helpers/PCLParent.t.sol';

contract PCLLiquidatedStatePriceOracle is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 _borrowAssetDecimals;
    uint256 _collateralAssetDecimals;
    uint128 _collateralAssetPriceMin;
    uint128 _borrowAssetPriceMin;
    uint128 _collateralAssetPriceMax;
    uint128 _borrowAssetPriceMax;
    uint256 requestId;
    uint256 _fromUserPoolTokenSupply;
    uint256 _toUserPoolTokenSupply;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;
    uint256 _calculatedCurrentDebt;
    uint256 _fetchedCurrentDebt;
    address lender_0;

    function setUp() public virtual override {
        super.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();
        _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));
        _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));

        _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();
        _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));
        _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        //The below function will create the PCL request and then lenders lend the entire requested amount
        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);
        lender_0 = lenders[0].lenderAddress;

        // Now we assert that we are in the ACTIVE state
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), 2);

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);
        borrower.depositCollateral(requestId, _requiredCollateral, false);

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);
        // and borrows the borrowable amount
        borrower.borrow(requestId, borrowableAmount);

        // Borrower decides to repay everything at mid-duration

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 2);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay the entire debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt / 200);
        borrower.repay(requestId, currentDebt / 200);

        // Now we travel past the expiration date
        vm.warp(block.timestamp + request.duration + request.defaultGracePeriod);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');

        // Now the PCL should be in the LIQUIDATED state
        PCLUser(lender_0).liquidate(requestId, false);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
    }

    // Test 0: Test SetUp
    function test_setUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED, '!Liquidated');

        (, int256 _borrowAssetPrice, , , ) = MockV3Aggregator(borrowAssetAggregatorAddress).latestRoundData();
        (, int256 _collateralAssetPrice, , , ) = MockV3Aggregator(collateralAssetAggregatorAddress).latestRoundData();

        // Checking out what are the prices
        log_named_int('Borrow Asset Price', _borrowAssetPrice);
        log_named_int('Collateral Asset Price', _collateralAssetPrice);

        // Check the prices of the borrowAsset and collateralAsset are non-zero
        assertGt(_borrowAssetPrice, 0);
        assertGt(_collateralAssetPrice, 0);
    }

    // Test 1: A Liquidated PCL cannot be started even with price fluctuations
    function test_pclCannotBeStarted(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try borrower.start(requestId) {
            revert('Cannot start a PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S1');
        }
    }

    // Test 2: Collateral cannot be deposited
    function test_collateralCannotBeDeposited(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        try borrower.depositCollateral(requestId, _minimumCollateralRequired, false) {
            revert('Collateral cannot be deposited');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:DC2');
        }
    }

    // Test 3: Withdrawable collateral is zero (since in this case, total collateral remaining < collateral to liquidate)
    function test_withdrawableCollateralIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        assertApproxEqAbs(_withdrawableCollateral, 0, 2);
    }

    // Test 3: Withdrawable collateral is non-zero if total collateral remaining > collateral to liquidate
    function test_withdrawableCollateralIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);
        lender_0 = lenders[0].lenderAddress;

        uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral * 2);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
        borrower.depositCollateral(_requestId, _requiredCollateral * 2, false);
        uint256 _borrowableAmount = borrower.calculateBorrowableAmount(_requestId);
        borrower.borrow(_requestId, _borrowableAmount);
        vm.warp(block.timestamp + request.duration / 2);
        uint256 _currentDebt = borrower.calculateCurrentDebt(_requestId);
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);
        borrower.repay(_requestId, _currentDebt / 2);
        vm.warp(block.timestamp + request.duration + request.defaultGracePeriod);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');

        PCLUser(lender_0).liquidate(_requestId, false);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.LIQUIDATED);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(_requestId);
        assertGt(_withdrawableCollateral, 0);
    }

    // Test 3.2: Collateral can or cannot be withdrawn
    function test_collateralCanOrCannotBeWithdrawn(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        uint256 _tokens = (pcl.depositedCollateralInShares(requestId) * ICToken(collateralCTokenAddress).exchangeRateCurrent()) / 1e18;
        if (_tokens > 0) {
            uint256 _borrowerBalanceBefore = collateralAsset.balanceOf(address(borrower));
            borrower.withdrawCollateral(requestId, 1, false);
            uint256 _borrowerBalanceAfter = collateralAsset.balanceOf(address(borrower));
            assertGe(_borrowerBalanceAfter, _borrowerBalanceBefore);
        } else {
            try borrower.withdrawCollateral(requestId, 1, false) {
                revert('Collateral cannot be withdrawn');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:WC1');
            }
        }
    }

    // Test 3.3: All collateral can or cannot be withdrawn
    function test_allCollateralCanOrCannotBeWithdrawn(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        uint256 _tokens = (pcl.depositedCollateralInShares(requestId) * ICToken(collateralCTokenAddress).exchangeRateCurrent()) / 1e18;
        if (_tokens > 0) {
            uint256 _borrowerBalanceBefore = collateralAsset.balanceOf(address(borrower));
            borrower.withdrawAllCollateral(requestId, false);
            uint256 _borrowerBalanceAfter = collateralAsset.balanceOf(address(borrower));
            assertGe(_borrowerBalanceAfter, _borrowerBalanceBefore);
        } else {
            try borrower.withdrawAllCollateral(requestId, false) {
                revert('All collateral cannot be withdrawn');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:WAC1');
            }
        }
    }

    // Test 4: Required collateral decreases if collateral asset price increases
    function test_requiredCollateralDecreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertGt(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 4.1: Required collateral increases if borrow asset price increases
    function test_requiredCollateralIncreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertLt(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 4.2: Required collateral increases if collateral asset price decreases
    function test_requiredCollateralIncreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertLt(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 4.3: Required collateral decreases if borrow asset price decreases
    function test_requiredCollateralDecreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertGt(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 4.4: Required collateral reverts if borrow asset price decreases to 0
    function test_requiredCollateralRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);

        try pcl.getRequiredCollateral(requestId, request.borrowLimit / 2) {
            revert('Required collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 4.5: Required collateral reverts if collateral asset price decreases to 0
    function test_requiredCollateralRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);

        try pcl.getRequiredCollateral(requestId, request.borrowLimit / 2) {
            revert('Required collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 5: Borrowable amount remains zero
    function test_borrowableAmountIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);

        assertEq(_borrowableAmount, 0);
    }

    // Test 6: A Liquidated PCL cannot be closed
    function test_pclCannotBeClosed(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try borrower.close(requestId) {
            revert('PCL cannot be closed');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C1');
        }
    }

    // Test 7: Collateral ratio remains zero
    function test_collateralRatioRemainsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);
        assertApproxEqAbs(_collateralRatioNew / 1e16, 0, 9);
    }

    // Test 7.1: Collateral ratio reverts if borrow asset price decreases to 0
    function test_collateralRatioRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);

        try pcl.calculateCurrentCollateralRatio(requestId) {
            revert('Collateral ratio should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 7.2: Collateral ratio reverts if collateral asset price decreases to 0
    function test_collateralRatioRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);

        try pcl.calculateCurrentCollateralRatio(requestId) {
            revert('Collateral ratio should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 8: Lenders can withdraw liquidation
    function test_lendersCanWithdrawLiquidation(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        uint256 _userPoolTokenBalance = lp.balanceOf(address(lender_0), requestId);
        uint256 _lenderInterestOwed = PCLUser(lender_0).getLenderInterest(requestId, lender_0);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        uint256 _userBorrowTokenBalanceBefore = IERC20(request.borrowAsset).balanceOf(address(lender_0));
        uint256 _userCollateralTokenBalanceBefore = IERC20(request.collateralAsset).balanceOf(address(lender_0));
        PCLUser(lender_0).withdrawLiquidation(requestId);
        uint256 _userBorrowTokenBalanceAfter = IERC20(request.borrowAsset).balanceOf(address(lender_0));
        uint256 _userCollateralTokenBalanceAfter = IERC20(request.collateralAsset).balanceOf(address(lender_0));
        assertGt(_userPoolTokenBalance + _lenderInterestOwed, _userBorrowTokenBalanceAfter - _userBorrowTokenBalanceBefore);
        assertGt(_userCollateralTokenBalanceAfter - _userCollateralTokenBalanceBefore, 0);
        _userPoolTokenBalance = lp.balanceOf(address(lender_0), requestId);
        assertEq(_userPoolTokenBalance, 0);
    }

    // Test 9: Lenders cannot withdraw liquidity
    function test_lendersCannotWithdrawLiquidity(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try PCLUser(lender_0).withdrawLiquidity(requestId) {
            revert('Lender cannot withdraw liquidity');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL2');
        }
    }

    // Test 10: A Liquidated PCL cannot be liquidated
    function test_lendersCannotLiquidate(
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed,
        bool _withdraw
    ) public {
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // lender_0 tries to liquidate the PCL
        try PCLUser(lender_0).liquidate(requestId, _withdraw) {
            revert('Cannot liquidate a Liquidated PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L2');
        }
    }

    // Test 11: Admin can terminate pcl
    function test_adminCanTerminatePCL(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        admin.terminate(requestId);
        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0);
        assertGt(_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate, 0);
    }

    // Test 12: Pool token transfers should be possible
    function test_poolTokenTransfersShouldBePossibleEntireBalance(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);

        //Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, 0);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == 0);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));
    }

    // Test 12.1: Pool token transfers should be possible
    function test_poolTokenTransfersShouldBePossiblePartialBalance(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed)
        public
    {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 13: Interest can be withdrawn amidst price fluctuations
    function test_lendersCanWithdrawInterest(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender0Balance = borrowAsset.balanceOf(address(lender0));

        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender1Balance = borrowAsset.balanceOf(address(lender1));

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lender0.getLenderInterest(requestId, address(lender0));
        uint256 lender1InterestOwed = lender1.getLenderInterest(requestId, address(lender1));

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        lender1.withdrawInterest(requestId);
        uint256 lender1BalanceAfter = borrowAsset.balanceOf(address(lender1));
        assertEq(lender1BalanceAfter, lender1Balance + lender1InterestOwed);
        assertEq(lender1.getLenderInterest(requestId, address(lender1)), 0);
    }

    // Test 14: A Liquidated PCL cannot be cancelled
    function test_pclCannotBeCancelled(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try borrower.cancelRequest(requestId) {
            revert('PCL cannot be cancelled');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    function assert_helperFunctionalitiesInLiquidatedState(
        uint256 _id,
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed
    ) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 1. calculateCurrentCollateralRatio
        {
            uint256 _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);
            assertApproxEqAbs(_currentCR1 / 1e16, 0, 9);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 2. calculatePrincipalWithdrawable
        {
            uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
            assertGe(_principalWithdrawable, 0); // Since the lenders can withdraw their liquidity from a closed PCL
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 3. withdrawableCollateral
        {
            uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
            assertApproxEqAbs(_withdrawableCollateral, 0, 2);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 4. calculateCurrentDebt
        {
            uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);
            assertGt(_currentDebt, 0);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 5. calculateBorrowableAmount
        {
            uint256 _borrowable = _borrower.calculateBorrowableAmount(_id);
            assertEq(_borrowable, 0);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 6. calculateTotalCollateralTokens
        {
            uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
            assertApproxEqAbs(_totalCollateral, 0, 2);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 7. collateralTokensToLiquidate
        {
            uint256 _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
            assertGt(_equivalentCollateral, 0);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 8. calculateInterestAccrued
        {
            uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
            assertGt(_interestAccrued, 0);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.LIQUIDATED);
    }

    function test_helperFunctionsInLiquidatedState(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        assert_helperFunctionalitiesInLiquidatedState(requestId, _borrowAssetPriceSeed, _collateralAssetPriceSeed);
    }
}",7030
RealWorld_BA_101_GovernanceTester_RealWord_20240827090150.log,101,GovernanceTester,5289,4918,10207,84.0,0.124805,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

contract GovernanceTester {
    address public gov;
    uint256 public value;

    event valueUpdated(address indexed governance, address indexed sender, uint256 v);

    modifier onlyGov() {
        require(msg.sender == gov, 'GT:OG1');
        _;
    }

    constructor(address _gov, uint256 _val) {
        gov = _gov;
        value = _val;
    }

    function update(uint256 _value) public onlyGov {
        value = _value;
        emit valueUpdated(gov, msg.sender, _value);
    }
}",131
RealWorld_BA_101_PCLUser.t_RealWord_20240827101354.log,101,PCLUser.t,24943,6071,31014,89.0,0.246135,"//SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '../../roles/User.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '../../../Verification/Verification.sol';
import '../../../mocks/MockAdminVerifier.sol';

contract PCLUser is IPooledCreditLineDeclarations, User {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    PooledCreditLine pcl;
    LenderPool lp;

    constructor(address _pclAddress, address _lpAddress) {
        pcl = PooledCreditLine(_pclAddress);
        lp = LenderPool(_lpAddress);
    }

    function updatePCL(address _pclAddress) public {
        pcl = PooledCreditLine(_pclAddress);
    }

    function updateLP(address _lpAddress) public {
        lp = LenderPool(_lpAddress);
    }

    function registerSelf(address _verifier) public {
        MockAdminVerifier verifier = MockAdminVerifier(payable(_verifier));
        verifier.registerSelf();
    }

    /******************************************************************************
     ******* PCL Borrower-specific functions **************************************
     ******************************************************************************/

    function createRequest(Request memory _request) public returns (uint256) {
        uint256 _id = pcl.request(_request);
        return _id;
    }

    function cancelRequest(uint256 _id) public {
        pcl.cancelRequest(_id);
    }

    function depositCollateral(
        uint256 _id,
        uint256 _amount,
        bool _fromSavingsAccount
    ) public {
        pcl.depositCollateral(_id, _amount, _fromSavingsAccount);
    }

    function withdrawCollateral(
        uint256 _id,
        uint256 _amount,
        bool _toSavingsAccount
    ) public {
        pcl.withdrawCollateral(_id, _amount, _toSavingsAccount);
    }

    function withdrawAllCollateral(uint256 _id, bool _toSavingsAccount) public {
        pcl.withdrawAllCollateral(_id, _toSavingsAccount);
    }

    function borrow(uint256 _id, uint256 _amount) public {
        pcl.borrow(_id, _amount);
    }

    function repay(uint256 _id, uint256 _amount) public {
        pcl.repay(_id, _amount);
    }

    function close(uint256 _id) public {
        pcl.close(_id);
    }

    function calculateTotalCollateralTokens(uint256 _id) public returns (uint256) {
        return pcl.calculateTotalCollateralTokens(_id);
    }

    function getRequiredCollateral(uint256 _id, uint256 _amount) public view returns (uint256) {
        return pcl.getRequiredCollateral(_id, _amount);
    }

    function calculateBorrowableAmount(uint256 _id) public returns (uint256) {
        return pcl.calculateBorrowableAmount(_id);
    }

    function calculateInterestAccrued(uint256 _id) public view returns (uint256) {
        return pcl.calculateInterestAccrued(_id);
    }

    function withdrawableCollateral(uint256 _id) public returns (uint256) {
        return pcl.withdrawableCollateral(_id);
    }

    function calculateCurrentDebt(uint256 _id) public view returns (uint256) {
        return pcl.calculateCurrentDebt(_id);
    }

    function getPrincipal(uint256 _id) public view {
        pcl.getPrincipal(_id);
    }

    function getStatus(uint256 _id) public returns (PooledCreditLineStatus) {
        return pcl.getStatusAndUpdate(_id);
    }

    function calculateCurrentCollateralRatio(uint256 _id) public returns (uint256) {
        return pcl.calculateCurrentCollateralRatio(_id);
    }

    /******************************************************************************
     ******* End of PCL Borrower-specific functions *******************************
     ******************************************************************************/

    /******************************************************************************
     ******* PCL Lender-specific functions ****************************************
     ******************************************************************************/

    function start(uint256 _id) public {
        lp.start(_id);
    }

    function lend(uint256 _id, uint256 _amount) public {
        lp.lend(_id, _amount);
    }

    function liquidate(uint256 _id, bool _withdraw) public {
        lp.liquidate(_id, _withdraw);
    }

    function withdrawTokensAfterLiquidation(uint256 _id) public {
        lp.withdrawTokensAfterLiquidation(_id);
    }

    function withdrawInterest(uint256 _id) public {
        lp.withdrawInterest(_id);
    }

    function withdrawLiquidity(uint256 _id) public {
        lp.withdrawLiquidity(_id);
    }

    function withdrawLiquidation(uint256 _id) public {
        lp.withdrawTokensAfterLiquidation(_id);
    }

    function calculatePrincipalWithdrawable(uint256 _id, address _lender) public returns (uint256) {
        return lp.calculatePrincipalWithdrawable(_id, _lender);
    }

    function transferLPTokens(
        address _to,
        uint256 _id,
        uint256 _amount
    ) public {
        bytes memory emptyBytes;
        lp.safeTransferFrom(address(this), _to, _id, _amount, emptyBytes);
    }

    function getLenderInterest(uint256 _id, address _lender) public returns (uint256) {
        uint256 interest = lp.getLenderInterestWithdrawable(_id, _lender);
        return interest;
    }

    /******************************************************************************
     ******* End of PCL Lender-specific functions **********************
     *******************************************************************************/

    /******************************************************************************
     ******* PCL invalid functions **********************
     *******************************************************************************/

    function accept(uint256 _id, uint256 _amount) public {
        pcl.accept(_id, _amount, address(this));
    }

    function cancelRequestOnLowCollection(uint256 _id) public {
        pcl.cancelRequestOnLowCollection(_id);
    }

    function collateralTokensToLiquidate(uint256 _id, uint256 _borrowTokens) public view returns (uint256) {
        return pcl.getEquivalentCollateralTokens(_id, _borrowTokens);
    }

    // To check for failure scenarios, can't be invoked in general
    function noAccessLiquidate(uint256 _id) public {
        pcl.liquidate(_id);
    }

    function terminate(uint256 _id) public {
        pcl.terminate(_id);
    }

    /******************************************************************************
     ******* END PCL invalid functions **********************
     *******************************************************************************/
}",1370
RealWorld_BA_101_MockVerification_RealWord_20240827085109.log,101,MockVerification,5085,5093,10178,76.0,0.127285,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

contract MockVerification {
    mapping(address => mapping(address => bool)) public isUser;

    function addUser(address _user, address _verifier) external {
        isUser[_user][_verifier] = true;
    }

    function removeUser(address _user, address _verifier) external {
        delete isUser[_user][_verifier];
    }
}",89
RealWorld_BA_101_PCLActiveState.t_RealWord_20240827102305.log,101,PCLActiveState.t,0,0,0,,0.0,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';

import '../Helpers/PCLParent.t.sol';

contract PCLActiveStatePriceOracle is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 _borrowAssetDecimals;
    uint256 _collateralAssetDecimals;
    uint128 _collateralAssetPriceMin;
    uint128 _borrowAssetPriceMin;
    uint128 _collateralAssetPriceMax;
    uint128 _borrowAssetPriceMax;
    uint256 requestId;
    uint256 _fromUserPoolTokenSupply;
    uint256 _toUserPoolTokenSupply;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;
    uint256 _calculatedCurrentDebt;
    uint256 _fetchedCurrentDebt;

    function setUp() public virtual override {
        super.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();
        _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));
        _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));

        _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();
        _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));
        _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');
    }

    // Test 0: Test SetUp
    function test_setUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        (, int256 _borrowAssetPrice, , , ) = MockV3Aggregator(borrowAssetAggregatorAddress).latestRoundData();
        (, int256 _collateralAssetPrice, , , ) = MockV3Aggregator(collateralAssetAggregatorAddress).latestRoundData();

        // Checking out what are the prices
        log_named_int('Borrow Asset Price', _borrowAssetPrice);
        log_named_int('Collateral Asset Price', _collateralAssetPrice);

        // Check the prices of the borrowAsset and collateralAsset are non-zero
        assertGt(_borrowAssetPrice, 0);
        assertGt(_collateralAssetPrice, 0);
    }

    // Test 1: An active PCL cannot be started even with price fluctuations
    function test_pclCannotBeStarted(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try borrower.start(requestId) {
            revert('Cannot start an Active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S1');
        }
    }

    // Test 2: Collateral can be deposited
    function test_collateralCanBeDeposited(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        assertGt(pcl.depositedCollateralInShares(requestId), 0);
    }

    // Test 3: Withdrawable collateral decreases if collateral asset price decreases
    function test_withdrawableCollateralDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertGt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.1: Withdrawable collateral decreases if borrow asset price increases
    function test_withdrawableCollateralDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertGt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.2: Withdrawable collateral increases if collateral asset price increases
    function test_withdrawableCollateralIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertLt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.3: Withdrawable collateral increases if borrow asset price decreases
    function test_withdrawableCollateralIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertLt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.4: Withdrawable collateral reverts if borrow asset price decreases to 0
    function test_withdrawableCollateralRevertsIfBorrowAssetPriceDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try pcl.withdrawableCollateral(requestId) {
            revert('Withdrawable collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 3.5: Withdrawable collateral reverts if collateral asset price decreases to 0
    function test_withdrawableCollateralRevertsIfCollateralAssetPriceDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try pcl.withdrawableCollateral(requestId) {
            revert('Withdrawable collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 4: Withdraw collateral reverts if collateral asset price decreases
    function test_withdrawCollateralRevertsIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC1');
        }
    }

    // Test 4.1: Withdraw collateral reverts if borrow asset price increases
    function test_withdrawCollateralRevertsIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC1');
        }
    }

    // Test 4.2: Withdraw collateral works if collateral asset price increases
    function test_withdrawCollateralWorksIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);
    }

    // Test 4.3: Withdraw collateral works if borrow asset price decreases
    function test_withdrawCollateralWorksIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);
    }

    // Test 4.4: Withdraw collateral reverts if borrow asset price decreases to 0
    function test_withdrawCollateralRevertsIfBorrowAssetPriceDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 4.5: Withdraw collateral reverts if collateral asset price decreases to 0
    function test_withdrawCollateralRevertsIfCollateralAssetPriceDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 5: An active PCL (with principal == 0) can be closed even with price fluctuations
    function test_pclCanBeClosedIfPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        borrower.close(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed');
    }

    // Test 5.1: An active PCL (with principal != 0) cannot be closed even with price fluctuations
    function test_pclCannotBeClosedPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');

        // Now let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        // Price fluctuations take place
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try borrower.close(requestId) {
            revert('Cannot close PCL when principal != 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C2');
        }
    }

    // Test 6: Required collateral decreases if collateral asset price increases
    function test_requiredCollateralDecreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertGt(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 6.1: Required collateral increases if borrow asset price increases
    function test_requiredCollateralIncreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertLt(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 6.2: Required collateral increases if collateral asset price decreases
    function test_requiredCollateralIncreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertLt(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 6.3: Required collateral decreases if borrow asset price decreases
    function test_requiredCollateralDecreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertGt(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 6.4: Required collateral reverts if borrow asset price decreases to 0
    function test_requiredCollateralRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try pcl.getRequiredCollateral(requestId, request.borrowLimit / 2) {
            revert('Required collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 6.5: Required collateral reverts if collateral asset price decreases to 0
    function test_requiredCollateralRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try pcl.getRequiredCollateral(requestId, request.borrowLimit / 2) {
            revert('Required collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 7: Collateral ratio decreases if collateral asset price decreases
    function test_collateralRatioDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertGt(_collateralRatio, _collateralRatioNew);
    }

    // Test 7.1: Collateral ratio decreases if borrow asset price increases
    function test_collateralRatioDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertGt(_collateralRatio, _collateralRatioNew);
    }

    // Test 7.2: Collateral ratio increases if collateral asset price increases
    function test_collateralRatioIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, _collateralRatioNew);
    }

    // Test 7.3: Collateral ratio increases if borrow asset price decreases
    function test_collateralRatioIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, _collateralRatioNew);
    }

    // Test 7.4: Collateral ratio reverts if borrow asset price decreases to 0
    function test_collateralRatioRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try pcl.calculateCurrentCollateralRatio(requestId) {
            revert('Collateral ratio should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 7.5: Collateral ratio reverts if collateral asset price decreases to 0
    function test_collateralRatioRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try pcl.calculateCurrentCollateralRatio(requestId) {
            revert('Collateral ratio should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 8: Lenders cannot withdraw liquidation from an ACTIVE pcl
    function test_lendersCannotWithdrawLiquidation(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try _lender0.withdrawLiquidation(requestId) {
            revert('Cannot withdraw liquidation from an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    // Test 9: Lenders cannot withdraw liquidity from an ACTIVE pcl
    function test_lendersCannotWithdrawLiquidity(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try _lender0.withdrawLiquidity(requestId) {
            revert('Cannot withdraw liquidity from an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL3');
        }
    }

    // Test 10: An active PCL cannot be liquidated if principal == 0
    function test_lendersCannotLiquidateIfPrincipalIsZero(
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed,
        bool _withdraw
    ) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // _lender0 tries to liquidate the PCL
        try _lender0.liquidate(requestId, _withdraw) {
            revert('Cannot liquidate an Active PCL with principal == 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L1');
        }
    }

    // Test 10.1: An active PCL with principal != 0 can or cannot be liquidated
    function test_lendersCanOrCannotLiquidate(
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed,
        bool _withdraw
    ) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        // Relative price fluctuations
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
        uint256 _currentCollateralRatio = pcl.calculateTotalCollateralTokens(requestId).mul(_ratioOfPrices).div(_currentDebt).mul(1e18).div(
            10**_decimals
        );

        if (_currentCollateralRatio < request.collateralRatio) {
            // assert liquidated
            _lender0.liquidate(requestId, false);
            assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
        } else {
            // asset not liquidated
            try _lender0.liquidate(requestId, _withdraw) {
                revert('Cannot liquidate an Active PCL with CR >= ICR');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:L3');
            }
        }
    }

    // Test 10.2: An active PCL can be liquidated if principal != 0 and CR < ICR
    function test_lendersCanLiquidateIfCollateralAssetPriceDecreases(uint256 _seed) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(1);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
        }

        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        _lender0.liquidate(requestId, false);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
    }

    // Test 10.3: An active PCL can be liquidated if principal != 0 and CR < ICR
    function test_lendersCanLiquidateIfBorrowAssetPriceIncreases(uint256 _seed) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(1);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
        }

        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        _lender0.liquidate(requestId, false);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
    }

    // Test 11.1: Admin should be able to terminate an ACTIVE PCL with principal == 0
    function test_adminCanTerminatePCLPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        // Admin terminates the PCL
        admin.terminate(requestId);

        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertTrue((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate) == 0); // Since no collateral was ever deposited
        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0);
    }

    // Test 11.2: Admin should be able to terminate an ACTIVE PCL with principal != 0
    function test_adminCanTerminatePCLPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        // Admin terminates the PCL
        admin.terminate(requestId);

        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0); // Since collateral was also extracted
        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); // Since the lent amount (which was still in the PCL/LP contracts) were extracted
    }

    // Test 12.1: Pool token transfers should be possible in an Active PCL
    function test_poolTokenTransfersShouldBePossibleEntireBalance(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);

        //Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, 0);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == 0);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));
    }

    // Test 12.2: Pool token transfers should be possible in an Active PCL
    function test_poolTokenTransfersShouldBePossiblePartialBalance(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed)
        public
    {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == (3 * lender2PoolTokenBalance) / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 12.3: Pool token transfers should be possible in an Active PCL and principal != 0
    function test_poolTokenTransfersShouldBePossiblePartialBalancePrincipalIsNonZero(
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed
    ) public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        // Price fluctuations take place
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == (3 * lender2PoolTokenBalance) / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 13: Interest can be withdrawn amidst price fluctuations
    function test_lendersCanWithdrawInterest(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        vm.warp(block.timestamp + request.duration / 2);

        // Borrower makes their first repayment (Entire pending interest + part of principal)
        {
            borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));
            uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);
            admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);
            borrower.repay(requestId, interestAccrued + 10);
        }

        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender0Balance = borrowAsset.balanceOf(address(lender0));

        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender1Balance = borrowAsset.balanceOf(address(lender1));

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lender0.getLenderInterest(requestId, address(lender0));
        uint256 lender1InterestOwed = lender1.getLenderInterest(requestId, address(lender1));

        lender0.withdrawInterest(requestId);

        uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(lender0));
        assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        lender1.withdrawInterest(requestId);

        uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(lender1));
        assertEq((lender1BalanceFinal - lender1Balance), lender1InterestOwed);
    }

    // Test 14: An active PCL cannot be cancelled if principal == 0
    function test_borrowerCannotCancelActivePCLPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try borrower.cancelRequest(requestId) {
            revert('Cannot cancel an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    // Test 15.1: An active PCL cannot be cancelled if principal != 0
    function test_borrowerCannotCancelActivePCLPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try borrower.cancelRequest(requestId) {
            revert('Cannot cancel an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    // Test 16: Borrowable amount decreases if collateral asset price decreases
    function test_borrowableAmountDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertGt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 16.1: Borrowable amount decreases if borrow asset price increases
    function test_borrowableAmountDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertGt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 16.2: Borrowable amount increases if collateral asset price increases
    function test_borrowableAmountIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertLt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 16.3: Borrowable amount increases if borrow asset price decreases
    function test_borrowableAmountIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertLt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 16.4: Borrowable amount reverts if borrow asset price decreases to 0
    function test_borrowableAmountRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try pcl.calculateBorrowableAmount(requestId) {
            revert('Borrowable amount should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 16.5: Borrowable amount reverts if collateral asset price decreases to 0
    function test_borrowableAmountRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try pcl.calculateBorrowableAmount(requestId) {
            revert('Borrowable amount should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 17: Borrower can repay
    function test_borrowerCanRepay(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        vm.warp(block.timestamp + 10 days);
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        admin.transferToken(address(borrowAsset), address(borrower), 1);
        borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, 1);
    }

    function assert_helperFunctionalitiesInActiveStateZeroPrincipal(
        uint256 _id,
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed
    ) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 1. calculateCurrentCollateralRatio
        {
            uint256 _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);
            assertEq(_currentCR1, uint256(-1)); // Since borrower has not yet borrowed anything
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 2. calculatePrincipalWithdrawable
        {
            uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
            assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an active PCL
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 3. withdrawableCollateral
        {
            uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
            assertEq(_withdrawableCollateral, 0); // Since no collateral was deposited in the first place
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 4. calculateCurrentDebt
        {
            uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);
            assertEq(_currentDebt, 0); // Since nothing was borrowed
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 5. calculateBorrowableAmount
        {
            uint256 _borrowable = _borrower.calculateBorrowableAmount(_id);
            assertEq(_borrowable, 0); // Since collateral was not deposited
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 6. calculateTotalCollateralTokens
        {
            uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
            assertEq(_totalCollateral, 0); // Since no collateral was deposited
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 7. collateralTokensToLiquidate
        {
            uint256 _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
            assertGt(_equivalentCollateral, 0);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 8. calculateInterestAccrued
        {
            uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
            assertEq(_interestAccrued, 0); // Since borrower did not borrow anything
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
    }

    function assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(
        uint256 _id,
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed
    ) public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);

        vm.warp(block.timestamp + 12 days);

        // 1. calculateCurrentCollateralRatio
        {
            uint256 _currentCR2 = _borrower.calculateCurrentCollateralRatio(_id);
            assertLt(_currentCR2, uint256(-1));
            assertGt(_currentCR2, request.collateralRatio);

            helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _collateralAssetPriceSeed);

            uint256 _currentCR3 = _borrower.calculateCurrentCollateralRatio(_id);
            assertLt(_currentCR3, _currentCR2);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 2. calculatePrincipalWithdrawable
        {
            uint256 _principalWithdrawable = _borrower.calculatePrincipalWithdrawable(_id, address(_lender));
            assertEq(_principalWithdrawable, 0); // Since lenders cannot withdraw funds from an active PCL
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 3. withdrawableCollateral
        {
            uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
            assertGe(_withdrawableCollateral, 0); // Since we had deposited twice the reqired collateral
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 4. calculateCurrentDebt
        {
            uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);
            assertGt(_currentDebt, 0);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 5. calculateBorrowableAmount
        {
            uint256 _borrowable = _borrower.calculateBorrowableAmount(_id);
            assertGe(_borrowable, 0);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 6. calculateTotalCollateralTokens
        {
            uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
            assertGt(_totalCollateral, 0);
        }
        // 7. collateralTokensToLiquidate
        {
            uint256 _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
            assertGt(_equivalentCollateral, 0);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 8. calculateInterestAccrued
        {
            uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
            assertGt(_interestAccrued, 0); // Since borrower did borrow
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
    }

    function test_helperFunctionsInActiveState(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        assert_helperFunctionalitiesInActiveStateZeroPrincipal(requestId, _borrowAssetPriceSeed, _collateralAssetPriceSeed);
    }

    function test_helperFunctionsInActiveStateNonZeroPrincipal(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(requestId, _borrowAssetPriceSeed, _collateralAssetPriceSeed);
    }
}",15978
RealWorld_BA_101_MockToken_RealWord_20240827085006.log,101,MockToken,7287,4247,11534,61.0,0.121375,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

import '@openzeppelin/contracts/token/ERC20/ERC20.sol';
import '@openzeppelin/contracts/access/Ownable.sol';

contract MockToken is ERC20, Ownable {
    constructor(
        string memory name,
        string memory symbol,
        uint8 decimals_,
        uint256 initialSupply,
        address _owner
    ) Ownable() ERC20(name, symbol) {
        _setupDecimals(decimals_);
        _mint(_owner, initialSupply);
        Ownable.transferOwnership(_owner);
    }

    function mint(address _to, uint256 _amount) external onlyOwner {
        require(_amount != 0, 'Token::burn: invalid amount');
        _mint(_to, _amount);
    }

    function approve(address _spender, uint256 _amount) public override returns (bool) {
        // copied from USDT contract
        // https://etherscan.io/address/0xdac17f958d2ee523a2206206994597c13d831ec7#code
        require(!((_amount != 0) && (allowance(msg.sender, _spender) != 0)), 'MT:A1');
        return super.approve(_spender, _amount);
    }
}",270
RealWorld_BA_101_PCLLiquidatedStage.t_RealWord_20240827093330.log,101,PCLLiquidatedStage.t,16182,5104,21286,64.0,0.18299,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '../PCLLiquidatedStage.t.sol';

contract PCLLiquidatedStageCollateralCompoundBorrowNoYield is PCLLiquidatedStage {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    function setUp() public override {
        PCLParent.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 5000 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = compoundYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);
        lender_0 = lenders[0].lenderAddress;

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, type(uint256).max);
        borrower.depositCollateral(requestId, _requiredCollateral, false);

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);
        // and borrows the borrowable amount
        borrower.borrow(requestId, borrowableAmount);

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 10);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, currentDebt / 200);

        // Now we travel past the expiration date
        vm.warp(block.timestamp + request.duration + request.defaultGracePeriod);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');

        // Now the PCL should be in the LIQUIDATED state
        PCLUser(lender_0).liquidate(requestId, false);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
    }
}",781
RealWorld_BA_101_PCLRequestedState.t_RealWord_20240827102010.log,101,PCLRequestedState.t,96644,5838,102482,99.0,0.59998,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';

import '../Helpers/PCLParent.t.sol';

contract PCLRequestedStatePriceOracle is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 _borrowAssetDecimals;
    uint256 _collateralAssetDecimals;
    uint128 _collateralAssetPriceMin;
    uint128 _borrowAssetPriceMin;
    uint128 _collateralAssetPriceMax;
    uint128 _borrowAssetPriceMax;
    uint256 requestId;
    uint256 _fromUserPoolTokenSupply;
    uint256 _toUserPoolTokenSupply;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;
    uint256 _calculatedCurrentDebt;
    uint256 _fetchedCurrentDebt;

    function setUp() public virtual override {
        super.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();
        _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));
        _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));

        _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();
        _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));
        _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));
    }

    // Test 0: Test SetUp
    function test_setUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.REQUESTED, '!Requested');

        (, int256 _borrowAssetPrice, , , ) = MockV3Aggregator(borrowAssetAggregatorAddress).latestRoundData();
        (, int256 _collateralAssetPrice, , , ) = MockV3Aggregator(collateralAssetAggregatorAddress).latestRoundData();

        // Checking out what are the prices
        log_named_int('Borrow Asset Price', _borrowAssetPrice);
        log_named_int('Collateral Asset Price', _collateralAssetPrice);

        // Check the prices of the borrowAsset and collateralAsset are non-zero
        assertGt(_borrowAssetPrice, 0);
        assertGt(_collateralAssetPrice, 0);
    }

    // Test 1: A requested PCL cannot be started even with price fluctuations
    function test_pclCannotBeStarted(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try borrower.start(requestId) {
            revert('Cannot start a PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S2');
        }
    }

    // Test 2: Collateral cannot be deposited
    function test_collateralCannotBeDeposited(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        try borrower.depositCollateral(requestId, _minimumCollateralRequired, false) {
            revert('Collateral cannot be deposited');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:DC2');
        }
    }

    // Test 3: Withdrawable collateral remains zero
    function test_withdrawableCollateralIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);

        assertEq(_withdrawableCollateral, 0);
    }

    // Test 3.1: Collateral cannot be withdrawn
    function test_collateralCannotBeWithdrawn(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try borrower.withdrawCollateral(requestId, 1, false) {
            revert('Collateral cannot be withdrawn');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC1');
        }
    }

    // Test 3.2: All Collateral cannot be withdrawn
    function test_allCollateralCannotBeWithdrawn(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try borrower.withdrawAllCollateral(requestId, false) {
            revert('Collateral cannot be withdrawn');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WAC1');
        }
    }

    // Test 4: Required collateral decreases if collateral asset price increases
    function test_requiredCollateralDecreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertGt(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 4.1: Required collateral increases if borrow asset price increases
    function test_requiredCollateralIncreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertLt(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 4.2: Required collateral increases if collateral asset price decreases
    function test_requiredCollateralIncreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertLt(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 4.3: Required collateral decreases if borrow asset price decreases
    function test_requiredCollateralDecreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertGt(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 4.4: Required collateral reverts if borrow asset price decreases to 0
    function test_requiredCollateralRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);

        try pcl.getRequiredCollateral(requestId, request.borrowLimit / 2) {
            revert('Required collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 4.5: Required collateral reverts if collateral asset price decreases to 0
    function test_requiredCollateralRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);

        try pcl.getRequiredCollateral(requestId, request.borrowLimit / 2) {
            revert('Required collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 5: Borrowable amount remains zero
    function test_borrowableAmountIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        assertEq(_borrowableAmount, 0);
    }

    // Test 6: A requested PCL cannot be closed
    function test_pclCannotBeClosed(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try borrower.close(requestId) {
            revert('PCL cannot be closed');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C1');
        }
    }

    // Test 7: Collateral ratio remains infinite
    function test_collateralRatioIsInfinite(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);

        assertEq(_collateralRatio, type(uint256).max);
    }

    // Test 7.1: Collateral ratio reverts if borrow asset price decreases to 0
    function test_collateralRatioRevertsIfBorrowAssetPriceDecreasesToZero() public {
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);

        try pcl.calculateCurrentCollateralRatio(requestId) {
            revert('Collateral ratio should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 7.2: Collateral ratio reverts if collateral asset price decreases to 0
    function test_collateralRatioRevertsIfCollateralAssetPriceDecreasesToZero() public {
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);

        try pcl.calculateCurrentCollateralRatio(requestId) {
            revert('Collateral ratio should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 8: Lenders cannot withdraw liquidation
    function test_lendersCannotWithdrawLiquidation(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        createMultipleLenders(requestId, 6, uint128(request.minBorrowAmount - 1), request.borrowAsset);
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try _lender0.withdrawLiquidation(requestId) {
            revert('Cannot withdraw liquidation from a requested PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    // Test 9: Lenders can withdraw liquidity
    function test_lendersCanWithdrawLiquidity(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        createMultipleLenders(requestId, 6, uint128(request.minBorrowAmount - 1), request.borrowAsset);
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        vm.warp(block.timestamp + (request.collectionPeriod + 2 days));
        uint256 _userPoolTokenBalance = lp.balanceOf(address(_lender0), requestId);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        uint256 _userBorrowTokenBalanceBefore = IERC20(request.borrowAsset).balanceOf(address(_lender0));
        _lender0.withdrawLiquidity(requestId);
        uint256 _userBorrowTokenBalanceAfter = IERC20(request.borrowAsset).balanceOf(address(_lender0));
        assertEq(_userPoolTokenBalance, _userBorrowTokenBalanceAfter - _userBorrowTokenBalanceBefore);

        _userPoolTokenBalance = lp.balanceOf(address(_lender0), requestId);
        assertEq(_userPoolTokenBalance, 0);
    }

    // Test 10: A requested PCL cannot be liquidated
    function test_lendersCannotLiquidate(
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed,
        bool _withdraw
    ) public {
        createMultipleLenders(requestId, 6, uint128(request.minBorrowAmount - 1), request.borrowAsset);
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // _lender0 tries to liquidate the PCL
        try _lender0.liquidate(requestId, _withdraw) {
            revert('Cannot liquidate a requested PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L1');
        }
    }

    // Test 11: Admin should be able to terminate
    function test_adminCanTerminatePCL(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        createMultipleLenders(requestId, 6, uint128(request.minBorrowAmount - 1), request.borrowAsset);
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        // Admin terminates the PCL
        admin.terminate(requestId);

        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertTrue((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate) == 0); // Since no collateral was ever deposited
        assertTrue((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate) == 0);
    }

    // Test 12: Pool token transfers should be possible
    function test_poolTokenTransfersShouldBePossibleEntireBalance(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        createMultipleLenders(requestId, 6, uint128(request.minBorrowAmount - 1), request.borrowAsset);
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);

        //Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, 0);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == 0);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));
    }

    // Test 12.1: Pool token transfers should be possible
    function test_poolTokenTransfersShouldBePossiblePartialBalance(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed)
        public
    {
        createMultipleLenders(requestId, 6, uint128(request.minBorrowAmount - 100), request.borrowAsset);
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 13: Interest cannot be withdrawn amidst price fluctuations
    function test_lendersCannotWithdrawInterest(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        createMultipleLenders(requestId, 6, uint128(request.minBorrowAmount - 1), request.borrowAsset);
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender0Balance = borrowAsset.balanceOf(address(lender0));

        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender1Balance = borrowAsset.balanceOf(address(lender1));

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lender0.getLenderInterest(requestId, address(lender0));
        uint256 lender1InterestOwed = lender1.getLenderInterest(requestId, address(lender1));

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try lender1.withdrawInterest(requestId) {
            revert('Interest cannot be withdrawn');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WI1');
        }
    }

    // Test 14: A requested PCL can be cancelled
    function test_pclCanBeCancelled(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        createMultipleLenders(requestId, 5, uint128(request.borrowLimit - 10), request.borrowAsset);
        vm.warp(block.timestamp + (request.collectionPeriod - 1 days));

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        borrower.cancelRequest(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CANCELLED);
    }

    function assert_helperFunctionalitiesInRequestedState(
        uint256 _id,
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed
    ) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);
        createMultipleLenders(requestId, 6, uint128(request.minBorrowAmount - 1), request.borrowAsset);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 1. calculateCurrentCollateralRatio
        {
            uint256 _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);
            assertEq(_currentCR1, uint256(-1)); // Since borrower has not yet borrowed anything
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 2. calculatePrincipalWithdrawable
        {
            uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
            assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from a requested PCL before its collection period
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 3. withdrawableCollateral
        {
            uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
            assertEq(_withdrawableCollateral, 0); // Since no collateral was deposited in the first place
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 4. calculateCurrentDebt
        {
            uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);
            assertEq(_currentDebt, 0); // Since nothing was borrowed
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 5. calculateBorrowableAmount
        {
            uint256 _borrowable = _borrower.calculateBorrowableAmount(_id);
            assertEq(_borrowable, 0); // Since collateral was not deposited
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 6. calculateTotalCollateralTokens
        {
            uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
            assertEq(_totalCollateral, 0); // Since no collateral was deposited
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 7. collateralTokensToLiquidate
        {
            uint256 _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
            assertGt(_equivalentCollateral, 0);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 8. calculateInterestAccrued
        {
            uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
            assertEq(_interestAccrued, 0); // Since borrower did not borrow anything
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.REQUESTED);
    }

    function test_helperFunctionsInRequestedState(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        assert_helperFunctionalitiesInRequestedState(requestId, _borrowAssetPriceSeed, _collateralAssetPriceSeed);
    }
}",5971
RealWorld_BA_101_PCLLifecycleTestWETHUSDC.t_RealWord_20240827095035.log,101,PCLLifecycleTestWETHUSDC.t,10674,5511,16185,71.0,0.16359,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../interfaces/IPriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';
import '../Helpers/PCLParent.t.sol';
import './PCLLifecycleTest.t.sol';

contract PCLLifecycleTestWETHUSDC is PCLLifecycleTest {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    function setCollateralAsset() public override {
        if (isForked) {
            collateralAsset = ERC20(Constants.USDC);
            collateralAssetAggregatorAddress = Constants.USDC_priceFeedChainlink;
            collateralCTokenAddress = Constants.cUSDC;
        } else {
            collateralAsset = new MockToken('CollateralAsset', 'MUSDC', 6, 1e40, address(admin));
            collateralAssetAggregatorAddress = address(new MockV3Aggregator(6, 12876423400));
        }
    }

    function setBorrowAsset() public override {
        if (isForked) {
            borrowAsset = IERC20(Constants.WETH);
            borrowAssetAggregatorAddress = Constants.ETH_priceFeedChainlink;
            borrowCTokenAddress = Constants.cETH;
        } else {
            borrowAsset = new MockToken('BorrowAsset', 'MWETH', 18, 1e40, address(admin));
            borrowAssetAggregatorAddress = address(new MockV3Aggregator(18, 1950405767382174661));
        }
    }

    function setUp() public override {
        super.setUp();
        request.borrowAssetStrategy = compoundYieldAddress;
        request.collateralAssetStrategy = compoundYieldAddress;
    }
}",502
RealWorld_BA_101_PCLLiquidatedStage.t_RealWord_20240827093904.log,101,PCLLiquidatedStage.t,16328,5888,22216,116.0,0.1994,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '../PCLLiquidatedStage.t.sol';

contract PCLLiquidatedStageCollateralCompoundBorrowCompound is PCLLiquidatedStage {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    function setUp() public override {
        PCLParent.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 5000 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = compoundYieldAddress;
        request.collateralAssetStrategy = compoundYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);
        lender_0 = lenders[0].lenderAddress;

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, type(uint256).max);
        borrower.depositCollateral(requestId, _requiredCollateral, false);

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);
        // and borrows the borrowable amount
        borrower.borrow(requestId, borrowableAmount);

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 10);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, currentDebt / 200);

        // Now we travel past the expiration date
        vm.warp(block.timestamp + request.duration + request.defaultGracePeriod);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');

        // Now the PCL should be in the LIQUIDATED state
        PCLUser(lender_0).liquidate(requestId, false);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
    }
}",779
RealWorld_BA_101_PCLRequestedStage.t_RealWord_20240827100209.log,101,PCLRequestedStage.t,8240,4986,13226,84.0,0.14092,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '../PCLStageTests/PCLRequestedStage.t.sol';

contract PCLRequestedStageZeroCollateral is PCLRequestedStage {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    function setUp() public override {
        PCLParent.setUp();

        request.borrowLimit = uint128(1_000_000 * 10**(ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * 1e18) / 1e2);
        request.collateralRatio = 0;
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * 1e18) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.REQUESTED, '!REQUESTED');
    }
}",328
RealWorld_BA_101_PCLCancelledState.t_RealWord_20240827102414.log,101,PCLCancelledState.t,81846,5577,87423,96.0,0.52077,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';

import '../Helpers/PCLParent.t.sol';

contract PCLCancelledStatePriceOracle is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 _borrowAssetDecimals;
    uint256 _collateralAssetDecimals;
    uint128 _collateralAssetPriceMin;
    uint128 _borrowAssetPriceMin;
    uint128 _collateralAssetPriceMax;
    uint128 _borrowAssetPriceMax;
    uint256 requestId;
    uint256 _fromUserPoolTokenSupply;
    uint256 _toUserPoolTokenSupply;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;
    uint256 _calculatedCurrentDebt;
    uint256 _fetchedCurrentDebt;
    address lender_0;

    function setUp() public virtual override {
        super.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();
        _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));
        _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));

        _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();
        _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));
        _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        createMultipleLenders(requestId, 5, request.borrowLimit - 100, request.borrowAsset);
        lender_0 = lenders[0].lenderAddress;

        // Let's travel a few days, but stay within the collection period
        vm.warp(block.timestamp + request.collectionPeriod / 2);

        // Borrower tries to cancel the PCL
        borrower.cancelRequest(requestId);
    }

    // Test 0: Test SetUp
    function test_setUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CANCELLED, '!Cancelled');

        (, int256 _borrowAssetPrice, , , ) = MockV3Aggregator(borrowAssetAggregatorAddress).latestRoundData();
        (, int256 _collateralAssetPrice, , , ) = MockV3Aggregator(collateralAssetAggregatorAddress).latestRoundData();

        // Checking out what are the prices
        log_named_int('Borrow Asset Price', _borrowAssetPrice);
        log_named_int('Collateral Asset Price', _collateralAssetPrice);

        // Check the prices of the borrowAsset and collateralAsset are non-zero
        assertGt(_borrowAssetPrice, 0);
        assertGt(_collateralAssetPrice, 0);
    }

    // Test 1: A cancelled PCL cannot be started even with price fluctuations
    function test_pclCannotBeStarted(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try borrower.start(requestId) {
            revert('Cannot start a PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S1');
        }
    }

    // Test 2: Collateral cannot be deposited
    function test_collateralCannotBeDeposited(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), 100);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        try borrower.depositCollateral(requestId, 100, false) {
            revert('Collateral cannot be deposited');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:DC2');
        }
    }

    // Test 3: Withdrawable collateral remains zero
    function test_withdrawableCollateralIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);

        assertEq(_withdrawableCollateral, 0);
    }

    // Test 3.1: Collateral cannot be withdrawn
    function test_collateralCannotBeWithdrawn(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try borrower.withdrawCollateral(requestId, 1, false) {
            revert('Collateral cannot be withdrawn');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:OCLB1');
        }
    }

    // Test 3.2: All Collateral cannot be withdrawn
    function test_allCollateralCannotBeWithdrawn(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try borrower.withdrawAllCollateral(requestId, false) {
            revert('Collateral cannot be withdrawn');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:OCLB1');
        }
    }

    // Test 4: Required collateral should not work
    function test_requiredCollateralReverts(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try pcl.getRequiredCollateral(requestId, request.borrowLimit / 2) {
            revert('Required collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:IGUPT1');
        }
    }

    // Test 5: Borrowable amount remains zero
    function test_borrowableAmountIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);

        assertEq(_borrowableAmount, 0);
    }

    // Test 6: A cancelled PCL cannot be closed
    function test_pclCannotBeClosed(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try borrower.close(requestId) {
            revert('PCL cannot be closed');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:OCLB1');
        }
    }

    // Test 7: Collateral ratio should not work
    function test_collateralRatioReverts(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try pcl.calculateCurrentCollateralRatio(requestId) {
            revert('Calculate collateral ratio should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:IGUPT1');
        }
    }

    // Test 8: Lenders cannot withdraw liquidation
    function test_lendersCannotWithdrawLiquidation(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try PCLUser(lender_0).withdrawLiquidation(requestId) {
            revert('Cannot withdraw liquidation from a cancelled PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    // Test 9: Lenders can withdraw liquidity
    function test_lendersCanWithdrawLiquidity(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        uint256 _userPoolTokenBalance = lp.balanceOf(address(lender_0), requestId);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        uint256 _userBorrowTokenBalanceBefore = IERC20(request.borrowAsset).balanceOf(address(lender_0));
        PCLUser(lender_0).withdrawLiquidity(requestId);
        uint256 _userBorrowTokenBalanceAfter = IERC20(request.borrowAsset).balanceOf(address(lender_0));
        assertEq(_userPoolTokenBalance, _userBorrowTokenBalanceAfter - _userBorrowTokenBalanceBefore);

        _userPoolTokenBalance = lp.balanceOf(address(lender_0), requestId);
        assertEq(_userPoolTokenBalance, 0);
    }

    // Test 10: A cancelled PCL cannot be liquidated
    function test_lendersCannotLiquidate(
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed,
        bool _withdraw
    ) public {
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // lender_0 tries to liquidate the PCL
        try PCLUser(lender_0).liquidate(requestId, _withdraw) {
            revert('Cannot liquidate a cancelled PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L1');
        }
    }

    // Test 11: Admin should not be able to terminate
    function test_adminCannotTerminatePCL(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // Admin terminates the PCL
        try admin.terminate(requestId) {
            revert('Admin cannot terminate a cancelled PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CTCT1');
        }
    }

    // Test 12: Pool token transfers should be possible
    function test_poolTokenTransfersShouldBePossibleEntireBalance(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);

        //Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, 0);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == 0);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));
    }

    // Test 12.1: Pool token transfers should be possible
    function test_poolTokenTransfersShouldBePossiblePartialBalance(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed)
        public
    {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 13: Interest cannot be withdrawn amidst price fluctuations
    function test_lendersCannotWithdrawInterest(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender0Balance = borrowAsset.balanceOf(address(lender0));

        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender1Balance = borrowAsset.balanceOf(address(lender1));

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lender0.getLenderInterest(requestId, address(lender0));
        uint256 lender1InterestOwed = lender1.getLenderInterest(requestId, address(lender1));

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try lender1.withdrawInterest(requestId) {
            revert('Interest cannot be withdrawn');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:WI1');
        }
    }

    // Test 14: A cancelled PCL cannot be cancelled
    function test_pclCannotBeCancelled(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        vm.warp(block.timestamp + (request.collectionPeriod - 1 days));

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        try borrower.cancelRequest(requestId) {
            revert('PCL cannot be cancelled');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:OCLB1');
        }
    }

    function assert_helperFunctionalitiesInCancelledState(
        uint256 _id,
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed
    ) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.CANCELLED);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 1. calculateCurrentCollateralRatio
        {
            try pcl.calculateCurrentCollateralRatio(requestId) {
                revert('Calculate collateral ratio should revert');
            } catch Error(string memory reason) {
                assertEq(reason, 'PO:IGUPT1');
            }
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 2. calculatePrincipalWithdrawable
        {
            uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
            assertGt(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from a requested PCL before its collection period
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 3. withdrawableCollateral
        {
            uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
            assertEq(_withdrawableCollateral, 0); // Since no collateral was deposited in the first place
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 4. calculateCurrentDebt
        {
            uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);
            assertEq(_currentDebt, 0); // Since nothing was borrowed
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 5. calculateBorrowableAmount
        {
            uint256 _borrowable = _borrower.calculateBorrowableAmount(_id);
            assertEq(_borrowable, 0); // Since collateral was not deposited
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 6. calculateTotalCollateralTokens
        {
            try _borrower.calculateTotalCollateralTokens(_id) {
                revert('Collateral tokens should revert');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:CTCT1');
            }
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 7. collateralTokensToLiquidate
        {
            try _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id)) {
                revert('Collateral tokens should revert');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:CTTL1');
            }
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 8. calculateInterestAccrued
        {
            uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
            assertEq(_interestAccrued, 0); // Since borrower did not borrow anything
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.CANCELLED);
    }

    function test_helperFunctionsInCancelledState(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        assert_helperFunctionalitiesInCancelledState(requestId, _borrowAssetPriceSeed, _collateralAssetPriceSeed);
    }
}",4902
RealWorld_BA_101_PCLLifecycleTestCompoundYield.t_RealWord_20240827095311.log,101,PCLLifecycleTestCompoundYield.t,4844,4124,8968,67.0,0.1067,"// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import './PCLLifecycleTest.t.sol';

contract PCLLifecycleTestCompoundYield is PCLLifecycleTest {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    function setUp() public override {
        super.setUp();
        request.borrowAssetStrategy = compoundYieldAddress;
        request.collateralAssetStrategy = compoundYieldAddress;
    }
}",109
RealWorld_BA_102_ERC20CompoundPCVDeposit_RealWord_20240827222424.log,102,ERC20CompoundPCVDeposit,9002,5554,14556,90.0,0.15609,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.0;

import ""./CompoundPCVDepositBase.sol"";

interface CErc20 {
    function mint(uint256 amount) external returns (uint256);

    function underlying() external returns (address);
}

/// @title ERC-20 implementation for a Compound PCV Deposit
/// @author Fei Protocol
contract ERC20CompoundPCVDeposit is CompoundPCVDepositBase {
    /// @notice the token underlying the cToken
    IERC20 public token;

    /// @notice Compound ERC20 PCV Deposit constructor
    /// @param _core Fei Core for reference
    /// @param _cToken Compound cToken to deposit
    constructor(address _core, address _cToken)
        CompoundPCVDepositBase(_core, _cToken)
    {
        token = IERC20(CErc20(_cToken).underlying());
    }

    /// @notice deposit ERC-20 tokens to Compound
    function deposit() external override whenNotPaused {
        uint256 amount = token.balanceOf(address(this));

        token.approve(address(cToken), amount);

        // Compound returns non-zero when there is an error
        require(
            CErc20(address(cToken)).mint(amount) == 0,
            ""ERC20CompoundPCVDeposit: deposit error""
        );

        emit Deposit(msg.sender, amount);
    }

    function _transferUnderlying(address to, uint256 amount) internal override {
        SafeERC20.safeTransfer(token, to, amount);
    }

    /// @notice display the related token of the balance reported
    function balanceReportedIn() public view override returns (address) {
        return address(token);
    }
}",358
RealWorld_BA_102_IVoltTimedMinter_RealWord_20240827223826.log,102,IVoltTimedMinter,7063,5318,12381,102.0,0.141675,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

/// @title a Fei Timed Minter
/// @author Fei Protocol
interface IVoltTimedMinter {
    // ----------- Events -----------

    event FeiMinting(address indexed caller, uint256 feiAmount);

    event TargetUpdate(address oldTarget, address newTarget);

    event MintAmountUpdate(uint256 oldMintAmount, uint256 newMintAmount);

    // ----------- State changing api -----------

    function mint() external;

    // ----------- Governor only state changing api -----------

    function setTarget(address newTarget) external;

    // ----------- Governor or Admin only state changing api -----------

    function setFrequency(uint256 newFrequency) external;

    function setMintAmount(uint256 newMintAmount) external;

    // ----------- Getters -----------

    function mintAmount() external view returns (uint256);

    function MIN_MINT_FREQUENCY() external view returns (uint256);

    function MAX_MINT_FREQUENCY() external view returns (uint256);

    function target() external view returns (address);
}",226
RealWorld_BA_102_IPermissions_RealWord_20240827211737.log,102,IPermissions,8022,4939,12961,77.0,0.13889,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.4;

import ""@openzeppelin/contracts/access/AccessControl.sol"";
import ""./IPermissionsRead.sol"";

/// @title Permissions interface
/// @author Fei Protocol
interface IPermissions is IAccessControl, IPermissionsRead {
    // ----------- Governor only state changing api -----------

    function createRole(bytes32 role, bytes32 adminRole) external;

    function grantMinter(address minter) external;

    function grantBurner(address burner) external;

    function grantPCVController(address pcvController) external;

    function grantGovernor(address governor) external;

    function grantGuardian(address guardian) external;

    function revokeMinter(address minter) external;

    function revokeBurner(address burner) external;

    function revokePCVController(address pcvController) external;

    function revokeGovernor(address governor) external;

    function revokeGuardian(address guardian) external;

    // ----------- Revoker only state changing api -----------

    function revokeOverride(bytes32 role, address account) external;

    // ----------- Getters -----------

    function GUARDIAN_ROLE() external view returns (bytes32);

    function GOVERN_ROLE() external view returns (bytes32);

    function BURNER_ROLE() external view returns (bytes32);

    function MINTER_ROLE() external view returns (bytes32);

    function PCV_CONTROLLER_ROLE() external view returns (bytes32);
}",302
RealWorld_BA_102_IVolt_RealWord_20240827223536.log,102,IVolt,7045,5260,12305,80.0,0.140425,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.4;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

/// @title FEI stablecoin interface
/// @author Fei Protocol
interface IVolt is IERC20 {
    // ----------- Events -----------

    event Minting(
        address indexed _to,
        address indexed _minter,
        uint256 _amount
    );

    event Burning(
        address indexed _to,
        address indexed _burner,
        uint256 _amount
    );

    event IncentiveContractUpdate(
        address indexed _incentivized,
        address indexed _incentiveContract
    );

    // ----------- State changing api -----------

    function burn(uint256 amount) external;

    function permit(
        address owner,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external;

    // ----------- Minter only state changing api -----------

    function mint(address account, uint256 amount) external;
}",231
RealWorld_BA_102_IPCVDepositBalances_RealWord_20240827222256.log,102,IPCVDepositBalances,5988,4924,10912,86.0,0.12842,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.4;

/// @title a PCV Deposit interface for only balance getters
/// @author Fei Protocol
interface IPCVDepositBalances {
    // ----------- Getters -----------

    /// @notice gets the effective balance of ""balanceReportedIn"" token if the deposit were fully withdrawn
    function balance() external view returns (uint256);

    /// @notice gets the token address in which this deposit returns its balance
    function balanceReportedIn() external view returns (address);

    /// @notice gets the resistant token balance and protocol owned fei of this deposit
    function resistantBalanceAndVolt() external view returns (uint256, uint256);
}",156
RealWorld_BA_102_Deviation.t_RealWord_20240827213740.log,102,Deviation.t,9578,4805,14383,78.0,0.14399,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.4;

import {Vm} from ""./../utils/Vm.sol"";
import ""./../utils/DSTest.sol"";
import {Constants} from ""./../../../Constants.sol"";
import {Deviation} from ""./../../../utils/Deviation.sol"";
import {getCore, getAddresses, FeiTestAddresses} from ""./../utils/Fixtures.sol"";
import {SafeCast} from ""@openzeppelin/contracts/utils/math/SafeCast.sol"";
import {SafeMath} from ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

contract DeviationTest is DSTest {
    using SafeCast for *;
    using Deviation for *;

    uint256 maxDeviationThresholdBasisPoints = 10_000;

    Vm public constant vm = Vm(HEVM_ADDRESS);
    FeiTestAddresses public addresses = getAddresses();

    function testDeviation() public {
        int256 x = 275000;
        int256 y = 270000;

        int256 delta = x - y;
        uint256 absDeviation = delta.toUint256();

        uint256 basisPoints = (absDeviation *
            Constants.BASIS_POINTS_GRANULARITY) / x.toUint256();

        assertEq(
            basisPoints,
            Deviation.calculateDeviationThresholdBasisPoints(x, y)
        );
    }

    function testWithinDeviation() public {
        int256 x = 275000;
        int256 y = 270000;

        assertTrue(
            maxDeviationThresholdBasisPoints.isWithinDeviationThreshold(x, y)
        );
    }

    function testWithinDeviationFuzz(int128 x, int128 y) public view {
        maxDeviationThresholdBasisPoints.isWithinDeviationThreshold(x, y);
    }

    function testOutsideDeviation() public {
        int256 x = 275000;
        int256 y = 577500;

        assertTrue(
            !maxDeviationThresholdBasisPoints.isWithinDeviationThreshold(x, y)
        );
    }
}",434
RealWorld_BA_102_IOracleRef_RealWord_20240827222907.log,102,IOracleRef,8160,5471,13631,84.0,0.15022,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.4;

import ""../oracle/IOracle.sol"";

/// @title OracleRef interface
/// @author Fei Protocol
interface IOracleRef {
    // ----------- Events -----------

    event OracleUpdate(address indexed oldOracle, address indexed newOracle);

    event InvertUpdate(bool oldDoInvert, bool newDoInvert);

    event DecimalsNormalizerUpdate(
        int256 oldDecimalsNormalizer,
        int256 newDecimalsNormalizer
    );

    event BackupOracleUpdate(
        address indexed oldBackupOracle,
        address indexed newBackupOracle
    );

    // ----------- State changing API -----------

    function updateOracle() external;

    // ----------- Governor only state changing API -----------

    function setOracle(address newOracle) external;

    function setBackupOracle(address newBackupOracle) external;

    function setDecimalsNormalizer(int256 newDecimalsNormalizer) external;

    function setDoInvert(bool newDoInvert) external;

    // ----------- Getters -----------

    function oracle() external view returns (IOracle);

    function backupOracle() external view returns (IOracle);

    function doInvert() external view returns (bool);

    function decimalsNormalizer() external view returns (int256);

    function readOracle() external view returns (Decimal.D256 memory);

    function invert(Decimal.D256 calldata price)
        external
        pure
        returns (Decimal.D256 memory);
}",309
RealWorld_BA_102_ForceEth_RealWord_20240827215113.log,102,ForceEth,3996,3896,7892,67.0,0.0979,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.4;

contract ForceEth {
    constructor() payable {}

    receive() external payable {}

    function forceEth(address to) public {
        selfdestruct(payable(to));
    }
}",58
RealWorld_BA_102_ICore_RealWord_20240827211856.log,102,ICore,5425,4584,10009,71.0,0.118805,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.4;

import {IPermissions} from ""./IPermissions.sol"";
import {IVolt, IERC20} from ""../volt/IVolt.sol"";

/// @title Core Interface
/// @author Fei Protocol
interface ICore is IPermissions {
    // ----------- Events -----------
    event VoltUpdate(IERC20 indexed _volt);
    event VconUpdate(IERC20 indexed _vcon);

    // ----------- Getters -----------

    function volt() external view returns (IVolt);

    function vcon() external view returns (IERC20);
}",135
RealWorld_BA_102_IMultiRateLimited_RealWord_20240827220756.log,102,IMultiRateLimited,12443,5544,17987,97.0,0.173095,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.4;

/// @title interface for putting a rate limit on how fast a contract can perform an action, e.g. Minting
/// @author Fei Protocol
interface IMultiRateLimited {
    // ----------- Events -----------

    /// @notice emitted when a buffer is eaten into
    event IndividualBufferUsed(
        address rateLimitedAddress,
        uint256 amountUsed,
        uint256 bufferRemaining
    );

    /// @notice emitted when rate limit is updated
    event IndividualRateLimitPerSecondUpdate(
        address rateLimitedAddress,
        uint256 oldRateLimitPerSecond,
        uint256 newRateLimitPerSecond
    );

    /// @notice emitted when the non gov buffer cap max is updated
    event MultiBufferCapUpdate(uint256 oldBufferCap, uint256 newBufferCap);

    /// @notice emitted when the non gov buffer rate limit per second max is updated
    event MultiMaxRateLimitPerSecondUpdate(
        uint256 oldMaxRateLimitPerSecond,
        uint256 newMaxRateLimitPerSecond
    );

    // ----------- View API -----------

    /// @notice the rate per second for each address
    function getRateLimitPerSecond(address) external view returns (uint256);

    /// @notice the last time the buffer was used by each address
    function getLastBufferUsedTime(address) external view returns (uint256);

    /// @notice the cap of the buffer that can be used at once
    function getBufferCap(address) external view returns (uint256);

    /// @notice the amount of action that can be used before hitting limit
    /// @dev replenishes at rateLimitPerSecond per second up to bufferCap
    function individualBuffer(address) external view returns (uint112);

    // ----------- Governance State Changing API -----------

    /// @notice update the non gov max rate limit per second
    function updateMaxRateLimitPerSecond(uint256 newMaxRateLimitPerSecond)
        external;

    /// @notice update the non gov max buffer cap
    function updateMaxBufferCap(uint256 newBufferCap) external;

    /// @notice add an authorized contract, its per second replenishment and buffer set to the non governor caps
    function addAddressWithCaps(address) external;

    /// @notice add an authorized contract, its per second replenishment and buffer
    function addAddress(
        address,
        uint112,
        uint112
    ) external;

    /// @notice update an authorized contract
    function updateAddress(
        address,
        uint112,
        uint112
    ) external;

    /// @notice remove an authorized contract
    function removeAddress(address) external;
}",562
RealWorld_BA_102_CoreRef_RealWord_20240827222719.log,102,CoreRef,26691,5576,32267,106.0,0.244975,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.4;

import ""./ICoreRef.sol"";
import ""@openzeppelin/contracts/security/Pausable.sol"";

/// @title A Reference to Core
/// @author Fei Protocol
/// @notice defines some modifiers and utilities around interacting with Core
abstract contract CoreRef is ICoreRef, Pausable {
    ICore private immutable _core;
    IVolt private immutable _volt;
    IERC20 private immutable _vcon;

    /// @notice a role used with a subset of governor permissions for this contract only
    bytes32 public override CONTRACT_ADMIN_ROLE;

    constructor(address coreAddress) {
        _core = ICore(coreAddress);

        _volt = ICore(coreAddress).volt();
        _vcon = ICore(coreAddress).vcon();

        _setContractAdminRole(ICore(coreAddress).GOVERN_ROLE());
    }

    function _initialize() internal {} // no-op for backward compatibility

    modifier ifMinterSelf() {
        if (_core.isMinter(address(this))) {
            _;
        }
    }

    modifier onlyMinter() {
        require(_core.isMinter(msg.sender), ""CoreRef: Caller is not a minter"");
        _;
    }

    modifier onlyBurner() {
        require(_core.isBurner(msg.sender), ""CoreRef: Caller is not a burner"");
        _;
    }

    modifier onlyPCVController() {
        require(
            _core.isPCVController(msg.sender),
            ""CoreRef: Caller is not a PCV controller""
        );
        _;
    }

    modifier onlyGovernorOrAdmin() {
        require(
            _core.isGovernor(msg.sender) || isContractAdmin(msg.sender),
            ""CoreRef: Caller is not a governor or contract admin""
        );
        _;
    }

    modifier onlyGovernor() {
        require(
            _core.isGovernor(msg.sender),
            ""CoreRef: Caller is not a governor""
        );
        _;
    }

    modifier onlyGuardianOrGovernor() {
        require(
            _core.isGovernor(msg.sender) || _core.isGuardian(msg.sender),
            ""CoreRef: Caller is not a guardian or governor""
        );
        _;
    }

    modifier onlyGovernorOrGuardianOrAdmin() {
        require(
            _core.isGovernor(msg.sender) ||
                _core.isGuardian(msg.sender) ||
                isContractAdmin(msg.sender),
            ""CoreRef: Caller is not governor or guardian or admin""
        );
        _;
    }

    // Named onlyTribeRole to prevent collision with OZ onlyRole modifier
    modifier onlyTribeRole(bytes32 role) {
        require(_core.hasRole(role, msg.sender), ""UNAUTHORIZED"");
        _;
    }

    // Modifiers to allow any combination of roles
    modifier hasAnyOfTwoRoles(bytes32 role1, bytes32 role2) {
        require(
            _core.hasRole(role1, msg.sender) ||
                _core.hasRole(role2, msg.sender),
            ""UNAUTHORIZED""
        );
        _;
    }

    modifier hasAnyOfThreeRoles(
        bytes32 role1,
        bytes32 role2,
        bytes32 role3
    ) {
        require(
            _core.hasRole(role1, msg.sender) ||
                _core.hasRole(role2, msg.sender) ||
                _core.hasRole(role3, msg.sender),
            ""UNAUTHORIZED""
        );
        _;
    }

    modifier hasAnyOfFourRoles(
        bytes32 role1,
        bytes32 role2,
        bytes32 role3,
        bytes32 role4
    ) {
        require(
            _core.hasRole(role1, msg.sender) ||
                _core.hasRole(role2, msg.sender) ||
                _core.hasRole(role3, msg.sender) ||
                _core.hasRole(role4, msg.sender),
            ""UNAUTHORIZED""
        );
        _;
    }

    modifier hasAnyOfFiveRoles(
        bytes32 role1,
        bytes32 role2,
        bytes32 role3,
        bytes32 role4,
        bytes32 role5
    ) {
        require(
            _core.hasRole(role1, msg.sender) ||
                _core.hasRole(role2, msg.sender) ||
                _core.hasRole(role3, msg.sender) ||
                _core.hasRole(role4, msg.sender) ||
                _core.hasRole(role5, msg.sender),
            ""UNAUTHORIZED""
        );
        _;
    }

    modifier onlyVolt() {
        require(msg.sender == address(_volt), ""CoreRef: Caller is not VOLT"");
        _;
    }

    /// @notice sets a new admin role for this contract
    function setContractAdminRole(bytes32 newContractAdminRole)
        external
        override
        onlyGovernor
    {
        _setContractAdminRole(newContractAdminRole);
    }

    /// @notice returns whether a given address has the admin role for this contract
    function isContractAdmin(address _admin)
        public
        view
        override
        returns (bool)
    {
        return _core.hasRole(CONTRACT_ADMIN_ROLE, _admin);
    }

    /// @notice set pausable methods to paused
    function pause() public override onlyGuardianOrGovernor {
        _pause();
    }

    /// @notice set pausable methods to unpaused
    function unpause() public override onlyGuardianOrGovernor {
        _unpause();
    }

    /// @notice address of the Core contract referenced
    /// @return ICore implementation address
    function core() public view override returns (ICore) {
        return _core;
    }

    /// @notice address of the Fei contract referenced by Core
    /// @return IFei implementation address
    function volt() public view override returns (IVolt) {
        return _volt;
    }

    /// @notice address of the Tribe contract referenced by Core
    /// @return IERC20 implementation address
    function vcon() public view override returns (IERC20) {
        return _vcon;
    }

    /// @notice volt balance of contract
    /// @return volt amount held
    function voltBalance() public view override returns (uint256) {
        return _volt.balanceOf(address(this));
    }

    /// @notice vcon balance of contract
    /// @return vcon amount held
    function vconBalance() public view override returns (uint256) {
        return _vcon.balanceOf(address(this));
    }

    function _burnVoltHeld() internal {
        _volt.burn(voltBalance());
    }

    function _mintVolt(address to, uint256 amount) internal virtual {
        if (amount != 0) {
            _volt.mint(to, amount);
        }
    }

    function _setContractAdminRole(bytes32 newContractAdminRole) internal {
        bytes32 oldContractAdminRole = CONTRACT_ADMIN_ROLE;
        CONTRACT_ADMIN_ROLE = newContractAdminRole;
        emit ContractAdminRoleUpdate(
            oldContractAdminRole,
            newContractAdminRole
        );
    }
}",1487
RealWorld_BA_102_CompoundPCVDepositBase_RealWord_20240827222556.log,102,CompoundPCVDepositBase,10643,4814,15457,81.0,0.149495,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.0;

import ""../PCVDeposit.sol"";
import ""../../refs/CoreRef.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";

interface CToken {
    function redeemUnderlying(uint256 redeemAmount) external returns (uint256);

    function exchangeRateStored() external view returns (uint256);

    function balanceOf(address account) external view returns (uint256);

    function isCToken() external view returns (bool);

    function isCEther() external view returns (bool);
}

/// @title base class for a Compound PCV Deposit
/// @author Fei Protocol
abstract contract CompoundPCVDepositBase is PCVDeposit {
    CToken public cToken;

    uint256 private constant EXCHANGE_RATE_SCALE = 1e18;

    /// @notice Compound PCV Deposit constructor
    /// @param _core Fei Core for reference
    /// @param _cToken Compound cToken to deposit
    constructor(address _core, address _cToken) CoreRef(_core) {
        cToken = CToken(_cToken);
        require(cToken.isCToken(), ""CompoundPCVDeposit: Not a cToken"");
    }

    /// @notice withdraw tokens from the PCV allocation
    /// @param amountUnderlying of tokens withdrawn
    /// @param to the address to send PCV to
    function withdraw(address to, uint256 amountUnderlying)
        external
        override
        onlyPCVController
        whenNotPaused
    {
        require(
            cToken.redeemUnderlying(amountUnderlying) == 0,
            ""CompoundPCVDeposit: redeem error""
        );
        _transferUnderlying(to, amountUnderlying);
        emit Withdrawal(msg.sender, to, amountUnderlying);
    }

    /// @notice returns total balance of PCV in the Deposit excluding the FEI
    /// @dev returns stale values from Compound if the market hasn't been updated
    function balance() public view override returns (uint256) {
        uint256 exchangeRate = cToken.exchangeRateStored();
        return
            (cToken.balanceOf(address(this)) * exchangeRate) /
            EXCHANGE_RATE_SCALE;
    }

    function _transferUnderlying(address to, uint256 amount) internal virtual;
}",489
RealWorld_BA_102_Deviation_RealWord_20240827220623.log,102,Deviation,8343,6095,14438,91.0,0.163615,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.4;

import {Constants} from ""./../Constants.sol"";
import {SafeCast} from ""@openzeppelin/contracts/utils/math/SafeCast.sol"";

/// @title contract that determines whether or not a new value is within
/// an acceptable deviation threshold
/// @author Elliot Friedman, FEI Protocol
library Deviation {
    using SafeCast for *;

    /// @notice event that is emitted when the threshold is changed
    event DeviationThresholdUpdate(uint256 oldThreshold, uint256 newThreshold);

    /// @notice return the percent deviation between a and b in basis points terms
    function calculateDeviationThresholdBasisPoints(int256 a, int256 b)
        internal
        pure
        returns (uint256)
    {
        int256 delta = a - b;
        int256 basisPoints = (delta * Constants.BP_INT) / a;

        return (basisPoints < 0 ? basisPoints * -1 : basisPoints).toUint256();
    }

    /// @notice function to return whether or not the new price is within
    /// the acceptable deviation threshold
    function isWithinDeviationThreshold(
        uint256 maxDeviationThresholdBasisPoints,
        int256 oldValue,
        int256 newValue
    ) internal pure returns (bool) {
        return
            maxDeviationThresholdBasisPoints >=
            calculateDeviationThresholdBasisPoints(oldValue, newValue);
    }
}",312
RealWorld_BA_102_IOraclePassThrough_RealWord_20240827220336.log,102,IOraclePassThrough,7741,4724,12465,76.0,0.133185,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.4;

import {Decimal} from ""../external/Decimal.sol"";
import {IScalingPriceOracle} from ""./IScalingPriceOracle.sol"";

/// @notice interface to get data from the Scaling Price Oracle
interface IOraclePassThrough {
    // ----------- Getters -----------

    /// @notice reference to the scaling price oracle
    function scalingPriceOracle() external view returns (IScalingPriceOracle);

    /// @notice function to get the current oracle price for the OracleRef contract
    function read()
        external
        view
        returns (Decimal.D256 memory price, bool valid);

    /// @notice function to get the current oracle price for the entire system
    function getCurrentOraclePrice() external view returns (uint256);

    // ----------- Governor only state changing api -----------

    /// @notice function to update the pointer to the scaling price oracle
    /// requires approval from both VOLT and FRAX governance to sign off on the change
    function updateScalingPriceOracle(IScalingPriceOracle newScalingPriceOracle)
        external;

    /// @notice event emitted when the scaling price oracle is updated
    event ScalingPriceOracleUpdate(
        IScalingPriceOracle oldScalingPriceOracle,
        IScalingPriceOracle newScalingPriceOracle
    );
}",275
RealWorld_BA_102_IGlobalRateLimitedMinter_RealWord_20240827220935.log,102,IGlobalRateLimitedMinter,7203,5183,12386,78.0,0.139675,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.4;

import ""./IMultiRateLimited.sol"";

/// @notice global contract to handle rate limited minting of VOLT on a global level
/// allows whitelisted minters to call in and specify the address to mint VOLT to within
/// the calling contract's limits
interface IGlobalRateLimitedMinter is IMultiRateLimited {
    /// @notice function that all VOLT minters call to mint VOLT
    /// pausable and depletes the msg.sender's buffer
    /// @param to the recipient address of the minted VOLT
    /// @param amount the amount of VOLT to mint
    function mintVolt(address to, uint256 amount) external;

    /// @notice mint VOLT to the target address and deplete the whole rate limited
    ///  minter's buffer, pausable and completely depletes the msg.sender's buffer
    /// @param to the recipient address of the minted VOLT
    /// mints all VOLT that msg.sender has in the buffer
    function mintMaxAllowableVolt(address to) external;
}",246
RealWorld_BA_102_IScalingPriceOracle_RealWord_20240827220141.log,102,IScalingPriceOracle,9500,5652,15152,113.0,0.16054,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.4;

import {Decimal} from ""../external/Decimal.sol"";

/// @notice contract that receives a chainlink price feed and then linearly interpolates that rate over
/// a 1 month period into the VOLT price. Interest is compounded monthly when the rate is updated
/// @author Elliot Friedman
interface IScalingPriceOracle {
    /// @notice the time frame over which all changes in CPI data are applied
    /// 28 days was chosen as that is the shortest length of a month
    function TIMEFRAME() external view returns (uint256);

    /// @notice the maximum allowable deviation in basis points for a new chainlink oracle update
    /// only allow price changes by 20% in a month.
    /// Any change over this threshold in either direction will be rejected
    function MAXORACLEDEVIATION() external view returns (uint256);

    /// @notice get the current scaled oracle price
    /// applies the change smoothly over a 28 day period
    /// scaled by 18 decimals
    function getCurrentOraclePrice() external view returns (uint256);

    /// @notice current amount that oracle price is inflating/deflating by monthly in basis points
    function monthlyChangeRateBasisPoints() external view returns (int256);

    /// @notice oracle price. starts off at 1 scaled up by 18 decimals
    function oraclePrice() external view returns (uint256);

    /// @notice event when the monthly change rate is updated
    event CPIMonthlyChangeRateUpdate(
        int256 oldChangeRateBasisPoints,
        int256 newChangeRateBasisPoints
    );
}",358
RealWorld_BA_102_BokkyPooBahsDateTimeLibrary_RealWord_20240827224507.log,102,BokkyPooBahsDateTimeLibrary,69722,5513,75235,84.0,0.45887,"// SPDX-License-Identifier: GNU Lesser General Public License 3.0
pragma solidity ^0.8.4;

// ----------------------------------------------------------------------------
// BokkyPooBah's DateTime Library v1.00
//
// A gas-efficient Solidity date and time library
//
// https://github.com/bokkypoobah/BokkyPooBahsDateTimeLibrary
//
// Tested date range 1970/01/01 to 2345/12/31
//
// Conventions:
// Unit      | Range         | Notes
// :-------- |:-------------:|:-----
// timestamp | >= 0          | Unix timestamp, number of seconds since 1970/01/01 00:00:00 UTC
// year      | 1970 ... 2345 |
// month     | 1 ... 12      |
// day       | 1 ... 31      |
// hour      | 0 ... 23      |
// minute    | 0 ... 59      |
// second    | 0 ... 59      |
// dayOfWeek | 1 ... 7       | 1 = Monday, ..., 7 = Sunday
//
//
// Enjoy. (c) BokkyPooBah / Bok Consulting Pty Ltd 2018.
//
// GNU Lesser General Public License 3.0
// https://www.gnu.org/licenses/lgpl-3.0.en.html
// ----------------------------------------------------------------------------

library BokkyPooBahsDateTimeLibrary {
    uint256 constant SECONDS_PER_DAY = 24 * 60 * 60;
    uint256 constant SECONDS_PER_HOUR = 60 * 60;
    uint256 constant SECONDS_PER_MINUTE = 60;
    int256 constant OFFSET19700101 = 2440588;

    uint256 constant DOW_MON = 1;
    uint256 constant DOW_TUE = 2;
    uint256 constant DOW_WED = 3;
    uint256 constant DOW_THU = 4;
    uint256 constant DOW_FRI = 5;
    uint256 constant DOW_SAT = 6;
    uint256 constant DOW_SUN = 7;

    // ------------------------------------------------------------------------
    // Calculate the number of days from 1970/01/01 to year/month/day using
    // the date conversion algorithm from
    //   http://aa.usno.navy.mil/faq/docs/JD_Formula.php
    // and subtracting the offset 2440588 so that 1970/01/01 is day 0
    //
    // days = day
    //      - 32075
    //      + 1461 * (year + 4800 + (month - 14) / 12) / 4
    //      + 367 * (month - 2 - (month - 14) / 12 * 12) / 12
    //      - 3 * ((year + 4900 + (month - 14) / 12) / 100) / 4
    //      - offset
    // ------------------------------------------------------------------------
    function _daysFromDate(
        uint256 year,
        uint256 month,
        uint256 day
    ) internal pure returns (uint256 _days) {
        require(year >= 1970);
        int256 _year = int256(year);
        int256 _month = int256(month);
        int256 _day = int256(day);

        int256 __days = _day -
            32075 +
            (1461 * (_year + 4800 + (_month - 14) / 12)) /
            4 +
            (367 * (_month - 2 - ((_month - 14) / 12) * 12)) /
            12 -
            (3 * ((_year + 4900 + (_month - 14) / 12) / 100)) /
            4 -
            OFFSET19700101;

        _days = uint256(__days);
    }

    // ------------------------------------------------------------------------
    // Calculate year/month/day from the number of days since 1970/01/01 using
    // the date conversion algorithm from
    //   http://aa.usno.navy.mil/faq/docs/JD_Formula.php
    // and adding the offset 2440588 so that 1970/01/01 is day 0
    //
    // int L = days + 68569 + offset
    // int N = 4 * L / 146097
    // L = L - (146097 * N + 3) / 4
    // year = 4000 * (L + 1) / 1461001
    // L = L - 1461 * year / 4 + 31
    // month = 80 * L / 2447
    // dd = L - 2447 * month / 80
    // L = month / 11
    // month = month + 2 - 12 * L
    // year = 100 * (N - 49) + year + L
    // ------------------------------------------------------------------------
    function _daysToDate(uint256 _days)
        internal
        pure
        returns (
            uint256 year,
            uint256 month,
            uint256 day
        )
    {
        int256 __days = int256(_days);

        int256 L = __days + 68569 + OFFSET19700101;
        int256 N = (4 * L) / 146097;
        L = L - (146097 * N + 3) / 4;
        int256 _year = (4000 * (L + 1)) / 1461001;
        L = L - (1461 * _year) / 4 + 31;
        int256 _month = (80 * L) / 2447;
        int256 _day = L - (2447 * _month) / 80;
        L = _month / 11;
        _month = _month + 2 - 12 * L;
        _year = 100 * (N - 49) + _year + L;

        year = uint256(_year);
        month = uint256(_month);
        day = uint256(_day);
    }

    function timestampFromDate(
        uint256 year,
        uint256 month,
        uint256 day
    ) internal pure returns (uint256 timestamp) {
        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY;
    }

    function timestampFromDateTime(
        uint256 year,
        uint256 month,
        uint256 day,
        uint256 hour,
        uint256 minute,
        uint256 second
    ) internal pure returns (uint256 timestamp) {
        timestamp =
            _daysFromDate(year, month, day) *
            SECONDS_PER_DAY +
            hour *
            SECONDS_PER_HOUR +
            minute *
            SECONDS_PER_MINUTE +
            second;
    }

    function timestampToDate(uint256 timestamp)
        internal
        pure
        returns (
            uint256 year,
            uint256 month,
            uint256 day
        )
    {
        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);
    }

    function timestampToDateTime(uint256 timestamp)
        internal
        pure
        returns (
            uint256 year,
            uint256 month,
            uint256 day,
            uint256 hour,
            uint256 minute,
            uint256 second
        )
    {
        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);
        uint256 secs = timestamp % SECONDS_PER_DAY;
        hour = secs / SECONDS_PER_HOUR;
        secs = secs % SECONDS_PER_HOUR;
        minute = secs / SECONDS_PER_MINUTE;
        second = secs % SECONDS_PER_MINUTE;
    }

    function isValidDate(
        uint256 year,
        uint256 month,
        uint256 day
    ) internal pure returns (bool valid) {
        if (year >= 1970 && month > 0 && month <= 12) {
            uint256 daysInMonth = _getDaysInMonth(year, month);
            if (day > 0 && day <= daysInMonth) {
                valid = true;
            }
        }
    }

    function isValidDateTime(
        uint256 year,
        uint256 month,
        uint256 day,
        uint256 hour,
        uint256 minute,
        uint256 second
    ) internal pure returns (bool valid) {
        if (isValidDate(year, month, day)) {
            if (hour < 24 && minute < 60 && second < 60) {
                valid = true;
            }
        }
    }

    function isLeapYear(uint256 timestamp)
        internal
        pure
        returns (bool leapYear)
    {
        uint256 year;
        uint256 month;
        uint256 day;
        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);
        leapYear = _isLeapYear(year);
    }

    function _isLeapYear(uint256 year) internal pure returns (bool leapYear) {
        leapYear = ((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0);
    }

    function isWeekDay(uint256 timestamp) internal pure returns (bool weekDay) {
        weekDay = getDayOfWeek(timestamp) <= DOW_FRI;
    }

    function isWeekEnd(uint256 timestamp) internal pure returns (bool weekEnd) {
        weekEnd = getDayOfWeek(timestamp) >= DOW_SAT;
    }

    function getDaysInMonth(uint256 timestamp)
        internal
        pure
        returns (uint256 daysInMonth)
    {
        uint256 year;
        uint256 month;
        uint256 day;
        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);
        daysInMonth = _getDaysInMonth(year, month);
    }

    function _getDaysInMonth(uint256 year, uint256 month)
        internal
        pure
        returns (uint256 daysInMonth)
    {
        if (
            month == 1 ||
            month == 3 ||
            month == 5 ||
            month == 7 ||
            month == 8 ||
            month == 10 ||
            month == 12
        ) {
            daysInMonth = 31;
        } else if (month != 2) {
            daysInMonth = 30;
        } else {
            daysInMonth = _isLeapYear(year) ? 29 : 28;
        }
    }

    // 1 = Monday, 7 = Sunday
    function getDayOfWeek(uint256 timestamp)
        internal
        pure
        returns (uint256 dayOfWeek)
    {
        uint256 _days = timestamp / SECONDS_PER_DAY;
        dayOfWeek = ((_days + 3) % 7) + 1;
    }

    function getYear(uint256 timestamp) internal pure returns (uint256 year) {
        uint256 month;
        uint256 day;
        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);
    }

    function getMonth(uint256 timestamp) internal pure returns (uint256 month) {
        uint256 year;
        uint256 day;
        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);
    }

    function getDay(uint256 timestamp) internal pure returns (uint256 day) {
        uint256 year;
        uint256 month;
        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);
    }

    function getHour(uint256 timestamp) internal pure returns (uint256 hour) {
        uint256 secs = timestamp % SECONDS_PER_DAY;
        hour = secs / SECONDS_PER_HOUR;
    }

    function getMinute(uint256 timestamp)
        internal
        pure
        returns (uint256 minute)
    {
        uint256 secs = timestamp % SECONDS_PER_HOUR;
        minute = secs / SECONDS_PER_MINUTE;
    }

    function getSecond(uint256 timestamp)
        internal
        pure
        returns (uint256 second)
    {
        second = timestamp % SECONDS_PER_MINUTE;
    }

    function addYears(uint256 timestamp, uint256 _years)
        internal
        pure
        returns (uint256 newTimestamp)
    {
        uint256 year;
        uint256 month;
        uint256 day;
        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);
        year += _years;
        uint256 daysInMonth = _getDaysInMonth(year, month);
        if (day > daysInMonth) {
            day = daysInMonth;
        }
        newTimestamp =
            _daysFromDate(year, month, day) *
            SECONDS_PER_DAY +
            (timestamp % SECONDS_PER_DAY);
        require(newTimestamp >= timestamp);
    }

    function addMonths(uint256 timestamp, uint256 _months)
        internal
        pure
        returns (uint256 newTimestamp)
    {
        uint256 year;
        uint256 month;
        uint256 day;
        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);
        month += _months;
        year += (month - 1) / 12;
        month = ((month - 1) % 12) + 1;
        uint256 daysInMonth = _getDaysInMonth(year, month);
        if (day > daysInMonth) {
            day = daysInMonth;
        }
        newTimestamp =
            _daysFromDate(year, month, day) *
            SECONDS_PER_DAY +
            (timestamp % SECONDS_PER_DAY);
        require(newTimestamp >= timestamp);
    }

    function addDays(uint256 timestamp, uint256 _days)
        internal
        pure
        returns (uint256 newTimestamp)
    {
        newTimestamp = timestamp + _days * SECONDS_PER_DAY;
        require(newTimestamp >= timestamp);
    }

    function addHours(uint256 timestamp, uint256 _hours)
        internal
        pure
        returns (uint256 newTimestamp)
    {
        newTimestamp = timestamp + _hours * SECONDS_PER_HOUR;
        require(newTimestamp >= timestamp);
    }

    function addMinutes(uint256 timestamp, uint256 _minutes)
        internal
        pure
        returns (uint256 newTimestamp)
    {
        newTimestamp = timestamp + _minutes * SECONDS_PER_MINUTE;
        require(newTimestamp >= timestamp);
    }

    function addSeconds(uint256 timestamp, uint256 _seconds)
        internal
        pure
        returns (uint256 newTimestamp)
    {
        newTimestamp = timestamp + _seconds;
        require(newTimestamp >= timestamp);
    }

    function subYears(uint256 timestamp, uint256 _years)
        internal
        pure
        returns (uint256 newTimestamp)
    {
        uint256 year;
        uint256 month;
        uint256 day;
        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);
        year -= _years;
        uint256 daysInMonth = _getDaysInMonth(year, month);
        if (day > daysInMonth) {
            day = daysInMonth;
        }
        newTimestamp =
            _daysFromDate(year, month, day) *
            SECONDS_PER_DAY +
            (timestamp % SECONDS_PER_DAY);
        require(newTimestamp <= timestamp);
    }

    function subMonths(uint256 timestamp, uint256 _months)
        internal
        pure
        returns (uint256 newTimestamp)
    {
        uint256 year;
        uint256 month;
        uint256 day;
        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);
        uint256 yearMonth = year * 12 + (month - 1) - _months;
        year = yearMonth / 12;
        month = (yearMonth % 12) + 1;
        uint256 daysInMonth = _getDaysInMonth(year, month);
        if (day > daysInMonth) {
            day = daysInMonth;
        }
        newTimestamp =
            _daysFromDate(year, month, day) *
            SECONDS_PER_DAY +
            (timestamp % SECONDS_PER_DAY);
        require(newTimestamp <= timestamp);
    }

    function subDays(uint256 timestamp, uint256 _days)
        internal
        pure
        returns (uint256 newTimestamp)
    {
        newTimestamp = timestamp - _days * SECONDS_PER_DAY;
        require(newTimestamp <= timestamp);
    }

    function subHours(uint256 timestamp, uint256 _hours)
        internal
        pure
        returns (uint256 newTimestamp)
    {
        newTimestamp = timestamp - _hours * SECONDS_PER_HOUR;
        require(newTimestamp <= timestamp);
    }

    function subMinutes(uint256 timestamp, uint256 _minutes)
        internal
        pure
        returns (uint256 newTimestamp)
    {
        newTimestamp = timestamp - _minutes * SECONDS_PER_MINUTE;
        require(newTimestamp <= timestamp);
    }

    function subSeconds(uint256 timestamp, uint256 _seconds)
        internal
        pure
        returns (uint256 newTimestamp)
    {
        newTimestamp = timestamp - _seconds;
        require(newTimestamp <= timestamp);
    }

    function diffYears(uint256 fromTimestamp, uint256 toTimestamp)
        internal
        pure
        returns (uint256 _years)
    {
        require(fromTimestamp <= toTimestamp);
        uint256 fromYear;
        uint256 fromMonth;
        uint256 fromDay;
        uint256 toYear;
        uint256 toMonth;
        uint256 toDay;
        (fromYear, fromMonth, fromDay) = _daysToDate(
            fromTimestamp / SECONDS_PER_DAY
        );
        (toYear, toMonth, toDay) = _daysToDate(toTimestamp / SECONDS_PER_DAY);
        _years = toYear - fromYear;
    }

    function diffMonths(uint256 fromTimestamp, uint256 toTimestamp)
        internal
        pure
        returns (uint256 _months)
    {
        require(fromTimestamp <= toTimestamp);
        uint256 fromYear;
        uint256 fromMonth;
        uint256 fromDay;
        uint256 toYear;
        uint256 toMonth;
        uint256 toDay;
        (fromYear, fromMonth, fromDay) = _daysToDate(
            fromTimestamp / SECONDS_PER_DAY
        );
        (toYear, toMonth, toDay) = _daysToDate(toTimestamp / SECONDS_PER_DAY);
        _months = toYear * 12 + toMonth - fromYear * 12 - fromMonth;
    }

    function diffDays(uint256 fromTimestamp, uint256 toTimestamp)
        internal
        pure
        returns (uint256 _days)
    {
        require(fromTimestamp <= toTimestamp);
        _days = (toTimestamp - fromTimestamp) / SECONDS_PER_DAY;
    }

    function diffHours(uint256 fromTimestamp, uint256 toTimestamp)
        internal
        pure
        returns (uint256 _hours)
    {
        require(fromTimestamp <= toTimestamp);
        _hours = (toTimestamp - fromTimestamp) / SECONDS_PER_HOUR;
    }

    function diffMinutes(uint256 fromTimestamp, uint256 toTimestamp)
        internal
        pure
        returns (uint256 _minutes)
    {
        require(fromTimestamp <= toTimestamp);
        _minutes = (toTimestamp - fromTimestamp) / SECONDS_PER_MINUTE;
    }

    function diffSeconds(uint256 fromTimestamp, uint256 toTimestamp)
        internal
        pure
        returns (uint256 _seconds)
    {
        require(fromTimestamp <= toTimestamp);
        _seconds = toTimestamp - fromTimestamp;
    }
}",4111
RealWorld_BA_102_GlobalRateLimitedMinter_RealWord_20240827221055.log,102,GlobalRateLimitedMinter,13203,5412,18615,94.0,0.174255,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.4;

import {MultiRateLimited} from ""./MultiRateLimited.sol"";
import {IGlobalRateLimitedMinter} from ""./IGlobalRateLimitedMinter.sol"";
import {CoreRef} from ""./../refs/CoreRef.sol"";
import {Math} from ""@openzeppelin/contracts/utils/math/Math.sol"";

/// @notice global contract to handle rate limited minting of VOLT on a global level
/// allows whitelisted minters to call in and specify the address to mint VOLT to within
/// that contract's limits
contract GlobalRateLimitedMinter is MultiRateLimited, IGlobalRateLimitedMinter {
    /// @param coreAddress address of the core contract
    /// @param _globalMaxRateLimitPerSecond maximum amount of VOLT that can replenish per second ever, this amount cannot be changed by governance
    /// @param _perAddressRateLimitMaximum maximum rate limit per second per address
    /// @param _maxRateLimitPerSecondPerAddress maximum rate limit per second per address in multi rate limited
    /// @param _maxBufferCap maximum buffer cap in multi rate limited contract
    /// @param _globalBufferCap maximum global buffer cap
    constructor(
        address coreAddress,
        uint256 _globalMaxRateLimitPerSecond,
        uint256 _perAddressRateLimitMaximum,
        uint256 _maxRateLimitPerSecondPerAddress,
        uint256 _maxBufferCap,
        uint256 _globalBufferCap
    )
        CoreRef(coreAddress)
        MultiRateLimited(
            _globalMaxRateLimitPerSecond,
            _perAddressRateLimitMaximum,
            _maxRateLimitPerSecondPerAddress,
            _maxBufferCap,
            _globalBufferCap
        )
    {}

    /// @notice mint VOLT to the target address and deplete the buffer
    /// pausable and depletes the msg.sender's buffer
    /// @param to the recipient address of the minted VOLT
    /// @param amount the amount of VOLT to mint
    function mintVolt(address to, uint256 amount)
        external
        virtual
        override
        whenNotPaused
    {
        _depleteIndividualBuffer(msg.sender, amount);
        _mintVolt(to, amount);
    }

    /// @notice mint VOLT to the target address and deplete the whole rate limited
    ///  minter's buffer, pausable and completely depletes the msg.sender's buffer
    /// @param to the recipient address of the minted VOLT
    /// mints all VOLT that msg.sender has in the buffer
    function mintMaxAllowableVolt(address to)
        external
        virtual
        override
        whenNotPaused
    {
        uint256 amount = Math.min(individualBuffer(msg.sender), buffer());

        _depleteIndividualBuffer(msg.sender, amount);
        _mintVolt(to, amount);
    }
}",617
RealWorld_BA_102_Fixtures_RealWord_20240827213505.log,102,Fixtures,10780,4872,15652,80.0,0.15134,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.4;

import {Core, Vcon, Volt, IERC20} from ""../../../core/Core.sol"";
import {DSTest} from ""./DSTest.sol"";
import {Vm} from ""./Vm.sol"";

struct FeiTestAddresses {
    address userAddress;
    address secondUserAddress;
    address beneficiaryAddress1;
    address beneficiaryAddress2;
    address governorAddress;
    address genesisGroup;
    address keeperAddress;
    address pcvControllerAddress;
    address minterAddress;
    address burnerAddress;
    address guardianAddress;
}

/// @dev Get a list of addresses
function getAddresses() pure returns (FeiTestAddresses memory) {
    FeiTestAddresses memory addresses = FeiTestAddresses({
        userAddress: address(0x1),
        secondUserAddress: address(0x2),
        beneficiaryAddress1: address(0x3),
        beneficiaryAddress2: address(0x4),
        governorAddress: address(0x5),
        genesisGroup: address(0x6),
        keeperAddress: address(0x7),
        pcvControllerAddress: address(0x8),
        minterAddress: address(0x9),
        burnerAddress: address(0x10),
        guardianAddress: address(0x11)
    });

    return addresses;
}

/// @dev Deploy and configure Core
function getCore() returns (Core) {
    address HEVM_ADDRESS = address(
        bytes20(uint160(uint256(keccak256(""hevm cheat code""))))
    );
    Vm vm = Vm(HEVM_ADDRESS);
    FeiTestAddresses memory addresses = getAddresses();

    // Deploy Core from Governor address
    vm.startPrank(addresses.governorAddress);
    Core core = new Core();
    core.init();
    Vcon vcon = new Vcon(addresses.governorAddress, addresses.governorAddress);

    core.setVcon(IERC20(address(vcon)));
    core.grantMinter(addresses.minterAddress);
    core.grantBurner(addresses.burnerAddress);
    core.grantPCVController(addresses.pcvControllerAddress);
    core.grantGuardian(addresses.guardianAddress);

    vm.stopPrank();
    return core;
}",485
RealWorld_BA_102_IPermissionsRead_RealWord_20240827212304.log,102,IPermissionsRead,4871,3508,8379,69.0,0.094515,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.4;

/// @title Permissions Read interface
/// @author Fei Protocol
interface IPermissionsRead {
    // ----------- Getters -----------

    function isBurner(address _address) external view returns (bool);

    function isMinter(address _address) external view returns (bool);

    function isGovernor(address _address) external view returns (bool);

    function isGuardian(address _address) external view returns (bool);

    function isPCVController(address _address) external view returns (bool);
}",126
RealWorld_BA_102_INonCustodialPSM_RealWord_20240827221634.log,102,INonCustodialPSM,24317,5830,30147,96.0,0.238185,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.4;

import {IERC20} from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import {IPCVDeposit} from ""../pcv/IPCVDeposit.sol"";
import {GlobalRateLimitedMinter} from ""../utils/GlobalRateLimitedMinter.sol"";

/**
 * @title Fei Peg Stability Module
 * @author Fei Protocol
 * @notice  The Fei PSM is a contract which pulls reserve assets from PCV Deposits in order to exchange FEI at $1 of underlying assets with a fee.
 * `mint()` - buy FEI for $1 of underlying tokens
 * `redeem()` - sell FEI back for $1 of the same
 *
 *
 * The contract is a
 * OracleRef - to determine price of underlying, and
 * RateLimitedReplenishable - to stop infinite mints and related DOS issues
 *
 * Inspired by MakerDAO PSM, code written without reference
 */
interface INonCustodialPSM {
    // ----------- Public State Changing API -----------

    /// @notice mint `amountFeiOut` FEI to address `to` for `amountIn` underlying tokens
    /// @dev see getMintAmountOut() to pre-calculate amount out
    function mint(
        address to,
        uint256 amountIn,
        uint256 minAmountOut
    ) external returns (uint256 amountFeiOut);

    /// @notice redeem `amountFeiIn` FEI for `amountOut` underlying tokens and send to address `to`
    /// @dev see getRedeemAmountOut() to pre-calculate amount out
    function redeem(
        address to,
        uint256 amountFeiIn,
        uint256 minAmountOut
    ) external returns (uint256 amountOut);

    // ----------- Governor or Admin Only State Changing API -----------

    /// @notice set the mint fee vs oracle price in basis point terms
    function setMintFee(uint256 newMintFeeBasisPoints) external;

    /// @notice set the redemption fee vs oracle price in basis point terms
    function setRedeemFee(uint256 newRedeemFeeBasisPoints) external;

    /// @notice set the target for sending surplus reserves
    function setPCVDeposit(IPCVDeposit newTarget) external;

    /// @notice set the target to call for FEI minting
    function setGlobalRateLimitedMinter(GlobalRateLimitedMinter newMinter)
        external;

    /// @notice withdraw ERC20 from the contract
    function withdrawERC20(
        address token,
        address to,
        uint256 amount
    ) external;

    // ----------- Getters -----------

    /// @notice calculate the amount of FEI out for a given `amountIn` of underlying
    function getMintAmountOut(uint256 amountIn)
        external
        view
        returns (uint256 amountFeiOut);

    /// @notice calculate the amount of underlying out for a given `amountFeiIn` of FEI
    function getRedeemAmountOut(uint256 amountFeiIn)
        external
        view
        returns (uint256 amountOut);

    /// @notice the maximum mint amount out
    function getMaxMintAmountOut() external view returns (uint256);

    /// @notice the mint fee vs oracle price in basis point terms
    function mintFeeBasisPoints() external view returns (uint256);

    /// @notice the redemption fee vs oracle price in basis point terms
    function redeemFeeBasisPoints() external view returns (uint256);

    /// @notice the underlying token exchanged for FEI
    function underlyingToken() external view returns (IERC20);

    /// @notice the PCV deposit target to deposit and withdraw from
    function pcvDeposit() external view returns (IPCVDeposit);

    /// @notice Rate Limited Minter contract that will be called when FEI needs to be minted
    function rateLimitedMinter()
        external
        view
        returns (GlobalRateLimitedMinter);

    /// @notice the max mint and redeem fee in basis points
    function MAX_FEE() external view returns (uint256);

    // ----------- Events -----------

    /// @notice event emitted when a new max fee is set
    event MaxFeeUpdate(uint256 oldMaxFee, uint256 newMaxFee);

    /// @notice event emitted when a new mint fee is set
    event MintFeeUpdate(uint256 oldMintFee, uint256 newMintFee);

    /// @notice event emitted when a new redeem fee is set
    event RedeemFeeUpdate(uint256 oldRedeemFee, uint256 newRedeemFee);

    /// @notice event emitted when reservesThreshold is updated
    event ReservesThresholdUpdate(
        uint256 oldReservesThreshold,
        uint256 newReservesThreshold
    );

    /// @notice event emitted when surplus target is updated
    event PCVDepositUpdate(IPCVDeposit oldTarget, IPCVDeposit newTarget);

    /// @notice event emitted upon a redemption
    event Redeem(address to, uint256 amountFeiIn, uint256 amountAssetOut);

    /// @notice event emitted when fei gets minted
    event Mint(address to, uint256 amountIn, uint256 amountFeiOut);

    /// @notice event emitted when ERC20 tokens get withdrawn
    event WithdrawERC20(
        address indexed _caller,
        address indexed _token,
        address indexed _to,
        uint256 _amount
    );

    /// @notice event emitted when global rate limited minter is updated
    event GlobalRateLimitedMinterUpdate(
        GlobalRateLimitedMinter oldMinter,
        GlobalRateLimitedMinter newMinter
    );

    /// @notice event that is emitted when redemptions are paused
    event RedemptionsPaused(address account);

    /// @notice event that is emitted when redemptions are unpaused
    event RedemptionsUnpaused(address account);

    /// @notice event that is emitted when minting is paused
    event MintingPaused(address account);

    /// @notice event that is emitted when minting is unpaused
    event MintingUnpaused(address account);
}",1310
RealWorld_BA_102_BokkyPooBahsDateTimeContract_RealWord_20240827224325.log,102,BokkyPooBahsDateTimeContract,45297,4958,50255,99.0,0.325645,"// SPDX-License-Identifier: GNU Lesser General Public License 3.0
pragma solidity ^0.8.4;

// ----------------------------------------------------------------------------
// BokkyPooBah's DateTime Library v1.00 - Contract Instance
//
// A gas-efficient Solidity date and time library
//
// https://github.com/bokkypoobah/BokkyPooBahsDateTimeLibrary
//
// Tested date range 1970/01/01 to 2345/12/31
//
// Conventions:
// Unit      | Range         | Notes
// :-------- |:-------------:|:-----
// timestamp | >= 0          | Unix timestamp, number of seconds since 1970/01/01 00:00:00 UTC
// year      | 1970 ... 2345 |
// month     | 1 ... 12      |
// day       | 1 ... 31      |
// hour      | 0 ... 23      |
// minute    | 0 ... 59      |
// second    | 0 ... 59      |
// dayOfWeek | 1 ... 7       | 1 = Monday, ..., 7 = Sunday
//
//
// Enjoy. (c) BokkyPooBah / Bok Consulting Pty Ltd 2018.
//
// GNU Lesser General Public License 3.0
// https://www.gnu.org/licenses/lgpl-3.0.en.html
// ----------------------------------------------------------------------------

import ""./BokkyPooBahsDateTimeLibrary.sol"";

contract BokkyPooBahsDateTimeContract {
    uint256 public constant SECONDS_PER_DAY = 24 * 60 * 60;
    uint256 public constant SECONDS_PER_HOUR = 60 * 60;
    uint256 public constant SECONDS_PER_MINUTE = 60;
    int256 public constant OFFSET19700101 = 2440588;

    uint256 public constant DOW_MON = 1;
    uint256 public constant DOW_TUE = 2;
    uint256 public constant DOW_WED = 3;
    uint256 public constant DOW_THU = 4;
    uint256 public constant DOW_FRI = 5;
    uint256 public constant DOW_SAT = 6;
    uint256 public constant DOW_SUN = 7;

    function _now() public view returns (uint256 timestamp) {
        timestamp = block.timestamp;
    }

    function _nowDateTime()
        public
        view
        returns (
            uint256 year,
            uint256 month,
            uint256 day,
            uint256 hour,
            uint256 minute,
            uint256 second
        )
    {
        (year, month, day, hour, minute, second) = BokkyPooBahsDateTimeLibrary
            .timestampToDateTime(block.timestamp);
    }

    function _daysFromDate(
        uint256 year,
        uint256 month,
        uint256 day
    ) public pure returns (uint256 _days) {
        return BokkyPooBahsDateTimeLibrary._daysFromDate(year, month, day);
    }

    function _daysToDate(uint256 _days)
        public
        pure
        returns (
            uint256 year,
            uint256 month,
            uint256 day
        )
    {
        return BokkyPooBahsDateTimeLibrary._daysToDate(_days);
    }

    function timestampFromDate(
        uint256 year,
        uint256 month,
        uint256 day
    ) public pure returns (uint256 timestamp) {
        return BokkyPooBahsDateTimeLibrary.timestampFromDate(year, month, day);
    }

    function timestampFromDateTime(
        uint256 year,
        uint256 month,
        uint256 day,
        uint256 hour,
        uint256 minute,
        uint256 second
    ) public pure returns (uint256 timestamp) {
        return
            BokkyPooBahsDateTimeLibrary.timestampFromDateTime(
                year,
                month,
                day,
                hour,
                minute,
                second
            );
    }

    function timestampToDate(uint256 timestamp)
        public
        pure
        returns (
            uint256 year,
            uint256 month,
            uint256 day
        )
    {
        (year, month, day) = BokkyPooBahsDateTimeLibrary.timestampToDate(
            timestamp
        );
    }

    function timestampToDateTime(uint256 timestamp)
        public
        pure
        returns (
            uint256 year,
            uint256 month,
            uint256 day,
            uint256 hour,
            uint256 minute,
            uint256 second
        )
    {
        (year, month, day, hour, minute, second) = BokkyPooBahsDateTimeLibrary
            .timestampToDateTime(timestamp);
    }

    function isValidDate(
        uint256 year,
        uint256 month,
        uint256 day
    ) public pure returns (bool valid) {
        valid = BokkyPooBahsDateTimeLibrary.isValidDate(year, month, day);
    }

    function isValidDateTime(
        uint256 year,
        uint256 month,
        uint256 day,
        uint256 hour,
        uint256 minute,
        uint256 second
    ) public pure returns (bool valid) {
        valid = BokkyPooBahsDateTimeLibrary.isValidDateTime(
            year,
            month,
            day,
            hour,
            minute,
            second
        );
    }

    function isLeapYear(uint256 timestamp) public pure returns (bool leapYear) {
        leapYear = BokkyPooBahsDateTimeLibrary.isLeapYear(timestamp);
    }

    function _isLeapYear(uint256 year) public pure returns (bool leapYear) {
        leapYear = BokkyPooBahsDateTimeLibrary._isLeapYear(year);
    }

    function isWeekDay(uint256 timestamp) public pure returns (bool weekDay) {
        weekDay = BokkyPooBahsDateTimeLibrary.isWeekDay(timestamp);
    }

    function isWeekEnd(uint256 timestamp) public pure returns (bool weekEnd) {
        weekEnd = BokkyPooBahsDateTimeLibrary.isWeekEnd(timestamp);
    }

    function getDaysInMonth(uint256 timestamp)
        public
        pure
        returns (uint256 daysInMonth)
    {
        daysInMonth = BokkyPooBahsDateTimeLibrary.getDaysInMonth(timestamp);
    }

    function _getDaysInMonth(uint256 year, uint256 month)
        public
        pure
        returns (uint256 daysInMonth)
    {
        daysInMonth = BokkyPooBahsDateTimeLibrary._getDaysInMonth(year, month);
    }

    function getDayOfWeek(uint256 timestamp)
        public
        pure
        returns (uint256 dayOfWeek)
    {
        dayOfWeek = BokkyPooBahsDateTimeLibrary.getDayOfWeek(timestamp);
    }

    function getYear(uint256 timestamp) public pure returns (uint256 year) {
        year = BokkyPooBahsDateTimeLibrary.getYear(timestamp);
    }

    function getMonth(uint256 timestamp) public pure returns (uint256 month) {
        month = BokkyPooBahsDateTimeLibrary.getMonth(timestamp);
    }

    function getDay(uint256 timestamp) public pure returns (uint256 day) {
        day = BokkyPooBahsDateTimeLibrary.getDay(timestamp);
    }

    function getHour(uint256 timestamp) public pure returns (uint256 hour) {
        hour = BokkyPooBahsDateTimeLibrary.getHour(timestamp);
    }

    function getMinute(uint256 timestamp) public pure returns (uint256 minute) {
        minute = BokkyPooBahsDateTimeLibrary.getMinute(timestamp);
    }

    function getSecond(uint256 timestamp) public pure returns (uint256 second) {
        second = BokkyPooBahsDateTimeLibrary.getSecond(timestamp);
    }

    function addYears(uint256 timestamp, uint256 _years)
        public
        pure
        returns (uint256 newTimestamp)
    {
        newTimestamp = BokkyPooBahsDateTimeLibrary.addYears(timestamp, _years);
    }

    function addMonths(uint256 timestamp, uint256 _months)
        public
        pure
        returns (uint256 newTimestamp)
    {
        newTimestamp = BokkyPooBahsDateTimeLibrary.addMonths(
            timestamp,
            _months
        );
    }

    function addDays(uint256 timestamp, uint256 _days)
        public
        pure
        returns (uint256 newTimestamp)
    {
        newTimestamp = BokkyPooBahsDateTimeLibrary.addDays(timestamp, _days);
    }

    function addHours(uint256 timestamp, uint256 _hours)
        public
        pure
        returns (uint256 newTimestamp)
    {
        newTimestamp = BokkyPooBahsDateTimeLibrary.addHours(timestamp, _hours);
    }

    function addMinutes(uint256 timestamp, uint256 _minutes)
        public
        pure
        returns (uint256 newTimestamp)
    {
        newTimestamp = BokkyPooBahsDateTimeLibrary.addMinutes(
            timestamp,
            _minutes
        );
    }

    function addSeconds(uint256 timestamp, uint256 _seconds)
        public
        pure
        returns (uint256 newTimestamp)
    {
        newTimestamp = BokkyPooBahsDateTimeLibrary.addSeconds(
            timestamp,
            _seconds
        );
    }

    function subYears(uint256 timestamp, uint256 _years)
        public
        pure
        returns (uint256 newTimestamp)
    {
        newTimestamp = BokkyPooBahsDateTimeLibrary.subYears(timestamp, _years);
    }

    function subMonths(uint256 timestamp, uint256 _months)
        public
        pure
        returns (uint256 newTimestamp)
    {
        newTimestamp = BokkyPooBahsDateTimeLibrary.subMonths(
            timestamp,
            _months
        );
    }

    function subDays(uint256 timestamp, uint256 _days)
        public
        pure
        returns (uint256 newTimestamp)
    {
        newTimestamp = BokkyPooBahsDateTimeLibrary.subDays(timestamp, _days);
    }

    function subHours(uint256 timestamp, uint256 _hours)
        public
        pure
        returns (uint256 newTimestamp)
    {
        newTimestamp = BokkyPooBahsDateTimeLibrary.subHours(timestamp, _hours);
    }

    function subMinutes(uint256 timestamp, uint256 _minutes)
        public
        pure
        returns (uint256 newTimestamp)
    {
        newTimestamp = BokkyPooBahsDateTimeLibrary.subMinutes(
            timestamp,
            _minutes
        );
    }

    function subSeconds(uint256 timestamp, uint256 _seconds)
        public
        pure
        returns (uint256 newTimestamp)
    {
        newTimestamp = BokkyPooBahsDateTimeLibrary.subSeconds(
            timestamp,
            _seconds
        );
    }

    function diffYears(uint256 fromTimestamp, uint256 toTimestamp)
        public
        pure
        returns (uint256 _years)
    {
        _years = BokkyPooBahsDateTimeLibrary.diffYears(
            fromTimestamp,
            toTimestamp
        );
    }

    function diffMonths(uint256 fromTimestamp, uint256 toTimestamp)
        public
        pure
        returns (uint256 _months)
    {
        _months = BokkyPooBahsDateTimeLibrary.diffMonths(
            fromTimestamp,
            toTimestamp
        );
    }

    function diffDays(uint256 fromTimestamp, uint256 toTimestamp)
        public
        pure
        returns (uint256 _days)
    {
        _days = BokkyPooBahsDateTimeLibrary.diffDays(
            fromTimestamp,
            toTimestamp
        );
    }

    function diffHours(uint256 fromTimestamp, uint256 toTimestamp)
        public
        pure
        returns (uint256 _hours)
    {
        _hours = BokkyPooBahsDateTimeLibrary.diffHours(
            fromTimestamp,
            toTimestamp
        );
    }

    function diffMinutes(uint256 fromTimestamp, uint256 toTimestamp)
        public
        pure
        returns (uint256 _minutes)
    {
        _minutes = BokkyPooBahsDateTimeLibrary.diffMinutes(
            fromTimestamp,
            toTimestamp
        );
    }

    function diffSeconds(uint256 fromTimestamp, uint256 toTimestamp)
        public
        pure
        returns (uint256 _seconds)
    {
        _seconds = BokkyPooBahsDateTimeLibrary.diffSeconds(
            fromTimestamp,
            toTimestamp
        );
    }
}",2617
RealWorld_BA_102_IntegrationTestVoltDeployment.t_RealWord_20240827214157.log,102,IntegrationTestVoltDeployment.t,43630,5380,49010,90.0,0.32575,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.0;

import {Vm} from ""./../unit/utils/Vm.sol"";
import {ICore} from ""../../core/ICore.sol"";
import {DSTest} from ""../unit/utils/DSTest.sol"";
import {StdLib} from ""../unit/utils/StdLib.sol"";
import {MockERC20} from ""../../mock/MockERC20.sol"";
import {IVolt, Volt} from ""../../volt/Volt.sol"";
import {OraclePassThrough} from ""../../oracle/OraclePassThrough.sol"";
import {ScalingPriceOracle} from ""../../oracle/ScalingPriceOracle.sol"";
import {MockScalingPriceOracle} from ""../../mock/MockScalingPriceOracle.sol"";
import {ERC20CompoundPCVDeposit} from ""../../pcv/compound/ERC20CompoundPCVDeposit.sol"";
import {getCore, getAddresses, FeiTestAddresses} from ""./../unit/utils/Fixtures.sol"";
import {NonCustodialPSM, GlobalRateLimitedMinter} from ""./../../peg/NonCustodialPSM.sol"";

// Create Core
// Global Rate Limited Minter
// Oracle System
// - Scaling Price Oracle
// - Oracle Pass Through

contract IntegrationTestVoltDeployment is DSTest, StdLib {
    GlobalRateLimitedMinter private rateLimitedMinter;
    NonCustodialPSM private psm;
    ICore private core;
    ICore private feiCore = ICore(0x8d5ED43dCa8C2F7dFB20CF7b53CC7E593635d7b9);
    IVolt private volt;
    IVolt private fei = IVolt(0x956F47F50A910163D8BF957Cf5846D573E7f87CA);

    /// ------------ Minting and RateLimited System Params ------------

    uint256 public constant mintAmount = 10_000_000e18;
    uint256 public constant bufferCap = 10_000_000e18;
    uint256 public constant individualMaxBufferCap = 5_000_000e18;
    uint256 public constant rps = 10_000e18;

    /// ------------ Oracle System Params ------------

    /// @notice prices during test will increase 1% monthly
    int256 public constant monthlyChangeRateBasisPoints = 100;
    uint256 public constant maxDeviationThresholdBasisPoints = 1_000;

    /// @notice chainlink job id on mainnet
    bytes32 public immutable jobId =
        0x3666376662346162636564623438356162323765623762623339636166383237;
    /// @notice chainlink oracle address on mainnet
    address public immutable oracleAddress =
        0x049Bd8C3adC3fE7d3Fc2a44541d955A537c2A484;

    /// @notice live FEI PCV Deposit
    ERC20CompoundPCVDeposit public immutable rariFEIPCVDeposit =
        ERC20CompoundPCVDeposit(0x81DCB06eA4db474D1506Ca6275Ff7D870bA3A1Be);

    /// @notice fei DAO timelock address
    address public immutable feiDAOTimelock =
        0xd51dbA7a94e1adEa403553A8235C302cEbF41a3c;

    /// @notice Oracle Pass Through contract
    OraclePassThrough public oracle;

    Vm public constant vm = Vm(HEVM_ADDRESS);
    FeiTestAddresses public addresses = getAddresses();

    function setUp() public {
        core = getCore();
        volt = core.volt();
        MockScalingPriceOracle mockScalingPriceOracle = new MockScalingPriceOracle(
                oracleAddress,
                jobId,
                10e18,
                101,
                100
            );

        oracle = new OraclePassThrough(
            ScalingPriceOracle(address(mockScalingPriceOracle))
        );

        rateLimitedMinter = new GlobalRateLimitedMinter(
            address(core),
            rps,
            rps,
            rps,
            individualMaxBufferCap,
            bufferCap
        );

        NonCustodialPSM.OracleParams memory oracleParams = NonCustodialPSM
            .OracleParams({
                coreAddress: address(core),
                oracleAddress: address(oracle),
                backupOracle: address(0),
                decimalsNormalizer: 0
            });

        NonCustodialPSM.RateLimitedParams
            memory multiRateLimitedParams = NonCustodialPSM.RateLimitedParams({
                maxRateLimitPerSecond: rps,
                rateLimitPerSecond: rps,
                bufferCap: bufferCap
            });

        NonCustodialPSM.PSMParams memory psmParams = NonCustodialPSM.PSMParams({
            mintFeeBasisPoints: 0,
            redeemFeeBasisPoints: 0,
            underlyingToken: fei,
            pcvDeposit: rariFEIPCVDeposit,
            rateLimitedMinter: rateLimitedMinter
        });

        /// create PSM
        psm = new NonCustodialPSM(
            oracleParams,
            multiRateLimitedParams,
            psmParams
        );

        vm.prank(feiDAOTimelock);
        feiCore.grantPCVController(address(psm));
        vm.prank(feiDAOTimelock);
        fei.mint(address(this), mintAmount);

        vm.startPrank(addresses.governorAddress);

        /// grant the PSM the PCV Controller role
        core.grantMinter(addresses.governorAddress);
        core.grantMinter(address(rateLimitedMinter));
        core.grantPCVController(address(psm));
        core.grantPCVController(addresses.governorAddress);
        rateLimitedMinter.addAddress(
            address(this),
            uint112(rps),
            uint112(bufferCap)
        );
        rateLimitedMinter.addAddress(
            address(psm),
            uint112(rps),
            uint112(bufferCap)
        );

        /// mint VOLT to the user
        volt.mint(address(this), mintAmount);

        vm.stopPrank();
    }

    /// @notice PSM is set up correctly and view functions are working
    function testGetMintAmountOut() public {
        uint256 amountFeiIn = 100;
        assertEq(psm.getMintAmountOut(amountFeiIn), amountFeiIn);
    }

    /// @notice PSM is set up correctly and view functions are working
    function testGetMintAmountOutMintAmount() public {
        assertEq(psm.getMintAmountOut(mintAmount), mintAmount);
    }

    /// @notice PSM is set up correctly and view functions are working
    function testGetMintAmountOutAfterTime() public {
        /// assert that for 101 stables you get 100 VOLT after volt price increases 1%
        uint256 amountFeiIn = 101_000;
        uint256 expectedAmountVoltOut = 99999; /// subtract 1 for precision loss from doInvert

        /// advance the full time period to get the full 1% price increase
        vm.warp(28 days + block.timestamp);

        assertEq(psm.getMintAmountOut(amountFeiIn), expectedAmountVoltOut);
    }

    /// @notice PSM is set up correctly and view functions are working
    function testGetRedeemAmountOut() public {
        uint256 amountFeiIn = 100;
        assertEq(psm.getRedeemAmountOut(amountFeiIn), amountFeiIn);
    }

    /// @notice PSM is set up correctly and view functions are working
    function testGetRedeemAmountOutAfterTime() public {
        uint256 amountVoltIn = 100_000;
        uint256 expectedAmountStableOut = 101_000;

        /// advance the full time period to get the full 1% price increase
        vm.warp(28 days + block.timestamp);

        assertEq(psm.getRedeemAmountOut(amountVoltIn), expectedAmountStableOut);
    }

    /// this test uses FEI as the underlying asset and hooks into a FEI PCV Deposit
    function testSwap() public {
        rariFEIPCVDeposit.deposit(); // get env cleaned up and ready for testing
        uint256 startingUserVoltBalance = volt.balanceOf(address(this));
        uint256 startingPCVDepositFeiBalance = rariFEIPCVDeposit.balance();

        fei.approve(address(psm), mintAmount);
        psm.mint(address(this), mintAmount, mintAmount);
        rariFEIPCVDeposit.deposit();

        uint256 endingUserVoltBalance = volt.balanceOf(address(this));
        uint256 endingPCVDepositFeiBalance = rariFEIPCVDeposit.balance();

        assertEq(endingUserVoltBalance - startingUserVoltBalance, mintAmount);
        assertEq(
            endingPCVDepositFeiBalance - startingPCVDepositFeiBalance,
            mintAmount - 1 /// goes down by 1 because of cToken pricing rounding down
        );
    }

    /// this test uses FEI as the underlying asset and hooks into a FEI PCV Deposit
    function testMintAfterPriceIncrease() public {
        uint256 amountFeiIn = 101_000;
        uint256 amountVoltOut = 99_999;

        rariFEIPCVDeposit.deposit(); // get env cleaned up and ready for testing
        vm.warp(28 days + block.timestamp);

        uint256 startingUserVoltBalance = volt.balanceOf(address(this));
        uint256 startingPCVDepositFeiBalance = rariFEIPCVDeposit.balance();

        fei.approve(address(psm), amountFeiIn);
        psm.mint(address(this), amountFeiIn, amountVoltOut);
        rariFEIPCVDeposit.deposit();

        uint256 endingUserVoltBalance = volt.balanceOf(address(this));
        uint256 endingPCVDepositFeiBalance = rariFEIPCVDeposit.balance();

        assertEq(
            endingUserVoltBalance - startingUserVoltBalance,
            amountVoltOut
        );
        assertEq(
            endingPCVDepositFeiBalance - startingPCVDepositFeiBalance,
            amountFeiIn - 1
        );
    }

    /// this test uses FEI as the underlying asset and hooks into a FEI PCV Deposit
    function testRedeemAfterPriceIncrease() public {
        uint256 amountVoltIn = 100_000;
        uint256 amountFeiOut = 101_000;

        rariFEIPCVDeposit.deposit(); // get env cleaned up and ready for testing
        vm.warp(28 days + block.timestamp);

        uint256 startingUserVoltBalance = volt.balanceOf(address(this));
        uint256 startingPCVDepositFeiBalance = rariFEIPCVDeposit.balance();

        volt.approve(address(psm), amountVoltIn);
        psm.redeem(address(this), amountVoltIn, amountFeiOut);
        rariFEIPCVDeposit.deposit();

        uint256 endingUserVoltBalance = volt.balanceOf(address(this));
        uint256 endingPCVDepositFeiBalance = rariFEIPCVDeposit.balance();

        assertEq(startingUserVoltBalance - endingUserVoltBalance, amountVoltIn);
        assertEq(
            startingPCVDepositFeiBalance - endingPCVDepositFeiBalance,
            amountFeiOut - 1
        );
    }

    function testGlobalRateLimitedMint() public {
        uint256 voltAvailableToMint = rateLimitedMinter.individualBuffer(
            address(this)
        );
        uint256 startingVolt = volt.balanceOf(address(this));

        rateLimitedMinter.mintMaxAllowableVolt(address(this));

        uint256 endingVolt = volt.balanceOf(address(this));

        assertEq(endingVolt, voltAvailableToMint + startingVolt);
    }
}",2536
RealWorld_BA_102_IOracle_RealWord_20240827220020.log,102,IOracle,5431,4603,10034,79.0,0.119215,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.4;

import ""../external/Decimal.sol"";

/// @title generic oracle interface for Fei Protocol
/// @author Fei Protocol
interface IOracle {
    // ----------- Events -----------

    event Update(uint256 _peg);

    // ----------- State changing API -----------

    function update() external;

    // ----------- Getters -----------

    function read() external view returns (Decimal.D256 memory, bool);

    function isOutdated() external view returns (bool);
}",115
RealWorld_BA_102_IPCVDeposit_RealWord_20240827222117.log,102,IPCVDeposit,7232,5010,12242,97.0,0.13636,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.4;

import ""./IPCVDepositBalances.sol"";

/// @title a PCV Deposit interface
/// @author Fei Protocol
interface IPCVDeposit is IPCVDepositBalances {
    // ----------- Events -----------
    event Deposit(address indexed _from, uint256 _amount);

    event Withdrawal(
        address indexed _caller,
        address indexed _to,
        uint256 _amount
    );

    event WithdrawERC20(
        address indexed _caller,
        address indexed _token,
        address indexed _to,
        uint256 _amount
    );

    event WithdrawETH(
        address indexed _caller,
        address indexed _to,
        uint256 _amount
    );

    // ----------- State changing api -----------

    function deposit() external;

    // ----------- PCV Controller only state changing api -----------

    function withdraw(address to, uint256 amount) external;

    function withdrawERC20(
        address token,
        address to,
        uint256 amount
    ) external;

    function withdrawETH(address payable to, uint256 amount) external;
}",236
RealWorld_BA_102_Core.t_RealWord_20240827212900.log,102,Core.t,7977,4984,12961,93.0,0.139565,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.4;

import {IERC20} from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

import {IVolt} from ""../../../volt/Volt.sol"";
import {Volt} from ""../../../volt/Volt.sol"";
import {ICore} from ""../../../core/ICore.sol"";
import {Core} from ""../../../core/Core.sol"";
import {Vm} from ""./../utils/Vm.sol"";
import {DSTest} from ""./../utils/DSTest.sol"";
import {getCore, getAddresses, FeiTestAddresses} from ""./../utils/Fixtures.sol"";
import {Address} from ""@openzeppelin/contracts/utils/Address.sol"";

contract CoreTest is DSTest {
    IVolt private volt;
    Core private core;

    Vm public constant vm = Vm(HEVM_ADDRESS);
    FeiTestAddresses public addresses = getAddresses();

    function setUp() public {
        core = getCore();

        volt = core.volt();
    }

    function testGovernorSetsVcon() public {
        vm.prank(addresses.governorAddress);
        core.setVcon(IERC20(addresses.userAddress));

        assertEq(address(core.vcon()), addresses.userAddress);
    }

    function testNonGovernorFailsSettingVcon() public {
        vm.expectRevert(""Permissions: Caller is not a governor"");
        core.setVcon(IERC20(addresses.userAddress));
    }
}",314
RealWorld_BA_102_IntegrationTest.t_RealWord_20240827214329.log,102,IntegrationTest.t,4048,3623,7671,71.0,0.0927,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.0;

import {DSTest} from ""../unit/utils/DSTest.sol"";
import {StdLib} from ""../unit/utils/StdLib.sol"";

contract IntegrationTest is DSTest, StdLib {
    function setUp() public {}

    function testPass() public {}
}",76
RealWorld_BA_102_Decimal_RealWord_20240827224145.log,102,Decimal,24655,5730,30385,98.0,0.237875,"/*
    Copyright 2019 dYdX Trading Inc.
    Copyright 2020 Empty Set Squad <emptysetsquad@protonmail.com>
    Licensed under the Apache License, Version 2.0 (the ""License"");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an ""AS IS"" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
*/

pragma solidity ^0.8.4;

import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";

/**
 * @title Decimal
 * @author dYdX
 *
 * Library that defines a fixed-point number with 18 decimal places.
 */
library Decimal {
    using SafeMath for uint256;

    // ============ Constants ============

    uint256 private constant BASE = 10**18;

    // ============ Structs ============

    struct D256 {
        uint256 value;
    }

    // ============ Static Functions ============

    function zero() internal pure returns (D256 memory) {
        return D256({value: 0});
    }

    function one() internal pure returns (D256 memory) {
        return D256({value: BASE});
    }

    function from(uint256 a) internal pure returns (D256 memory) {
        return D256({value: a.mul(BASE)});
    }

    function ratio(uint256 a, uint256 b) internal pure returns (D256 memory) {
        return D256({value: getPartial(a, BASE, b)});
    }

    // ============ Self Functions ============

    function add(D256 memory self, uint256 b)
        internal
        pure
        returns (D256 memory)
    {
        return D256({value: self.value.add(b.mul(BASE))});
    }

    function sub(D256 memory self, uint256 b)
        internal
        pure
        returns (D256 memory)
    {
        return D256({value: self.value.sub(b.mul(BASE))});
    }

    function sub(
        D256 memory self,
        uint256 b,
        string memory reason
    ) internal pure returns (D256 memory) {
        return D256({value: self.value.sub(b.mul(BASE), reason)});
    }

    function mul(D256 memory self, uint256 b)
        internal
        pure
        returns (D256 memory)
    {
        return D256({value: self.value.mul(b)});
    }

    function div(D256 memory self, uint256 b)
        internal
        pure
        returns (D256 memory)
    {
        return D256({value: self.value.div(b)});
    }

    function pow(D256 memory self, uint256 b)
        internal
        pure
        returns (D256 memory)
    {
        if (b == 0) {
            return from(1);
        }

        D256 memory temp = D256({value: self.value});
        for (uint256 i = 1; i < b; i++) {
            temp = mul(temp, self);
        }

        return temp;
    }

    function add(D256 memory self, D256 memory b)
        internal
        pure
        returns (D256 memory)
    {
        return D256({value: self.value.add(b.value)});
    }

    function sub(D256 memory self, D256 memory b)
        internal
        pure
        returns (D256 memory)
    {
        return D256({value: self.value.sub(b.value)});
    }

    function sub(
        D256 memory self,
        D256 memory b,
        string memory reason
    ) internal pure returns (D256 memory) {
        return D256({value: self.value.sub(b.value, reason)});
    }

    function mul(D256 memory self, D256 memory b)
        internal
        pure
        returns (D256 memory)
    {
        return D256({value: getPartial(self.value, b.value, BASE)});
    }

    function div(D256 memory self, D256 memory b)
        internal
        pure
        returns (D256 memory)
    {
        return D256({value: getPartial(self.value, BASE, b.value)});
    }

    function equals(D256 memory self, D256 memory b)
        internal
        pure
        returns (bool)
    {
        return self.value == b.value;
    }

    function greaterThan(D256 memory self, D256 memory b)
        internal
        pure
        returns (bool)
    {
        return compareTo(self, b) == 2;
    }

    function lessThan(D256 memory self, D256 memory b)
        internal
        pure
        returns (bool)
    {
        return compareTo(self, b) == 0;
    }

    function greaterThanOrEqualTo(D256 memory self, D256 memory b)
        internal
        pure
        returns (bool)
    {
        return compareTo(self, b) > 0;
    }

    function lessThanOrEqualTo(D256 memory self, D256 memory b)
        internal
        pure
        returns (bool)
    {
        return compareTo(self, b) < 2;
    }

    function isZero(D256 memory self) internal pure returns (bool) {
        return self.value == 0;
    }

    function asUint256(D256 memory self) internal pure returns (uint256) {
        return self.value.div(BASE);
    }

    // ============ Core Methods ============

    function getPartial(
        uint256 target,
        uint256 numerator,
        uint256 denominator
    ) private pure returns (uint256) {
        return target.mul(numerator).div(denominator);
    }

    function compareTo(D256 memory a, D256 memory b)
        private
        pure
        returns (uint256)
    {
        if (a.value == b.value) {
            return 1;
        }
        return a.value > b.value ? 2 : 0;
    }
}",1288
RealWorld_BA_102_ICoreRef_RealWord_20240827223218.log,102,ICoreRef,7297,5419,12716,86.0,0.144865,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.4;

import ""../core/ICore.sol"";

/// @title CoreRef interface
/// @author Fei Protocol
interface ICoreRef {
    // ----------- Events -----------

    event CoreUpdate(address indexed oldCore, address indexed newCore);

    event ContractAdminRoleUpdate(
        bytes32 indexed oldContractAdminRole,
        bytes32 indexed newContractAdminRole
    );

    // ----------- Governor only state changing api -----------

    function setContractAdminRole(bytes32 newContractAdminRole) external;

    // ----------- Governor or Guardian only state changing api -----------

    function pause() external;

    function unpause() external;

    // ----------- Getters -----------

    function core() external view returns (ICore);

    function volt() external view returns (IVolt);

    function vcon() external view returns (IERC20);

    function voltBalance() external view returns (uint256);

    function vconBalance() external view returns (uint256);

    function CONTRACT_ADMIN_ROLE() external view returns (bytes32);

    function isContractAdmin(address admin) external view returns (bool);
}",242
RealWorld_BA_102_Core_RealWord_20240827212132.log,102,Core,7778,5174,12952,90.0,0.14237,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.4;

import {Vcon} from ""../vcon/Vcon.sol"";
import {IVolt, Volt, IERC20} from ""../volt/Volt.sol"";
import {ICore} from ""./ICore.sol"";
import {Permissions} from ""./Permissions.sol"";
import {Initializable} from ""@openzeppelin/contracts/proxy/utils/Initializable.sol"";

/// @title Source of truth for VOLT Protocol
/// @author Fei Protocol
/// @notice maintains roles, access control, Volt, Vcon, and the Vcon treasury
contract Core is ICore, Permissions, Initializable {
    /// @notice the address of the FEI contract
    IVolt public override volt;

    /// @notice the address of the Vcon contract
    IERC20 public override vcon;

    function init() external initializer {
        volt = new Volt(address(this));
        /// msg.sender already has the VOLT Minting abilities, so grant them governor as well
        _setupGovernor(msg.sender);
    }

    /// @notice governor only function to set the VCON token
    function setVcon(IERC20 _vcon) external onlyGovernor {
        vcon = _vcon;

        emit VconUpdate(_vcon);
    }
}",279
RealWorld_BA_102_DSTest_RealWord_20240827213900.log,102,DSTest,64771,4690,69461,91.0,0.417655,"// SPDX-License-Identifier: GPL-3.0-or-later

// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

pragma solidity >=0.4.23;

contract DSTest {
    event log(string);
    event logs(bytes);

    event log_address(address);
    event log_bytes32(bytes32);
    event log_int(int256);
    event log_uint(uint256);
    event log_bytes(bytes);
    event log_string(string);

    event log_named_address(string key, address val);
    event log_named_bytes32(string key, bytes32 val);
    event log_named_decimal_int(string key, int256 val, uint256 decimals);
    event log_named_decimal_uint(string key, uint256 val, uint256 decimals);
    event log_named_int(string key, int256 val);
    event log_named_uint(string key, uint256 val);
    event log_named_bytes(string key, bytes val);
    event log_named_string(string key, string val);

    bool public IS_TEST = true;
    bool public failed;

    address constant HEVM_ADDRESS =
        address(bytes20(uint160(uint256(keccak256(""hevm cheat code"")))));

    modifier mayRevert() {
        _;
    }
    modifier testopts(string memory) {
        _;
    }

    function fail() internal {
        failed = true;
    }

    modifier logs_gas() {
        uint256 startGas = gasleft();
        _;
        uint256 endGas = gasleft();
        emit log_named_uint(""gas"", startGas - endGas);
    }

    function assertTrue(bool condition) internal {
        if (!condition) {
            emit log(""Error: Assertion Failed"");
            fail();
        }
    }

    function assertTrue(bool condition, string memory err) internal {
        if (!condition) {
            emit log_named_string(""Error"", err);
            assertTrue(condition);
        }
    }

    function assertEq(address a, address b) internal {
        if (a != b) {
            emit log(""Error: a == b not satisfied [address]"");
            emit log_named_address(""  Expected"", b);
            emit log_named_address(""    Actual"", a);
            fail();
        }
    }

    function assertEq(
        address a,
        address b,
        string memory err
    ) internal {
        if (a != b) {
            emit log_named_string(""Error"", err);
            assertEq(a, b);
        }
    }

    function assertEq(bytes32 a, bytes32 b) internal {
        if (a != b) {
            emit log(""Error: a == b not satisfied [bytes32]"");
            emit log_named_bytes32(""  Expected"", b);
            emit log_named_bytes32(""    Actual"", a);
            fail();
        }
    }

    function assertEq(
        bytes32 a,
        bytes32 b,
        string memory err
    ) internal {
        if (a != b) {
            emit log_named_string(""Error"", err);
            assertEq(a, b);
        }
    }

    function assertEq32(bytes32 a, bytes32 b) internal {
        assertEq(a, b);
    }

    function assertEq32(
        bytes32 a,
        bytes32 b,
        string memory err
    ) internal {
        assertEq(a, b, err);
    }

    function assertEq(int256 a, int256 b) internal {
        if (a != b) {
            emit log(""Error: a == b not satisfied [int]"");
            emit log_named_int(""  Expected"", b);
            emit log_named_int(""    Actual"", a);
            fail();
        }
    }

    function assertEq(
        int256 a,
        int256 b,
        string memory err
    ) internal {
        if (a != b) {
            emit log_named_string(""Error"", err);
            assertEq(a, b);
        }
    }

    function assertEq(uint256 a, uint256 b) internal {
        if (a != b) {
            emit log(""Error: a == b not satisfied [uint]"");
            emit log_named_uint(""  Expected"", b);
            emit log_named_uint(""    Actual"", a);
            fail();
        }
    }

    function assertEq(
        uint256 a,
        uint256 b,
        string memory err
    ) internal {
        if (a != b) {
            emit log_named_string(""Error"", err);
            assertEq(a, b);
        }
    }

    function assertEqDecimal(
        int256 a,
        int256 b,
        uint256 decimals
    ) internal {
        if (a != b) {
            emit log(""Error: a == b not satisfied [decimal int]"");
            emit log_named_decimal_int(""  Expected"", b, decimals);
            emit log_named_decimal_int(""    Actual"", a, decimals);
            fail();
        }
    }

    function assertEqDecimal(
        int256 a,
        int256 b,
        uint256 decimals,
        string memory err
    ) internal {
        if (a != b) {
            emit log_named_string(""Error"", err);
            assertEqDecimal(a, b, decimals);
        }
    }

    function assertEqDecimal(
        uint256 a,
        uint256 b,
        uint256 decimals
    ) internal {
        if (a != b) {
            emit log(""Error: a == b not satisfied [decimal uint]"");
            emit log_named_decimal_uint(""  Expected"", b, decimals);
            emit log_named_decimal_uint(""    Actual"", a, decimals);
            fail();
        }
    }

    function assertEqDecimal(
        uint256 a,
        uint256 b,
        uint256 decimals,
        string memory err
    ) internal {
        if (a != b) {
            emit log_named_string(""Error"", err);
            assertEqDecimal(a, b, decimals);
        }
    }

    function assertGt(uint256 a, uint256 b) internal {
        if (a <= b) {
            emit log(""Error: a > b not satisfied [uint]"");
            emit log_named_uint(""  Value a"", a);
            emit log_named_uint(""  Value b"", b);
            fail();
        }
    }

    function assertGt(
        uint256 a,
        uint256 b,
        string memory err
    ) internal {
        if (a <= b) {
            emit log_named_string(""Error"", err);
            assertGt(a, b);
        }
    }

    function assertGt(int256 a, int256 b) internal {
        if (a <= b) {
            emit log(""Error: a > b not satisfied [int]"");
            emit log_named_int(""  Value a"", a);
            emit log_named_int(""  Value b"", b);
            fail();
        }
    }

    function assertGt(
        int256 a,
        int256 b,
        string memory err
    ) internal {
        if (a <= b) {
            emit log_named_string(""Error"", err);
            assertGt(a, b);
        }
    }

    function assertGtDecimal(
        int256 a,
        int256 b,
        uint256 decimals
    ) internal {
        if (a <= b) {
            emit log(""Error: a > b not satisfied [decimal int]"");
            emit log_named_decimal_int(""  Value a"", a, decimals);
            emit log_named_decimal_int(""  Value b"", b, decimals);
            fail();
        }
    }

    function assertGtDecimal(
        int256 a,
        int256 b,
        uint256 decimals,
        string memory err
    ) internal {
        if (a <= b) {
            emit log_named_string(""Error"", err);
            assertGtDecimal(a, b, decimals);
        }
    }

    function assertGtDecimal(
        uint256 a,
        uint256 b,
        uint256 decimals
    ) internal {
        if (a <= b) {
            emit log(""Error: a > b not satisfied [decimal uint]"");
            emit log_named_decimal_uint(""  Value a"", a, decimals);
            emit log_named_decimal_uint(""  Value b"", b, decimals);
            fail();
        }
    }

    function assertGtDecimal(
        uint256 a,
        uint256 b,
        uint256 decimals,
        string memory err
    ) internal {
        if (a <= b) {
            emit log_named_string(""Error"", err);
            assertGtDecimal(a, b, decimals);
        }
    }

    function assertGe(uint256 a, uint256 b) internal {
        if (a < b) {
            emit log(""Error: a >= b not satisfied [uint]"");
            emit log_named_uint(""  Value a"", a);
            emit log_named_uint(""  Value b"", b);
            fail();
        }
    }

    function assertGe(
        uint256 a,
        uint256 b,
        string memory err
    ) internal {
        if (a < b) {
            emit log_named_string(""Error"", err);
            assertGe(a, b);
        }
    }

    function assertGe(int256 a, int256 b) internal {
        if (a < b) {
            emit log(""Error: a >= b not satisfied [int]"");
            emit log_named_int(""  Value a"", a);
            emit log_named_int(""  Value b"", b);
            fail();
        }
    }

    function assertGe(
        int256 a,
        int256 b,
        string memory err
    ) internal {
        if (a < b) {
            emit log_named_string(""Error"", err);
            assertGe(a, b);
        }
    }

    function assertGeDecimal(
        int256 a,
        int256 b,
        uint256 decimals
    ) internal {
        if (a < b) {
            emit log(""Error: a >= b not satisfied [decimal int]"");
            emit log_named_decimal_int(""  Value a"", a, decimals);
            emit log_named_decimal_int(""  Value b"", b, decimals);
            fail();
        }
    }

    function assertGeDecimal(
        int256 a,
        int256 b,
        uint256 decimals,
        string memory err
    ) internal {
        if (a < b) {
            emit log_named_string(""Error"", err);
            assertGeDecimal(a, b, decimals);
        }
    }

    function assertGeDecimal(
        uint256 a,
        uint256 b,
        uint256 decimals
    ) internal {
        if (a < b) {
            emit log(""Error: a >= b not satisfied [decimal uint]"");
            emit log_named_decimal_uint(""  Value a"", a, decimals);
            emit log_named_decimal_uint(""  Value b"", b, decimals);
            fail();
        }
    }

    function assertGeDecimal(
        uint256 a,
        uint256 b,
        uint256 decimals,
        string memory err
    ) internal {
        if (a < b) {
            emit log_named_string(""Error"", err);
            assertGeDecimal(a, b, decimals);
        }
    }

    function assertLt(uint256 a, uint256 b) internal {
        if (a >= b) {
            emit log(""Error: a < b not satisfied [uint]"");
            emit log_named_uint(""  Value a"", a);
            emit log_named_uint(""  Value b"", b);
            fail();
        }
    }

    function assertLt(
        uint256 a,
        uint256 b,
        string memory err
    ) internal {
        if (a >= b) {
            emit log_named_string(""Error"", err);
            assertLt(a, b);
        }
    }

    function assertLt(int256 a, int256 b) internal {
        if (a >= b) {
            emit log(""Error: a < b not satisfied [int]"");
            emit log_named_int(""  Value a"", a);
            emit log_named_int(""  Value b"", b);
            fail();
        }
    }

    function assertLt(
        int256 a,
        int256 b,
        string memory err
    ) internal {
        if (a >= b) {
            emit log_named_string(""Error"", err);
            assertLt(a, b);
        }
    }

    function assertLtDecimal(
        int256 a,
        int256 b,
        uint256 decimals
    ) internal {
        if (a >= b) {
            emit log(""Error: a < b not satisfied [decimal int]"");
            emit log_named_decimal_int(""  Value a"", a, decimals);
            emit log_named_decimal_int(""  Value b"", b, decimals);
            fail();
        }
    }

    function assertLtDecimal(
        int256 a,
        int256 b,
        uint256 decimals,
        string memory err
    ) internal {
        if (a >= b) {
            emit log_named_string(""Error"", err);
            assertLtDecimal(a, b, decimals);
        }
    }

    function assertLtDecimal(
        uint256 a,
        uint256 b,
        uint256 decimals
    ) internal {
        if (a >= b) {
            emit log(""Error: a < b not satisfied [decimal uint]"");
            emit log_named_decimal_uint(""  Value a"", a, decimals);
            emit log_named_decimal_uint(""  Value b"", b, decimals);
            fail();
        }
    }

    function assertLtDecimal(
        uint256 a,
        uint256 b,
        uint256 decimals,
        string memory err
    ) internal {
        if (a >= b) {
            emit log_named_string(""Error"", err);
            assertLtDecimal(a, b, decimals);
        }
    }

    function assertLe(uint256 a, uint256 b) internal {
        if (a > b) {
            emit log(""Error: a <= b not satisfied [uint]"");
            emit log_named_uint(""  Value a"", a);
            emit log_named_uint(""  Value b"", b);
            fail();
        }
    }

    function assertLe(
        uint256 a,
        uint256 b,
        string memory err
    ) internal {
        if (a > b) {
            emit log_named_string(""Error"", err);
            assertLe(a, b);
        }
    }

    function assertLe(int256 a, int256 b) internal {
        if (a > b) {
            emit log(""Error: a <= b not satisfied [int]"");
            emit log_named_int(""  Value a"", a);
            emit log_named_int(""  Value b"", b);
            fail();
        }
    }

    function assertLe(
        int256 a,
        int256 b,
        string memory err
    ) internal {
        if (a > b) {
            emit log_named_string(""Error"", err);
            assertLe(a, b);
        }
    }

    function assertLeDecimal(
        int256 a,
        int256 b,
        uint256 decimals
    ) internal {
        if (a > b) {
            emit log(""Error: a <= b not satisfied [decimal int]"");
            emit log_named_decimal_int(""  Value a"", a, decimals);
            emit log_named_decimal_int(""  Value b"", b, decimals);
            fail();
        }
    }

    function assertLeDecimal(
        int256 a,
        int256 b,
        uint256 decimals,
        string memory err
    ) internal {
        if (a > b) {
            emit log_named_string(""Error"", err);
            assertLeDecimal(a, b, decimals);
        }
    }

    function assertLeDecimal(
        uint256 a,
        uint256 b,
        uint256 decimals
    ) internal {
        if (a > b) {
            emit log(""Error: a <= b not satisfied [decimal uint]"");
            emit log_named_decimal_uint(""  Value a"", a, decimals);
            emit log_named_decimal_uint(""  Value b"", b, decimals);
            fail();
        }
    }

    function assertLeDecimal(
        uint256 a,
        uint256 b,
        uint256 decimals,
        string memory err
    ) internal {
        if (a > b) {
            emit log_named_string(""Error"", err);
            assertGeDecimal(a, b, decimals);
        }
    }

    function assertEq(string memory a, string memory b) internal {
        if (keccak256(abi.encodePacked(a)) != keccak256(abi.encodePacked(b))) {
            emit log(""Error: a == b not satisfied [string]"");
            emit log_named_string(""  Value a"", a);
            emit log_named_string(""  Value b"", b);
            fail();
        }
    }

    function assertEq(
        string memory a,
        string memory b,
        string memory err
    ) internal {
        if (keccak256(abi.encodePacked(a)) != keccak256(abi.encodePacked(b))) {
            emit log_named_string(""Error"", err);
            assertEq(a, b);
        }
    }

    function checkEq0(bytes memory a, bytes memory b)
        internal
        pure
        returns (bool ok)
    {
        ok = true;
        if (a.length == b.length) {
            for (uint256 i = 0; i < a.length; i++) {
                if (a[i] != b[i]) {
                    ok = false;
                }
            }
        } else {
            ok = false;
        }
    }

    function assertEq0(bytes memory a, bytes memory b) internal {
        if (!checkEq0(a, b)) {
            emit log(""Error: a == b not satisfied [bytes]"");
            emit log_named_bytes(""  Expected"", a);
            emit log_named_bytes(""    Actual"", b);
            fail();
        }
    }

    function assertEq0(
        bytes memory a,
        bytes memory b,
        string memory err
    ) internal {
        if (!checkEq0(a, b)) {
            emit log_named_string(""Error"", err);
            assertEq0(a, b);
        }
    }
}",3849
RealWorld_BA_102_Constants_RealWord_20240827211610.log,102,Constants,8070,4499,12569,85.0,0.13033,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.0;

import {IWETH} from ""@uniswap/v2-periphery/contracts/interfaces/IWETH.sol"";

library Constants {
    /// @notice the denominator for basis points granularity (10,000)
    uint256 public constant BASIS_POINTS_GRANULARITY = 10_000;

    /// @notice the denominator for basis points granularity (10,000) expressed as an int data type
    int256 public constant BP_INT = int256(BASIS_POINTS_GRANULARITY);

    uint256 public constant ONE_YEAR = 365.25 days;

    int256 public constant ONE_YEAR_INT = int256(ONE_YEAR);

    /// @notice WETH9 address
    IWETH public constant WETH =
        IWETH(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);

    /// @notice USD stand-in address
    address public constant USD = 0x1111111111111111111111111111111111111111;

    /// @notice Wei per ETH, i.e. 10**18
    uint256 public constant ETH_GRANULARITY = 1e18;

    /// @notice number of decimals in ETH, 18
    uint256 public constant ETH_DECIMALS = 18;
}",292
RealWorld_BA_81_TokenHandler_RealWord_20240825202442.log,81,TokenHandler,17636,5442,23078,76.0,0.19702,"// SPDX-License-Identifier: GPL-3.0-only
pragma solidity =0.7.6;
pragma abicoder v2;

import ""../math/SafeInt256.sol"";
import ""../global/LibStorage.sol"";
import ""../global/Types.sol"";
import ""../global/Constants.sol"";
import ""interfaces/compound/CErc20Interface.sol"";
import ""interfaces/compound/CEtherInterface.sol"";
import ""@openzeppelin-0.7/contracts/math/SafeMath.sol"";
import ""@openzeppelin-0.7/contracts/token/ERC20/ERC20.sol"";

/// @notice Handles all external token transfers and events
library TokenHandler {
    using SafeInt256 for int256;
    using SafeMath for uint256;

    function getAssetToken(uint256 currencyId) internal view returns (Token memory) {
        return _getToken(currencyId, false);
    }

    function getUnderlyingToken(uint256 currencyId) internal view returns (Token memory) {
        return _getToken(currencyId, true);
    }

    /// @notice Gets token data for a particular currency id, if underlying is set to true then returns
    /// the underlying token. (These may not always exist)
    function _getToken(uint256 currencyId, bool underlying) private view returns (Token memory) {
        mapping(uint256 => mapping(bool => TokenStorage)) storage store = LibStorage.getTokenStorage();
        TokenStorage storage tokenStorage = store[currencyId][underlying];

        return
            Token({
                tokenAddress: tokenStorage.tokenAddress,
                hasTransferFee: tokenStorage.hasTransferFee,
                // No overflow, restricted on storage
                decimals: int256(10**tokenStorage.decimalPlaces),
                tokenType: tokenStorage.tokenType,
                maxCollateralBalance: tokenStorage.maxCollateralBalance
            });
    }

    function redeem(
        Token memory assetToken,
        Token memory underlyingToken,
        uint256 assetAmountExternal
    ) internal returns (int256) {
        uint256 startingBalance;
        if (assetToken.tokenType == TokenType.cETH) {
            startingBalance = address(this).balance;
        } else if (assetToken.tokenType == TokenType.cToken) {
            startingBalance = IERC20(underlyingToken.tokenAddress).balanceOf(address(this));
        } else {
            revert(); // dev: non redeemable failure
        }

        uint256 success = CErc20Interface(assetToken.tokenAddress).redeem(assetAmountExternal);
        require(success == Constants.COMPOUND_RETURN_CODE_NO_ERROR, ""Redeem"");

        uint256 endingBalance;
        if (assetToken.tokenType == TokenType.cETH) {
            endingBalance = address(this).balance;
        } else {
            endingBalance = IERC20(underlyingToken.tokenAddress).balanceOf(address(this));
        }

        // Underlying token external precision
        return SafeInt256.toInt(endingBalance.sub(startingBalance));
    }

    function convertToInternal(Token memory token, int256 amount) internal pure returns (int256) {
        // If token decimals > INTERNAL_TOKEN_PRECISION:
        //  on deposit: resulting dust will accumulate to protocol
        //  on withdraw: protocol may lose dust amount. However, withdraws are only calculated based
        //    on a conversion from internal token precision to external token precision so therefore dust
        //    amounts cannot be specified for withdraws.
        // If token decimals < INTERNAL_TOKEN_PRECISION then this will add zeros to the
        // end of amount and will not result in dust.
        if (token.decimals == Constants.INTERNAL_TOKEN_PRECISION) return amount;
        return amount.mul(Constants.INTERNAL_TOKEN_PRECISION).div(token.decimals);
    }

    function convertToExternal(Token memory token, int256 amount) internal pure returns (int256) {
        if (token.decimals == Constants.INTERNAL_TOKEN_PRECISION) return amount;
        // If token decimals > INTERNAL_TOKEN_PRECISION then this will increase amount
        // by adding a number of zeros to the end and will not result in dust.
        // If token decimals < INTERNAL_TOKEN_PRECISION:
        //  on deposit: Deposits are specified in external token precision and there is no loss of precision when
        //      tokens are converted from external to internal precision
        //  on withdraw: this calculation will round down such that the protocol retains the residual cash balance
        return amount.mul(token.decimals).div(Constants.INTERNAL_TOKEN_PRECISION);
    }

}",914
RealWorld_BA_81_IVault_RealWord_20240825204955.log,81,IVault,10728,5162,15890,67.0,0.15688,"pragma solidity ^0.8.9;

interface IAsset {
    // solhint-disable-previous-line no-empty-blocks
}

interface IVault {
    enum PoolSpecialization {
        GENERAL,
        MINIMAL_SWAP_INFO,
        TWO_TOKEN
    }
    enum JoinKind {
        INIT,
        EXACT_TOKENS_IN_FOR_BPT_OUT,
        TOKEN_IN_FOR_EXACT_BPT_OUT,
        ALL_TOKENS_IN_FOR_EXACT_BPT_OUT
    }
    enum ExitKind {
        EXACT_BPT_IN_FOR_ONE_TOKEN_OUT,
        EXACT_BPT_IN_FOR_TOKENS_OUT,
        BPT_IN_FOR_EXACT_TOKENS_OUT,
        MANAGEMENT_FEE_TOKENS_OUT // for ManagedPool
    }

    /**
     * @dev Returns a Pool's contract address and specialization setting.
     */
    function getPool(bytes32 poolId)
        external
        view
        returns (address, PoolSpecialization);

    function joinPool(
        bytes32 poolId,
        address sender,
        address recipient,
        JoinPoolRequest memory request
    ) external payable;

    struct JoinPoolRequest {
        IAsset[] assets;
        uint256[] maxAmountsIn;
        bytes userData;
        bool fromInternalBalance;
    }

    function exitPool(
        bytes32 poolId,
        address sender,
        address payable recipient,
        ExitPoolRequest memory request
    ) external;

    struct ExitPoolRequest {
        IAsset[] assets;
        uint256[] minAmountsOut;
        bytes userData;
        bool toInternalBalance;
    }

    enum SwapKind {
        GIVEN_IN,
        GIVEN_OUT
    }

    struct SingleSwap {
        bytes32 poolId;
        SwapKind kind;
        IAsset assetIn;
        IAsset assetOut;
        uint256 amount;
        bytes userData;
    }

    struct FundManagement {
        address sender;
        bool fromInternalBalance;
        address payable recipient;
        bool toInternalBalance;
    }

    function swap(
        SingleSwap memory singleSwap,
        FundManagement memory funds,
        uint256 limit,
        uint256 deadline
    ) external payable returns (uint256);

    function getPoolTokens(bytes32 poolId)
        external
        view
        returns (
            address[] memory tokens,
            uint256[] memory balances,
            uint256 lastChangeBlock
        );
}",477
RealWorld_BA_81_NotionalTreasury_RealWord_20240825204318.log,81,NotionalTreasury,5652,5576,11228,69.0,0.13978,"// SPDX-License-Identifier: GPL-3.0-only
pragma solidity =0.7.6;
pragma abicoder v2;

interface NotionalTreasury {
    function claimCOMPAndTransfer(address[] calldata ctokens) external returns (uint256);

    function transferReserveToTreasury(uint16[] calldata currencies)
        external
        returns (uint256[] memory);

    function setTreasuryManager(address manager) external;

    function setReserveBuffer(uint16 currencyId, uint256 amount) external;

    function setReserveCashBalance(uint16 currencyId, int256 reserveBalance) external;
}",127
RealWorld_BA_81_SafeInt256_RealWord_20240825203151.log,81,SafeInt256,13836,5600,19436,77.0,0.18118,"// SPDX-License-Identifier: GPL-3.0-only
pragma solidity =0.7.6;

import ""../global/Constants.sol"";

library SafeInt256 {
    int256 private constant _INT256_MIN = type(int256).min;

    /// @dev Returns the multiplication of two signed integers, reverting on
    /// overflow.

    /// Counterpart to Solidity's `*` operator.

    /// Requirements:

    /// - Multiplication cannot overflow.

    function mul(int256 a, int256 b) internal pure returns (int256 c) {
        c = a * b;
        if (a == -1) require (b == 0 || c / b == a);
        else require (a == 0 || c / a == b);
    }

    /// @dev Returns the integer division of two signed integers. Reverts on
    /// division by zero. The result is rounded towards zero.

    /// Counterpart to Solidity's `/` operator. Note: this function uses a
    /// `revert` opcode (which leaves remaining gas untouched) while Solidity
    /// uses an invalid opcode to revert (consuming all remaining gas).

    /// Requirements:

    /// - The divisor cannot be zero.

    function div(int256 a, int256 b) internal pure returns (int256 c) {
        require(!(b == -1 && a == _INT256_MIN)); // dev: int256 div overflow
        // NOTE: solidity will automatically revert on divide by zero
        c = a / b;
    }

    function sub(int256 x, int256 y) internal pure returns (int256 z) {
        //  taken from uniswap v3
        require((z = x - y) <= x == (y >= 0));
    }

    function add(int256 x, int256 y) internal pure returns (int256 z) {
        require((z = x + y) >= x == (y >= 0));
    }

    function neg(int256 x) internal pure returns (int256 y) {
        return mul(-1, x);
    }

    function abs(int256 x) internal pure returns (int256) {
        if (x < 0) return neg(x);
        else return x;
    }

    function subNoNeg(int256 x, int256 y) internal pure returns (int256 z) {
        z = sub(x, y);
        require(z >= 0); // dev: int256 sub to negative

        return z;
    }

    function toUint(int256 x) internal pure returns (uint256) {
        require(x >= 0);
        return uint256(x);
    }

    function toInt(uint256 x) internal pure returns (int256) {
        require (x <= uint256(type(int256).max)); // dev: toInt overflow
        return int256(x);
    }

    function max(int256 x, int256 y) internal pure returns (int256) {
        return x > y ? x : y;
    }

    function min(int256 x, int256 y) internal pure returns (int256) {
        return x < y ? x : y;
    }
}",660
RealWorld_BA_81_TreasuryAction_RealWord_20240825202058.log,81,TreasuryAction,31788,5392,37180,69.0,0.26678,"// SPDX-License-Identifier: GPL-3.0-only
pragma solidity =0.7.6;
pragma abicoder v2;

import ""@openzeppelin-0.7/contracts/math/SafeMath.sol"";
import ""@openzeppelin-0.7/contracts/token/ERC20/SafeERC20.sol"";
import ""./ActionGuards.sol"";
import ""./math/SafeInt256.sol"";
import ""./stubs/BalanceHandler.sol"";
import ""./stubs/TokenHandler.sol"";
import ""./global/StorageLayoutV2.sol"";
import ""./global/Constants.sol"";
import ""interfaces/notional/NotionalTreasury.sol"";
import ""interfaces/compound/ComptrollerInterface.sol"";
import ""interfaces/compound/CErc20Interface.sol"";
import {WETH9_07 as WETH9} from ""interfaces/WETH9_07.sol"";

contract TreasuryAction is StorageLayoutV2, ActionGuards, NotionalTreasury {
    using SafeMath for uint256;
    using SafeInt256 for int256;
    using SafeERC20 for IERC20;
    using TokenHandler for Token;

    IERC20 public immutable COMP;
    Comptroller public immutable COMPTROLLER;
    WETH9 public immutable WETH;

    /// @dev Emitted when treasury manager is updated
    event TreasuryManagerChanged(address indexed previousManager, address indexed newManager);
    /// @dev Emitted when reserve buffer value is updated
    event ReserveBufferUpdated(uint16 currencyId, uint256 bufferAmount);

    /// @dev Throws if called by any account other than the owner.
    modifier onlyOwner() {
        require(owner == msg.sender, ""Ownable: caller is not the owner"");
        _;
    }

    /// @dev Harvest methods are only callable by the authorized treasury manager contract
    modifier onlyManagerContract() {
        require(treasuryManagerContract == msg.sender, ""Caller is not the treasury manager"");
        _;
    }

    /// @dev Checks if the currency ID is valid
    function _checkValidCurrency(uint16 currencyId) internal view {
        require(0 < currencyId && currencyId <= maxCurrencyId, ""Invalid currency id"");
    }

    constructor(Comptroller _comptroller, WETH9 _weth) {
        COMPTROLLER = _comptroller;
        COMP = IERC20(_comptroller.getCompAddress());
        WETH = _weth;
    }

    /// @notice Sets the new treasury manager contract
    function setTreasuryManager(address manager) external override onlyOwner {
        emit TreasuryManagerChanged(treasuryManagerContract, manager);
        treasuryManagerContract = manager;
    }

    /// @notice Sets the reserve buffer. This is the amount of reserve balance to keep denominated in 1e8 
    /// The reserve cannot be harvested if it's below this amount. This portion of the reserve will remain on 
    /// the contract to act as a buffer against potential insolvency.
    /// @param currencyId refers to the currency of the reserve
    /// @param bufferAmount reserve buffer amount to keep in internal token precision (1e8)
    function setReserveBuffer(uint16 currencyId, uint256 bufferAmount)
        external
        override
        onlyOwner
    {
        _checkValidCurrency(currencyId);
        reserveBuffer[currencyId] = bufferAmount;
        emit ReserveBufferUpdated(currencyId, bufferAmount);
    }

    /// @notice This is used in the case of insolvency. It allows the owner to re-align the reserve with its correct balance.
    /// @param currencyId refers to the currency of the reserve
    /// @param newBalance new reserve balance to set, must be less than the current balance
    function setReserveCashBalance(uint16 currencyId, int256 newBalance)
        external
        override
        onlyOwner
    {
        _checkValidCurrency(currencyId);
        // prettier-ignore
        (int256 reserveBalance, /* */, /* */, /* */) = BalanceHandler.getBalanceStorage(Constants.RESERVE, currencyId);
        require(newBalance < reserveBalance, ""cannot increase reserve balance"");
        // newBalance cannot be negative and is checked inside BalanceHandler.setReserveCashBalance
        BalanceHandler.setReserveCashBalance(currencyId, newBalance);
    }

    /// @notice Claims COMP incentives earned and transfers to the treasury manager contract.
    /// @param cTokens a list of cTokens to claim incentives for
    /// @return the balance of COMP claimed
    function claimCOMPAndTransfer(address[] calldata cTokens)
        external
        override
        onlyManagerContract
        nonReentrant
        returns (uint256)
    {
        // Take a snasphot of the COMP balance before we claim COMP so that we don't inadvertently transfer
        // something we shouldn't.
        uint256 balanceBefore = COMP.balanceOf(address(this));
        COMPTROLLER.claimComp(address(this), cTokens);
        // NOTE: If Notional ever lists COMP as a collateral asset it will be cCOMP instead and it
        // will never hold COMP balances directly. In this case we can always transfer all the COMP
        // off of the contract.
        uint256 balanceAfter = COMP.balanceOf(address(this));
        uint256 amountClaimed = balanceAfter.sub(balanceBefore);
        // NOTE: the onlyManagerContract modifier prevents a transfer to address(0) here
        COMP.safeTransfer(treasuryManagerContract, amountClaimed);
        // NOTE: TreasuryManager contract will emit a COMPHarvested event
        return amountClaimed;
    }

    /// @notice redeems and transfers tokens to the treasury manager contract
    function _redeemAndTransfer(
        uint16 currencyId,
        Token memory asset,
        int256 assetInternalRedeemAmount
    ) private returns (uint256) {
        Token memory underlying = TokenHandler.getUnderlyingToken(currencyId);
        int256 assetExternalRedeemAmount = asset.convertToExternal(assetInternalRedeemAmount);

        // This is the actual redeemed amount in underlying external precision
        uint256 redeemedExternalUnderlying = asset
            .redeem(underlying, assetExternalRedeemAmount.toUint())
            .toUint();

        // NOTE: cETH redeems to ETH, converting it to WETH
        if (underlying.tokenAddress == address(0)) {
            WETH9(WETH).deposit{value: address(this).balance}();
        }

        address underlyingAddress = underlying.tokenAddress == address(0)
            ? address(WETH)
            : underlying.tokenAddress;
        IERC20(underlyingAddress).safeTransfer(treasuryManagerContract, redeemedExternalUnderlying);

        return redeemedExternalUnderlying;
    }

    /// @notice Transfers some amount of reserve assets to the treasury manager contract to be invested
    /// into the sNOTE pool.
    /// @param currencies an array of currencies to transfer from Notional
    function transferReserveToTreasury(uint16[] calldata currencies)
        external
        override
        onlyManagerContract
        nonReentrant
        returns (uint256[] memory)
    {
        uint256[] memory amountsTransferred = new uint256[](currencies.length);

        for (uint256 i; i < currencies.length; i++) {
            // Prevents duplicate currency IDs
            if (i > 0) require(currencies[i] > currencies[i - 1], ""IDs must be sorted"");

            uint16 currencyId = currencies[i];

            _checkValidCurrency(currencyId);

            // Reserve buffer amount in INTERNAL_TOKEN_PRECISION
            int256 bufferInternal = SafeInt256.toInt(reserveBuffer[currencyId]);

            // Reserve requirement not defined
            if (bufferInternal == 0) continue;

            // prettier-ignore
            (int256 reserveInternal, /* */, /* */, /* */) = BalanceHandler.getBalanceStorage(Constants.RESERVE, currencyId);

            // Do not withdraw anything if reserve is below or equal to reserve requirement
            if (reserveInternal <= bufferInternal) continue;

            Token memory asset = TokenHandler.getAssetToken(currencyId);

            // Actual reserve amount allowed to be redeemed and transferred
            int256 assetInternalRedeemAmount = reserveInternal.subNoNeg(bufferInternal);

            // Redeems cTokens and transfer underlying to treasury manager contract
            amountsTransferred[i] = _redeemAndTransfer(
                currencyId,
                asset,
                assetInternalRedeemAmount
            );

            // Updates the reserve balance
            BalanceHandler.harvestExcessReserveBalance(
                currencyId,
                reserveInternal,
                assetInternalRedeemAmount
            );
        }

        // NOTE: TreasuryManager contract will emit an AssetsHarvested event
        return amountsTransferred;
    }
}",1811
RealWorld_BA_81_NotionalTreasuryAction_RealWord_20240825204429.log,81,NotionalTreasuryAction,4585,5317,9902,67.0,0.129265,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.9;
pragma abicoder v2;

interface NotionalTreasuryAction {
    function claimCOMPAndTransfer(address[] calldata ctokens) external returns (uint256);

    function transferReserveToTreasury(uint16[] calldata currencies)
        external
        returns (uint256[] memory);

    function setTreasuryManager(address manager) external;
}",87
RealWorld_BA_81_WETH9_07_RealWord_20240825204113.log,81,WETH9,3597,4408,8005,59.0,0.106145,"// SPDX-License-Identifier: MIT
pragma solidity =0.7.6;

interface WETH9_07 {
    function deposit() external payable;

    function withdraw(uint256 wad) external;
}",41
RealWorld_BA_81_LibStorage_RealWord_20240825203645.log,81,LibStorage,12449,4901,17350,66.0,0.160265,"// SPDX-License-Identifier: GPL-3.0-only
pragma solidity =0.7.6;
pragma abicoder v2;

import ""./Types.sol"";
import ""./Constants.sol"";

library LibStorage {

    /// @dev Offset for the initial slot in lib storage, gives us this number of storage slots
    /// available in StorageLayoutV1 and all subsequent storage layouts that inherit from it.
    uint256 private constant STORAGE_SLOT_BASE = 1000000;
    /// @dev Set to MAX_TRADED_MARKET_INDEX * 2, Solidity does not allow assigning constants from imported values
    uint256 private constant NUM_NTOKEN_MARKET_FACTORS = 14;
    /// @dev Theoretical maximum for MAX_PORTFOLIO_ASSETS, however, we limit this to MAX_TRADED_MARKET_INDEX
    /// in practice. It is possible to exceed that value during liquidation up to 14 potential assets.
    uint256 private constant MAX_PORTFOLIO_ASSETS = 16;

    /// @dev Storage IDs for storage buckets. Each id maps to an internal storage
    /// slot used for a particular mapping
    ///     WARNING: APPEND ONLY
    enum StorageId {
        Unused,
        AccountStorage,
        nTokenContext,
        nTokenAddress,
        nTokenDeposit,
        nTokenInitialization,
        Balance,
        Token,
        SettlementRate,
        CashGroup,
        Market,
        AssetsBitmap,
        ifCashBitmap,
        PortfolioArray,
        nTokenTotalSupply,
        AssetRate,
        ExchangeRate
    }

    /// @dev Mapping from account to currencyId to it's balance storage for that currency
    function getBalanceStorage() internal pure
        returns (mapping(address => mapping(uint256 => BalanceStorage)) storage store)
    {
        uint256 slot = _getStorageSlot(StorageId.Balance);
        assembly { store.slot := slot }
    }

    /// @dev Mapping from currency id to a boolean for underlying or asset token to
    /// the TokenStorage
    function getTokenStorage() internal pure
        returns (mapping(uint256 => mapping(bool => TokenStorage)) storage store)
    {
        uint256 slot = _getStorageSlot(StorageId.Token);
        assembly { store.slot := slot }
    }

    /// @dev Get the storage slot given a storage ID.
    /// @param storageId An entry in `StorageId`
    /// @return slot The storage slot.
    function _getStorageSlot(StorageId storageId)
        private
        pure
        returns (uint256 slot)
    {
        // This should never overflow with a reasonable `STORAGE_SLOT_EXP`
        // because Solidity will do a range check on `storageId` during the cast.
        return uint256(storageId) + STORAGE_SLOT_BASE;
    }
}",575
RealWorld_BA_81_StorageLayoutV2_RealWord_20240825203540.log,81,StorageLayoutV2,5412,5015,10427,63.0,0.12736,"// SPDX-License-Identifier: GPL-3.0-only
pragma solidity =0.7.6;
pragma abicoder v2;

import ""./StorageLayoutV1.sol"";

contract StorageLayoutV2 is StorageLayoutV1 {
    // Contract that manages the treasury and reserves
    address internal treasuryManagerContract;

    // Reserve buffers per currency, used in the TreasuryAction contract
    mapping(uint256 => uint256) internal reserveBuffer;

    // Pending owner used in the transfer ownership / claim ownership pattern
    address internal pendingOwner;
}",111
RealWorld_BA_81_nProxy_RealWord_20240825202938.log,81,nProxy,4684,3687,8371,50.0,0.09716,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.9;

import ""@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol"";

contract nProxy is ERC1967Proxy {
    constructor(
        address _logic,
        bytes memory _data
    ) ERC1967Proxy(_logic, _data) {}

    receive() external payable override {
        // Allow ETH transfers to succeed
    }

    function getImplementation() external view returns (address) {
        return _getImplementation();
    }
}",110
RealWorld_BA_81_StorageLayoutV1_RealWord_20240825203426.log,81,StorageLayoutV1,12600,5855,18455,72.0,0.1801,"// SPDX-License-Identifier: GPL-3.0-only
pragma solidity =0.7.6;
pragma abicoder v2;

import ""./Types.sol"";

/**
 * @notice Storage layout for the system. Do not change this file once deployed, future storage
 * layouts must inherit this and increment the version number.
 */
contract StorageLayoutV1 {
    // The current maximum currency id
    uint16 internal maxCurrencyId;
    // Sets the state of liquidations being enabled during a paused state. Each of the four lower
    // bits can be turned on to represent one of the liquidation types being enabled.
    bytes1 internal liquidationEnabledState;
    // Set to true once the system has been initialized
    bool internal hasInitialized;

    /* Authentication Mappings */
    // This is set to the timelock contract to execute governance functions
    address public owner;
    // This is set to an address of a router that can only call governance actions
    address public pauseRouter;
    // This is set to an address of a router that can only call governance actions
    address public pauseGuardian;
    // On upgrades this is set in the case that the pause router is used to pass the rollback check
    address internal rollbackRouterImplementation;

    // A blanket allowance for a spender to transfer any of an account's nTokens. This would allow a user
    // to set an allowance on all nTokens for a particular integrating contract system.
    // owner => spender => transferAllowance
    mapping(address => mapping(address => uint256)) internal nTokenWhitelist;
    // Individual transfer allowances for nTokens used for ERC20
    // owner => spender => currencyId => transferAllowance
    mapping(address => mapping(address => mapping(uint16 => uint256))) internal nTokenAllowance;

    // Transfer operators
    // Mapping from a global ERC1155 transfer operator contract to an approval value for it
    mapping(address => bool) internal globalTransferOperator;
    // Mapping from an account => operator => approval status for that operator. This is a specific
    // approval between two addresses for ERC1155 transfers.
    mapping(address => mapping(address => bool)) internal accountAuthorizedTransferOperator;
    // Approval for a specific contract to use the `batchBalanceAndTradeActionWithCallback` method in
    // BatchAction.sol, can only be set by governance
    mapping(address => bool) internal authorizedCallbackContract;

    // Reverse mapping from token addresses to currency ids, only used for referencing in views
    // and checking for duplicate token listings.
    mapping(address => uint16) internal tokenAddressToCurrencyId;

    // Reentrancy guard
    uint256 internal reentrancyStatus;
}",558
RealWorld_BA_81_TreasuryManager_RealWord_20240825201826.log,81,TreasuryManager,32719,5959,38678,77.0,0.282775,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.9;

import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""@openzeppelin/contracts/proxy/utils/Initializable.sol"";
import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""@openzeppelin/contracts/proxy/utils/UUPSUpgradeable.sol"";
import {BoringOwnable} from ""./utils/BoringOwnable.sol"";
import {EIP1271Wallet} from ""./utils/EIP1271Wallet.sol"";
import {IVault, IAsset} from ""interfaces/balancer/IVault.sol"";
import {NotionalTreasuryAction} from ""interfaces/notional/NotionalTreasuryAction.sol"";
import {WETH9} from ""interfaces/WETH9.sol"";
import ""interfaces/balancer/IPriceOracle.sol"";

contract TreasuryManager is
    EIP1271Wallet,
    BoringOwnable,
    Initializable,
    UUPSUpgradeable
{
    using SafeERC20 for IERC20;

    /// @notice precision used to limit the amount of NOTE price impact (1e8 = 100%)
    uint256 internal constant NOTE_PURCHASE_LIMIT_PRECISION = 1e8;

    NotionalTreasuryAction public immutable NOTIONAL;
    IERC20 public immutable NOTE;
    IVault public immutable BALANCER_VAULT;
    ERC20 public immutable BALANCER_POOL_TOKEN;
    address public immutable sNOTE;
    bytes32 public immutable NOTE_ETH_POOL_ID;
    address public immutable ASSET_PROXY;

    address public manager;
    uint32 public refundGasPrice;
    uint256 public notePurchaseLimit;

    event ManagementTransferred(address prevManager, address newManager);
    event AssetsHarvested(uint16[] currencies, uint256[] amounts);
    event COMPHarvested(address[] ctokens, uint256 amount);
    event NOTEPurchaseLimitUpdated(uint256 purchaseLimit);

    /// @dev Restricted methods for the treasury manager
    modifier onlyManager() {
        require(msg.sender == manager, ""Unauthorized"");
        _;
    }

    constructor(
        NotionalTreasuryAction _notional,
        WETH9 _weth,
        IVault _balancerVault,
        bytes32 _noteETHPoolId,
        IERC20 _note,
        address _sNOTE,
        address _assetProxy
    ) EIP1271Wallet(_weth) initializer {
        // prettier-ignore
        (address poolAddress, /* */) = _balancerVault.getPool(_noteETHPoolId);
        require(poolAddress != address(0));

        NOTIONAL = NotionalTreasuryAction(_notional);
        sNOTE = _sNOTE;
        NOTE = _note;
        BALANCER_VAULT = _balancerVault;
        NOTE_ETH_POOL_ID = _noteETHPoolId;
        ASSET_PROXY = _assetProxy;
        BALANCER_POOL_TOKEN = ERC20(poolAddress);
    }

    function initialize(address _owner, address _manager) external initializer {
        owner = _owner;
        manager = _manager;
        emit OwnershipTransferred(address(0), _owner);
        emit ManagementTransferred(address(0), _manager);
    }

    function approveToken(address token, uint256 amount) external onlyOwner {
        IERC20(token).approve(ASSET_PROXY, amount);
    }

    function setPriceOracle(address tokenAddress, address oracleAddress)
        external
        onlyOwner
    {
        _setPriceOracle(tokenAddress, oracleAddress);
    }

    function setSlippageLimit(address tokenAddress, uint256 slippageLimit)
        external
        onlyOwner
    {
        _setSlippageLimit(tokenAddress, slippageLimit);
    }

    function setNOTEPurchaseLimit(uint256 purchaseLimit) external onlyOwner {
        require(
            purchaseLimit <= NOTE_PURCHASE_LIMIT_PRECISION,
            ""purchase limit is too high""
        );
        notePurchaseLimit = purchaseLimit;
        emit NOTEPurchaseLimitUpdated(purchaseLimit);
    }

    function withdraw(address token, uint256 amount) external onlyOwner {
        if (amount == type(uint256).max)
            amount = IERC20(token).balanceOf(address(this));
        IERC20(token).safeTransfer(owner, amount);
    }

    function wrapToWETH() external onlyManager {
        WETH.deposit{value: address(this).balance}();
    }

    function setManager(address newManager) external onlyOwner {
        emit ManagementTransferred(manager, newManager);
        manager = newManager;
    }

    /*** Manager Functionality  ***/

    /// @dev Will need to add a this method as a separate action behind the notional proxy
    function harvestAssetsFromNotional(uint16[] calldata currencies)
        external
        onlyManager
    {
        uint256[] memory amountsTransferred = NOTIONAL
            .transferReserveToTreasury(currencies);
        emit AssetsHarvested(currencies, amountsTransferred);
    }

    function harvestCOMPFromNotional(address[] calldata ctokens)
        external
        onlyManager
    {
        uint256 amountTransferred = NOTIONAL.claimCOMPAndTransfer(ctokens);
        emit COMPHarvested(ctokens, amountTransferred);
    }

    function investWETHToBuyNOTE(uint256 wethAmount) external onlyManager {
        _investWETHToBuyNOTE(wethAmount);
    }

    function _getNOTESpotPrice() public view returns (uint256) {
        // prettier-ignore
        (
            /* address[] memory tokens */,
            uint256[] memory balances,
            /* uint256 lastChangeBlock */
        ) = BALANCER_VAULT.getPoolTokens(NOTE_ETH_POOL_ID);

        // balances[0] = WETH
        // balances[1] = NOTE
        // increase NOTE precision to 1e18
        uint256 noteBal = balances[1] * 1e10;

        // We need to multiply the numerator by 1e18 to preserve enough
        // precision for the division
        // NOTEWeight = 0.8
        // ETHWeight = 0.2
        // SpotPrice = (ETHBalance / 0.2 * 1e18) / (NOTEBalance / 0.8)
        // SpotPrice = (ETHBalance * 5 * 1e18) / (NOTEBalance * 1.25)
        // SpotPrice = (ETHBalance * 5 * 1e18) / (NOTEBalance * 125 / 100)

        return (balances[0] * 5 * 1e18) / ((noteBal * 125) / 100);
    }

    function _investWETHToBuyNOTE(uint256 wethAmount) internal {
        IAsset[] memory assets = new IAsset[](2);
        assets[0] = IAsset(address(WETH));
        assets[1] = IAsset(address(NOTE));
        uint256[] memory maxAmountsIn = new uint256[](2);
        maxAmountsIn[0] = wethAmount;
        maxAmountsIn[1] = 0;

        IPriceOracle.OracleAverageQuery[]
            memory queries = new IPriceOracle.OracleAverageQuery[](1);

        queries[0].variable = IPriceOracle.Variable.PAIR_PRICE;
        queries[0].secs = 3600; // last hour
        queries[0].ago = 0; // now

        // Gets the balancer time weighted average price denominated in ETH
        uint256 noteOraclePrice = IPriceOracle(address(BALANCER_POOL_TOKEN))
            .getTimeWeightedAverage(queries)[0];

        BALANCER_VAULT.joinPool(
            NOTE_ETH_POOL_ID,
            address(this),
            sNOTE, // sNOTE will receive the BPT
            IVault.JoinPoolRequest(
                assets,
                maxAmountsIn,
                abi.encode(
                    IVault.JoinKind.EXACT_TOKENS_IN_FOR_BPT_OUT,
                    maxAmountsIn,
                    0 // Accept however much BPT the pool will give us
                ),
                false // Don't use internal balances
            )
        );

        uint256 noteSpotPrice = _getNOTESpotPrice();

        // Calculate the max spot price based on the purchase limit
        uint256 maxPrice = noteOraclePrice +
            (noteOraclePrice * notePurchaseLimit) /
            NOTE_PURCHASE_LIMIT_PRECISION;

        require(noteSpotPrice <= maxPrice, ""price impact is too high"");
    }

    function isValidSignature(bytes calldata data, bytes calldata signature)
        external
        view
        returns (bytes4)
    {
        return _isValidSignature(data, signature, manager);
    }

    function _authorizeUpgrade(address newImplementation)
        internal
        override
        onlyOwner
    {}
}",1854
RealWorld_BA_81_WETH9_RealWord_20240825204017.log,81,WETH9,3548,4247,7795,54.0,0.10268,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.9;

interface WETH9 {
    function deposit() external payable;

    function withdraw(uint256 wad) external;
}",39
RealWorld_BA_81_Types_RealWord_20240825203850.log,81,Types,10057,5532,15589,85.0,0.160925,"// SPDX-License-Identifier: GPL-3.0-only
pragma solidity =0.7.6;
pragma abicoder v2;

/// @notice Different types of internal tokens
///  - UnderlyingToken: underlying asset for a cToken (except for Ether)
///  - cToken: Compound interest bearing token
///  - cETH: Special handling for cETH tokens
///  - Ether: the one and only
///  - NonMintable: tokens that do not have an underlying (therefore not cTokens)
enum TokenType {UnderlyingToken, cToken, cETH, Ether, NonMintable}

/// @notice Internal object that represents a token
struct Token {
    address tokenAddress;
    bool hasTransferFee;
    int256 decimals;
    TokenType tokenType;
    uint256 maxCollateralBalance;
}

/// @dev Token object in storage:
///  20 bytes for token address
///  1 byte for hasTransferFee
///  1 byte for tokenType
///  1 byte for tokenDecimals
///  9 bytes for maxCollateralBalance (may not always be set)
struct TokenStorage {
    // Address of the token
    address tokenAddress;
    // Transfer fees will change token deposit behavior
    bool hasTransferFee;
    TokenType tokenType;
    uint8 decimalPlaces;
    // Upper limit on how much of this token the contract can hold at any time
    uint72 maxCollateralBalance;
}

/// @dev Holds account balance information, total storage 32 bytes
struct BalanceStorage {
    // Number of nTokens held by the account
    uint80 nTokenBalance;
    // Last time the account claimed their nTokens
    uint32 lastClaimTime;
    // The total integral supply of the nToken at the last claim time packed into
    // 56 bits. There is some loss of precision here but it is acceptable
    uint56 packedLastClaimIntegralSupply;
    // Cash balance of the account
    int88 cashBalance;
}",421
RealWorld_BA_81_IWeightedPool_RealWord_20240825205104.log,81,IWeightedPool,3261,4292,7553,61.0,0.102145,"pragma solidity ^0.8.9;

interface IWeightedPool {
    function setSwapFeePercentage(uint256 swapFeePercentage) external;
}",30
RealWorld_BA_81_sNOTE_RealWord_20240825202209.log,81,sNOTE,67386,5918,73304,85.0,0.45529,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.9;

import {BoringOwnable} from ""./utils/BoringOwnable.sol"";
import ""@openzeppelin/contracts/proxy/utils/UUPSUpgradeable.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin-upgradeable/contracts/token/ERC20/extensions/ERC20VotesUpgradeable.sol"";
import ""@openzeppelin-upgradeable/contracts/token/ERC20/ERC20Upgradeable.sol"";
import {IVault, IAsset} from ""interfaces/balancer/IVault.sol"";
import ""interfaces/balancer/IWeightedPool.sol"";
import ""interfaces/balancer/IPriceOracle.sol"";

contract sNOTE is ERC20Upgradeable, ERC20VotesUpgradeable, BoringOwnable, UUPSUpgradeable, ReentrancyGuard {
    using SafeERC20 for ERC20;

    IVault public immutable BALANCER_VAULT;
    ERC20 public immutable NOTE;
    ERC20 public immutable BALANCER_POOL_TOKEN;
    ERC20 public immutable WETH;
    bytes32 public immutable NOTE_ETH_POOL_ID;

    /// @notice Maximum shortfall withdraw of 50%
    uint256 public constant MAX_SHORTFALL_WITHDRAW = 50;
    uint256 public constant BPT_TOKEN_PRECISION = 1e18;

    /// @notice Redemption window in seconds
    uint256 public constant REDEEM_WINDOW_SECONDS = 3 days;

    /// @notice Tracks an account's redemption window
    struct AccountCoolDown {
        uint32 redeemWindowBegin;
        uint32 redeemWindowEnd;
    }

    /// @notice Number of seconds that need to pass before sNOTE can be redeemed
    uint32 public coolDownTimeInSeconds;

    /// @notice Mapping between sNOTE holders and their current cooldown status
    mapping(address => AccountCoolDown) public accountCoolDown;

    /// @notice Emitted when a cool down begins
    event CoolDownStarted(address account, uint256 redeemWindowBegin, uint256 redeemWindowEnd);

    /// @notice Emitted when a cool down ends
    event CoolDownEnded(address account);

    /// @notice Emitted when cool down time is updated
    event GlobalCoolDownUpdated(uint256 newCoolDownTimeSeconds);

    /// @notice Constructor sets immutable contract addresses
    constructor(
        IVault _balancerVault,
        bytes32 _noteETHPoolId,
        ERC20 _note,
        ERC20 _weth
    ) initializer { 
        // Validate that the pool exists
        (address poolAddress, /* */) = _balancerVault.getPool(_noteETHPoolId);
        require(poolAddress != address(0));

        WETH = _weth;
        NOTE = _note;
        NOTE_ETH_POOL_ID = _noteETHPoolId;
        BALANCER_VAULT = _balancerVault;
        BALANCER_POOL_TOKEN = ERC20(poolAddress);
    }

    /// @notice Initializes sNOTE ERC20 metadata and owner
    function initialize(
        address _owner,
        uint32 _coolDownTimeInSeconds
    ) external initializer {
        string memory _name = ""Staked NOTE"";
        string memory _symbol = ""sNOTE"";
        __ERC20_init(_name, _symbol);
        __ERC20Permit_init(_name);

        coolDownTimeInSeconds = _coolDownTimeInSeconds;
        owner = _owner;
        NOTE.safeApprove(address(BALANCER_VAULT), type(uint256).max);
        WETH.safeApprove(address(BALANCER_VAULT), type(uint256).max);

        emit OwnershipTransferred(address(0), _owner);
    }

    /** Governance Methods **/

    /// @notice Authorizes the DAO to upgrade this contract
    function _authorizeUpgrade(address newImplementation) internal override onlyOwner {}

    /// @notice Updates the required cooldown time to redeem
    function setCoolDownTime(uint32 _coolDownTimeInSeconds) external onlyOwner {
        coolDownTimeInSeconds = _coolDownTimeInSeconds;
        emit GlobalCoolDownUpdated(_coolDownTimeInSeconds);
    }

    /// @notice Allows the DAO to extract up to 50% of the BPT tokens during a collateral shortfall event
    function extractTokensForCollateralShortfall(uint256 requestedWithdraw) external nonReentrant onlyOwner {
        uint256 bptBalance = BALANCER_POOL_TOKEN.balanceOf(address(this));
        uint256 maxBPTWithdraw = (bptBalance * MAX_SHORTFALL_WITHDRAW) / 100;
        // Do not allow a withdraw of more than the MAX_SHORTFALL_WITHDRAW percentage. Specifically don't
        // revert here since there may be a delay between when governance issues the token amount and when
        // the withdraw actually occurs.
        uint256 bptExitAmount = requestedWithdraw > maxBPTWithdraw ? maxBPTWithdraw : requestedWithdraw;

        IAsset[] memory assets = new IAsset[](2);
        assets[0] = IAsset(address(WETH));
        assets[1] = IAsset(address(NOTE));
        uint256[] memory minAmountsOut = new uint256[](2);
        minAmountsOut[0] = 0;
        minAmountsOut[1] = 0;

        BALANCER_VAULT.exitPool(
            NOTE_ETH_POOL_ID,
            address(this),
            payable(owner), // Owner will receive the NOTE and WETH
            IVault.ExitPoolRequest(
                assets,
                minAmountsOut,
                abi.encode(
                    IVault.ExitKind.EXACT_BPT_IN_FOR_TOKENS_OUT,
                    bptExitAmount
                ),
                false // Don't use internal balances
            )
        );
    }

    /// @notice Allows the DAO to set the swap fee on the BPT
    function setSwapFeePercentage(uint256 swapFeePercentage) external onlyOwner {
        IWeightedPool(address(BALANCER_POOL_TOKEN)).setSwapFeePercentage(swapFeePercentage);
    }

    /** User Methods **/

    /// @notice Mints sNOTE from the underlying BPT token.
    /// @param bptAmount is the amount of BPT to transfer from the msg.sender.
    function mintFromBPT(uint256 bptAmount) external nonReentrant {
        // _mint logic requires that tokens are transferred first
        BALANCER_POOL_TOKEN.safeTransferFrom(msg.sender, address(this), bptAmount);
        _mint(msg.sender, bptAmount);
    }

    /// @notice Mints sNOTE from some amount of NOTE tokens.
    /// @param noteAmount amount of NOTE to transfer into the sNOTE contract
    function mintFromNOTE(uint256 noteAmount) external nonReentrant {
        // Transfer the NOTE balance into sNOTE first
        NOTE.safeTransferFrom(msg.sender, address(this), noteAmount);

        IAsset[] memory assets = new IAsset[](2);
        assets[0] = IAsset(address(0));
        assets[1] = IAsset(address(NOTE));
        uint256[] memory maxAmountsIn = new uint256[](2);
        maxAmountsIn[0] = 0;
        maxAmountsIn[1] = noteAmount;

        _mintFromAssets(assets, maxAmountsIn);
    }

    /// @notice Mints sNOTE from some amount of ETH
    function mintFromETH() payable external nonReentrant {
        IAsset[] memory assets = new IAsset[](2);
        assets[0] = IAsset(address(0));
        assets[1] = IAsset(address(NOTE));
        uint256[] memory maxAmountsIn = new uint256[](2);
        maxAmountsIn[0] = msg.value;
        maxAmountsIn[1] = 0;

        _mintFromAssets(assets, maxAmountsIn);
    }

    /// @notice Mints sNOTE from some amount of WETH
    /// @param wethAmount amount of WETH to transfer into the sNOTE contract
    function mintFromWETH(uint256 wethAmount) external nonReentrant {
        // Transfer the NOTE balance into sNOTE first
        WETH.safeTransferFrom(msg.sender, address(this), wethAmount);

        IAsset[] memory assets = new IAsset[](2);
        assets[0] = IAsset(address(WETH));
        assets[1] = IAsset(address(NOTE));
        uint256[] memory maxAmountsIn = new uint256[](2);
        maxAmountsIn[0] = wethAmount;
        maxAmountsIn[1] = 0;

        _mintFromAssets(assets, maxAmountsIn);
    }

    function _mintFromAssets(IAsset[] memory assets, uint256[] memory maxAmountsIn) internal {
        uint256 bptBefore = BALANCER_POOL_TOKEN.balanceOf(address(this));
        // Set msgValue when joining via ETH
        uint256 msgValue = assets[0] == IAsset(address(0)) ? maxAmountsIn[0] : 0;

        BALANCER_VAULT.joinPool{value: msgValue}(
            NOTE_ETH_POOL_ID,
            address(this),
            address(this), // sNOTE will receive the BPT
            IVault.JoinPoolRequest(
                assets,
                maxAmountsIn,
                abi.encode(
                    IVault.JoinKind.EXACT_TOKENS_IN_FOR_BPT_OUT,
                    maxAmountsIn,
                    0 // Accept however much BPT the pool will give us
                ),
                false // Don't use internal balances
            )
        );
        uint256 bptAfter = BALANCER_POOL_TOKEN.balanceOf(address(this));

        // Balancer pool token amounts must increase
        _mint(msg.sender, bptAfter - bptBefore);
    }

    /// @notice Begins a cool down period for the sender, this is required to redeem tokens
    function startCoolDown() external {
        // Cannot start a cool down if there is already one in effect
        _requireAccountNotInCoolDown(msg.sender);
        uint256 redeemWindowBegin = block.timestamp + coolDownTimeInSeconds;
        uint256 redeemWindowEnd = redeemWindowBegin + REDEEM_WINDOW_SECONDS;

        accountCoolDown[msg.sender] = AccountCoolDown(_safe32(redeemWindowBegin), _safe32(redeemWindowEnd));

        emit CoolDownStarted(msg.sender, redeemWindowBegin, redeemWindowEnd);
    }

    /// @notice Stops a cool down for the sender
    function stopCoolDown() public {
        // Reset the cool down back to zero so that the account must initiate it again to redeem
        delete accountCoolDown[msg.sender];
        emit CoolDownEnded(msg.sender);
    }

    /// @notice Redeems some amount of sNOTE to underlying BPT tokens (which can then be sold for
    /// NOTE or ETH). An account must have passed its cool down expiration before they can redeem
    /// @param sNOTEAmount amount of sNOTE to redeem
    function redeem(uint256 sNOTEAmount) external nonReentrant {
        AccountCoolDown memory coolDown = accountCoolDown[msg.sender];
        require(sNOTEAmount <= balanceOf(msg.sender), ""Insufficient balance"");
        require(
            coolDown.redeemWindowBegin != 0 &&
            coolDown.redeemWindowBegin < block.timestamp &&
            block.timestamp < coolDown.redeemWindowEnd,
            ""Not in Redemption Window""
        );

        uint256 bptToRedeem = getPoolTokenShare(sNOTEAmount);
        _burn(msg.sender, bptToRedeem);

        BALANCER_POOL_TOKEN.safeTransfer(msg.sender, bptToRedeem);
    }

    /** External View Methods **/

    /// @notice Returns how many Balancer pool tokens an sNOTE token amount has a claim on
    function getPoolTokenShare(uint256 sNOTEAmount) public view returns (uint256 bptClaim) {
        uint256 bptBalance = BALANCER_POOL_TOKEN.balanceOf(address(this));
        // BPT and sNOTE are both in 18 decimal precision so no conversion required
        return (bptBalance * sNOTEAmount) / totalSupply();
    }

    /// @notice Returns the pool token share of a specific account
    function poolTokenShareOf(address account) public view returns (uint256 bptClaim) {
        return getPoolTokenShare(balanceOf(account));
    }

    /// @notice Calculates voting power for a given amount of sNOTE
    /// @param sNOTEAmount amount of sNOTE to calculate voting power for
    /// @return corresponding NOTE voting power
    function getVotingPower(uint256 sNOTEAmount) public view returns (uint256) {
        // Gets the BPT token price (in ETH)
        uint256 bptPrice = IPriceOracle(address(BALANCER_POOL_TOKEN)).getLatest(IPriceOracle.Variable.BPT_PRICE);
        // Gets the NOTE token price (in ETH)
        uint256 notePrice = IPriceOracle(address(BALANCER_POOL_TOKEN)).getLatest(IPriceOracle.Variable.PAIR_PRICE);
        
        // Since both bptPrice and notePrice are denominated in ETH, we can use
        // this formula to calculate noteAmount
        // bptBalance * bptPrice = notePrice * noteAmount
        // noteAmount = bptPrice/notePrice * bptBalance
        uint256 priceRatio = bptPrice * 1e18 / notePrice;
        uint256 bptBalance = BALANCER_POOL_TOKEN.balanceOf(address(this));

        // Amount_note = Price_NOTE_per_BPT * BPT_supply * 80% (80/20 pool)
        uint256 noteAmount = priceRatio * bptBalance * 80 / 100;

        // Reduce precision down to 1e8 (NOTE token)
        // priceRatio and bptBalance are both 1e18 (1e36 total)
        // we divide by 1e28 to get to 1e8
        noteAmount /= 1e28;

        return (noteAmount * sNOTEAmount) / totalSupply();
    }

    /// @notice Calculates voting power for a given account
    /// @param account a given sNOTE holding account
    /// @return corresponding NOTE voting power
    function votingPowerOf(address account) external view returns (uint256) {
        return getVotingPower(balanceOf(account));
    }

    /** Internal Methods **/

    function _requireAccountNotInCoolDown(address account) internal view {
        AccountCoolDown memory coolDown = accountCoolDown[account];
        // An account is in cool down if the redeem window has begun and the window end has not
        // passed yet.
        bool isInCoolDown = (0 < coolDown.redeemWindowBegin && block.timestamp < coolDown.redeemWindowEnd);
        require(!isInCoolDown, ""Account in Cool Down"");
    }

    /// @notice Burns sNOTE tokens when they are redeemed
    /// @param account account to burn tokens on
    /// @param bptToRedeem the number of BPT tokens being redeemed by the account
    function _burn(address account, uint256 bptToRedeem) internal override(ERC20Upgradeable, ERC20VotesUpgradeable) {
        uint256 poolTokenShare = poolTokenShareOf(account);
        require(bptToRedeem <= poolTokenShare, ""Invalid Redeem Amount"");

        // Burns the portion of the sNOTE corresponding to the bptToRedeem
        uint256 sNOTEToBurn = balanceOf(account) * bptToRedeem / poolTokenShare;
        // Handles event emission, balance update and total supply update
        super._burn(account, sNOTEToBurn);
    }

    /// @notice Mints sNOTE tokens given a bptAmount
    /// @param account account to mint tokens to
    /// @param bptAmount the number of BPT tokens being minted by the account
    function _mint(address account, uint256 bptAmount) internal override(ERC20Upgradeable, ERC20VotesUpgradeable) {
        // Cannot mint if a cooldown is already in effect. If an account mints during a cool down period then they will
        // be able to redeem the tokens immediately, bypassing the cool down.
        _requireAccountNotInCoolDown(account);

        // Immediately after minting, we need to satisfy the equality:
        // (sNOTEToMint * bptBalance) / (totalSupply + sNOTEToMint) == bptAmount

        // Rearranging to get sNOTEToMint on one side:
        // (sNOTEToMint * bptBalance) = (totalSupply + sNOTEToMint) * bptAmount
        // (sNOTEToMint * bptBalance) = totalSupply * bptAmount + sNOTEToMint * bptAmount
        // (sNOTEToMint * bptBalance) - (sNOTEToMint * bptAmount) = totalSupply * bptAmount
        // sNOTEToMint * (bptBalance - bptAmount) = totalSupply * bptAmount
        // sNOTEToMint = (totalSupply * bptAmount) / (bptBalance - bptAmount)

        // NOTE: at this point the BPT has already been transferred into the sNOTE contract, so this
        // bptBalance amount includes bptAmount.
        uint256 bptBalance = BALANCER_POOL_TOKEN.balanceOf(address(this));
        uint256 _totalSupply = totalSupply();
        uint256 sNOTEToMint;
        if (_totalSupply == 0) {
            sNOTEToMint = bptAmount;
        } else {
            sNOTEToMint = (_totalSupply * bptAmount) / (bptBalance - bptAmount);
        }

        // Handles event emission, balance update and total supply update
        super._mint(account, sNOTEToMint);
    }

    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal override(ERC20Upgradeable) {
        // Cannot send or receive tokens if a cool down is in effect or else accounts
        // can bypass the cool down. It's not clear if sending tokens can be used to bypass
        // the cool down but we restrict it here anyway, there's no clear use case for sending
        // sNOTE tokens during a cool down.
        if (to != address(0)) {
            // Run these checks only when we are not burning tokens. (OZ ERC20 does not allow transfers
            // to address(0), to == address(0) only when _burn is called).
            _requireAccountNotInCoolDown(from);
            _requireAccountNotInCoolDown(to);
        }

        super._beforeTokenTransfer(from, to, amount);
    }

    function _afterTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal override(ERC20Upgradeable, ERC20VotesUpgradeable) {
        // Moves sNOTE checkpoints
        super._afterTokenTransfer(from, to, amount);
    }

    function _safe32(uint256 x) internal pure returns (uint32) {
        require (x <= type(uint32).max);
        return uint32(x);
    }
}",4058
RealWorld_BA_83_IShelterClient_RealWord_20240825232123.log,83,IShelterClient,4014,4405,8419,61.0,0.10817,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.11;

import { IERC20 } from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

interface IShelterClient {
    function totalShare(IERC20 _token) external view returns(uint256);
    function shareOf(IERC20 _token, address _user) external view returns(uint256);
}",82
RealWorld_BA_83_MasterChef_RealWord_20240825231219.log,83,MasterChef,36357,6168,42525,95.0,0.305145,"// SPDX-License-Identifier: MIT


pragma solidity ^0.8.11;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""@openzeppelin/contracts/utils/math/SafeMath.sol"";
import ""@openzeppelin/contracts/utils/math/SafeCast.sol"";

contract MasterChef is Ownable, ReentrancyGuard {
    using SafeMath for uint;
    using SafeERC20 for IERC20;

    event Deposit(address indexed _user, uint indexed _pid, uint _amount);
    event Withdraw(address indexed _user, uint indexed _pid, uint _amount);
    event EmergencyWithdraw(address indexed user, uint indexed _pid, uint _amount);

    struct UserInfo {
        uint128 amount; // How many tokens the user has provided.
        uint128 rewardDebt; // Reward debt. See explanation below.
        //
        // We do some fancy math here. Basically, any point in time, the amount of RADSs
        // entitled to a user but is pending to be distributed is:
        //
        //   pending reward = (user.amount * pool.accumlatedConcurPerShare) - user.rewardDebt
        //
        // Whenever a user deposits or withdraws LP tokens to a pool. Here's what happens:
        //   1. The pool's `accumlatedConcurPerShare` (and `lastRewardBlock`) gets updated.
        //   2. User receives the pending reward sent to his/her address.
        //   3. User's `amount` gets updated.
        //   4. User's `rewardDebt` gets updated.
    }

    // Info of each pool.
    struct PoolInfo {
        IERC20 depositToken; // Address of LP token contract.
        uint allocPoint; // How many allocation points assigned to this pool. to distribute per block.
        uint lastRewardBlock; // Last block number that distribution occurs.
        uint accConcurPerShare; // Accumulated per share, times multiplier. See below.
        uint16 depositFeeBP; // Deposit fee in basis points
    }

    PoolInfo[] public poolInfo;
    mapping(uint => mapping(address => UserInfo)) public userInfo; // Info of each user that stakes LP tokens.
    mapping(address => bool) public isDepositor;
    mapping(address => uint256) public pid; // pid mapped to token
    uint public concurPerBlock = 100000 gwei; // concur tokens transferred per block
    uint public totalAllocPoint = 0; // Total allocation points. Must be the sum of all allocation points in all pools.
    uint public startBlock;
    uint public endBlock; // The block number when mining starts.
    IERC20 public concur;

    uint private _concurShareMultiplier = 1e18;
    uint private _perMille = 1000; // 100%

    constructor(IERC20 _concur, uint _startBlock, uint _endBlock) Ownable() {
        startBlock = _startBlock;
        endBlock = _endBlock;
        concur = _concur;
        poolInfo.push(
            PoolInfo({
            depositToken: IERC20(address(0)),
            allocPoint : 0,
            lastRewardBlock : _startBlock,
            accConcurPerShare : 0,
            depositFeeBP : 0
        }));
    }

    modifier onlyDepositor() {
        require(isDepositor[msg.sender], ""!depositor"");
        _;
    }

    function addDepositor(address _depositor) external onlyOwner {
        isDepositor[_depositor] = true;
    }

    function removeDepositor(address _depositor) external onlyOwner {
        isDepositor[_depositor] = false;
    }

    function add(address _token, uint _allocationPoints, uint16 _depositFee, uint _startBlock) public onlyOwner {
        require(_token != address(0), ""zero address"");
        uint lastRewardBlock = block.number > _startBlock ? block.number : _startBlock;
        totalAllocPoint = totalAllocPoint.add(_allocationPoints);
        require(pid[_token] == 0, ""already registered""); // pid starts from 0
        poolInfo.push(
            PoolInfo({
                depositToken: IERC20(_token),
                allocPoint: _allocationPoints,
                lastRewardBlock: lastRewardBlock,
                accConcurPerShare: 0,
                depositFeeBP: _depositFee
            })
        );
        pid[_token] = poolInfo.length - 1;
    }

    function poolLength() external view returns (uint) {
        return poolInfo.length;
    }

    // Return reward multiplier over the given _from to _to block.
    function getMultiplier(uint _from, uint _to) public pure returns (uint) {
        return _to.sub(_from);
    }

    // View function to see pending [concur] on frontend.
    function pendingConcur(uint _pid, address _user) external view returns (uint) {
        PoolInfo storage pool = poolInfo[_pid];
        UserInfo storage user = userInfo[_pid][_user];
        uint accConcurPerShare = pool.accConcurPerShare;
        uint lpSupply = pool.depositToken.balanceOf(address(this));
        if (block.number > pool.lastRewardBlock && lpSupply != 0) {
            uint multiplier = getMultiplier(pool.lastRewardBlock, block.number);
            uint concurReward = multiplier.mul(concurPerBlock).mul(pool.allocPoint).div(totalAllocPoint);
            accConcurPerShare = accConcurPerShare.add(concurReward.mul(_concurShareMultiplier).div(lpSupply));
        }
        return user.amount * accConcurPerShare / _concurShareMultiplier - user.rewardDebt;
    }

    // Update reward variables for all pools. Be careful of gas spending!
    function massUpdatePools() public {
        uint length = poolInfo.length;
        for (uint _pid = 0; _pid < length; ++_pid) {
            updatePool(_pid);
        }
    }

    // Update reward variables of the given pool to be up-to-date.
    function updatePool(uint _pid) public {
        PoolInfo storage pool = poolInfo[_pid];
        if (block.number <= pool.lastRewardBlock) {
            return;
        }
        uint lpSupply = pool.depositToken.balanceOf(address(this));
        if (lpSupply == 0 || pool.allocPoint == 0) {
            pool.lastRewardBlock = block.number;
            return;
        }
        if(block.number >= endBlock) {
            pool.lastRewardBlock = block.number;
            return;
        }        

        uint multiplier = getMultiplier(pool.lastRewardBlock, block.number);
        uint concurReward = multiplier.mul(concurPerBlock).mul(pool.allocPoint).div(totalAllocPoint);
        pool.accConcurPerShare = pool.accConcurPerShare.add(concurReward.mul(_concurShareMultiplier).div(lpSupply));
        pool.lastRewardBlock = block.number;
    }

    // Deposit tokens for [concur] allocation.  
    function deposit(address _recipient, uint _pid, uint _amount) external nonReentrant onlyDepositor {
        PoolInfo storage pool = poolInfo[_pid];
        UserInfo storage user = userInfo[_pid][_msgSender()];
        updatePool(_pid);
       
        if(user.amount > 0) {  
            uint pending = user.amount * pool.accConcurPerShare / _concurShareMultiplier - user.rewardDebt;
            if (pending > 0) {
                safeConcurTransfer(_recipient, pending);
            }
        }

        if (_amount > 0) {
            if (pool.depositFeeBP > 0) {
                uint depositFee = _amount.mul(pool.depositFeeBP).div(_perMille);
                user.amount = SafeCast.toUint128(user.amount + _amount - depositFee);
            } else {
                user.amount = SafeCast.toUint128(user.amount + _amount);
            }
        }     

        user.rewardDebt = SafeCast.toUint128(user.amount * pool.accConcurPerShare / _concurShareMultiplier);
        emit Deposit(_recipient, _pid, _amount);
    }

    // Withdraw tokens
    function withdraw(address _recipient, uint _pid, uint _amount) external nonReentrant onlyDepositor {
        PoolInfo storage pool = poolInfo[_pid];
        UserInfo storage user = userInfo[_pid][_msgSender()];
        require(user.amount > 0, ""MasterChef: nothing to withdraw"");
        require(user.amount >= _amount, ""MasterChef: withdraw not allowed"");
        updatePool(_pid);

        uint pending = user.amount * pool.accConcurPerShare / _concurShareMultiplier - user.rewardDebt;
        if(pending > 0) {
            safeConcurTransfer(_recipient, pending);
        }
        if (_amount > 0) {
            user.amount = SafeCast.toUint128(user.amount - _amount);
        }
        user.rewardDebt = SafeCast.toUint128(user.amount * pool.accConcurPerShare / _concurShareMultiplier);
        emit Withdraw(_recipient, _pid, _amount);
    }

    // Safe [concur] transfer function, just in case if rounding error causes pool to not have enough
    function safeConcurTransfer(address _to, uint _amount) private {
        uint concurBalance = concur.balanceOf(address(this));
        bool transferSuccess = false;
        if (_amount > concurBalance) {
            transferSuccess = concur.transfer(_to, concurBalance);
        } else {
            transferSuccess = concur.transfer(_to, _amount);
        }
        require(transferSuccess, ""safeConcurTransfer: transfer failed"");
    }
}",2092
RealWorld_BA_83_USDMPegRecovery_RealWord_20240825231511.log,83,USDMPegRecovery,21067,5930,26997,74.0,0.223935,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.11;

import { SafeERC20 } from ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import { IERC20 } from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import { Ownable } from ""@openzeppelin/contracts/access/Ownable.sol"";
import { ICurveMetaPool } from ""./external/CurveInterfaces.sol"";

contract USDMPegRecovery is Ownable {

    using SafeERC20 for IERC20; 

    IERC20 public immutable usdm;

    IERC20 public immutable pool3;

    ICurveMetaPool public immutable usdm3crv;

    address public immutable kpiOracle;

    uint256 public step;

    uint256 public startLiquidity;

    struct Liquidity {
        uint128 usdm;
        uint128 pool3;
    }

    event Deposit(address indexed depositor, Liquidity deposits);

    event Withdraw(address indexed withdrawer, Liquidity withdrawals);

    Liquidity public totalLiquidity;

    mapping(address => Liquidity) public userLiquidity;

    mapping(address => bool) public isGuardian;

    bool public unlockable;

    modifier onlyGuardian() {
        require(isGuardian[msg.sender], ""!guardian"");
        _;
    }

    constructor(
        uint256 _startLiquidity,
        address _kpiOracle
    ) Ownable() {
        startLiquidity = _startLiquidity;
        usdm = IERC20(0x31d4Eb09a216e181eC8a43ce79226A487D6F0BA9);
        pool3 = IERC20(0x6c3F90f043a72FA612cbac8115EE7e52BDe6E490);
        usdm3crv = ICurveMetaPool(0x5B3b5DF2BF2B6543f78e053bD91C4Bdd820929f1);
        step = 250000e18;
        kpiOracle = _kpiOracle;
    }

    function addGuardian(address _guardian) external onlyOwner {
        isGuardian[_guardian] = true;
    }

    function removeGuardian(address _guardian) external onlyOwner {
        isGuardian[_guardian] = false;
    }

    function enableUnlock() external {
        require(msg.sender == kpiOracle, ""!oracle"");
        unlockable = true;
    }

    function provide(uint256 _minimumLP) external onlyGuardian {
        require(usdm.balanceOf(address(this)) >= totalLiquidity.usdm, ""<liquidity"");
        // truncate amounts under step
        uint256 addingLiquidity = (usdm.balanceOf(address(this)) / step) * step;
        // match usdm : pool3 = 1 : 1
        uint256[2] memory amounts = [addingLiquidity, addingLiquidity];
        usdm.approve(address(usdm3crv), addingLiquidity);
        pool3.approve(address(usdm3crv), addingLiquidity);
        usdm3crv.add_liquidity(amounts, _minimumLP);
    }

    function removeLiquidity(uint256 _steps, uint256 _burningLPs) external onlyGuardian {
        uint256 removingLiquidity = _steps * step;
        uint256[2] memory amounts = [removingLiquidity, removingLiquidity];
        usdm3crv.remove_liquidity(_burningLPs, amounts);
    }

    function deposit(Liquidity calldata _deposits) external {
        Liquidity memory total = totalLiquidity;
        Liquidity memory user = userLiquidity[msg.sender];
        if(_deposits.usdm > 0) {
            usdm.safeTransferFrom(msg.sender, address(this), uint256(_deposits.usdm));
            total.usdm += _deposits.usdm;
            user.usdm += _deposits.usdm;
        }

        if(_deposits.pool3 > 0) {
            require(totalLiquidity.usdm > 4000000e18, ""usdm low"");
            pool3.safeTransferFrom(msg.sender, address(this), uint256(_deposits.pool3));
            total.pool3 += _deposits.pool3;
            user.pool3 += _deposits.pool3;
        }
        totalLiquidity = total;
        userLiquidity[msg.sender] = user;
        emit Deposit(msg.sender, _deposits);
    }

    function withdraw(Liquidity calldata _withdrawal) external {
        Liquidity memory total = totalLiquidity;
        Liquidity memory user = userLiquidity[msg.sender];
        if(_withdrawal.usdm > 0) {
            require(unlockable, ""!unlock usdm"");
            usdm.safeTransfer(msg.sender, uint256(_withdrawal.usdm));
            total.usdm -= _withdrawal.usdm;
            user.usdm -= _withdrawal.usdm;
        }

        if(_withdrawal.pool3 > 0) {
            pool3.safeTransfer(msg.sender, uint256(_withdrawal.pool3));
            total.pool3 -= _withdrawal.pool3;
            user.pool3 -= _withdrawal.pool3;
        }
        totalLiquidity = total;
        userLiquidity[msg.sender] = user;
        emit Withdraw(msg.sender, _withdrawal);
    }
}",1156
RealWorld_BA_83_ConcurRewardPool_RealWord_20240825231627.log,83,ConcurRewardPool,8229,4896,13125,65.0,0.139065,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.11;

import {IERC20} from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import {SafeERC20} from ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import {IConcurRewardClaim} from ""./interfaces/IConcurRewardClaim.sol"";

contract ConcurRewardPool is IConcurRewardClaim {
    using SafeERC20 for IERC20;
    address public immutable rewardNotifier;

    mapping(address => mapping(address => uint256)) public reward;

    constructor(address _notifier) {
        rewardNotifier = _notifier;
    }

    /// @notice push reward to `_recipient`
    /// @param _recipient reward recipient address
    /// @param _token token to reward
    /// @param _amount amount of tokens to allocate to `_recipient`
    function pushReward(
        address _recipient,
        address _token,
        uint256 _amount
    ) external override {
        require(msg.sender == rewardNotifier, ""!notifier"");
        reward[_recipient][_token] += _amount;
    }

    /// @notice claim rewards of `msg.sender`
    /// @param _tokens array of tokens to claim
    function claimRewards(address[] calldata _tokens) external override {
        for (uint256 i = 0; i < _tokens.length; i++) {
            uint256 getting = reward[msg.sender][_tokens[i]];
            IERC20(_tokens[i]).safeTransfer(msg.sender, getting);
            reward[msg.sender][_tokens[i]] = 0;
        }
    }
}",338
RealWorld_BA_83_IConcurRewardClaim_RealWord_20240825232446.log,83,IConcurRewardClaim,4263,5168,9431,63.0,0.124675,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.11;

interface IConcurRewardClaim {
    function pushReward(
        address _recipient,
        address _token,
        uint256 _amount
    ) external;

    function claimRewards(address[] calldata _tokens) external;
}",63
RealWorld_BA_83_Iauction_RealWord_20240825232336.log,83,Iauction,4429,4729,9158,68.0,0.116725,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.11;

interface Iauction {
    function isWinningSignature(bytes32 _hash, bytes memory _signature)
        external
        view
        returns (bool);
}",48
RealWorld_BA_83_VoteProxy_RealWord_20240825230819.log,83,VoteProxy,6860,5401,12261,78.0,0.14232,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.11;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""./interfaces/Iauction.sol"";

contract VoteProxy is Ownable {
    Iauction public auctioneer;

    function updateAuctioneer(address _auctioneer) external onlyOwner {
        auctioneer = Iauction(_auctioneer);
    }

    function isValidSignature(bytes32 _hash, bytes calldata _signature)
        external
        view
        returns (bytes4)
    {
        // Validate signatures
        if (auctioneer.isWinningSignature(_hash, _signature) == true) {
            return 0x1626ba7e;
        } else {
            return 0xffffffff;
        }
    }

    function execute(
        address _to,
        uint256 _value,
        bytes calldata _data
    ) external onlyOwner returns (bool, bytes memory) {
        (bool success, bytes memory result) = _to.call{value: _value}(_data);
        return (success, result);
    }
}",222
RealWorld_BA_83_ConvexStakingWrapper_RealWord_20240825231356.log,83,ConvexStakingWrapper,42707,5591,48298,73.0,0.325355,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.11;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/security/Pausable.sol"";
import ""./external/ConvexInterfaces.sol"";
import ""./interfaces/IConcurRewardClaim.sol"";
import ""./MasterChef.sol"";

contract ConvexStakingWrapper is Ownable, ReentrancyGuard, Pausable {
    using SafeERC20 for IERC20;

    struct RewardType {
        address token;
        address pool;
        uint128 integral;
        uint128 remaining;
    }

    struct Reward {
        uint128 integral;
    }

    //constants/immutables
    address public constant convexBooster =
        address(0xF403C135812408BFbE8713b5A23a04b3D48AAE31);
    address public constant crv =
        address(0xD533a949740bb3306d119CC777fa900bA034cd52);
    address public constant cvx =
        address(0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B);

    uint256 public constant CRV_INDEX = 0;
    uint256 public constant CVX_INDEX = 1;
    uint256 public constant VOTECYCLE_START = 1645002000; //Feb 16 2022 09:00:00 GMT+0000
    MasterChef public immutable masterChef;

    //convex rewards
    mapping(uint256 => address) public convexPool;
    mapping(uint256 => RewardType[]) public rewards;
    mapping(uint256 => mapping(uint256 => mapping(address => Reward)))
        public userReward;
    mapping(uint256 => mapping(address => uint256)) public registeredRewards;

    //management
    address public treasury;
    IConcurRewardClaim public claimContract;

    struct Deposit {
        uint64 epoch;
        uint192 amount;
    }

    struct WithdrawRequest {
        uint64 epoch;
        uint192 amount;
    }

    mapping(address => uint256) public pids;
    mapping(uint256 => mapping(address => Deposit)) public deposits;
    mapping(uint256 => mapping(address => WithdrawRequest)) public withdrawRequest;

    event Deposited(address indexed _user, uint256 _amount);
    event Withdrawn(address indexed _user, uint256 _amount);

    constructor(address _treasury, MasterChef _masterChef) {
        treasury = _treasury;
        masterChef = _masterChef;
    }

    function pause() external onlyOwner {
        _pause();
    }

    function unpause() external onlyOwner {
        _unpause();
    }

    function changeTreasury(address _treasury) external onlyOwner {
        treasury = _treasury;
    }

    function setRewardPool(address _claimContract) external onlyOwner {
        claimContract = IConcurRewardClaim(_claimContract);
    }

    /// @notice function to bootstrap the reward pool and extra rewards of convex booster
    /// @dev should be able to be called more than once
    /// @param _pid pid of the curve lp. same as convex booster pid
    function addRewards(uint256 _pid) public {
        address mainPool = IRewardStaking(convexBooster)
            .poolInfo(_pid)
            .crvRewards;
        if (rewards[_pid].length == 0) {
            pids[IRewardStaking(convexBooster).poolInfo(_pid).lptoken] = _pid;
            convexPool[_pid] = mainPool;
            rewards[_pid].push(
                RewardType({
                    token: crv,
                    pool: mainPool,
                    integral: 0,
                    remaining: 0
                })
            );
            rewards[_pid].push(
                RewardType({
                    token: cvx,
                    pool: address(0),
                    integral: 0,
                    remaining: 0
                })
            );
            registeredRewards[_pid][crv] = CRV_INDEX + 1; //mark registered at index+1
            registeredRewards[_pid][cvx] = CVX_INDEX + 1; //mark registered at index+1
        }

        uint256 extraCount = IRewardStaking(mainPool).extraRewardsLength();
        for (uint256 i = 0; i < extraCount; i++) {
            address extraPool = IRewardStaking(mainPool).extraRewards(i);
            address extraToken = IRewardStaking(extraPool).rewardToken();
            if (extraToken == cvx) {
                //no-op for cvx, crv rewards
                rewards[_pid][CVX_INDEX].pool = extraPool;
            } else if (registeredRewards[_pid][extraToken] == 0) {
                //add new token to list
                rewards[_pid].push(
                    RewardType({
                        token: IRewardStaking(extraPool).rewardToken(),
                        pool: extraPool,
                        integral: 0,
                        remaining: 0
                    })
                );
                registeredRewards[_pid][extraToken] = rewards[_pid].length; //mark registered at index+1
            }
        }
    }

    function rewardLength(uint256 _pid) external view returns (uint256) {
        return rewards[_pid].length;
    }

    function _getDepositedBalance(uint256 _pid, address _account)
        internal
        view
        virtual
        returns (uint256)
    {
        return deposits[_pid][_account].amount;
    }

    function _getTotalSupply(uint256 _pid)
        internal
        view
        virtual
        returns (uint256)
    {
        return IRewardStaking(convexPool[_pid]).balanceOf(address(this));
    }

    function _calcRewardIntegral(
        uint256 _pid,
        uint256 _index,
        address _account,
        uint256 _balance,
        uint256 _supply
    ) internal {
        RewardType memory reward = rewards[_pid][_index];

        //get difference in balance and remaining rewards
        //getReward is unguarded so we use remaining to keep track of how much was actually claimed
        uint256 bal = IERC20(reward.token).balanceOf(address(this));
        uint256 d_reward = bal - reward.remaining;
        // send 20 % of cvx / crv reward to treasury
        if (reward.token == cvx || reward.token == crv) {
            IERC20(reward.token).transfer(treasury, d_reward / 5);
            d_reward = (d_reward * 4) / 5;
        }
        IERC20(reward.token).transfer(address(claimContract), d_reward);

        if (_supply > 0 && d_reward > 0) {
            reward.integral =
                reward.integral +
                uint128((d_reward * 1e20) / _supply);
        }

        //update user integrals
        uint256 userI = userReward[_pid][_index][_account].integral;
        if (userI < reward.integral) {
            userReward[_pid][_index][_account].integral = reward.integral;
            claimContract.pushReward(
                _account,
                reward.token,
                (_balance * (reward.integral - userI)) / 1e20
            );
        }

        //update remaining reward here since balance could have changed if claiming
        if (bal != reward.remaining) {
            reward.remaining = uint128(bal);
        }

        rewards[_pid][_index] = reward;
    }

    function _checkpoint(uint256 _pid, address _account) internal {
        //if shutdown, no longer checkpoint in case there are problems
        if (paused()) return;

        uint256 supply = _getTotalSupply(_pid);
        uint256 depositedBalance = _getDepositedBalance(_pid, _account);

        IRewardStaking(convexPool[_pid]).getReward(address(this), true);

        uint256 rewardCount = rewards[_pid].length;
        for (uint256 i = 0; i < rewardCount; i++) {
            _calcRewardIntegral(_pid, i, _account, depositedBalance, supply);
        }
    }

    /// @notice deposit curve lp token
    /// @dev should approve curve lp token to this address before calling this function
    /// @param _pid pid to deposit, uses same pid as convex booster
    /// @param _amount amount to withdraw
    function deposit(uint256 _pid, uint256 _amount)
        external
        whenNotPaused
        nonReentrant
    {
        _checkpoint(_pid, msg.sender);
        deposits[_pid][msg.sender].epoch = currentEpoch();
        deposits[_pid][msg.sender].amount += uint192(_amount);
        if (_amount > 0) {
            IERC20 lpToken = IERC20(
                IRewardStaking(convexPool[_pid]).poolInfo(_pid).lptoken
            );

            lpToken.safeTransferFrom(msg.sender, address(this), _amount);
            lpToken.safeApprove(convexBooster, _amount);
            IConvexDeposits(convexBooster).deposit(_pid, _amount, true);
            lpToken.safeApprove(convexBooster, 0);
            uint256 pid = masterChef.pid(address(lpToken));
            masterChef.deposit(msg.sender, pid, _amount);
        }

        emit Deposited(msg.sender, _amount);
    }

    /// @notice withdraw curve lp token
    /// @dev should request withdraw before calling this function
    /// @param _pid pid to withdraw, uses same pid as convex booster
    /// @param _amount amount to withdraw
    function withdraw(uint256 _pid, uint256 _amount) external nonReentrant {
        WithdrawRequest memory request = withdrawRequest[_pid][msg.sender];
        require(request.epoch < currentEpoch() && deposits[_pid][msg.sender].epoch + 1 < currentEpoch(), ""wait"");
        require(request.amount >= _amount, ""too much"");
        _checkpoint(_pid, msg.sender);
        deposits[_pid][msg.sender].amount -= uint192(_amount);
        if (_amount > 0) {
            IRewardStaking(convexPool[_pid]).withdrawAndUnwrap(_amount, false);
            IERC20 lpToken = IERC20(
                IRewardStaking(convexPool[_pid]).poolInfo(_pid).lptoken
            );
            lpToken.safeTransfer(msg.sender, _amount);
            uint256 pid = masterChef.pid(address(lpToken));
            masterChef.withdraw(msg.sender, pid, _amount);
        }
        delete withdrawRequest[_pid][msg.sender];
        //events
        emit Withdrawn(msg.sender, _amount);
    }

    /// @notice epoch for voting cycle
    /// @return returns the epoch in uint64 type
    function currentEpoch() public view returns(uint64) {
        return uint64((block.timestamp - VOTECYCLE_START) / 2 weeks) + 1;
    }

    /// @notice request withdraw to be eligible for withdrawal after currentEpoch
    /// @dev prior withdrawal request will be overwritten
    /// @param _pid pid to withdraw
    /// @param _amount amount to request withdrawal
    function requestWithdraw(uint256 _pid, uint256 _amount) external {
        require(_amount <= uint256(deposits[_pid][msg.sender].amount), ""too much"");
        withdrawRequest[_pid][msg.sender] = WithdrawRequest({
            epoch : currentEpoch(),
            amount : uint192(_amount)
        });
    }
}",2477
RealWorld_BA_83_EasySign_RealWord_20240825230939.log,83,EasySign,35112,5113,40225,77.0,0.27782,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.11;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""./interfaces/Iauction.sol"";

contract EasySign is Ownable, Iauction {
    enum RecoverError {
        NoError,
        InvalidSignature,
        InvalidSignatureLength,
        InvalidSignatureS,
        InvalidSignatureV
    }

    function _throwError(RecoverError error) private pure {
        if (error == RecoverError.NoError) {
            return; // no error: do nothing
        } else if (error == RecoverError.InvalidSignature) {
            revert(""ECDSA: invalid signature"");
        } else if (error == RecoverError.InvalidSignatureLength) {
            revert(""ECDSA: invalid signature length"");
        } else if (error == RecoverError.InvalidSignatureS) {
            revert(""ECDSA: invalid signature 's' value"");
        } else if (error == RecoverError.InvalidSignatureV) {
            revert(""ECDSA: invalid signature 'v' value"");
        }
    }

    /**
     * @dev Returns the address that signed a hashed message (`hash`) with
     * `signature` or error string. This address can then be used for verification purposes.
     *
     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:
     * this function rejects them by requiring the `s` value to be in the lower
     * half order, and the `v` value to be either 27 or 28.
     *
     * IMPORTANT: `hash` _must_ be the result of a hash operation for the
     * verification to be secure: it is possible to craft signatures that
     * recover to arbitrary addresses for non-hashed data. A safe way to ensure
     * this is by receiving a hash of the original message (which may otherwise
     * be too long), and then calling {toEthSignedMessageHash} on it.
     *
     * Documentation for signature generation:
     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]
     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]
     *
     * _Available since v4.3._
     */
    function tryRecover(bytes32 hash, bytes memory signature)
        internal
        pure
        returns (address, RecoverError)
    {
        // Check the signature length
        // - case 65: r,s,v signature (standard)
        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._
        if (signature.length == 65) {
            bytes32 r;
            bytes32 s;
            uint8 v;
            // ecrecover takes the signature parameters, and the only way to get them
            // currently is to use assembly.
            assembly {
                r := mload(add(signature, 0x20))
                s := mload(add(signature, 0x40))
                v := byte(0, mload(add(signature, 0x60)))
            }
            return tryRecover(hash, v, r, s);
        } else if (signature.length == 64) {
            bytes32 r;
            bytes32 vs;
            // ecrecover takes the signature parameters, and the only way to get them
            // currently is to use assembly.
            assembly {
                r := mload(add(signature, 0x20))
                vs := mload(add(signature, 0x40))
            }
            return tryRecover(hash, r, vs);
        } else {
            return (address(0), RecoverError.InvalidSignatureLength);
        }
    }

    /**
     * @dev Returns the address that signed a hashed message (`hash`) with
     * `signature`. This address can then be used for verification purposes.
     *
     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:
     * this function rejects them by requiring the `s` value to be in the lower
     * half order, and the `v` value to be either 27 or 28.
     *
     * IMPORTANT: `hash` _must_ be the result of a hash operation for the
     * verification to be secure: it is possible to craft signatures that
     * recover to arbitrary addresses for non-hashed data. A safe way to ensure
     * this is by receiving a hash of the original message (which may otherwise
     * be too long), and then calling {toEthSignedMessageHash} on it.
     */
    function recover(bytes32 hash, bytes memory signature)
        internal
        pure
        returns (address)
    {
        (address recovered, RecoverError error) = tryRecover(hash, signature);
        _throwError(error);
        return recovered;
    }

    /**
     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.
     *
     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]
     *
     * _Available since v4.3._
     */
    function tryRecover(
        bytes32 hash,
        bytes32 r,
        bytes32 vs
    ) internal pure returns (address, RecoverError) {
        bytes32 s;
        uint8 v;
        assembly {
            s := and(
                vs,
                0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
            )
            v := add(shr(255, vs), 27)
        }
        return tryRecover(hash, v, r, s);
    }

    /**
     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.
     *
     * _Available since v4.2._
     */
    function recover(
        bytes32 hash,
        bytes32 r,
        bytes32 vs
    ) internal pure returns (address) {
        (address recovered, RecoverError error) = tryRecover(hash, r, vs);
        _throwError(error);
        return recovered;
    }

    /**
     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,
     * `r` and `s` signature fields separately.
     *
     * _Available since v4.3._
     */
    function tryRecover(
        bytes32 hash,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) internal pure returns (address, RecoverError) {
        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature
        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines
        // the valid range for s in (301): 0 < s < secp256k1n  2 + 1, and for v in (302): v  {27, 28}. Most
        // signatures from current libraries generate a unique signature with an s-value in the lower half order.
        //
        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value
        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or
        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept
        // these malleable signatures as well.
        if (
            uint256(s) >
            0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0
        ) {
            return (address(0), RecoverError.InvalidSignatureS);
        }
        if (v != 27 && v != 28) {
            return (address(0), RecoverError.InvalidSignatureV);
        }

        // If the signature is valid (and not malleable), return the signer address
        address signer = ecrecover(hash, v, r, s);
        if (signer == address(0)) {
            return (address(0), RecoverError.InvalidSignature);
        }

        return (signer, RecoverError.NoError);
    }

    /**
     * @dev Overload of {ECDSA-recover} that receives the `v`,
     * `r` and `s` signature fields separately.
     */
    function recover(
        bytes32 hash,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) internal pure returns (address) {
        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);
        _throwError(error);
        return recovered;
    }

    mapping(address => bool) public approvedTeam;

    constructor() {
        approvedTeam[msg.sender] = true;
    }

    function modifyTeam(address _member, bool _approval) external onlyOwner {
        approvedTeam[_member] = _approval;
    }

    function isWinningSignature(bytes32 _hash, bytes memory _signature)
        external
        view
        override
        returns (bool)
    {
        address signer = recover(_hash, _signature);
        return approvedTeam[signer];
    }
}",2001
RealWorld_BA_83_CurveInterfaces_RealWord_20240825231856.log,83,CurveInterfaces,4826,5130,9956,73.0,0.12673,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.11;

import { IERC20 } from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

interface ICurveMetaPool is IERC20{
    function add_liquidity(uint256[2] calldata _amounts, uint256 _min_mint_amount) external;
    function remove_liquidity(uint256 _burning_amount, uint256[2] calldata _min_amounts) external;
}",104
RealWorld_BA_83_ConvexInterfaces_RealWord_20240825232011.log,83,ConvexInterfaces,8364,5744,14108,70.0,0.1567,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.11;

interface ICvx {
    function reductionPerCliff() external view returns(uint256);
    function totalSupply() external view returns(uint256);
    function totalCliffs() external view returns(uint256);
    function maxSupply() external view returns(uint256);
}

interface IRewardStaking {
    struct PoolInfo {
        address lptoken;
        address token;
        address gauge;
        address crvRewards;
        address stash;
        bool shutdown;
    }

    function poolInfo(uint256) external view returns(PoolInfo memory);
    function stakeFor(address, uint256) external;
    function stake( uint256) external;
    function withdraw(uint256 amount, bool claim) external;
    function withdrawAndUnwrap(uint256 amount, bool claim) external;
    function earned(address account) external view returns (uint256);
    function getReward() external;
    function getReward(address _account, bool _claimExtras) external;
    function extraRewardsLength() external view returns (uint256);
    function extraRewards(uint256 _pid) external view returns (address);
    function rewardToken() external view returns (address);
    function balanceOf(address _account) external view returns (uint256);
}

interface IConvexDeposits {
    function deposit(uint256 _pid, uint256 _amount, bool _stake) external returns(bool);
    function deposit(uint256 _amount, bool _lock, address _stakeAddress) external;
}",315
RealWorld_BA_83_Shelter_RealWord_20240825230714.log,83,Shelter,11360,5269,16629,63.0,0.16218,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.11;

import { IERC20 } from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import { SafeERC20 } from ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import { IShelter } from ""./interfaces/IShelter.sol"";
import { IShelterClient } from ""./interfaces/IShelterClient.sol"";

contract Shelter is IShelter {
    using SafeERC20 for IERC20;

    IShelterClient public immutable client;

    uint256 public constant GRACE_PERIOD = 1 weeks;

    mapping(IERC20 => mapping(address => bool)) public override claimed;

    mapping(IERC20 => uint256) public activated;

    mapping(IERC20 => uint256) public savedTokens;

    modifier onlyClient {
        require(msg.sender == address(client), ""!client"");
        _;
    }

    constructor(IShelterClient _client){
        client = _client;
    }

    function donate(IERC20 _token, uint256 _amount) external {
        require(activated[_token] != 0, ""!activated"");
        savedTokens[_token] += _amount;
        _token.safeTransferFrom(msg.sender, address(this), _amount);
    }

    function activate(IERC20 _token) external override onlyClient {
        activated[_token] = block.timestamp;
        savedTokens[_token] = _token.balanceOf(address(this));
        emit ShelterActivated(_token);
    }

    function deactivate(IERC20 _token) external override onlyClient {
        require(activated[_token] != 0 && activated[_token] + GRACE_PERIOD > block.timestamp, ""too late"");
        activated[_token] = 0;
        savedTokens[_token] = 0;
        _token.safeTransfer(msg.sender, _token.balanceOf(address(this)));
        emit ShelterDeactivated(_token);
    }

    function withdraw(IERC20 _token, address _to) external override {
        require(activated[_token] != 0 && activated[_token] + GRACE_PERIOD < block.timestamp, ""shelter not activated"");
        uint256 amount = savedTokens[_token] * client.shareOf(_token, msg.sender) / client.totalShare(_token);
        claimed[_token][_to] = true;
        emit ExitShelter(_token, msg.sender, _to, amount);
        _token.safeTransfer(_to, amount);
    }
}",511
RealWorld_BA_83_IShelter_RealWord_20240825232227.log,83,IShelter,5546,4473,10019,67.0,0.11719,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.11;

import { IERC20 } from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

interface IShelter {

    event ShelterActivated(IERC20 indexed token);
    event ShelterDeactivated(IERC20 indexed token);
    event ExitShelter(IERC20 indexed token, address indexed refugee, address indexed destination, uint256 amount);

    function claimed(IERC20 _token, address _user) external view returns(bool);
    function activate(IERC20 _token) external;
    function deactivate(IERC20 _token) external;
    function withdraw(IERC20 _token, address _to) external;
}",144
RealWorld_BA_83_StakingRewards_RealWord_20240825231058.log,83,StakingRewards,27190,5783,32973,79.0,0.25161,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.11;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/security/Pausable.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""./MasterChef.sol"";

contract StakingRewards is Ownable, ReentrancyGuard, Pausable {
    using SafeERC20 for IERC20;

    MasterChef public immutable masterChef;

    /* ========== STATE VARIABLES ========== */

    IERC20 public rewardsToken;
    IERC20 public stakingToken;
    uint256 public periodFinish = 0;
    uint256 public rewardRate = 0;
    uint256 public rewardsDuration = 7 days;
    uint256 public lastUpdateTime;
    uint256 public rewardPerTokenStored;

    mapping(address => uint256) public userRewardPerTokenPaid;
    mapping(address => uint256) public rewards;

    uint256 private _totalSupply;
    mapping(address => uint256) private _balances;

    address public rewardsDistribution;

    /* ========== CONSTRUCTOR ========== */

    constructor(
        address _rewardsDistribution,
        address _rewardsToken,
        address _stakingToken,
        MasterChef _masterChef
    ) {
        rewardsToken = IERC20(_rewardsToken);
        stakingToken = IERC20(_stakingToken);
        rewardsDistribution = _rewardsDistribution;
        masterChef = _masterChef;
    }

    /* ========== VIEWS ========== */

    function totalSupply() external view returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address account) external view returns (uint256) {
        return _balances[account];
    }

    function lastTimeRewardApplicable() public view returns (uint256) {
        return block.timestamp < periodFinish ? block.timestamp : periodFinish;
    }

    function rewardPerToken() public view returns (uint256) {
        if (_totalSupply == 0) {
            return rewardPerTokenStored;
        }
        return
            rewardPerTokenStored +
            (((lastTimeRewardApplicable() - lastUpdateTime) *
                rewardRate *
                1e18) / _totalSupply);
    }

    function earned(address account) public view returns (uint256) {
        return
            (_balances[account] *
                (rewardPerToken() - userRewardPerTokenPaid[account])) /
            1e18 +
            rewards[account];
    }

    function getRewardForDuration() external view returns (uint256) {
        return rewardRate * rewardsDuration;
    }

    /* ========== MUTATIVE FUNCTIONS ========== */

    function stake(uint256 amount)
        external
        nonReentrant
        whenNotPaused
        updateReward(msg.sender)
    {
        require(amount > 0, ""Cannot stake 0"");
        _totalSupply += amount;
        _balances[msg.sender] += amount;
        stakingToken.safeTransferFrom(msg.sender, address(this), amount);
        uint256 pid = masterChef.pid(address(stakingToken));
        masterChef.deposit(msg.sender, pid, amount);
        emit Staked(msg.sender, amount);
    }

    function withdraw(uint256 amount)
        public
        nonReentrant
        updateReward(msg.sender)
    {
        require(amount > 0, ""Cannot withdraw 0"");
        _totalSupply -= amount;
        _balances[msg.sender] -= amount;
        stakingToken.safeTransfer(msg.sender, amount);
        uint256 pid = masterChef.pid(address(stakingToken));
        masterChef.withdraw(msg.sender, pid, amount);
        emit Withdrawn(msg.sender, amount);
    }

    function getReward() public nonReentrant updateReward(msg.sender) {
        uint256 reward = rewards[msg.sender];
        if (reward > 0) {
            rewards[msg.sender] = 0;
            rewardsToken.safeTransfer(msg.sender, reward);
            emit RewardPaid(msg.sender, reward);
        }
    }

    function exit() external {
        withdraw(_balances[msg.sender]);
        getReward();
    }

    /* ========== RESTRICTED FUNCTIONS ========== */

    function notifyRewardAmount(uint256 reward)
        external
        updateReward(address(0))
    {
        require(
            msg.sender == rewardsDistribution,
            ""Caller is not RewardsDistribution contract""
        );

        if (block.timestamp >= periodFinish) {
            rewardRate = reward / rewardsDuration;
        } else {
            uint256 remaining = periodFinish - block.timestamp;
            uint256 leftover = remaining * rewardRate;
            rewardRate = (reward + leftover) / rewardsDuration;
        }

        // Ensure the provided reward amount is not more than the balance in the contract.
        // This keeps the reward rate in the right range, preventing overflows due to
        // very high values of rewardRate in the earned and rewardsPerToken functions;
        // Reward + leftover must be less than 2^256 / 10^18 to avoid overflow.
        uint256 balance = rewardsToken.balanceOf(address(this));
        require(
            rewardRate <= balance / rewardsDuration,
            ""Provided reward too high""
        );

        lastUpdateTime = block.timestamp;
        periodFinish = block.timestamp + rewardsDuration;
        emit RewardAdded(reward);
    }

    // Added to support recovering LP Rewards from other systems such as BAL to be distributed to holders
    function recoverERC20(address tokenAddress, uint256 tokenAmount)
        external
        onlyOwner
    {
        require(
            tokenAddress != address(stakingToken),
            ""Cannot withdraw the staking token""
        );
        IERC20(tokenAddress).safeTransfer(owner(), tokenAmount);
        emit Recovered(tokenAddress, tokenAmount);
    }

    function setRewardsDuration(uint256 _rewardsDuration) external onlyOwner {
        require(
            block.timestamp > periodFinish,
            ""Previous rewards period must be complete before changing the duration for the new period""
        );
        rewardsDuration = _rewardsDuration;
        emit RewardsDurationUpdated(rewardsDuration);
    }

    function setRewardsDistribution(address _rewardsDistribution)
        external
        onlyOwner
    {
        require(
            block.timestamp > periodFinish,
            ""Previous rewards period must be complete before changing the duration for the new period""
        );
        rewardsDistribution = _rewardsDistribution;
        emit RewardsDistributionUpdated(rewardsDistribution);
    }

    /* ========== MODIFIERS ========== */

    modifier updateReward(address account) {
        rewardPerTokenStored = rewardPerToken();
        lastUpdateTime = lastTimeRewardApplicable();
        if (account != address(0)) {
            rewards[account] = earned(account);
            userRewardPerTokenPaid[account] = rewardPerTokenStored;
        }
        _;
    }

    /* ========== EVENTS ========== */

    event RewardAdded(uint256 reward);
    event Staked(address indexed user, uint256 amount);
    event Withdrawn(address indexed user, uint256 amount);
    event RewardPaid(address indexed user, uint256 reward);
    event RewardsDurationUpdated(uint256 newDuration);
    event RewardsDistributionUpdated(address indexed newDistribution);
    event Recovered(address token, uint256 amount);
}",1501
RealWorld_BA_83_CvxMining_RealWord_20240825231735.log,83,CvxMining,7434,4928,12362,79.0,0.13573,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.11;

import ""../external/ConvexInterfaces.sol"";

library CvxMining{
    ICvx public constant cvx = ICvx(0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B);

    function ConvertCrvToCvx(uint256 _amount) external view returns(uint256){
        uint256 supply = cvx.totalSupply();
        uint256 reductionPerCliff = cvx.reductionPerCliff();
        uint256 totalCliffs = cvx.totalCliffs();
        uint256 maxSupply = cvx.maxSupply();

        uint256 cliff = supply / reductionPerCliff;
        //mint if below total cliffs
        if(cliff < totalCliffs){
            //for reduction% take inverse of current cliff
            uint256 reduction = totalCliffs - cliff;
            //reduce
            _amount = _amount * reduction / totalCliffs;

            //supply cap check
            uint256 amtTillMax = maxSupply - supply;
            if(_amount > amtTillMax){
                _amount = amtTillMax;
            }

            //mint
            return _amount;
        }
        return 0;
    }
}",268
RealWorld_BA_90_IIndexRegistry_RealWord_20240826121901.log,90,IIndexRegistry,9659,4862,14521,61.0,0.145535,"// SPDX-License-Identifier: GPL-2.0-or-later

pragma solidity >=0.8.7;

import ""./IIndexFactory.sol"";

/// @title Index registry interface
/// @notice Contains core components, addresses and asset market capitalizations
interface IIndexRegistry {
    /// @notice Index logic address
    /// @return Returns index logic address
    function indexLogic() external returns (address);

    /// @notice Registers new index
    /// @param _index Index address
    /// @param _nameDetails Name details (name and symbol) for provided index
    function registerIndex(address _index, IIndexFactory.NameDetails calldata _nameDetails) external;

    /// @notice Maximum assets for an index
    /// @return Returns maximum assets for an index
    function maxComponents() external view returns (uint);

    /// @notice Returns total market capitalization of the given assets
    /// @param _assets Assets array to calculate market capitalization of
    /// @return _marketCaps Corresponding capitalizations of the given asset
    /// @return _totalMarketCap Total market capitalization of the given assets
    function marketCapsOf(address[] calldata _assets)
        external
        view
        returns (uint[] memory _marketCaps, uint _totalMarketCap);

    /// @notice Total market capitalization of all registered assets
    /// @return Returns total market capitalization of all registered assets
    function totalMarketCap() external view returns (uint);

    /// @notice Price oracle address
    /// @return Returns price oracle address
    function priceOracle() external view returns (address);

    /// @notice Orderer address
    /// @return Returns orderer address
    function orderer() external view returns (address);

    /// @notice Fee pool address
    /// @return Returns fee pool address
    function feePool() external view returns (address);
}",391
RealWorld_BA_90_ITopNMarketCapIndexFactory_RealWord_20240826121110.log,90,ITopNMarketCapIndexFactory,4668,4475,9143,75.0,0.11284,"// SPDX-License-Identifier: GPL-2.0-or-later

pragma solidity >=0.8.7;

import ""./IIndexFactory.sol"";

/// @title Top N market capitalization index factory interface
/// @notice Contains logic for top N market capitalization index creation
interface ITopNMarketCapIndexFactory is IIndexFactory {
    /// @notice Market cap categories address
    /// @return Returns market cap categories address
    function marketCapCategories() external view returns (address);
}",101
RealWorld_BA_90_TrackedIndex_RealWord_20240826104225.log,90,TrackedIndex,13579,5296,18875,70.0,0.173815,"// SPDX-License-Identifier: BUSL-1.1

pragma solidity >=0.8.7;

import ""./interfaces/IIndexFactory.sol"";
import ""./interfaces/IReweightableIndex.sol"";
import ""./interfaces/ITrackedIndexReweightingLogic.sol"";

import ""./BaseIndex.sol"";

/// @title Tracked index
/// @notice  Contains initialization and reweighting logic
contract TrackedIndex is IReweightableIndex, BaseIndex {
    using EnumerableSet for EnumerableSet.AddressSet;

    /// @notice Orderer role
    bytes32 internal constant ORDERER_ROLE = keccak256(""ORDERER_ROLE"");

    constructor() BaseIndex(msg.sender) {}

    /// @notice Initializes index with provided set of parameters
    /// @param _assets Assets list
    /// @param _capitalizations List of corresponding assets capitalizations
    /// @param _totalCapitalization Total capitalization of assets
    function initialize(
        address[] calldata _assets,
        uint[] calldata _capitalizations,
        uint _totalCapitalization
    ) external {
        require(msg.sender == factory, ""TrackedIndex: FORBIDDEN"");

        uint8 totalWeight;
        uint maxCapitalization = _capitalizations[0];
        address maxCapitalizationAsset = _assets[0];
        for (uint i; i < _assets.length; ++i) {
            address asset = _assets[i];
            uint8 weight = uint8((_capitalizations[i] * type(uint8).max) / _totalCapitalization);
            if (_capitalizations[i] > maxCapitalization) {
                emit UpdateAnatomy(maxCapitalizationAsset, weightOf[maxCapitalizationAsset]);
                maxCapitalization = _capitalizations[i];
                maxCapitalizationAsset = asset;
            }
            weightOf[asset] = weight;
            totalWeight += weight;
            assets.add(asset);
            if (asset != maxCapitalizationAsset) {
                emit UpdateAnatomy(asset, weight);
            }
        }
        if (totalWeight < IndexLibrary.MAX_WEIGHT) {
            weightOf[maxCapitalizationAsset] += IndexLibrary.MAX_WEIGHT - totalWeight;
        }
        emit UpdateAnatomy(maxCapitalizationAsset, weightOf[maxCapitalizationAsset]);
    }

    /// @notice Reweighs index assets according to the latest market cap data
    function reweight() external override onlyRole(ORDERER_ROLE) {
        (bool success, bytes memory data) = IIndexFactory(factory).reweightingLogic().delegatecall(
            abi.encodeWithSelector(ITrackedIndexReweightingLogic.reweight.selector)
        );
        if (!success) {
            if (data.length == 0) {
                revert(""TrackedIndex: REWEIGH_FAILED"");
            } else {
                assembly {
                    revert(add(32, data), mload(data))
                }
            }
        }
    }

    /// @inheritdoc ERC165
    function supportsInterface(bytes4 _interfaceId) public view virtual override returns (bool) {
        return _interfaceId == type(IReweightableIndex).interfaceId || super.supportsInterface(_interfaceId);
    }
}",640
RealWorld_BA_90_IndexLayout_RealWord_20240826113232.log,90,IndexLayout,6507,5663,12170,72.0,0.145795,"// SPDX-License-Identifier: BUSL-1.1

pragma solidity >=0.8.7;

import ""@openzeppelin/contracts/utils/structs/EnumerableSet.sol"";

import ""./interfaces/IIndexLayout.sol"";

/// @title Index layout
/// @notice Contains storage layout of index
abstract contract IndexLayout is IIndexLayout {
    /// @inheritdoc IIndexLayout
    address public override factory;
    /// @inheritdoc IIndexLayout
    address public override vTokenFactory;
    /// @inheritdoc IIndexLayout
    address public override registry;

    /// @notice Timestamp of last AUM fee charge
    uint internal lastTransferTime;

    /// @notice Set with asset addresses
    EnumerableSet.AddressSet internal assets;
    /// @notice Set with previously used asset addresses
    EnumerableSet.AddressSet internal inactiveAssets;
    /// @notice Map of assets and their corresponding weights in index
    mapping(address => uint8) internal weightOf;
}",195
RealWorld_BA_90_IIndexFactory_RealWord_20240826111043.log,90,IIndexFactory,5802,4603,10405,61.0,0.12107,"// SPDX-License-Identifier: GPL-2.0-or-later

pragma solidity >=0.8.7;

/// @title Index factory interface
/// @notice Contains logic for initial fee management for indexes which will be created by this factory
interface IIndexFactory {
    struct NameDetails {
        string name;
        string symbol;
    }

    /// @notice Index registry address
    /// @return Returns index registry address
    function registry() external view returns (address);

    /// @notice vTokenFactory address
    /// @return Returns vTokenFactory address
    function vTokenFactory() external view returns (address);

    /// @notice Reweighting logic address
    /// @return Returns reweighting logic address
    function reweightingLogic() external view returns (address);
}",162
RealWorld_BA_90_TopNMarketCapIndex_RealWord_20240826114726.log,90,TopNMarketCapIndex,15552,5930,21482,71.0,0.19636,"// SPDX-License-Identifier: BUSL-1.1

pragma solidity >=0.8.7;

import ""./interfaces/IIndexFactory.sol"";
import ""./interfaces/IReweightableIndex.sol"";
import ""./interfaces/ITopNMarketCapIndexReweightingLogic.sol"";

import ""./BaseIndex.sol"";

/// @title Top N market capitalization index
/// @notice Contains initialization and reweighting logic
/// @dev This index reweighs according to the latest data from the TopNMarketCapCategories contract
contract TopNMarketCapIndex is IReweightableIndex, BaseIndex {
    using EnumerableSet for EnumerableSet.AddressSet;

    /// @notice Orderer role
    bytes32 internal constant ORDERER_ROLE = keccak256(""ORDERER_ROLE"");

    /// @notice Number of assets used in the index
    uint8 public topN;
    /// @notice Category identifier used for the given index
    uint public category;

    /// @notice Latest category snapshot to track diff
    uint private snapshot;

    constructor() BaseIndex(msg.sender) {}

    /// @notice Initializes index with provided set of parameters
    /// @param _topN Number of assets used in the index
    /// @param _category Category identifier used for the given index
    /// @param _snapshot Initial snapshot from the category
    /// @param _assets Assets list
    /// @param _capitalizations List of corresponding assets capitalizations
    /// @param _totalCapitalization Total capitalization of assets
    function initialize(
        uint8 _topN,
        uint _category,
        uint _snapshot,
        address[] calldata _assets,
        uint[] calldata _capitalizations,
        uint _totalCapitalization
    ) external {
        require(msg.sender == factory, ""TopNMarketCapIndex: FORBIDDEN"");

        uint8 _totalWeight;
        for (uint i; i < _assets.length; ++i) {
            uint _i = _assets.length - 1 - i;
            address asset = _assets[_i];
            uint8 weight = _i == 0
                ? IndexLibrary.MAX_WEIGHT - _totalWeight
                : uint8((_capitalizations[_i] * type(uint8).max) / _totalCapitalization);
            weightOf[asset] = weight;
            require(asset != address(0), ""TopNMarketCapIndex: ZERO"");
            if (weight > 0) {
                assets.add(asset);
                _totalWeight += weight;
                emit UpdateAnatomy(asset, weight);
            }
        }
        snapshot = _snapshot;
        category = _category;
        topN = _topN;
    }

    /// @notice Reweighs index assets according to the latest market cap data for specified category
    function reweight() external override onlyRole(ORDERER_ROLE) {
        (bool success, bytes memory data) = IIndexFactory(factory).reweightingLogic().delegatecall(
            abi.encodeWithSelector(ITopNMarketCapIndexReweightingLogic.reweight.selector, category, snapshot, topN)
        );
        if (!success) {
            if (data.length == 0) {
                revert(""TopNMarketCapIndex: REWEIGH_FAILED"");
            } else {
                assembly {
                    revert(add(32, data), mload(data))
                }
            }
        }
        snapshot = abi.decode(data, (uint));
    }

    /// @inheritdoc ERC165
    function supportsInterface(bytes4 _interfaceId) public view virtual override returns (bool) {
        return _interfaceId == type(IReweightableIndex).interfaceId || super.supportsInterface(_interfaceId);
    }
}",754
RealWorld_BA_90_IReweightableIndex_RealWord_20240826120915.log,90,IReweightableIndex,4082,3741,7823,55.0,0.09523,"// SPDX-License-Identifier: Apache-2.0

pragma solidity >=0.8.7;

/// @title Rewightable index interface
/// @notice Contains reweighting logic
interface IReweightableIndex {
    /// @notice Call index reweight process
    function reweight() external;
}",63
RealWorld_BA_90_BP_RealWord_20240826110010.log,90,BP,4307,3099,7406,42.0,0.083515,"// SPDX-License-Identifier: GPL-2.0-or-later

pragma solidity >=0.8.7;

/// @title Base point library
/// @notice Contains constant used to prevent underflow of math operations
library BP {
    /// @notice Base point number
    /// @dev Used to prevent underflow of math operations
    uint16 constant DECIMAL_FACTOR = 10_000;
}",82
RealWorld_BA_90_IManagedIndexReweightingLogic_RealWord_20240826115805.log,90,IManagedIndexReweightingLogic,5271,4266,9537,61.0,0.111675,"// SPDX-License-Identifier: GPL-2.0-or-later

pragma solidity >=0.8.7;

import ""./IAnatomyUpdater.sol"";

/// @title ManagedIndex reweighing logic interface
/// @notice Contains reweighing logic
interface IManagedIndexReweightingLogic is IAnatomyUpdater {
    /// @notice Updates index anatomy with corresponding weights and assets
    /// @param _assets List for new asset(s) for the index
    /// @param _weights List of new asset(s) corresponding weights
    function reweight(address[] calldata _assets, uint8[] calldata _weights) external;
}",131
RealWorld_BA_90_INameRegistry_RealWord_20240826110632.log,90,INameRegistry,5295,4774,10069,63.0,0.121955,"// SPDX-License-Identifier: GPL-2.0-or-later

pragma solidity >=0.8.7;

/// @title Name registry interface
/// @notice Providing information about index names and symbols
interface INameRegistry {
    /// @notice Returns name of the given index
    /// @param _index Index address
    /// @return Index name
    function nameOfIndex(address _index) external view returns (string memory);

    /// @notice Returns symbol of the given index
    /// @param _index Index address
    /// @return Index symbol
    function symbolOfIndex(address _index) external view returns (string memory);
}",133
RealWorld_BA_90_IIndexRegistry_RealWord_20240826112728.log,90,IIndexRegistry,9375,4950,14325,68.0,0.145875,"// SPDX-License-Identifier: GPL-2.0-or-later

pragma solidity >=0.8.7;

import ""./IIndexFactory.sol"";

/// @title Index registry interface
/// @notice Contains core components, addresses and asset market capitalizations
interface IIndexRegistry {
    /// @notice Index logic address
    /// @return Returns index logic address
    function indexLogic() external returns (address);

    /// @notice Registers new index
    /// @param _index Index address
    /// @param _nameDetails Name details (name and symbol) for provided index
    function registerIndex(address _index, IIndexFactory.NameDetails calldata _nameDetails) external;

    /// @notice Maximum assets for an index
    /// @return Returns maximum assets for an index
    function maxComponents() external view returns (uint);

    /// @notice Returns total market capitalization of the given assets
    /// @param _assets Assets array to calculate market capitalization of
    /// @return _marketCaps Corresponding capitalizations of the given asset
    /// @return _totalMarketCap Total market capitalization of the given assets
    function marketCapsOf(address[] calldata _assets)
        external
        view
        returns (uint[] memory _marketCaps, uint _totalMarketCap);

    /// @notice Total market capitalization of all registered assets
    /// @return Returns total market capitalization of all registered assets
    function totalMarketCap() external view returns (uint);

    /// @notice Price oracle address
    /// @return Returns price oracle address
    function priceOracle() external view returns (address);

    /// @notice Orderer address
    /// @return Returns orderer address
    function orderer() external view returns (address);

    /// @notice Fee pool address
    /// @return Returns fee pool address
    function feePool() external view returns (address);
}",391
RealWorld_BA_90_IOrderer_RealWord_20240826111958.log,90,IOrderer,8919,5310,14229,70.0,0.150795,"// SPDX-License-Identifier: GPL-2.0-or-later

pragma solidity >=0.8.7;

import ""./IvToken.sol"";
import ""./IPhuturePriceOracle.sol"";

/// @title Orderer interface
/// @notice Describes methods for reweigh execution, order creation and execution
interface IOrderer {
    enum OrderSide {
        Sell,
        Buy
    }

    /// @notice Places order to orderer queue and returns order id
    /// @return Order id of the placed order
    function placeOrder() external returns (uint);

    /// @notice Fulfills specified order with order details
    /// @param _orderId Order id to fulfill
    /// @param _asset Asset address to be exchanged
    /// @param _shares Amount of asset to be exchanged
    /// @param _side Order side: buy or sell
    function addOrderDetails(
        uint _orderId,
        address _asset,
        uint _shares,
        OrderSide _side
    ) external;

    /// @notice Updates asset amount for the latest order placed by the sender
    /// @param _asset Asset to change amount for
    /// @param _newTotalSupply New amount value
    /// @param _oldTotalSupply Old amount value
    function reduceOrderAsset(
        address _asset,
        uint _newTotalSupply,
        uint _oldTotalSupply
    ) external;

    /// @notice Returns last order id of the given account
    /// @param _account Account to get last order for
    /// @return Last order id of the given account
    function lastOrderIdOf(address _account) external view returns (uint);
}",344
RealWorld_BA_90_IAnatomyUpdater_RealWord_20240826112344.log,90,IAnatomyUpdater,4037,3673,7710,69.0,0.093645,"// SPDX-License-Identifier: GPL-2.0-or-later

pragma solidity >=0.8.7;

/// @title Anatomy Updater interface
/// @notice Contains event for aatomy update
interface IAnatomyUpdater {
    event UpdateAnatomy(address asset, uint8 weight);
}",60
RealWorld_BA_90_TrackedIndexReweightingLogic_RealWord_20240826113508.log,90,TrackedIndexReweightingLogic,17502,5852,23354,70.0,0.20455,"// SPDX-License-Identifier: BUSL-1.1

pragma solidity >=0.8.7;

import ""@openzeppelin/contracts/access/IAccessControl.sol"";
import ""@openzeppelin/contracts/utils/introspection/ERC165.sol"";

import ""./libraries/IndexLibrary.sol"";

import ""./interfaces/IvToken.sol"";
import ""./interfaces/IOrderer.sol"";
import ""./interfaces/IvTokenFactory.sol"";
import ""./interfaces/IIndexRegistry.sol"";
import ""./interfaces/ITrackedIndexReweightingLogic.sol"";

import ""./IndexLayout.sol"";

/// @title TrackedIndex reweighing logic
/// @notice  Contains reweighing logic
contract TrackedIndexReweightingLogic is IndexLayout, ITrackedIndexReweightingLogic, ERC165 {
    using FullMath for uint;
    using EnumerableSet for EnumerableSet.AddressSet;

    /// @notice Asset role
    bytes32 internal constant ASSET_ROLE = keccak256(""ASSET_ROLE"");

    /// @inheritdoc ITrackedIndexReweightingLogic
    function reweight() external override {
        IPhuturePriceOracle oracle = IPhuturePriceOracle(IIndexRegistry(registry).priceOracle());
        (uint[] memory _capitalizations, uint _totalCapitalization) = IIndexRegistry(registry).marketCapsOf(
            assets.values()
        );
        uint virtualEvaluationInBase;
        uint8 totalWeight;
        uint maxCapitalization = _capitalizations[0];
        address maxCapitalizationAsset = assets.at(0);
        for (uint i; i < assets.length(); ++i) {
            require(IAccessControl(registry).hasRole(ASSET_ROLE, assets.at(i)), ""TrackedIndex: INVALID_ASSET"");

            uint priceAssetPerBaseInUQ = oracle.refreshedAssetPerBaseInUQ(assets.at(i));
            uint availableAssets = IvToken(IvTokenFactory(vTokenFactory).createOrReturnVTokenOf(assets.at(i)))
                .assetBalanceOf(address(this));
            virtualEvaluationInBase += availableAssets.mulDiv(FixedPoint112.Q112, priceAssetPerBaseInUQ);
            address asset = assets.at(i);
            uint8 weight = uint8((_capitalizations[i] * type(uint8).max) / _totalCapitalization);
            if (_capitalizations[i] > maxCapitalization) {
                emit UpdateAnatomy(maxCapitalizationAsset, weightOf[maxCapitalizationAsset]);
                maxCapitalization = _capitalizations[i];
                maxCapitalizationAsset = asset;
            }
            weightOf[asset] = weight;
            totalWeight += weight;
            if (asset != maxCapitalizationAsset) {
                emit UpdateAnatomy(asset, weight);
            }
        }

        if (totalWeight < IndexLibrary.MAX_WEIGHT) {
            weightOf[maxCapitalizationAsset] += IndexLibrary.MAX_WEIGHT - totalWeight;
        }
        emit UpdateAnatomy(maxCapitalizationAsset, weightOf[maxCapitalizationAsset]);

        IOrderer orderer = IOrderer(IIndexRegistry(registry).orderer());
        uint orderId = orderer.placeOrder();

        for (uint i; i < assets.length(); ++i) {
            address asset = assets.at(i);
            uint amountInBase = (virtualEvaluationInBase * weightOf[asset]) / IndexLibrary.MAX_WEIGHT;
            uint amountInAsset = amountInBase.mulDiv(oracle.refreshedAssetPerBaseInUQ(asset), FixedPoint112.Q112);
            (uint newShares, uint oldShares) = IvToken(IvTokenFactory(vTokenFactory).vTokenOf(asset)).shareChange(
                address(this),
                amountInAsset
            );
            if (newShares > oldShares) {
                orderer.addOrderDetails(orderId, asset, newShares - oldShares, IOrderer.OrderSide.Buy);
            } else if (oldShares > newShares) {
                orderer.addOrderDetails(orderId, asset, oldShares - newShares, IOrderer.OrderSide.Sell);
            }
        }
    }

    /// @inheritdoc ERC165
    function supportsInterface(bytes4 _interfaceId) public view virtual override returns (bool) {
        return _interfaceId == type(ITrackedIndexReweightingLogic).interfaceId || super.supportsInterface(_interfaceId);
    }
}",883
RealWorld_BA_90_TopNMarketCapReweightingLogic_RealWord_20240826114350.log,90,TopNMarketCapReweightingLogic,21226,5905,27131,80.0,0.22423,"// SPDX-License-Identifier: BUSL-1.1

pragma solidity >=0.8.7;

import ""@openzeppelin/contracts/access/IAccessControl.sol"";
import ""@openzeppelin/contracts/utils/introspection/ERC165.sol"";

import ""./libraries/IndexLibrary.sol"";

import ""./interfaces/IvToken.sol"";
import ""./interfaces/IOrderer.sol"";
import ""./interfaces/IvTokenFactory.sol"";
import ""./interfaces/IIndexRegistry.sol"";
import ""./interfaces/ITopNMarketCapCategories.sol"";
import ""./interfaces/ITopNMarketCapIndexFactory.sol"";
import ""./interfaces/ITopNMarketCapIndexReweightingLogic.sol"";

import ""./IndexLayout.sol"";

/// @title TopNMarketCapIndex reweighing logic
/// @notice Contains reweighting logic
contract TopNMarketCapIndexReweightingLogic is IndexLayout, ITopNMarketCapIndexReweightingLogic, ERC165 {
    using FullMath for uint;
    using EnumerableSet for EnumerableSet.AddressSet;

    /// @notice Asset role
    bytes32 internal constant ASSET_ROLE = keccak256(""ASSET_ROLE"");

    /// @inheritdoc ITopNMarketCapIndexReweightingLogic
    function reweight(
        uint _category,
        uint _snapshotId,
        uint _topN
    ) external override returns (uint) {
        IPhuturePriceOracle oracle = IPhuturePriceOracle(IIndexRegistry(registry).priceOracle());
        uint virtualEvaluationInBase;
        for (uint i; i < assets.length(); ++i) {
            uint priceAssetPerBaseInUQ = oracle.refreshedAssetPerBaseInUQ(assets.at(i));
            uint availableAssets = IvToken(IvTokenFactory(vTokenFactory).createOrReturnVTokenOf(assets.at(i)))
                .assetBalanceOf(address(this));
            virtualEvaluationInBase += availableAssets.mulDiv(FixedPoint112.Q112, priceAssetPerBaseInUQ);
        }
        ITopNMarketCapCategories.DiffDetails memory diff = ITopNMarketCapCategories(
            ITopNMarketCapIndexFactory(factory).marketCapCategories()
        ).assetDiff(_category, _snapshotId, _topN);

        IOrderer orderer = IOrderer(IIndexRegistry(registry).orderer());
        uint orderId = orderer.placeOrder();

        uint8 _totalWeight;
        for (uint _i; _i < diff.assetCount; ++_i) {
            uint i = diff.assetCount - 1 - _i;
            address asset = diff.assets[i].asset;
            IvToken vToken = IvToken(IvTokenFactory(vTokenFactory).createOrReturnVTokenOf(asset));
            if (diff.assets[i].isRemoved) {
                {
                    uint shares = vToken.balanceOf(address(this));
                    if (shares > 0) {
                        inactiveAssets.add(asset);
                    }
                    delete weightOf[asset];
                    assets.remove(asset);
                    emit UpdateAnatomy(asset, 0);
                }
            } else {
                // diff guarantees that updated assets go before the removed assets
                require(IAccessControl(registry).hasRole(ASSET_ROLE, asset), ""TopNMarketCapIndex: INVALID_ASSET"");
                {
                    uint8 weight;
                    if (i == 0) {
                        weight = IndexLibrary.MAX_WEIGHT - _totalWeight;
                    } else {
                        weight = uint8(
                            (diff.assets[i].capitalizationInBase * type(uint8).max) / diff.totalCapitalizationInBase
                        );
                    }
                    weightOf[asset] = weight;
                    _totalWeight += weight;
                    if (weight > 0) {
                        assets.add(asset);
                        inactiveAssets.remove(asset);
                    } else {
                        assets.remove(asset);
                        inactiveAssets.add(asset);
                    }
                    emit UpdateAnatomy(asset, weight);
                }
                {
                    uint amountInBase = (virtualEvaluationInBase * weightOf[asset]) / IndexLibrary.MAX_WEIGHT;
                    uint amountInAsset = amountInBase.mulDiv(
                        oracle.refreshedAssetPerBaseInUQ(asset),
                        FixedPoint112.Q112
                    );
                    (uint newShares, uint oldShares) = vToken.shareChange(address(this), amountInAsset);
                    if (newShares > oldShares) {
                        orderer.addOrderDetails(orderId, asset, newShares - oldShares, IOrderer.OrderSide.Buy);
                    } else if (oldShares > newShares) {
                        orderer.addOrderDetails(orderId, asset, oldShares - newShares, IOrderer.OrderSide.Sell);
                    }
                }
            }
        }
        address[] memory _inactiveAssets = inactiveAssets.values();
        for (uint i; i < _inactiveAssets.length; ++i) {
            uint shares = IvToken(IvTokenFactory(vTokenFactory).vTokenOf(_inactiveAssets[i])).balanceOf(address(this));
            if (shares > 0) {
                orderer.addOrderDetails(orderId, _inactiveAssets[i], shares, IOrderer.OrderSide.Sell);
            } else {
                inactiveAssets.remove(_inactiveAssets[i]);
            }
        }
        return diff.snapshotId;
    }

    /// @inheritdoc ERC165
    function supportsInterface(bytes4 _interfaceId) public view virtual override returns (bool) {
        return
            _interfaceId == type(ITopNMarketCapIndexReweightingLogic).interfaceId ||
            super.supportsInterface(_interfaceId);
    }
}",1131
RealWorld_BA_90_IWETH_RealWord_20240826112933.log,90,IWETH,3961,3955,7916,70.0,0.098905,"// SPDX-License-Identifier: GPL-2.0-or-later

pragma solidity >=0.8.7;

interface IWETH {
    function deposit() external payable;

    function transfer(address to, uint value) external returns (bool);

    function withdraw(uint) external;
}",56
RealWorld_BA_90_IvToken_RealWord_20240826110304.log,90,IvToken,19652,5269,24921,74.0,0.20364,"// SPDX-License-Identifier: GPL-2.0-or-later

pragma solidity >=0.8.7;

/// @title Vault token interface
/// @notice Contains logic for index's asset management
interface IvToken {
    struct AssetData {
        uint maxShares;
        uint amountInAsset;
    }

    event VTokenTransfer(address indexed from, address indexed to, uint amount);

    /// @notice Initializes vToken with the given parameters
    /// @param _asset Asset that will be stored
    /// @param _registry Index registry address
    function initialize(address _asset, address _registry) external;

    /// @notice Transfers shares between given accounts
    /// @param _from Account to transfer shares from
    /// @param _to Account to transfer shares to
    /// @param _shares Amount of shares to transfer
    function transferFrom(
        address _from,
        address _to,
        uint _shares
    ) external;

    /// @notice Transfers asset to the given recipient
    /// @dev Method is restricted to orderer
    /// @param _recipient Recipient address
    /// @param _amount Amount to transfer
    function transferAsset(address _recipient, uint _amount) external;

    /// @notice Mints shares for the current sender
    /// @return shares Amount of minted shares
    function mint() external returns (uint shares);

    /// @notice Burns shares for the given recipient and returns assets to the given recipient
    /// @param _recipient Recipient to send assets to
    /// @return amount Amount of sent assets
    function burn(address _recipient) external returns (uint amount);

    /// @notice Transfers shares from the sender to the given recipient
    /// @param _recipient Account to transfer shares to
    /// @param _amount Amount of shares to transfer
    function transfer(address _recipient, uint _amount) external;

    /// @notice Manually synchronizes shares balances
    function sync() external;

    /// @notice Mints shares for the given recipient
    /// @param _recipient Recipient to mint shares for
    /// @return Returns minted shares amount
    function mintFor(address _recipient) external returns (uint);

    /// @notice Burns shares and sends assets to the given recipient
    /// @param _recipient Recipient to send assets to
    /// @return Returns amount of sent assets
    function burnFor(address _recipient) external returns (uint);

    /// @notice Total supply amount: current balance + deposited using vault controller
    /// @return Returns total supply amount
    function totalAssetSupply() external view returns (uint);

    /// @notice Returns mintable amount of shares for given asset's amount
    /// @param _amount Amount of assets to mint shares for
    /// @return Returns amount of shares available for minting
    function mintableShares(uint _amount) external view returns (uint);

    /// @notice Returns amount of assets for the given account with the given shares amount
    /// @return Amount of assets for the given account with the given shares amount
    function assetDataOf(address _account, uint _shares) external view returns (AssetData memory);

    /// @notice Asset balance of the given address
    /// @param _account Address to check balance of
    /// @return Returns asset balance of the given address
    function assetBalanceOf(address _account) external view returns (uint);

    /// @notice Last asset balance for the given address
    /// @param _account Address to check balance of
    /// @return Returns last asset balance for the given address
    function lastAssetBalanceOf(address _account) external view returns (uint);

    /// @notice Last shares balance
    /// @return Returns last shares balance
    function lastBalance() external view returns (uint);

    /// @notice Total shares supply
    /// @return Returns total shares supply
    function totalSupply() external view returns (uint);

    /// @notice Shares balance of the given address
    /// @param _account Address to check balance of
    /// @return Returns shares balance of the given address
    function balanceOf(address _account) external view returns (uint);

    /// @notice Returns the change in shares for a given amount of an asset
    /// @param _account Account to calculate shares for
    /// @param _amountInAsset Amount of asset to calculate shares
    /// @return newShares New shares value
    /// @return oldShares Old shares value
    function shareChange(address _account, uint _amountInAsset) external view returns (uint newShares, uint oldShares);

    /// @notice Stored asset address
    /// @return Returns stored asset address
    function asset() external view returns (address);

    /// @notice Index registry address
    /// @return Returns index registry address
    function registry() external view returns (address);
}",1012
RealWorld_BA_90_UniswapV2PriceOracle_RealWord_20240826114622.log,90,UniswapV2PriceOracle,18189,5402,23591,61.0,0.198985,"// SPDX-License-Identifier: GPL-2.0-or-later

pragma solidity >=0.8.7;

import ""@openzeppelin/contracts/utils/introspection/ERC165.sol"";
import ""@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol"";
import ""@uniswap/v2-periphery/contracts/libraries/UniswapV2OracleLibrary.sol"";

import ""./interfaces/IUniswapV2PriceOracle.sol"";

/// @title Uniswap V2 price oracle
/// @notice Contains logic for price calculation of asset using Uniswap V2 Pair
/// @dev Oracle works through base asset which is set in initialize function
contract UniswapV2PriceOracle is IUniswapV2PriceOracle, ERC165 {
    using UniswapV2OracleLibrary for address;

    /// @notice Minimum oracle update interval
    /// @dev If min update interval hasn't passed (24h) before update, previously cached value is returned
    uint private constant MIN_UPDATE_INTERVAL = 24 hours;

    IUniswapV2Pair immutable pair;
    /// @inheritdoc IUniswapV2PriceOracle
    address public immutable override asset0;
    /// @inheritdoc IUniswapV2PriceOracle
    address public immutable override asset1;

    uint private price0CumulativeLast;
    uint private price1CumulativeLast;
    uint32 private blockTimestampLast;
    uint private price0Average;
    uint private price1Average;

    constructor(
        address _factory,
        address _assetA,
        address _assetB
    ) {
        IUniswapV2Pair _pair = IUniswapV2Pair(IUniswapV2Factory(_factory).getPair(_assetA, _assetB));
        pair = _pair;
        asset0 = _pair.token0();
        asset1 = _pair.token1();

        uint112 reserve0;
        uint112 reserve1;
        (reserve0, reserve1, blockTimestampLast) = _pair.getReserves();
        require(reserve0 != 0 && reserve1 != 0, ""UniswapV2PriceOracle: RESERVES"");

        uint _price0CumulativeLast = _pair.price0CumulativeLast();
        uint _price1CumulativeLast = _pair.price1CumulativeLast();
        (uint price0Cml, uint price1Cml, uint32 blockTimestamp) = address(_pair).currentCumulativePrices();
        uint32 timeElapsed = blockTimestamp - blockTimestampLast;
        price0CumulativeLast = _price0CumulativeLast;
        price1CumulativeLast = _price1CumulativeLast;
        price0Average = (price0Cml - _price0CumulativeLast) / timeElapsed;
        price1Average = (price1Cml - _price1CumulativeLast) / timeElapsed;
    }

    /// @inheritdoc IPriceOracle
    /// @dev Updates and returns cumulative price value
    /// @dev If min update interval hasn't passed (24h), previously cached value is returned
    function refreshedAssetPerBaseInUQ(address _asset) external override returns (uint) {
        (uint price0Cumulative, uint price1Cumulative, uint32 blockTimestamp) = address(pair).currentCumulativePrices();
        uint32 timeElapsed = blockTimestamp - blockTimestampLast;

        if (timeElapsed >= MIN_UPDATE_INTERVAL) {
            price0Average = (price0Cumulative - price0CumulativeLast) / timeElapsed;
            price1Average = (price1Cumulative - price1CumulativeLast) / timeElapsed;

            price0CumulativeLast = price0Cumulative;
            price1CumulativeLast = price1Cumulative;
            blockTimestampLast = blockTimestamp;
        }

        return lastAssetPerBaseInUQ(_asset);
    }

    /// @inheritdoc IPriceOracle
    /// @dev Returns cumulative price value cached during last refresh call
    function lastAssetPerBaseInUQ(address _asset) public view override returns (uint) {
        if (_asset == asset0) {
            return price1Average;
        } else {
            require(_asset == asset1, ""UniswapV2PriceOracle: UNKNOWN"");
            return price0Average;
        }
    }

    /// @inheritdoc ERC165
    function supportsInterface(bytes4 _interfaceId) public view virtual override returns (bool) {
        return
            _interfaceId == type(IUniswapV2PriceOracle).interfaceId ||
            _interfaceId == type(IPriceOracle).interfaceId ||
            super.supportsInterface(_interfaceId);
    }
}",969
RealWorld_BA_90_IvTokenFactory_RealWord_20240826120309.log,90,IvTokenFactory,5500,4836,10336,56.0,0.12422,"// SPDX-License-Identifier: GPL-2.0-or-later

pragma solidity >=0.8.7;

/// @title vToken factory interface
/// @notice Contains vToken creation logic
interface IvTokenFactory {
    /// @notice Creates or returns address of previously created vToken for the given asset
    /// @param _asset Asset to create or return vToken for
    function createOrReturnVTokenOf(address _asset) external returns (address);

    /// @notice Returns vToken for the given asset
    /// @param _asset Asset to retrieve vToken for
    /// @return vToken for the given asset
    function vTokenOf(address _asset) external view returns (address);
}",147
RealWorld_BA_90_ManagedIndex_RealWord_20240826114244.log,90,ManagedIndex,11795,5197,16992,64.0,0.162915,"// SPDX-License-Identifier: BUSL-1.1

pragma solidity >=0.8.7;

import ""./interfaces/IManagedIndex.sol"";
import ""./interfaces/IIndexFactory.sol"";
import ""./interfaces/IManagedIndexReweightingLogic.sol"";

import ""./BaseIndex.sol"";

/// @title Managed index
/// @notice Contains initialization and reweighting logic
contract ManagedIndex is IManagedIndex, BaseIndex {
    using EnumerableSet for EnumerableSet.AddressSet;

    /// @notice Role for index reweighting
    bytes32 private REWEIGHT_INDEX_ROLE;

    constructor() BaseIndex(msg.sender) {
        REWEIGHT_INDEX_ROLE = keccak256(abi.encodePacked(""REWEIGHT_PERMISSION"", address(this)));
    }

    /// @notice Index initialization with assets and their weights
    /// @dev Method is called by factory
    /// @param _assets Assets list for the index
    /// @param _weights List of assets corresponding weights
    function initialize(address[] calldata _assets, uint8[] calldata _weights) external {
        require(msg.sender == factory, ""ManagedIndex: FORBIDDEN"");

        for (uint i; i < _assets.length; ++i) {
            address asset = _assets[i];
            uint8 weight = _weights[i];

            weightOf[asset] = weight;
            assets.add(asset);

            emit UpdateAnatomy(asset, weight);
        }
    }

    /// @inheritdoc IManagedIndex
    /// @dev Assets total weight should be equal to 255
    function reweight(address[] calldata _updatedAssets, uint8[] calldata _updatedWeights) external override {
        require(
            IAccessControl(registry).hasRole(INDEX_MANAGER_ROLE, msg.sender) ||
                IAccessControl(registry).hasRole(REWEIGHT_INDEX_ROLE, msg.sender),
            ""ManagedIndex: FORBIDDEN""
        );
        (bool success, bytes memory data) = IIndexFactory(factory).reweightingLogic().delegatecall(
            abi.encodeWithSelector(IManagedIndexReweightingLogic.reweight.selector, _updatedAssets, _updatedWeights)
        );
        if (!success) {
            if (data.length == 0) {
                revert(""ManagedIndex: REWEIGH_FAILED"");
            } else {
                assembly {
                    revert(add(32, data), mload(data))
                }
            }
        }
    }

    /// @inheritdoc ERC165
    function supportsInterface(bytes4 _interfaceId) public view virtual override returns (bool) {
        return _interfaceId == type(IManagedIndex).interfaceId || super.supportsInterface(_interfaceId);
    }
}",540
RealWorld_BA_90_IPhuturePriceOracle_RealWord_20240826120500.log,90,IPhuturePriceOracle,8361,4862,13223,60.0,0.139045,"// SPDX-License-Identifier: GPL-2.0-or-later

pragma solidity >=0.8.7;

import ""./IPriceOracle.sol"";

/// @title Phuture price oracle interface
/// @notice Aggregates all price oracles and works with them through IPriceOracle interface
interface IPhuturePriceOracle is IPriceOracle {
    /// @notice Assigns given oracle to specified asset. Then oracle will be used to manage asset price
    /// @param _asset Asset to register
    /// @param _oracle Oracle to assign
    function setOracleOf(address _asset, address _oracle) external;

    /// @notice Removes oracle of specified asset
    /// @param _asset Asset to remove oracle from
    function removeOracleOf(address _asset) external;

    /// @notice Converts to index amount
    /// @param _baseAmount Amount in base
    /// @param _indexDecimals Index's decimals
    /// @return Asset per base in UQ with index decimals
    function convertToIndex(uint _baseAmount, uint8 _indexDecimals) external view returns (uint);

    /// @notice Checks if the given asset has oracle assigned
    /// @param _asset Asset to check
    /// @return Returns boolean flag defining if the given asset has oracle assigned
    function containsOracleOf(address _asset) external view returns (bool);

    /// @notice Price oracle assigned to the given `_asset`
    /// @param _asset Asset to obtain price oracle for
    /// @return Returns price oracle assigned to the `_asset`
    function priceOracleOf(address _asset) external view returns (address);
}",338
RealWorld_BA_90_ManagedIndexReweightingLogic_RealWord_20240826114839.log,90,ManagedIndexReweightingLogic,20056,5267,25323,72.0,0.20562,"// SPDX-License-Identifier: BUSL-1.1

pragma solidity >=0.8.7;

import ""@openzeppelin/contracts/access/IAccessControl.sol"";
import ""@openzeppelin/contracts/utils/introspection/ERC165.sol"";

import ""./libraries/IndexLibrary.sol"";

import ""./interfaces/IvToken.sol"";
import ""./interfaces/IOrderer.sol"";
import ""./interfaces/IvTokenFactory.sol"";
import ""./interfaces/IIndexRegistry.sol"";
import ""./interfaces/IManagedIndexReweightingLogic.sol"";

import ""./IndexLayout.sol"";

/// @title ManagedIndex reweighting logic
/// @notice Contains reweighting logic
contract ManagedIndexReweightingLogic is IndexLayout, IManagedIndexReweightingLogic, ERC165 {
    using FullMath for uint;
    using EnumerableSet for EnumerableSet.AddressSet;

    /// @notice Asset role
    bytes32 internal constant ASSET_ROLE = keccak256(""ASSET_ROLE"");

    /// @inheritdoc IManagedIndexReweightingLogic
    function reweight(address[] calldata _updatedAssets, uint8[] calldata _updatedWeights) external override {
        require(
            _updatedAssets.length > 1 &&
                _updatedWeights.length == _updatedAssets.length &&
                _updatedAssets.length <= IIndexRegistry(registry).maxComponents(),
            ""ManagedIndex: INVALID""
        );

        uint virtualEvaluationInBase;
        IPhuturePriceOracle oracle = IPhuturePriceOracle(IIndexRegistry(registry).priceOracle());
        for (uint i; i < assets.length(); ++i) {
            uint priceAssetPerBaseInUQ = oracle.refreshedAssetPerBaseInUQ(assets.at(i));
            uint availableAssets = IvToken(IvTokenFactory(vTokenFactory).createOrReturnVTokenOf(assets.at(i)))
                .assetBalanceOf(address(this));
            virtualEvaluationInBase += availableAssets.mulDiv(FixedPoint112.Q112, priceAssetPerBaseInUQ);
        }

        IOrderer orderer = IOrderer(IIndexRegistry(registry).orderer());
        uint orderId = orderer.placeOrder();

        uint _totalWeight = IndexLibrary.MAX_WEIGHT;

        for (uint i; i < _updatedAssets.length; ++i) {
            address asset = _updatedAssets[i];
            require(asset != address(0), ""ManagedIndex: ZERO"");

            uint8 newWeight = _updatedWeights[i];

            if (i > 0) {
                // makes sure that there are no duplicate assets
                require(_updatedAssets[i - 1] < asset, ""ManagedIndex: SORT"");
            }

            if (newWeight > 0) {
                require(IAccessControl(registry).hasRole(ASSET_ROLE, asset), ""ManagedIndex: INVALID_ASSET"");
                assets.add(asset);
                inactiveAssets.remove(asset);

                uint8 prevWeight = weightOf[asset];
                if (prevWeight != newWeight) {
                    emit UpdateAnatomy(asset, newWeight);
                }

                _totalWeight = _totalWeight + newWeight - prevWeight;
                weightOf[asset] = newWeight;

                uint amountInBase = (virtualEvaluationInBase * weightOf[asset]) / IndexLibrary.MAX_WEIGHT;
                uint amountInAsset = amountInBase.mulDiv(oracle.refreshedAssetPerBaseInUQ(asset), FixedPoint112.Q112);
                (uint newShares, uint oldShares) = IvToken(IvTokenFactory(vTokenFactory).createOrReturnVTokenOf(asset))
                    .shareChange(address(this), amountInAsset);

                if (newShares > oldShares) {
                    orderer.addOrderDetails(orderId, asset, newShares - oldShares, IOrderer.OrderSide.Buy);
                } else if (oldShares > newShares) {
                    orderer.addOrderDetails(orderId, asset, oldShares - newShares, IOrderer.OrderSide.Sell);
                }
            } else {
                require(assets.remove(asset), ""ManagedIndex: INVALID"");
                inactiveAssets.add(asset);

                _totalWeight -= weightOf[asset];

                delete weightOf[asset];

                emit UpdateAnatomy(asset, 0);
            }
        }
        address[] memory _inactiveAssets = inactiveAssets.values();
        for (uint i; i < _inactiveAssets.length; ++i) {
            uint shares = IvToken(IvTokenFactory(vTokenFactory).vTokenOf(_inactiveAssets[i])).balanceOf(address(this));
            if (shares > 0) {
                orderer.addOrderDetails(orderId, _inactiveAssets[i], shares, IOrderer.OrderSide.Sell);
            } else {
                inactiveAssets.remove(_inactiveAssets[i]);
            }
        }
        require(_totalWeight == IndexLibrary.MAX_WEIGHT, ""ManagedIndex: MAX"");
    }

    /// @inheritdoc ERC165
    function supportsInterface(bytes4 _interfaceId) public view virtual override returns (bool) {
        return _interfaceId == type(IManagedIndexReweightingLogic).interfaceId || super.supportsInterface(_interfaceId);
    }
}",1039
RealWorld_BA_90_AUMCalculationLibrary_RealWord_20240826115451.log,90,AUMCalculationLibrary,11603,4930,16533,60.0,0.156615,"// SPDX-License-Identifier: GPL-2.0-or-later

pragma solidity >=0.8.7;

/// @title AUM fee calculation library
/// @notice More details https://github.com/enzymefinance/protocol/blob/b671b3dfea92596dd2e962c73b233dcdb22bf753/contracts/release/utils/MakerDaoMath.sol
/// @dev Taken from https://github.com/enzymefinance/protocol
library AUMCalculationLibrary {
    /// @dev A constant used for AUM fee calculation to prevent underflow
    uint constant RATE_SCALE_BASE = 1e27;

    /// @notice Power function for AUM fee calculation
    /// @param _x Base number
    /// @param _n Exponent number
    /// @param _base Base number multiplier
    /// @return z_ Returns value of `_x` raised to power of `_n`
    function rpow(
        uint _x,
        uint _n,
        uint _base
    ) internal pure returns (uint z_) {
        assembly {
            switch _x
            case 0 {
                switch _n
                case 0 {
                    z_ := _base
                }
                default {
                    z_ := 0
                }
            }
            default {
                switch mod(_n, 2)
                case 0 {
                    z_ := _base
                }
                default {
                    z_ := _x
                }
                let half := div(_base, 2)
                for {
                    _n := div(_n, 2)
                } _n {
                    _n := div(_n, 2)
                } {
                    let xx := mul(_x, _x)
                    if iszero(eq(div(xx, _x), _x)) {
                        revert(0, 0)
                    }
                    let xxRound := add(xx, half)
                    if lt(xxRound, xx) {
                        revert(0, 0)
                    }
                    _x := div(xxRound, _base)
                    if mod(_n, 2) {
                        let zx := mul(z_, _x)
                        if and(iszero(iszero(_x)), iszero(eq(div(zx, _x), z_))) {
                            revert(0, 0)
                        }
                        let zxRound := add(zx, half)
                        if lt(zxRound, zx) {
                            revert(0, 0)
                        }
                        z_ := div(zxRound, _base)
                    }
                }
            }
        }

        return z_;
    }
}",537
RealWorld_BA_90_IChainlinkPriceOracle_RealWord_20240826120602.log,90,IChainlinkPriceOracle,4658,3926,8584,54.0,0.10181,"// SPDX-License-Identifier: GPL-2.0-or-later

pragma solidity >=0.8.7;

import ""./IPriceOracle.sol"";

/// @title Chainlink price oracle interface
/// @notice Extends IPriceOracle interface
interface IChainlinkPriceOracle is IPriceOracle {
    /// @notice Adds `_asset` to the oracle
    /// @param _asset Asset's address
    /// @param _asset Asset aggregator's address
    function addAsset(address _asset, address _assetAggregator) external;
}",110
RealWorld_BA_90_ITopNMarketCapCategories_RealWord_20240826121332.log,90,ITopNMarketCapCategories,7036,5414,12450,70.0,0.14346,"// SPDX-License-Identifier: GPL-2.0-or-later

pragma solidity >=0.8.7;

/// @title Top N market capitalization categories interface
/// @notice Interface describing logic for top market capitalization categories management
interface ITopNMarketCapCategories {
    struct DiffDetails {
        uint snapshotId;
        uint totalCapitalizationInBase;
        uint assetCount;
        DiffAsset[] assets;
    }

    struct DiffAsset {
        address asset;
        bool isRemoved;
        uint capitalizationInBase;
    }

    /// @notice Compare asset changes (diff) between provided snapshots within given category
    /// @param _categoryId Category id to check
    /// @param _lastSnapshotId Snapshot id to compare with the latest snapshot
    /// @param _topN Assets amount to compare
    /// @return diff Assets diff object of type DiffDetails
    function assetDiff(
        uint _categoryId,
        uint _lastSnapshotId,
        uint _topN
    ) external view returns (DiffDetails memory diff);
}",215
RealWorld_BA_90_IManagedIndex_RealWord_20240826112455.log,90,IManagedIndex,5374,5117,10491,66.0,0.12921,"// SPDX-License-Identifier: GPL-2.0-or-later

pragma solidity >=0.8.7;

import ""./IIndex.sol"";

/// @title Managed index interface
/// @notice Interface for dynamic indexes that could be updated with new anatomy data
interface IManagedIndex is IIndex {
    /// @notice Updates index anatomy with corresponding weights and assets
    /// @param _assets List for new asset(s) for the index
    /// @param _weights List of new asset(s) corresponding weights
    function reweight(address[] calldata _assets, uint8[] calldata _weights) external;
}",126
RealWorld_BA_90_IReweightableIndex_RealWord_20240826111639.log,90,IReweightableIndex,4451,4927,9378,65.0,0.120795,"// SPDX-License-Identifier: Apache-2.0

pragma solidity >=0.8.7;

/// @title Rewightable index interface
/// @notice Contains reweighting logic
interface IReweightableIndex {
    /// @notice Call index reweight process
    function reweight() external;
}",63
RealWorld_BA_90_UniswapV2PathPriceOracle_RealWord_20240826105033.log,90,UniswapV2PathPriceOracle,14207,6047,20254,77.0,0.191975,"// SPDX-License-Identifier: GPL-2.0-or-later

pragma solidity >=0.8.7;

import ""@openzeppelin/contracts/utils/introspection/ERC165.sol"";

import ""./libraries/FullMath.sol"";
import ""./libraries/FixedPoint112.sol"";

import ""./interfaces/IUniswapV2PriceOracle.sol"";
import ""./interfaces/IUniswapV2PathPriceOracle.sol"";

/// @title Uniswap path price oracle
/// @notice Contains logic for price calculation of asset which doesn't have a pair with a base asset
contract UniswapV2PathPriceOracle is IUniswapV2PathPriceOracle, ERC165 {
    using FullMath for uint;

    /// @notice List of assets to compose exchange pairs, where first element is input asset
    address[] private path;
    /// @notice List of corresponding price oracles for provided path
    address[] private oracles;

    constructor(address[] memory _path, address[] memory _oracles) {
        require(_path.length >= 2, ""UniswapV2PathPriceOracle: PATH"");
        require(_oracles.length == _path.length - 1, ""UniswapV2PathPriceOracle: ORACLES"");

        path = _path;
        oracles = _oracles;
    }

    /// @inheritdoc IPriceOracle
    function refreshedAssetPerBaseInUQ(address _asset) external override returns (uint currentAssetPerBaseInUQ) {
        currentAssetPerBaseInUQ = FixedPoint112.Q112;
        for (uint i = 0; i < path.length - 1; i++) {
            address asset = path[i + 1];
            currentAssetPerBaseInUQ = currentAssetPerBaseInUQ.mulDiv(
                IUniswapV2PriceOracle(oracles[i]).refreshedAssetPerBaseInUQ(asset),
                FixedPoint112.Q112
            );
            if (_asset == asset) {
                break;
            }
        }
    }

    /// @inheritdoc IPriceOracle
    function lastAssetPerBaseInUQ(address _asset) external view override returns (uint currentAssetPerBaseInUQ) {
        currentAssetPerBaseInUQ = FixedPoint112.Q112;
        for (uint i = 0; i < path.length - 1; i++) {
            address asset = path[i + 1];
            currentAssetPerBaseInUQ = currentAssetPerBaseInUQ.mulDiv(
                IUniswapV2PriceOracle(oracles[i]).lastAssetPerBaseInUQ(asset),
                FixedPoint112.Q112
            );
            if (_asset == asset) {
                break;
            }
        }
    }

    /// @inheritdoc ERC165
    function supportsInterface(bytes4 _interfaceId) public view virtual override returns (bool) {
        return
            _interfaceId == type(IUniswapV2PathPriceOracle).interfaceId ||
            _interfaceId == type(IPriceOracle).interfaceId ||
            super.supportsInterface(_interfaceId);
    }

    /// @inheritdoc IUniswapV2PathPriceOracle
    function anatomy() public view virtual override returns (address[] memory _path, address[] memory _oracles) {
        _path = path;
        _oracles = oracles;
    }
}",694
RealWorld_BA_90_ManagedIndex_RealWord_20240826104754.log,90,ManagedIndex,12110,5567,17677,74.0,0.17189,"// SPDX-License-Identifier: BUSL-1.1

pragma solidity >=0.8.7;

import ""./interfaces/IManagedIndex.sol"";
import ""./interfaces/IIndexFactory.sol"";
import ""./interfaces/IManagedIndexReweightingLogic.sol"";

import ""./BaseIndex.sol"";

/// @title Managed index
/// @notice Contains initialization and reweighting logic
contract ManagedIndex is IManagedIndex, BaseIndex {
    using EnumerableSet for EnumerableSet.AddressSet;

    /// @notice Role for index reweighting
    bytes32 private REWEIGHT_INDEX_ROLE;

    constructor() BaseIndex(msg.sender) {
        REWEIGHT_INDEX_ROLE = keccak256(abi.encodePacked(""REWEIGHT_PERMISSION"", address(this)));
    }

    /// @notice Index initialization with assets and their weights
    /// @dev Method is called by factory
    /// @param _assets Assets list for the index
    /// @param _weights List of assets corresponding weights
    function initialize(address[] calldata _assets, uint8[] calldata _weights) external {
        require(msg.sender == factory, ""ManagedIndex: FORBIDDEN"");

        for (uint i; i < _assets.length; ++i) {
            address asset = _assets[i];
            uint8 weight = _weights[i];

            weightOf[asset] = weight;
            assets.add(asset);

            emit UpdateAnatomy(asset, weight);
        }
    }

    /// @inheritdoc IManagedIndex
    /// @dev Assets total weight should be equal to 255
    function reweight(address[] calldata _updatedAssets, uint8[] calldata _updatedWeights) external override {
        require(
            IAccessControl(registry).hasRole(INDEX_MANAGER_ROLE, msg.sender) ||
                IAccessControl(registry).hasRole(REWEIGHT_INDEX_ROLE, msg.sender),
            ""ManagedIndex: FORBIDDEN""
        );
        (bool success, bytes memory data) = IIndexFactory(factory).reweightingLogic().delegatecall(
            abi.encodeWithSelector(IManagedIndexReweightingLogic.reweight.selector, _updatedAssets, _updatedWeights)
        );
        if (!success) {
            if (data.length == 0) {
                revert(""ManagedIndex: REWEIGH_FAILED"");
            } else {
                assembly {
                    revert(add(32, data), mload(data))
                }
            }
        }
    }

    /// @inheritdoc ERC165
    function supportsInterface(bytes4 _interfaceId) public view virtual override returns (bool) {
        return _interfaceId == type(IManagedIndex).interfaceId || super.supportsInterface(_interfaceId);
    }
}",540
RealWorld_BA_90_TopNMarketCapReweightingLogic_RealWord_20240826104910.log,90,TopNMarketCapReweightingLogic,21485,5994,27479,80.0,0.227305,"// SPDX-License-Identifier: BUSL-1.1

pragma solidity >=0.8.7;

import ""@openzeppelin/contracts/access/IAccessControl.sol"";
import ""@openzeppelin/contracts/utils/introspection/ERC165.sol"";

import ""./libraries/IndexLibrary.sol"";

import ""./interfaces/IvToken.sol"";
import ""./interfaces/IOrderer.sol"";
import ""./interfaces/IvTokenFactory.sol"";
import ""./interfaces/IIndexRegistry.sol"";
import ""./interfaces/ITopNMarketCapCategories.sol"";
import ""./interfaces/ITopNMarketCapIndexFactory.sol"";
import ""./interfaces/ITopNMarketCapIndexReweightingLogic.sol"";

import ""./IndexLayout.sol"";

/// @title TopNMarketCapIndex reweighing logic
/// @notice Contains reweighting logic
contract TopNMarketCapIndexReweightingLogic is IndexLayout, ITopNMarketCapIndexReweightingLogic, ERC165 {
    using FullMath for uint;
    using EnumerableSet for EnumerableSet.AddressSet;

    /// @notice Asset role
    bytes32 internal constant ASSET_ROLE = keccak256(""ASSET_ROLE"");

    /// @inheritdoc ITopNMarketCapIndexReweightingLogic
    function reweight(
        uint _category,
        uint _snapshotId,
        uint _topN
    ) external override returns (uint) {
        IPhuturePriceOracle oracle = IPhuturePriceOracle(IIndexRegistry(registry).priceOracle());
        uint virtualEvaluationInBase;
        for (uint i; i < assets.length(); ++i) {
            uint priceAssetPerBaseInUQ = oracle.refreshedAssetPerBaseInUQ(assets.at(i));
            uint availableAssets = IvToken(IvTokenFactory(vTokenFactory).createOrReturnVTokenOf(assets.at(i)))
                .assetBalanceOf(address(this));
            virtualEvaluationInBase += availableAssets.mulDiv(FixedPoint112.Q112, priceAssetPerBaseInUQ);
        }
        ITopNMarketCapCategories.DiffDetails memory diff = ITopNMarketCapCategories(
            ITopNMarketCapIndexFactory(factory).marketCapCategories()
        ).assetDiff(_category, _snapshotId, _topN);

        IOrderer orderer = IOrderer(IIndexRegistry(registry).orderer());
        uint orderId = orderer.placeOrder();

        uint8 _totalWeight;
        for (uint _i; _i < diff.assetCount; ++_i) {
            uint i = diff.assetCount - 1 - _i;
            address asset = diff.assets[i].asset;
            IvToken vToken = IvToken(IvTokenFactory(vTokenFactory).createOrReturnVTokenOf(asset));
            if (diff.assets[i].isRemoved) {
                {
                    uint shares = vToken.balanceOf(address(this));
                    if (shares > 0) {
                        inactiveAssets.add(asset);
                    }
                    delete weightOf[asset];
                    assets.remove(asset);
                    emit UpdateAnatomy(asset, 0);
                }
            } else {
                // diff guarantees that updated assets go before the removed assets
                require(IAccessControl(registry).hasRole(ASSET_ROLE, asset), ""TopNMarketCapIndex: INVALID_ASSET"");
                {
                    uint8 weight;
                    if (i == 0) {
                        weight = IndexLibrary.MAX_WEIGHT - _totalWeight;
                    } else {
                        weight = uint8(
                            (diff.assets[i].capitalizationInBase * type(uint8).max) / diff.totalCapitalizationInBase
                        );
                    }
                    weightOf[asset] = weight;
                    _totalWeight += weight;
                    if (weight > 0) {
                        assets.add(asset);
                        inactiveAssets.remove(asset);
                    } else {
                        assets.remove(asset);
                        inactiveAssets.add(asset);
                    }
                    emit UpdateAnatomy(asset, weight);
                }
                {
                    uint amountInBase = (virtualEvaluationInBase * weightOf[asset]) / IndexLibrary.MAX_WEIGHT;
                    uint amountInAsset = amountInBase.mulDiv(
                        oracle.refreshedAssetPerBaseInUQ(asset),
                        FixedPoint112.Q112
                    );
                    (uint newShares, uint oldShares) = vToken.shareChange(address(this), amountInAsset);
                    if (newShares > oldShares) {
                        orderer.addOrderDetails(orderId, asset, newShares - oldShares, IOrderer.OrderSide.Buy);
                    } else if (oldShares > newShares) {
                        orderer.addOrderDetails(orderId, asset, oldShares - newShares, IOrderer.OrderSide.Sell);
                    }
                }
            }
        }
        address[] memory _inactiveAssets = inactiveAssets.values();
        for (uint i; i < _inactiveAssets.length; ++i) {
            uint shares = IvToken(IvTokenFactory(vTokenFactory).vTokenOf(_inactiveAssets[i])).balanceOf(address(this));
            if (shares > 0) {
                orderer.addOrderDetails(orderId, _inactiveAssets[i], shares, IOrderer.OrderSide.Sell);
            } else {
                inactiveAssets.remove(_inactiveAssets[i]);
            }
        }
        return diff.snapshotId;
    }

    /// @inheritdoc ERC165
    function supportsInterface(bytes4 _interfaceId) public view virtual override returns (bool) {
        return
            _interfaceId == type(ITopNMarketCapIndexReweightingLogic).interfaceId ||
            super.supportsInterface(_interfaceId);
    }
}",1131
RealWorld_BA_90_IUniswapV2PathPriceOracle_RealWord_20240826120658.log,90,IUniswapV2PathPriceOracle,5324,4105,9429,75.0,0.10872,"// SPDX-License-Identifier: GPL-2.0-or-later

pragma solidity >=0.8.7;

import ""./IPriceOracle.sol"";

/// @title Uniswap path price oracle interface
/// @notice Contains logic for price calculation of asset which doesn't have a pair with a base asset
interface IUniswapV2PathPriceOracle is IPriceOracle {
    /// @notice Returns anatomy data for the current oracle
    /// @return _path List of assets to compose exchange pairs
    /// @return _oracles List of corresponding price oracles for pairs provided by {_path}
    function anatomy() external view returns (address[] calldata _path, address[] calldata _oracles);
}",147
RealWorld_BA_90_IUniswapV2PriceOracle_RealWord_20240826121444.log,90,IUniswapV2PriceOracle,5744,5140,10884,64.0,0.13152,"// SPDX-License-Identifier: GPL-2.0-or-later

pragma solidity >=0.8.7;

import ""./IPriceOracle.sol"";

/// @title Uniswap price oracle interface
/// @notice Contains logic for price calculation of asset using Uniswap V2 Pair
interface IUniswapV2PriceOracle is IPriceOracle {
    /// @notice Asset0 in the pair
    /// @return Returns address of asset0 in the pair
    function asset0() external view returns (address);

    /// @notice Asset1 in the pair
    /// @return Returns address of asset1 in the pair
    function asset1() external view returns (address);
}",141
RealWorld_BA_90_ITopNMarketCapIndexReweightingLogic_RealWord_20240826115553.log,90,ITopNMarketCapIndexReweightingLogic,5659,4965,10624,65.0,0.127595,"// SPDX-License-Identifier: GPL-2.0-or-later

pragma solidity >=0.8.7;

import ""./IAnatomyUpdater.sol"";

/// @title TopNMarketCapIndex reweighitng logic interface
/// @notice Contains reweighitng logic
interface ITopNMarketCapIndexReweightingLogic is IAnatomyUpdater {
    /// @notice Call index reweight process
    /// @param _category Index category
    /// @param _snapshotId Snapshot identifier
    /// @param _topN Number of assets
    /// @return New snaphsot id
    function reweight(
        uint _category,
        uint _snapshotId,
        uint _topN
    ) external returns (uint);
}",154
RealWorld_BA_90_UniswapV2PathPriceOracle_RealWord_20240826114513.log,90,UniswapV2PathPriceOracle,14099,5419,19518,67.0,0.178875,"// SPDX-License-Identifier: GPL-2.0-or-later

pragma solidity >=0.8.7;

import ""@openzeppelin/contracts/utils/introspection/ERC165.sol"";

import ""./libraries/FullMath.sol"";
import ""./libraries/FixedPoint112.sol"";

import ""./interfaces/IUniswapV2PriceOracle.sol"";
import ""./interfaces/IUniswapV2PathPriceOracle.sol"";

/// @title Uniswap path price oracle
/// @notice Contains logic for price calculation of asset which doesn't have a pair with a base asset
contract UniswapV2PathPriceOracle is IUniswapV2PathPriceOracle, ERC165 {
    using FullMath for uint;

    /// @notice List of assets to compose exchange pairs, where first element is input asset
    address[] private path;
    /// @notice List of corresponding price oracles for provided path
    address[] private oracles;

    constructor(address[] memory _path, address[] memory _oracles) {
        require(_path.length >= 2, ""UniswapV2PathPriceOracle: PATH"");
        require(_oracles.length == _path.length - 1, ""UniswapV2PathPriceOracle: ORACLES"");

        path = _path;
        oracles = _oracles;
    }

    /// @inheritdoc IPriceOracle
    function refreshedAssetPerBaseInUQ(address _asset) external override returns (uint currentAssetPerBaseInUQ) {
        currentAssetPerBaseInUQ = FixedPoint112.Q112;
        for (uint i = 0; i < path.length - 1; i++) {
            address asset = path[i + 1];
            currentAssetPerBaseInUQ = currentAssetPerBaseInUQ.mulDiv(
                IUniswapV2PriceOracle(oracles[i]).refreshedAssetPerBaseInUQ(asset),
                FixedPoint112.Q112
            );
            if (_asset == asset) {
                break;
            }
        }
    }

    /// @inheritdoc IPriceOracle
    function lastAssetPerBaseInUQ(address _asset) external view override returns (uint currentAssetPerBaseInUQ) {
        currentAssetPerBaseInUQ = FixedPoint112.Q112;
        for (uint i = 0; i < path.length - 1; i++) {
            address asset = path[i + 1];
            currentAssetPerBaseInUQ = currentAssetPerBaseInUQ.mulDiv(
                IUniswapV2PriceOracle(oracles[i]).lastAssetPerBaseInUQ(asset),
                FixedPoint112.Q112
            );
            if (_asset == asset) {
                break;
            }
        }
    }

    /// @inheritdoc ERC165
    function supportsInterface(bytes4 _interfaceId) public view virtual override returns (bool) {
        return
            _interfaceId == type(IUniswapV2PathPriceOracle).interfaceId ||
            _interfaceId == type(IPriceOracle).interfaceId ||
            super.supportsInterface(_interfaceId);
    }

    /// @inheritdoc IUniswapV2PathPriceOracle
    function anatomy() public view virtual override returns (address[] memory _path, address[] memory _oracles) {
        _path = path;
        _oracles = oracles;
    }
}",694
RealWorld_BA_90_NAV_RealWord_20240826114953.log,90,NAV,18963,5351,24314,65.0,0.201835,"// SPDX-License-Identifier: BUSL-1.1

pragma solidity >=0.8.7;

/// @title NAV library
/// @notice Library for transfer, mint, burn and distribute vToken shares
/// @dev Used in conjunction with vToken
library NAV {
    /// @notice Initial shares quantity
    uint internal constant INITIAL_QUANTITY = 10000;

    struct Data {
        uint lastBalance;
        uint totalSupply;
        mapping(address => uint) balanceOf;
    }

    /// @notice Transfer `_amount` of shares between given addresses
    /// @param _from Account to send shares from
    /// @param _to Account to send shares to
    /// @param _amount Amount of shares to send
    function transfer(
        Data storage self,
        address _from,
        address _to,
        uint _amount
    ) internal {
        self.balanceOf[_from] -= _amount;
        self.balanceOf[_to] += _amount;
    }

    /// @notice Mints shares to the `_recipient` account
    /// @param self Data structure reference
    /// @param _balance New shares maximum limit
    /// @param _recipient Recipient that will receive minted shares
    function mint(
        Data storage self,
        uint _balance,
        address _recipient
    ) internal returns (uint shares) {
        uint amount = _balance - self.lastBalance;
        uint _totalSupply = self.totalSupply;
        if (_totalSupply != 0) {
            shares = (amount * _totalSupply) / self.lastBalance;
        } else {
            shares = amount - INITIAL_QUANTITY;
            _mint(self, address(0), INITIAL_QUANTITY);
        }
        require(shares > 0, ""NAV: INSUFFICIENT_AMOUNT"");
        _mint(self, _recipient, shares);
    }

    /// @notice Burns shares from the `_recipient` account
    /// @param self Data structure reference
    /// @param _balance Shares balance
    function burn(Data storage self, uint _balance) internal returns (uint amount) {
        uint value = self.balanceOf[address(this)];
        amount = (value * _balance) / self.totalSupply;
        require(amount > 0, ""NAV: INSUFFICIENT_SHARES_BURNED"");
        _burn(self, address(this), value);
    }

    /// @notice Synchronizes token balances
    /// @param self Data structure reference
    /// @param _newBalance Total asset amount
    function sync(Data storage self, uint _newBalance) internal {
        if (self.lastBalance != _newBalance) {
            self.lastBalance = _newBalance;
        }
    }

    /// @notice Returns amount of tokens corresponding to the given `_shares` amount
    /// @param self Data structure reference
    /// @param _shares Amount of shares
    /// @param _balance Shares balance
    /// @return Amount of tokens corresponding to given shares
    function assetBalanceForShares(
        Data storage self,
        uint _shares,
        uint _balance
    ) internal view returns (uint) {
        uint _totalSupply = self.totalSupply;
        if (_totalSupply != 0) {
            return (_shares * _balance) / _totalSupply;
        }

        return 0;
    }

    /// @notice Returns amount of shares that will be minted for the given tokens amount
    /// @param self Data structure reference
    /// @param _amount Tokens amount
    /// @return Amount of mintable shares
    function mintableShares(Data storage self, uint _amount) internal view returns (uint) {
        uint _totalSupply = self.totalSupply;
        if (_totalSupply != 0) {
            return (_amount * _totalSupply) / self.lastBalance;
        }

        return _amount - INITIAL_QUANTITY;
    }

    /// @notice Mints shares for the given account
    /// @param self Data structure reference
    /// @param _account Account to mint shares for
    /// @param _amount Amount shares to mint
    function _mint(
        Data storage self,
        address _account,
        uint _amount
    ) private {
        self.balanceOf[_account] += _amount;
        self.totalSupply += _amount;
    }

    /// @notice Burns shares of the given account
    /// @param self Data structure reference
    /// @param _account Account to burn shares of
    /// @param _amount Amount shares to burn
    function _burn(
        Data storage self,
        address _account,
        uint _amount
    ) private {
        self.balanceOf[_account] -= _amount;
        self.totalSupply -= _amount;
    }
}",978
RealWorld_BA_90_TopNMarketCapIndex_RealWord_20240826105301.log,90,TopNMarketCapIndex,15762,5007,20769,68.0,0.17895,"// SPDX-License-Identifier: BUSL-1.1

pragma solidity >=0.8.7;

import ""./interfaces/IIndexFactory.sol"";
import ""./interfaces/IReweightableIndex.sol"";
import ""./interfaces/ITopNMarketCapIndexReweightingLogic.sol"";

import ""./BaseIndex.sol"";

/// @title Top N market capitalization index
/// @notice Contains initialization and reweighting logic
/// @dev This index reweighs according to the latest data from the TopNMarketCapCategories contract
contract TopNMarketCapIndex is IReweightableIndex, BaseIndex {
    using EnumerableSet for EnumerableSet.AddressSet;

    /// @notice Orderer role
    bytes32 internal constant ORDERER_ROLE = keccak256(""ORDERER_ROLE"");

    /// @notice Number of assets used in the index
    uint8 public topN;
    /// @notice Category identifier used for the given index
    uint public category;

    /// @notice Latest category snapshot to track diff
    uint private snapshot;

    constructor() BaseIndex(msg.sender) {}

    /// @notice Initializes index with provided set of parameters
    /// @param _topN Number of assets used in the index
    /// @param _category Category identifier used for the given index
    /// @param _snapshot Initial snapshot from the category
    /// @param _assets Assets list
    /// @param _capitalizations List of corresponding assets capitalizations
    /// @param _totalCapitalization Total capitalization of assets
    function initialize(
        uint8 _topN,
        uint _category,
        uint _snapshot,
        address[] calldata _assets,
        uint[] calldata _capitalizations,
        uint _totalCapitalization
    ) external {
        require(msg.sender == factory, ""TopNMarketCapIndex: FORBIDDEN"");

        uint8 _totalWeight;
        for (uint i; i < _assets.length; ++i) {
            uint _i = _assets.length - 1 - i;
            address asset = _assets[_i];
            uint8 weight = _i == 0
                ? IndexLibrary.MAX_WEIGHT - _totalWeight
                : uint8((_capitalizations[_i] * type(uint8).max) / _totalCapitalization);
            weightOf[asset] = weight;
            require(asset != address(0), ""TopNMarketCapIndex: ZERO"");
            if (weight > 0) {
                assets.add(asset);
                _totalWeight += weight;
                emit UpdateAnatomy(asset, weight);
            }
        }
        snapshot = _snapshot;
        category = _category;
        topN = _topN;
    }

    /// @notice Reweighs index assets according to the latest market cap data for specified category
    function reweight() external override onlyRole(ORDERER_ROLE) {
        (bool success, bytes memory data) = IIndexFactory(factory).reweightingLogic().delegatecall(
            abi.encodeWithSelector(ITopNMarketCapIndexReweightingLogic.reweight.selector, category, snapshot, topN)
        );
        if (!success) {
            if (data.length == 0) {
                revert(""TopNMarketCapIndex: REWEIGH_FAILED"");
            } else {
                assembly {
                    revert(add(32, data), mload(data))
                }
            }
        }
        snapshot = abi.decode(data, (uint));
    }

    /// @inheritdoc ERC165
    function supportsInterface(bytes4 _interfaceId) public view virtual override returns (bool) {
        return _interfaceId == type(IReweightableIndex).interfaceId || super.supportsInterface(_interfaceId);
    }
}",754
RealWorld_BA_90_ITopNMarketCapIndexReweightingLogic_RealWord_20240826110200.log,90,ITopNMarketCapIndexReweightingLogic,5545,4117,9662,62.0,0.110065,"// SPDX-License-Identifier: GPL-2.0-or-later

pragma solidity >=0.8.7;

import ""./IAnatomyUpdater.sol"";

/// @title TopNMarketCapIndex reweighitng logic interface
/// @notice Contains reweighitng logic
interface ITopNMarketCapIndexReweightingLogic is IAnatomyUpdater {
    /// @notice Call index reweight process
    /// @param _category Index category
    /// @param _snapshotId Snapshot identifier
    /// @param _topN Number of assets
    /// @return New snaphsot id
    function reweight(
        uint _category,
        uint _snapshotId,
        uint _topN
    ) external returns (uint);
}",154
RealWorld_BA_90_NAV_RealWord_20240826105532.log,90,NAV,19295,5698,24993,74.0,0.210435,"// SPDX-License-Identifier: BUSL-1.1

pragma solidity >=0.8.7;

/// @title NAV library
/// @notice Library for transfer, mint, burn and distribute vToken shares
/// @dev Used in conjunction with vToken
library NAV {
    /// @notice Initial shares quantity
    uint internal constant INITIAL_QUANTITY = 10000;

    struct Data {
        uint lastBalance;
        uint totalSupply;
        mapping(address => uint) balanceOf;
    }

    /// @notice Transfer `_amount` of shares between given addresses
    /// @param _from Account to send shares from
    /// @param _to Account to send shares to
    /// @param _amount Amount of shares to send
    function transfer(
        Data storage self,
        address _from,
        address _to,
        uint _amount
    ) internal {
        self.balanceOf[_from] -= _amount;
        self.balanceOf[_to] += _amount;
    }

    /// @notice Mints shares to the `_recipient` account
    /// @param self Data structure reference
    /// @param _balance New shares maximum limit
    /// @param _recipient Recipient that will receive minted shares
    function mint(
        Data storage self,
        uint _balance,
        address _recipient
    ) internal returns (uint shares) {
        uint amount = _balance - self.lastBalance;
        uint _totalSupply = self.totalSupply;
        if (_totalSupply != 0) {
            shares = (amount * _totalSupply) / self.lastBalance;
        } else {
            shares = amount - INITIAL_QUANTITY;
            _mint(self, address(0), INITIAL_QUANTITY);
        }
        require(shares > 0, ""NAV: INSUFFICIENT_AMOUNT"");
        _mint(self, _recipient, shares);
    }

    /// @notice Burns shares from the `_recipient` account
    /// @param self Data structure reference
    /// @param _balance Shares balance
    function burn(Data storage self, uint _balance) internal returns (uint amount) {
        uint value = self.balanceOf[address(this)];
        amount = (value * _balance) / self.totalSupply;
        require(amount > 0, ""NAV: INSUFFICIENT_SHARES_BURNED"");
        _burn(self, address(this), value);
    }

    /// @notice Synchronizes token balances
    /// @param self Data structure reference
    /// @param _newBalance Total asset amount
    function sync(Data storage self, uint _newBalance) internal {
        if (self.lastBalance != _newBalance) {
            self.lastBalance = _newBalance;
        }
    }

    /// @notice Returns amount of tokens corresponding to the given `_shares` amount
    /// @param self Data structure reference
    /// @param _shares Amount of shares
    /// @param _balance Shares balance
    /// @return Amount of tokens corresponding to given shares
    function assetBalanceForShares(
        Data storage self,
        uint _shares,
        uint _balance
    ) internal view returns (uint) {
        uint _totalSupply = self.totalSupply;
        if (_totalSupply != 0) {
            return (_shares * _balance) / _totalSupply;
        }

        return 0;
    }

    /// @notice Returns amount of shares that will be minted for the given tokens amount
    /// @param self Data structure reference
    /// @param _amount Tokens amount
    /// @return Amount of mintable shares
    function mintableShares(Data storage self, uint _amount) internal view returns (uint) {
        uint _totalSupply = self.totalSupply;
        if (_totalSupply != 0) {
            return (_amount * _totalSupply) / self.lastBalance;
        }

        return _amount - INITIAL_QUANTITY;
    }

    /// @notice Mints shares for the given account
    /// @param self Data structure reference
    /// @param _account Account to mint shares for
    /// @param _amount Amount shares to mint
    function _mint(
        Data storage self,
        address _account,
        uint _amount
    ) private {
        self.balanceOf[_account] += _amount;
        self.totalSupply += _amount;
    }

    /// @notice Burns shares of the given account
    /// @param self Data structure reference
    /// @param _account Account to burn shares of
    /// @param _amount Amount shares to burn
    function _burn(
        Data storage self,
        address _account,
        uint _amount
    ) private {
        self.balanceOf[_account] -= _amount;
        self.totalSupply -= _amount;
    }
}",978
RealWorld_BA_90_vToken_RealWord_20240826113118.log,90,vToken,33921,5396,39317,71.0,0.277525,"// SPDX-License-Identifier: BUSL-1.1

pragma solidity >=0.8.7;

import ""@openzeppelin/contracts/utils/math/Math.sol"";
import ""@openzeppelin/contracts/access/IAccessControl.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";
import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/utils/introspection/ERC165CheckerUpgradeable.sol"";

import ""./libraries/BP.sol"";
import ""./libraries/NAV.sol"";

import ""./interfaces/IvToken.sol"";
import ""./interfaces/IIndexRegistry.sol"";

/// @title Vault token
/// @notice Contains logic for index's asset management
contract vToken is IvToken, Initializable, ReentrancyGuardUpgradeable, ERC165Upgradeable {
    using NAV for NAV.Data;
    using SafeERC20 for IERC20;
    using ERC165CheckerUpgradeable for address;

    /// @notice Index role
    bytes32 private constant INDEX_ROLE = keccak256(""INDEX_ROLE"");
    /// @notice Oracle role
    bytes32 private constant ORACLE_ROLE = keccak256(""ORACLE_ROLE"");
    /// @notice Orderer role
    bytes32 private constant ORDERER_ROLE = keccak256(""ORDERER_ROLE"");
    /// @notice Role allows configure reserve related data/components
    bytes32 private constant RESERVE_MANAGER_ROLE = keccak256(""RESERVE_MANAGER_ROLE"");

    /// @inheritdoc IvToken
    address public override asset;
    /// @inheritdoc IvToken
    address public override registry;

    /// @notice NAV library used to track contract shares between indexes
    NAV.Data internal _NAV;

    /// @notice Requires msg.sender to have `_role` role
    /// @param _role Required role
    modifier onlyRole(bytes32 _role) {
        require(IAccessControl(registry).hasRole(_role, msg.sender), ""vToken: FORBIDDEN"");
        _;
    }

    /// @custom:oz-upgrades-unsafe-allow constructor
    constructor() initializer {}

    /// @inheritdoc IvToken
    /// @dev also sets initial values for public variables
    function initialize(address _asset, address _registry) external override initializer {
        bytes4[] memory interfaceIds = new bytes4[](2);
        interfaceIds[0] = type(IAccessControl).interfaceId;
        interfaceIds[1] = type(IIndexRegistry).interfaceId;
        require(_registry.supportsAllInterfaces(interfaceIds), ""vToken: INTERFACE"");
        require(_asset != address(0), ""vToken: ZERO"");

        __ERC165_init();
        __ReentrancyGuard_init();

        asset = _asset;
        registry = _registry;
    }

    /// @inheritdoc IvToken
    function transferAsset(address _recipient, uint _amount) external override nonReentrant {
        require(msg.sender == IIndexRegistry(registry).orderer(), ""vToken: FORBIDDEN"");
        _transferAsset(_recipient, _amount);
    }

    /// @inheritdoc IvToken
    function transfer(address _recipient, uint _amount) external override nonReentrant {
        _transfer(msg.sender, _recipient, _amount);
    }

    /// @inheritdoc IvToken
    function transferFrom(
        address _from,
        address _to,
        uint _shares
    ) external override nonReentrant onlyRole(ORDERER_ROLE) {
        _transfer(_from, _to, _shares);
    }

    /// @inheritdoc IvToken
    function mint() external override nonReentrant onlyRole(INDEX_ROLE) returns (uint shares) {
        return _mint(msg.sender);
    }

    /// @inheritdoc IvToken
    function burn(address _recipient) external override nonReentrant onlyRole(INDEX_ROLE) returns (uint amount) {
        return _burn(_recipient);
    }

    /// @inheritdoc IvToken
    function mintFor(address _recipient) external override nonReentrant onlyRole(ORDERER_ROLE) returns (uint) {
        return _mint(_recipient);
    }

    /// @inheritdoc IvToken
    function burnFor(address _recipient) external override nonReentrant onlyRole(ORDERER_ROLE) returns (uint) {
        return _burn(_recipient);
    }

    /// @inheritdoc IvToken
    function sync() external override nonReentrant {
        _NAV.sync(totalAssetSupply());
    }

    /// @inheritdoc IvToken
    function balanceOf(address _account) external view override returns (uint) {
        return _NAV.balanceOf[_account];
    }

    /// @inheritdoc IvToken
    function lastBalance() external view override returns (uint) {
        return _NAV.lastBalance;
    }

    /// @inheritdoc IvToken
    function mintableShares(uint _amount) external view override returns (uint) {
        return _NAV.mintableShares(_amount);
    }

    /// @inheritdoc IvToken
    function totalSupply() external view override returns (uint) {
        return _NAV.totalSupply;
    }

    /// @inheritdoc IvToken
    function lastAssetBalanceOf(address _account) external view override returns (uint) {
        return _NAV.assetBalanceForShares(_NAV.balanceOf[_account], _NAV.lastBalance);
    }

    /// @inheritdoc IvToken
    function assetBalanceOf(address _account) external view override returns (uint) {
        return _NAV.assetBalanceForShares(_NAV.balanceOf[_account], totalAssetSupply());
    }

    /// @inheritdoc IvToken
    function assetDataOf(address _account, uint _shares) external view override returns (AssetData memory) {
        _shares = Math.min(_shares, _NAV.balanceOf[_account]);
        uint amountInAsset = _NAV.assetBalanceForShares(_shares, totalAssetSupply());
        return AssetData({ maxShares: _shares, amountInAsset: amountInAsset });
    }

    /// @inheritdoc IvToken
    function shareChange(address _account, uint _amountInAsset)
        external
        view
        override
        returns (uint newShares, uint oldShares)
    {
        oldShares = _NAV.balanceOf[_account];
        uint _totalSupply = _NAV.totalSupply;
        if (_totalSupply > 0) {
            uint _balance = _NAV.balanceOf[_account];
            uint _assetBalance = totalAssetSupply();
            uint availableAssets = (_balance * _assetBalance) / _totalSupply;
            newShares = (_amountInAsset * (_totalSupply - oldShares)) / (_assetBalance - availableAssets);
        } else {
            newShares = _amountInAsset < NAV.INITIAL_QUANTITY ? 0 : _amountInAsset - NAV.INITIAL_QUANTITY;
        }
    }

    /// @inheritdoc IvToken
    function totalAssetSupply() public view override returns (uint) {
        return IERC20(asset).balanceOf(address(this));
    }

    /// @inheritdoc ERC165Upgradeable
    function supportsInterface(bytes4 _interfaceId) public view virtual override returns (bool) {
        return _interfaceId == type(IvToken).interfaceId || super.supportsInterface(_interfaceId);
    }

    /// @notice Mints shares to `_recipient` address
    /// @param _recipient Shares recipient
    /// @return shares Amount of minted shares
    function _mint(address _recipient) internal returns (uint shares) {
        uint _totalAssetSupply = totalAssetSupply();
        shares = _NAV.mint(_totalAssetSupply, _recipient);
        _NAV.sync(_totalAssetSupply);
        emit VTokenTransfer(address(0), _recipient, shares);
    }

    /// @notice Burns shares from `_recipient` address
    /// @param _recipient Recipient of assets from burnt shares
    /// @return amount Amount of asset for burnt shares
    function _burn(address _recipient) internal returns (uint amount) {
        uint shares = _NAV.balanceOf[address(this)];
        amount = _NAV.burn(totalAssetSupply());
        _transferAsset(_recipient, amount);
        _NAV.sync(totalAssetSupply());
        emit VTokenTransfer(_recipient, address(0), shares);
    }

    /// @notice Transfers `_amount` of shares from one address to another
    /// @param _from Address to transfer shares from
    /// @param _to Address to transfer shares to
    /// @param _amount Amount of shares to transfer
    function _transfer(
        address _from,
        address _to,
        uint _amount
    ) internal {
        _NAV.transfer(_from, _to, _amount);
        emit VTokenTransfer(_from, _to, _amount);
    }

    /// @notice Transfers `_amount` of asset to `_recipient` address
    /// @param _recipient Recipient of assets
    /// @param _amount Amount of assets to transfer
    function _transferAsset(address _recipient, uint _amount) internal {
        uint balance = IERC20(asset).balanceOf(address(this));
        IERC20(asset).safeTransfer(_recipient, Math.min(_amount, balance));
    }

    uint256[42] private __gap;
}",1936
RealWorld_BA_90_ManagedIndexReweightingLogic_RealWord_20240826105411.log,90,ManagedIndexReweightingLogic,19905,5455,25360,79.0,0.208625,"// SPDX-License-Identifier: BUSL-1.1

pragma solidity >=0.8.7;

import ""@openzeppelin/contracts/access/IAccessControl.sol"";
import ""@openzeppelin/contracts/utils/introspection/ERC165.sol"";

import ""./libraries/IndexLibrary.sol"";

import ""./interfaces/IvToken.sol"";
import ""./interfaces/IOrderer.sol"";
import ""./interfaces/IvTokenFactory.sol"";
import ""./interfaces/IIndexRegistry.sol"";
import ""./interfaces/IManagedIndexReweightingLogic.sol"";

import ""./IndexLayout.sol"";

/// @title ManagedIndex reweighting logic
/// @notice Contains reweighting logic
contract ManagedIndexReweightingLogic is IndexLayout, IManagedIndexReweightingLogic, ERC165 {
    using FullMath for uint;
    using EnumerableSet for EnumerableSet.AddressSet;

    /// @notice Asset role
    bytes32 internal constant ASSET_ROLE = keccak256(""ASSET_ROLE"");

    /// @inheritdoc IManagedIndexReweightingLogic
    function reweight(address[] calldata _updatedAssets, uint8[] calldata _updatedWeights) external override {
        require(
            _updatedAssets.length > 1 &&
                _updatedWeights.length == _updatedAssets.length &&
                _updatedAssets.length <= IIndexRegistry(registry).maxComponents(),
            ""ManagedIndex: INVALID""
        );

        uint virtualEvaluationInBase;
        IPhuturePriceOracle oracle = IPhuturePriceOracle(IIndexRegistry(registry).priceOracle());
        for (uint i; i < assets.length(); ++i) {
            uint priceAssetPerBaseInUQ = oracle.refreshedAssetPerBaseInUQ(assets.at(i));
            uint availableAssets = IvToken(IvTokenFactory(vTokenFactory).createOrReturnVTokenOf(assets.at(i)))
                .assetBalanceOf(address(this));
            virtualEvaluationInBase += availableAssets.mulDiv(FixedPoint112.Q112, priceAssetPerBaseInUQ);
        }

        IOrderer orderer = IOrderer(IIndexRegistry(registry).orderer());
        uint orderId = orderer.placeOrder();

        uint _totalWeight = IndexLibrary.MAX_WEIGHT;

        for (uint i; i < _updatedAssets.length; ++i) {
            address asset = _updatedAssets[i];
            require(asset != address(0), ""ManagedIndex: ZERO"");

            uint8 newWeight = _updatedWeights[i];

            if (i > 0) {
                // makes sure that there are no duplicate assets
                require(_updatedAssets[i - 1] < asset, ""ManagedIndex: SORT"");
            }

            if (newWeight > 0) {
                require(IAccessControl(registry).hasRole(ASSET_ROLE, asset), ""ManagedIndex: INVALID_ASSET"");
                assets.add(asset);
                inactiveAssets.remove(asset);

                uint8 prevWeight = weightOf[asset];
                if (prevWeight != newWeight) {
                    emit UpdateAnatomy(asset, newWeight);
                }

                _totalWeight = _totalWeight + newWeight - prevWeight;
                weightOf[asset] = newWeight;

                uint amountInBase = (virtualEvaluationInBase * weightOf[asset]) / IndexLibrary.MAX_WEIGHT;
                uint amountInAsset = amountInBase.mulDiv(oracle.refreshedAssetPerBaseInUQ(asset), FixedPoint112.Q112);
                (uint newShares, uint oldShares) = IvToken(IvTokenFactory(vTokenFactory).createOrReturnVTokenOf(asset))
                    .shareChange(address(this), amountInAsset);

                if (newShares > oldShares) {
                    orderer.addOrderDetails(orderId, asset, newShares - oldShares, IOrderer.OrderSide.Buy);
                } else if (oldShares > newShares) {
                    orderer.addOrderDetails(orderId, asset, oldShares - newShares, IOrderer.OrderSide.Sell);
                }
            } else {
                require(assets.remove(asset), ""ManagedIndex: INVALID"");
                inactiveAssets.add(asset);

                _totalWeight -= weightOf[asset];

                delete weightOf[asset];

                emit UpdateAnatomy(asset, 0);
            }
        }
        address[] memory _inactiveAssets = inactiveAssets.values();
        for (uint i; i < _inactiveAssets.length; ++i) {
            uint shares = IvToken(IvTokenFactory(vTokenFactory).vTokenOf(_inactiveAssets[i])).balanceOf(address(this));
            if (shares > 0) {
                orderer.addOrderDetails(orderId, _inactiveAssets[i], shares, IOrderer.OrderSide.Sell);
            } else {
                inactiveAssets.remove(_inactiveAssets[i]);
            }
        }
        require(_totalWeight == IndexLibrary.MAX_WEIGHT, ""ManagedIndex: MAX"");
    }

    /// @inheritdoc ERC165
    function supportsInterface(bytes4 _interfaceId) public view virtual override returns (bool) {
        return _interfaceId == type(IManagedIndexReweightingLogic).interfaceId || super.supportsInterface(_interfaceId);
    }
}",1039
RealWorld_BA_90_IChainLinkFeed_RealWord_20240826122005.log,90,IChainLinkFeed,3696,4070,7766,59.0,0.09988,"// SPDX-License-Identifier: GPL-2.0-or-later

pragma solidity >=0.8.7;

interface IChainLinkFeed {
    function latestAnswer() external view returns (int);
}",41
RealWorld_BA_90_IndexLayout_RealWord_20240826103720.log,90,IndexLayout,6093,4378,10471,62.0,0.118025,"// SPDX-License-Identifier: BUSL-1.1

pragma solidity >=0.8.7;

import ""@openzeppelin/contracts/utils/structs/EnumerableSet.sol"";

import ""./interfaces/IIndexLayout.sol"";

/// @title Index layout
/// @notice Contains storage layout of index
abstract contract IndexLayout is IIndexLayout {
    /// @inheritdoc IIndexLayout
    address public override factory;
    /// @inheritdoc IIndexLayout
    address public override vTokenFactory;
    /// @inheritdoc IIndexLayout
    address public override registry;

    /// @notice Timestamp of last AUM fee charge
    uint internal lastTransferTime;

    /// @notice Set with asset addresses
    EnumerableSet.AddressSet internal assets;
    /// @notice Set with previously used asset addresses
    EnumerableSet.AddressSet internal inactiveAssets;
    /// @notice Map of assets and their corresponding weights in index
    mapping(address => uint8) internal weightOf;
}",195
RealWorld_BA_90_ITopNMarketCapCategories_RealWord_20240826112110.log,90,ITopNMarketCapCategories,6899,5138,12037,68.0,0.137255,"// SPDX-License-Identifier: GPL-2.0-or-later

pragma solidity >=0.8.7;

/// @title Top N market capitalization categories interface
/// @notice Interface describing logic for top market capitalization categories management
interface ITopNMarketCapCategories {
    struct DiffDetails {
        uint snapshotId;
        uint totalCapitalizationInBase;
        uint assetCount;
        DiffAsset[] assets;
    }

    struct DiffAsset {
        address asset;
        bool isRemoved;
        uint capitalizationInBase;
    }

    /// @notice Compare asset changes (diff) between provided snapshots within given category
    /// @param _categoryId Category id to check
    /// @param _lastSnapshotId Snapshot id to compare with the latest snapshot
    /// @param _topN Assets amount to compare
    /// @return diff Assets diff object of type DiffDetails
    function assetDiff(
        uint _categoryId,
        uint _lastSnapshotId,
        uint _topN
    ) external view returns (DiffDetails memory diff);
}",215
RealWorld_BA_90_IPhuturePriceOracle_RealWord_20240826111146.log,90,IPhuturePriceOracle,8850,5301,14151,71.0,0.15027,"// SPDX-License-Identifier: GPL-2.0-or-later

pragma solidity >=0.8.7;

import ""./IPriceOracle.sol"";

/// @title Phuture price oracle interface
/// @notice Aggregates all price oracles and works with them through IPriceOracle interface
interface IPhuturePriceOracle is IPriceOracle {
    /// @notice Assigns given oracle to specified asset. Then oracle will be used to manage asset price
    /// @param _asset Asset to register
    /// @param _oracle Oracle to assign
    function setOracleOf(address _asset, address _oracle) external;

    /// @notice Removes oracle of specified asset
    /// @param _asset Asset to remove oracle from
    function removeOracleOf(address _asset) external;

    /// @notice Converts to index amount
    /// @param _baseAmount Amount in base
    /// @param _indexDecimals Index's decimals
    /// @return Asset per base in UQ with index decimals
    function convertToIndex(uint _baseAmount, uint8 _indexDecimals) external view returns (uint);

    /// @notice Checks if the given asset has oracle assigned
    /// @param _asset Asset to check
    /// @return Returns boolean flag defining if the given asset has oracle assigned
    function containsOracleOf(address _asset) external view returns (bool);

    /// @notice Price oracle assigned to the given `_asset`
    /// @param _asset Asset to obtain price oracle for
    /// @return Returns price oracle assigned to the `_asset`
    function priceOracleOf(address _asset) external view returns (address);
}",338
RealWorld_BA_90_ITrackedIndexReweightingLogic_RealWord_20240826121012.log,90,ITrackedIndexReweightingLogic,4501,4219,8720,56.0,0.106885,"// SPDX-License-Identifier: GPL-2.0-or-later

pragma solidity >=0.8.7;

import ""./IAnatomyUpdater.sol"";

/// @title TrackedIndex reweighitng logic interface
/// @notice Contains reweighitng logic
interface ITrackedIndexReweightingLogic is IAnatomyUpdater {
    /// @notice Call index reweight process
    function reweight() external;
}",87
RealWorld_BA_90_PhuturePriceOracle_RealWord_20240826113347.log,90,PhuturePriceOracle,16928,5405,22333,79.0,0.19274,"// SPDX-License-Identifier: BUSL-1.1

pragma solidity >=0.8.7;

import ""@openzeppelin/contracts/access/IAccessControl.sol"";
import ""@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol"";
import ""@openzeppelin/contracts/utils/introspection/ERC165Checker.sol"";

import ""./libraries/FixedPoint112.sol"";

import ""./interfaces/IPriceOracle.sol"";
import ""./interfaces/IIndexRegistry.sol"";
import ""./interfaces/IPhuturePriceOracle.sol"";

/// @title Phuture price oracle
/// @notice Aggregates all price oracles and works with them through IPriceOracle interface
contract PhuturePriceOracle is IPhuturePriceOracle {
    using ERC165Checker for address;

    /// @notice Role allows configure asset related data/components
    bytes32 private constant ASSET_MANAGER_ROLE = keccak256(""ASSET_MANAGER_ROLE"");

    /// @notice Base asset address
    address public base;

    /// @notice Index registry address
    address public registry;

    /// @inheritdoc IPhuturePriceOracle
    mapping(address => address) public override priceOracleOf;

    /// @notice Decimals of base asset
    uint8 private baseDecimals;

    /// @notice Requires msg.sender to have `_role` role
    /// @param _role Required role
    modifier onlyRole(bytes32 _role) {
        require(IAccessControl(registry).hasRole(_role, msg.sender), ""PhuturePriceOracle: FORBIDDEN"");
        _;
    }

    constructor(address _registry, address _base) {
        bytes4[] memory interfaceIds = new bytes4[](2);
        interfaceIds[0] = type(IAccessControl).interfaceId;
        interfaceIds[1] = type(IIndexRegistry).interfaceId;
        require(_registry.supportsAllInterfaces(interfaceIds), ""PhuturePriceOracle: INTERFACE"");
        require(_base != address(0), ""PhuturePriceOracle: ZERO"");

        base = _base;
        baseDecimals = IERC20Metadata(_base).decimals();
        registry = _registry;
    }

    /// @inheritdoc IPhuturePriceOracle
    function setOracleOf(address _asset, address _oracle) external override onlyRole(ASSET_MANAGER_ROLE) {
        require(_oracle.supportsInterface(type(IPriceOracle).interfaceId), ""PhuturePriceOracle: INTERFACE"");

        priceOracleOf[_asset] = _oracle;
    }

    /// @inheritdoc IPhuturePriceOracle
    function removeOracleOf(address _asset) external override onlyRole(ASSET_MANAGER_ROLE) {
        require(priceOracleOf[_asset] != address(0), ""PhuturePriceOracle: UNSET"");
        delete priceOracleOf[_asset];
    }

    /// @inheritdoc IPhuturePriceOracle
    function convertToIndex(uint _baseAmount, uint8 _indexDecimals) external view override returns (uint) {
        return (_baseAmount * 10**_indexDecimals) / 10**baseDecimals;
    }

    /// @inheritdoc IPhuturePriceOracle
    function containsOracleOf(address _asset) external view override returns (bool) {
        return priceOracleOf[_asset] != address(0) || _asset == base;
    }

    /// @inheritdoc IPriceOracle
    function refreshedAssetPerBaseInUQ(address _asset) public override returns (uint) {
        if (_asset == base) {
            return FixedPoint112.Q112;
        }

        require(priceOracleOf[_asset] != address(0), ""PhuturePriceOracle: UNSET"");
        return IPriceOracle(priceOracleOf[_asset]).refreshedAssetPerBaseInUQ(_asset);
    }

    /// @inheritdoc IPriceOracle
    function lastAssetPerBaseInUQ(address _asset) public view override returns (uint) {
        if (_asset == base) {
            return FixedPoint112.Q112;
        }

        require(priceOracleOf[_asset] != address(0), ""PhuturePriceOracle: UNSET"");
        return IPriceOracle(priceOracleOf[_asset]).lastAssetPerBaseInUQ(_asset);
    }
}",861
RealWorld_BA_90_IWETH_RealWord_20240826122106.log,90,IWETH,3780,4348,8128,75.0,0.10586,"// SPDX-License-Identifier: GPL-2.0-or-later

pragma solidity >=0.8.7;

interface IWETH {
    function deposit() external payable;

    function transfer(address to, uint value) external returns (bool);

    function withdraw(uint) external;
}",56
RealWorld_BA_90_IChainlinkPriceOracle_RealWord_20240826111300.log,90,IChainlinkPriceOracle,5065,4691,9756,70.0,0.119145,"// SPDX-License-Identifier: GPL-2.0-or-later

pragma solidity >=0.8.7;

import ""./IPriceOracle.sol"";

/// @title Chainlink price oracle interface
/// @notice Extends IPriceOracle interface
interface IChainlinkPriceOracle is IPriceOracle {
    /// @notice Adds `_asset` to the oracle
    /// @param _asset Asset's address
    /// @param _asset Asset aggregator's address
    function addAsset(address _asset, address _assetAggregator) external;
}",110
RealWorld_BA_90_IndexLibrary_RealWord_20240826105649.log,90,IndexLibrary,7193,4194,11387,55.0,0.119845,"// SPDX-License-Identifier: BUSL-1.1

pragma solidity >=0.8.7;

import ""./FullMath.sol"";
import ""./FixedPoint112.sol"";

/// @title Index library
/// @notice Provides various utilities for indexes
library IndexLibrary {
    using FullMath for uint;

    /// @notice Initial index quantity to mint
    uint constant INITIAL_QUANTITY = 10000;

    /// @notice Total assets weight within an index
    uint8 constant MAX_WEIGHT = type(uint8).max;

    /// @notice Returns amount of asset equivalent to the given parameters
    /// @param _assetPerBaseInUQ Asset per base price in UQ
    /// @param _weight Weight of the given asset
    /// @param _amountInBase Total assets amount in base
    /// @return Amount of asset
    function amountInAsset(
        uint _assetPerBaseInUQ,
        uint8 _weight,
        uint _amountInBase
    ) internal pure returns (uint) {
        require(_assetPerBaseInUQ > 0, ""IndexLibrary: ORACLE"");

        return ((_amountInBase * _weight) / MAX_WEIGHT).mulDiv(_assetPerBaseInUQ, FixedPoint112.Q112);
    }
}",263
RealWorld_BA_90_BaseIndex_RealWord_20240826104337.log,90,BaseIndex,15267,6048,21315,92.0,0.197295,"// SPDX-License-Identifier: BUSL-1.1

pragma solidity >=0.8.7;

import ""@openzeppelin/contracts/access/IAccessControl.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/utils/introspection/ERC165Checker.sol"";

import ""./libraries/IndexLibrary.sol"";

import ""./interfaces/IIndex.sol"";
import ""./interfaces/IIndexLogic.sol"";
import ""./interfaces/IIndexFactory.sol"";
import ""./interfaces/IPhuturePriceOracle.sol"";

import ""./PhutureIndex.sol"";

/// @title Base index
/// @notice Contains common logic for all indices
abstract contract BaseIndex is PhutureIndex, ReentrancyGuard, IIndex {
    using ERC165Checker for address;
    using EnumerableSet for EnumerableSet.AddressSet;

    /// @notice Role allows configure index related data/components
    bytes32 internal constant INDEX_MANAGER_ROLE = keccak256(""INDEX_MANAGER_ROLE"");

    /// @notice Checks if msg.sender has the given role's permission
    modifier onlyRole(bytes32 role) {
        require(IAccessControl(registry).hasRole(role, msg.sender), ""GovernableIndex: FORBIDDEN"");
        _;
    }

    constructor(address _factory) {
        require(_factory.supportsInterface(type(IIndexFactory).interfaceId), ""BaseIndex: INTERFACE"");

        factory = _factory;
        lastTransferTime = block.timestamp;
        registry = IIndexFactory(_factory).registry();
        vTokenFactory = IIndexFactory(_factory).vTokenFactory();
    }

    /// @inheritdoc IIndex
    function mint(address _recipient) external override nonReentrant {
        (bool success, bytes memory data) = IIndexRegistry(registry).indexLogic().delegatecall(
            abi.encodeWithSelector(IIndexLogic.mint.selector, _recipient)
        );
        if (!success) {
            if (data.length == 0) {
                revert(""BaseIndex: MINT_FAILED"");
            } else {
                assembly {
                    revert(add(32, data), mload(data))
                }
            }
        }
    }

    /// @inheritdoc IIndex
    function burn(address _recipient) external override nonReentrant {
        (bool success, bytes memory data) = IIndexRegistry(registry).indexLogic().delegatecall(
            abi.encodeWithSelector(IIndexLogic.burn.selector, _recipient)
        );
        if (!success) {
            if (data.length == 0) {
                revert(""BaseIndex: BURN_FAILED"");
            } else {
                assembly {
                    revert(add(32, data), mload(data))
                }
            }
        }
    }

    /// @inheritdoc IIndex
    function anatomy() external view override returns (address[] memory _assets, uint8[] memory _weights) {
        _assets = assets.values();
        _weights = new uint8[](_assets.length);
        for (uint i; i < _assets.length; ++i) {
            _weights[i] = weightOf[_assets[i]];
        }
    }

    /// @inheritdoc IIndex
    function inactiveAnatomy() external view override returns (address[] memory _assets) {
        _assets = inactiveAssets.values();
    }

    /// @inheritdoc ERC165
    function supportsInterface(bytes4 _interfaceId) public view virtual override returns (bool) {
        return _interfaceId == type(IIndex).interfaceId || super.supportsInterface(_interfaceId);
    }
}",708
RealWorld_BA_90_UniswapV2PriceOracle_RealWord_20240826105152.log,90,UniswapV2PriceOracle,18526,5568,24094,67.0,0.20399,"// SPDX-License-Identifier: GPL-2.0-or-later

pragma solidity >=0.8.7;

import ""@openzeppelin/contracts/utils/introspection/ERC165.sol"";
import ""@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol"";
import ""@uniswap/v2-periphery/contracts/libraries/UniswapV2OracleLibrary.sol"";

import ""./interfaces/IUniswapV2PriceOracle.sol"";

/// @title Uniswap V2 price oracle
/// @notice Contains logic for price calculation of asset using Uniswap V2 Pair
/// @dev Oracle works through base asset which is set in initialize function
contract UniswapV2PriceOracle is IUniswapV2PriceOracle, ERC165 {
    using UniswapV2OracleLibrary for address;

    /// @notice Minimum oracle update interval
    /// @dev If min update interval hasn't passed (24h) before update, previously cached value is returned
    uint private constant MIN_UPDATE_INTERVAL = 24 hours;

    IUniswapV2Pair immutable pair;
    /// @inheritdoc IUniswapV2PriceOracle
    address public immutable override asset0;
    /// @inheritdoc IUniswapV2PriceOracle
    address public immutable override asset1;

    uint private price0CumulativeLast;
    uint private price1CumulativeLast;
    uint32 private blockTimestampLast;
    uint private price0Average;
    uint private price1Average;

    constructor(
        address _factory,
        address _assetA,
        address _assetB
    ) {
        IUniswapV2Pair _pair = IUniswapV2Pair(IUniswapV2Factory(_factory).getPair(_assetA, _assetB));
        pair = _pair;
        asset0 = _pair.token0();
        asset1 = _pair.token1();

        uint112 reserve0;
        uint112 reserve1;
        (reserve0, reserve1, blockTimestampLast) = _pair.getReserves();
        require(reserve0 != 0 && reserve1 != 0, ""UniswapV2PriceOracle: RESERVES"");

        uint _price0CumulativeLast = _pair.price0CumulativeLast();
        uint _price1CumulativeLast = _pair.price1CumulativeLast();
        (uint price0Cml, uint price1Cml, uint32 blockTimestamp) = address(_pair).currentCumulativePrices();
        uint32 timeElapsed = blockTimestamp - blockTimestampLast;
        price0CumulativeLast = _price0CumulativeLast;
        price1CumulativeLast = _price1CumulativeLast;
        price0Average = (price0Cml - _price0CumulativeLast) / timeElapsed;
        price1Average = (price1Cml - _price1CumulativeLast) / timeElapsed;
    }

    /// @inheritdoc IPriceOracle
    /// @dev Updates and returns cumulative price value
    /// @dev If min update interval hasn't passed (24h), previously cached value is returned
    function refreshedAssetPerBaseInUQ(address _asset) external override returns (uint) {
        (uint price0Cumulative, uint price1Cumulative, uint32 blockTimestamp) = address(pair).currentCumulativePrices();
        uint32 timeElapsed = blockTimestamp - blockTimestampLast;

        if (timeElapsed >= MIN_UPDATE_INTERVAL) {
            price0Average = (price0Cumulative - price0CumulativeLast) / timeElapsed;
            price1Average = (price1Cumulative - price1CumulativeLast) / timeElapsed;

            price0CumulativeLast = price0Cumulative;
            price1CumulativeLast = price1Cumulative;
            blockTimestampLast = blockTimestamp;
        }

        return lastAssetPerBaseInUQ(_asset);
    }

    /// @inheritdoc IPriceOracle
    /// @dev Returns cumulative price value cached during last refresh call
    function lastAssetPerBaseInUQ(address _asset) public view override returns (uint) {
        if (_asset == asset0) {
            return price1Average;
        } else {
            require(_asset == asset1, ""UniswapV2PriceOracle: UNKNOWN"");
            return price0Average;
        }
    }

    /// @inheritdoc ERC165
    function supportsInterface(bytes4 _interfaceId) public view virtual override returns (bool) {
        return
            _interfaceId == type(IUniswapV2PriceOracle).interfaceId ||
            _interfaceId == type(IPriceOracle).interfaceId ||
            super.supportsInterface(_interfaceId);
    }
}",969
RealWorld_BA_90_PhuturePriceOracle_RealWord_20240826103824.log,90,PhuturePriceOracle,17084,5577,22661,75.0,0.19696,"// SPDX-License-Identifier: BUSL-1.1

pragma solidity >=0.8.7;

import ""@openzeppelin/contracts/access/IAccessControl.sol"";
import ""@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol"";
import ""@openzeppelin/contracts/utils/introspection/ERC165Checker.sol"";

import ""./libraries/FixedPoint112.sol"";

import ""./interfaces/IPriceOracle.sol"";
import ""./interfaces/IIndexRegistry.sol"";
import ""./interfaces/IPhuturePriceOracle.sol"";

/// @title Phuture price oracle
/// @notice Aggregates all price oracles and works with them through IPriceOracle interface
contract PhuturePriceOracle is IPhuturePriceOracle {
    using ERC165Checker for address;

    /// @notice Role allows configure asset related data/components
    bytes32 private constant ASSET_MANAGER_ROLE = keccak256(""ASSET_MANAGER_ROLE"");

    /// @notice Base asset address
    address public base;

    /// @notice Index registry address
    address public registry;

    /// @inheritdoc IPhuturePriceOracle
    mapping(address => address) public override priceOracleOf;

    /// @notice Decimals of base asset
    uint8 private baseDecimals;

    /// @notice Requires msg.sender to have `_role` role
    /// @param _role Required role
    modifier onlyRole(bytes32 _role) {
        require(IAccessControl(registry).hasRole(_role, msg.sender), ""PhuturePriceOracle: FORBIDDEN"");
        _;
    }

    constructor(address _registry, address _base) {
        bytes4[] memory interfaceIds = new bytes4[](2);
        interfaceIds[0] = type(IAccessControl).interfaceId;
        interfaceIds[1] = type(IIndexRegistry).interfaceId;
        require(_registry.supportsAllInterfaces(interfaceIds), ""PhuturePriceOracle: INTERFACE"");
        require(_base != address(0), ""PhuturePriceOracle: ZERO"");

        base = _base;
        baseDecimals = IERC20Metadata(_base).decimals();
        registry = _registry;
    }

    /// @inheritdoc IPhuturePriceOracle
    function setOracleOf(address _asset, address _oracle) external override onlyRole(ASSET_MANAGER_ROLE) {
        require(_oracle.supportsInterface(type(IPriceOracle).interfaceId), ""PhuturePriceOracle: INTERFACE"");

        priceOracleOf[_asset] = _oracle;
    }

    /// @inheritdoc IPhuturePriceOracle
    function removeOracleOf(address _asset) external override onlyRole(ASSET_MANAGER_ROLE) {
        require(priceOracleOf[_asset] != address(0), ""PhuturePriceOracle: UNSET"");
        delete priceOracleOf[_asset];
    }

    /// @inheritdoc IPhuturePriceOracle
    function convertToIndex(uint _baseAmount, uint8 _indexDecimals) external view override returns (uint) {
        return (_baseAmount * 10**_indexDecimals) / 10**baseDecimals;
    }

    /// @inheritdoc IPhuturePriceOracle
    function containsOracleOf(address _asset) external view override returns (bool) {
        return priceOracleOf[_asset] != address(0) || _asset == base;
    }

    /// @inheritdoc IPriceOracle
    function refreshedAssetPerBaseInUQ(address _asset) public override returns (uint) {
        if (_asset == base) {
            return FixedPoint112.Q112;
        }

        require(priceOracleOf[_asset] != address(0), ""PhuturePriceOracle: UNSET"");
        return IPriceOracle(priceOracleOf[_asset]).refreshedAssetPerBaseInUQ(_asset);
    }

    /// @inheritdoc IPriceOracle
    function lastAssetPerBaseInUQ(address _asset) public view override returns (uint) {
        if (_asset == base) {
            return FixedPoint112.Q112;
        }

        require(priceOracleOf[_asset] != address(0), ""PhuturePriceOracle: UNSET"");
        return IPriceOracle(priceOracleOf[_asset]).lastAssetPerBaseInUQ(_asset);
    }
}",861
RealWorld_BA_90_IPriceOracle_RealWord_20240826120113.log,90,IPriceOracle,5273,4553,9826,59.0,0.117425,"// SPDX-License-Identifier: GPL-2.0-or-later

pragma solidity >=0.8.7;

/// @title Price oracle interface
/// @notice Returns price of single asset in relation to base
interface IPriceOracle {
    /// @notice Updates and returns asset per base
    /// @return Asset per base in UQ
    function refreshedAssetPerBaseInUQ(address _asset) external returns (uint);

    /// @notice Returns last asset per base
    /// @return Asset per base in UQ
    function lastAssetPerBaseInUQ(address _asset) external view returns (uint);
}",129
RealWorld_BA_90_BaseIndex_RealWord_20240826113847.log,90,BaseIndex,15015,5936,20951,74.0,0.193795,"// SPDX-License-Identifier: BUSL-1.1

pragma solidity >=0.8.7;

import ""@openzeppelin/contracts/access/IAccessControl.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/utils/introspection/ERC165Checker.sol"";

import ""./libraries/IndexLibrary.sol"";

import ""./interfaces/IIndex.sol"";
import ""./interfaces/IIndexLogic.sol"";
import ""./interfaces/IIndexFactory.sol"";
import ""./interfaces/IPhuturePriceOracle.sol"";

import ""./PhutureIndex.sol"";

/// @title Base index
/// @notice Contains common logic for all indices
abstract contract BaseIndex is PhutureIndex, ReentrancyGuard, IIndex {
    using ERC165Checker for address;
    using EnumerableSet for EnumerableSet.AddressSet;

    /// @notice Role allows configure index related data/components
    bytes32 internal constant INDEX_MANAGER_ROLE = keccak256(""INDEX_MANAGER_ROLE"");

    /// @notice Checks if msg.sender has the given role's permission
    modifier onlyRole(bytes32 role) {
        require(IAccessControl(registry).hasRole(role, msg.sender), ""GovernableIndex: FORBIDDEN"");
        _;
    }

    constructor(address _factory) {
        require(_factory.supportsInterface(type(IIndexFactory).interfaceId), ""BaseIndex: INTERFACE"");

        factory = _factory;
        lastTransferTime = block.timestamp;
        registry = IIndexFactory(_factory).registry();
        vTokenFactory = IIndexFactory(_factory).vTokenFactory();
    }

    /// @inheritdoc IIndex
    function mint(address _recipient) external override nonReentrant {
        (bool success, bytes memory data) = IIndexRegistry(registry).indexLogic().delegatecall(
            abi.encodeWithSelector(IIndexLogic.mint.selector, _recipient)
        );
        if (!success) {
            if (data.length == 0) {
                revert(""BaseIndex: MINT_FAILED"");
            } else {
                assembly {
                    revert(add(32, data), mload(data))
                }
            }
        }
    }

    /// @inheritdoc IIndex
    function burn(address _recipient) external override nonReentrant {
        (bool success, bytes memory data) = IIndexRegistry(registry).indexLogic().delegatecall(
            abi.encodeWithSelector(IIndexLogic.burn.selector, _recipient)
        );
        if (!success) {
            if (data.length == 0) {
                revert(""BaseIndex: BURN_FAILED"");
            } else {
                assembly {
                    revert(add(32, data), mload(data))
                }
            }
        }
    }

    /// @inheritdoc IIndex
    function anatomy() external view override returns (address[] memory _assets, uint8[] memory _weights) {
        _assets = assets.values();
        _weights = new uint8[](_assets.length);
        for (uint i; i < _assets.length; ++i) {
            _weights[i] = weightOf[_assets[i]];
        }
    }

    /// @inheritdoc IIndex
    function inactiveAnatomy() external view override returns (address[] memory _assets) {
        _assets = inactiveAssets.values();
    }

    /// @inheritdoc ERC165
    function supportsInterface(bytes4 _interfaceId) public view virtual override returns (bool) {
        return _interfaceId == type(IIndex).interfaceId || super.supportsInterface(_interfaceId);
    }
}",708
RealWorld_BA_90_IIndex_RealWord_20240826115908.log,90,IIndex,6409,4909,11318,63.0,0.130225,"// SPDX-License-Identifier: GPL-2.0-or-later

pragma solidity >=0.8.7;

import ""./IIndexLayout.sol"";
import ""./IAnatomyUpdater.sol"";

/// @title Index interface
/// @notice Interface containing basic logic for indexes: mint, burn, anatomy info
interface IIndex is IIndexLayout, IAnatomyUpdater {
    /// @notice Index minting
    /// @param _recipient Recipient address
    function mint(address _recipient) external;

    /// @notice Index burning
    /// @param _recipient Recipient address
    function burn(address _recipient) external;

    /// @notice Returns index assets weights information
    /// @return _assets Assets list
    /// @return _weights List of assets corresponding weights
    function anatomy() external view returns (address[] memory _assets, uint8[] memory _weights);

    /// @notice Returns inactive assets
    /// @return _assets Assets list
    function inactiveAnatomy() external view returns (address[] memory _assets);
}",213
RealWorld_BA_90_IManagedIndex_RealWord_20240826121651.log,90,IManagedIndex,5297,5147,10444,61.0,0.129425,"// SPDX-License-Identifier: GPL-2.0-or-later

pragma solidity >=0.8.7;

import ""./IIndex.sol"";

/// @title Managed index interface
/// @notice Interface for dynamic indexes that could be updated with new anatomy data
interface IManagedIndex is IIndex {
    /// @notice Updates index anatomy with corresponding weights and assets
    /// @param _assets List for new asset(s) for the index
    /// @param _weights List of new asset(s) corresponding weights
    function reweight(address[] calldata _assets, uint8[] calldata _weights) external;
}",126
RealWorld_BA_90_IFeePool_RealWord_20240826121754.log,90,IFeePool,5966,4781,10747,65.0,0.12545,"// SPDX-License-Identifier: GPL-2.0-or-later

pragma solidity >=0.8.7;

/// @title Fee pool interface
/// @notice Provides methods for fee management
interface IFeePool {
    /// @notice Minting fee in base point format
    /// @return Returns minting fee in base point (BP) format
    function mintingFeeInBPOf(address _index) external view returns (uint16);

    /// @notice Burning fee in base point format
    /// @return Returns burning fee in base point (BP) format
    function burningFeeInBPOf(address _index) external view returns (uint16);

    /// @notice AUM scaled per seconds rate
    /// @return Returns AUM scaled per seconds rate
    function AUMScaledPerSecondsRateOf(address _index) external view returns (uint);
}",180
RealWorld_BA_90_IndexLogic_RealWord_20240826104103.log,90,IndexLogic,25721,5841,31562,80.0,0.245425,"// SPDX-License-Identifier: BUSL-1.1

pragma solidity >=0.8.7;

import ""@openzeppelin/contracts/access/IAccessControl.sol"";

import ""./libraries/BP.sol"";
import ""./libraries/IndexLibrary.sol"";

import ""./interfaces/IvToken.sol"";
import ""./interfaces/IOrderer.sol"";
import ""./interfaces/IIndexLogic.sol"";
import ""./interfaces/IvTokenFactory.sol"";
import ""./interfaces/IPhuturePriceOracle.sol"";

import ""./PhutureIndex.sol"";

/// @title Index logic
/// @notice Contains common logic for index minting and burning
contract IndexLogic is PhutureIndex, IIndexLogic {
    using FullMath for uint;
    using EnumerableSet for EnumerableSet.AddressSet;

    /// @notice Asset role
    bytes32 internal constant ASSET_ROLE = keccak256(""ASSET_ROLE"");
    /// @notice Role granted for asset which should be skipped during burning
    bytes32 internal constant SKIPPED_ASSET_ROLE = keccak256(""SKIPPED_ASSET_ROLE"");

    /// @notice Mints index to `_recipient` address
    /// @param _recipient Recipient address
    function mint(address _recipient) external override {
        address feePool = IIndexRegistry(registry).feePool();
        _chargeAUMFee(feePool);

        IPhuturePriceOracle oracle = IPhuturePriceOracle(IIndexRegistry(registry).priceOracle());

        uint lastAssetBalanceInBase;
        uint minAmountInBase = type(uint).max;
        for (uint i; i < assets.length(); ++i) {
            require(IAccessControl(registry).hasRole(ASSET_ROLE, assets.at(i)), ""Index: INVALID_ASSET"");
            if (weightOf[assets.at(i)] == 0) {
                continue;
            }
            uint assetPerBaseInUQ = oracle.refreshedAssetPerBaseInUQ(assets.at(i));
            // Q_b * w_i * p_i = Q_i
            // Q_b = Q_i / (w_i * p_i)
            IvToken vToken = IvToken(IvTokenFactory(vTokenFactory).createOrReturnVTokenOf(assets.at(i)));
            uint amountInAsset = IERC20(assets.at(i)).balanceOf(address(vToken)) - vToken.lastBalance();
            uint weightedPrice = assetPerBaseInUQ * weightOf[assets.at(i)];
            uint _minAmountInBase = amountInAsset.mulDiv(FixedPoint112.Q112 * IndexLibrary.MAX_WEIGHT, weightedPrice);
            if (_minAmountInBase < minAmountInBase) {
                minAmountInBase = _minAmountInBase;
            }
            uint lastBalanceInAsset = vToken.lastAssetBalanceOf(address(this));
            vToken.mint();
            uint balanceInBase = lastBalanceInAsset.mulDiv(FixedPoint112.Q112, assetPerBaseInUQ);
            lastAssetBalanceInBase += balanceInBase;
        }

        for (uint i; i < inactiveAssets.length(); ++i) {
            if (!IAccessControl(registry).hasRole(SKIPPED_ASSET_ROLE, inactiveAssets.at(i))) {
                uint lastBalanceInAsset = IvToken(
                    IvTokenFactory(vTokenFactory).createOrReturnVTokenOf(inactiveAssets.at(i))
                ).lastAssetBalanceOf(address(this));
                lastAssetBalanceInBase += lastBalanceInAsset.mulDiv(
                    FixedPoint112.Q112,
                    oracle.refreshedAssetPerBaseInUQ(inactiveAssets.at(i))
                );
            }
        }

        assert(minAmountInBase != type(uint).max);

        uint value;
        if (totalSupply() != 0) {
            require(lastAssetBalanceInBase > 0, ""Index: INSUFFICIENT_AMOUNT"");
            value =
                (oracle.convertToIndex(minAmountInBase, decimals()) * totalSupply()) /
                oracle.convertToIndex(lastAssetBalanceInBase, decimals());
        } else {
            value = oracle.convertToIndex(minAmountInBase, decimals()) - IndexLibrary.INITIAL_QUANTITY;
            _mint(address(0xdead), IndexLibrary.INITIAL_QUANTITY);
        }

        uint fee = (value * IFeePool(feePool).mintingFeeInBPOf(address(this))) / BP.DECIMAL_FACTOR;
        if (fee > 0) {
            _mint(feePool, fee);
            value -= fee;
        }

        _mint(_recipient, value);
    }

    /// @notice Burns index and transfers assets to `_recipient` address
    /// @param _recipient Recipient address
    function burn(address _recipient) external override {
        uint value = balanceOf(address(this));
        require(value > 0, ""Index: INSUFFICIENT_AMOUNT"");
        uint length = assets.length();

        bool containsBlacklistedAssets;
        for (uint i; i < length; ++i) {
            if (!IAccessControl(registry).hasRole(ASSET_ROLE, assets.at(i))) {
                containsBlacklistedAssets = true;
                break;
            }
        }

        if (!containsBlacklistedAssets) {
            address feePool = IIndexRegistry(registry).feePool();

            uint fee = (value * IFeePool(feePool).burningFeeInBPOf(address(this))) / BP.DECIMAL_FACTOR;

            if (fee > 0) {
                // AUM charged in _transfer method
                _transfer(address(this), feePool, fee);
                value -= fee;
            } else {
                _chargeAUMFee(feePool);
            }
        }

        address orderer = IIndexRegistry(registry).orderer();
        uint lastOrderId = IOrderer(orderer).lastOrderIdOf(address(this));
        for (uint i; i < length + inactiveAssets.length(); ++i) {
            address asset = i < length ? assets.at(i) : inactiveAssets.at(i - length);
            if (containsBlacklistedAssets && IAccessControl(registry).hasRole(SKIPPED_ASSET_ROLE, asset)) {
                continue;
            }

            IvToken vToken = IvToken(IvTokenFactory(vTokenFactory).vTokenOf(asset));
            uint indexAssetBalance = vToken.balanceOf(address(this));
            uint accountBalance = (value * indexAssetBalance) / totalSupply();
            if (accountBalance == 0) {
                continue;
            }

            // calculate index value in vault to be burned
            vToken.transfer(address(vToken), accountBalance);
            vToken.burn(_recipient);
            if (lastOrderId > 0) {
                IOrderer(orderer).reduceOrderAsset(asset, totalSupply() - value, totalSupply());
            }
        }

        _burn(address(this), value);
    }
}",1396
RealWorld_BA_90_FixedPoint112_RealWord_20240826115154.log,90,FixedPoint112,4812,3517,8329,54.0,0.0944,"// SPDX-License-Identifier: GPL-2.0-or-later

pragma solidity >=0.8.7;

/// @title FixedPoint112
/// @notice A library for handling binary fixed point numbers, see https://en.wikipedia.org/wiki/Q_(number_format)
library FixedPoint112 {
    uint8 internal constant RESOLUTION = 112;
    /// @dev 2**112
    uint256 internal constant Q112 = 0x10000000000000000000000000000;
}",102
RealWorld_BA_90_IndexLibrary_RealWord_20240826115100.log,90,IndexLibrary,7121,4575,11696,52.0,0.127105,"// SPDX-License-Identifier: BUSL-1.1

pragma solidity >=0.8.7;

import ""./FullMath.sol"";
import ""./FixedPoint112.sol"";

/// @title Index library
/// @notice Provides various utilities for indexes
library IndexLibrary {
    using FullMath for uint;

    /// @notice Initial index quantity to mint
    uint constant INITIAL_QUANTITY = 10000;

    /// @notice Total assets weight within an index
    uint8 constant MAX_WEIGHT = type(uint8).max;

    /// @notice Returns amount of asset equivalent to the given parameters
    /// @param _assetPerBaseInUQ Asset per base price in UQ
    /// @param _weight Weight of the given asset
    /// @param _amountInBase Total assets amount in base
    /// @return Amount of asset
    function amountInAsset(
        uint _assetPerBaseInUQ,
        uint8 _weight,
        uint _amountInBase
    ) internal pure returns (uint) {
        require(_assetPerBaseInUQ > 0, ""IndexLibrary: ORACLE"");

        return ((_amountInBase * _weight) / MAX_WEIGHT).mulDiv(_assetPerBaseInUQ, FixedPoint112.Q112);
    }
}",263
RealWorld_BA_90_ITopNMarketCapIndexFactory_RealWord_20240826111858.log,90,ITopNMarketCapIndexFactory,4829,4406,9235,58.0,0.112265,"// SPDX-License-Identifier: GPL-2.0-or-later

pragma solidity >=0.8.7;

import ""./IIndexFactory.sol"";

/// @title Top N market capitalization index factory interface
/// @notice Contains logic for top N market capitalization index creation
interface ITopNMarketCapIndexFactory is IIndexFactory {
    /// @notice Market cap categories address
    /// @return Returns market cap categories address
    function marketCapCategories() external view returns (address);
}",101
RealWorld_BA_90_PhutureIndex_RealWord_20240826104625.log,90,PhutureIndex,12083,5278,17361,87.0,0.165975,"// SPDX-License-Identifier: GPL-2.0-or-later

pragma solidity >=0.8.7;

import ""@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol"";
import ""@openzeppelin/contracts/utils/introspection/ERC165.sol"";

import ""./libraries/AUMCalculationLibrary.sol"";

import ""./interfaces/IFeePool.sol"";
import ""./interfaces/INameRegistry.sol"";
import ""./interfaces/IIndexRegistry.sol"";

import ""./IndexLayout.sol"";

/// @title Phuture index
/// @notice Contains AUM fee's logic, overrides name and symbol
abstract contract PhutureIndex is IndexLayout, ERC20Permit, ERC165 {
    constructor() ERC20Permit(""PhutureIndex"") ERC20("""", """") {}

    /// @notice Index symbol
    /// @return Returns index symbol
    function symbol() public view override returns (string memory) {
        return INameRegistry(registry).symbolOfIndex(address(this));
    }

    /// @notice Index name
    /// @return Returns index name
    function name() public view override returns (string memory) {
        return INameRegistry(registry).nameOfIndex(address(this));
    }

    /// @inheritdoc ERC165
    function supportsInterface(bytes4 _interfaceId) public view virtual override returns (bool) {
        return
            _interfaceId == type(IIndexLayout).interfaceId ||
            _interfaceId == type(IERC20Permit).interfaceId ||
            _interfaceId == type(IERC20).interfaceId ||
            super.supportsInterface(_interfaceId);
    }

    /// @dev Overrides _transfer to include AUM fee logic
    function _transfer(
        address _from,
        address _to,
        uint _value
    ) internal override {
        _chargeAUMFee(IIndexRegistry(registry).feePool());
        super._transfer(_from, _to, _value);
    }

    /// @notice Calculates and mints AUM fee
    /// @param _feePool Fee pool address
    function _chargeAUMFee(address _feePool) internal {
        uint timePassed = block.timestamp - lastTransferTime;
        if (timePassed > 0) {
            uint fee = ((totalSupply() - balanceOf(factory)) *
                (AUMCalculationLibrary.rpow(
                    IFeePool(_feePool).AUMScaledPerSecondsRateOf(address(this)),
                    timePassed,
                    AUMCalculationLibrary.RATE_SCALE_BASE
                ) - AUMCalculationLibrary.RATE_SCALE_BASE)) / AUMCalculationLibrary.RATE_SCALE_BASE;

            if (fee > 0) {
                super._mint(factory, fee);
                lastTransferTime = block.timestamp;
            }
        }
    }
}",567
RealWorld_BA_90_FixedPoint112_RealWord_20240826105747.log,90,FixedPoint112,4819,3713,8532,60.0,0.098355,"// SPDX-License-Identifier: GPL-2.0-or-later

pragma solidity >=0.8.7;

/// @title FixedPoint112
/// @notice A library for handling binary fixed point numbers, see https://en.wikipedia.org/wiki/Q_(number_format)
library FixedPoint112 {
    uint8 internal constant RESOLUTION = 112;
    /// @dev 2**112
    uint256 internal constant Q112 = 0x10000000000000000000000000000;
}",102
RealWorld_BA_90_FullMath_RealWord_20240826115250.log,90,FullMath,23400,5053,28453,65.0,0.21806,"// SPDX-License-Identifier: MIT
pragma solidity >=0.8.4 <0.9.0;

/// @title Contains 512-bit math functions
/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision
/// @dev Handles ""phantom overflow"" i.e., allows multiplication and division where an intermediate value overflows 256 bits
library FullMath {
    /// @notice Calculates floor(abdenominator) with full precision. Throws if result overflows a uint256 or denominator == 0
    /// @param a The multiplicand
    /// @param b The multiplier
    /// @param denominator The divisor
    /// @return result The 256-bit result
    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv
    function mulDiv(
        uint256 a,
        uint256 b,
        uint256 denominator
    ) internal pure returns (uint256 result) {
        unchecked {
            // 512-bit multiply [prod1 prod0] = a * b
            // Compute the product mod 2**256 and mod 2**256 - 1
            // then use the Chinese Remainder Theorem to reconstruct
            // the 512 bit result. The result is stored in two 256
            // variables such that product = prod1 * 2**256 + prod0
            uint256 prod0; // Least significant 256 bits of the product
            uint256 prod1; // Most significant 256 bits of the product
            assembly {
                let mm := mulmod(a, b, not(0))
                prod0 := mul(a, b)
                prod1 := sub(sub(mm, prod0), lt(mm, prod0))
            }

            // Handle non-overflow cases, 256 by 256 division
            if (prod1 == 0) {
                require(denominator > 0);
                assembly {
                    result := div(prod0, denominator)
                }
                return result;
            }

            // Make sure the result is less than 2**256.
            // Also prevents denominator == 0
            require(denominator > prod1);

            ///////////////////////////////////////////////
            // 512 by 256 division.
            ///////////////////////////////////////////////

            // Make division exact by subtracting the remainder from [prod1 prod0]
            // Compute remainder using mulmod
            uint256 remainder;
            assembly {
                remainder := mulmod(a, b, denominator)
            }
            // Subtract 256 bit number from 512 bit number
            assembly {
                prod1 := sub(prod1, gt(remainder, prod0))
                prod0 := sub(prod0, remainder)
            }

            // Factor powers of two out of denominator
            // Compute largest power of two divisor of denominator.
            // Always >= 1.
            uint256 twos = (~denominator + 1) & denominator;
            // Divide denominator by power of two
            assembly {
                denominator := div(denominator, twos)
            }

            // Divide [prod1 prod0] by the factors of two
            assembly {
                prod0 := div(prod0, twos)
            }
            // Shift in bits from prod1 into prod0. For this we need
            // to flip `twos` such that it is 2**256 / twos.
            // If twos is zero, then it becomes one
            assembly {
                twos := add(div(sub(0, twos), twos), 1)
            }
            prod0 |= prod1 * twos;

            // Invert denominator mod 2**256
            // Now that denominator is an odd number, it has an inverse
            // modulo 2**256 such that denominator * inv = 1 mod 2**256.
            // Compute the inverse by starting with a seed that is correct
            // correct for four bits. That is, denominator * inv = 1 mod 2**4
            uint256 inv = (3 * denominator) ^ 2;
            // Now use Newton-Raphson iteration to improve the precision.
            // Thanks to Hensel's lifting lemma, this also works in modular
            // arithmetic, doubling the correct bits in each step.
            inv *= 2 - denominator * inv; // inverse mod 2**8
            inv *= 2 - denominator * inv; // inverse mod 2**16
            inv *= 2 - denominator * inv; // inverse mod 2**32
            inv *= 2 - denominator * inv; // inverse mod 2**64
            inv *= 2 - denominator * inv; // inverse mod 2**128
            inv *= 2 - denominator * inv; // inverse mod 2**256

            // Because the division is now exact we can divide by multiplying
            // with the modular inverse of denominator. This will give us the
            // correct result modulo 2**256. Since the precoditions guarantee
            // that the outcome is less than 2**256, this is the final result.
            // We don't need to compute the high bits of the result and prod1
            // is no longer required.
            result = prod0 * inv;
            return result;
        }
    }

    /// @notice Calculates ceil(abdenominator) with full precision. Throws if result overflows a uint256 or denominator == 0
    /// @param a The multiplicand
    /// @param b The multiplier
    /// @param denominator The divisor
    /// @return result The 256-bit result
    function mulDivRoundingUp(
        uint256 a,
        uint256 b,
        uint256 denominator
    ) internal pure returns (uint256 result) {
        unchecked {
            result = mulDiv(a, b, denominator);
            if (mulmod(a, b, denominator) > 0) {
                require(result < type(uint256).max);
                result++;
            }
        }
    }
}",1258
RealWorld_BA_90_ChainlinkPriceOracle_RealWord_20240826114004.log,90,ChainlinkPriceOracle,17786,5334,23120,85.0,0.19561,"// SPDX-License-Identifier: GPL-2.0-or-later

pragma solidity >=0.8.7;

import ""@openzeppelin/contracts/access/IAccessControl.sol"";
import ""@openzeppelin/contracts/utils/introspection/ERC165.sol"";
import ""@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol"";
import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV2V3Interface.sol"";

import ""./libraries/FullMath.sol"";
import ""./libraries/FixedPoint112.sol"";

import ""./interfaces/IChainlinkPriceOracle.sol"";

/// @title Chainlink price oracle
/// @notice Contains logic for getting asset's price from Chainlink data feed
/// @dev Oracle works through base asset which is set in initialize function
contract ChainlinkPriceOracle is IChainlinkPriceOracle, ERC165 {
    using FullMath for uint;

    struct AssetInfo {
        AggregatorV2V3Interface aggregator;
        uint8 answerDecimals;
        uint8 decimals;
        uint lastAssetPerBaseInUQ;
    }

    /// @notice Role allows configure asset related data/components
    bytes32 private constant ASSET_MANAGER_ROLE = keccak256(""ASSET_MANAGER_ROLE"");

    /// @notice Index registry address
    IAccessControl private immutable registry;

    /// @notice Chainlink aggregator for the base asset
    AggregatorV2V3Interface private immutable baseAggregator;

    /// @notice Number of decimals in base asset answer
    uint8 private immutable baseDecimals;

    /// @notice Number of decimals in base asset answer
    uint8 private immutable baseAnswerDecimals;

    /// @notice Infos of added assets
    mapping(address => AssetInfo) private assetInfoOf;

    constructor(
        address _registry,
        address _base,
        address _baseAggregator
    ) {
        require(_baseAggregator != address(0) && _base != address(0), ""ChainlinkPriceOracle: ZERO"");

        registry = IAccessControl(_registry);
        baseAnswerDecimals = AggregatorV2V3Interface(_baseAggregator).decimals();
        baseDecimals = IERC20Metadata(_base).decimals();
        baseAggregator = AggregatorV2V3Interface(_baseAggregator);
    }

    /// @inheritdoc IChainlinkPriceOracle
    function addAsset(address _asset, address _assetAggregator) external override {
        require(registry.hasRole(ASSET_MANAGER_ROLE, msg.sender), ""ChainlinkPriceOracle: FORBIDDEN"");
        require(_asset != address(0), ""ChainlinkPriceOracle: ZERO"");

        assetInfoOf[_asset] = AssetInfo({
            aggregator: AggregatorV2V3Interface(_assetAggregator),
            answerDecimals: AggregatorV2V3Interface(_assetAggregator).decimals(),
            decimals: IERC20Metadata(_asset).decimals(),
            lastAssetPerBaseInUQ: 0
        });

        refreshedAssetPerBaseInUQ(_asset);
    }

    /// @inheritdoc IPriceOracle
    function lastAssetPerBaseInUQ(address _asset) external view override returns (uint) {
        return assetInfoOf[_asset].lastAssetPerBaseInUQ;
    }

    /// @inheritdoc IPriceOracle
    function refreshedAssetPerBaseInUQ(address _asset) public override returns (uint) {
        AssetInfo storage assetInfo = assetInfoOf[_asset];

        (, int basePrice, , , ) = baseAggregator.latestRoundData();
        (, int quotePrice, , , ) = assetInfo.aggregator.latestRoundData();

        require(basePrice > 0 && quotePrice > 0, ""ChainlinkPriceOracle: NEGATIVE"");

        uint assetPerBaseInUQ = ((uint(basePrice) * 10**assetInfo.decimals).mulDiv(
            FixedPoint112.Q112,
            (uint(quotePrice) * 10**baseDecimals)
        ) * 10**assetInfo.answerDecimals) / 10**baseAnswerDecimals;
        assetInfo.lastAssetPerBaseInUQ = assetPerBaseInUQ;
        return assetPerBaseInUQ;
    }

    /// @inheritdoc ERC165
    function supportsInterface(bytes4 _interfaceId) public view virtual override returns (bool) {
        return
            _interfaceId == type(IChainlinkPriceOracle).interfaceId ||
            _interfaceId == type(IPriceOracle).interfaceId ||
            super.supportsInterface(_interfaceId);
    }
}",942
RealWorld_BA_90_IIndexFactory_RealWord_20240826120408.log,90,IIndexFactory,5656,3463,9119,50.0,0.09754,"// SPDX-License-Identifier: GPL-2.0-or-later

pragma solidity >=0.8.7;

/// @title Index factory interface
/// @notice Contains logic for initial fee management for indexes which will be created by this factory
interface IIndexFactory {
    struct NameDetails {
        string name;
        string symbol;
    }

    /// @notice Index registry address
    /// @return Returns index registry address
    function registry() external view returns (address);

    /// @notice vTokenFactory address
    /// @return Returns vTokenFactory address
    function vTokenFactory() external view returns (address);

    /// @notice Reweighting logic address
    /// @return Returns reweighting logic address
    function reweightingLogic() external view returns (address);
}",162
RealWorld_BA_90_IIndex_RealWord_20240826110524.log,90,IIndex,6868,5128,11996,66.0,0.1369,"// SPDX-License-Identifier: GPL-2.0-or-later

pragma solidity >=0.8.7;

import ""./IIndexLayout.sol"";
import ""./IAnatomyUpdater.sol"";

/// @title Index interface
/// @notice Interface containing basic logic for indexes: mint, burn, anatomy info
interface IIndex is IIndexLayout, IAnatomyUpdater {
    /// @notice Index minting
    /// @param _recipient Recipient address
    function mint(address _recipient) external;

    /// @notice Index burning
    /// @param _recipient Recipient address
    function burn(address _recipient) external;

    /// @notice Returns index assets weights information
    /// @return _assets Assets list
    /// @return _weights List of assets corresponding weights
    function anatomy() external view returns (address[] memory _assets, uint8[] memory _weights);

    /// @notice Returns inactive assets
    /// @return _assets Assets list
    function inactiveAnatomy() external view returns (address[] memory _assets);
}",213
RealWorld_BA_90_IOrderer_RealWord_20240826121228.log,90,IOrderer,8819,5388,14207,62.0,0.151855,"// SPDX-License-Identifier: GPL-2.0-or-later

pragma solidity >=0.8.7;

import ""./IvToken.sol"";
import ""./IPhuturePriceOracle.sol"";

/// @title Orderer interface
/// @notice Describes methods for reweigh execution, order creation and execution
interface IOrderer {
    enum OrderSide {
        Sell,
        Buy
    }

    /// @notice Places order to orderer queue and returns order id
    /// @return Order id of the placed order
    function placeOrder() external returns (uint);

    /// @notice Fulfills specified order with order details
    /// @param _orderId Order id to fulfill
    /// @param _asset Asset address to be exchanged
    /// @param _shares Amount of asset to be exchanged
    /// @param _side Order side: buy or sell
    function addOrderDetails(
        uint _orderId,
        address _asset,
        uint _shares,
        OrderSide _side
    ) external;

    /// @notice Updates asset amount for the latest order placed by the sender
    /// @param _asset Asset to change amount for
    /// @param _newTotalSupply New amount value
    /// @param _oldTotalSupply Old amount value
    function reduceOrderAsset(
        address _asset,
        uint _newTotalSupply,
        uint _oldTotalSupply
    ) external;

    /// @notice Returns last order id of the given account
    /// @param _account Account to get last order for
    /// @return Last order id of the given account
    function lastOrderIdOf(address _account) external view returns (uint);
}",344
RealWorld_BA_90_INameRegistry_RealWord_20240826120013.log,90,INameRegistry,5432,3995,9427,58.0,0.10706,"// SPDX-License-Identifier: GPL-2.0-or-later

pragma solidity >=0.8.7;

/// @title Name registry interface
/// @notice Providing information about index names and symbols
interface INameRegistry {
    /// @notice Returns name of the given index
    /// @param _index Index address
    /// @return Index name
    function nameOfIndex(address _index) external view returns (string memory);

    /// @notice Returns symbol of the given index
    /// @param _index Index address
    /// @return Index symbol
    function symbolOfIndex(address _index) external view returns (string memory);
}",133
RealWorld_BA_90_IIndexLayout_RealWord_20240826120214.log,90,IIndexLayout,5087,3410,8497,52.0,0.093635,"// SPDX-License-Identifier: GPL-2.0-or-later

pragma solidity >=0.8.7;

/// @title Index layout interface
/// @notice Contains storage layout of index
interface IIndexLayout {
    /// @notice Index factory address
    /// @return Returns index factory address
    function factory() external view returns (address);

    /// @notice vTokenFactory address
    /// @return Returns vTokenFactory address
    function vTokenFactory() external view returns (address);

    /// @notice Registry address
    /// @return Returns registry address
    function registry() external view returns (address);
}",128
RealWorld_BA_90_IIndexLogic_RealWord_20240826120815.log,90,IIndexLogic,4494,3567,8061,58.0,0.09381,"// SPDX-License-Identifier: GPL-2.0-or-later

pragma solidity >=0.8.7;

/// @title Index logic interface
/// @notice Contains mint and burn logic
interface IIndexLogic {
    /// @notice Index minting
    /// @param _recipient Recipient address
    function mint(address _recipient) external;

    /// @notice Index burning
    /// @param _recipient Recipient address
    function burn(address _recipient) external;
}",98
RealWorld_BA_90_IIndexLayout_RealWord_20240826110843.log,90,IIndexLayout,4748,3802,8550,56.0,0.09978,"// SPDX-License-Identifier: GPL-2.0-or-later

pragma solidity >=0.8.7;

/// @title Index layout interface
/// @notice Contains storage layout of index
interface IIndexLayout {
    /// @notice Index factory address
    /// @return Returns index factory address
    function factory() external view returns (address);

    /// @notice vTokenFactory address
    /// @return Returns vTokenFactory address
    function vTokenFactory() external view returns (address);

    /// @notice Registry address
    /// @return Returns registry address
    function registry() external view returns (address);
}",128
RealWorld_BA_90_FullMath_RealWord_20240826105849.log,90,FullMath,23361,5500,28861,79.0,0.226805,"// SPDX-License-Identifier: MIT
pragma solidity >=0.8.4 <0.9.0;

/// @title Contains 512-bit math functions
/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision
/// @dev Handles ""phantom overflow"" i.e., allows multiplication and division where an intermediate value overflows 256 bits
library FullMath {
    /// @notice Calculates floor(abdenominator) with full precision. Throws if result overflows a uint256 or denominator == 0
    /// @param a The multiplicand
    /// @param b The multiplier
    /// @param denominator The divisor
    /// @return result The 256-bit result
    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv
    function mulDiv(
        uint256 a,
        uint256 b,
        uint256 denominator
    ) internal pure returns (uint256 result) {
        unchecked {
            // 512-bit multiply [prod1 prod0] = a * b
            // Compute the product mod 2**256 and mod 2**256 - 1
            // then use the Chinese Remainder Theorem to reconstruct
            // the 512 bit result. The result is stored in two 256
            // variables such that product = prod1 * 2**256 + prod0
            uint256 prod0; // Least significant 256 bits of the product
            uint256 prod1; // Most significant 256 bits of the product
            assembly {
                let mm := mulmod(a, b, not(0))
                prod0 := mul(a, b)
                prod1 := sub(sub(mm, prod0), lt(mm, prod0))
            }

            // Handle non-overflow cases, 256 by 256 division
            if (prod1 == 0) {
                require(denominator > 0);
                assembly {
                    result := div(prod0, denominator)
                }
                return result;
            }

            // Make sure the result is less than 2**256.
            // Also prevents denominator == 0
            require(denominator > prod1);

            ///////////////////////////////////////////////
            // 512 by 256 division.
            ///////////////////////////////////////////////

            // Make division exact by subtracting the remainder from [prod1 prod0]
            // Compute remainder using mulmod
            uint256 remainder;
            assembly {
                remainder := mulmod(a, b, denominator)
            }
            // Subtract 256 bit number from 512 bit number
            assembly {
                prod1 := sub(prod1, gt(remainder, prod0))
                prod0 := sub(prod0, remainder)
            }

            // Factor powers of two out of denominator
            // Compute largest power of two divisor of denominator.
            // Always >= 1.
            uint256 twos = (~denominator + 1) & denominator;
            // Divide denominator by power of two
            assembly {
                denominator := div(denominator, twos)
            }

            // Divide [prod1 prod0] by the factors of two
            assembly {
                prod0 := div(prod0, twos)
            }
            // Shift in bits from prod1 into prod0. For this we need
            // to flip `twos` such that it is 2**256 / twos.
            // If twos is zero, then it becomes one
            assembly {
                twos := add(div(sub(0, twos), twos), 1)
            }
            prod0 |= prod1 * twos;

            // Invert denominator mod 2**256
            // Now that denominator is an odd number, it has an inverse
            // modulo 2**256 such that denominator * inv = 1 mod 2**256.
            // Compute the inverse by starting with a seed that is correct
            // correct for four bits. That is, denominator * inv = 1 mod 2**4
            uint256 inv = (3 * denominator) ^ 2;
            // Now use Newton-Raphson iteration to improve the precision.
            // Thanks to Hensel's lifting lemma, this also works in modular
            // arithmetic, doubling the correct bits in each step.
            inv *= 2 - denominator * inv; // inverse mod 2**8
            inv *= 2 - denominator * inv; // inverse mod 2**16
            inv *= 2 - denominator * inv; // inverse mod 2**32
            inv *= 2 - denominator * inv; // inverse mod 2**64
            inv *= 2 - denominator * inv; // inverse mod 2**128
            inv *= 2 - denominator * inv; // inverse mod 2**256

            // Because the division is now exact we can divide by multiplying
            // with the modular inverse of denominator. This will give us the
            // correct result modulo 2**256. Since the precoditions guarantee
            // that the outcome is less than 2**256, this is the final result.
            // We don't need to compute the high bits of the result and prod1
            // is no longer required.
            result = prod0 * inv;
            return result;
        }
    }

    /// @notice Calculates ceil(abdenominator) with full precision. Throws if result overflows a uint256 or denominator == 0
    /// @param a The multiplicand
    /// @param b The multiplier
    /// @param denominator The divisor
    /// @return result The 256-bit result
    function mulDivRoundingUp(
        uint256 a,
        uint256 b,
        uint256 denominator
    ) internal pure returns (uint256 result) {
        unchecked {
            result = mulDiv(a, b, denominator);
            if (mulmod(a, b, denominator) > 0) {
                require(result < type(uint256).max);
                result++;
            }
        }
    }
}",1258
RealWorld_BA_90_IFeePool_RealWord_20240826112603.log,90,IFeePool,6193,4910,11103,83.0,0.129165,"// SPDX-License-Identifier: GPL-2.0-or-later

pragma solidity >=0.8.7;

/// @title Fee pool interface
/// @notice Provides methods for fee management
interface IFeePool {
    /// @notice Minting fee in base point format
    /// @return Returns minting fee in base point (BP) format
    function mintingFeeInBPOf(address _index) external view returns (uint16);

    /// @notice Burning fee in base point format
    /// @return Returns burning fee in base point (BP) format
    function burningFeeInBPOf(address _index) external view returns (uint16);

    /// @notice AUM scaled per seconds rate
    /// @return Returns AUM scaled per seconds rate
    function AUMScaledPerSecondsRateOf(address _index) external view returns (uint);
}",180
RealWorld_BA_90_TrackedIndexReweightingLogic_RealWord_20240826103941.log,90,TrackedIndexReweightingLogic,17420,5834,23254,80.0,0.20378,"// SPDX-License-Identifier: BUSL-1.1

pragma solidity >=0.8.7;

import ""@openzeppelin/contracts/access/IAccessControl.sol"";
import ""@openzeppelin/contracts/utils/introspection/ERC165.sol"";

import ""./libraries/IndexLibrary.sol"";

import ""./interfaces/IvToken.sol"";
import ""./interfaces/IOrderer.sol"";
import ""./interfaces/IvTokenFactory.sol"";
import ""./interfaces/IIndexRegistry.sol"";
import ""./interfaces/ITrackedIndexReweightingLogic.sol"";

import ""./IndexLayout.sol"";

/// @title TrackedIndex reweighing logic
/// @notice  Contains reweighing logic
contract TrackedIndexReweightingLogic is IndexLayout, ITrackedIndexReweightingLogic, ERC165 {
    using FullMath for uint;
    using EnumerableSet for EnumerableSet.AddressSet;

    /// @notice Asset role
    bytes32 internal constant ASSET_ROLE = keccak256(""ASSET_ROLE"");

    /// @inheritdoc ITrackedIndexReweightingLogic
    function reweight() external override {
        IPhuturePriceOracle oracle = IPhuturePriceOracle(IIndexRegistry(registry).priceOracle());
        (uint[] memory _capitalizations, uint _totalCapitalization) = IIndexRegistry(registry).marketCapsOf(
            assets.values()
        );
        uint virtualEvaluationInBase;
        uint8 totalWeight;
        uint maxCapitalization = _capitalizations[0];
        address maxCapitalizationAsset = assets.at(0);
        for (uint i; i < assets.length(); ++i) {
            require(IAccessControl(registry).hasRole(ASSET_ROLE, assets.at(i)), ""TrackedIndex: INVALID_ASSET"");

            uint priceAssetPerBaseInUQ = oracle.refreshedAssetPerBaseInUQ(assets.at(i));
            uint availableAssets = IvToken(IvTokenFactory(vTokenFactory).createOrReturnVTokenOf(assets.at(i)))
                .assetBalanceOf(address(this));
            virtualEvaluationInBase += availableAssets.mulDiv(FixedPoint112.Q112, priceAssetPerBaseInUQ);
            address asset = assets.at(i);
            uint8 weight = uint8((_capitalizations[i] * type(uint8).max) / _totalCapitalization);
            if (_capitalizations[i] > maxCapitalization) {
                emit UpdateAnatomy(maxCapitalizationAsset, weightOf[maxCapitalizationAsset]);
                maxCapitalization = _capitalizations[i];
                maxCapitalizationAsset = asset;
            }
            weightOf[asset] = weight;
            totalWeight += weight;
            if (asset != maxCapitalizationAsset) {
                emit UpdateAnatomy(asset, weight);
            }
        }

        if (totalWeight < IndexLibrary.MAX_WEIGHT) {
            weightOf[maxCapitalizationAsset] += IndexLibrary.MAX_WEIGHT - totalWeight;
        }
        emit UpdateAnatomy(maxCapitalizationAsset, weightOf[maxCapitalizationAsset]);

        IOrderer orderer = IOrderer(IIndexRegistry(registry).orderer());
        uint orderId = orderer.placeOrder();

        for (uint i; i < assets.length(); ++i) {
            address asset = assets.at(i);
            uint amountInBase = (virtualEvaluationInBase * weightOf[asset]) / IndexLibrary.MAX_WEIGHT;
            uint amountInAsset = amountInBase.mulDiv(oracle.refreshedAssetPerBaseInUQ(asset), FixedPoint112.Q112);
            (uint newShares, uint oldShares) = IvToken(IvTokenFactory(vTokenFactory).vTokenOf(asset)).shareChange(
                address(this),
                amountInAsset
            );
            if (newShares > oldShares) {
                orderer.addOrderDetails(orderId, asset, newShares - oldShares, IOrderer.OrderSide.Buy);
            } else if (oldShares > newShares) {
                orderer.addOrderDetails(orderId, asset, oldShares - newShares, IOrderer.OrderSide.Sell);
            }
        }
    }

    /// @inheritdoc ERC165
    function supportsInterface(bytes4 _interfaceId) public view virtual override returns (bool) {
        return _interfaceId == type(ITrackedIndexReweightingLogic).interfaceId || super.supportsInterface(_interfaceId);
    }
}",883
RealWorld_BA_90_TrackedIndex_RealWord_20240826113736.log,90,TrackedIndex,13902,6117,20019,69.0,0.19185,"// SPDX-License-Identifier: BUSL-1.1

pragma solidity >=0.8.7;

import ""./interfaces/IIndexFactory.sol"";
import ""./interfaces/IReweightableIndex.sol"";
import ""./interfaces/ITrackedIndexReweightingLogic.sol"";

import ""./BaseIndex.sol"";

/// @title Tracked index
/// @notice  Contains initialization and reweighting logic
contract TrackedIndex is IReweightableIndex, BaseIndex {
    using EnumerableSet for EnumerableSet.AddressSet;

    /// @notice Orderer role
    bytes32 internal constant ORDERER_ROLE = keccak256(""ORDERER_ROLE"");

    constructor() BaseIndex(msg.sender) {}

    /// @notice Initializes index with provided set of parameters
    /// @param _assets Assets list
    /// @param _capitalizations List of corresponding assets capitalizations
    /// @param _totalCapitalization Total capitalization of assets
    function initialize(
        address[] calldata _assets,
        uint[] calldata _capitalizations,
        uint _totalCapitalization
    ) external {
        require(msg.sender == factory, ""TrackedIndex: FORBIDDEN"");

        uint8 totalWeight;
        uint maxCapitalization = _capitalizations[0];
        address maxCapitalizationAsset = _assets[0];
        for (uint i; i < _assets.length; ++i) {
            address asset = _assets[i];
            uint8 weight = uint8((_capitalizations[i] * type(uint8).max) / _totalCapitalization);
            if (_capitalizations[i] > maxCapitalization) {
                emit UpdateAnatomy(maxCapitalizationAsset, weightOf[maxCapitalizationAsset]);
                maxCapitalization = _capitalizations[i];
                maxCapitalizationAsset = asset;
            }
            weightOf[asset] = weight;
            totalWeight += weight;
            assets.add(asset);
            if (asset != maxCapitalizationAsset) {
                emit UpdateAnatomy(asset, weight);
            }
        }
        if (totalWeight < IndexLibrary.MAX_WEIGHT) {
            weightOf[maxCapitalizationAsset] += IndexLibrary.MAX_WEIGHT - totalWeight;
        }
        emit UpdateAnatomy(maxCapitalizationAsset, weightOf[maxCapitalizationAsset]);
    }

    /// @notice Reweighs index assets according to the latest market cap data
    function reweight() external override onlyRole(ORDERER_ROLE) {
        (bool success, bytes memory data) = IIndexFactory(factory).reweightingLogic().delegatecall(
            abi.encodeWithSelector(ITrackedIndexReweightingLogic.reweight.selector)
        );
        if (!success) {
            if (data.length == 0) {
                revert(""TrackedIndex: REWEIGH_FAILED"");
            } else {
                assembly {
                    revert(add(32, data), mload(data))
                }
            }
        }
    }

    /// @inheritdoc ERC165
    function supportsInterface(bytes4 _interfaceId) public view virtual override returns (bool) {
        return _interfaceId == type(IReweightableIndex).interfaceId || super.supportsInterface(_interfaceId);
    }
}",640
RealWorld_BA_90_IvToken_RealWord_20240826115700.log,90,IvToken,19497,5556,25053,63.0,0.208605,"// SPDX-License-Identifier: GPL-2.0-or-later

pragma solidity >=0.8.7;

/// @title Vault token interface
/// @notice Contains logic for index's asset management
interface IvToken {
    struct AssetData {
        uint maxShares;
        uint amountInAsset;
    }

    event VTokenTransfer(address indexed from, address indexed to, uint amount);

    /// @notice Initializes vToken with the given parameters
    /// @param _asset Asset that will be stored
    /// @param _registry Index registry address
    function initialize(address _asset, address _registry) external;

    /// @notice Transfers shares between given accounts
    /// @param _from Account to transfer shares from
    /// @param _to Account to transfer shares to
    /// @param _shares Amount of shares to transfer
    function transferFrom(
        address _from,
        address _to,
        uint _shares
    ) external;

    /// @notice Transfers asset to the given recipient
    /// @dev Method is restricted to orderer
    /// @param _recipient Recipient address
    /// @param _amount Amount to transfer
    function transferAsset(address _recipient, uint _amount) external;

    /// @notice Mints shares for the current sender
    /// @return shares Amount of minted shares
    function mint() external returns (uint shares);

    /// @notice Burns shares for the given recipient and returns assets to the given recipient
    /// @param _recipient Recipient to send assets to
    /// @return amount Amount of sent assets
    function burn(address _recipient) external returns (uint amount);

    /// @notice Transfers shares from the sender to the given recipient
    /// @param _recipient Account to transfer shares to
    /// @param _amount Amount of shares to transfer
    function transfer(address _recipient, uint _amount) external;

    /// @notice Manually synchronizes shares balances
    function sync() external;

    /// @notice Mints shares for the given recipient
    /// @param _recipient Recipient to mint shares for
    /// @return Returns minted shares amount
    function mintFor(address _recipient) external returns (uint);

    /// @notice Burns shares and sends assets to the given recipient
    /// @param _recipient Recipient to send assets to
    /// @return Returns amount of sent assets
    function burnFor(address _recipient) external returns (uint);

    /// @notice Total supply amount: current balance + deposited using vault controller
    /// @return Returns total supply amount
    function totalAssetSupply() external view returns (uint);

    /// @notice Returns mintable amount of shares for given asset's amount
    /// @param _amount Amount of assets to mint shares for
    /// @return Returns amount of shares available for minting
    function mintableShares(uint _amount) external view returns (uint);

    /// @notice Returns amount of assets for the given account with the given shares amount
    /// @return Amount of assets for the given account with the given shares amount
    function assetDataOf(address _account, uint _shares) external view returns (AssetData memory);

    /// @notice Asset balance of the given address
    /// @param _account Address to check balance of
    /// @return Returns asset balance of the given address
    function assetBalanceOf(address _account) external view returns (uint);

    /// @notice Last asset balance for the given address
    /// @param _account Address to check balance of
    /// @return Returns last asset balance for the given address
    function lastAssetBalanceOf(address _account) external view returns (uint);

    /// @notice Last shares balance
    /// @return Returns last shares balance
    function lastBalance() external view returns (uint);

    /// @notice Total shares supply
    /// @return Returns total shares supply
    function totalSupply() external view returns (uint);

    /// @notice Shares balance of the given address
    /// @param _account Address to check balance of
    /// @return Returns shares balance of the given address
    function balanceOf(address _account) external view returns (uint);

    /// @notice Returns the change in shares for a given amount of an asset
    /// @param _account Account to calculate shares for
    /// @param _amountInAsset Amount of asset to calculate shares
    /// @return newShares New shares value
    /// @return oldShares Old shares value
    function shareChange(address _account, uint _amountInAsset) external view returns (uint newShares, uint oldShares);

    /// @notice Stored asset address
    /// @return Returns stored asset address
    function asset() external view returns (address);

    /// @notice Index registry address
    /// @return Returns index registry address
    function registry() external view returns (address);
}",1012
RealWorld_BA_90_IndexLogic_RealWord_20240826113620.log,90,IndexLogic,25820,5879,31699,73.0,0.24668,"// SPDX-License-Identifier: BUSL-1.1

pragma solidity >=0.8.7;

import ""@openzeppelin/contracts/access/IAccessControl.sol"";

import ""./libraries/BP.sol"";
import ""./libraries/IndexLibrary.sol"";

import ""./interfaces/IvToken.sol"";
import ""./interfaces/IOrderer.sol"";
import ""./interfaces/IIndexLogic.sol"";
import ""./interfaces/IvTokenFactory.sol"";
import ""./interfaces/IPhuturePriceOracle.sol"";

import ""./PhutureIndex.sol"";

/// @title Index logic
/// @notice Contains common logic for index minting and burning
contract IndexLogic is PhutureIndex, IIndexLogic {
    using FullMath for uint;
    using EnumerableSet for EnumerableSet.AddressSet;

    /// @notice Asset role
    bytes32 internal constant ASSET_ROLE = keccak256(""ASSET_ROLE"");
    /// @notice Role granted for asset which should be skipped during burning
    bytes32 internal constant SKIPPED_ASSET_ROLE = keccak256(""SKIPPED_ASSET_ROLE"");

    /// @notice Mints index to `_recipient` address
    /// @param _recipient Recipient address
    function mint(address _recipient) external override {
        address feePool = IIndexRegistry(registry).feePool();
        _chargeAUMFee(feePool);

        IPhuturePriceOracle oracle = IPhuturePriceOracle(IIndexRegistry(registry).priceOracle());

        uint lastAssetBalanceInBase;
        uint minAmountInBase = type(uint).max;
        for (uint i; i < assets.length(); ++i) {
            require(IAccessControl(registry).hasRole(ASSET_ROLE, assets.at(i)), ""Index: INVALID_ASSET"");
            if (weightOf[assets.at(i)] == 0) {
                continue;
            }
            uint assetPerBaseInUQ = oracle.refreshedAssetPerBaseInUQ(assets.at(i));
            // Q_b * w_i * p_i = Q_i
            // Q_b = Q_i / (w_i * p_i)
            IvToken vToken = IvToken(IvTokenFactory(vTokenFactory).createOrReturnVTokenOf(assets.at(i)));
            uint amountInAsset = IERC20(assets.at(i)).balanceOf(address(vToken)) - vToken.lastBalance();
            uint weightedPrice = assetPerBaseInUQ * weightOf[assets.at(i)];
            uint _minAmountInBase = amountInAsset.mulDiv(FixedPoint112.Q112 * IndexLibrary.MAX_WEIGHT, weightedPrice);
            if (_minAmountInBase < minAmountInBase) {
                minAmountInBase = _minAmountInBase;
            }
            uint lastBalanceInAsset = vToken.lastAssetBalanceOf(address(this));
            vToken.mint();
            uint balanceInBase = lastBalanceInAsset.mulDiv(FixedPoint112.Q112, assetPerBaseInUQ);
            lastAssetBalanceInBase += balanceInBase;
        }

        for (uint i; i < inactiveAssets.length(); ++i) {
            if (!IAccessControl(registry).hasRole(SKIPPED_ASSET_ROLE, inactiveAssets.at(i))) {
                uint lastBalanceInAsset = IvToken(
                    IvTokenFactory(vTokenFactory).createOrReturnVTokenOf(inactiveAssets.at(i))
                ).lastAssetBalanceOf(address(this));
                lastAssetBalanceInBase += lastBalanceInAsset.mulDiv(
                    FixedPoint112.Q112,
                    oracle.refreshedAssetPerBaseInUQ(inactiveAssets.at(i))
                );
            }
        }

        assert(minAmountInBase != type(uint).max);

        uint value;
        if (totalSupply() != 0) {
            require(lastAssetBalanceInBase > 0, ""Index: INSUFFICIENT_AMOUNT"");
            value =
                (oracle.convertToIndex(minAmountInBase, decimals()) * totalSupply()) /
                oracle.convertToIndex(lastAssetBalanceInBase, decimals());
        } else {
            value = oracle.convertToIndex(minAmountInBase, decimals()) - IndexLibrary.INITIAL_QUANTITY;
            _mint(address(0xdead), IndexLibrary.INITIAL_QUANTITY);
        }

        uint fee = (value * IFeePool(feePool).mintingFeeInBPOf(address(this))) / BP.DECIMAL_FACTOR;
        if (fee > 0) {
            _mint(feePool, fee);
            value -= fee;
        }

        _mint(_recipient, value);
    }

    /// @notice Burns index and transfers assets to `_recipient` address
    /// @param _recipient Recipient address
    function burn(address _recipient) external override {
        uint value = balanceOf(address(this));
        require(value > 0, ""Index: INSUFFICIENT_AMOUNT"");
        uint length = assets.length();

        bool containsBlacklistedAssets;
        for (uint i; i < length; ++i) {
            if (!IAccessControl(registry).hasRole(ASSET_ROLE, assets.at(i))) {
                containsBlacklistedAssets = true;
                break;
            }
        }

        if (!containsBlacklistedAssets) {
            address feePool = IIndexRegistry(registry).feePool();

            uint fee = (value * IFeePool(feePool).burningFeeInBPOf(address(this))) / BP.DECIMAL_FACTOR;

            if (fee > 0) {
                // AUM charged in _transfer method
                _transfer(address(this), feePool, fee);
                value -= fee;
            } else {
                _chargeAUMFee(feePool);
            }
        }

        address orderer = IIndexRegistry(registry).orderer();
        uint lastOrderId = IOrderer(orderer).lastOrderIdOf(address(this));
        for (uint i; i < length + inactiveAssets.length(); ++i) {
            address asset = i < length ? assets.at(i) : inactiveAssets.at(i - length);
            if (containsBlacklistedAssets && IAccessControl(registry).hasRole(SKIPPED_ASSET_ROLE, asset)) {
                continue;
            }

            IvToken vToken = IvToken(IvTokenFactory(vTokenFactory).vTokenOf(asset));
            uint indexAssetBalance = vToken.balanceOf(address(this));
            uint accountBalance = (value * indexAssetBalance) / totalSupply();
            if (accountBalance == 0) {
                continue;
            }

            // calculate index value in vault to be burned
            vToken.transfer(address(vToken), accountBalance);
            vToken.burn(_recipient);
            if (lastOrderId > 0) {
                IOrderer(orderer).reduceOrderAsset(asset, totalSupply() - value, totalSupply());
            }
        }

        _burn(address(this), value);
    }
}",1396
RealWorld_BA_90_IUniswapV2PathPriceOracle_RealWord_20240826111413.log,90,IUniswapV2PathPriceOracle,5531,5005,10536,83.0,0.127755,"// SPDX-License-Identifier: GPL-2.0-or-later

pragma solidity >=0.8.7;

import ""./IPriceOracle.sol"";

/// @title Uniswap path price oracle interface
/// @notice Contains logic for price calculation of asset which doesn't have a pair with a base asset
interface IUniswapV2PathPriceOracle is IPriceOracle {
    /// @notice Returns anatomy data for the current oracle
    /// @return _path List of assets to compose exchange pairs
    /// @return _oracles List of corresponding price oracles for pairs provided by {_path}
    function anatomy() external view returns (address[] calldata _path, address[] calldata _oracles);
}",147
RealWorld_BA_90_PhutureIndex_RealWord_20240826114132.log,90,PhutureIndex,12417,5534,17951,70.0,0.172765,"// SPDX-License-Identifier: GPL-2.0-or-later

pragma solidity >=0.8.7;

import ""@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol"";
import ""@openzeppelin/contracts/utils/introspection/ERC165.sol"";

import ""./libraries/AUMCalculationLibrary.sol"";

import ""./interfaces/IFeePool.sol"";
import ""./interfaces/INameRegistry.sol"";
import ""./interfaces/IIndexRegistry.sol"";

import ""./IndexLayout.sol"";

/// @title Phuture index
/// @notice Contains AUM fee's logic, overrides name and symbol
abstract contract PhutureIndex is IndexLayout, ERC20Permit, ERC165 {
    constructor() ERC20Permit(""PhutureIndex"") ERC20("""", """") {}

    /// @notice Index symbol
    /// @return Returns index symbol
    function symbol() public view override returns (string memory) {
        return INameRegistry(registry).symbolOfIndex(address(this));
    }

    /// @notice Index name
    /// @return Returns index name
    function name() public view override returns (string memory) {
        return INameRegistry(registry).nameOfIndex(address(this));
    }

    /// @inheritdoc ERC165
    function supportsInterface(bytes4 _interfaceId) public view virtual override returns (bool) {
        return
            _interfaceId == type(IIndexLayout).interfaceId ||
            _interfaceId == type(IERC20Permit).interfaceId ||
            _interfaceId == type(IERC20).interfaceId ||
            super.supportsInterface(_interfaceId);
    }

    /// @dev Overrides _transfer to include AUM fee logic
    function _transfer(
        address _from,
        address _to,
        uint _value
    ) internal override {
        _chargeAUMFee(IIndexRegistry(registry).feePool());
        super._transfer(_from, _to, _value);
    }

    /// @notice Calculates and mints AUM fee
    /// @param _feePool Fee pool address
    function _chargeAUMFee(address _feePool) internal {
        uint timePassed = block.timestamp - lastTransferTime;
        if (timePassed > 0) {
            uint fee = ((totalSupply() - balanceOf(factory)) *
                (AUMCalculationLibrary.rpow(
                    IFeePool(_feePool).AUMScaledPerSecondsRateOf(address(this)),
                    timePassed,
                    AUMCalculationLibrary.RATE_SCALE_BASE
                ) - AUMCalculationLibrary.RATE_SCALE_BASE)) / AUMCalculationLibrary.RATE_SCALE_BASE;

            if (fee > 0) {
                super._mint(factory, fee);
                lastTransferTime = block.timestamp;
            }
        }
    }
}",567
RealWorld_BA_90_ITrackedIndexReweightingLogic_RealWord_20240826111746.log,90,ITrackedIndexReweightingLogic,4535,3749,8284,69.0,0.097655,"// SPDX-License-Identifier: GPL-2.0-or-later

pragma solidity >=0.8.7;

import ""./IAnatomyUpdater.sol"";

/// @title TrackedIndex reweighitng logic interface
/// @notice Contains reweighitng logic
interface ITrackedIndexReweightingLogic is IAnatomyUpdater {
    /// @notice Call index reweight process
    function reweight() external;
}",87
RealWorld_BA_90_AUMCalculationLibrary_RealWord_20240826110055.log,90,AUMCalculationLibrary,11906,5113,17019,63.0,0.16179,"// SPDX-License-Identifier: GPL-2.0-or-later

pragma solidity >=0.8.7;

/// @title AUM fee calculation library
/// @notice More details https://github.com/enzymefinance/protocol/blob/b671b3dfea92596dd2e962c73b233dcdb22bf753/contracts/release/utils/MakerDaoMath.sol
/// @dev Taken from https://github.com/enzymefinance/protocol
library AUMCalculationLibrary {
    /// @dev A constant used for AUM fee calculation to prevent underflow
    uint constant RATE_SCALE_BASE = 1e27;

    /// @notice Power function for AUM fee calculation
    /// @param _x Base number
    /// @param _n Exponent number
    /// @param _base Base number multiplier
    /// @return z_ Returns value of `_x` raised to power of `_n`
    function rpow(
        uint _x,
        uint _n,
        uint _base
    ) internal pure returns (uint z_) {
        assembly {
            switch _x
            case 0 {
                switch _n
                case 0 {
                    z_ := _base
                }
                default {
                    z_ := 0
                }
            }
            default {
                switch mod(_n, 2)
                case 0 {
                    z_ := _base
                }
                default {
                    z_ := _x
                }
                let half := div(_base, 2)
                for {
                    _n := div(_n, 2)
                } _n {
                    _n := div(_n, 2)
                } {
                    let xx := mul(_x, _x)
                    if iszero(eq(div(xx, _x), _x)) {
                        revert(0, 0)
                    }
                    let xxRound := add(xx, half)
                    if lt(xxRound, xx) {
                        revert(0, 0)
                    }
                    _x := div(xxRound, _base)
                    if mod(_n, 2) {
                        let zx := mul(z_, _x)
                        if and(iszero(iszero(_x)), iszero(eq(div(zx, _x), z_))) {
                            revert(0, 0)
                        }
                        let zxRound := add(zx, half)
                        if lt(zxRound, zx) {
                            revert(0, 0)
                        }
                        z_ := div(zxRound, _base)
                    }
                }
            }
        }

        return z_;
    }
}",537
RealWorld_BA_90_vToken_RealWord_20240826103600.log,90,vToken,33920,5463,39383,78.0,0.27886,"// SPDX-License-Identifier: BUSL-1.1

pragma solidity >=0.8.7;

import ""@openzeppelin/contracts/utils/math/Math.sol"";
import ""@openzeppelin/contracts/access/IAccessControl.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";
import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/utils/introspection/ERC165CheckerUpgradeable.sol"";

import ""./libraries/BP.sol"";
import ""./libraries/NAV.sol"";

import ""./interfaces/IvToken.sol"";
import ""./interfaces/IIndexRegistry.sol"";

/// @title Vault token
/// @notice Contains logic for index's asset management
contract vToken is IvToken, Initializable, ReentrancyGuardUpgradeable, ERC165Upgradeable {
    using NAV for NAV.Data;
    using SafeERC20 for IERC20;
    using ERC165CheckerUpgradeable for address;

    /// @notice Index role
    bytes32 private constant INDEX_ROLE = keccak256(""INDEX_ROLE"");
    /// @notice Oracle role
    bytes32 private constant ORACLE_ROLE = keccak256(""ORACLE_ROLE"");
    /// @notice Orderer role
    bytes32 private constant ORDERER_ROLE = keccak256(""ORDERER_ROLE"");
    /// @notice Role allows configure reserve related data/components
    bytes32 private constant RESERVE_MANAGER_ROLE = keccak256(""RESERVE_MANAGER_ROLE"");

    /// @inheritdoc IvToken
    address public override asset;
    /// @inheritdoc IvToken
    address public override registry;

    /// @notice NAV library used to track contract shares between indexes
    NAV.Data internal _NAV;

    /// @notice Requires msg.sender to have `_role` role
    /// @param _role Required role
    modifier onlyRole(bytes32 _role) {
        require(IAccessControl(registry).hasRole(_role, msg.sender), ""vToken: FORBIDDEN"");
        _;
    }

    /// @custom:oz-upgrades-unsafe-allow constructor
    constructor() initializer {}

    /// @inheritdoc IvToken
    /// @dev also sets initial values for public variables
    function initialize(address _asset, address _registry) external override initializer {
        bytes4[] memory interfaceIds = new bytes4[](2);
        interfaceIds[0] = type(IAccessControl).interfaceId;
        interfaceIds[1] = type(IIndexRegistry).interfaceId;
        require(_registry.supportsAllInterfaces(interfaceIds), ""vToken: INTERFACE"");
        require(_asset != address(0), ""vToken: ZERO"");

        __ERC165_init();
        __ReentrancyGuard_init();

        asset = _asset;
        registry = _registry;
    }

    /// @inheritdoc IvToken
    function transferAsset(address _recipient, uint _amount) external override nonReentrant {
        require(msg.sender == IIndexRegistry(registry).orderer(), ""vToken: FORBIDDEN"");
        _transferAsset(_recipient, _amount);
    }

    /// @inheritdoc IvToken
    function transfer(address _recipient, uint _amount) external override nonReentrant {
        _transfer(msg.sender, _recipient, _amount);
    }

    /// @inheritdoc IvToken
    function transferFrom(
        address _from,
        address _to,
        uint _shares
    ) external override nonReentrant onlyRole(ORDERER_ROLE) {
        _transfer(_from, _to, _shares);
    }

    /// @inheritdoc IvToken
    function mint() external override nonReentrant onlyRole(INDEX_ROLE) returns (uint shares) {
        return _mint(msg.sender);
    }

    /// @inheritdoc IvToken
    function burn(address _recipient) external override nonReentrant onlyRole(INDEX_ROLE) returns (uint amount) {
        return _burn(_recipient);
    }

    /// @inheritdoc IvToken
    function mintFor(address _recipient) external override nonReentrant onlyRole(ORDERER_ROLE) returns (uint) {
        return _mint(_recipient);
    }

    /// @inheritdoc IvToken
    function burnFor(address _recipient) external override nonReentrant onlyRole(ORDERER_ROLE) returns (uint) {
        return _burn(_recipient);
    }

    /// @inheritdoc IvToken
    function sync() external override nonReentrant {
        _NAV.sync(totalAssetSupply());
    }

    /// @inheritdoc IvToken
    function balanceOf(address _account) external view override returns (uint) {
        return _NAV.balanceOf[_account];
    }

    /// @inheritdoc IvToken
    function lastBalance() external view override returns (uint) {
        return _NAV.lastBalance;
    }

    /// @inheritdoc IvToken
    function mintableShares(uint _amount) external view override returns (uint) {
        return _NAV.mintableShares(_amount);
    }

    /// @inheritdoc IvToken
    function totalSupply() external view override returns (uint) {
        return _NAV.totalSupply;
    }

    /// @inheritdoc IvToken
    function lastAssetBalanceOf(address _account) external view override returns (uint) {
        return _NAV.assetBalanceForShares(_NAV.balanceOf[_account], _NAV.lastBalance);
    }

    /// @inheritdoc IvToken
    function assetBalanceOf(address _account) external view override returns (uint) {
        return _NAV.assetBalanceForShares(_NAV.balanceOf[_account], totalAssetSupply());
    }

    /// @inheritdoc IvToken
    function assetDataOf(address _account, uint _shares) external view override returns (AssetData memory) {
        _shares = Math.min(_shares, _NAV.balanceOf[_account]);
        uint amountInAsset = _NAV.assetBalanceForShares(_shares, totalAssetSupply());
        return AssetData({ maxShares: _shares, amountInAsset: amountInAsset });
    }

    /// @inheritdoc IvToken
    function shareChange(address _account, uint _amountInAsset)
        external
        view
        override
        returns (uint newShares, uint oldShares)
    {
        oldShares = _NAV.balanceOf[_account];
        uint _totalSupply = _NAV.totalSupply;
        if (_totalSupply > 0) {
            uint _balance = _NAV.balanceOf[_account];
            uint _assetBalance = totalAssetSupply();
            uint availableAssets = (_balance * _assetBalance) / _totalSupply;
            newShares = (_amountInAsset * (_totalSupply - oldShares)) / (_assetBalance - availableAssets);
        } else {
            newShares = _amountInAsset < NAV.INITIAL_QUANTITY ? 0 : _amountInAsset - NAV.INITIAL_QUANTITY;
        }
    }

    /// @inheritdoc IvToken
    function totalAssetSupply() public view override returns (uint) {
        return IERC20(asset).balanceOf(address(this));
    }

    /// @inheritdoc ERC165Upgradeable
    function supportsInterface(bytes4 _interfaceId) public view virtual override returns (bool) {
        return _interfaceId == type(IvToken).interfaceId || super.supportsInterface(_interfaceId);
    }

    /// @notice Mints shares to `_recipient` address
    /// @param _recipient Shares recipient
    /// @return shares Amount of minted shares
    function _mint(address _recipient) internal returns (uint shares) {
        uint _totalAssetSupply = totalAssetSupply();
        shares = _NAV.mint(_totalAssetSupply, _recipient);
        _NAV.sync(_totalAssetSupply);
        emit VTokenTransfer(address(0), _recipient, shares);
    }

    /// @notice Burns shares from `_recipient` address
    /// @param _recipient Recipient of assets from burnt shares
    /// @return amount Amount of asset for burnt shares
    function _burn(address _recipient) internal returns (uint amount) {
        uint shares = _NAV.balanceOf[address(this)];
        amount = _NAV.burn(totalAssetSupply());
        _transferAsset(_recipient, amount);
        _NAV.sync(totalAssetSupply());
        emit VTokenTransfer(_recipient, address(0), shares);
    }

    /// @notice Transfers `_amount` of shares from one address to another
    /// @param _from Address to transfer shares from
    /// @param _to Address to transfer shares to
    /// @param _amount Amount of shares to transfer
    function _transfer(
        address _from,
        address _to,
        uint _amount
    ) internal {
        _NAV.transfer(_from, _to, _amount);
        emit VTokenTransfer(_from, _to, _amount);
    }

    /// @notice Transfers `_amount` of asset to `_recipient` address
    /// @param _recipient Recipient of assets
    /// @param _amount Amount of assets to transfer
    function _transferAsset(address _recipient, uint _amount) internal {
        uint balance = IERC20(asset).balanceOf(address(this));
        IERC20(asset).safeTransfer(_recipient, Math.min(_amount, balance));
    }

    uint256[42] private __gap;
}",1936
RealWorld_BA_90_IManagedIndexReweightingLogic_RealWord_20240826110420.log,90,IManagedIndexReweightingLogic,5220,4140,9360,62.0,0.1089,"// SPDX-License-Identifier: GPL-2.0-or-later

pragma solidity >=0.8.7;

import ""./IAnatomyUpdater.sol"";

/// @title ManagedIndex reweighing logic interface
/// @notice Contains reweighing logic
interface IManagedIndexReweightingLogic is IAnatomyUpdater {
    /// @notice Updates index anatomy with corresponding weights and assets
    /// @param _assets List for new asset(s) for the index
    /// @param _weights List of new asset(s) corresponding weights
    function reweight(address[] calldata _assets, uint8[] calldata _weights) external;
}",131
RealWorld_BA_90_IIndexLogic_RealWord_20240826111539.log,90,IIndexLogic,4616,4096,8712,58.0,0.105,"// SPDX-License-Identifier: GPL-2.0-or-later

pragma solidity >=0.8.7;

/// @title Index logic interface
/// @notice Contains mint and burn logic
interface IIndexLogic {
    /// @notice Index minting
    /// @param _recipient Recipient address
    function mint(address _recipient) external;

    /// @notice Index burning
    /// @param _recipient Recipient address
    function burn(address _recipient) external;
}",98
RealWorld_BA_90_IvTokenFactory_RealWord_20240826110941.log,90,IvTokenFactory,5685,4957,10642,60.0,0.127565,"// SPDX-License-Identifier: GPL-2.0-or-later

pragma solidity >=0.8.7;

/// @title vToken factory interface
/// @notice Contains vToken creation logic
interface IvTokenFactory {
    /// @notice Creates or returns address of previously created vToken for the given asset
    /// @param _asset Asset to create or return vToken for
    function createOrReturnVTokenOf(address _asset) external returns (address);

    /// @notice Returns vToken for the given asset
    /// @param _asset Asset to retrieve vToken for
    /// @return vToken for the given asset
    function vTokenOf(address _asset) external view returns (address);
}",147
RealWorld_BA_90_IPriceOracle_RealWord_20240826110738.log,90,IPriceOracle,5263,4797,10060,63.0,0.122255,"// SPDX-License-Identifier: GPL-2.0-or-later

pragma solidity >=0.8.7;

/// @title Price oracle interface
/// @notice Returns price of single asset in relation to base
interface IPriceOracle {
    /// @notice Updates and returns asset per base
    /// @return Asset per base in UQ
    function refreshedAssetPerBaseInUQ(address _asset) external returns (uint);

    /// @notice Returns last asset per base
    /// @return Asset per base in UQ
    function lastAssetPerBaseInUQ(address _asset) external view returns (uint);
}",129
RealWorld_BA_90_IUniswapV2PriceOracle_RealWord_20240826112220.log,90,IUniswapV2PriceOracle,5988,5114,11102,82.0,0.13222,"// SPDX-License-Identifier: GPL-2.0-or-later

pragma solidity >=0.8.7;

import ""./IPriceOracle.sol"";

/// @title Uniswap price oracle interface
/// @notice Contains logic for price calculation of asset using Uniswap V2 Pair
interface IUniswapV2PriceOracle is IPriceOracle {
    /// @notice Asset0 in the pair
    /// @return Returns address of asset0 in the pair
    function asset0() external view returns (address);

    /// @notice Asset1 in the pair
    /// @return Returns address of asset1 in the pair
    function asset1() external view returns (address);
}",141
RealWorld_BA_90_IChainLinkFeed_RealWord_20240826112838.log,90,IChainLinkFeed,3568,3675,7243,53.0,0.09134,"// SPDX-License-Identifier: GPL-2.0-or-later

pragma solidity >=0.8.7;

interface IChainLinkFeed {
    function latestAnswer() external view returns (int);
}",41
RealWorld_BA_90_BP_RealWord_20240826115358.log,90,BP,4188,3481,7669,51.0,0.09056,"// SPDX-License-Identifier: GPL-2.0-or-later

pragma solidity >=0.8.7;

/// @title Base point library
/// @notice Contains constant used to prevent underflow of math operations
library BP {
    /// @notice Base point number
    /// @dev Used to prevent underflow of math operations
    uint16 constant DECIMAL_FACTOR = 10_000;
}",82
RealWorld_BA_90_ChainlinkPriceOracle_RealWord_20240826104511.log,90,ChainlinkPriceOracle,17893,5701,23594,72.0,0.203485,"// SPDX-License-Identifier: GPL-2.0-or-later

pragma solidity >=0.8.7;

import ""@openzeppelin/contracts/access/IAccessControl.sol"";
import ""@openzeppelin/contracts/utils/introspection/ERC165.sol"";
import ""@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol"";
import ""@chainlink/contracts/src/v0.8/interfaces/AggregatorV2V3Interface.sol"";

import ""./libraries/FullMath.sol"";
import ""./libraries/FixedPoint112.sol"";

import ""./interfaces/IChainlinkPriceOracle.sol"";

/// @title Chainlink price oracle
/// @notice Contains logic for getting asset's price from Chainlink data feed
/// @dev Oracle works through base asset which is set in initialize function
contract ChainlinkPriceOracle is IChainlinkPriceOracle, ERC165 {
    using FullMath for uint;

    struct AssetInfo {
        AggregatorV2V3Interface aggregator;
        uint8 answerDecimals;
        uint8 decimals;
        uint lastAssetPerBaseInUQ;
    }

    /// @notice Role allows configure asset related data/components
    bytes32 private constant ASSET_MANAGER_ROLE = keccak256(""ASSET_MANAGER_ROLE"");

    /// @notice Index registry address
    IAccessControl private immutable registry;

    /// @notice Chainlink aggregator for the base asset
    AggregatorV2V3Interface private immutable baseAggregator;

    /// @notice Number of decimals in base asset answer
    uint8 private immutable baseDecimals;

    /// @notice Number of decimals in base asset answer
    uint8 private immutable baseAnswerDecimals;

    /// @notice Infos of added assets
    mapping(address => AssetInfo) private assetInfoOf;

    constructor(
        address _registry,
        address _base,
        address _baseAggregator
    ) {
        require(_baseAggregator != address(0) && _base != address(0), ""ChainlinkPriceOracle: ZERO"");

        registry = IAccessControl(_registry);
        baseAnswerDecimals = AggregatorV2V3Interface(_baseAggregator).decimals();
        baseDecimals = IERC20Metadata(_base).decimals();
        baseAggregator = AggregatorV2V3Interface(_baseAggregator);
    }

    /// @inheritdoc IChainlinkPriceOracle
    function addAsset(address _asset, address _assetAggregator) external override {
        require(registry.hasRole(ASSET_MANAGER_ROLE, msg.sender), ""ChainlinkPriceOracle: FORBIDDEN"");
        require(_asset != address(0), ""ChainlinkPriceOracle: ZERO"");

        assetInfoOf[_asset] = AssetInfo({
            aggregator: AggregatorV2V3Interface(_assetAggregator),
            answerDecimals: AggregatorV2V3Interface(_assetAggregator).decimals(),
            decimals: IERC20Metadata(_asset).decimals(),
            lastAssetPerBaseInUQ: 0
        });

        refreshedAssetPerBaseInUQ(_asset);
    }

    /// @inheritdoc IPriceOracle
    function lastAssetPerBaseInUQ(address _asset) external view override returns (uint) {
        return assetInfoOf[_asset].lastAssetPerBaseInUQ;
    }

    /// @inheritdoc IPriceOracle
    function refreshedAssetPerBaseInUQ(address _asset) public override returns (uint) {
        AssetInfo storage assetInfo = assetInfoOf[_asset];

        (, int basePrice, , , ) = baseAggregator.latestRoundData();
        (, int quotePrice, , , ) = assetInfo.aggregator.latestRoundData();

        require(basePrice > 0 && quotePrice > 0, ""ChainlinkPriceOracle: NEGATIVE"");

        uint assetPerBaseInUQ = ((uint(basePrice) * 10**assetInfo.decimals).mulDiv(
            FixedPoint112.Q112,
            (uint(quotePrice) * 10**baseDecimals)
        ) * 10**assetInfo.answerDecimals) / 10**baseAnswerDecimals;
        assetInfo.lastAssetPerBaseInUQ = assetPerBaseInUQ;
        return assetPerBaseInUQ;
    }

    /// @inheritdoc ERC165
    function supportsInterface(bytes4 _interfaceId) public view virtual override returns (bool) {
        return
            _interfaceId == type(IChainlinkPriceOracle).interfaceId ||
            _interfaceId == type(IPriceOracle).interfaceId ||
            super.supportsInterface(_interfaceId);
    }
}",942
RealWorld_BA_90_IAnatomyUpdater_RealWord_20240826121551.log,90,IAnatomyUpdater,3999,3460,7459,57.0,0.089195,"// SPDX-License-Identifier: GPL-2.0-or-later

pragma solidity >=0.8.7;

/// @title Anatomy Updater interface
/// @notice Contains event for aatomy update
interface IAnatomyUpdater {
    event UpdateAnatomy(address asset, uint8 weight);
}",60
RealWorld_BA_92_FuseAdmin_RealWord_20240826125300.log,92,FuseAdmin,5803,4144,9947,53.0,0.111895,"// SPDX-License-Identifier: AGPL-3.0-only
pragma solidity 0.8.10;

/// @title Fuse Admin
/// @author Fei Protocol
/// @notice Minimal Fuse Admin interface.
interface FuseAdmin {
    /// @notice Whitelists or blacklists a user from accessing the cTokens in the pool.
    /// @param users The users to whitelist or blacklist.
    /// @param enabled Whether to whitelist or blacklist each user.
    function _setWhitelistStatuses(address[] calldata users, bool[] calldata enabled) external;

    function _deployMarket(
        address underlying,
        address irm,
        string calldata name,
        string calldata symbol,
        address impl,
        bytes calldata data,
        uint256 reserveFactor,
        uint256 adminFee,
        uint256 collateralFactorMantissa
    ) external;
}",177
RealWorld_BA_92_MockCToken_RealWord_20240826124235.log,92,MockCToken,11958,5633,17591,69.0,0.17245,"// SPDX-License-Identifier: AGPL-3.0-only
pragma solidity 0.8.10;

import {ERC20} from ""solmate/tokens/ERC20.sol"";
import {SafeTransferLib} from ""solmate/utils/SafeTransferLib.sol"";
import {FixedPointMathLib} from ""solmate/utils/FixedPointMathLib.sol"";

import {CERC20} from ""../../interfaces/CERC20.sol"";

contract MockCToken is CERC20 {
    using SafeTransferLib for ERC20;
    using FixedPointMathLib for uint256;

    /*///////////////////////////////////////////////////////////////
                              CTOKEN LOGIC
    //////////////////////////////////////////////////////////////*/

    ERC20 public underlying;

    mapping(address => uint256) public override borrowBalanceCurrent;

    function mint(uint256 underlyingAmount) external override returns (uint256) {
        underlying.safeTransferFrom(msg.sender, address(this), underlyingAmount);

        _mint(msg.sender, underlyingAmount.divWadDown(exchangeRateStored()));

        return 0;
    }

    function borrow(uint256 underlyingAmount) external override returns (uint256) {
        borrowBalanceCurrent[msg.sender] += underlyingAmount;

        underlying.safeTransfer(msg.sender, underlyingAmount);

        return 0;
    }

    function repayBorrow(uint256 underlyingAmount) external override returns (uint256) {
        borrowBalanceCurrent[msg.sender] -= underlyingAmount;

        underlying.safeTransferFrom(msg.sender, address(this), underlyingAmount);

        return 0;
    }

    function redeemUnderlying(uint256 underlyingAmount) external override returns (uint256) {
        _burn(msg.sender, underlyingAmount.divWadDown(exchangeRateStored()));

        underlying.safeTransfer(msg.sender, underlyingAmount);

        return 0;
    }

    function repayBorrowBehalf(address user, uint256 underlyingAmount) external override returns (uint256) {
        borrowBalanceCurrent[user] -= underlyingAmount;

        underlying.safeTransferFrom(msg.sender, address(this), underlyingAmount);

        return 0;
    }

    function balanceOfUnderlying(address user) external view override returns (uint256) {
        return balanceOf[user].mulWadDown(exchangeRateStored());
    }

    function exchangeRateStored() public view override returns (uint256) {
        return 10**underlying.decimals();
    }

    /*///////////////////////////////////////////////////////////////
                              CONSTRUCTOR
    //////////////////////////////////////////////////////////////*/

    constructor(ERC20 _underlying)
        ERC20(
            string(abi.encodePacked(""Compound "", _underlying.name())),
            string(abi.encodePacked(""c"", _underlying.symbol)),
            _underlying.decimals()
        )
    {
        underlying = _underlying;
    }
}",541
RealWorld_BA_92_TurboMaster.t_RealWord_20240826123435.log,92,TurboMaster.t,16037,5582,21619,73.0,0.191825,"// SPDX-License-Identifier: AGPL-3.0-only
pragma solidity 0.8.10;

import {ERC20} from ""solmate/tokens/ERC20.sol"";
import {Authority} from ""solmate/auth/Auth.sol"";
import {DSTestPlus} from ""solmate/test/utils/DSTestPlus.sol"";
import {MockERC20} from ""solmate/test/utils/mocks/MockERC20.sol"";

import {MockCToken} from ""./mocks/MockCToken.sol"";
import {MockPriceFeed} from ""./mocks/MockPriceFeed.sol"";
import {MockFuseAdmin} from ""./mocks/MockFuseAdmin.sol"";
import {MockComptroller} from ""./mocks/MockComptroller.sol"";

import {TurboClerk} from ""../modules/TurboClerk.sol"";
import {TurboBooster} from ""../modules/TurboBooster.sol"";

import {TurboSafe} from ""../TurboSafe.sol"";
import {TurboMaster} from ""../TurboMaster.sol"";

contract TurboMasterTest is DSTestPlus {
    TurboMaster master;

    MockFuseAdmin fuseAdmin;

    MockComptroller comptroller;

    MockERC20 fei;

    MockERC20 asset;

    MockCToken mockCToken;

    function setUp() public {
        fei = new MockERC20(""Fei USD"", ""FEI"", 18);

        asset = new MockERC20(""Mock Token"", ""MOCK"", 18);

        fuseAdmin = new MockFuseAdmin();

        comptroller = new MockComptroller(address(fuseAdmin), new MockPriceFeed());

        master = new TurboMaster(comptroller, fei, address(this), Authority(address(0)));

        assertEq(master.getAllSafes().length, 1);
    }

    /*///////////////////////////////////////////////////////////////
                     MODULE CONFIGURATION TESTS
    //////////////////////////////////////////////////////////////*/

    function testSetBooster(TurboBooster booster) public {
        master.setBooster(booster);

        assertEq(address(master.booster()), address(booster));
    }

    function testSetClerk(TurboClerk clerk) public {
        master.setClerk(clerk);

        assertEq(address(master.clerk()), address(clerk));
    }

    /*///////////////////////////////////////////////////////////////
                 DEFAULT AUTHORITY CONFIGURATION TESTS
    //////////////////////////////////////////////////////////////*/

    function testSetDefaultSafeAuthority(Authority authority) public {
        master.setDefaultSafeAuthority(authority);

        assertEq(address(master.defaultSafeAuthority()), address(authority));
    }

    function testCreateSafeWithCustomDefaultSafeAuthority(Authority defaultSafeAuthority) public {
        master.setDefaultSafeAuthority(defaultSafeAuthority);

        comptroller.mapUnderlyingToCToken(asset, new MockCToken(asset));

        (TurboSafe safe, ) = master.createSafe(asset);

        assertEq(address(safe.authority()), address(defaultSafeAuthority));
    }

    /*///////////////////////////////////////////////////////////////
                        SAFE CREATION TESTS
    //////////////////////////////////////////////////////////////*/

    function testFailCreateWithNoCTokenMapped() public {
        master.createSafe(asset);
    }

    function testFailCreateSafeWithInvalidAsset(ERC20 invalidAsset) public {
        if (invalidAsset == asset) revert();

        comptroller.mapUnderlyingToCToken(invalidAsset, new MockCToken(invalidAsset));

        master.createSafe(invalidAsset);
    }

    function testCreateSafe() public {
        comptroller.mapUnderlyingToCToken(asset, new MockCToken(asset));
        (TurboSafe safe, uint256 id) = master.createSafe(asset);

        assertEq(address(safe.asset()), address(asset));
        assertEq(safe.owner(), address(this));
        assertEq(id, 1);

        assertEq(address(master.safes(1)), address(safe));
        assertEq(master.getAllSafes().length, 2);

        assertTrue(fuseAdmin.isWhitelisted(address(safe)));
    }
}",810
RealWorld_BA_92_TurboBooster.t_RealWord_20240826123312.log,92,TurboBooster.t,10285,6251,16536,81.0,0.176445,"// SPDX-License-Identifier: AGPL-3.0-only
pragma solidity 0.8.10;

import {ERC20} from ""solmate/tokens/ERC20.sol"";
import {Authority} from ""solmate/auth/Auth.sol"";
import {ERC4626} from ""solmate/mixins/ERC4626.sol"";
import {DSTestPlus} from ""solmate/test/utils/DSTestPlus.sol"";

import {TurboBooster} from ""../modules/TurboBooster.sol"";

import {TurboSafe} from ""../TurboSafe.sol"";

contract TurboBoosterTest is DSTestPlus {
    TurboBooster booster;

    function setUp() public {
        booster = new TurboBooster(address(this), Authority(address(0)));
    }

    function testCanSafeBoostVault(
        bool frozen,
        ERC20 collateral,
        uint256 boostCapForCollateral,
        ERC4626 vault,
        uint256 boostCapForVault,
        TurboSafe safe,
        uint256 feiAmount,
        uint256 newTotalBoostedForVault,
        uint256 newTotalBoostedAgainstCollateral
    ) public {
        booster.setFreezeStatus(frozen);
        assertBoolEq(booster.frozen(), frozen);

        booster.setBoostCapForCollateral(collateral, boostCapForCollateral);
        assertEq(booster.getBoostCapForCollateral(collateral), boostCapForCollateral);

        booster.setBoostCapForVault(vault, boostCapForVault);
        assertEq(booster.getBoostCapForVault(vault), boostCapForVault);

        assertBoolEq(
            booster.canSafeBoostVault(
                safe,
                collateral,
                vault,
                feiAmount,
                newTotalBoostedForVault,
                newTotalBoostedAgainstCollateral
            ),
            !frozen &&
                boostCapForCollateral >= newTotalBoostedAgainstCollateral &&
                boostCapForVault >= newTotalBoostedForVault
        );
    }
}",410
RealWorld_BA_92_TurboGibber.t_RealWord_20240826123550.log,92,TurboGibber.t,21564,5580,27144,66.0,0.21942,"// SPDX-License-Identifier: AGPL-3.0-only
pragma solidity 0.8.10;

import {Authority} from ""solmate/auth/Auth.sol"";
import {ERC4626} from ""solmate/mixins/ERC4626.sol"";
import {DSTestPlus} from ""solmate/test/utils/DSTestPlus.sol"";
import {MockERC20} from ""solmate/test/utils/mocks/MockERC20.sol"";
import {MockERC4626} from ""solmate/test/utils/mocks/MockERC4626.sol"";
import {MockAuthority} from ""solmate/test/utils/mocks/MockAuthority.sol"";
import {FixedPointMathLib} from ""solmate/utils/FixedPointMathLib.sol"";

import {MockCToken} from ""./mocks/MockCToken.sol"";
import {MockPriceFeed} from ""./mocks/MockPriceFeed.sol"";
import {MockFuseAdmin} from ""./mocks/MockFuseAdmin.sol"";
import {MockComptroller} from ""./mocks/MockComptroller.sol"";

import {TurboClerk} from ""../modules/TurboClerk.sol"";
import {TurboGibber} from ""../modules/TurboGibber.sol"";
import {TurboBooster} from ""../modules/TurboBooster.sol"";

import {TurboSafe} from ""../TurboSafe.sol"";
import {TurboMaster} from ""../TurboMaster.sol"";

contract TurboGibberTest is DSTestPlus {
    using FixedPointMathLib for uint256;

    TurboMaster master;

    TurboBooster booster;

    TurboGibber gibber;

    MockFuseAdmin fuseAdmin;

    MockComptroller comptroller;

    MockERC20 fei;

    MockERC20 asset;

    MockCToken assetCToken;

    MockCToken feiCToken;

    MockERC4626 vault;

    TurboSafe safe;

    function setUp() public {
        fei = new MockERC20(""Fei USD"", ""FEI"", 18);

        asset = new MockERC20(""Mock Token"", ""MOCK"", 18);

        fuseAdmin = new MockFuseAdmin();

        booster = new TurboBooster(address(this), Authority(address(0)));

        comptroller = new MockComptroller(address(fuseAdmin), new MockPriceFeed());

        master = new TurboMaster(comptroller, fei, address(this), new MockAuthority(true));

        assetCToken = new MockCToken(asset);

        comptroller.mapUnderlyingToCToken(asset, assetCToken);

        feiCToken = new MockCToken(fei);

        comptroller.mapUnderlyingToCToken(fei, feiCToken);

        vault = new MockERC4626(fei, ""Mock Fei Vault"", ""mvFEI"");

        master.setBooster(booster);

        (safe, ) = master.createSafe(asset);

        asset.mint(address(this), type(uint256).max);
        asset.approve(address(safe), type(uint256).max);

        gibber = new TurboGibber(master, address(this), Authority(address(0)));
    }

    /*///////////////////////////////////////////////////////////////
                             IMPOUND TESTS
    //////////////////////////////////////////////////////////////*/

    function testImpound(
        uint128 depositAmount,
        uint128 borrowAmount,
        uint128 feiAmount,
        uint128 assetAmount,
        address to
    ) public {
        if (depositAmount == 0) depositAmount = 1;
        if (borrowAmount == 0) borrowAmount = 1;
        if (feiAmount == 0) feiAmount = 1;
        if (assetAmount == 0) assetAmount = 1;

        feiAmount = uint128(bound(feiAmount, 0, borrowAmount));
        assetAmount = uint128(bound(assetAmount, 0, depositAmount));

        safe.deposit(depositAmount, to);

        fei.mint(address(feiCToken), borrowAmount);

        booster.setBoostCapForVault(vault, borrowAmount);
        booster.setBoostCapForCollateral(asset, borrowAmount);

        safe.boost(vault, borrowAmount);

        uint256 preBal = asset.balanceOf(to);

        gibber.impound(safe, feiAmount, assetAmount, to);

        assertEq(feiCToken.borrowBalanceCurrent(address(safe)), borrowAmount - feiAmount);
        assertEq(asset.balanceOf(to), preBal + assetAmount);
        assertEq(safe.assetsOf(address(to)), depositAmount - assetAmount);
    }

    /*///////////////////////////////////////////////////////////////
                          IMPOUND ALL TESTS
    //////////////////////////////////////////////////////////////*/

    function testImpoundAll(
        uint128 depositAmount,
        uint128 borrowAmount,
        address to
    ) public {
        if (depositAmount == 0) depositAmount = 1;
        if (borrowAmount == 0) borrowAmount = 1;

        safe.deposit(depositAmount, to);

        fei.mint(address(feiCToken), borrowAmount);

        booster.setBoostCapForVault(vault, borrowAmount);
        booster.setBoostCapForCollateral(asset, borrowAmount);

        safe.boost(vault, borrowAmount);

        uint256 preBal = asset.balanceOf(to);

        gibber.impoundAll(safe, to);

        assertEq(feiCToken.borrowBalanceCurrent(address(safe)), 0);
        assertEq(asset.balanceOf(to), preBal + depositAmount);
        assertEq(safe.assetsOf(address(to)), 0);
    }
}",1142
RealWorld_BA_92_TurboBooster_RealWord_20240826124609.log,92,TurboBooster,20214,5395,25609,92.0,0.20897,"// SPDX-License-Identifier: AGPL-3.0-only
pragma solidity 0.8.10;

import {ERC20} from ""solmate/tokens/ERC20.sol"";
import {ERC4626} from ""solmate/mixins/ERC4626.sol"";
import {Auth, Authority} from ""solmate/auth/Auth.sol"";

import {TurboSafe} from ""../TurboSafe.sol"";

/// @title Turbo Booster
/// @author Transmissions11
/// @notice Boost authorization module.
contract TurboBooster is Auth {
    /*///////////////////////////////////////////////////////////////
                              CONSTRUCTOR
    //////////////////////////////////////////////////////////////*/

    /// @notice Creates a new Turbo Booster contract.
    /// @param _owner The owner of the Booster.
    /// @param _authority The Authority of the Booster.
    constructor(address _owner, Authority _authority) Auth(_owner, _authority) {}

    /*///////////////////////////////////////////////////////////////
                      GLOBAL FREEZE CONFIGURATION
    //////////////////////////////////////////////////////////////*/

    /// @notice Whether boosting is currently frozen.
    bool public frozen;

    /// @notice Emitted when boosting is frozen or unfrozen.
    /// @param user The user who froze or unfroze boosting.
    /// @param frozen Whether boosting is now frozen.
    event FreezeStatusUpdated(address indexed user, bool frozen);

    /// @notice Sets whether boosting is frozen.
    /// @param freeze Whether boosting will be frozen.
    function setFreezeStatus(bool freeze) external requiresAuth {
        // Update freeze status.
        frozen = freeze;

        emit FreezeStatusUpdated(msg.sender, freeze);
    }

    /*///////////////////////////////////////////////////////////////
                     VAULT BOOST CAP CONFIGURATION
    //////////////////////////////////////////////////////////////*/

    /// @notice Maps Vaults to the cap on the amount of Fei used to boost them.
    mapping(ERC4626 => uint256) public getBoostCapForVault;

    /// @notice Emitted when a Vault's boost cap is updated.
    /// @param vault The Vault who's boost cap was updated.
    /// @param newBoostCap The new boost cap for the Vault.
    event BoostCapUpdatedForVault(address indexed user, ERC4626 indexed vault, uint256 newBoostCap);

    /// @notice Sets a Vault's boost cap.
    /// @param vault The Vault to set the boost cap for.
    /// @param newBoostCap The new boost cap for the Vault.
    function setBoostCapForVault(ERC4626 vault, uint256 newBoostCap) external requiresAuth {
        // Update the boost cap for the Vault.
        getBoostCapForVault[vault] = newBoostCap;

        emit BoostCapUpdatedForVault(msg.sender, vault, newBoostCap);
    }

    /*///////////////////////////////////////////////////////////////
                     COLLATERAL BOOST CAP CONFIGURATION
    //////////////////////////////////////////////////////////////*/

    /// @notice Maps collateral types to the cap on the amount of Fei boosted against them.
    mapping(ERC20 => uint256) public getBoostCapForCollateral;

    /// @notice Emitted when a collateral type's boost cap is updated.
    /// @param collateral The collateral type who's boost cap was updated.
    /// @param newBoostCap The new boost cap for the collateral type.
    event BoostCapUpdatedForCollateral(address indexed user, ERC20 indexed collateral, uint256 newBoostCap);

    /// @notice Sets a collateral type's boost cap.
    /// @param collateral The collateral type to set the boost cap for.
    /// @param newBoostCap The new boost cap for the collateral type.
    function setBoostCapForCollateral(ERC20 collateral, uint256 newBoostCap) external requiresAuth {
        // Update the boost cap for the collateral type.
        getBoostCapForCollateral[collateral] = newBoostCap;

        emit BoostCapUpdatedForCollateral(msg.sender, collateral, newBoostCap);
    }

    /*///////////////////////////////////////////////////////////////
                          AUTHORIZATION LOGIC
    //////////////////////////////////////////////////////////////*/

    /// @notice Returns whether a Safe is authorized to boost a Vault.
    /// @param safe The Safe to check is authorized to boost the Vault.
    /// @param collateral The collateral/asset of the Safe.
    /// @param vault The Vault to check the Safe is authorized to boost.
    /// @param feiAmount The amount of Fei asset to check the Safe is authorized boost the Vault with.
    /// @param newTotalBoostedForVault The total amount of Fei that will boosted to the Vault after boost (if it is not rejected).
    /// @param newTotalBoostedAgainstCollateral The total amount of Fei that will be boosted against the Safe's collateral type after this boost.
    /// @return Whether the Safe is authorized to boost the Vault with the given amount of Fei asset.
    function canSafeBoostVault(
        TurboSafe safe,
        ERC20 collateral,
        ERC4626 vault,
        uint256 feiAmount,
        uint256 newTotalBoostedForVault,
        uint256 newTotalBoostedAgainstCollateral
    ) external view returns (bool) {
        return
            !frozen &&
            getBoostCapForVault[vault] >= newTotalBoostedForVault &&
            getBoostCapForCollateral[collateral] >= newTotalBoostedAgainstCollateral;
    }
}",1066
RealWorld_BA_92_MockFuseAdmin_RealWord_20240826124130.log,92,MockFuseAdmin,6425,5038,11463,63.0,0.132885,"// SPDX-License-Identifier: AGPL-3.0-only
pragma solidity 0.8.10;

import {FuseAdmin} from ""../../interfaces/FuseAdmin.sol"";

contract MockFuseAdmin is FuseAdmin {
    mapping(address => bool) public isWhitelisted;

    function _setWhitelistStatuses(address[] calldata users, bool[] calldata enabled) external {
        for (uint256 i = 0; i < users.length; i++) isWhitelisted[users[i]] = enabled[i];
    }

    function _deployMarket(
        address underlying,
        address irm,
        string calldata name,
        string calldata symbol,
        address impl,
        bytes calldata data,
        uint256 reserveFactor,
        uint256 adminFee,
        uint256 collateralFactorMantissa
    ) external {
        
    }
}",173
RealWorld_BA_92_MockPriceFeed_RealWord_20240826124033.log,92,MockPriceFeed,4904,4354,9258,55.0,0.1116,"// SPDX-License-Identifier: AGPL-3.0-only
pragma solidity 0.8.10;

import {CERC20} from ""../../interfaces/CERC20.sol"";
import {PriceFeed} from ""../../interfaces/PriceFeed.sol"";

contract MockPriceFeed is PriceFeed {
    mapping(CERC20 => uint256) public override getUnderlyingPrice;

    function setUnderlyingPrice(CERC20 cToken, uint256 priceFeed) external {
        getUnderlyingPrice[cToken] = priceFeed;
    }
}",107
RealWorld_BA_92_Integration.t_RealWord_20240826123156.log,92,Integration.t,24630,5669,30299,74.0,0.23653,"// SPDX-License-Identifier: AGPL-3.0-only
pragma solidity 0.8.10;

import ""../deploy/Deployer.sol"";
import {FuseAdmin} from ""../interfaces/FuseAdmin.sol"";
import {DSTestPlus} from ""solmate/test/utils/DSTestPlus.sol"";
import {MockERC20} from ""solmate/test/utils/mocks/MockERC20.sol"";
import {MockERC4626} from ""solmate/test/utils/mocks/MockERC4626.sol"";

import {CERC20} from ""../interfaces/CERC20.sol"";

interface ICore {
    function grantRole(bytes32 role, address to) external;

    function allocateTribe(address to, uint amount) external;
}

contract Integration is DSTestPlus {
    TurboMaster master;
    TurboGibber gibber;
    TurboSavior savior;
    TurboBooster booster;
    MultiRolesAuthority authority;
    Comptroller comptroller;
    FuseAdmin fuseAdmin;

    MockERC4626 strategy;

    ERC20 tribe = ERC20(0xc7283b66Eb1EB5FB86327f08e1B5816b0720212B);
    MockERC20 fei = MockERC20(0x956F47F50A910163D8BF957Cf5846D573E7f87CA);
    CERC20 fFEI = CERC20(0xa837E15471D07a9cf0733B99ba3bD30C369a73F9);

    address constant feiDAOTimelock = 0xd51dbA7a94e1adEa403553A8235C302cEbF41a3c;
    ICore constant core = ICore(0x8d5ED43dCa8C2F7dFB20CF7b53CC7E593635d7b9);

    function setUp() public {
        Deployer deployer = new Deployer();

        master = deployer.master();
        gibber = deployer.gibber();
        savior = deployer.savior();

        booster = master.booster();
        authority = MultiRolesAuthority(address(master.authority()));

        comptroller = master.pool();
        fuseAdmin = FuseAdmin(address(comptroller.admin()));
    
        strategy = new MockERC4626(fei, ""xFEI"", ""xFEI"");

        configurePool();
    }

    function configurePool() public {
        hevm.startPrank(feiDAOTimelock);
        fuseAdmin._deployMarket(
            address(tribe), 
            0xEDE47399e2aA8f076d40DC52896331CBa8bd40f7, 
            ""Turbo Tribe"", 
            ""fTRIBE"", 
            0x67Db14E73C2Dce786B5bbBfa4D010dEab4BBFCF9, 
            new bytes(0), 
            0, 
            0, 
            80e16
        );
        core.grantRole(keccak256(""TRIBAL_CHIEF_ADMIN_ROLE""), address(master));
        
        fei.mint(feiDAOTimelock, 10_000_000e18);

        fei.approve(address(fFEI), 10_000_000e18);
        
        address[] memory users = new address[](1);
        users[0] = feiDAOTimelock;

        bool[] memory enabled = new bool[](1);
        enabled[0] = true;

        fuseAdmin._setWhitelistStatuses(users, enabled);

        require(fFEI.mint(10_000_000e18) == 0, ""mint fails"");

        booster.setBoostCapForCollateral(tribe, 2_000_000e18); // 1M boost cap TRIBE
        booster.setBoostCapForVault(strategy, 2_000_000e18); // 1M boost cap for vault

        core.allocateTribe(address(this), 10_000_000e18);
        hevm.stopPrank();
    }

    function testFailCreationWithoutApproval() public {
        master.createSafe(tribe);
    }

    function testIntegraion() public {
        hevm.prank(authority.owner());
        authority.setPublicCapability(TurboMaster.createSafe.selector, true);

        (TurboSafe safe,) = master.createSafe(tribe);
        
        tribe.approve(address(safe), 2_000_000e18);
        safe.deposit(2_000_000e18, address(this));

        assertEq(safe.balanceOf(address(this)), 2_000_000e18);

        safe.boost(strategy, 100_000e18);

        assertEq(strategy.balanceOf(address(safe)), 100_000e18);

        hevm.prank(feiDAOTimelock);
        fei.mint(address(strategy), 10_000e18);

        require(fei.balanceOf(address(master)) == 0, ""no fei"");
        safe.slurp(strategy);
        require(fei.balanceOf(address(master)) == 9000e18, ""master slurps"");

        safe.less(strategy, 101_000e18);

        require(strategy.balanceOf(address(safe)) == 0, ""Safe empty"");

        safe.redeem(2_000_000e18, address(this), address(this));

        assertEq(safe.balanceOf(address(safe)), 0);
    }

    function testSavior() public {
        hevm.prank(authority.owner());
        authority.setPublicCapability(TurboMaster.createSafe.selector, true);

        (TurboSafe safe,) = master.createSafe(tribe);
        
        tribe.approve(address(safe), 2_000_000e18);
        safe.deposit(2_000_000e18, address(this));

        assertEq(safe.balanceOf(address(this)), 2_000_000e18);

        safe.boost(strategy, 1_100_000e18);
        require(strategy.balanceOf(address(safe)) == 1_100_000e18);

        savior.save(safe, strategy, 1_000_000e18);

        require(strategy.balanceOf(address(safe)) == 100_000e18);
    }
}",1327
RealWorld_BA_92_CERC20_RealWord_20240826125143.log,92,CERC20,12753,5381,18134,75.0,0.171385,"// SPDX-License-Identifier: AGPL-3.0-only
pragma solidity 0.8.10;

import {ERC20} from ""solmate/tokens/ERC20.sol"";

/// @title CERC20
/// @author Compound Labs and Rari Capital
/// @notice Minimal Compound/Fuse Comptroller interface.
abstract contract CERC20 is ERC20 {
    /// @notice Deposit an amount of underlying tokens to the CERC20.
    /// @param underlyingAmount Amount of underlying tokens to deposit.
    /// @return An error code or zero if there was no error in the deposit.
    function mint(uint256 underlyingAmount) external virtual returns (uint256);

    /// @notice Borrow an amount of underlying tokens from the CERC20.
    /// @param underlyingAmount Amount of underlying tokens to borrow.
    /// @return An error code or zero if there was no error in the borrow.
    function borrow(uint256 underlyingAmount) external virtual returns (uint256);

    /// @notice Repay an amount of underlying tokens to the CERC20.
    /// @param underlyingAmount Amount of underlying tokens to repay.
    /// @return An error code or zero if there was no error in the repay.
    function repayBorrow(uint256 underlyingAmount) external virtual returns (uint256);

    /// @notice Returns the underlying balance of a specific user.
    /// @param user The user who's balance the CERC20 will retrieve.
    /// @return The amount of underlying tokens the user is entitled to.
    function balanceOfUnderlying(address user) external view virtual returns (uint256);

    /// @notice Returns the amount of underlying tokens a cToken redeemable for.
    /// @return The amount of underlying tokens a cToken is redeemable for.
    function exchangeRateStored() external view virtual returns (uint256);

    /// @notice Withdraw a specific amount of underlying tokens from the CERC20.
    /// @param underlyingAmount Amount of underlying tokens to withdraw.
    /// @return An error code or zero if there was no error in the withdraw.
    function redeemUnderlying(uint256 underlyingAmount) external virtual returns (uint256);

    /// @notice Return teh current borrow balance of a user in the CERC20.
    /// @param user The user to get the borrow balance for.
    /// @return The current borrow balance of the user.
    function borrowBalanceCurrent(address user) external virtual returns (uint256);

    /// @notice Repay a user's borrow on their behalf.
    /// @param user The user who's borrow to repay.
    /// @param underlyingAmount The amount of debt to repay.
    /// @return An error code or zero if there was no error in the repayBorrowBehalf.
    function repayBorrowBehalf(address user, uint256 underlyingAmount) external virtual returns (uint256);
}",584
RealWorld_BA_92_PriceFeed_RealWord_20240826125453.log,92,PriceFeed,5611,4758,10369,63.0,0.123215,"// SPDX-License-Identifier: AGPL-3.0-only
pragma solidity 0.8.10;

import {CERC20} from ""./CERC20.sol"";

/// @notice Price Feed
/// @author Compound Labs
/// @notice Minimal cToken price feed interface.
interface PriceFeed {
    /// @notice Get the underlying price of the cToken's asset.
    /// @param cToken The cToken to get the underlying price of.
    /// @return The underlying asset price scaled by 1e18.
    function getUnderlyingPrice(CERC20 cToken) external view returns (uint256);
}",127
RealWorld_BA_92_TurboClerk_RealWord_20240826124916.log,92,TurboClerk,22283,5410,27693,72.0,0.219615,"// SPDX-License-Identifier: AGPL-3.0-only
pragma solidity 0.8.10;

import {ERC20} from ""solmate/tokens/ERC20.sol"";
import {Auth, Authority} from ""solmate/auth/Auth.sol"";

import {TurboSafe} from ""../TurboSafe.sol"";

/// @title Turbo Clerk
/// @author Transmissions11
/// @notice Fee determination module for Turbo Safes.
contract TurboClerk is Auth {
    /*///////////////////////////////////////////////////////////////
                              CONSTRUCTOR
    //////////////////////////////////////////////////////////////*/

    /// @notice Creates a new Turbo Clerk contract.
    /// @param _owner The owner of the Clerk.
    /// @param _authority The Authority of the Clerk.
    constructor(address _owner, Authority _authority) Auth(_owner, _authority) {}

    /*///////////////////////////////////////////////////////////////
                        DEFAULT FEE CONFIGURATION
    //////////////////////////////////////////////////////////////*/

    /// @notice The default fee on Safe interest taken by the protocol.
    /// @dev A fixed point number where 1e18 represents 100% and 0 represents 0%.
    uint256 public defaultFeePercentage;

    /// @notice Emitted when the default fee percentage is updated.
    /// @param newDefaultFeePercentage The new default fee percentage.
    event DefaultFeePercentageUpdated(address indexed user, uint256 newDefaultFeePercentage);

    /// @notice Sets the default fee percentage.
    /// @param newDefaultFeePercentage The new default fee percentage.
    function setDefaultFeePercentage(uint256 newDefaultFeePercentage) external requiresAuth {
        // A fee percentage over 100% makes no sense.
        require(newDefaultFeePercentage <= 1e18, ""FEE_TOO_HIGH"");

        // Update the default fee percentage.
        defaultFeePercentage = newDefaultFeePercentage;

        emit DefaultFeePercentageUpdated(msg.sender, newDefaultFeePercentage);
    }

    /*///////////////////////////////////////////////////////////////
                        CUSTOM FEE CONFIGURATION
    //////////////////////////////////////////////////////////////*/

    /// @notice Maps collaterals to their custom fees on interest taken by the protocol.
    /// @dev A fixed point number where 1e18 represents 100% and 0 represents 0%.
    mapping(ERC20 => uint256) public getCustomFeePercentageForCollateral;

    /// @notice Maps Safes to their custom fees on interest taken by the protocol.
    /// @dev A fixed point number where 1e18 represents 100% and 0 represents 0%.
    mapping(TurboSafe => uint256) public getCustomFeePercentageForSafe;

    /// @notice Emitted when a collateral's custom fee percentage is updated.
    /// @param collateral The collateral who's custom fee percentage was updated.
    /// @param newFeePercentage The new custom fee percentage.
    event CustomFeePercentageUpdatedForCollateral(
        address indexed user,
        ERC20 indexed collateral,
        uint256 newFeePercentage
    );

    /// @notice Sets a collateral's custom fee percentage.
    /// @param collateral The collateral to set the custom fee percentage for.
    /// @param newFeePercentage The new custom fee percentage for the collateral.
    function setCustomFeePercentageForCollateral(ERC20 collateral, uint256 newFeePercentage) external requiresAuth {
        // A fee percentage over 100% makes no sense.
        require(newFeePercentage <= 1e18, ""FEE_TOO_HIGH"");

        // Update the custom fee percentage for the Safe.
        getCustomFeePercentageForCollateral[collateral] = newFeePercentage;

        emit CustomFeePercentageUpdatedForCollateral(msg.sender, collateral, newFeePercentage);
    }

    /// @notice Emitted when a Safe's custom fee percentage is updated.
    /// @param safe The Safe who's custom fee percentage was updated.
    /// @param newFeePercentage The new custom fee percentage.
    event CustomFeePercentageUpdatedForSafe(address indexed user, TurboSafe indexed safe, uint256 newFeePercentage);

    /// @notice Sets a Safe's custom fee percentage.
    /// @param safe The Safe to set the custom fee percentage for.
    /// @param newFeePercentage The new custom fee percentage for the Safe.
    function setCustomFeePercentageForSafe(TurboSafe safe, uint256 newFeePercentage) external requiresAuth {
        // A fee percentage over 100% makes no sense.
        require(newFeePercentage <= 1e18, ""FEE_TOO_HIGH"");

        // Update the custom fee percentage for the Safe.
        getCustomFeePercentageForSafe[safe] = newFeePercentage;

        emit CustomFeePercentageUpdatedForSafe(msg.sender, safe, newFeePercentage);
    }

    /*///////////////////////////////////////////////////////////////
                          ACCOUNTING LOGIC
    //////////////////////////////////////////////////////////////*/

    /// @notice Returns the fee on interest taken by the protocol for a Safe.
    /// @param safe The Safe to get the fee percentage for.
    /// @param collateral The collateral/asset of the Safe.
    /// @return The fee percentage for the Safe.
    function getFeePercentageForSafe(TurboSafe safe, ERC20 collateral) external view returns (uint256) {
        // Get the custom fee percentage for the Safe.
        uint256 customFeePercentageForSafe = getCustomFeePercentageForSafe[safe];

        // If a custom fee percentage is set for the Safe, return it.
        if (customFeePercentageForSafe != 0) return customFeePercentageForSafe;

        // Get the custom fee percentage for the collateral type.
        uint256 customFeePercentageForCollateral = getCustomFeePercentageForCollateral[collateral];

        // If a custom fee percentage is set for the collateral, return it.
        if (customFeePercentageForCollateral != 0) return customFeePercentageForCollateral;

        // Otherwise, return the default fee percentage.
        return defaultFeePercentage;
    }
}",1189
RealWorld_BA_92_Comptroller_RealWord_20240826125030.log,92,Comptroller,10186,5307,15493,71.0,0.15707,"// SPDX-License-Identifier: AGPL-3.0-only
pragma solidity 0.8.10;

import {ERC20} from ""solmate/tokens/ERC20.sol"";

import {CERC20} from ""./CERC20.sol"";
import {PriceFeed} from ""./PriceFeed.sol"";

/// @title Comptroller
/// @author Compound Labs and Rari Capital
/// @notice Minimal Compound/Fuse Comptroller interface.
interface Comptroller {
    /// @notice Retrieves the admin of the Comptroller.
    /// @return The current administrator of the Comptroller.
    function admin() external view returns (address);

    /// @notice Retrieves the price feed of the Comptroller.
    /// @return The current price feed of the Comptroller.
    function oracle() external view returns (PriceFeed);

    /// @notice Maps underlying tokens to their equivalent cTokens in a pool.
    /// @param token The underlying token to find the equivalent cToken for.
    /// @return The equivalent cToken for the given underlying token.
    function cTokensByUnderlying(ERC20 token) external view returns (CERC20);

    /// @notice Get's data about a cToken.
    /// @param cToken The cToken to get data about.
    /// @return isListed Whether the cToken is listed in the Comptroller.
    /// @return collateralFactor The collateral factor of the cToken.

    function markets(CERC20 cToken) external view returns (bool isListed, uint256 collateralFactor);

    /// @notice Enters into a list of cToken markets, enabling them as collateral.
    /// @param cTokens The list of cTokens to enter into, enabling them as collateral.
    /// @return A list of error codes, or 0 if there were no failures in entering the cTokens.
    function enterMarkets(CERC20[] calldata cTokens) external returns (uint256[] memory);
}",405
RealWorld_BA_92_TurboSavior.t_RealWord_20240826123809.log,92,TurboSavior.t,19158,5809,24967,75.0,0.21197,"// SPDX-License-Identifier: AGPL-3.0-only
pragma solidity 0.8.10;

import {Authority} from ""solmate/auth/Auth.sol"";
import {ERC4626} from ""solmate/mixins/ERC4626.sol"";
import {DSTestPlus} from ""solmate/test/utils/DSTestPlus.sol"";
import {MockERC20} from ""solmate/test/utils/mocks/MockERC20.sol"";
import {MockERC4626} from ""solmate/test/utils/mocks/MockERC4626.sol"";
import {MockAuthority} from ""solmate/test/utils/mocks/MockAuthority.sol"";
import {FixedPointMathLib} from ""solmate/utils/FixedPointMathLib.sol"";

import {MockCToken} from ""./mocks/MockCToken.sol"";
import {MockPriceFeed} from ""./mocks/MockPriceFeed.sol"";
import {MockFuseAdmin} from ""./mocks/MockFuseAdmin.sol"";
import {MockComptroller} from ""./mocks/MockComptroller.sol"";

import {TurboClerk} from ""../modules/TurboClerk.sol"";
import {TurboSavior} from ""../modules/TurboSavior.sol"";
import {TurboBooster} from ""../modules/TurboBooster.sol"";

import {TurboSafe} from ""../TurboSafe.sol"";
import {TurboMaster} from ""../TurboMaster.sol"";

contract TurboSaviorTest is DSTestPlus {
    using FixedPointMathLib for uint256;

    TurboMaster master;

    MockPriceFeed oracle;

    TurboBooster booster;

    TurboSavior savior;

    MockFuseAdmin fuseAdmin;

    MockComptroller comptroller;

    MockERC20 fei;

    MockERC20 asset;

    MockCToken assetCToken;

    MockCToken feiCToken;

    MockERC4626 vault;

    TurboSafe safe;

    function setUp() public {
        fei = new MockERC20(""Fei USD"", ""FEI"", 18);

        asset = new MockERC20(""Mock Token"", ""MOCK"", 18);

        fuseAdmin = new MockFuseAdmin();

        booster = new TurboBooster(address(this), Authority(address(0)));

        oracle = new MockPriceFeed();

        comptroller = new MockComptroller(address(fuseAdmin), oracle);

        master = new TurboMaster(comptroller, fei, address(this), new MockAuthority(true));

        assetCToken = new MockCToken(asset);

        comptroller.mapUnderlyingToCToken(asset, assetCToken);

        feiCToken = new MockCToken(fei);

        comptroller.mapUnderlyingToCToken(fei, feiCToken);

        vault = new MockERC4626(fei, ""Mock Fei Vault"", ""mvFEI"");

        master.setBooster(booster);

        (safe, ) = master.createSafe(asset);

        asset.mint(address(this), type(uint256).max);
        asset.approve(address(safe), type(uint256).max);

        savior = new TurboSavior(master, address(this), Authority(address(0)));
    }

    /*///////////////////////////////////////////////////////////////
                              SAVE TESTS
    //////////////////////////////////////////////////////////////*/

    function testSave(
        uint64 depositAmount,
        uint64 borrowAmount,
        uint64 feiAmount,
        address to
    ) public {
        if (depositAmount == 0) depositAmount = 1;
        if (feiAmount == 0) feiAmount = 1;

        borrowAmount = uint64(bound(borrowAmount, 1, depositAmount));
        feiAmount = uint64(bound(feiAmount, 1, borrowAmount));

        safe.deposit(depositAmount, to);

        fei.mint(address(feiCToken), borrowAmount);

        booster.setBoostCapForVault(vault, borrowAmount);
        booster.setBoostCapForCollateral(asset, borrowAmount);

        safe.boost(vault, borrowAmount);

        oracle.setUnderlyingPrice(assetCToken, 2e18);
        oracle.setUnderlyingPrice(feiCToken, 1e18);

        comptroller.setMarket(assetCToken, MockComptroller.Market(true, 0.75e18));

        uint256 borrowLimit = assetCToken.balanceOfUnderlying(address(safe)).mulWadDown(0.75e18).mulWadDown(2e18);

        uint256 debtValue = feiCToken.borrowBalanceCurrent(address(safe)).mulWadUp(1e18);

        if (borrowLimit == 0) return;

        savior.setMinDebtPercentageForSaving(debtValue.divWadUp(borrowLimit));

        savior.save(safe, vault, feiAmount);
    }
}",994
RealWorld_BA_92_TurboSavior_RealWord_20240826124743.log,92,TurboSavior,22515,6185,28700,91.0,0.236275,"// SPDX-License-Identifier: AGPL-3.0-only
pragma solidity 0.8.10;

import {ERC4626} from ""solmate/mixins/ERC4626.sol"";
import {Auth, Authority} from ""solmate/auth/Auth.sol"";
import {ReentrancyGuard} from ""solmate/utils/ReentrancyGuard.sol"";
import {FixedPointMathLib} from ""solmate/utils/FixedPointMathLib.sol"";

import {Fei} from ""../interfaces/Fei.sol"";
import {CERC20} from ""../interfaces/CERC20.sol"";
import {Comptroller} from ""../interfaces/Comptroller.sol"";

import {TurboSafe} from ""../TurboSafe.sol"";
import {TurboMaster} from ""../TurboMaster.sol"";

/// @title Turbo Savior
/// @author Transmissions11
/// @notice Safe repayment module.
contract TurboSavior is Auth, ReentrancyGuard {
    using FixedPointMathLib for uint256;

    /*///////////////////////////////////////////////////////////////
                               IMMUTABLES
    //////////////////////////////////////////////////////////////*/

    /// @notice The Master contract.
    /// @dev Used to validate Safes are legitimate.
    TurboMaster public immutable master;

    /// @notice The Fei token on the network.
    Fei public immutable fei;

    /// @notice The Turbo Fuse Pool used by the Master.
    Comptroller public immutable pool;

    /// @notice The Fei cToken in the Turbo Fuse Pool.
    CERC20 public immutable feiTurboCToken;

    /*///////////////////////////////////////////////////////////////
                              CONSTRUCTOR
    //////////////////////////////////////////////////////////////*/

    /// @notice Creates a new Turbo Savior contract.
    /// @param _master The Master of the Savior.
    /// @param _owner The owner of the Savior.
    /// @param _authority The Authority of the Savior.
    constructor(
        TurboMaster _master,
        address _owner,
        Authority _authority
    ) Auth(_owner, _authority) {
        master = _master;

        fei = Fei(address(master.fei()));

        pool = master.pool();

        feiTurboCToken = pool.cTokensByUnderlying(fei);
    }

    /*///////////////////////////////////////////////////////////////
                              LINE LOGIC
    //////////////////////////////////////////////////////////////*/

    /// @notice The minimum percentage debt must make up of the borrow limit for a Safe to be saved.
    /// @dev A fixed point number where 1e18 represents 100% and 0 represents 0%.
    uint256 public minDebtPercentageForSaving;

    /// @notice Emitted when the minimum debt percentage for saving is updated.
    /// @param newDefaultFeePercentage The new minimum debt percentage for saving.
    event MinDebtPercentageForSavingUpdated(address indexed user, uint256 newDefaultFeePercentage);

    /// @notice Sets the minimum debt percentage.
    /// @param newMinDebtPercentageForSaving The new minimum debt percentage.
    function setMinDebtPercentageForSaving(uint256 newMinDebtPercentageForSaving) external requiresAuth {
        // A minimum debt percentage over 100% makes no sense.
        require(newMinDebtPercentageForSaving <= 1e18, ""PERCENT_TOO_HIGH"");

        // Update the minimum debt percentage.
        minDebtPercentageForSaving = newMinDebtPercentageForSaving;

        emit MinDebtPercentageForSavingUpdated(msg.sender, newMinDebtPercentageForSaving);
    }

    /*///////////////////////////////////////////////////////////////
                              SAVE LOGIC
    //////////////////////////////////////////////////////////////*/

    /// @notice Emitted a save is executed.
    /// @param user The user who executed the save.
    /// @param safe The Safe that was saved.
    /// @param vault The Vault that was lessed.
    /// @param feiAmount The amount of Fei that was lessed.
    event SafeSaved(address indexed user, TurboSafe indexed safe, ERC4626 indexed vault, uint256 feiAmount);

    /// @notice Save a Safe (call less on owner's behalf to prevent liquidation).
    /// @param safe The Safe to be saved.
    /// @param vault The Vault to less from.
    /// @param feiAmount The amount of Fei to less from the Safe.
    function save(
        TurboSafe safe,
        ERC4626 vault,
        uint256 feiAmount
    ) external requiresAuth nonReentrant {
        // Ensure the Safe is registered with the Master.
        require(master.getSafeId(safe) != 0);

        emit SafeSaved(msg.sender, safe, vault, feiAmount);

        // Cache the Safe's collateral asset, saves a warm SLOAD below.
        CERC20 assetTurboCToken = safe.assetTurboCToken();

        // Get the Safe's asset's collateral factor in the Turbo Fuse Pool.
        (, uint256 collateralFactor) = pool.markets(assetTurboCToken);

        // Compute the value of the Safe's collateral. Rounded down to favor saving.
        uint256 borrowLimit = assetTurboCToken
            .balanceOf(address(safe))
            .mulWadDown(assetTurboCToken.exchangeRateStored())
            .mulWadDown(collateralFactor)
            .mulWadDown(pool.oracle().getUnderlyingPrice(assetTurboCToken));

        // Compute the value of the Safe's debt. Rounding up to favor saving them.
        uint256 debtValue = feiTurboCToken.borrowBalanceCurrent(address(safe)).mulWadUp(
            pool.oracle().getUnderlyingPrice(feiTurboCToken)
        );

        // Ensure the Safe's debt percentage is high enough to justify saving, otherwise revert.
        require(
            borrowLimit != 0 && debtValue.divWadUp(borrowLimit) >= minDebtPercentageForSaving,
            ""DEBT_PERCENT_TOO_LOW""
        );

        // Less the Fei from the Safe.
        safe.less(vault, feiAmount);
    }
}",1214
RealWorld_BA_92_TurboMaster_RealWord_20240826122825.log,92,TurboMaster,47749,4947,52696,64.0,0.337685,"// SPDX-License-Identifier: AGPL-3.0-only
pragma solidity 0.8.10;

import {ERC20} from ""solmate/tokens/ERC20.sol"";
import {ERC4626} from ""solmate/mixins/ERC4626.sol"";
import {Auth, Authority} from ""solmate/auth/Auth.sol"";
import {SafeTransferLib} from ""solmate/utils/SafeTransferLib.sol"";

import {FuseAdmin} from ""./interfaces/FuseAdmin.sol"";
import {Comptroller} from ""./interfaces/Comptroller.sol"";

import {TurboClerk} from ""./modules/TurboClerk.sol"";
import {TurboGibber} from ""./modules/TurboGibber.sol"";
import {TurboBooster} from ""./modules/TurboBooster.sol"";

import {TurboSafe} from ""./TurboSafe.sol"";

/// @title Turbo Master
/// @author Transmissions11
/// @notice Factory for creating and managing Turbo Safes.
/// @dev Must be authorized to call the Turbo Fuse Pool's FuseAdmin.
contract TurboMaster is Auth {
    using SafeTransferLib for ERC20;

    /*///////////////////////////////////////////////////////////////
                               IMMUTABLES
    //////////////////////////////////////////////////////////////*/

    /// @notice The Turbo Fuse Pool the Safes will interact with.
    Comptroller public immutable pool;

    /// @notice The Fei token on the network.
    ERC20 public immutable fei;

    /*///////////////////////////////////////////////////////////////
                              CONSTRUCTOR
    //////////////////////////////////////////////////////////////*/

    /// @notice Creates a new Turbo Master contract.
    /// @param _pool The Turbo Fuse Pool the Master will use.
    /// @param _fei The Fei token on the network.
    /// @param _owner The owner of the Master.
    /// @param _authority The Authority of the Master.
    constructor(
        Comptroller _pool,
        ERC20 _fei,
        address _owner,
        Authority _authority
    ) Auth(_owner, _authority) {
        pool = _pool;

        fei = _fei;

        // Prevent the first safe from getting id 0.
        safes.push(TurboSafe(address(0)));
    }

    /*///////////////////////////////////////////////////////////////
                            BOOSTER STORAGE
    //////////////////////////////////////////////////////////////*/

    /// @notice The Booster module used by the Master and its Safes.
    TurboBooster public booster;

    /// @notice Emitted when the Booster is updated.
    /// @param user The user who triggered the update of the Booster.
    /// @param newBooster The new Booster contract used by the Master.
    event BoosterUpdated(address indexed user, TurboBooster newBooster);

    /// @notice Update the Booster used by the Master.
    /// @param newBooster The new Booster contract to be used by the Master.
    function setBooster(TurboBooster newBooster) external requiresAuth {
        booster = newBooster;

        emit BoosterUpdated(msg.sender, newBooster);
    }

    /*///////////////////////////////////////////////////////////////
                             CLERK STORAGE
    //////////////////////////////////////////////////////////////*/

    /// @notice The Clerk module used by the Master and its Safes.
    TurboClerk public clerk;

    /// @notice Emitted when the Clerk is updated.
    /// @param user The user who triggered the update of the Clerk.
    /// @param newClerk The new Clerk contract used by the Master.
    event ClerkUpdated(address indexed user, TurboClerk newClerk);

    /// @notice Update the Clerk used by the Master.
    /// @param newClerk The new Clerk contract to be used by the Master.
    function setClerk(TurboClerk newClerk) external requiresAuth {
        clerk = newClerk;

        emit ClerkUpdated(msg.sender, newClerk);
    }

    /*///////////////////////////////////////////////////////////////
                  DEFAULT SAFE AUTHORITY CONFIGURATION
    //////////////////////////////////////////////////////////////*/

    /// @notice The default authority to be used by created Safes.
    Authority public defaultSafeAuthority;

    /// @notice Emitted when the default safe authority is updated.
    /// @param user The user who triggered the update of the default safe authority.
    /// @param newDefaultSafeAuthority The new default authority to be used by created Safes.
    event DefaultSafeAuthorityUpdated(address indexed user, Authority newDefaultSafeAuthority);

    /// @notice Set the default authority to be used by created Safes.
    /// @param newDefaultSafeAuthority The new default safe authority.
    function setDefaultSafeAuthority(Authority newDefaultSafeAuthority) external requiresAuth {
        // Update the default safe authority.
        defaultSafeAuthority = newDefaultSafeAuthority;

        emit DefaultSafeAuthorityUpdated(msg.sender, newDefaultSafeAuthority);
    }

    /*///////////////////////////////////////////////////////////////
                             SAFE STORAGE
    //////////////////////////////////////////////////////////////*/

    /// @notice The total Fei currently boosting Vaults.
    uint256 public totalBoosted;

    /// @notice Maps Safe addresses to the id they are stored under in the Safes array.
    mapping(TurboSafe => uint256) public getSafeId;

    /// @notice Maps Vault addresses to the total amount of Fei they've being boosted with.
    mapping(ERC4626 => uint256) public getTotalBoostedForVault;

    /// @notice Maps collateral types to the total amount of Fei boosted by Safes using it as collateral.
    mapping(ERC20 => uint256) public getTotalBoostedAgainstCollateral;

    /// @notice An array of all Safes created by the Master.
    /// @dev The first Safe is purposely invalid to prevent any Safes from having an id of 0.
    TurboSafe[] public safes;

    /// @notice Returns all Safes created by the Master.
    /// @return An array of all Safes created by the Master.
    /// @dev This is provided because Solidity converts public arrays into index getters,
    /// but we need a way to allow external contracts and users to access the whole array.
    function getAllSafes() external view returns (TurboSafe[] memory) {
        return safes;
    }

    /*///////////////////////////////////////////////////////////////
                          SAFE CREATION LOGIC
    //////////////////////////////////////////////////////////////*/

    /// @notice Emitted when a new Safe is created.
    /// @param user The user who created the Safe.
    /// @param asset The asset of the Safe.
    /// @param safe The newly deployed Safe contract.
    /// @param id The index of the Safe in the safes array.
    event TurboSafeCreated(address indexed user, ERC20 indexed asset, TurboSafe safe, uint256 id);

    /// @notice Creates a new Turbo Safe which supports a specific asset.
    /// @param asset The ERC20 token that the Safe should accept.
    /// @return safe The newly deployed Turbo Safe which accepts the provided asset.
    function createSafe(ERC20 asset) external requiresAuth returns (TurboSafe safe, uint256 id) {
        // Create a new Safe using the default authority and provided asset.
        safe = new TurboSafe(msg.sender, defaultSafeAuthority, asset);

        // Add the safe to the list of Safes.
        safes.push(safe);

        unchecked {
            // Get the index/id of the new Safe.
            // Cannot underflow, we just pushed to it.
            id = safes.length - 1;
        }

        // Store the id/index of the new Safe.
        getSafeId[safe] = id;

        emit TurboSafeCreated(msg.sender, asset, safe, id);

        // Prepare a users array to whitelist the Safe.
        address[] memory users = new address[](1);
        users[0] = address(safe);

        // Prepare an enabled array to whitelist the Safe.
        bool[] memory enabled = new bool[](1);
        enabled[0] = true;

        // Whitelist the Safe to access the Turbo Fuse Pool.
        FuseAdmin(pool.admin())._setWhitelistStatuses(users, enabled);
    }

    /*///////////////////////////////////////////////////////////////
                          SAFE CALLBACK LOGIC
    //////////////////////////////////////////////////////////////*/

    /// @notice Callback triggered whenever a Safe boosts a Vault.
    /// @param asset The asset of the Safe.
    /// @param vault The Vault that was boosted.
    /// @param feiAmount The amount of Fei used to boost the Vault.
    function onSafeBoost(
        ERC20 asset,
        ERC4626 vault,
        uint256 feiAmount
    ) external {
        // Get the caller as a Safe instance.
        TurboSafe safe = TurboSafe(msg.sender);

        // Ensure the Safe was created by this Master.
        require(getSafeId[safe] != 0, ""INVALID_SAFE"");

        // Update the total amount of Fei being using to boost Vaults.
        totalBoosted += feiAmount;

        // Cache the new total boosted for the Vault.
        uint256 newTotalBoostedForVault;

        // Cache the new total boosted against the Vault's collateral.
        uint256 newTotalBoostedAgainstCollateral;

        unchecked {
            // Update the total amount of Fei being using to boost the Vault.
            // Cannot overflow because a Safe's total will never be greater than global total.
            getTotalBoostedForVault[vault] = (newTotalBoostedForVault = getTotalBoostedForVault[vault] + feiAmount);

            // Update the total amount of Fei boosted against the collateral type.
            // Cannot overflow because a collateral type's total will never be greater than global total.
            getTotalBoostedAgainstCollateral[asset] = (newTotalBoostedAgainstCollateral =
                getTotalBoostedAgainstCollateral[asset] +
                feiAmount);
        }

        // Check with the booster that the Safe is allowed to boost the Vault using this amount of Fei.
        require(
            booster.canSafeBoostVault(
                safe,
                asset,
                vault,
                feiAmount,
                newTotalBoostedForVault,
                newTotalBoostedAgainstCollateral
            ),
            ""BOOSTER_REJECTED""
        );
    }

    /// @notice Callback triggered whenever a Safe withdraws from a Vault.
    /// @param asset The asset of the Safe.
    /// @param vault The Vault that was withdrawn from.
    /// @param feiAmount The amount of Fei withdrawn from the Vault.
    function onSafeLess(
        ERC20 asset,
        ERC4626 vault,
        uint256 feiAmount
    ) external {
        // Get the caller as a Safe instance.
        TurboSafe safe = TurboSafe(msg.sender);

        // Ensure the Safe was created by this Master.
        require(getSafeId[safe] != 0, ""INVALID_SAFE"");

        unchecked {
            // Update the total amount of Fei being using to boost the Vault.
            // Cannot underflow as the Safe validated the withdrawal amount before.
            getTotalBoostedForVault[vault] -= feiAmount;

            // Update the total amount of Fei being using to boost Vaults.
            // Cannot underflow as the Safe validated the withdrawal amount earlier.
            totalBoosted -= feiAmount;

            // Update the total amount of Fei boosted against the collateral type.
            // Cannot underflow as the Safe validated the withdrawal amount previously.
            getTotalBoostedAgainstCollateral[asset] -= feiAmount;
        }
    }

    /// @notice Callback triggered whenever a Safe harvests from a Vault.
    /// @param asset The asset of the Safe.
    /// @param vault The Vault that was harvested from.
    /// @param feiAmount The amount of Fei accrued as interest to the Safe.
    function onSafeSlurp(
        ERC20 asset,
        ERC4626 vault,
        uint256 feiAmount
    ) external {
        // Get the caller as a Safe instance.
        TurboSafe safe = TurboSafe(msg.sender);

        // Ensure the Safe was created by this Master.
        require(getSafeId[safe] != 0, ""INVALID_SAFE"");

        // Update the total amount of Fei being using to boost Vaults.
        totalBoosted += feiAmount;

        unchecked {
            // Update the total amount of Fei being using to boost the Vault.
            // Cannot overflow because a Safe's total will never be greater than global total.
            getTotalBoostedForVault[vault] += feiAmount;

            // Update the total amount of Fei boosted against the collateral type.
            // Cannot overflow because a collateral type's total will never be greater than global total.
            getTotalBoostedAgainstCollateral[asset] += feiAmount;
        }
    }

    /*///////////////////////////////////////////////////////////////
                              SWEEP LOGIC
    //////////////////////////////////////////////////////////////*/

    /// @notice Emitted a token is sweeped from the Master.
    /// @param user The user who sweeped the token from the Master.
    /// @param to The recipient of the sweeped tokens.
    /// @param amount The amount of the token that was sweeped.
    event TokenSweeped(address indexed user, address indexed to, ERC20 indexed token, uint256 amount);

    /// @notice Claim tokens sitting idly in the Master.
    /// @param to The recipient of the sweeped tokens.
    /// @param token The token to sweep and send.
    /// @param amount The amount of the token to sweep.
    function sweep(
        address to,
        ERC20 token,
        uint256 amount
    ) external requiresAuth {
        emit TokenSweeped(msg.sender, to, token, amount);

        // Transfer the sweeped tokens to the recipient.
        token.safeTransfer(to, amount);
    }
}",2791
RealWorld_BA_92_TurboSafe_RealWord_20240826123041.log,92,TurboSafe,56805,5665,62470,73.0,0.397325,"// SPDX-License-Identifier: AGPL-3.0-only
pragma solidity 0.8.10;

import {ERC20} from ""solmate/tokens/ERC20.sol"";
import {ERC4626} from ""solmate/mixins/ERC4626.sol"";
import {Auth, Authority} from ""solmate/auth/Auth.sol"";
import {ReentrancyGuard} from ""solmate/utils/ReentrancyGuard.sol"";
import {SafeTransferLib} from ""solmate/utils/SafeTransferLib.sol"";
import {FixedPointMathLib} from ""solmate/utils/FixedPointMathLib.sol"";

import {CERC20} from ""./interfaces/CERC20.sol"";
import {Comptroller} from ""./interfaces/Comptroller.sol"";

import {TurboMaster} from ""./TurboMaster.sol"";

/// @title Turbo Safe
/// @author Transmissions11
/// @notice Fuse liquidity accelerator.
contract TurboSafe is Auth, ERC4626, ReentrancyGuard {
    using SafeTransferLib for ERC20;
    using FixedPointMathLib for uint256;

    /*///////////////////////////////////////////////////////////////
                               IMMUTABLES
    //////////////////////////////////////////////////////////////*/

    /// @notice The Master contract that created the Safe.
    /// @dev Fees are paid directly to the Master, where they can be swept.
    TurboMaster public immutable master;

    /// @notice The Fei token on the network.
    ERC20 public immutable fei;

    /// @notice The Turbo Fuse Pool contract that collateral is held in and Fei is borrowed from.
    Comptroller public immutable pool;

    /// @notice The Fei cToken in the Turbo Fuse Pool that Fei is borrowed from.
    CERC20 public immutable feiTurboCToken;

    /// @notice The cToken that accepts the asset in the Turbo Fuse Pool.
    CERC20 public immutable assetTurboCToken;

    /*///////////////////////////////////////////////////////////////
                              CONSTRUCTOR
    //////////////////////////////////////////////////////////////*/

    /// @notice Creates a new Safe that accepts a specific asset.
    /// @param _owner The owner of the Safe.
    /// @param _authority The Authority of the Safe.
    /// @param _asset The ERC20 compliant token the Safe should accept.
    constructor(
        address _owner,
        Authority _authority,
        ERC20 _asset
    )
        Auth(_owner, _authority)
        ERC4626(
            _asset,
            // ex: Dai Stablecoin Turbo Safe
            string(abi.encodePacked(_asset.name(), "" Turbo Safe"")),
            // ex: tsDAI
            string(abi.encodePacked(""ts"", _asset.symbol()))
        )
    {
        master = TurboMaster(msg.sender);

        fei = master.fei();

        // An asset of Fei makes no sense.
        require(asset != fei, ""INVALID_ASSET"");

        pool = master.pool();

        feiTurboCToken = pool.cTokensByUnderlying(fei);

        assetTurboCToken = pool.cTokensByUnderlying(asset);

        // If the provided asset is not supported by the Turbo Fuse Pool, revert.
        require(address(assetTurboCToken) != address(0), ""UNSUPPORTED_ASSET"");

        // Construct an array of market(s) to enable as collateral.
        CERC20[] memory marketsToEnter = new CERC20[](1);
        marketsToEnter[0] = assetTurboCToken;

        // Enter the market(s) and ensure to properly revert if there is an error.
        require(pool.enterMarkets(marketsToEnter)[0] == 0, ""ENTER_MARKETS_FAILED"");

        // Preemptively approve the asset to the Turbo Fuse Pool's corresponding cToken.
        asset.safeApprove(address(assetTurboCToken), type(uint256).max);

        // Preemptively approve Fei to the Turbo Fuse Pool's Fei cToken.
        fei.safeApprove(address(feiTurboCToken), type(uint256).max);
    }

    /*///////////////////////////////////////////////////////////////
                               SAFE STORAGE
    //////////////////////////////////////////////////////////////*/

    /// @notice The current total amount of Fei the Safe is using to boost Vaults.
    uint256 public totalFeiBoosted;

    /// @notice Maps Vaults to the total amount of Fei they've being boosted with.
    /// @dev Used to determine the fees to be paid back to the Master.
    mapping(ERC4626 => uint256) public getTotalFeiBoostedForVault;

    /*///////////////////////////////////////////////////////////////
                               MODIFIERS
    //////////////////////////////////////////////////////////////*/

    /// @dev Checks the caller is authorized using either the Master's Authority or the Safe's local Authority.
    modifier requiresLocalOrMasterAuth() {
        // Check if the caller is the owner first:
        if (msg.sender != owner) {
            Authority masterAuth = master.authority(); // Saves a warm SLOAD, about 100 gas.

            // If the Master's Authority does not exist or does not accept upfront:
            if (address(masterAuth) == address(0) || !masterAuth.canCall(msg.sender, address(this), msg.sig)) {
                Authority auth = authority; // Memoizing saves us a warm SLOAD, around 100 gas.

                // The only authorization option left is via the local Authority, otherwise revert.
                require(
                    address(auth) != address(0) && auth.canCall(msg.sender, address(this), msg.sig),
                    ""UNAUTHORIZED""
                );
            }
        }

        _;
    }

    /*///////////////////////////////////////////////////////////////
                             ERC4626 LOGIC
    //////////////////////////////////////////////////////////////*/

    /// @notice Called after any type of deposit occurs.
    /// @param assetAmount The amount of assets being deposited.
    /// @dev Using requiresAuth here prevents unauthorized users from depositing.
    function afterDeposit(uint256 assetAmount, uint256) internal override nonReentrant requiresAuth {
        // Collateralize the assets in the Turbo Fuse Pool.
        require(assetTurboCToken.mint(assetAmount) == 0, ""MINT_FAILED"");
    }

    /// @notice Called before any type of withdrawal occurs.
    /// @param assetAmount The amount of assets being withdrawn.
    /// @dev Using requiresAuth here prevents unauthorized users from withdrawing.
    function beforeWithdraw(uint256 assetAmount, uint256) internal override nonReentrant requiresAuth {
        // Withdraw the assets from the Turbo Fuse Pool.
        require(assetTurboCToken.redeemUnderlying(assetAmount) == 0, ""REDEEM_FAILED"");
    }

    /// @notice Returns the total amount of assets held in the Safe.
    /// @return The total amount of assets held in the Safe.
    function totalAssets() public view override returns (uint256) {
        return assetTurboCToken.balanceOf(address(this)).mulWadDown(assetTurboCToken.exchangeRateStored());
    }

    /*///////////////////////////////////////////////////////////////
                           BOOST/LESS LOGIC
    //////////////////////////////////////////////////////////////*/

    /// @notice Emitted when a Vault is boosted by the Safe.
    /// @param user The user who boosted the Vault.
    /// @param vault The Vault that was boosted.
    /// @param feiAmount The amount of Fei that was boosted to the Vault.
    event VaultBoosted(address indexed user, ERC4626 indexed vault, uint256 feiAmount);

    /// @notice Borrow Fei from the Turbo Fuse Pool and deposit it into an authorized Vault.
    /// @param vault The Vault to deposit the borrowed Fei into.
    /// @param feiAmount The amount of Fei to borrow and supply into the Vault.
    /// @dev Automatically accrues any fees earned by the Safe in the Vault to the Master.
    function boost(ERC4626 vault, uint256 feiAmount) external nonReentrant requiresAuth {
        // Ensure the Vault accepts Fei asset.
        require(vault.asset() == fei, ""NOT_FEI"");

        // Call the Master where it will do extra validation
        // and update it's total count of funds used for boosting.
        master.onSafeBoost(asset, vault, feiAmount);

        // Increase the boost total proportionately.
        totalFeiBoosted += feiAmount;

        unchecked {
            // Update the total Fei deposited into the Vault proportionately.
            // Cannot overflow because the total cannot be less than a single Vault.
            getTotalFeiBoostedForVault[vault] += feiAmount;
        }

        emit VaultBoosted(msg.sender, vault, feiAmount);

        // Borrow the Fei amount from the Fei cToken in the Turbo Fuse Pool.
        require(feiTurboCToken.borrow(feiAmount) == 0, ""BORROW_FAILED"");

        // Approve the borrowed Fei to the specified Vault.
        fei.safeApprove(address(vault), feiAmount);

        // Deposit the Fei into the specified Vault.
        vault.deposit(feiAmount, address(this));
    }

    /// @notice Emitted when a Vault is withdrawn from by the Safe.
    /// @param user The user who lessed the Vault.
    /// @param vault The Vault that was withdrawn from.
    /// @param feiAmount The amount of Fei that was withdrawn from the Vault.
    event VaultLessened(address indexed user, ERC4626 indexed vault, uint256 feiAmount);

    /// @notice Withdraw Fei from a deposited Vault and use it to repay debt in the Turbo Fuse Pool.
    /// @param vault The Vault to withdraw the Fei from.
    /// @param feiAmount The amount of Fei to withdraw from the Vault and repay in the Turbo Fuse Pool.
    /// @dev Automatically accrues any fees earned by the Safe in the Vault to the Master.
    function less(ERC4626 vault, uint256 feiAmount) external nonReentrant requiresLocalOrMasterAuth {
        // Update the total Fei deposited into the Vault proportionately.
        getTotalFeiBoostedForVault[vault] -= feiAmount;

        unchecked {
            // Decrease the boost total proportionately.
            // Cannot underflow because the total cannot be less than a single Vault.
            totalFeiBoosted -= feiAmount;
        }

        emit VaultLessened(msg.sender, vault, feiAmount);

        // Withdraw the specified amount of Fei from the Vault.
        vault.withdraw(feiAmount, address(this), address(this));

        // Get out current amount of Fei debt in the Turbo Fuse Pool.
        uint256 feiDebt = feiTurboCToken.borrowBalanceCurrent(address(this));

        // If our debt balance decreased, repay the minimum.
        // The surplus Fei will accrue as fees and can be sweeped.
        if (feiAmount > feiDebt) feiAmount = feiDebt;

        // Repay Fei debt in the Turbo Fuse Pool, unless we would repay nothing.
        if (feiAmount != 0) require(feiTurboCToken.repayBorrow(feiAmount) == 0, ""REPAY_FAILED"");

        // Call the Master to allow it to update its accounting.
        master.onSafeLess(asset, vault, feiAmount);
    }

    /*///////////////////////////////////////////////////////////////
                              SLURP LOGIC
    //////////////////////////////////////////////////////////////*/

    /// @notice Emitted when a Vault is slurped from by the Safe.
    /// @param user The user who slurped the Vault.
    /// @param vault The Vault that was slurped.
    /// @param protocolFeeAmount The amount of Fei accrued as fees to the Master.
    /// @param safeInterestAmount The amount of Fei accrued as interest to the Safe.
    event VaultSlurped(
        address indexed user,
        ERC4626 indexed vault,
        uint256 protocolFeeAmount,
        uint256 safeInterestAmount
    );

    /// @notice Accrue any interest earned by the Safe in the Vault.
    /// @param vault The Vault to accrue interest from, if any.
    /// @dev Sends a portion of the interest to the Master, as determined by the Clerk.
    function slurp(ERC4626 vault) external nonReentrant requiresLocalOrMasterAuth {
        // Ensure the Safe has Fei currently boosting the Vault.
        require(getTotalFeiBoostedForVault[vault] != 0, ""NO_FEI_BOOSTED"");

        // Compute the amount of Fei interest the Safe generated by boosting the Vault.
        uint256 interestEarned = vault.assetsOf(address(this)) - getTotalFeiBoostedForVault[vault];

        // Compute what percentage of the interest earned will go back to the Safe.
        uint256 protocolFeePercent = master.clerk().getFeePercentageForSafe(this, asset);

        // Compute the amount of Fei the protocol will retain as fees.
        uint256 protocolFeeAmount = interestEarned.mulWadDown(protocolFeePercent);

        // Compute the amount of Fei the Safe will retain as interest.
        uint256 safeInterestAmount = interestEarned - protocolFeeAmount;

        // Increase the boost total proportionately.
        totalFeiBoosted += safeInterestAmount;

        unchecked {
            // Update the total Fei held in the Vault proportionately.
            // Cannot overflow because the total cannot be less than a single Vault.
            getTotalFeiBoostedForVault[vault] += safeInterestAmount;
        }

        emit VaultSlurped(msg.sender, vault, protocolFeeAmount, safeInterestAmount);

        // If we have unaccrued fees, withdraw them from the Vault and transfer them to the Master.
        if (protocolFeeAmount != 0) vault.withdraw(protocolFeeAmount, address(master), address(this));

        // Call the Master to allow it to update its accounting.
        master.onSafeSlurp(asset, vault, safeInterestAmount);
    }

    /*///////////////////////////////////////////////////////////////
                              SWEEP LOGIC
    //////////////////////////////////////////////////////////////*/

    /// @notice Emitted a token is sweeped from the Safe.
    /// @param user The user who sweeped the token from the Safe.
    /// @param to The recipient of the sweeped tokens.
    /// @param amount The amount of the token that was sweeped.
    event TokenSweeped(address indexed user, address indexed to, ERC20 indexed token, uint256 amount);

    /// @notice Claim tokens sitting idly in the Safe.
    /// @param to The recipient of the sweeped tokens.
    /// @param token The token to sweep and send.
    /// @param amount The amount of the token to sweep.
    function sweep(
        address to,
        ERC20 token,
        uint256 amount
    ) external nonReentrant requiresAuth {
        // Ensure the caller is not trying to steal Vault shares or collateral cTokens.
        require(getTotalFeiBoostedForVault[ERC4626(address(token))] == 0 && token != assetTurboCToken, ""INVALID_TOKEN"");

        emit TokenSweeped(msg.sender, to, token, amount);

        // Transfer the sweeped tokens to the recipient.
        token.safeTransfer(to, amount);
    }

    /*///////////////////////////////////////////////////////////////
                               GIB LOGIC
    //////////////////////////////////////////////////////////////*/

    /// @notice Emitted when a Safe is gibbed.
    /// @param user The user who gibbed the Safe.
    /// @param to The recipient of the impounded collateral.
    /// @param assetAmount The amount of underling tokens impounded.
    event SafeGibbed(address indexed user, address indexed to, uint256 assetAmount);

    /// @notice Impound a specific amount of a Safe's collateral.
    /// @param to The address to send the impounded collateral to.
    /// @param assetAmount The amount of the asset to impound.
    /// @dev Can only be called by the Gibber, not by the Safe owner.
    /// @dev Debt must be repaid in advance, or the redemption will fail.
    function gib(address to, uint256 assetAmount) external nonReentrant requiresLocalOrMasterAuth {
        emit SafeGibbed(msg.sender, to, assetAmount);

        // Withdraw the specified amount of assets from the Turbo Fuse Pool.
        require(assetTurboCToken.redeemUnderlying(assetAmount) == 0, ""REDEEM_FAILED"");

        // Transfer the assets to the authorized caller.
        asset.safeTransfer(to, assetAmount);
    }
}",3368
RealWorld_BA_92_TurboSafe.t_RealWord_20240826123658.log,92,TurboSafe.t,48844,5297,54141,69.0,0.35016,"// SPDX-License-Identifier: AGPL-3.0-only
pragma solidity 0.8.10;

import {Authority} from ""solmate/auth/Auth.sol"";
import {ERC4626} from ""solmate/mixins/ERC4626.sol"";
import {DSTestPlus} from ""solmate/test/utils/DSTestPlus.sol"";
import {MockERC20} from ""solmate/test/utils/mocks/MockERC20.sol"";
import {MockERC4626} from ""solmate/test/utils/mocks/MockERC4626.sol"";
import {FixedPointMathLib} from ""solmate/utils/FixedPointMathLib.sol"";

import {MockCToken} from ""./mocks/MockCToken.sol"";
import {MockPriceFeed} from ""./mocks/MockPriceFeed.sol"";
import {MockFuseAdmin} from ""./mocks/MockFuseAdmin.sol"";
import {MockComptroller} from ""./mocks/MockComptroller.sol"";

import {TurboClerk} from ""../modules/TurboClerk.sol"";
import {TurboBooster} from ""../modules/TurboBooster.sol"";

import {TurboSafe} from ""../TurboSafe.sol"";
import {TurboMaster} from ""../TurboMaster.sol"";

contract TurboSafeTest is DSTestPlus {
    using FixedPointMathLib for uint256;

    TurboMaster master;

    TurboClerk clerk;

    TurboBooster booster;

    MockFuseAdmin fuseAdmin;

    MockComptroller comptroller;

    MockERC20 fei;

    MockERC20 asset;

    MockCToken assetCToken;

    MockCToken feiCToken;

    MockERC4626 vault;

    TurboSafe safe;

    function setUp() public {
        fei = new MockERC20(""Fei USD"", ""FEI"", 18);

        asset = new MockERC20(""Mock Token"", ""MOCK"", 18);

        fuseAdmin = new MockFuseAdmin();

        booster = new TurboBooster(address(this), Authority(address(0)));

        clerk = new TurboClerk(address(this), Authority(address(0)));

        comptroller = new MockComptroller(address(fuseAdmin), new MockPriceFeed());

        master = new TurboMaster(comptroller, fei, address(this), Authority(address(0)));

        assetCToken = new MockCToken(asset);

        comptroller.mapUnderlyingToCToken(asset, assetCToken);

        feiCToken = new MockCToken(fei);

        comptroller.mapUnderlyingToCToken(fei, feiCToken);

        vault = new MockERC4626(fei, ""Mock Fei Vault"", ""mvFEI"");

        master.setBooster(booster);

        master.setClerk(clerk);

        (safe, ) = master.createSafe(asset);

        asset.mint(address(this), type(uint256).max);
        asset.approve(address(safe), type(uint256).max);
    }

    /*///////////////////////////////////////////////////////////////
                      DEPOSIT/WITHDRAWAL TESTS
    //////////////////////////////////////////////////////////////*/

    function testDeposit(uint128 amount, address to) public {
        if (amount == 0) amount = 1;

        safe.deposit(amount, to);

        assertEq(safe.balanceOf(to), amount);
        assertEq(safe.assetsOf(to), amount);
        assertEq(assetCToken.balanceOfUnderlying(address(safe)), amount);
        assertEq(safe.totalAssets(), amount);
    }

    function testDepositRedeem(uint128 amount, address to) public {
        if (amount == 0) amount = 1;

        uint256 toBalance = asset.balanceOf(to);

        safe.deposit(amount, address(this));
        safe.redeem(amount, to, address(this));

        assertEq(safe.totalAssets(), 0);
        assertEq(safe.balanceOf(to), 0);
        assertEq(asset.balanceOf(to), to == address(this) ? toBalance : toBalance + amount);
        assertEq(assetCToken.balanceOfUnderlying(address(safe)), 0);
    }

    function testDepositWithdraw(uint128 amount, address to) public {
        if (amount == 0) amount = 1;

        uint256 toBalance = asset.balanceOf(to);

        safe.deposit(amount, address(this));
        safe.withdraw(amount, to, address(this));

        assertEq(safe.totalAssets(), 0);
        assertEq(safe.balanceOf(to), 0);
        assertEq(asset.balanceOf(to), to == address(this) ? toBalance : toBalance + amount);
        assertEq(assetCToken.balanceOfUnderlying(address(safe)), 0);
    }

    /*///////////////////////////////////////////////////////////////
                             BOOST TESTS
    //////////////////////////////////////////////////////////////*/

    function testFailBoostNotEnoughCollateral(
        uint128 underlyingAmount,
        uint128 feiMintAmount,
        uint128 feiAmount,
        address to
    ) public {
        feiAmount = uint128(bound(feiAmount, feiMintAmount + 1, type(uint128).max));

        safe.deposit(underlyingAmount, to);

        fei.mint(address(feiCToken), feiMintAmount);

        booster.setBoostCapForVault(vault, feiAmount);
        booster.setBoostCapForCollateral(asset, feiAmount);

        safe.boost(vault, feiAmount);
    }

    function testFailBoostVaultCapTooLow(
        uint128 underlyingAmount,
        uint128 feiMintAmount,
        uint128 feiAmount,
        address to
    ) public {
        feiAmount = uint128(bound(feiAmount, 0, feiMintAmount));

        safe.deposit(underlyingAmount, to);

        fei.mint(address(feiCToken), feiMintAmount);

        booster.setBoostCapForVault(vault, bound(feiAmount, 0, feiAmount - 1));
        booster.setBoostCapForCollateral(asset, feiAmount);

        safe.boost(vault, feiAmount);
    }

    function testFailBoostCollateralCapTooLow(
        uint128 underlyingAmount,
        uint128 feiMintAmount,
        uint128 feiAmount,
        address to
    ) public {
        feiAmount = uint128(bound(feiAmount, 0, feiMintAmount));

        safe.deposit(underlyingAmount, to);

        fei.mint(address(feiCToken), feiMintAmount);

        booster.setBoostCapForVault(vault, feiAmount);
        booster.setBoostCapForCollateral(asset, bound(feiAmount, 0, feiAmount - 1));

        safe.boost(vault, feiAmount);
    }

    function testFailBoostFrozen(
        uint128 underlyingAmount,
        uint128 feiMintAmount,
        uint128 feiAmount,
        address to
    ) public {
        feiAmount = uint128(bound(feiAmount, 0, feiMintAmount));

        safe.deposit(underlyingAmount, to);

        fei.mint(address(feiCToken), feiMintAmount);

        booster.setBoostCapForVault(vault, feiAmount);
        booster.setBoostCapForCollateral(asset, feiAmount);

        booster.setFreezeStatus(true);

        safe.boost(vault, feiAmount);
    }

    function testFailInvalidVault(
        uint128 underlyingAmount,
        uint128 feiMintAmount,
        uint128 feiAmount,
        address to,
        ERC4626 invalidVault
    ) public {
        feiAmount = uint128(bound(feiAmount, 0, feiMintAmount));

        safe.deposit(underlyingAmount, to);

        fei.mint(address(feiCToken), feiMintAmount);

        booster.setBoostCapForVault(invalidVault, feiAmount);
        booster.setBoostCapForCollateral(invalidVault, feiAmount);

        safe.boost(invalidVault, feiAmount);
    }

    function testFailWrongAssetVault(
        uint128 underlyingAmount,
        uint128 feiMintAmount,
        uint128 feiAmount,
        address to
    ) public {
        feiAmount = uint128(bound(feiAmount, 0, feiMintAmount));

        safe.deposit(underlyingAmount, to);

        fei.mint(address(feiCToken), feiMintAmount);

        MockERC4626 wrongAssetVault = new MockERC4626(asset, ""Wrong Asset Vault"", ""WAV"");

        booster.setBoostCapForVault(wrongAssetVault, feiAmount);
        booster.setBoostCapForCollateral(wrongAssetVault, feiAmount);

        safe.boost(wrongAssetVault, feiAmount);
    }

    function testBoost(
        uint128 underlyingAmount,
        uint128 feiMintAmount,
        uint128 feiAmount,
        address to
    ) public {
        if (underlyingAmount == 0) underlyingAmount = 1;
        if (feiMintAmount == 0) feiMintAmount = 1;

        feiAmount = uint128(bound(feiAmount, 1, feiMintAmount));

        safe.deposit(underlyingAmount, to);

        fei.mint(address(feiCToken), feiMintAmount);

        booster.setBoostCapForVault(vault, feiAmount);
        booster.setBoostCapForCollateral(asset, feiAmount);

        safe.boost(vault, feiAmount);

        assertEq(safe.totalFeiBoosted(), feiAmount);
        assertEq(safe.getTotalFeiBoostedForVault(vault), feiAmount);
        assertEq(vault.assetsOf(address(safe)), feiAmount);
        assertEq(vault.totalAssets(), feiAmount);
        assertEq(feiCToken.borrowBalanceCurrent(address(safe)), feiAmount);

        assertEq(master.totalBoosted(), feiAmount);
        assertEq(master.getTotalBoostedForVault(vault), feiAmount);
        assertEq(master.getTotalBoostedAgainstCollateral(asset), feiAmount);
    }

    /*///////////////////////////////////////////////////////////////
                             LESS TESTS
    //////////////////////////////////////////////////////////////*/

    function testBoostAndLess(
        uint128 boostAmount,
        uint128 lessAmount,
        address to
    ) public {
        if (boostAmount == 0) boostAmount = 1;
        if (lessAmount == 0) lessAmount = 1;

        lessAmount = uint128(bound(lessAmount, 0, boostAmount));

        safe.deposit(boostAmount, to);

        fei.mint(address(feiCToken), boostAmount);

        booster.setBoostCapForVault(vault, boostAmount);
        booster.setBoostCapForCollateral(asset, boostAmount);

        safe.boost(vault, boostAmount);

        safe.less(vault, lessAmount);

        uint256 delta = boostAmount - lessAmount;

        assertEq(safe.totalFeiBoosted(), delta);
        assertEq(safe.getTotalFeiBoostedForVault(vault), delta);
        assertEq(vault.assetsOf(address(safe)), delta);
        assertEq(vault.totalAssets(), delta);
        assertEq(feiCToken.borrowBalanceCurrent(address(safe)), delta);

        assertEq(master.totalBoosted(), delta);
        assertEq(master.getTotalBoostedForVault(vault), delta);
        assertEq(master.getTotalBoostedAgainstCollateral(asset), delta);
    }

    /*///////////////////////////////////////////////////////////////
                             SLURP TESTS
    //////////////////////////////////////////////////////////////*/

    function testFailSlurpUntrustedVault(ERC4626 untrustedVault) public {
        if (untrustedVault == vault) revert();

        safe.slurp(untrustedVault);
    }

    function testSlurp(
        uint64 boostAmount,
        uint64 donationAmount,
        uint256 feePercentage,
        address to
    ) public {
        if (boostAmount == 0) boostAmount = 1;

        feePercentage = bound(feePercentage, 0, 1e18);

        safe.deposit(boostAmount, to);

        fei.mint(address(feiCToken), boostAmount);

        booster.setBoostCapForVault(vault, boostAmount);
        booster.setBoostCapForCollateral(asset, boostAmount);

        safe.boost(vault, boostAmount);

        fei.mint(address(vault), donationAmount);

        clerk.setDefaultFeePercentage(feePercentage);

        safe.slurp(vault);

        uint256 protocolFeeAmount = uint256(donationAmount).mulWadDown(feePercentage);

        uint256 safeInterestAmount = donationAmount - protocolFeeAmount;

        uint256 delta = boostAmount + safeInterestAmount;

        assertEq(safe.totalFeiBoosted(), delta);
        assertEq(safe.getTotalFeiBoostedForVault(vault), delta);
        assertEq(vault.assetsOf(address(safe)), delta);
        assertEq(vault.totalAssets(), delta);
        assertEq(feiCToken.borrowBalanceCurrent(address(safe)), boostAmount);

        assertEq(master.totalBoosted(), delta);
        assertEq(master.getTotalBoostedForVault(vault), delta);
        assertEq(master.getTotalBoostedAgainstCollateral(asset), delta);

        assertEq(fei.balanceOf(address(master)), protocolFeeAmount);
    }

    /*///////////////////////////////////////////////////////////////
                             SWEEP TESTS
    //////////////////////////////////////////////////////////////*/

    function testFailSweepVaultShares(address to, uint256 amount) public {
        safe.sweep(to, vault, amount);
    }

    function testFailSweepAssetCToken(address to, uint256 amount) public {
        safe.sweep(to, assetCToken, amount);
    }

    function testSweep(uint256 amount, address to) public {
        fei.mint(address(safe), amount);

        safe.sweep(to, fei, amount);

        assertEq(fei.balanceOf(to), amount);
    }
}",2894
RealWorld_BA_92_MockComptroller_RealWord_20240826123926.log,92,MockComptroller,9208,5269,14477,65.0,0.15142,"// SPDX-License-Identifier: AGPL-3.0-only
pragma solidity 0.8.10;

import {ERC20} from ""solmate/tokens/ERC20.sol"";

import {CERC20} from ""../../interfaces/Comptroller.sol"";
import {PriceFeed} from ""../../interfaces/PriceFeed.sol"";
import {Comptroller} from ""../../interfaces/Comptroller.sol"";

contract MockComptroller is Comptroller {
    /*///////////////////////////////////////////////////////////////
                            COMPTROLLER LOGIC
    //////////////////////////////////////////////////////////////*/

    mapping(ERC20 => CERC20) public override cTokensByUnderlying;

    struct Market {
        bool isListed;
        uint256 collateralFactor;
    }

    mapping(CERC20 => Market) public override markets;

    address public immutable override admin;

    PriceFeed public immutable override oracle;

    function enterMarkets(CERC20[] calldata cTokens) external returns (uint256[] memory errors) {
        errors = new uint256[](cTokens.length); // Will be filled with all 0s.

        for (uint256 i = 0; i < cTokens.length; i++) isMember[msg.sender][cTokens[i]] = true;
    }

    /*///////////////////////////////////////////////////////////////
                              CONSTRUCTOR
    //////////////////////////////////////////////////////////////*/

    constructor(address _admin, PriceFeed _oracle) {
        admin = _admin;
        oracle = _oracle;
    }

    /*///////////////////////////////////////////////////////////////
                             MOCK LOGIC
    //////////////////////////////////////////////////////////////*/

    mapping(address => mapping(CERC20 => bool)) public isMember;

    function mapUnderlyingToCToken(ERC20 asset, CERC20 cToken) external {
        cTokensByUnderlying[asset] = cToken;
    }

    function setMarket(CERC20 cToken, Market calldata newMarket) external {
        markets[cToken] = newMarket;
    }
}",378
RealWorld_BA_92_TurboRouter_RealWord_20240826122931.log,92,TurboRouter,20505,5429,25934,68.0,0.211105,"// SPDX-License-Identifier: AGPL-3.0-only
pragma solidity 0.8.10;

import {TurboMaster} from ""./TurboMaster.sol"";
import {TurboSafe} from ""./TurboSafe.sol"";

import {ENSReverseRecord} from ""ERC4626/ens/ENSReverseRecord.sol"";
import {IERC4626, ERC4626RouterBase, IWETH9, PeripheryPayments} from ""ERC4626/ERC4626RouterBase.sol"";

import {ERC20} from ""solmate/tokens/ERC20.sol"";
import {SafeTransferLib} from ""solmate/utils/SafeTransferLib.sol"";

import {ERC4626} from ""solmate/mixins/ERC4626.sol"";
import {Auth, Authority} from ""solmate/auth/Auth.sol"";

/**
 @title a router which can perform multiple Turbo actions between Master and the Safes
 @notice routes custom users flows between actions on the master and safes.

 Extends the ERC4626RouterBase to allow for flexible combinations of actions involving ERC4626 and permit, weth, and Turbo specific actions.

 Safe Creation has functions bundled with deposit (and optionally boost) because a newly created Safe address can only be known at runtime. 
 The caller is always atomically given the owner role of a new safe.

 Authentication requires the caller to be the owner of the Safe to perform any ERC4626 method or TurboSafe requiresAuth method. 
 Assumes the Safe's authority gives permission to call these functions to the TurboRouter.
 */
contract TurboRouter is ERC4626RouterBase, ENSReverseRecord {
    using SafeTransferLib for ERC20;

    TurboMaster public immutable master;

    constructor (TurboMaster _master, string memory name, IWETH9 weth) ENSReverseRecord(name) PeripheryPayments(weth) {
        master = _master;
    }

    modifier authenticate(address target) {
        require(msg.sender == Auth(target).owner(), ""NOT_AUTHED"");

        _;
    }

    function createSafe(ERC20 underlying) external {
        (TurboSafe safe, ) = master.createSafe(underlying);

        safe.setOwner(msg.sender);
    }

    function createSafeAndDeposit(ERC20 underlying, address to, uint256 amount, uint256 minSharesOut) external {
        (TurboSafe safe, ) = master.createSafe(underlying);

        super.deposit(IERC4626(address(safe)), to, amount, minSharesOut);

        safe.setOwner(msg.sender);
    }

    function createSafeAndDepositAndBoost(
        ERC20 underlying, 
        address to, 
        uint256 amount, 
        uint256 minSharesOut, 
        ERC4626 boostedVault, 
        uint256 boostedFeiAmount
    ) public {
        (TurboSafe safe, ) = master.createSafe(underlying);

        super.deposit(IERC4626(address(safe)), to, amount, minSharesOut);

        safe.boost(boostedVault, boostedFeiAmount);

        safe.setOwner(msg.sender);
    }

    function deposit(IERC4626 safe, address to, uint256 amount, uint256 minSharesOut) 
        public 
        payable 
        override 
        authenticate(address(safe)) 
        returns (uint256) 
    {
        return super.deposit(safe, to, amount, minSharesOut);
    }

    function mint(IERC4626 safe, address to, uint256 shares, uint256 maxAmountIn) 
        public 
        payable 
        override 
        authenticate(address(safe)) 
        returns (uint256) 
    {
        return super.mint(safe, to, shares, maxAmountIn);
    }

    function withdraw(IERC4626 safe, address to, uint256 amount, uint256 minSharesOut) 
        public 
        payable 
        override 
        authenticate(address(safe)) 
        returns (uint256) 
    {
        return super.withdraw(safe, to, amount, minSharesOut);
    }

    function redeem(IERC4626 safe, address to, uint256 shares, uint256 minAmountOut) 
        public 
        payable 
        override 
        authenticate(address(safe)) 
        returns (uint256) 
    {
        return super.redeem(safe, to, shares, minAmountOut);
    }

    function slurp(TurboSafe safe, ERC4626 vault) external authenticate(address(safe)) {
        safe.slurp(vault);
    }

    function boost(TurboSafe safe, ERC4626 vault, uint256 feiAmount) public authenticate(address(safe)) {
        safe.boost(vault, feiAmount);
    }

    function less(TurboSafe safe, ERC4626 vault, uint256 feiAmount) external authenticate(address(safe)) {
        safe.less(vault, feiAmount);
    }

    function sweep(TurboSafe safe, address to, ERC20 token, uint256 amount) external authenticate(address(safe)) {
        safe.sweep(to, token, amount);
    }

    function slurpAndLess(TurboSafe safe, ERC4626 vault, uint256 feiAmount) external authenticate(address(safe)) {
        safe.slurp(vault);
        safe.less(vault, feiAmount);
    }
}",1095
RealWorld_BA_92_Deployer_RealWord_20240826124346.log,92,Deployer,21530,5557,27087,72.0,0.21879,"// SPDX-License-Identifier: AGPL-3.0-only
pragma solidity 0.8.10;

import {ERC20} from ""solmate/tokens/ERC20.sol"";
import {Auth, Authority} from ""solmate/auth/Auth.sol"";
import {MultiRolesAuthority} from ""solmate/auth/authorities/MultiRolesAuthority.sol"";

import {Comptroller} from ""../interfaces/Comptroller.sol"";

import {TurboClerk} from ""../modules/TurboClerk.sol"";
import {TurboGibber} from ""../modules/TurboGibber.sol"";
import {TurboBooster} from ""../modules/TurboBooster.sol"";
import {TurboSavior} from ""../modules/TurboSavior.sol"";

import {TurboRouter, IWETH9} from ""../TurboRouter.sol"";
import {TurboMaster, TurboSafe, ERC4626} from ""../TurboMaster.sol"";

import {TimelockController} from ""@openzeppelin/governance/TimelockController.sol"";

/// @title Turbo Deployer
contract Deployer {
    Comptroller pool = Comptroller(0xc62ceB397a65edD6A68715b2d3922dEE0D63F45c);
    ERC20 fei = ERC20(0x956F47F50A910163D8BF957Cf5846D573E7f87CA);
    IWETH9 weth = IWETH9(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);

    address constant feiDAOTimelock = 0xd51dbA7a94e1adEa403553A8235C302cEbF41a3c;

    uint256 public timelockDelay = 30 days;

    uint8 public constant GIBBER_ROLE = 1;
    uint8 public constant ROUTER_ROLE = 2;
    uint8 public constant SAVIOR_ROLE = 3;
    uint8 public constant TURBO_POD_ROLE = 4;

    TurboMaster public master;
    TurboGibber public gibber;
    TurboSavior public savior;
    TurboRouter public router;

    constructor() {
        deploy();
    }

    function deploy() public {
        TimelockController turboTimelock = new TimelockController(timelockDelay, new address[](0), new address[](0));
        MultiRolesAuthority turboAuthority = new MultiRolesAuthority(address(this), Authority(address(0)));
        turboAuthority.setRoleCapability(GIBBER_ROLE, TurboSafe.gib.selector, true);
        turboAuthority.setRoleCapability(TURBO_POD_ROLE, TurboSafe.slurp.selector, true);
        turboAuthority.setRoleCapability(TURBO_POD_ROLE, TurboSafe.less.selector, true);

        master = new TurboMaster(
            pool,
            fei,
            address(this),
            turboAuthority
        );

        TurboClerk clerk = new TurboClerk(address(this), Authority(address(0)));

        clerk.setDefaultFeePercentage(90e16);
        clerk.setOwner(feiDAOTimelock);

        master.setClerk(clerk);

        TurboBooster booster = new TurboBooster(
           feiDAOTimelock, Authority(address(0)) 
        );

        master.setBooster(booster);
        
        gibber = new TurboGibber(master, address(turboTimelock), Authority(address(0)));

        turboAuthority.setUserRole(address(gibber), GIBBER_ROLE, true);

        savior = new TurboSavior(
            master, address(this), Authority(address(0))
        );

        savior.setMinDebtPercentageForSaving(80e16); // 80%

        router = new TurboRouter(master, """", weth);

        master.setDefaultSafeAuthority(
            configureDefaultAuthority(
                address(turboTimelock),
                address(router),
                address(savior)
            )
        );

        savior.setAuthority(master.defaultSafeAuthority());
        savior.setOwner(feiDAOTimelock);

        master.setOwner(address(turboTimelock));
    }

    function configureDefaultAuthority(address owner, address _router, address _savior) internal returns (MultiRolesAuthority) {
        MultiRolesAuthority defaultAuthority = new MultiRolesAuthority(address(this), Authority(address(0)));
        defaultAuthority.setRoleCapability(ROUTER_ROLE, TurboSafe.boost.selector, true);
        defaultAuthority.setRoleCapability(ROUTER_ROLE, TurboSafe.less.selector, true);
        defaultAuthority.setRoleCapability(ROUTER_ROLE, TurboSafe.slurp.selector, true);
        defaultAuthority.setRoleCapability(ROUTER_ROLE, TurboSafe.sweep.selector, true);
        defaultAuthority.setRoleCapability(ROUTER_ROLE, ERC4626.deposit.selector, true);
        defaultAuthority.setRoleCapability(ROUTER_ROLE, ERC4626.mint.selector, true);
        defaultAuthority.setRoleCapability(ROUTER_ROLE, ERC4626.withdraw.selector, true);
        defaultAuthority.setRoleCapability(ROUTER_ROLE, ERC4626.redeem.selector, true);

        defaultAuthority.setUserRole(_router, ROUTER_ROLE, true);

        defaultAuthority.setRoleCapability(SAVIOR_ROLE, TurboSafe.less.selector, true);

        defaultAuthority.setUserRole(_savior, SAVIOR_ROLE, true);

        defaultAuthority.setPublicCapability(TurboSavior.save.selector, true);
        defaultAuthority.setOwner(owner);
        return defaultAuthority;
    }
}",1159
RealWorld_BA_92_Fei_RealWord_20240826125355.log,92,Fei,4592,4207,8799,56.0,0.1071,"// SPDX-License-Identifier: AGPL-3.0-only
pragma solidity 0.8.10;

import {ERC20} from ""solmate/tokens/ERC20.sol"";

/// @title Fei
/// @author Fei Protocol
/// @notice Minimal interface for the Fei token.
abstract contract Fei is ERC20 {
    function mint(address to, uint256 amount) external virtual;
}",84
RealWorld_BA_92_TurboGibber_RealWord_20240826124500.log,92,TurboGibber,20794,5494,26288,66.0,0.21385,"// SPDX-License-Identifier: AGPL-3.0-only
pragma solidity 0.8.10;

import {ERC20} from ""solmate/tokens/ERC20.sol"";
import {Auth, Authority} from ""solmate/auth/Auth.sol"";
import {ReentrancyGuard} from ""solmate/utils/ReentrancyGuard.sol"";
import {SafeTransferLib} from ""solmate/utils/SafeTransferLib.sol"";

import {Fei} from ""../interfaces/Fei.sol"";
import {CERC20} from ""../interfaces/CERC20.sol"";

import {TurboSafe} from ""../TurboSafe.sol"";
import {TurboMaster} from ""../TurboMaster.sol"";

/// @title Turbo Gibber
/// @author Transmissions11
/// @notice Atomic impounder module.
contract TurboGibber is Auth, ReentrancyGuard {
    using SafeTransferLib for Fei;

    /*///////////////////////////////////////////////////////////////
                               IMMUTABLES
    //////////////////////////////////////////////////////////////*/

    /// @notice The Master contract.
    /// @dev Used to validate Safes are legitimate.
    TurboMaster public immutable master;

    /// @notice The Fei token on the network.
    Fei public immutable fei;

    /// @notice The Fei cToken in the Turbo Fuse Pool.
    CERC20 public immutable feiTurboCToken;

    /*///////////////////////////////////////////////////////////////
                              CONSTRUCTOR
    //////////////////////////////////////////////////////////////*/

    /// @notice Creates a new Turbo Gibber contract.
    /// @param _master The Master of the Gibber.
    /// @param _owner The owner of the Gibber.
    /// @param _authority The Authority of the Gibber.
    constructor(
        TurboMaster _master,
        address _owner,
        Authority _authority
    ) Auth(_owner, _authority) {
        master = _master;

        fei = Fei(address(master.fei()));

        feiTurboCToken = master.pool().cTokensByUnderlying(fei);

        // Preemptively approve to the Fei cToken in the Turbo Fuse Pool.
        fei.safeApprove(address(feiTurboCToken), type(uint256).max);
    }

    /*///////////////////////////////////////////////////////////////
                          ATOMIC IMPOUND LOGIC
    //////////////////////////////////////////////////////////////*/

    /// @notice Emitted an impound is executed.
    /// @param user The user who executed the impound.
    /// @param safe The Safe that was impounded.
    /// @param feiAmount The amount of Fei that was repaid.
    /// @param assetAmount The amount of assets impounded.
    event ImpoundExecuted(address indexed user, TurboSafe indexed safe, uint256 feiAmount, uint256 assetAmount);

    /// @notice Impound a safe.
    /// @param safe The Safe to be impounded.
    /// @param feiAmount The amount of Fei to repay the Safe's debt with.
    /// @param assetAmount The amount of assets to impound.
    /// @param to The recipient of the impounded collateral tokens.
    function impound(
        TurboSafe safe,
        uint256 feiAmount,
        uint256 assetAmount,
        address to
    ) external requiresAuth nonReentrant {
        // Ensure the Safe is registered with the Master.
        require(master.getSafeId(safe) != 0);

        emit ImpoundExecuted(msg.sender, safe, feiAmount, assetAmount);

        // Mint the Fei amount requested.
        fei.mint(address(this), feiAmount);

        // Repay the safe's Fei debt with the minted Fei, ensuring to catch cToken errors.
        require(feiTurboCToken.repayBorrowBehalf(address(safe), feiAmount) == 0, ""REPAY_FAILED"");

        // Impound some of the safe's collateral and send it to the chosen recipient.
        safe.gib(to, assetAmount);
    }

    /// @notice Impound all of a safe's collateral.
    /// @param safe The Safe to be impounded.
    /// @param to The recipient of the impounded collateral tokens.
    function impoundAll(TurboSafe safe, address to) external requiresAuth nonReentrant {
        // Ensure the Safe is registered with the Master.
        require(master.getSafeId(safe) != 0);

        // Get the asset cToken in the Turbo Fuse Pool.
        CERC20 assetTurboCToken = safe.assetTurboCToken();

        // Get the amount of assets to impound from the Safe.
        uint256 assetAmount = assetTurboCToken.balanceOfUnderlying(address(safe));

        // Get the amount of Fei debt to repay for the Safe.
        uint256 feiAmount = feiTurboCToken.borrowBalanceCurrent(address(safe));

        emit ImpoundExecuted(msg.sender, safe, feiAmount, assetAmount);

        // Mint the Fei amount requested.
        fei.mint(address(this), feiAmount);

        // Repay the safe's Fei debt with the minted Fei, ensuring to catch cToken errors.
        require(feiTurboCToken.repayBorrowBehalf(address(safe), feiAmount) == 0, ""REPAY_FAILED"");

        // Impound all of the safe's collateral and send it to the chosen recipient.
        safe.gib(to, assetAmount);
    }
}",1110
RealWorld_BA_94_IOperatorRole_RealWord_20240826153553.log,94,IOperatorRole,4323,4398,8721,86.0,0.109575,"// SPDX-License-Identifier: MIT OR Apache-2.0

pragma solidity ^0.8.0;

/**
 * @notice Interface for OperatorRole which wraps a role from
 * OpenZeppelin's AccessControl for easy integration.
 */
interface IOperatorRole {
  function isOperator(address account) external view returns (bool);
}",67
RealWorld_BA_94_IOwnable_RealWord_20240826153210.log,94,IOwnable,3878,3845,7723,70.0,0.09629,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

interface IOwnable {
  /**
   * @dev Returns the address of the current owner.
   */
  function owner() external view returns (address);
}",48
RealWorld_BA_94_NFTMarketAuction_RealWord_20240826151048.log,94,NFTMarketAuction,8144,4771,12915,65.0,0.13614,"// SPDX-License-Identifier: MIT OR Apache-2.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";

/**
 * @title An abstraction layer for auctions.
 * @dev This contract can be expanded with reusable calls and data as more auction types are added.
 */
abstract contract NFTMarketAuction is Initializable {
  /**
   * @notice A global id for auctions of any type.
   */
  uint256 private nextAuctionId;

  /**
   * @notice Called once to configure the contract after the initial proxy deployment.
   * @dev This sets the initial auction id to 1, making the first auction cheaper
   * and id 0 represents no auction found.
   */
  function _initializeNFTMarketAuction() internal onlyInitializing {
    nextAuctionId = 1;
  }

  /**
   * @notice Returns id to assign to the next auction.
   */
  function _getNextAndIncrementAuctionId() internal returns (uint256) {
    // AuctionId cannot overflow 256 bits.
    unchecked {
      return nextAuctionId++;
    }
  }

  /**
   * @notice This empty reserved space is put in place to allow future versions to add new
   * variables without shifting down storage in the inheritance chain.
   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps
   */
  uint256[1000] private __gap;
}",313
RealWorld_BA_94_FoundationTreasury_RealWord_20240826145332.log,94,FoundationTreasury,16418,5000,21418,96.0,0.18209,"/*                                                                               
  
   * 
       
         
   *  *  
          *  *.
       *.
    ** *
  *. 
  *
 * *
*
 * 
 *   
                      `                     .-:::::-.`              `-::---...```                   
                     `-:`               .:+ssssoooo++//:.`       .-/+shhhhhhhhhhhhhyyyssooo:        
                    .--::.            .+ossso+/////++/:://-`   .////+shhhhhhhhhhhhhhhhhhhhhy        
                  `-----::.         `/+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy        
                 `------:::-`      `//-.``.-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy        
                .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy        
              `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy        
             .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy        
            .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy        
          `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy        
         .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy        
       `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy        
       .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo        
     .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...``hhhhyo            
                                              `````       
   * 
       
 
   *  *  
          *  *.
       *.
    ** *
  *. 
  *
 * *
*
 *
 
*/

// SPDX-License-Identifier: MIT OR Apache-2.0

pragma solidity ^0.8.0;

import ""./mixins/roles/AdminRole.sol"";
import ""./mixins/roles/OperatorRole.sol"";
import ""./mixins/CollateralManagement.sol"";
import ""./mixins/WithdrawFromEscrow.sol"";

/**
 * @title Manage revenue and roles for Foundation.
 * @notice All fees generated by the market are forwarded to this contract.
 * It also defines the Admin and Operator roles which are used in other contracts.
 */
contract FoundationTreasury is AdminRole, OperatorRole, CollateralManagement, WithdrawFromEscrow {
  function initialize(address admin) external initializer {
    AdminRole._initializeAdminRole(admin);
  }
}",929
RealWorld_BA_94_LockedBalance_RealWord_20240826152756.log,94,LockedBalance,20762,5705,26467,88.0,0.21791,"// SPDX-License-Identifier: MIT OR Apache-2.0

pragma solidity ^0.8.0;

/**
 * @title Library that handles locked balances efficiently using bit packing.
 */
library LockedBalance {
  /// @dev Tracks an account's total lockup per expiration time.
  struct Lockup {
    uint32 expiration;
    uint96 totalAmount;
  }

  struct Lockups {
    /// @dev Mapping from key to lockups.
    /// i) A key represents 2 lockups. The key for a lockup is `index / 2`.
    ///     For instance, elements with index 25 and 24 would map to the same key.
    /// ii) The `value` for the `key` is split into two 128bits which are used to store the metadata for a lockup.
    mapping(uint256 => uint256) lockups;
  }

  // Masks used to split a uint256 into two equal pieces which represent two individual Lockups.
  uint256 private constant last128BitsMask = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;
  uint256 private constant first128BitsMask = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00000000000000000000000000000000;

  // Masks used to retrieve or set the totalAmount value of a single Lockup.
  uint256 private constant firstAmountBitsMask = 0xFFFFFFFF000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;
  uint256 private constant secondAmountBitsMask = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000000;

  /**
   * @notice Clears the lockup at the index.
   */
  function del(Lockups storage lockups, uint256 index) internal {
    unchecked {
      if (index % 2 == 0) {
        index /= 2;
        lockups.lockups[index] = (lockups.lockups[index] & last128BitsMask);
      } else {
        index /= 2;
        lockups.lockups[index] = (lockups.lockups[index] & first128BitsMask);
      }
    }
  }

  /**
   * @notice Sets the Lockup at the provided index.
   */
  function set(
    Lockups storage lockups,
    uint256 index,
    uint256 expiration,
    uint256 totalAmount
  ) internal {
    unchecked {
      uint256 lockedBalanceBits = totalAmount | (expiration << 96);
      if (index % 2 == 0) {
        // set first 128 bits.
        index /= 2;
        lockups.lockups[index] = (lockups.lockups[index] & last128BitsMask) | (lockedBalanceBits << 128);
      } else {
        // set last 128 bits.
        index /= 2;
        lockups.lockups[index] = (lockups.lockups[index] & first128BitsMask) | lockedBalanceBits;
      }
    }
  }

  /**
   * @notice Sets only the totalAmount for a lockup at the index.
   */
  function setTotalAmount(
    Lockups storage lockups,
    uint256 index,
    uint256 totalAmount
  ) internal {
    unchecked {
      if (index % 2 == 0) {
        index /= 2;
        lockups.lockups[index] = (lockups.lockups[index] & firstAmountBitsMask) | (totalAmount << 128);
      } else {
        index /= 2;
        lockups.lockups[index] = (lockups.lockups[index] & secondAmountBitsMask) | totalAmount;
      }
    }
  }

  /**
   * @notice Returns the Lockup at the provided index.
   * @dev To get the lockup stored in the *first* 128 bits (first slot/lockup):
   *       - we remove the last 128 bits (done by >> 128)
   *      To get the lockup stored in the *last* 128 bits (second slot/lockup):
   *       - we take the last 128 bits (done by % (2**128))
   *      Once the lockup is obtained:
   *       - get `expiration` by peaking at the first 32 bits (done by >> 96)
   *       - get `totalAmount` by peaking at the last 96 bits (done by % (2**96))
   */
  function get(Lockups storage lockups, uint256 index) internal view returns (Lockup memory balance) {
    unchecked {
      uint256 lockupMetadata = lockups.lockups[index / 2];
      if (lockupMetadata == 0) {
        return balance;
      }
      uint128 lockedBalanceBits;
      if (index % 2 == 0) {
        // use first 128 bits.
        lockedBalanceBits = uint128(lockupMetadata >> 128);
      } else {
        // use last 128 bits.
        lockedBalanceBits = uint128(lockupMetadata % (2**128));
      }
      // unpack the bits to retrieve the Lockup.
      balance.expiration = uint32(lockedBalanceBits >> 96);
      balance.totalAmount = uint96(lockedBalanceBits % (2**96));
    }
  }
}",1084
RealWorld_BA_94_IRoyaltyInfo_RealWord_20240826153322.log,94,IRoyaltyInfo,6142,4190,10332,77.0,0.11451,"// SPDX-License-Identifier: MIT OR Apache-2.0

pragma solidity ^0.8.0;

/**
 * @notice Interface for EIP-2981: NFT Royalty Standard.
 * For more see: https://eips.ethereum.org/EIPS/eip-2981.
 */
interface IRoyaltyInfo {
  /// @notice Called with the sale price to determine how much royalty
  //          is owed and to whom.
  /// @param _tokenId - the NFT asset queried for royalty information
  /// @param _salePrice - the sale price of the NFT asset specified by _tokenId
  /// @return receiver - address of who should be sent the royalty payment
  /// @return royaltyAmount - the royalty payment amount for _salePrice
  function royaltyInfo(uint256 _tokenId, uint256 _salePrice)
    external
    view
    returns (address receiver, uint256 royaltyAmount);
}",193
RealWorld_BA_94_ISendValueWithFallbackWithdraw_RealWord_20240826154132.log,94,ISendValueWithFallbackWithdraw,4281,4382,8663,70.0,0.109045,"// SPDX-License-Identifier: MIT OR Apache-2.0

pragma solidity ^0.8.0;

/**
 * @notice Attempt to send ETH and if the transfer fails or runs out of gas, store the balance
 * for future withdrawal instead.
 */
interface ISendValueWithFallbackWithdraw {
  /**
   * @notice Allows a user to manually withdraw funds which originally failed to transfer.
   */
  function withdraw() external;
}",88
RealWorld_BA_94_IAdminRole_RealWord_20240826153843.log,94,IAdminRole,4028,3591,7619,97.0,0.09196,"// SPDX-License-Identifier: MIT OR Apache-2.0

pragma solidity ^0.8.0;

/**
 * @notice Interface for AdminRole which wraps the default admin role from
 * OpenZeppelin's AccessControl for easy integration.
 */
interface IAdminRole {
  function isAdmin(address account) external view returns (bool);
}",68
RealWorld_BA_94_NFTMarketPrivateSale_RealWord_20240826150348.log,94,NFTMarketPrivateSale,33153,4898,38051,70.0,0.263725,"// SPDX-License-Identifier: MIT OR Apache-2.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol"";

import ""./NFTMarketFees.sol"";

import ""@openzeppelin/contracts/token/ERC721/IERC721.sol"";

error NFTMarketPrivateSale_Can_Be_Offered_For_24Hrs_Max();
error NFTMarketPrivateSale_Proxy_Address_Is_Not_A_Contract();
error NFTMarketPrivateSale_Sale_Expired();
error NFTMarketPrivateSale_Signature_Verification_Failed();
error NFTMarketPrivateSale_Too_Much_Value_Provided();

/**
 * @title Allows owners to offer an NFT for sale to a specific collector.
 * @notice Private sales are authorized by the seller with an EIP-712 signature.
 * @dev Private sale offers must be accepted by the buyer before they expire, typically in 24 hours.
 */
abstract contract NFTMarketPrivateSale is NFTMarketFees {
  using AddressUpgradeable for address;

  /// @dev This value was replaced with an immutable version.
  bytes32 private __gap_was_DOMAIN_SEPARATOR;

  /// @notice The domain used in EIP-712 signatures.
  /// @dev It is not a constant so that the chainId can be determined dynamically.
  /// If multiple classes use EIP-712 signatures in the future this can move to a shared file.
  bytes32 private immutable DOMAIN_SEPARATOR;

  /// @notice The hash of the private sale method signature used for EIP-712 signatures.
  bytes32 private constant BUY_FROM_PRIVATE_SALE_TYPEHASH =
    keccak256(""BuyFromPrivateSale(address nftContract,uint256 tokenId,address buyer,uint256 price,uint256 deadline)"");
  /// @notice The name used in the EIP-712 domain.
  /// @dev If multiple classes use EIP-712 signatures in the future this can move to the shared constants file.
  string private constant NAME = ""FNDNFTMarket"";

  /**
   * @notice Emitted when an NFT is sold in a private sale.
   * @dev The total amount of this sale is `f8nFee` + `creatorFee` + `ownerRev`.
   * @param nftContract The address of the NFT contract.
   * @param tokenId The ID of the NFT.
   * @param seller The address of the seller.
   * @param buyer The address of the buyer.
   * @param f8nFee The amount of ETH that was sent to Foundation for this sale.
   * @param creatorFee The amount of ETH that was sent to the creator for this sale.
   * @param ownerRev The amount of ETH that was sent to the owner for this sale.
   */
  event PrivateSaleFinalized(
    address indexed nftContract,
    uint256 indexed tokenId,
    address indexed seller,
    address buyer,
    uint256 f8nFee,
    uint256 creatorFee,
    uint256 ownerRev,
    uint256 deadline
  );

  /**
   * @notice Configures the contract to accept EIP-712 signatures.
   * @param marketProxyAddress The address of the proxy contract which will be called when accepting a private sale.
   */
  constructor(address marketProxyAddress) {
    if (!marketProxyAddress.isContract()) {
      revert NFTMarketPrivateSale_Proxy_Address_Is_Not_A_Contract();
    }
    uint256 chainId;
    // solhint-disable-next-line no-inline-assembly
    assembly {
      chainId := chainid()
    }
    DOMAIN_SEPARATOR = keccak256(
      abi.encode(
        keccak256(""EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)""),
        keccak256(bytes(NAME)),
        // Incrementing the version can be used to invalidate previously signed messages.
        keccak256(bytes(""1"")),
        chainId,
        marketProxyAddress
      )
    );
  }

  /**
   * @notice Buy an NFT from a private sale.
   * @dev The seller signs a message approving the sale and then the buyer calls this function
   * with the `msg.value` equal to the agreed upon price.
   * @param nftContract The address of the NFT contract.
   * @param tokenId The ID of the NFT.
   * @param deadline The timestamp at which the offer to sell will expire.
   * @param v The v value of the EIP-712 signature.
   * @param r The r value of the EIP-712 signature.
   * @param s The s value of the EIP-712 signature.
   */
  function buyFromPrivateSale(
    IERC721 nftContract,
    uint256 tokenId,
    uint256 deadline,
    uint8 v,
    bytes32 r,
    bytes32 s
  ) external payable {
    buyFromPrivateSaleFor(nftContract, tokenId, msg.value, deadline, v, r, s);
  }

  /**
   * @notice Buy an NFT from a private sale.
   * @dev The seller signs a message approving the sale and then the buyer calls this function
   * with the `amount` equal to the agreed upon price.
   * @dev `amount` - `msg.value` is withdrawn from the bidder's FETH balance.
   * @param nftContract The address of the NFT contract.
   * @param tokenId The ID of the NFT.
   * @param amount The amount to buy for, if this is more than `msg.value` funds will be
   * withdrawn from your FETH balance.
   * @param deadline The timestamp at which the offer to sell will expire.
   * @param v The v value of the EIP-712 signature.
   * @param r The r value of the EIP-712 signature.
   * @param s The s value of the EIP-712 signature.
   */
  function buyFromPrivateSaleFor(
    IERC721 nftContract,
    uint256 tokenId,
    uint256 amount,
    uint256 deadline,
    uint8 v,
    bytes32 r,
    bytes32 s
  ) public payable nonReentrant {
    if (deadline < block.timestamp) {
      // The signed message from the seller has expired.
      revert NFTMarketPrivateSale_Sale_Expired();
    } else if (deadline > block.timestamp + 2 days) {
      // Private sales typically expire in 24 hours, but 2 days is used here in order to ensure
      // that transactions do not fail due to a minor timezone error or similar during signing.

      // This prevents malicious actors from requesting signatures that never expire.
      revert NFTMarketPrivateSale_Can_Be_Offered_For_24Hrs_Max();
    }

    if (amount > msg.value) {
      // Withdraw additional ETH required from their available FETH balance.

      unchecked {
        // The if above ensures delta will not underflow
        uint256 delta = amount - msg.value;
        feth.marketWithdrawFrom(msg.sender, delta);
      }
    } else if (amount < msg.value) {
      // The terms of the sale cannot change, so if too much ETH is sent then something went wrong.
      revert NFTMarketPrivateSale_Too_Much_Value_Provided();
    }

    // The seller must have the NFT in their wallet when this function is called,
    // otherwise the signature verification below will fail.
    address payable seller = payable(nftContract.ownerOf(tokenId));

    // Scoping this block to avoid a stack too deep error
    {
      bytes32 digest = keccak256(
        abi.encodePacked(
          ""\x19\x01"",
          DOMAIN_SEPARATOR,
          keccak256(abi.encode(BUY_FROM_PRIVATE_SALE_TYPEHASH, nftContract, tokenId, msg.sender, amount, deadline))
        )
      );

      // Revert if the signature is invalid, the terms are not as expected, or if the seller transferred the NFT.
      if (ecrecover(digest, v, r, s) != seller) {
        revert NFTMarketPrivateSale_Signature_Verification_Failed();
      }
    }

    // This should revert if the seller has not given the market contract approval.
    nftContract.transferFrom(seller, msg.sender, tokenId);

    // Distribute revenue for this sale.
    (uint256 f8nFee, uint256 creatorFee, uint256 ownerRev) = _distributeFunds(
      address(nftContract),
      tokenId,
      seller,
      amount
    );

    emit PrivateSaleFinalized(
      address(nftContract),
      tokenId,
      seller,
      msg.sender,
      f8nFee,
      creatorFee,
      ownerRev,
      deadline
    );
  }

  /**
   * @notice This empty reserved space is put in place to allow future versions to add new
   * variables without shifting down storage in the inheritance chain.
   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps
   */
  uint256[1000] private __gap;
}",1896
RealWorld_BA_94_FNDNFTMarket_RealWord_20240826145656.log,94,FNDNFTMarket,29247,5762,35009,95.0,0.261475,"/*
  
   *
       
         
   *  *  
          *  *.
       *.

                      `                     .-:::::-.`              `-::---...```
                     `-:`               .:+ssssoooo++//:.`       .-/+shhhhhhhhhhhhhyyyssooo:
                    .--::.            .+ossso+/////++/:://-`   .////+shhhhhhhhhhhhhhhhhhhhhy
                  `-----::.         `/+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy
                 `------:::-`      `//-.``.-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy
                .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy
              `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy
             .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy
            .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy
          `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy
         .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy
       `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy
       .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo
     .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...``hhhhyo
                                              `````
   *
       
 
   *  *  
          *  *.
       *.
    ** *
  *. 
  *
 * *
*
 *
 
*/

// SPDX-License-Identifier: MIT OR Apache-2.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";
import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";

import ""./mixins/Constants.sol"";
import ""./mixins/FoundationTreasuryNode.sol"";
import ""./mixins/NFTMarketAuction.sol"";
import ""./mixins/NFTMarketBuyPrice.sol"";
import ""./mixins/NFTMarketCore.sol"";
import ""./mixins/NFTMarketCreators.sol"";
import ""./mixins/NFTMarketFees.sol"";
import ""./mixins/NFTMarketOffer.sol"";
import ""./mixins/NFTMarketPrivateSale.sol"";
import ""./mixins/NFTMarketReserveAuction.sol"";
import ""./mixins/SendValueWithFallbackWithdraw.sol"";

/**
 * @title A market for NFTs on Foundation.
 * @notice The Foundation marketplace is a contract which allows traders to buy and sell NFTs.
 * It supports buying and selling via auctions, private sales, buy price, and offers.
 * @dev All sales in the Foundation market will pay the creator 10% royalties on secondary sales. This is not specific
 * to NFTs minted on Foundation, it should work for any NFT. If royalty information was not defined when the NFT was
 * originally deployed, it may be added using the [Royalty Registry](https://royaltyregistry.xyz/) which will be
 * respected by our market contract.
 */
contract FNDNFTMarket is
  Constants,
  Initializable,
  FoundationTreasuryNode,
  NFTMarketCore,
  ReentrancyGuardUpgradeable,
  NFTMarketCreators,
  SendValueWithFallbackWithdraw,
  NFTMarketFees,
  NFTMarketAuction,
  NFTMarketReserveAuction,
  NFTMarketPrivateSale,
  NFTMarketBuyPrice,
  NFTMarketOffer
{
  /**
   * @notice Set immutable variables for the implementation contract.
   * @dev Using immutable instead of constants allows us to use different values on testnet.
   */
  constructor(
    address payable treasury,
    address feth,
    address royaltyRegistry,
    uint256 duration,
    address marketProxyAddress
  )
    FoundationTreasuryNode(treasury)
    NFTMarketCore(feth)
    NFTMarketCreators(royaltyRegistry)
    NFTMarketReserveAuction(duration)
    NFTMarketPrivateSale(marketProxyAddress) // solhint-disable-next-line no-empty-blocks
  {}

  /**
   * @notice Called once to configure the contract after the initial proxy deployment.
   * @dev This farms the initialize call out to inherited contracts as needed to initialize mutable variables.
   */
  function initialize() external initializer {
    NFTMarketAuction._initializeNFTMarketAuction();
  }

  /**
   * @inheritdoc NFTMarketCore
   * @dev This is a no-op function required to avoid compile errors.
   */
  function _afterAuctionStarted(address nftContract, uint256 tokenId)
    internal
    override(NFTMarketCore, NFTMarketBuyPrice, NFTMarketOffer)
  {
    super._afterAuctionStarted(nftContract, tokenId);
  }

  /**
   * @inheritdoc NFTMarketCore
   * @dev This is a no-op function required to avoid compile errors.
   */
  function _transferFromEscrow(
    address nftContract,
    uint256 tokenId,
    address recipient,
    address seller
  ) internal override(NFTMarketCore, NFTMarketReserveAuction, NFTMarketBuyPrice, NFTMarketOffer) {
    super._transferFromEscrow(nftContract, tokenId, recipient, seller);
  }

  /**
   * @inheritdoc NFTMarketCore
   * @dev This is a no-op function required to avoid compile errors.
   */
  function _transferFromEscrowIfAvailable(
    address nftContract,
    uint256 tokenId,
    address recipient
  ) internal override(NFTMarketCore, NFTMarketReserveAuction, NFTMarketBuyPrice) {
    super._transferFromEscrowIfAvailable(nftContract, tokenId, recipient);
  }

  /**
   * @inheritdoc NFTMarketCore
   * @dev This is a no-op function required to avoid compile errors.
   */
  function _transferToEscrow(address nftContract, uint256 tokenId)
    internal
    override(NFTMarketCore, NFTMarketReserveAuction, NFTMarketBuyPrice)
  {
    super._transferToEscrow(nftContract, tokenId);
  }

  /**
   * @inheritdoc NFTMarketCore
   * @dev This is a no-op function required to avoid compile errors.
   */
  function _getSellerFor(address nftContract, uint256 tokenId)
    internal
    view
    override(NFTMarketCore, NFTMarketReserveAuction, NFTMarketBuyPrice)
    returns (address payable seller)
  {
    return super._getSellerFor(nftContract, tokenId);
  }
}",1760
RealWorld_BA_94_FoundationTreasuryNode_RealWord_20240826150228.log,94,FoundationTreasuryNode,11415,5043,16458,78.0,0.157935,"// SPDX-License-Identifier: MIT OR Apache-2.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";

import ""../interfaces/IAdminRole.sol"";
import ""../interfaces/IOperatorRole.sol"";

error FoundationTreasuryNode_Address_Is_Not_A_Contract();
error FoundationTreasuryNode_Caller_Not_Admin();
error FoundationTreasuryNode_Caller_Not_Operator();

/**
 * @title A mixin that stores a reference to the Foundation treasury contract.
 * @notice The treasury collects fees and defines admin/operator roles.
 */
abstract contract FoundationTreasuryNode is Initializable {
  using AddressUpgradeable for address payable;

  /// @dev This value was replaced with an immutable version.
  address payable private __gap_was_treasury;

  /// @notice The address of the treasury contract.
  address payable private immutable treasury;

  /// @notice Requires the caller is a Foundation admin.
  modifier onlyFoundationAdmin() {
    if (!IAdminRole(treasury).isAdmin(msg.sender)) {
      revert FoundationTreasuryNode_Caller_Not_Admin();
    }
    _;
  }

  /// @notice Requires the caller is a Foundation operator.
  modifier onlyFoundationOperator() {
    if (!IOperatorRole(treasury).isOperator(msg.sender)) {
      revert FoundationTreasuryNode_Caller_Not_Operator();
    }
    _;
  }

  /**
   * @notice Set immutable variables for the implementation contract.
   * @dev Assigns the treasury contract address.
   */
  constructor(address payable _treasury) {
    if (!_treasury.isContract()) {
      revert FoundationTreasuryNode_Address_Is_Not_A_Contract();
    }
    treasury = _treasury;
  }

  /**
   * @notice Gets the Foundation treasury contract.
   * @return treasuryAddress The address of the Foundation treasury contract.
   * @dev This call is used in the royalty registry contract.
   */
  function getFoundationTreasury() public view returns (address payable treasuryAddress) {
    return treasury;
  }

  /**
   * @notice This empty reserved space is put in place to allow future versions to add new
   * variables without shifting down storage in the inheritance chain.
   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps
   */
  uint256[2000] private __gap;
}",509
RealWorld_BA_94_EmptyMockContract_RealWord_20240826150110.log,94,EmptyMockContract,3614,4222,7836,76.0,0.10251,"// SPDX-License-Identifier: MIT OR Apache-2.0

pragma solidity ^0.8.0;

contract EmptyMockContract {
  // Something must be included in order to generate the typechain file
  event DummyEvent();
}",48
RealWorld_BA_94_AccessControlUpgradeable_RealWord_20240826152453.log,94,AccessControlUpgradeable,35338,5131,40469,89.0,0.27931,"// SPDX-License-Identifier: MIT

/**
 * Copied from https://raw.githubusercontent.com/OpenZeppelin/openzeppelin-contracts-upgradeable/v3.4.2-solc-0.7
 * Modified to support solc-8.
 * Using this instead of the new OZ implementation due to a change in storage slots used.
 * Also limited access of several functions as we will be using convenience wrappers.
 */

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/utils/structs/EnumerableSet.sol"";
import ""@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";

// solhint-disable

/**
 * @title Implements role-based access control mechanisms.
 * @dev Contract module that allows children to implement role-based access
 * control mechanisms.
 *
 * Roles are referred to by their `bytes32` identifier. These should be exposed
 * in the external API and be unique. The best way to achieve this is by
 * using `public constant` hash digests:
 *
 * ```
 * bytes32 public constant MY_ROLE = keccak256(""MY_ROLE"");
 * ```
 *
 * Roles can be used to represent a set of permissions. To restrict access to a
 * function call, use {hasRole}:
 *
 * ```
 * function foo() public {
 *     require(hasRole(MY_ROLE, msg.sender));
 *     ...
 * }
 * ```
 *
 * Roles can be granted and revoked dynamically via the {grantRole} and
 * {revokeRole} functions. Each role has an associated admin role, and only
 * accounts that have a role's admin role can call {grantRole} and {revokeRole}.
 *
 * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means
 * that only accounts with this role will be able to grant or revoke other
 * roles. More complex role relationships can be created by using
 * {_setRoleAdmin}.
 *
 * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to
 * grant and revoke this role. Extra precautions should be taken to secure
 * accounts that have been granted it.
 */
abstract contract AccessControlUpgradeable is Initializable, ContextUpgradeable {
  function __AccessControl_init() internal onlyInitializing {
    __Context_init_unchained();
    __AccessControl_init_unchained();
  }

  function __AccessControl_init_unchained() internal onlyInitializing {}

  using EnumerableSet for EnumerableSet.AddressSet;
  using AddressUpgradeable for address;

  struct RoleData {
    EnumerableSet.AddressSet members;
    bytes32 adminRole;
  }

  mapping(bytes32 => RoleData) private _roles;

  bytes32 internal constant DEFAULT_ADMIN_ROLE = 0x00;

  /**
   * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`
   *
   * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite
   * {RoleAdminChanged} not being emitted signaling this.
   *
   * _Available since v3.1._
   */
  event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);

  /**
   * @dev Emitted when `account` is granted `role`.
   *
   * `sender` is the account that originated the contract call, an admin role
   * bearer except when using {_setupRole}.
   */
  event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);

  /**
   * @dev Emitted when `account` is revoked `role`.
   *
   * `sender` is the account that originated the contract call:
   *   - if using `revokeRole`, it is the admin role bearer
   *   - if using `renounceRole`, it is the role bearer (i.e. `account`)
   */
  event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);

  /**
   * @dev Returns `true` if `account` has been granted `role`.
   */
  function hasRole(bytes32 role, address account) internal view returns (bool) {
    return _roles[role].members.contains(account);
  }

  /**
   * @dev Returns the number of accounts that have `role`. Can be used
   * together with {getRoleMember} to enumerate all bearers of a role.
   */
  function getRoleMemberCount(bytes32 role) internal view returns (uint256) {
    return _roles[role].members.length();
  }

  /**
   * @dev Returns one of the accounts that have `role`. `index` must be a
   * value between 0 and {getRoleMemberCount}, non-inclusive.
   *
   * Role bearers are not sorted in any particular way, and their ordering may
   * change at any point.
   *
   * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure
   * you perform all queries on the same block. See the following
   * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]
   * for more information.
   */
  function getRoleMember(bytes32 role, uint256 index) internal view returns (address) {
    return _roles[role].members.at(index);
  }

  /**
   * @dev Returns the admin role that controls `role`. See {grantRole} and
   * {revokeRole}.
   *
   * To change a role's admin, use {_setRoleAdmin}.
   */
  function getRoleAdmin(bytes32 role) internal view returns (bytes32) {
    return _roles[role].adminRole;
  }

  /**
   * @dev Grants `role` to `account`.
   *
   * If `account` had not been already granted `role`, emits a {RoleGranted}
   * event.
   *
   * Requirements:
   *
   * - the caller must have ``role``'s admin role.
   */
  function grantRole(bytes32 role, address account) internal virtual {
    require(hasRole(_roles[role].adminRole, _msgSender()), ""AccessControl: sender must be an admin to grant"");

    _grantRole(role, account);
  }

  /**
   * @dev Revokes `role` from `account`.
   *
   * If `account` had been granted `role`, emits a {RoleRevoked} event.
   *
   * Requirements:
   *
   * - the caller must have ``role``'s admin role.
   */
  function revokeRole(bytes32 role, address account) internal virtual {
    require(hasRole(_roles[role].adminRole, _msgSender()), ""AccessControl: sender must be an admin to revoke"");

    _revokeRole(role, account);
  }

  /**
   * @dev Revokes `role` from the calling account.
   *
   * Roles are often managed via {grantRole} and {revokeRole}: this function's
   * purpose is to provide a mechanism for accounts to lose their privileges
   * if they are compromised (such as when a trusted device is misplaced).
   *
   * If the calling account had been granted `role`, emits a {RoleRevoked}
   * event.
   *
   * Requirements:
   *
   * - the caller must be `account`.
   */
  function renounceRole(bytes32 role, address account) internal virtual {
    require(account == _msgSender(), ""AccessControl: can only renounce roles for self"");

    _revokeRole(role, account);
  }

  /**
   * @dev Grants `role` to `account`.
   *
   * If `account` had not been already granted `role`, emits a {RoleGranted}
   * event. Note that unlike {grantRole}, this function doesn't perform any
   * checks on the calling account.
   *
   * [WARNING]
   * ====
   * This function should only be called from the constructor when setting
   * up the initial roles for the system.
   *
   * Using this function in any other way is effectively circumventing the admin
   * system imposed by {AccessControl}.
   * ====
   */
  function _setupRole(bytes32 role, address account) internal {
    _grantRole(role, account);
  }

  /**
   * @dev Sets `adminRole` as ``role``'s admin role.
   *
   * Emits a {RoleAdminChanged} event.
   */
  function _setRoleAdmin(bytes32 role, bytes32 adminRole) private {
    emit RoleAdminChanged(role, _roles[role].adminRole, adminRole);
    _roles[role].adminRole = adminRole;
  }

  function _grantRole(bytes32 role, address account) private {
    if (_roles[role].members.add(account)) {
      emit RoleGranted(role, account, _msgSender());
    }
  }

  function _revokeRole(bytes32 role, address account) private {
    if (_roles[role].members.remove(account)) {
      emit RoleRevoked(role, account, _msgSender());
    }
  }

  /**
   * @notice This empty reserved space is put in place to allow future versions to add new
   * variables without shifting down storage in the inheritance chain.
   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps
   */
  uint256[49] private __gap;
}",2029
RealWorld_BA_94_SendValueWithFallbackWithdraw_RealWord_20240826151809.log,94,SendValueWithFallbackWithdraw,16002,5649,21651,107.0,0.19299,"// SPDX-License-Identifier: MIT OR Apache-2.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";

error SendValueWithFallbackWithdraw_No_Funds_Available();

/**
 * @title A mixin for sending ETH with a fallback withdraw mechanism.
 * @notice Attempt to send ETH and if the transfer fails or runs out of gas, store the balance
 * for future withdrawal instead.
 */
abstract contract SendValueWithFallbackWithdraw is ReentrancyGuardUpgradeable {
  using AddressUpgradeable for address payable;

  /// @dev Tracks the amount of ETH that is stored in escrow for future withdrawal.
  mapping(address => uint256) private pendingWithdrawals;

  /**
   * @notice Emitted when an attempt to send ETH fails or runs out of gas and the value is stored in escrow instead.
   * @param user The account which has escrowed ETH to withdraw.
   * @param amount The amount of ETH which has been added to the user's escrow balance.
   */
  event WithdrawPending(address indexed user, uint256 amount);
  /**
   * @notice Emitted when escrowed funds are withdrawn.
   * @param user The account which has withdrawn ETH.
   * @param amount The amount of ETH which has been withdrawn.
   */
  event Withdrawal(address indexed user, uint256 amount);

  /**
   * @notice Allows a user to manually withdraw funds which originally failed to transfer to themselves.
   */
  function withdraw() external {
    withdrawFor(payable(msg.sender));
  }

  /**
   * @notice Allows anyone to manually trigger a withdrawal of funds which originally failed to transfer for a user.
   * @param user The account which has escrowed ETH to withdraw.
   */
  function withdrawFor(address payable user) public nonReentrant {
    uint256 amount = pendingWithdrawals[user];
    if (amount == 0) {
      revert SendValueWithFallbackWithdraw_No_Funds_Available();
    }
    pendingWithdrawals[user] = 0;
    user.sendValue(amount);
    emit Withdrawal(user, amount);
  }

  /**
   * @dev Attempt to send a user or contract ETH and if it fails store the amount owned for later withdrawal.
   */
  function _sendValueWithFallbackWithdraw(
    address payable user,
    uint256 amount,
    uint256 gasLimit
  ) internal {
    if (amount == 0) {
      return;
    }
    // Cap the gas to prevent consuming all available gas to block a tx from completing successfully
    // solhint-disable-next-line avoid-low-level-calls
    (bool success, ) = user.call{ value: amount, gas: gasLimit }("""");
    if (!success) {
      // Record failed sends for a withdrawal later
      // Transfers could fail if sent to a multisig with non-trivial receiver logic
      unchecked {
        pendingWithdrawals[user] += amount;
      }
      emit WithdrawPending(user, amount);
    }
  }

  /**
   * @notice Returns how much funds are available for manual withdraw due to failed transfers.
   * @param user The account to check the escrowed balance of.
   * @return balance The amount of funds which are available for withdrawal for the given user.
   */
  function getPendingWithdrawal(address user) external view returns (uint256 balance) {
    return pendingWithdrawals[user];
  }

  /**
   * @notice This empty reserved space is put in place to allow future versions to add new
   * variables without shifting down storage in the inheritance chain.
   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps
   */
  uint256[499] private __gap;
}",802
RealWorld_BA_94_WithdrawFromEscrow_RealWord_20240826151515.log,94,WithdrawFromEscrow,5878,4960,10838,77.0,0.12859,"// SPDX-License-Identifier: MIT OR Apache-2.0

pragma solidity ^0.8.0;

import ""../mixins/roles/AdminRole.sol"";

import ""../interfaces/ISendValueWithFallbackWithdraw.sol"";

/**
 * @title Recovers funds in escrow.
 * @notice Allows recovery of funds that were not successfully transferred directly by the market.
 */
abstract contract WithdrawFromEscrow is AdminRole {
  /**
   * @notice Allows an admin to withdraw funds in the market escrow.
   * @dev This only applies when funds were unable to send, such as due to an out of gas error.
   * @param market The address of the contract to withdraw from.
   */
  function withdrawFromEscrow(ISendValueWithFallbackWithdraw market) external onlyAdmin {
    market.withdraw();
  }
}",167
RealWorld_BA_94_NFTMarketReserveAuction_RealWord_20240826151335.log,94,NFTMarketReserveAuction,108187,6102,114289,97.0,0.662975,"// SPDX-License-Identifier: MIT OR Apache-2.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";

import ""../libraries/AccountMigrationLibrary.sol"";
import ""./Constants.sol"";
import ""./FoundationTreasuryNode.sol"";
import ""./NFTMarketAuction.sol"";
import ""./NFTMarketCore.sol"";
import ""./NFTMarketFees.sol"";
import ""./SendValueWithFallbackWithdraw.sol"";

import ""@openzeppelin/contracts/token/ERC721/IERC721.sol"";

/// @param minAmount The minimum amount that must be bid in order for it to be accepted.
error NFTMarketReserveAuction_Bid_Must_Be_At_Least_Min_Amount(uint256 minAmount);
error NFTMarketReserveAuction_Cannot_Admin_Cancel_Without_Reason();
/// @param reservePrice The current reserve price.
error NFTMarketReserveAuction_Cannot_Bid_Lower_Than_Reserve_Price(uint256 reservePrice);
/// @param endTime The timestamp at which the auction had ended.
error NFTMarketReserveAuction_Cannot_Bid_On_Ended_Auction(uint256 endTime);
error NFTMarketReserveAuction_Cannot_Bid_On_Nonexistent_Auction();
error NFTMarketReserveAuction_Cannot_Cancel_Nonexistent_Auction();
error NFTMarketReserveAuction_Cannot_Finalize_Already_Settled_Auction();
/// @param endTime The timestamp at which the auction will end.
error NFTMarketReserveAuction_Cannot_Finalize_Auction_In_Progress(uint256 endTime);
/// @param seller The current owner of the NFT.
error NFTMarketReserveAuction_Cannot_Migrate_Non_Matching_Seller(address seller);
error NFTMarketReserveAuction_Cannot_Rebid_Over_Outstanding_Bid();
error NFTMarketReserveAuction_Cannot_Update_Auction_In_Progress();
/// @param maxDuration The maximum configuration for a duration of the auction, in seconds.
error NFTMarketReserveAuction_Exceeds_Max_Duration(uint256 maxDuration);
/// @param extensionDuration The extension duration, in seconds.
error NFTMarketReserveAuction_Less_Than_Extension_Duration(uint256 extensionDuration);
error NFTMarketReserveAuction_Must_Set_Non_Zero_Reserve_Price();
/// @param seller The current owner of the NFT.
error NFTMarketReserveAuction_Not_Matching_Seller(address seller);
/// @param owner The current owner of the NFT.
error NFTMarketReserveAuction_Only_Owner_Can_Update_Auction(address owner);
error NFTMarketReserveAuction_Too_Much_Value_Provided();

/**
 * @title Allows the owner of an NFT to list it in auction.
 * @notice NFTs in auction are escrowed in the market contract.
 * @dev There is room to optimize the storage for auctions, significantly reducing gas costs.
 * This may be done in the future, but for now it will remain as is in order to ease upgrade compatibility.
 */
abstract contract NFTMarketReserveAuction is
  Constants,
  FoundationTreasuryNode,
  NFTMarketCore,
  ReentrancyGuardUpgradeable,
  SendValueWithFallbackWithdraw,
  NFTMarketFees,
  NFTMarketAuction
{
  using AccountMigrationLibrary for address;

  /// @notice Stores the auction configuration for a specific NFT.
  struct ReserveAuction {
    /// @notice The address of the NFT contract.
    address nftContract;
    /// @notice The id of the NFT.
    uint256 tokenId;
    /// @notice The owner of the NFT which listed it in auction.
    address payable seller;
    /// @notice The duration for this auction.
    uint256 duration;
    /// @notice The extension window for this auction.
    uint256 extensionDuration;
    /// @notice The time at which this auction will not accept any new bids.
    /// @dev This is `0` until the first bid is placed.
    uint256 endTime;
    /// @notice The current highest bidder in this auction.
    /// @dev This is `address(0)` until the first bid is placed.
    address payable bidder;
    /// @notice The latest price of the NFT in this auction.
    /// @dev This is set to the reserve price, and then to the highest bid once the auction has started.
    uint256 amount;
  }

  /// @notice The auction configuration for a specific auction id.
  mapping(address => mapping(uint256 => uint256)) private nftContractToTokenIdToAuctionId;
  /// @notice The auction id for a specific NFT.
  /// @dev This is deleted when an auction is finalized or canceled.
  mapping(uint256 => ReserveAuction) private auctionIdToAuction;

  /**
   * @dev Removing old unused variables in an upgrade safe way. Was:
   * uint256 private __gap_was_minPercentIncrementInBasisPoints;
   * uint256 private __gap_was_maxBidIncrementRequirement;
   * uint256 private __gap_was_duration;
   * uint256 private __gap_was_extensionDuration;
   * uint256 private __gap_was_goLiveDate;
   */
  uint256[5] private __gap_was_config;

  /// @notice How long an auction lasts for once the first bid has been received.
  uint256 private immutable DURATION;

  /// @notice The window for auction extensions, any bid placed in the final 15 minutes
  /// of an auction will reset the time remaining to 15 minutes.
  uint256 private constant EXTENSION_DURATION = 15 minutes;

  /// @notice Caps the max duration that may be configured so that overflows will not occur.
  uint256 private constant MAX_MAX_DURATION = 1000 days;

  /**
   * @notice Emitted when a bid is placed.
   * @param auctionId The id of the auction this bid was for.
   * @param bidder The address of the bidder.
   * @param amount The amount of the bid.
   * @param endTime The new end time of the auction (which may have been set or extended by this bid).
   */
  event ReserveAuctionBidPlaced(uint256 indexed auctionId, address indexed bidder, uint256 amount, uint256 endTime);
  /**
   * @notice Emitted when an auction is cancelled.
   * @dev This is only possible if the auction has not received any bids.
   * @param auctionId The id of the auction that was cancelled.
   */
  event ReserveAuctionCanceled(uint256 indexed auctionId);
  /**
   * @notice Emitted when an auction is canceled by a Foundation admin.
   * @dev When this occurs, the highest bidder (if there was a bid) is automatically refunded.
   * @param auctionId The id of the auction that was cancelled.
   * @param reason The reason for the cancellation.
   */
  event ReserveAuctionCanceledByAdmin(uint256 indexed auctionId, string reason);
  /**
   * @notice Emitted when an NFT is listed for auction.
   * @param seller The address of the seller.
   * @param nftContract The address of the NFT contract.
   * @param tokenId The id of the NFT.
   * @param duration The duration of the auction (always 24-hours).
   * @param extensionDuration The duration of the auction extension window (always 15-minutes).
   * @param reservePrice The reserve price to kick off the auction.
   * @param auctionId The id of the auction that was created.
   */
  event ReserveAuctionCreated(
    address indexed seller,
    address indexed nftContract,
    uint256 indexed tokenId,
    uint256 duration,
    uint256 extensionDuration,
    uint256 reservePrice,
    uint256 auctionId
  );
  /**
   * @notice Emitted when an auction that has already ended is finalized,
   * indicating that the NFT has been transferred and revenue from the sale distributed.
   * @dev The amount of the highest bid / final sale price for this auction is `f8nFee` + `creatorFee` + `ownerRev`.
   * @param auctionId The id of the auction that was finalized.
   * @param seller The address of the seller.
   * @param bidder The address of the highest bidder that won the NFT.
   * @param f8nFee The amount of ETH that was sent to Foundation for this sale.
   * @param creatorFee The amount of ETH that was sent to the creator for this sale.
   * @param ownerRev The amount of ETH that was sent to the owner for this sale.
   */
  event ReserveAuctionFinalized(
    uint256 indexed auctionId,
    address indexed seller,
    address indexed bidder,
    uint256 f8nFee,
    uint256 creatorFee,
    uint256 ownerRev
  );
  /**
   * @notice Emitted when an auction is invalidated due to other market activity.
   * @dev This occurs when the NFT is sold another way, such as with `buy` or `acceptOffer`.
   * @param auctionId The id of the auction that was invalidated.
   */
  event ReserveAuctionInvalidated(uint256 indexed auctionId);
  /**
   * @notice Emitted when the seller for an auction has been changed to a new account.
   * @dev Account migrations require approval from both the original account and Foundation.
   * @param auctionId The id of the auction that was updated.
   * @param originalSellerAddress The original address of the auction's seller.
   * @param newSellerAddress The new address for the auction's seller.
   */
  event ReserveAuctionSellerMigrated(
    uint256 indexed auctionId,
    address indexed originalSellerAddress,
    address indexed newSellerAddress
  );
  /**
   * @notice Emitted when the auction's reserve price is changed.
   * @dev This is only possible if the auction has not received any bids.
   * @param auctionId The id of the auction that was updated.
   * @param reservePrice The new reserve price for the auction.
   */
  event ReserveAuctionUpdated(uint256 indexed auctionId, uint256 reservePrice);

  /// @notice Confirms that the reserve price is not zero.
  modifier onlyValidAuctionConfig(uint256 reservePrice) {
    if (reservePrice == 0) {
      revert NFTMarketReserveAuction_Must_Set_Non_Zero_Reserve_Price();
    }
    _;
  }

  /**
   * @notice Configures the duration for auctions.
   * @param duration The duration for auctions, in seconds.
   */
  constructor(uint256 duration) {
    if (duration > MAX_MAX_DURATION) {
      // This ensures that math in this file will not overflow due to a huge duration.
      revert NFTMarketReserveAuction_Exceeds_Max_Duration(MAX_MAX_DURATION);
    }
    if (duration < EXTENSION_DURATION) {
      // The auction duration configuration must be greater than the extension window of 15 minutes
      revert NFTMarketReserveAuction_Less_Than_Extension_Duration(EXTENSION_DURATION);
    }
    DURATION = duration;
  }

  /**
   * @notice Allows Foundation to cancel an auction, refunding the bidder and returning the NFT to
   * the seller (if not active buy price set).
   * This should only be used for extreme cases such as DMCA takedown requests.
   * @param auctionId The id of the auction to cancel.
   * @param reason The reason for the cancellation (a required field).
   */
  function adminCancelReserveAuction(uint256 auctionId, string calldata reason)
    external
    onlyFoundationAdmin
    nonReentrant
  {
    if (bytes(reason).length == 0) {
      revert NFTMarketReserveAuction_Cannot_Admin_Cancel_Without_Reason();
    }
    ReserveAuction memory auction = auctionIdToAuction[auctionId];
    if (auction.amount == 0) {
      revert NFTMarketReserveAuction_Cannot_Cancel_Nonexistent_Auction();
    }

    delete nftContractToTokenIdToAuctionId[auction.nftContract][auction.tokenId];
    delete auctionIdToAuction[auctionId];

    // Return the NFT to the owner.
    _transferFromEscrowIfAvailable(auction.nftContract, auction.tokenId, auction.seller);

    if (auction.bidder != address(0)) {
      // Refund the highest bidder if any bids were placed in this auction.
      _sendValueWithFallbackWithdraw(auction.bidder, auction.amount, SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT);
    }

    emit ReserveAuctionCanceledByAdmin(auctionId, reason);
  }

  /**
   * @notice Allows an NFT owner and Foundation to work together in order to update the seller
   * for auctions they have listed to a new account.
   * @dev This will gracefully skip any auctions that have already been finalized.
   * @param listedAuctionIds The ids of the auctions to update.
   * @param originalAddress The original address of the seller of these auctions.
   * @param newAddress The new address for the seller of these auctions.
   * @param signature Message `I authorize Foundation to migrate my account to ${newAccount.address.toLowerCase()}`
   * signed by the original account.
   */
  function adminAccountMigration(
    uint256[] calldata listedAuctionIds,
    address originalAddress,
    address payable newAddress,
    bytes memory signature
  ) external onlyFoundationOperator {
    // Validate the owner of the original account has approved this change.
    originalAddress.requireAuthorizedAccountMigration(newAddress, signature);

    unchecked {
      // The array length cannot overflow 256 bits.
      for (uint256 i = 0; i < listedAuctionIds.length; ++i) {
        uint256 auctionId = listedAuctionIds[i];
        ReserveAuction storage auction = auctionIdToAuction[auctionId];
        if (auction.seller != address(0)) {
          // Only if the auction was found and not finalized before this transaction.

          if (auction.seller != originalAddress) {
            // Confirm that the signature approval was the correct owner of this auction.
            revert NFTMarketReserveAuction_Cannot_Migrate_Non_Matching_Seller(auction.seller);
          }

          // Update the auction's seller address.
          auction.seller = newAddress;

          emit ReserveAuctionSellerMigrated(auctionId, originalAddress, newAddress);
        }
      }
    }
  }

  /**
   * @notice If an auction has been created but has not yet received bids, it may be canceled by the seller.
   * @dev The NFT is transferred back to the owner unless there is still has a buy price set.
   * @param auctionId The id of the auction to cancel.
   */
  function cancelReserveAuction(uint256 auctionId) external nonReentrant {
    ReserveAuction memory auction = auctionIdToAuction[auctionId];
    if (auction.seller != msg.sender) {
      revert NFTMarketReserveAuction_Only_Owner_Can_Update_Auction(auction.seller);
    }
    if (auction.endTime != 0) {
      revert NFTMarketReserveAuction_Cannot_Update_Auction_In_Progress();
    }

    // Remove the auction.
    delete nftContractToTokenIdToAuctionId[auction.nftContract][auction.tokenId];
    delete auctionIdToAuction[auctionId];

    // Transfer the NFT unless it still has a buy price set.
    _transferFromEscrowIfAvailable(auction.nftContract, auction.tokenId, auction.seller);

    emit ReserveAuctionCanceled(auctionId);
  }

  /**
   * @notice Creates an auction for the given NFT.
   * The NFT is held in escrow until the auction is finalized or canceled.
   * @param nftContract The address of the NFT contract.
   * @param tokenId The id of the NFT.
   * @param reservePrice The initial reserve price for the auction.
   */
  function createReserveAuction(
    address nftContract,
    uint256 tokenId,
    uint256 reservePrice
  ) external nonReentrant onlyValidAuctionConfig(reservePrice) {
    uint256 auctionId = _getNextAndIncrementAuctionId();

    // If the `msg.sender` is not the owner of the NFT, transferring into escrow should fail.
    _transferToEscrow(nftContract, tokenId);

    // Store the auction details
    nftContractToTokenIdToAuctionId[nftContract][tokenId] = auctionId;
    auctionIdToAuction[auctionId] = ReserveAuction(
      nftContract,
      tokenId,
      payable(msg.sender),
      DURATION,
      EXTENSION_DURATION,
      0, // endTime is only known once the reserve price is met
      payable(0), // bidder is only known once a bid has been placed
      reservePrice
    );

    emit ReserveAuctionCreated(msg.sender, nftContract, tokenId, DURATION, EXTENSION_DURATION, reservePrice, auctionId);
  }

  /**
   * @notice Once the countdown has expired for an auction, anyone can settle the auction.
   * This will send the NFT to the highest bidder and distribute revenue for this sale.
   * @param auctionId The id of the auction to settle.
   */
  function finalizeReserveAuction(uint256 auctionId) external nonReentrant {
    if (auctionIdToAuction[auctionId].endTime == 0) {
      revert NFTMarketReserveAuction_Cannot_Finalize_Already_Settled_Auction();
    }
    _finalizeReserveAuction(auctionId, false);
  }

  /**
   * @notice Place a bid in an auction.
   * A bidder may place a bid which is at least the value defined by `getMinBidAmount`.
   * If this is the first bid on the auction, the countdown will begin.
   * If there is already an outstanding bid, the previous bidder will be refunded at this time
   * and if the bid is placed in the final moments of the auction, the countdown may be extended.
   * @param auctionId The id of the auction to bid on.
   */
  function placeBid(uint256 auctionId) external payable {
    placeBidOf(auctionId, msg.value);
  }

  /**
   * @notice Place a bid in an auction.
   * A bidder may place a bid which is at least the amount defined by `getMinBidAmount`.
   * If this is the first bid on the auction, the countdown will begin.
   * If there is already an outstanding bid, the previous bidder will be refunded at this time
   * and if the bid is placed in the final moments of the auction, the countdown may be extended.
   * @dev `amount` - `msg.value` is withdrawn from the bidder's FETH balance.
   * @param auctionId The id of the auction to bid on.
   * @param amount The amount to bid, if this is more than `msg.value` funds will be withdrawn from your FETH balance.
   */
  /* solhint-disable-next-line code-complexity */
  function placeBidOf(uint256 auctionId, uint256 amount) public payable nonReentrant {
    if (amount < msg.value) {
      // The amount is specified by the bidder, so if too much ETH is sent then something went wrong.
      revert NFTMarketReserveAuction_Too_Much_Value_Provided();
    } else if (amount > msg.value) {
      // Withdraw additional ETH required from their available FETH balance.

      unchecked {
        // The if above ensures delta will not underflow.
        uint256 delta = amount - msg.value;

        // Withdraw ETH from the buyer's account in the FETH token contract.
        feth.marketWithdrawFrom(msg.sender, delta);
      }
    }

    ReserveAuction storage auction = auctionIdToAuction[auctionId];

    if (auction.amount == 0) {
      // No auction found
      revert NFTMarketReserveAuction_Cannot_Bid_On_Nonexistent_Auction();
    }

    if (auction.endTime == 0) {
      // This is the first bid, kicking off the auction.

      if (auction.amount > amount) {
        // The bid must be >= the reserve price.
        revert NFTMarketReserveAuction_Cannot_Bid_Lower_Than_Reserve_Price(auction.amount);
      }

      // Notify other market tools that an auction for this NFT has been kicked off.
      _afterAuctionStarted(auction.nftContract, auction.tokenId);

      // Store the bid details.
      auction.amount = amount;
      auction.bidder = payable(msg.sender);

      // On the first bid, set the endTime to now + duration.
      unchecked {
        // Duration is always set to 24hrs so the below can't overflow.
        auction.endTime = block.timestamp + auction.duration;
      }
    } else {
      if (auction.endTime < block.timestamp) {
        // The auction has already ended.
        revert NFTMarketReserveAuction_Cannot_Bid_On_Ended_Auction(auction.endTime);
      } else if (auction.bidder == msg.sender) {
        // We currently do not allow a bidder to increase their bid unless another user has outbid them first.
        revert NFTMarketReserveAuction_Cannot_Rebid_Over_Outstanding_Bid();
      } else if (amount < _getMinIncrement(auction.amount)) {
        // If this bid outbids another, it must be at least 10% greater than the last bid.
        revert NFTMarketReserveAuction_Bid_Must_Be_At_Least_Min_Amount(_getMinIncrement(auction.amount));
      }

      // Cache and update bidder state
      uint256 originalAmount = auction.amount;
      address payable originalBidder = auction.bidder;
      auction.amount = amount;
      auction.bidder = payable(msg.sender);

      unchecked {
        // When a bid outbids another, check to see if a time extension should apply.
        // We confirmed that the auction has not ended, so endTime is always >= the current timestamp.
        if (auction.endTime - block.timestamp < auction.extensionDuration) {
          // Current time plus extension duration (always 15 mins) cannot overflow.
          auction.endTime = block.timestamp + auction.extensionDuration;
        }
      }

      // Refund the previous bidder
      _sendValueWithFallbackWithdraw(originalBidder, originalAmount, SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT);
    }

    emit ReserveAuctionBidPlaced(auctionId, msg.sender, amount, auction.endTime);
  }

  /**
   * @notice If an auction has been created but has not yet received bids, the reservePrice may be
   * changed by the seller.
   * @param auctionId The id of the auction to change.
   * @param reservePrice The new reserve price for this auction.
   */
  function updateReserveAuction(uint256 auctionId, uint256 reservePrice) external onlyValidAuctionConfig(reservePrice) {
    ReserveAuction storage auction = auctionIdToAuction[auctionId];
    if (auction.seller != msg.sender) {
      revert NFTMarketReserveAuction_Only_Owner_Can_Update_Auction(auction.seller);
    } else if (auction.endTime != 0) {
      revert NFTMarketReserveAuction_Cannot_Update_Auction_In_Progress();
    }

    // Update the current reserve price.
    auction.amount = reservePrice;

    emit ReserveAuctionUpdated(auctionId, reservePrice);
  }

  /**
   * @notice Settle an auction that has already ended.
   * This will send the NFT to the highest bidder and distribute revenue for this sale.
   * @param keepInEscrow If true, the NFT will be kept in escrow to save gas by avoiding
   * redundant transfers if the NFT should remain in escrow, such as when the new owner
   * sets a buy price or lists it in a new auction.
   */
  function _finalizeReserveAuction(uint256 auctionId, bool keepInEscrow) private {
    ReserveAuction memory auction = auctionIdToAuction[auctionId];

    if (auction.endTime >= block.timestamp) {
      revert NFTMarketReserveAuction_Cannot_Finalize_Auction_In_Progress(auction.endTime);
    }

    // Remove the auction.
    delete nftContractToTokenIdToAuctionId[auction.nftContract][auction.tokenId];
    delete auctionIdToAuction[auctionId];

    if (!keepInEscrow) {
      /*
       * Save gas by calling core directly since it cannot have another escrow requirement
       * (buy price set or another auction listed) until this one has been finalized.
       */
      NFTMarketCore._transferFromEscrow(auction.nftContract, auction.tokenId, auction.bidder, address(0));
    }

    // Distribute revenue for this sale.
    (uint256 f8nFee, uint256 creatorFee, uint256 ownerRev) = _distributeFunds(
      auction.nftContract,
      auction.tokenId,
      auction.seller,
      auction.amount
    );

    emit ReserveAuctionFinalized(auctionId, auction.seller, auction.bidder, f8nFee, creatorFee, ownerRev);
  }

  /**
   * @inheritdoc NFTMarketCore
   * @dev If an auction is found:
   *  - If the auction is over, it will settle the auction and confirm the new seller won the auction.
   *  - If the auction has not received a bid, it will invalidate the auction.
   *  - If the auction is in progress, this will revert.
   */
  function _transferFromEscrow(
    address nftContract,
    uint256 tokenId,
    address recipient,
    address seller
  ) internal virtual override {
    uint256 auctionId = nftContractToTokenIdToAuctionId[nftContract][tokenId];
    if (auctionId != 0) {
      ReserveAuction storage auction = auctionIdToAuction[auctionId];
      if (auction.endTime == 0) {
        // The auction has not received any bids yet so it may be invalided.

        if (auction.seller != seller) {
          // The account trying to transfer the NFT is not the current owner.
          revert NFTMarketReserveAuction_Not_Matching_Seller(auction.seller);
        }

        // Remove the auction.
        delete nftContractToTokenIdToAuctionId[nftContract][tokenId];
        delete auctionIdToAuction[auctionId];

        emit ReserveAuctionInvalidated(auctionId);
      } else {
        // If the auction has started, the highest bidder will be the new owner.

        if (auction.bidder != seller) {
          revert NFTMarketReserveAuction_Not_Matching_Seller(auction.bidder);
        }

        // Finalization will revert if the auction has not yet ended.
        _finalizeReserveAuction(auctionId, false);

        // Finalize includes the transfer, so we are done here.
        return;
      }
    }

    super._transferFromEscrow(nftContract, tokenId, recipient, seller);
  }

  /**
   * @inheritdoc NFTMarketCore
   * @dev Checks if there is an auction for this NFT before allowing the transfer to continue.
   */
  function _transferFromEscrowIfAvailable(
    address nftContract,
    uint256 tokenId,
    address recipient
  ) internal virtual override {
    if (nftContractToTokenIdToAuctionId[nftContract][tokenId] == 0) {
      // No auction was found

      super._transferFromEscrowIfAvailable(nftContract, tokenId, recipient);
    }
  }

  /**
   * @inheritdoc NFTMarketCore
   */
  function _transferToEscrow(address nftContract, uint256 tokenId) internal virtual override {
    uint256 auctionId = nftContractToTokenIdToAuctionId[nftContract][tokenId];
    if (auctionId == 0) {
      // NFT is not in auction
      super._transferToEscrow(nftContract, tokenId);
      return;
    }
    // Using storage saves gas since most of the data is not needed
    ReserveAuction storage auction = auctionIdToAuction[auctionId];
    if (auction.endTime == 0) {
      // Reserve price set, confirm the seller is a match
      if (auction.seller != msg.sender) {
        revert NFTMarketReserveAuction_Not_Matching_Seller(auction.seller);
      }
    } else {
      // Auction in progress, confirm the highest bidder is a match
      if (auction.bidder != msg.sender) {
        revert NFTMarketReserveAuction_Not_Matching_Seller(auction.bidder);
      }

      // Finalize auction but leave NFT in escrow, reverts if the auction has not ended
      _finalizeReserveAuction(auctionId, true);
    }
  }

  /**
   * @notice Returns the minimum amount a bidder must spend to participate in an auction.
   * Bids must be greater than or equal to this value or they will revert.
   * @param auctionId The id of the auction to check.
   * @return minimum The minimum amount for a bid to be accepted.
   */
  function getMinBidAmount(uint256 auctionId) external view returns (uint256 minimum) {
    ReserveAuction storage auction = auctionIdToAuction[auctionId];
    if (auction.endTime == 0) {
      return auction.amount;
    }
    return _getMinIncrement(auction.amount);
  }

  /**
   * @notice Returns auction details for a given auctionId.
   * @param auctionId The id of the auction to lookup.
   * @return auction The auction details.
   */
  function getReserveAuction(uint256 auctionId) external view returns (ReserveAuction memory auction) {
    return auctionIdToAuction[auctionId];
  }

  /**
   * @notice Returns the auctionId for a given NFT, or 0 if no auction is found.
   * @dev If an auction is canceled, it will not be returned. However the auction may be over and pending finalization.
   * @param nftContract The address of the NFT contract.
   * @param tokenId The id of the NFT.
   * @return auctionId The id of the auction, or 0 if no auction is found.
   */
  function getReserveAuctionIdFor(address nftContract, uint256 tokenId) external view returns (uint256 auctionId) {
    return nftContractToTokenIdToAuctionId[nftContract][tokenId];
  }

  /**
   * @inheritdoc NFTMarketCore
   * @dev Returns the seller that has the given NFT in escrow for an auction,
   * or bubbles the call up for other considerations.
   */
  function _getSellerFor(address nftContract, uint256 tokenId)
    internal
    view
    virtual
    override
    returns (address payable seller)
  {
    seller = auctionIdToAuction[nftContractToTokenIdToAuctionId[nftContract][tokenId]].seller;
    if (seller == address(0)) {
      seller = super._getSellerFor(nftContract, tokenId);
    }
  }

  /**
   * @inheritdoc NFTMarketCore
   */
  function _isInActiveAuction(address nftContract, uint256 tokenId) internal view override returns (bool) {
    uint256 auctionId = nftContractToTokenIdToAuctionId[nftContract][tokenId];
    return auctionId != 0 && auctionIdToAuction[auctionId].endTime >= block.timestamp;
  }

  /**
   * @notice This empty reserved space is put in place to allow future versions to add new
   * variables without shifting down storage in the inheritance chain.
   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps
   */
  uint256[1000] private __gap;
}",6797
RealWorld_BA_94_NFTMarketOffer_RealWord_20240826151156.log,94,NFTMarketOffer,69219,5751,74970,97.0,0.461115,"// SPDX-License-Identifier: MIT OR Apache-2.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";

import ""./FoundationTreasuryNode.sol"";
import ""./NFTMarketCore.sol"";
import ""./NFTMarketFees.sol"";

import ""@openzeppelin/contracts/token/ERC721/IERC721.sol"";

error NFTMarketOffer_Cannot_Be_Accepted_While_In_Auction();
/// @param currentOfferAmount The current highest offer available for this NFT.
error NFTMarketOffer_Offer_Below_Min_Amount(uint256 currentOfferAmount);
/// @param expiry The time at which the offer had expired.
error NFTMarketOffer_Offer_Expired(uint256 expiry);
/// @param currentOfferFrom The address of the collector which has made the current highest offer.
error NFTMarketOffer_Offer_From_Does_Not_Match(address currentOfferFrom);
/// @param minOfferAmount The minimum amount that must be offered in order for it to be accepted.
error NFTMarketOffer_Offer_Must_Be_At_Least_Min_Amount(uint256 minOfferAmount);
error NFTMarketOffer_Reason_Required();

/**
 * @title Allows collectors to make an offer for an NFT, valid for 24-25 hours.
 * @notice Funds are escrowed in the FETH ERC-20 token contract.
 */
abstract contract NFTMarketOffer is FoundationTreasuryNode, NFTMarketCore, ReentrancyGuardUpgradeable, NFTMarketFees {
  using AddressUpgradeable for address;

  /// @notice Stores offer details for a specific NFT.
  struct Offer {
    // Slot 1: When increasing an offer, only this slot is updated.
    /// @notice The expiration timestamp of when this offer expires.
    uint32 expiration;
    /// @notice The amount, in wei, of the highest offer.
    uint96 amount;
    // 128 bits are available in slot 1

    // Slot 2: When the buyer changes, both slots need updating
    /// @notice The address of the collector who made this offer.
    address buyer;
  }

  /// @notice Stores the highest offer for each NFT.
  mapping(address => mapping(uint256 => Offer)) private nftContractToIdToOffer;

  /**
   * @notice Emitted when an offer is accepted,
   * indicating that the NFT has been transferred and revenue from the sale distributed.
   * @dev The accepted total offer amount is `f8nFee` + `creatorFee` + `ownerRev`.
   * @param nftContract The address of the NFT contract.
   * @param tokenId The id of the NFT.
   * @param buyer The address of the collector that made the offer which was accepted.
   * @param seller The address of the seller which accepted the offer.
   * @param f8nFee The amount of ETH that was sent to Foundation for this sale.
   * @param creatorFee The amount of ETH that was sent to the creator for this sale.
   * @param ownerRev The amount of ETH that was sent to the owner for this sale.
   */
  event OfferAccepted(
    address indexed nftContract,
    uint256 indexed tokenId,
    address indexed buyer,
    address seller,
    uint256 f8nFee,
    uint256 creatorFee,
    uint256 ownerRev
  );
  /**
   * @notice Emitted when an offer is canceled by a Foundation admin.
   * @dev This should only be used for extreme cases such as DMCA takedown requests.
   * @param nftContract The address of the NFT contract.
   * @param tokenId The id of the NFT.
   * @param reason The reason for the cancellation (a required field).
   */
  event OfferCanceledByAdmin(address indexed nftContract, uint256 indexed tokenId, string reason);
  /**
   * @notice Emitted when an offer is invalidated due to other market activity.
   * When this occurs, the collector which made the offer has their FETH balance unlocked
   * and the funds are available to place other offers or to be withdrawn.
   * @dev This occurs when the offer is no longer eligible to be accepted,
   * e.g. when a bid is placed in an auction for this NFT.
   * @param nftContract The address of the NFT contract.
   * @param tokenId The id of the NFT.
   */
  event OfferInvalidated(address indexed nftContract, uint256 indexed tokenId);
  /**
   * @notice Emitted when an offer is made.
   * @dev The `amount` of the offer is locked in the FETH ERC-20 contract, guaranteeing that the funds
   * remain available until the `expiration` date.
   * @param nftContract The address of the NFT contract.
   * @param tokenId The id of the NFT.
   * @param buyer The address of the collector that made the offer to buy this NFT.
   * @param amount The amount, in wei, of the offer.
   * @param expiration The expiration timestamp for the offer.
   */
  event OfferMade(
    address indexed nftContract,
    uint256 indexed tokenId,
    address indexed buyer,
    uint256 amount,
    uint256 expiration
  );

  /**
   * @notice Accept the highest offer for an NFT.
   * @dev The offer must not be expired and the NFT owned + approved by the seller or
   * available in the market contract's escrow.
   * @param nftContract The address of the NFT contract.
   * @param tokenId The id of the NFT.
   * @param offerFrom The address of the collector that you wish to sell to.
   * If the current highest offer is not from this user, the transaction will revert.
   * This could happen if a last minute offer was made by another collector,
   * and would require the seller to try accepting again.
   * @param minAmount The minimum value of the highest offer for it to be accepted.
   * If the value is less than this amount, the transaction will revert.
   * This could happen if the original offer expires and is replaced with a smaller offer.
   */
  function acceptOffer(
    address nftContract,
    uint256 tokenId,
    address offerFrom,
    uint256 minAmount
  ) external nonReentrant {
    Offer storage offer = nftContractToIdToOffer[nftContract][tokenId];
    // Validate offer expiry and amount
    if (offer.expiration < block.timestamp) {
      revert NFTMarketOffer_Offer_Expired(offer.expiration);
    } else if (offer.amount < minAmount) {
      revert NFTMarketOffer_Offer_Below_Min_Amount(offer.amount);
    }
    // Validate the buyer
    if (offer.buyer != offerFrom) {
      revert NFTMarketOffer_Offer_From_Does_Not_Match(offer.buyer);
    }

    _acceptOffer(nftContract, tokenId);
  }

  /**
   * @notice Allows Foundation to cancel offers.
   * This will unlock the funds in the FETH ERC-20 contract for the highest offer
   * and prevent the offer from being accepted.
   * @dev This should only be used for extreme cases such as DMCA takedown requests.
   * @param nftContracts The addresses of the NFT contracts to cancel. This must be the same length as `tokenIds`.
   * @param tokenIds The ids of the NFTs to cancel. This must be the same length as `nftContracts`.
   * @param reason The reason for the cancellation (a required field).
   */
  function adminCancelOffers(
    address[] calldata nftContracts,
    uint256[] calldata tokenIds,
    string calldata reason
  ) external onlyFoundationAdmin nonReentrant {
    if (bytes(reason).length == 0) {
      revert NFTMarketOffer_Reason_Required();
    }

    // The array length cannot overflow 256 bits
    unchecked {
      for (uint256 i = 0; i < nftContracts.length; ++i) {
        Offer memory offer = nftContractToIdToOffer[nftContracts[i]][tokenIds[i]];
        delete nftContractToIdToOffer[nftContracts[i]][tokenIds[i]];

        if (offer.expiration >= block.timestamp) {
          // Unlock from escrow and emit an event only if the offer is still active
          feth.marketUnlockFor(offer.buyer, offer.expiration, offer.amount);
          emit OfferCanceledByAdmin(nftContracts[i], tokenIds[i], reason);
        }
        // Else continue on so the rest of the batch transaction can process successfully
      }
    }
  }

  /**
   * @notice Make an offer for any NFT which is valid for 24-25 hours.
   * The funds will be locked in the FETH token contract and become available once the offer is outbid or has expired.
   * @dev An offer may be made for an NFT before it is minted, although we generally not recommend you do that.
   * If there is a buy price set at this price or lower, that will be accepted instead of making an offer.
   * `msg.value` must be <= `amount` and any delta will be taken from the account's available FETH balance.
   * @param nftContract The address of the NFT contract.
   * @param tokenId The id of the NFT.
   * @param amount The amount to offer for this NFT.
   * @return expiration The timestamp for when this offer will expire.
   * This is provided as a return value in case another contract would like to leverage this information,
   * user's should refer to the expiration in the `OfferMade` event log.
   * If the buy price is accepted instead, `0` is returned as the expiration since that's n/a.
   */
  function makeOffer(
    address nftContract,
    uint256 tokenId,
    uint256 amount
  ) external payable returns (uint256 expiration) {
    // If there is a buy price set at this price or lower, accept that instead.
    if (_autoAcceptBuyPrice(nftContract, tokenId, amount)) {
      // If the buy price is accepted, `0` is returned as the expiration since that's n/a.
      return 0;
    }

    if (_isInActiveAuction(nftContract, tokenId)) {
      revert NFTMarketOffer_Cannot_Be_Accepted_While_In_Auction();
    }

    Offer storage offer = nftContractToIdToOffer[nftContract][tokenId];

    if (offer.expiration < block.timestamp) {
      // This is a new offer for the NFT (no other offer found or the previous offer expired)

      // Lock the offer amount in FETH until the offer expires in 24-25 hours.
      expiration = feth.marketLockupFor{ value: msg.value }(msg.sender, amount);
    } else {
      // A previous offer exists and has not expired

      if (amount < _getMinIncrement(offer.amount)) {
        // A non-trivial increase in price is required to avoid sniping
        revert NFTMarketOffer_Offer_Must_Be_At_Least_Min_Amount(_getMinIncrement(offer.amount));
      }

      // Unlock the previous offer so that the FETH tokens are available for other offers or to transfer / withdraw
      // and lock the new offer amount in FETH until the offer expires in 24-25 hours.
      expiration = feth.marketChangeLockup{ value: msg.value }(
        offer.buyer,
        offer.expiration,
        offer.amount,
        msg.sender,
        amount
      );
    }

    // Record offer details
    offer.buyer = msg.sender;
    // The FETH contract guarantees that the expiration fits into 32 bits.
    offer.expiration = uint32(expiration);
    // `amount` is capped by the ETH provided, which cannot realistically overflow 96 bits.
    offer.amount = uint96(amount);

    emit OfferMade(nftContract, tokenId, msg.sender, amount, expiration);
  }

  /**
   * @notice Accept the highest offer for an NFT from the `msg.sender` account.
   * The NFT will be transferred to the buyer and revenue from the sale will be distributed.
   * @dev The caller must validate the expiry and amount before calling this helper.
   * This may invalidate other market tools, such as clearing the buy price if set.
   */
  function _acceptOffer(address nftContract, uint256 tokenId) private {
    Offer memory offer = nftContractToIdToOffer[nftContract][tokenId];

    // Remove offer
    delete nftContractToIdToOffer[nftContract][tokenId];
    // Withdraw ETH from the buyer's account in the FETH token contract.
    feth.marketWithdrawLocked(offer.buyer, offer.expiration, offer.amount);

    // Distribute revenue for this sale leveraging the ETH received from the FETH contract in the line above.
    (uint256 f8nFee, uint256 creatorFee, uint256 ownerRev) = _distributeFunds(
      nftContract,
      tokenId,
      payable(msg.sender),
      offer.amount
    );

    // Transfer the NFT to the buyer.
    try
      IERC721(nftContract).transferFrom(msg.sender, offer.buyer, tokenId) // solhint-disable-next-line no-empty-blocks
    {
      // NFT was in the seller's wallet so the transfer is complete.
    } catch {
      // If the transfer fails then attempt to transfer from escrow instead.
      // This should revert if the NFT is not in escrow of the `msg.sender` is not the owner of this NFT.
      _transferFromEscrow(nftContract, tokenId, offer.buyer, msg.sender);
    }

    emit OfferAccepted(nftContract, tokenId, offer.buyer, msg.sender, f8nFee, creatorFee, ownerRev);
  }

  /**
   * @inheritdoc NFTMarketCore
   * @dev Invalidates the highest offer when an auction is kicked off, if one is found.
   */
  function _afterAuctionStarted(address nftContract, uint256 tokenId) internal virtual override {
    _invalidateOffer(nftContract, tokenId);
    super._afterAuctionStarted(nftContract, tokenId);
  }

  /**
   * @inheritdoc NFTMarketCore
   * @dev Invalidates the highest offer if it's from the same user that purchased the NFT
   * using a different market tool such as accepting the buy price.
   */
  function _transferFromEscrow(
    address nftContract,
    uint256 tokenId,
    address buyer,
    address seller
  ) internal virtual override {
    Offer storage offer = nftContractToIdToOffer[nftContract][tokenId];
    if (offer.buyer == buyer) {
      // The highest offer is from the same user that purchased the NFT using a different market tool.
      _invalidateOffer(nftContract, tokenId);
    }
    // For other users, the offer remains valid for consideration by the new owner.
    super._transferFromEscrow(nftContract, tokenId, buyer, seller);
  }

  /**
   * @inheritdoc NFTMarketCore
   */
  function _autoAcceptOffer(
    address nftContract,
    uint256 tokenId,
    uint256 minAmount
  ) internal override returns (bool) {
    Offer storage offer = nftContractToIdToOffer[nftContract][tokenId];
    if (offer.expiration < block.timestamp || offer.amount < minAmount) {
      // No offer found, the most recent offer is now expired, or the highest offer is below the minimum amount.
      return false;
    }

    _acceptOffer(nftContract, tokenId);
    return true;
  }

  /**
   * @inheritdoc NFTMarketCore
   */
  function _cancelBuyersOffer(address nftContract, uint256 tokenId) internal override {
    Offer storage offer = nftContractToIdToOffer[nftContract][tokenId];
    if (offer.buyer == msg.sender) {
      _invalidateOffer(nftContract, tokenId);
    }
  }

  /**
   * @notice Invalidates the offer and frees ETH from escrow, if the offer has not already expired.
   */
  function _invalidateOffer(address nftContract, uint256 tokenId) private {
    if (nftContractToIdToOffer[nftContract][tokenId].expiration >= block.timestamp) {
      // An offer was found and it has not already expired
      Offer memory offer = nftContractToIdToOffer[nftContract][tokenId];

      // Remove offer
      delete nftContractToIdToOffer[nftContract][tokenId];
      // Unlock the offer so that the FETH tokens are available for other offers or to transfer / withdraw
      feth.marketUnlockFor(offer.buyer, offer.expiration, offer.amount);

      emit OfferInvalidated(nftContract, tokenId);
    }
  }

  /**
   * @notice Returns the minimum amount a collector must offer for this NFT in order for the offer to be valid.
   * @dev Offers for this NFT which are less than this value will revert.
   * Once the previous offer has expired smaller offers can be made.
   * @param nftContract The address of the NFT contract.
   * @param tokenId The id of the NFT.
   * @return minimum The minimum amount that must be offered for this NFT.
   */
  function getMinOfferAmount(address nftContract, uint256 tokenId) external view returns (uint256 minimum) {
    Offer storage offer = nftContractToIdToOffer[nftContract][tokenId];
    if (offer.expiration >= block.timestamp) {
      return _getMinIncrement(offer.amount);
    }
    // Absolute min is anything > 0
    return 1;
  }

  /**
   * @notice Returns details about the current highest offer for an NFT.
   * @dev Default values are returned if there is no offer or the offer has expired.
   * @param nftContract The address of the NFT contract.
   * @param tokenId The id of the NFT.
   * @return buyer The address of the buyer that made the current highest offer.
   * Returns `address(0)` if there is no offer or the most recent offer has expired.
   * @return expiration The timestamp that the current highest offer expires.
   * Returns `0` if there is no offer or the most recent offer has expired.
   * @return amount The amount being offered for this NFT.
   * Returns `0` if there is no offer or the most recent offer has expired.
   */
  function getOffer(address nftContract, uint256 tokenId)
    external
    view
    returns (
      address buyer,
      uint256 expiration,
      uint256 amount
    )
  {
    Offer storage offer = nftContractToIdToOffer[nftContract][tokenId];
    if (offer.expiration < block.timestamp) {
      // Offer not found or has expired
      return (address(0), 0, 0);
    }

    // An offer was found and it has not yet expired.
    return (offer.buyer, offer.expiration, offer.amount);
  }

  /**
   * @notice This empty reserved space is put in place to allow future versions to add new
   * variables without shifting down storage in the inheritance chain.
   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps
   */
  uint256[1000] private __gap;
}",4149
RealWorld_BA_94_OperatorRole_RealWord_20240826152315.log,94,OperatorRole,10629,5750,16379,96.0,0.168145,"// SPDX-License-Identifier: MIT OR Apache-2.0

pragma solidity ^0.8.0;

import ""../OZ/AccessControlUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";

/**
 * @title Defines a role for Foundation operator accounts.
 * @dev Wraps a role from OpenZeppelin's AccessControl for easy integration.
 */
abstract contract OperatorRole is Initializable, AccessControlUpgradeable {
  bytes32 private constant OPERATOR_ROLE = keccak256(""OPERATOR_ROLE"");

  /**
   * @notice Adds the account to the list of approved operators.
   * @dev Only callable by admins as enforced by `grantRole`.
   * @param account The address to be approved.
   */
  function grantOperator(address account) external {
    grantRole(OPERATOR_ROLE, account);
  }

  /**
   * @notice Removes the account from the list of approved operators.
   * @dev Only callable by admins as enforced by `grantRole`.
   * @param account The address to be removed from the approved list.
   */
  function revokeOperator(address account) external {
    revokeRole(OPERATOR_ROLE, account);
  }

  /**
   * @notice Returns one of the operator by index.
   * @param index The index of the operator to return from 0 to getOperatorMemberCount() - 1.
   * @return account The address of the operator.
   */
  function getOperatorMember(uint256 index) external view returns (address account) {
    return getRoleMember(OPERATOR_ROLE, index);
  }

  /**
   * @notice Checks how many accounts have been granted operator access.
   * @return count The number of accounts with operator access.
   */
  function getOperatorMemberCount() external view returns (uint256 count) {
    return getRoleMemberCount(OPERATOR_ROLE);
  }

  /**
   * @notice Checks if the account provided is an operator.
   * @param account The address to check.
   * @return approved True if the account is an operator.
   */
  function isOperator(address account) external view returns (bool approved) {
    return hasRole(OPERATOR_ROLE, account);
  }
}",458
RealWorld_BA_94_ERC165Checker_RealWord_20240826152624.log,94,ERC165Checker,20406,5128,25534,90.0,0.20459,"// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

/**
 * From https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.2.0/contracts/utils/introspection/ERC165.sol
 * Modified to allow checking multiple interfaces w/o checking general 165 support.
 */

import ""@openzeppelin/contracts/utils/introspection/IERC165.sol"";

/**
 * @title Library to query ERC165 support.
 * @dev Library used to query support of an interface declared via {IERC165}.
 *
 * Note that these functions return the actual result of the query: they do not
 * `revert` if an interface is not supported. It is up to the caller to decide
 * what to do in these cases.
 */
library ERC165Checker {
  // As per the EIP-165 spec, no interface should ever match 0xffffffff
  bytes4 private constant _INTERFACE_ID_INVALID = 0xffffffff;

  /**
   * @dev Returns true if `account` supports the {IERC165} interface,
   */
  function supportsERC165(address account) internal view returns (bool) {
    // Any contract that implements ERC165 must explicitly indicate support of
    // InterfaceId_ERC165 and explicitly indicate non-support of InterfaceId_Invalid
    return
      supportsERC165Interface(account, type(IERC165).interfaceId) &&
      !supportsERC165Interface(account, _INTERFACE_ID_INVALID);
  }

  /**
   * @dev Returns true if `account` supports the interface defined by
   * `interfaceId`. Support for {IERC165} itself is queried automatically.
   *
   * See {IERC165-supportsInterface}.
   */
  function supportsInterface(address account, bytes4 interfaceId) internal view returns (bool) {
    // query support of both ERC165 as per the spec and support of _interfaceId
    return supportsERC165(account) && supportsERC165Interface(account, interfaceId);
  }

  /**
   * @dev Returns a boolean array where each value corresponds to the
   * interfaces passed in and whether they're supported or not. This allows
   * you to batch check interfaces for a contract where your expectation
   * is that some interfaces may not be supported.
   *
   * See {IERC165-supportsInterface}.
   *
   * _Available since v3.4._
   */
  function getSupportedInterfaces(address account, bytes4[] memory interfaceIds) internal view returns (bool[] memory) {
    // an array of booleans corresponding to interfaceIds and whether they're supported or not
    bool[] memory interfaceIdsSupported = new bool[](interfaceIds.length);

    // query support of ERC165 itself
    if (supportsERC165(account)) {
      // query support of each interface in interfaceIds
      unchecked {
        for (uint256 i = 0; i < interfaceIds.length; ++i) {
          interfaceIdsSupported[i] = supportsERC165Interface(account, interfaceIds[i]);
        }
      }
    }

    return interfaceIdsSupported;
  }

  /**
   * @dev Returns true if `account` supports all the interfaces defined in
   * `interfaceIds`. Support for {IERC165} itself is queried automatically.
   *
   * Batch-querying can lead to gas savings by skipping repeated checks for
   * {IERC165} support.
   *
   * See {IERC165-supportsInterface}.
   */
  function supportsAllInterfaces(address account, bytes4[] memory interfaceIds) internal view returns (bool) {
    // query support of ERC165 itself
    if (!supportsERC165(account)) {
      return false;
    }

    // query support of each interface in _interfaceIds
    unchecked {
      for (uint256 i = 0; i < interfaceIds.length; ++i) {
        if (!supportsERC165Interface(account, interfaceIds[i])) {
          return false;
        }
      }
    }

    // all interfaces supported
    return true;
  }

  /**
   * @notice Query if a contract implements an interface, does not check ERC165 support
   * @param account The address of the contract to query for support of an interface
   * @param interfaceId The interface identifier, as specified in ERC-165
   * @return true if the contract at account indicates support of the interface with
   * identifier interfaceId, false otherwise
   * @dev Assumes that account contains a contract that supports ERC165, otherwise
   * the behavior of this method is undefined. This precondition can be checked
   * with {supportsERC165}.
   * Interface identification is specified in ERC-165.
   */
  function supportsERC165Interface(address account, bytes4 interfaceId) internal view returns (bool) {
    bytes memory encodedParams = abi.encodeWithSelector(IERC165(account).supportsInterface.selector, interfaceId);
    (bool success, bytes memory result) = account.staticcall{ gas: 30000 }(encodedParams);
    if (result.length < 32) return false;
    return success && abi.decode(result, (bool));
  }
}",1060
RealWorld_BA_94_IGetFees_RealWord_20240826153442.log,94,IGetFees,4942,3749,8691,68.0,0.09969,"// SPDX-License-Identifier: MIT OR Apache-2.0

pragma solidity ^0.8.0;

/**
 * @notice An interface for communicating fees to 3rd party marketplaces.
 * @dev Originally implemented in mainnet contract 0x44d6e8933f8271abcf253c72f9ed7e0e4c0323b3
 */
interface IGetFees {
  function getFeeRecipients(uint256 id) external view returns (address payable[] memory);

  function getFeeBps(uint256 id) external view returns (uint256[] memory);
}",125
RealWorld_BA_94_NFTMarketBuyPrice_RealWord_20240826150921.log,94,NFTMarketBuyPrice,61762,5765,67527,84.0,0.42411,"// SPDX-License-Identifier: MIT OR Apache-2.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";

import ""./Constants.sol"";
import ""./NFTMarketCore.sol"";
import ""./NFTMarketFees.sol"";

import ""@openzeppelin/contracts/token/ERC721/IERC721.sol"";

/// @param buyPrice The current buy price set for this NFT.
error NFTMarketBuyPrice_Cannot_Buy_At_Lower_Price(uint256 buyPrice);
error NFTMarketBuyPrice_Cannot_Buy_Unset_Price();
error NFTMarketBuyPrice_Cannot_Cancel_Unset_Price();
/// @param owner The current owner of this NFT.
error NFTMarketBuyPrice_Only_Owner_Can_Cancel_Price(address owner);
/// @param owner The current owner of this NFT.
error NFTMarketBuyPrice_Only_Owner_Can_Set_Price(address owner);
error NFTMarketBuyPrice_Price_Too_High();
/// @param seller The current owner of this NFT.
error NFTMarketBuyPrice_Seller_Mismatch(address seller);

/**
 * @title Allows sellers to set a buy price of their NFTs that may be accepted and instantly transferred to the buyer.
 * @notice NFTs with a buy price set are escrowed in the market contract.
 */
abstract contract NFTMarketBuyPrice is NFTMarketCore, NFTMarketFees {
  using AddressUpgradeable for address payable;

  /// @notice Stores the buy price details for a specific NFT.
  /// @dev The struct is packed into a single slot to optimize gas.
  struct BuyPrice {
    /// @notice The current owner of this NFT which set a buy price.
    /// @dev A zero price is acceptable so a non-zero address determines whether a price has been set.
    address payable seller;
    /// @notice The current buy price set for this NFT.
    uint96 price;
  }

  /// @notice Stores the current buy price for each NFT.
  mapping(address => mapping(uint256 => BuyPrice)) private nftContractToTokenIdToBuyPrice;

  /**
   * @notice Emitted when an NFT is bought by accepting the buy price,
   * indicating that the NFT has been transferred and revenue from the sale distributed.
   * @dev The total buy price that was accepted is `f8nFee` + `creatorFee` + `ownerRev`.
   * @param nftContract The address of the NFT contract.
   * @param tokenId The id of the NFT.
   * @param buyer The address of the collector that purchased the NFT using `buy`.
   * @param seller The address of the seller which originally set the buy price.
   * @param f8nFee The amount of ETH that was sent to Foundation for this sale.
   * @param creatorFee The amount of ETH that was sent to the creator for this sale.
   * @param ownerRev The amount of ETH that was sent to the owner for this sale.
   */
  event BuyPriceAccepted(
    address indexed nftContract,
    uint256 indexed tokenId,
    address indexed seller,
    address buyer,
    uint256 f8nFee,
    uint256 creatorFee,
    uint256 ownerRev
  );
  /**
   * @notice Emitted when the buy price is removed by the owner of an NFT.
   * @dev The NFT is transferred back to the owner unless it's still escrowed for another market tool,
   * e.g. listed for sale in an auction.
   * @param nftContract The address of the NFT contract.
   * @param tokenId The id of the NFT.
   */
  event BuyPriceCanceled(address indexed nftContract, uint256 indexed tokenId);
  /**
   * @notice Emitted when a buy price is invalidated due to other market activity.
   * @dev This occurs when the buy price is no longer eligible to be accepted,
   * e.g. when a bid is placed in an auction for this NFT.
   * @param nftContract The address of the NFT contract.
   * @param tokenId The id of the NFT.
   */
  event BuyPriceInvalidated(address indexed nftContract, uint256 indexed tokenId);
  /**
   * @notice Emitted when a buy price is set by the owner of an NFT.
   * @dev The NFT is transferred into the market contract for escrow unless it was already escrowed,
   * e.g. for auction listing.
   * @param nftContract The address of the NFT contract.
   * @param tokenId The id of the NFT.
   * @param seller The address of the NFT owner which set the buy price.
   * @param price The price of the NFT.
   */
  event BuyPriceSet(address indexed nftContract, uint256 indexed tokenId, address indexed seller, uint256 price);

  /**
   * @notice Buy the NFT at the set buy price.
   * `msg.value` must be <= `maxPrice` and any delta will be taken from the account's available FETH balance.
   * @dev `maxPrice` protects the buyer in case a the price is increased but allows the transaction to continue
   * when the price is reduced (and any surplus funds provided are refunded).
   * @param nftContract The address of the NFT contract.
   * @param tokenId The id of the NFT.
   * @param maxPrice The maximum price to pay for the NFT.
   */
  function buy(
    address nftContract,
    uint256 tokenId,
    uint256 maxPrice
  ) external payable {
    BuyPrice storage buyPrice = nftContractToTokenIdToBuyPrice[nftContract][tokenId];
    if (buyPrice.price > maxPrice) {
      revert NFTMarketBuyPrice_Cannot_Buy_At_Lower_Price(buyPrice.price);
    } else if (buyPrice.seller == address(0)) {
      revert NFTMarketBuyPrice_Cannot_Buy_Unset_Price();
    }

    _buy(nftContract, tokenId);
  }

  /**
   * @notice Removes the buy price set for an NFT.
   * @dev The NFT is transferred back to the owner unless it's still escrowed for another market tool,
   * e.g. listed for sale in an auction.
   * @param nftContract The address of the NFT contract.
   * @param tokenId The id of the NFT.
   */
  function cancelBuyPrice(address nftContract, uint256 tokenId) external nonReentrant {
    BuyPrice storage buyPrice = nftContractToTokenIdToBuyPrice[nftContract][tokenId];
    if (buyPrice.seller == address(0)) {
      // This check is redundant with the next one, but done in order to provide a more clear error message.
      revert NFTMarketBuyPrice_Cannot_Cancel_Unset_Price();
    } else if (buyPrice.seller != msg.sender) {
      revert NFTMarketBuyPrice_Only_Owner_Can_Cancel_Price(buyPrice.seller);
    }

    // Remove the buy price
    delete nftContractToTokenIdToBuyPrice[nftContract][tokenId];

    // Transfer the NFT back to the owner if it is not listed in auction.
    _transferFromEscrowIfAvailable(nftContract, tokenId, msg.sender);

    emit BuyPriceCanceled(nftContract, tokenId);
  }

  /**
   * @notice Sets the buy price for an NFT and escrows it in the market contract.
   * @dev If there is an offer for this amount or higher, that will be accepted instead of setting a buy price.
   * @param nftContract The address of the NFT contract.
   * @param tokenId The id of the NFT.
   * @param price The price at which someone could buy this NFT.
   */
  function setBuyPrice(
    address nftContract,
    uint256 tokenId,
    uint256 price
  ) external nonReentrant {
    // If there is a valid offer at this price or higher, accept that instead.
    if (_autoAcceptOffer(nftContract, tokenId, price)) {
      return;
    }

    if (price > type(uint96).max) {
      // This ensures that no data is lost when storing the price as `uint96`.
      revert NFTMarketBuyPrice_Price_Too_High();
    }

    BuyPrice storage buyPrice = nftContractToTokenIdToBuyPrice[nftContract][tokenId];

    // Store the new price for this NFT.
    buyPrice.price = uint96(price);

    if (buyPrice.seller == address(0)) {
      // Transfer the NFT into escrow, if it's already in escrow confirm the `msg.sender` is the owner.
      _transferToEscrow(nftContract, tokenId);

      // The price was not previously set for this NFT, store the seller.
      buyPrice.seller = payable(msg.sender);
    } else if (buyPrice.seller != msg.sender) {
      // Buy price was previously set by a different user
      revert NFTMarketBuyPrice_Only_Owner_Can_Set_Price(buyPrice.seller);
    }

    emit BuyPriceSet(nftContract, tokenId, msg.sender, price);
  }

  /**
   * @inheritdoc NFTMarketCore
   * @dev Invalidates the buy price on a auction start, if one is found.
   */
  function _afterAuctionStarted(address nftContract, uint256 tokenId) internal virtual override {
    BuyPrice storage buyPrice = nftContractToTokenIdToBuyPrice[nftContract][tokenId];
    if (buyPrice.seller != address(0)) {
      // A buy price was set for this NFT, invalidate it.
      _invalidateBuyPrice(nftContract, tokenId);
    }
    super._afterAuctionStarted(nftContract, tokenId);
  }

  /**
   * @notice If there is a buy price at this price or lower, accept that and return true.
   */
  function _autoAcceptBuyPrice(
    address nftContract,
    uint256 tokenId,
    uint256 maxPrice
  ) internal override returns (bool) {
    BuyPrice storage buyPrice = nftContractToTokenIdToBuyPrice[nftContract][tokenId];
    if (buyPrice.seller == address(0) || buyPrice.price > maxPrice) {
      // No buy price was found, or the price is too high.
      return false;
    }

    _buy(nftContract, tokenId);
    return true;
  }

  /**
   * @notice Process the purchase of an NFT at the current buy price.
   * @dev The caller must confirm that the seller != address(0) before calling this function.
   */
  function _buy(address nftContract, uint256 tokenId) private nonReentrant {
    BuyPrice memory buyPrice = nftContractToTokenIdToBuyPrice[nftContract][tokenId];

    // Remove the buy now price
    delete nftContractToTokenIdToBuyPrice[nftContract][tokenId];

    if (buyPrice.price > msg.value) {
      // Withdraw additional ETH required from their available FETH balance.

      // Cancel the buyer's offer if there is one in order to free up their FETH balance.
      _cancelBuyersOffer(nftContract, tokenId);

      unchecked {
        // The if above ensures delta will not underflow.
        uint256 delta = buyPrice.price - msg.value;
        // Withdraw ETH from the buyer's account in the FETH token contract,
        // making the ETH available for `_distributeFunds` below.
        feth.marketWithdrawFrom(msg.sender, delta);
      }
    } else if (buyPrice.price < msg.value) {
      // Return any surplus funds to the buyer.

      unchecked {
        // The if above ensures this will not underflow
        payable(msg.sender).sendValue(msg.value - buyPrice.price);
      }
    }

    // Transfer the NFT to the buyer.
    // This should revert if the `msg.sender` is not the owner of this NFT.
    _transferFromEscrow(nftContract, tokenId, msg.sender, buyPrice.seller);

    // Distribute revenue for this sale.
    (uint256 f8nFee, uint256 creatorFee, uint256 ownerRev) = _distributeFunds(
      address(nftContract),
      tokenId,
      buyPrice.seller,
      buyPrice.price
    );

    emit BuyPriceAccepted(nftContract, tokenId, buyPrice.seller, msg.sender, f8nFee, creatorFee, ownerRev);
  }

  /**
   * @notice Clear a buy price and emit BuyPriceInvalidated.
   * @dev The caller must confirm the buy price is set before calling this function.
   */
  function _invalidateBuyPrice(address nftContract, uint256 tokenId) private {
    delete nftContractToTokenIdToBuyPrice[nftContract][tokenId];
    emit BuyPriceInvalidated(nftContract, tokenId);
  }

  /**
   * @inheritdoc NFTMarketCore
   * @dev Invalidates the buy price if one is found before transferring the NFT.
   * This will revert if there is a buy price set but the `msg.sender` is not the owner.
   */
  function _transferFromEscrow(
    address nftContract,
    uint256 tokenId,
    address recipient,
    address seller
  ) internal virtual override {
    BuyPrice storage buyPrice = nftContractToTokenIdToBuyPrice[nftContract][tokenId];
    if (buyPrice.seller != address(0)) {
      // A buy price was set for this NFT.
      if (buyPrice.seller != seller) {
        // When there is a buy price set, the `buyPrice.seller` is the owner of the NFT.
        revert NFTMarketBuyPrice_Seller_Mismatch(buyPrice.seller);
      }

      // Invalidate the buy price as the NFT will no longer be in escrow.
      _invalidateBuyPrice(nftContract, tokenId);
    }
    super._transferFromEscrow(nftContract, tokenId, recipient, seller);
  }

  /**
   * @inheritdoc NFTMarketCore
   * @dev Checks if there is a buy price set, if not then allow the transfer to proceed.
   */
  function _transferFromEscrowIfAvailable(
    address nftContract,
    uint256 tokenId,
    address recipient
  ) internal virtual override {
    BuyPrice storage buyPrice = nftContractToTokenIdToBuyPrice[nftContract][tokenId];
    if (buyPrice.seller == address(0)) {
      // A buy price has been set for this NFT so it should remain in escrow.
      super._transferFromEscrowIfAvailable(nftContract, tokenId, recipient);
    }
  }

  /**
   * @inheritdoc NFTMarketCore
   * @dev Checks if the NFT is already in escrow for buy now.
   */
  function _transferToEscrow(address nftContract, uint256 tokenId) internal virtual override {
    BuyPrice storage buyPrice = nftContractToTokenIdToBuyPrice[nftContract][tokenId];
    if (buyPrice.seller == address(0)) {
      // The NFT is not in escrow for buy now.
      super._transferToEscrow(nftContract, tokenId);
    } else if (buyPrice.seller != msg.sender) {
      // When there is a buy price set, the `buyPrice.seller` is the owner of the NFT.
      revert NFTMarketBuyPrice_Seller_Mismatch(buyPrice.seller);
    }
  }

  /**
   * @notice Returns the buy price details for an NFT if one is available.
   * @dev If no price is found, seller will be address(0) and price will be max uint256.
   * @param nftContract The address of the NFT contract.
   * @param tokenId The id of the NFT.
   * @return seller The address of the owner that listed a buy price for this NFT.
   * Returns `address(0)` if there is no buy price set for this NFT.
   * @return price The price of the NFT.
   * Returns `0` if there is no buy price set for this NFT.
   */
  function getBuyPrice(address nftContract, uint256 tokenId) external view returns (address seller, uint256 price) {
    BuyPrice storage buyPrice = nftContractToTokenIdToBuyPrice[nftContract][tokenId];
    if (buyPrice.seller == address(0)) {
      return (address(0), type(uint256).max);
    }
    return (buyPrice.seller, buyPrice.price);
  }

  /**
   * @inheritdoc NFTMarketCore
   * @dev Returns the seller if there is a buy price set for this NFT, otherwise
   * bubbles the call up for other considerations.
   */
  function _getSellerFor(address nftContract, uint256 tokenId)
    internal
    view
    virtual
    override
    returns (address payable seller)
  {
    seller = nftContractToTokenIdToBuyPrice[nftContract][tokenId].seller;
    if (seller == address(0)) {
      seller = super._getSellerFor(nftContract, tokenId);
    }
  }

  /**
   * @notice This empty reserved space is put in place to allow future versions to add new
   * variables without shifting down storage in the inheritance chain.
   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps
   */
  uint256[1000] private __gap;
}",3752
RealWorld_BA_94_AdminRole_RealWord_20240826152149.log,94,AdminRole,12899,5300,18199,84.0,0.170495,"// SPDX-License-Identifier: MIT OR Apache-2.0

pragma solidity ^0.8.0;

import ""../OZ/AccessControlUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";

/**
 * @title Defines a role for Foundation admin accounts.
 * @dev Wraps the default admin role from OpenZeppelin's AccessControl for easy integration.
 */
abstract contract AdminRole is Initializable, AccessControlUpgradeable {
  function _initializeAdminRole(address admin) internal onlyInitializing {
    AccessControlUpgradeable.__AccessControl_init();
    // Grant the role to a specified account
    _setupRole(DEFAULT_ADMIN_ROLE, admin);
  }

  modifier onlyAdmin() {
    require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), ""AdminRole: caller does not have the Admin role"");
    _;
  }

  /**
   * @notice Adds the account to the list of approved admins.
   * @dev Only callable by admins as enforced by `grantRole`.
   * @param account The address to be approved.
   */
  function grantAdmin(address account) external {
    grantRole(DEFAULT_ADMIN_ROLE, account);
  }

  /**
   * @notice Removes the account from the list of approved admins.
   * @dev Only callable by admins as enforced by `grantRole`.
   * @param account The address to be removed from the approved list.
   */
  function revokeAdmin(address account) external {
    revokeRole(DEFAULT_ADMIN_ROLE, account);
  }

  /**
   * @notice Returns one of the admins by index.
   * @param index The index of the admin to return from 0 to getAdminMemberCount() - 1.
   * @return account The address of the admin.
   */
  function getAdminMember(uint256 index) external view returns (address account) {
    return getRoleMember(DEFAULT_ADMIN_ROLE, index);
  }

  /**
   * @notice Checks how many accounts have been granted admin access.
   * @return count The number of accounts with admin access.
   */
  function getAdminMemberCount() external view returns (uint256 count) {
    return getRoleMemberCount(DEFAULT_ADMIN_ROLE);
  }

  /**
   * @notice Checks if the account provided is an admin.
   * @param account The address to check.
   * @return approved True if the account is an admin.
   * @dev This call is used by the royalty registry contract.
   */
  function isAdmin(address account) external view returns (bool approved) {
    return hasRole(DEFAULT_ADMIN_ROLE, account);
  }

  /**
   * @notice This empty reserved space is put in place to allow future versions to add new
   * variables without shifting down storage in the inheritance chain.
   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps
   */
  uint256[1000] private __gap;
}",600
RealWorld_BA_94_FETH_RealWord_20240826145511.log,94,FETH,122910,5698,128608,103.0,0.72851,"/*
  
   *
       
         
   *  *  
          *  *.
       *.

                      `                     .-:::::-.`              `-::---...```
                     `-:`               .:+ssssoooo++//:.`       .-/+shhhhhhhhhhhhhyyyssooo:
                    .--::.            .+ossso+/////++/:://-`   .////+shhhhhhhhhhhhhhhhhhhhhy
                  `-----::.         `/+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy
                 `------:::-`      `//-.``.-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy
                .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy
              `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy
             .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy
            .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy
          `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy
         .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy
       `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy
       .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo
     .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...``hhhhyo
                                              `````
   *
       
 
   *  *  
          *  *.
       *.
    ** *
  *. 
  *
 * *
*
 *
 
*/

// SPDX-License-Identifier: MIT OR Apache-2.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol"";
import ""@openzeppelin/contracts/utils/math/Math.sol"";

import ""./libraries/LockedBalance.sol"";

error FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();
error FETH_Escrow_Expired();
error FETH_Escrow_Not_Found();
error FETH_Expiration_Too_Far_In_Future();
/// @param amount The current allowed amount the spender is authorized to transact for this account.
error FETH_Insufficient_Allowance(uint256 amount);
/// @param amount The current available (unlocked) token count of this account.
error FETH_Insufficient_Available_Funds(uint256 amount);
/// @param amount The current number of tokens this account has for the given lockup expiry bucket.
error FETH_Insufficient_Escrow(uint256 amount);
error FETH_Invalid_Lockup_Duration();
error FETH_Market_Must_Be_A_Contract();
error FETH_Must_Deposit_Non_Zero_Amount();
error FETH_Must_Lockup_Non_Zero_Amount();
error FETH_No_Funds_To_Withdraw();
error FETH_Only_FND_Market_Allowed();
error FETH_Too_Much_ETH_Provided();
error FETH_Transfer_To_Burn_Not_Allowed();
error FETH_Transfer_To_FETH_Not_Allowed();

/**
 * @title An ERC-20 token which wraps ETH, potentially with a 1 day lockup period.
 * @notice FETH is an [ERC-20 token](https://eips.ethereum.org/EIPS/eip-20) modeled after
 * [WETH9](https://etherscan.io/address/0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2#code).
 * It has the added ability to lockup tokens for 24-25 hours - during this time they may not be
 * transferred or withdrawn, except by our market contract which requested the lockup in the first place.
 * @dev Locked balances are rounded up to the next hour.
 * They are grouped by the expiration time of the lockup into what we refer to as a lockup ""bucket"".
 * At any time there may be up to 25 buckets but never more than that which prevents loops from exhausting gas limits.
 */
contract FETH {
  using AddressUpgradeable for address payable;
  using LockedBalance for LockedBalance.Lockups;
  using Math for uint256;

  /// @notice Tracks an account's info.
  struct AccountInfo {
    /// @notice The number of tokens which have been unlocked already.
    uint96 freedBalance;
    /// @notice The first applicable lockup bucket for this account.
    uint32 lockupStartIndex;
    /// @notice Stores up to 25 buckets of locked balance for a user, one per hour.
    LockedBalance.Lockups lockups;
    /// @notice Returns the amount which a spender is still allowed to withdraw from this account.
    mapping(address => uint256) allowance;
  }

  /// @notice Stores per-account details.
  mapping(address => AccountInfo) private accountToInfo;

  // Lockup configuration
  /// @notice The minimum lockup period in seconds.
  uint256 private immutable lockupDuration;
  /// @notice The interval to which lockup expiries are rounded, limiting the max number of outstanding lockup buckets.
  uint256 private immutable lockupInterval;

  /// @notice The Foundation market contract with permissions to manage lockups.
  address payable private immutable foundationMarket;

  // ERC-20 metadata fields
  /**
   * @notice The number of decimals the token uses.
   * @dev This method can be used to improve usability when displaying token amounts, but all interactions
   * with this contract use whole amounts not considering decimals.
   * @return 18
   */
  uint8 public constant decimals = 18;
  /**
   * @notice The name of the token.
   * @return Foundation Wrapped Ether
   */
  string public constant name = ""Foundation Wrapped Ether"";
  /**
   * @notice The symbol of the token.
   * @return FETH
   */
  string public constant symbol = ""FETH"";

  // ERC-20 events
  /**
   * @notice Emitted when the allowance for a spender account is updated.
   * @param from The account the spender is authorized to transact for.
   * @param spender The account with permissions to manage FETH tokens for the `from` account.
   * @param amount The max amount of tokens which can be spent by the `spender` account.
   */
  event Approval(address indexed from, address indexed spender, uint256 amount);
  /**
   * @notice Emitted when a transfer of FETH tokens is made from one account to another.
   * @param from The account which is sending FETH tokens.
   * @param to The account which is receiving FETH tokens.
   * @param amount The number of FETH tokens which were sent.
   */
  event Transfer(address indexed from, address indexed to, uint256 amount);

  // Custom events
  /**
   * @notice Emitted when FETH tokens are locked up by the Foundation market for 24-25 hours
   * and may include newly deposited ETH which is added to the account's total FETH balance.
   * @param account The account which has access to the FETH after the `expiration`.
   * @param expiration The time at which the `from` account will have access to the locked FETH.
   * @param amount The number of FETH tokens which where locked up.
   * @param valueDeposited The amount of ETH added to their account's total FETH balance,
   * this may be lower than `amount` if available FETH was leveraged.
   */
  event BalanceLocked(address indexed account, uint256 indexed expiration, uint256 amount, uint256 valueDeposited);
  /**
   * @notice Emitted when FETH tokens are unlocked by the Foundation market.
   * @dev This event will not be emitted when lockups expire,
   * it's only for tokens which are unlocked before their expiry.
   * @param account The account which had locked FETH freed before expiration.
   * @param expiration The time this balance was originally scheduled to be unlocked.
   * @param amount The number of FETH tokens which were unlocked.
   */
  event BalanceUnlocked(address indexed account, uint256 indexed expiration, uint256 amount);
  /**
   * @notice Emitted when ETH is withdrawn from a user's account.
   * @dev This may be triggered by the user, an approved operator, or the Foundation market.
   * @param from The account from which FETH was deducted in order to send the ETH.
   * @param to The address the ETH was sent to.
   * @param amount The number of tokens which were deducted from the user's FETH balance and transferred as ETH.
   */
  event ETHWithdrawn(address indexed from, address indexed to, uint256 amount);

  /// @dev Allows the Foundation market permission to manage lockups for a user.
  modifier onlyFoundationMarket() {
    if (msg.sender != foundationMarket) {
      revert FETH_Only_FND_Market_Allowed();
    }
    _;
  }

  /**
   * @notice Initializes variables which may differ on testnet.
   * @param _foundationMarket The address of the Foundation NFT marketplace.
   * @param _lockupDuration The minimum length of time to lockup tokens for when `BalanceLocked`, in seconds.
   */
  constructor(address payable _foundationMarket, uint256 _lockupDuration) {
    if (!_foundationMarket.isContract()) {
      revert FETH_Market_Must_Be_A_Contract();
    }
    foundationMarket = _foundationMarket;
    lockupDuration = _lockupDuration;
    lockupInterval = _lockupDuration / 24;
    if (lockupInterval * 24 != _lockupDuration || _lockupDuration == 0) {
      revert FETH_Invalid_Lockup_Duration();
    }
  }

  /**
   * @notice Transferring ETH (via `msg.value`) to the contract performs a `deposit` into the user's account.
   */
  receive() external payable {
    depositFor(msg.sender);
  }

  /**
   * @notice Approves a `spender` as an operator with permissions to transfer from your account.
   * @param spender The address of the operator account that has approval to spend funds
   * from the `msg.sender`'s account.
   * @param amount The max number of FETH tokens from `msg.sender`'s account that this spender is
   * allowed to transact with.
   * @return success Always true.
   */
  function approve(address spender, uint256 amount) external returns (bool success) {
    accountToInfo[msg.sender].allowance[spender] = amount;
    emit Approval(msg.sender, spender, amount);
    return true;
  }

  /**
   * @notice Deposit ETH (via `msg.value`) and receive the equivalent amount in FETH tokens.
   * These tokens are not subject to any lockup period.
   */
  function deposit() external payable {
    depositFor(msg.sender);
  }

  /**
   * @notice Deposit ETH (via `msg.value`) and credit the `account` provided with the equivalent amount in FETH tokens.
   * These tokens are not subject to any lockup period.
   * @dev This may be used by the Foundation market to credit a user's account with FETH tokens.
   * @param account The account to credit with FETH tokens.
   */
  function depositFor(address account) public payable {
    if (msg.value == 0) {
      revert FETH_Must_Deposit_Non_Zero_Amount();
    }
    AccountInfo storage accountInfo = accountToInfo[account];
    // ETH value cannot realistically overflow 96 bits.
    unchecked {
      accountInfo.freedBalance += uint96(msg.value);
    }
    emit Transfer(address(0), account, msg.value);
  }

  /**
   * @notice Used by the market contract only:
   * Remove an account's lockup and then create a new lockup, potentially for a different account.
   * @dev Used by the market when an offer for an NFT is increased.
   * This may be for a single account (increasing their offer)
   * or two different accounts (outbidding someone elses offer).
   * @param unlockFrom The account whose lockup is to be removed.
   * @param unlockExpiration The original lockup expiration for the tokens to be unlocked.
   * This will revert if the lockup has already expired.
   * @param unlockAmount The number of tokens to be unlocked from `unlockFrom`'s account.
   * This will revert if the tokens were previously unlocked.
   * @param lockupFor The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.
   * @param lockupAmount The number of tokens to be locked up for the `lockupFor`'s account.
   * `msg.value` must be <= `lockupAmount` and any delta will be taken from the account's available FETH balance.
   * @return expiration The expiration timestamp for the FETH tokens that were locked.
   */
  function marketChangeLockup(
    address unlockFrom,
    uint256 unlockExpiration,
    uint256 unlockAmount,
    address lockupFor,
    uint256 lockupAmount
  ) external payable onlyFoundationMarket returns (uint256 expiration) {
    _marketUnlockFor(unlockFrom, unlockExpiration, unlockAmount);
    return _marketLockupFor(lockupFor, lockupAmount);
  }

  /**
   * @notice Used by the market contract only:
   * Lockup an account's FETH tokens for 24-25 hours.
   * @dev Used by the market when a new offer for an NFT is made.
   * @param account The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.
   * @param amount The number of tokens to be locked up for the `lockupFor`'s account.
   * `msg.value` must be <= `amount` and any delta will be taken from the account's available FETH balance.
   * @return expiration The expiration timestamp for the FETH tokens that were locked.
   */
  function marketLockupFor(address account, uint256 amount)
    external
    payable
    onlyFoundationMarket
    returns (uint256 expiration)
  {
    return _marketLockupFor(account, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.
   * @dev Used by the market when an offer is invalidated, which occurs when an auction for the same NFT
   * receives its first bid or the buyer purchased the NFT another way, such as with `buy`.
   * @param account The account whose lockup is to be unlocked.
   * @param expiration The original lockup expiration for the tokens to be unlocked unlocked.
   * This will revert if the lockup has already expired.
   * @param amount The number of tokens to be unlocked from `account`.
   * This will revert if the tokens were previously unlocked.
   */
  function marketUnlockFor(
    address account,
    uint256 expiration,
    uint256 amount
  ) external onlyFoundationMarket {
    _marketUnlockFor(account, expiration, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Removes tokens from the user's available balance and returns ETH to the caller.
   * @dev Used by the market when a user's available FETH balance is used to make a purchase
   * including accepting a buy price or a private sale, or placing a bid in an auction.
   * @param from The account whose available balance is to be withdrawn from.
   * @param amount The number of tokens to be deducted from `unlockFrom`'s available balance and transferred as ETH.
   * This will revert if the tokens were previously unlocked.
   */
  function marketWithdrawFrom(address from, uint256 amount) external onlyFoundationMarket {
    AccountInfo storage accountInfo = _freeFromEscrow(from);
    _deductBalanceFrom(accountInfo, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(from, msg.sender, amount);
  }

  /**
   * @notice Used by the market contract only:
   * Removes a lockup from the user's account and then returns ETH to the caller.
   * @dev Used by the market to extract unexpired funds as ETH to distribute for
   * a sale when the user's offer is accepted.
   * @param account The account whose lockup is to be removed.
   * @param expiration The original lockup expiration for the tokens to be unlocked.
   * This will revert if the lockup has already expired.
   * @param amount The number of tokens to be unlocked and withdrawn as ETH.
   */
  function marketWithdrawLocked(
    address account,
    uint256 expiration,
    uint256 amount
  ) external onlyFoundationMarket {
    _removeFromLockedBalance(account, expiration, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(account, msg.sender, amount);
  }

  /**
   * @notice Transfers an amount from your account.
   * @param to The address of the account which the tokens are transferred from.
   * @param amount The number of FETH tokens to be transferred.
   * @return success Always true (reverts if insufficient funds).
   */
  function transfer(address to, uint256 amount) external returns (bool success) {
    return transferFrom(msg.sender, to, amount);
  }

  /**
   * @notice Transfers an amount from the account specified if the `msg.sender` has approval.
   * @param from The address from which the available tokens are transferred from.
   * @param to The address to which the tokens are to be transferred.
   * @param amount The number of FETH tokens to be transferred.
   * @return success Always true (reverts if insufficient funds or not approved).
   */
  function transferFrom(
    address from,
    address to,
    uint256 amount
  ) public returns (bool success) {
    if (to == address(0)) {
      revert FETH_Transfer_To_Burn_Not_Allowed();
    } else if (to == address(this)) {
      revert FETH_Transfer_To_FETH_Not_Allowed();
    }
    AccountInfo storage fromAccountInfo = _freeFromEscrow(from);
    if (from != msg.sender) {
      _deductAllowanceFrom(fromAccountInfo, amount);
    }
    _deductBalanceFrom(fromAccountInfo, amount);
    AccountInfo storage toAccountInfo = accountToInfo[to];

    // Total ETH cannot realistically overflow 96 bits.
    unchecked {
      toAccountInfo.freedBalance += uint96(amount);
    }

    emit Transfer(from, to, amount);

    return true;
  }

  /**
   * @notice Withdraw all tokens available in your account and receive ETH.
   */
  function withdrawAvailableBalance() external {
    AccountInfo storage accountInfo = _freeFromEscrow(msg.sender);
    uint256 amount = accountInfo.freedBalance;
    if (amount == 0) {
      revert FETH_No_Funds_To_Withdraw();
    }
    delete accountInfo.freedBalance;

    // With the external call after state changes, we do not need a nonReentrant guard
    payable(msg.sender).sendValue(amount);

    emit ETHWithdrawn(msg.sender, msg.sender, amount);
  }

  /**
   * @notice Withdraw the specified number of tokens from the `from` accounts available balance
   * and send ETH to the destination address, if the `msg.sender` has approval.
   * @param from The address from which the available funds are to be withdrawn.
   * @param to The destination address for the ETH to be transferred to.
   * @param amount The number of tokens to be withdrawn and transferred as ETH.
   */
  function withdrawFrom(
    address from,
    address payable to,
    uint256 amount
  ) external {
    if (amount == 0) {
      revert FETH_No_Funds_To_Withdraw();
    }
    AccountInfo storage accountInfo = _freeFromEscrow(from);
    if (from != msg.sender) {
      _deductAllowanceFrom(accountInfo, amount);
    }
    _deductBalanceFrom(accountInfo, amount);

    // With the external call after state changes, we do not need a nonReentrant guard
    to.sendValue(amount);

    emit ETHWithdrawn(from, to, amount);
  }

  /**
   * @dev Require msg.sender has been approved and deducts the amount from the available allowance.
   */
  function _deductAllowanceFrom(AccountInfo storage accountInfo, uint256 amount) private {
    if (accountInfo.allowance[msg.sender] != type(uint256).max) {
      if (accountInfo.allowance[msg.sender] < amount) {
        revert FETH_Insufficient_Allowance(accountInfo.allowance[msg.sender]);
      }
      // The check above ensures allowance cannot underflow.
      unchecked {
        accountInfo.allowance[msg.sender] -= amount;
      }
    }
  }

  /**
   * @dev Removes an amount from the account's available FETH balance.
   */
  function _deductBalanceFrom(AccountInfo storage accountInfo, uint256 amount) private {
    // Free from escrow in order to consider any expired escrow balance
    if (accountInfo.freedBalance < amount) {
      revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);
    }
    // The check above ensures balance cannot underflow.
    unchecked {
      accountInfo.freedBalance -= uint96(amount);
    }
  }

  /**
   * @dev Moves expired escrow to the available balance.
   */
  function _freeFromEscrow(address account) private returns (AccountInfo storage) {
    AccountInfo storage accountInfo = accountToInfo[account];
    uint256 escrowIndex = accountInfo.lockupStartIndex;
    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);

    // If the first bucket (the oldest) is empty or not yet expired, no change to escrowStartIndex is required
    if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {
      return accountInfo;
    }

    while (true) {
      // Total ETH cannot realistically overflow 96 bits.
      unchecked {
        accountInfo.freedBalance += escrow.totalAmount;
        accountInfo.lockups.del(escrowIndex);
        // Escrow index cannot overflow 32 bits.
        escrow = accountInfo.lockups.get(escrowIndex + 1);
      }

      // If the next bucket is empty, the start index is set to the previous bucket
      if (escrow.expiration == 0) {
        break;
      }

      // Escrow index cannot overflow 32 bits.
      unchecked {
        // Increment the escrow start index if the next bucket is not empty
        ++escrowIndex;
      }

      // If the next bucket is expired, that's the new start index
      if (escrow.expiration >= block.timestamp) {
        break;
      }
    }

    // Escrow index cannot overflow 32 bits.
    unchecked {
      accountInfo.lockupStartIndex = uint32(escrowIndex);
    }
    return accountInfo;
  }

  /**
   * @notice Lockup an account's FETH tokens for 24-25 hours.
   */
  /* solhint-disable-next-line code-complexity */
  function _marketLockupFor(address account, uint256 amount) private returns (uint256 expiration) {
    if (account == address(0)) {
      revert FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();
    }
    if (amount == 0) {
      revert FETH_Must_Lockup_Non_Zero_Amount();
    }

    // Block timestamp in seconds is small enough to never overflow
    unchecked {
      // Lockup expires after 24 hours, rounded up to the next hour for a total of [24-25) hours
      expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval;
    }

    // Update available escrow
    // Always free from escrow to ensure the max bucket count is <= 25
    AccountInfo storage accountInfo = _freeFromEscrow(account);
    if (msg.value < amount) {
      // The check above prevents underflow with delta.
      unchecked {
        uint256 delta = amount - msg.value;
        if (accountInfo.freedBalance < delta) {
          revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);
        }
        // The check above prevents underflow of freed balance.
        accountInfo.freedBalance -= uint96(delta);
      }
    } else if (msg.value != amount) {
      // There's no reason to send msg.value more than the amount being locked up
      revert FETH_Too_Much_ETH_Provided();
    }

    // Add to locked escrow
    unchecked {
      // The number of buckets is always < 256 bits.
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          if (expiration > type(uint32).max) {
            revert FETH_Expiration_Too_Far_In_Future();
          }
          // Amount (ETH) will always be < 96 bits.
          accountInfo.lockups.set(escrowIndex, expiration, amount);
          break;
        }
        if (escrow.expiration == expiration) {
          // Total ETH will always be < 96 bits.
          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount + amount);
          break;
        }
      }
    }

    emit BalanceLocked(account, expiration, amount, msg.value);
  }

  /**
   * @notice Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.
   */
  function _marketUnlockFor(
    address account,
    uint256 expiration,
    uint256 amount
  ) private {
    AccountInfo storage accountInfo = _removeFromLockedBalance(account, expiration, amount);
    // Total ETH cannot realistically overflow 96 bits.
    unchecked {
      accountInfo.freedBalance += uint96(amount);
    }
  }

  /**
   * @dev Removes the specified amount from locked escrow, potentially before its expiration.
   */
  /* solhint-disable-next-line code-complexity */
  function _removeFromLockedBalance(
    address account,
    uint256 expiration,
    uint256 amount
  ) private returns (AccountInfo storage) {
    if (expiration < block.timestamp) {
      revert FETH_Escrow_Expired();
    }

    AccountInfo storage accountInfo = accountToInfo[account];
    uint256 escrowIndex = accountInfo.lockupStartIndex;
    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);

    if (escrow.expiration == expiration) {
      // If removing from the first bucket, we may be able to delete it
      if (escrow.totalAmount == amount) {
        accountInfo.lockups.del(escrowIndex);

        // Bump the escrow start index unless it's the last one
        if (accountInfo.lockups.get(escrowIndex + 1).expiration != 0) {
          // The number of escrow buckets will never overflow 32 bits.
          unchecked {
            ++accountInfo.lockupStartIndex;
          }
        }
      } else {
        if (escrow.totalAmount < amount) {
          revert FETH_Insufficient_Escrow(escrow.totalAmount);
        }
        // The require above ensures balance will not underflow.
        unchecked {
          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);
        }
      }
    } else {
      // Removing from the 2nd+ bucket
      while (true) {
        // The number of escrow buckets will never overflow 32 bits.
        unchecked {
          ++escrowIndex;
        }
        escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == expiration) {
          if (amount > escrow.totalAmount) {
            revert FETH_Insufficient_Escrow(escrow.totalAmount);
          }
          // The require above ensures balance will not underflow.
          unchecked {
            accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);
          }
          // We may have an entry with 0 totalAmount but expiration will be set
          break;
        }
        if (escrow.expiration == 0) {
          revert FETH_Escrow_Not_Found();
        }
      }
    }

    emit BalanceUnlocked(account, expiration, amount);
    return accountInfo;
  }

  /**
   * @notice Returns the amount which a spender is still allowed to transact from the `account`'s balance.
   * @param account The owner of the funds.
   * @param operator The address with approval to spend from the `account`'s balance.
   * @return amount The number of tokens the `operator` is still allowed to transact with.
   */
  function allowance(address account, address operator) external view returns (uint256 amount) {
    AccountInfo storage accountInfo = accountToInfo[account];
    return accountInfo.allowance[operator];
  }

  /**
   * @notice Returns the balance of an account which is available to transfer or withdraw.
   * @dev This will automatically increase as soon as locked tokens reach their expiry date.
   * @param account The account to query the available balance of.
   * @return balance The available balance of the account.
   */
  function balanceOf(address account) external view returns (uint256 balance) {
    AccountInfo storage accountInfo = accountToInfo[account];
    balance = accountInfo.freedBalance;

    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.
    unchecked {
      // Add expired lockups
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {
          break;
        }
        balance += escrow.totalAmount;
      }
    }
  }

  /**
   * @notice Gets the Foundation market address which has permissions to manage lockups.
   * @return market The Foundation market contract address.
   */
  function getFoundationMarket() external view returns (address market) {
    return foundationMarket;
  }

  /**
   * @notice Returns the balance and each outstanding (unexpired) lockup bucket for an account, grouped by expiry.
   * @dev `expires.length` == `amounts.length`
   * and `amounts[i]` is the number of tokens which will expire at `expires[i]`.
   * The results returned are sorted by expiry, with the earliest expiry date first.
   * @param account The account to query the locked balance of.
   * @return expiries The time at which each outstanding lockup bucket expires.
   * @return amounts The number of FETH tokens which will expire for each outstanding lockup bucket.
   */
  function getLockups(address account) external view returns (uint256[] memory expiries, uint256[] memory amounts) {
    AccountInfo storage accountInfo = accountToInfo[account];

    // Count lockups
    uint256 lockedCount;
    // The number of buckets is always < 256 bits.
    unchecked {
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        if (escrow.expiration >= block.timestamp && escrow.totalAmount > 0) {
          // Lockup count will never overflow 256 bits.
          ++lockedCount;
        }
      }
    }

    // Allocate arrays
    expiries = new uint256[](lockedCount);
    amounts = new uint256[](lockedCount);

    // Populate results
    uint256 i;
    // The number of buckets is always < 256 bits.
    unchecked {
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        if (escrow.expiration >= block.timestamp && escrow.totalAmount > 0) {
          expiries[i] = escrow.expiration;
          amounts[i] = escrow.totalAmount;
          ++i;
        }
      }
    }
  }

  /**
   * @notice Returns the total balance of an account, including locked FETH tokens.
   * @dev Use `balanceOf` to get the number of tokens available for transfer or withdrawal.
   * @param account The account to query the total balance of.
   * @return balance The total FETH balance tracked for this account.
   */
  function totalBalanceOf(address account) external view returns (uint256 balance) {
    AccountInfo storage accountInfo = accountToInfo[account];
    balance = accountInfo.freedBalance;

    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.
    unchecked {
      // Add all lockups
      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {
        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);
        if (escrow.expiration == 0) {
          break;
        }
        balance += escrow.totalAmount;
      }
    }
  }

  /**
   * @notice Returns the total amount of ETH locked in this contract.
   * @return supply The total amount of ETH locked in this contract.
   */
  function totalSupply() external view returns (uint256 supply) {
    /* It is possible for this to diverge from the total token count by transferring ETH on self destruct
       but this is on-par with the WETH implementation and done for gas savings. */
    return address(this).balance;
  }
}",7670
RealWorld_BA_94_ITokenCreator_RealWord_20240826153104.log,94,ITokenCreator,3749,3950,7699,64.0,0.097745,"// SPDX-License-Identifier: MIT OR Apache-2.0

pragma solidity ^0.8.0;

interface ITokenCreator {
  function tokenCreator(uint256 tokenId) external view returns (address payable);
}",43
RealWorld_BA_94_NFTMarketCreators_RealWord_20240826151634.log,94,NFTMarketCreators,40429,5620,46049,92.0,0.314545,"// SPDX-License-Identifier: MIT OR Apache-2.0

pragma solidity ^0.8.0;

import ""./OZ/ERC165Checker.sol"";
import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";

import ""./Constants.sol"";

import ""../interfaces/IGetFees.sol"";
import ""../interfaces/IGetRoyalties.sol"";
import ""../interfaces/IOwnable.sol"";
import ""../interfaces/IRoyaltyInfo.sol"";
import ""../interfaces/ITokenCreator.sol"";
import ""@manifoldxyz/royalty-registry-solidity/contracts/IRoyaltyRegistry.sol"";

error NFTMarketCreators_Address_Does_Not_Support_IRoyaltyRegistry();

/**
 * @title A mixin for associating creators to NFTs.
 * @dev In the future this may store creators directly in order to support NFTs created on a different platform.
 */
abstract contract NFTMarketCreators is
  Constants,
  ReentrancyGuardUpgradeable // Adding this unused mixin to help with linearization
{
  using ERC165Checker for address;

  IRoyaltyRegistry private immutable royaltyRegistry;

  /**
   * @notice Configures the registry allowing for royalty overrides to be defined.
   * @param _royaltyRegistry The registry to use for royalty overrides.
   */
  constructor(address _royaltyRegistry) {
    if (!_royaltyRegistry.supportsInterface(type(IRoyaltyRegistry).interfaceId)) {
      revert NFTMarketCreators_Address_Does_Not_Support_IRoyaltyRegistry();
    }
    royaltyRegistry = IRoyaltyRegistry(_royaltyRegistry);
  }

  /**
   * @notice Looks up the royalty payment configuration for a given NFT.
   * @dev This will check various royalty APIs on the NFT and the royalty override
   * if one was registered with the royalty registry. This aims to send royalties
   * in the manner requested by the NFT owner, regardless of where the NFT was minted.
   */
  // solhint-disable-next-line code-complexity
  function _getCreatorPaymentInfo(
    address nftContract,
    uint256 tokenId,
    address seller
  )
    internal
    view
    returns (
      address payable[] memory recipients,
      uint256[] memory splitPerRecipientInBasisPoints,
      bool isCreator
    )
  {
    // All NFTs implement 165 so we skip that check, individual interfaces should return false if 165 is not implemented

    // 1st priority: ERC-2981
    if (nftContract.supportsERC165Interface(type(IRoyaltyInfo).interfaceId)) {
      try IRoyaltyInfo(nftContract).royaltyInfo{ gas: READ_ONLY_GAS_LIMIT }(tokenId, BASIS_POINTS) returns (
        address receiver,
        uint256 /* royaltyAmount */
      ) {
        if (receiver != address(0)) {
          recipients = new address payable[](1);
          recipients[0] = payable(receiver);
          // splitPerRecipientInBasisPoints is not relevant when only 1 recipient is defined
          if (receiver == seller) {
            return (recipients, splitPerRecipientInBasisPoints, true);
          }
        }
      } catch // solhint-disable-next-line no-empty-blocks
      {
        // Fall through
      }
    }

    // 2nd priority: getRoyalties
    if (recipients.length == 0 && nftContract.supportsERC165Interface(type(IGetRoyalties).interfaceId)) {
      try IGetRoyalties(nftContract).getRoyalties{ gas: READ_ONLY_GAS_LIMIT }(tokenId) returns (
        address payable[] memory _recipients,
        uint256[] memory recipientBasisPoints
      ) {
        if (_recipients.length > 0 && _recipients.length == recipientBasisPoints.length) {
          bool hasRecipient;
          unchecked {
            // The array length cannot overflow 256 bits.
            for (uint256 i = 0; i < _recipients.length; ++i) {
              if (_recipients[i] != address(0)) {
                hasRecipient = true;
                if (_recipients[i] == seller) {
                  return (_recipients, recipientBasisPoints, true);
                }
              }
            }
          }
          if (hasRecipient) {
            recipients = _recipients;
            splitPerRecipientInBasisPoints = recipientBasisPoints;
          }
        }
      } catch // solhint-disable-next-line no-empty-blocks
      {
        // Fall through
      }
    }

    /* Overrides must support ERC-165 when registered, except for overrides defined by the registry owner.
       If that results in an override w/o 165 we may need to upgrade the market to support or ignore that override. */
    // The registry requires overrides are not 0 and contracts when set.
    // If no override is set, the nftContract address is returned.
    if (recipients.length == 0) {
      try royaltyRegistry.getRoyaltyLookupAddress{ gas: READ_ONLY_GAS_LIMIT }(nftContract) returns (
        address overrideContract
      ) {
        if (overrideContract != nftContract) {
          nftContract = overrideContract;

          // The functions above are repeated here if an override is set.

          // 3rd priority: ERC-2981 override
          if (nftContract.supportsERC165Interface(type(IRoyaltyInfo).interfaceId)) {
            try IRoyaltyInfo(nftContract).royaltyInfo{ gas: READ_ONLY_GAS_LIMIT }(tokenId, BASIS_POINTS) returns (
              address receiver,
              uint256 /* royaltyAmount */
            ) {
              if (receiver != address(0)) {
                recipients = new address payable[](1);
                recipients[0] = payable(receiver);
                // splitPerRecipientInBasisPoints is not relevant when only 1 recipient is defined
                if (receiver == seller) {
                  return (recipients, splitPerRecipientInBasisPoints, true);
                }
              }
            } catch // solhint-disable-next-line no-empty-blocks
            {
              // Fall through
            }
          }

          // 4th priority: getRoyalties override
          if (recipients.length == 0 && nftContract.supportsERC165Interface(type(IGetRoyalties).interfaceId)) {
            try IGetRoyalties(nftContract).getRoyalties{ gas: READ_ONLY_GAS_LIMIT }(tokenId) returns (
              address payable[] memory _recipients,
              uint256[] memory recipientBasisPoints
            ) {
              if (_recipients.length > 0 && _recipients.length == recipientBasisPoints.length) {
                bool hasRecipient;
                for (uint256 i = 0; i < _recipients.length; ++i) {
                  if (_recipients[i] != address(0)) {
                    hasRecipient = true;
                    if (_recipients[i] == seller) {
                      return (_recipients, recipientBasisPoints, true);
                    }
                  }
                }
                if (hasRecipient) {
                  recipients = _recipients;
                  splitPerRecipientInBasisPoints = recipientBasisPoints;
                }
              }
            } catch // solhint-disable-next-line no-empty-blocks
            {
              // Fall through
            }
          }
        }
      } catch // solhint-disable-next-line no-empty-blocks
      {
        // Ignore out of gas errors and continue using the nftContract address
      }
    }

    // 5th priority: getFee* from contract or override
    if (recipients.length == 0 && nftContract.supportsERC165Interface(type(IGetFees).interfaceId)) {
      try IGetFees(nftContract).getFeeRecipients{ gas: READ_ONLY_GAS_LIMIT }(tokenId) returns (
        address payable[] memory _recipients
      ) {
        if (_recipients.length > 0) {
          try IGetFees(nftContract).getFeeBps{ gas: READ_ONLY_GAS_LIMIT }(tokenId) returns (
            uint256[] memory recipientBasisPoints
          ) {
            if (_recipients.length == recipientBasisPoints.length) {
              bool hasRecipient;
              unchecked {
                // The array length cannot overflow 256 bits.
                for (uint256 i = 0; i < _recipients.length; ++i) {
                  if (_recipients[i] != address(0)) {
                    hasRecipient = true;
                    if (_recipients[i] == seller) {
                      return (_recipients, recipientBasisPoints, true);
                    }
                  }
                }
              }
              if (hasRecipient) {
                recipients = _recipients;
                splitPerRecipientInBasisPoints = recipientBasisPoints;
              }
            }
          } catch // solhint-disable-next-line no-empty-blocks
          {
            // Fall through
          }
        }
      } catch // solhint-disable-next-line no-empty-blocks
      {
        // Fall through
      }
    }

    // 6th priority: tokenCreator w/ or w/o requiring 165 from contract or override
    try ITokenCreator(nftContract).tokenCreator{ gas: READ_ONLY_GAS_LIMIT }(tokenId) returns (
      address payable _creator
    ) {
      if (_creator != address(0)) {
        if (recipients.length == 0) {
          // Only pay the tokenCreator if there wasn't another royalty defined
          recipients = new address payable[](1);
          recipients[0] = _creator;
          // splitPerRecipientInBasisPoints is not relevant when only 1 recipient is defined
        }
        return (recipients, splitPerRecipientInBasisPoints, _creator == seller);
      }
    } catch // solhint-disable-next-line no-empty-blocks
    {
      // Fall through
    }

    // 7th priority: owner from contract or override
    try IOwnable(nftContract).owner{ gas: READ_ONLY_GAS_LIMIT }() returns (address owner) {
      if (recipients.length == 0) {
        // Only pay the owner if there wasn't another royalty defined
        recipients = new address payable[](1);
        recipients[0] = payable(owner);
        // splitPerRecipientInBasisPoints is not relevant when only 1 recipient is defined
      }
      return (recipients, splitPerRecipientInBasisPoints, owner == seller);
    } catch // solhint-disable-next-line no-empty-blocks
    {
      // Fall through
    }

    // If no valid payment address or creator is found, return 0 recipients
  }

  /**
   * @notice Returns the address of the registry allowing for royalty configuration overrides.
   * @return registry The address of the royalty registry contract.
   */
  function getRoyaltyRegistry() public view returns (address registry) {
    return address(royaltyRegistry);
  }

  /**
   * @notice This empty reserved space is put in place to allow future versions to add new
   * variables without shifting down storage in the inheritance chain.
   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps
   * @dev 500 slots were consumed with the addition of `SendValueWithFallbackWithdraw`.
   */
  uint256[500] private __gap;
}",2363
RealWorld_BA_94_NFTMarketFees_RealWord_20240826150638.log,94,NFTMarketFees,32713,5186,37899,75.0,0.267285,"// SPDX-License-Identifier: MIT OR Apache-2.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";

import ""./Constants.sol"";
import ""./FoundationTreasuryNode.sol"";
import ""./NFTMarketCore.sol"";
import ""./NFTMarketCreators.sol"";
import ""./SendValueWithFallbackWithdraw.sol"";

import ""@openzeppelin/contracts/token/ERC721/IERC721.sol"";

/**
 * @title A mixin to distribute funds when an NFT is sold.
 */
abstract contract NFTMarketFees is
  Constants,
  Initializable,
  FoundationTreasuryNode,
  NFTMarketCore,
  NFTMarketCreators,
  SendValueWithFallbackWithdraw
{
  /**
   * @dev Removing old unused variables in an upgrade safe way. Was:
   * uint256 private _primaryFoundationFeeBasisPoints;
   * uint256 private _secondaryFoundationFeeBasisPoints;
   * uint256 private _secondaryCreatorFeeBasisPoints;
   */
  uint256[3] private __gap_was_fees;

  /// @notice Track if there has been a sale for the NFT in this market previously.
  mapping(address => mapping(uint256 => bool)) private _nftContractToTokenIdToFirstSaleCompleted;

  /// @notice The royalties sent to creator recipients on secondary sales.
  uint256 private constant CREATOR_ROYALTY_BASIS_POINTS = 1000; // 10%
  /// @notice The fee collected by Foundation for sales facilitated by this market contract for a primary sale.
  uint256 private constant PRIMARY_FOUNDATION_FEE_BASIS_POINTS = 1500; // 15%
  /// @notice The fee collected by Foundation for sales facilitated by this market contract for a secondary sale.
  uint256 private constant SECONDARY_FOUNDATION_FEE_BASIS_POINTS = 500; // 5%

  /**
   * @notice Distributes funds to foundation, creator recipients, and NFT owner after a sale.
   */
  // solhint-disable-next-line code-complexity
  function _distributeFunds(
    address nftContract,
    uint256 tokenId,
    address payable seller,
    uint256 price
  )
    internal
    returns (
      uint256 foundationFee,
      uint256 creatorFee,
      uint256 ownerRev
    )
  {
    address payable[] memory creatorRecipients;
    uint256[] memory creatorShares;

    address payable ownerRevTo;
    (foundationFee, creatorRecipients, creatorShares, creatorFee, ownerRevTo, ownerRev) = _getFees(
      nftContract,
      tokenId,
      seller,
      price
    );

    _sendValueWithFallbackWithdraw(getFoundationTreasury(), foundationFee, SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT);

    if (creatorFee > 0) {
      if (creatorRecipients.length > 1) {
        uint256 maxCreatorIndex = creatorRecipients.length - 1;
        if (maxCreatorIndex > MAX_ROYALTY_RECIPIENTS_INDEX) {
          maxCreatorIndex = MAX_ROYALTY_RECIPIENTS_INDEX;
        }

        // Determine the total shares defined so it can be leveraged to distribute below
        uint256 totalShares;
        unchecked {
          // The array length cannot overflow 256 bits.
          for (uint256 i = 0; i <= maxCreatorIndex; ++i) {
            if (creatorShares[i] > BASIS_POINTS) {
              // If the numbers are >100% we ignore the fee recipients and pay just the first instead
              maxCreatorIndex = 0;
              break;
            }
            // The check above ensures totalShares wont overflow.
            totalShares += creatorShares[i];
          }
        }
        if (totalShares == 0) {
          maxCreatorIndex = 0;
        }

        // Send payouts to each additional recipient if more than 1 was defined
        uint256 totalDistributed;
        for (uint256 i = 1; i <= maxCreatorIndex; ++i) {
          uint256 share = (creatorFee * creatorShares[i]) / totalShares;
          totalDistributed += share;
          _sendValueWithFallbackWithdraw(creatorRecipients[i], share, SEND_VALUE_GAS_LIMIT_MULTIPLE_RECIPIENTS);
        }

        // Send the remainder to the 1st creator, rounding in their favor
        _sendValueWithFallbackWithdraw(
          creatorRecipients[0],
          creatorFee - totalDistributed,
          SEND_VALUE_GAS_LIMIT_MULTIPLE_RECIPIENTS
        );
      } else {
        _sendValueWithFallbackWithdraw(creatorRecipients[0], creatorFee, SEND_VALUE_GAS_LIMIT_MULTIPLE_RECIPIENTS);
      }
    }
    _sendValueWithFallbackWithdraw(ownerRevTo, ownerRev, SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT);

    _nftContractToTokenIdToFirstSaleCompleted[nftContract][tokenId] = true;
  }

  /**
   * @notice Returns how funds will be distributed for a sale at the given price point.
   * @param nftContract The address of the NFT contract.
   * @param tokenId The id of the NFT.
   * @param price The sale price to calculate the fees for.
   * @return foundationFee How much will be sent to the Foundation treasury.
   * @return creatorRev How much will be sent across all the `creatorRecipients` defined.
   * @return creatorRecipients The addresses of the recipients to receive a portion of the creator fee.
   * @return creatorShares The percentage of the creator fee to be distributed to each `creatorRecipient`.
   * If there is only one `creatorRecipient`, this may be an empty array.
   * Otherwise `creatorShares.length` == `creatorRecipients.length`.
   * @return ownerRev How much will be sent to the owner/seller of the NFT.
   * If the NFT is being sold by the creator, this may be 0 and the full revenue will appear as `creatorRev`.
   * @return owner The address of the owner of the NFT.
   * If `ownerRev` is 0, this may be `address(0)`.
   */
  function getFeesAndRecipients(
    address nftContract,
    uint256 tokenId,
    uint256 price
  )
    external
    view
    returns (
      uint256 foundationFee,
      uint256 creatorRev,
      address payable[] memory creatorRecipients,
      uint256[] memory creatorShares,
      uint256 ownerRev,
      address payable owner
    )
  {
    address payable seller = _getSellerFor(nftContract, tokenId);
    (foundationFee, creatorRecipients, creatorShares, creatorRev, owner, ownerRev) = _getFees(
      nftContract,
      tokenId,
      seller,
      price
    );
  }

  /**
   * @dev Calculates how funds should be distributed for the given sale details.
   */
  function _getFees(
    address nftContract,
    uint256 tokenId,
    address payable seller,
    uint256 price
  )
    private
    view
    returns (
      uint256 foundationFee,
      address payable[] memory creatorRecipients,
      uint256[] memory creatorShares,
      uint256 creatorRev,
      address payable ownerRevTo,
      uint256 ownerRev
    )
  {
    bool isCreator;
    (creatorRecipients, creatorShares, isCreator) = _getCreatorPaymentInfo(nftContract, tokenId, seller);

    // Calculate the Foundation fee
    uint256 fee;
    if (isCreator && !_nftContractToTokenIdToFirstSaleCompleted[nftContract][tokenId]) {
      fee = PRIMARY_FOUNDATION_FEE_BASIS_POINTS;
    } else {
      fee = SECONDARY_FOUNDATION_FEE_BASIS_POINTS;
    }

    foundationFee = (price * fee) / BASIS_POINTS;

    if (creatorRecipients.length > 0) {
      if (isCreator) {
        // When sold by the creator, all revenue is split if applicable.
        creatorRev = price - foundationFee;
      } else {
        // Rounding favors the owner first, then creator, and foundation last.
        creatorRev = (price * CREATOR_ROYALTY_BASIS_POINTS) / BASIS_POINTS;
        ownerRevTo = seller;
        ownerRev = price - foundationFee - creatorRev;
      }
    } else {
      // No royalty recipients found.
      ownerRevTo = seller;
      ownerRev = price - foundationFee;
    }
  }

  /**
   * @notice This empty reserved space is put in place to allow future versions to add new
   * variables without shifting down storage in the inheritance chain.
   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps
   */
  uint256[1000] private __gap;
}",1867
RealWorld_BA_94_CollateralManagement_RealWord_20240826151958.log,94,CollateralManagement,8587,5106,13693,108.0,0.145055,"// SPDX-License-Identifier: MIT OR Apache-2.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol"";

import ""../mixins/roles/AdminRole.sol"";

/**
 * @title Enables deposits and withdrawals.
 */
abstract contract CollateralManagement is AdminRole {
  using AddressUpgradeable for address payable;

  event FundsWithdrawn(address indexed to, uint256 amount);

  /**
   * @notice Accept native currency payments (i.e. fees)
   */
  // solhint-disable-next-line no-empty-blocks
  receive() external payable {}

  /**
   * @notice Allows an admin to withdraw funds.
   * @dev    In normal operation only ETH is required, but this allows access to any
   *         ERC-20 funds sent to the contract as well.
   *
   * @param to        Address to receive the withdrawn funds
   * @param amount    Amount to withdrawal or 0 to withdraw all available funds
   */
  function withdrawFunds(address payable to, uint256 amount) external onlyAdmin {
    if (amount == 0) {
      amount = address(this).balance;
    }
    to.sendValue(amount);

    emit FundsWithdrawn(to, amount);
  }

  /**
   * @notice This empty reserved space is put in place to allow future versions to add new
   * variables without shifting down storage in the inheritance chain.
   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps
   */
  uint256[1000] private __gap;
}",334
RealWorld_BA_94_NFTMarketCore_RealWord_20240826150500.log,94,NFTMarketCore,23239,6102,29341,96.0,0.238235,"// SPDX-License-Identifier: MIT OR Apache-2.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/token/ERC721/IERC721.sol"";
import ""@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol"";

import ""./Constants.sol"";

import ""../interfaces/IFethMarket.sol"";

error NFTMarketCore_FETH_Address_Is_Not_A_Contract();
error NFTMarketCore_Only_FETH_Can_Transfer_ETH();

/**
 * @title A place for common modifiers and functions used by various NFTMarket mixins, if any.
 * @dev This also leaves a gap which can be used to add a new mixin to the top of the inheritance tree.
 */
abstract contract NFTMarketCore is Constants {
  using AddressUpgradeable for address;

  /// @notice The FETH ERC-20 token for managing escrow and lockup.
  IFethMarket internal immutable feth;

  constructor(address _feth) {
    if (!_feth.isContract()) {
      revert NFTMarketCore_FETH_Address_Is_Not_A_Contract();
    }
    feth = IFethMarket(_feth);
  }

  /**
   * @notice Only used by FETH. Any direct transfer from users will revert.
   */
  receive() external payable {
    if (msg.sender != address(feth)) {
      revert NFTMarketCore_Only_FETH_Can_Transfer_ETH();
    }
  }

  /**
   * @notice Notify implementors when an auction has received its first bid.
   * Once a bid is received the sale is guaranteed to the auction winner
   * and other sale mechanisms become unavailable.
   * @dev Implementors of this interface should update internal state to reflect an auction has been kicked off.
   */
  function _afterAuctionStarted(
    address, /*nftContract*/
    uint256 /*tokenId*/ // solhint-disable-next-line no-empty-blocks
  ) internal virtual {
    // No-op
  }

  /**
   * @notice If there is a buy price at this amount or lower, accept that and return true.
   */
  function _autoAcceptBuyPrice(
    address nftContract,
    uint256 tokenId,
    uint256 amount
  ) internal virtual returns (bool);

  /**
   * @notice If there is a valid offer at the given price or higher, accept that and return true.
   */
  function _autoAcceptOffer(
    address nftContract,
    uint256 tokenId,
    uint256 minAmount
  ) internal virtual returns (bool);

  /**
   * @notice Cancel the buyer's offer if there is one in order to free up their FETH balance.
   */
  function _cancelBuyersOffer(address nftContract, uint256 tokenId) internal virtual;

  /**
   * @notice Transfers the NFT from escrow and clears any state tracking this escrowed NFT.
   */
  function _transferFromEscrow(
    address nftContract,
    uint256 tokenId,
    address recipient,
    address /*seller*/
  ) internal virtual {
    IERC721(nftContract).transferFrom(address(this), recipient, tokenId);
  }

  /**
   * @notice Transfers the NFT from escrow unless there is another reason for it to remain in escrow.
   */
  function _transferFromEscrowIfAvailable(
    address nftContract,
    uint256 tokenId,
    address recipient
  ) internal virtual {
    IERC721(nftContract).transferFrom(address(this), recipient, tokenId);
  }

  /**
   * @notice Transfers an NFT into escrow,
   * if already there this requires the msg.sender is authorized to manage the sale of this NFT.
   */
  function _transferToEscrow(address nftContract, uint256 tokenId) internal virtual {
    IERC721(nftContract).transferFrom(msg.sender, address(this), tokenId);
  }

  /**
   * @notice Gets the FETH contract used to escrow offer funds.
   * @return fethAddress The FETH contract address.
   */
  function getFethAddress() external view returns (address fethAddress) {
    return address(feth);
  }

  /**
   * @dev Determines the minimum amount when increasing an existing offer or bid.
   */
  function _getMinIncrement(uint256 currentAmount) internal pure returns (uint256) {
    uint256 minIncrement = currentAmount * MIN_PERCENT_INCREMENT_IN_BASIS_POINTS;
    unchecked {
      minIncrement /= BASIS_POINTS;
      if (minIncrement == 0) {
        // Since minIncrement reduces from the currentAmount, this cannot overflow.
        // The next amount must be at least 1 wei greater than the current.
        return currentAmount + 1;
      }
    }

    return minIncrement + currentAmount;
  }

  /**
   * @notice Checks who the seller for an NFT is, checking escrow or return the current owner if not in escrow.
   * @dev If the NFT did not have an escrowed seller to return, fall back to return the current owner.
   */
  function _getSellerFor(address nftContract, uint256 tokenId) internal view virtual returns (address payable seller) {
    seller = payable(IERC721(nftContract).ownerOf(tokenId));
  }

  /**
   * @notice Checks if an escrowed NFT is currently in active auction.
   * @return Returns false if the auction has ended, even if it has not yet been settled.
   */
  function _isInActiveAuction(address nftContract, uint256 tokenId) internal view virtual returns (bool);

  /**
   * @notice This empty reserved space is put in place to allow future versions to add new
   * variables without shifting down storage in the inheritance chain.
   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps
   * @dev 50 slots were consumed by adding `ReentrancyGuard`.
   */
  uint256[950] private __gap;
}",1253
RealWorld_BA_94_AccountMigrationLibrary_RealWord_20240826152927.log,94,AccountMigrationLibrary,14356,5097,19453,94.0,0.17372,"// SPDX-License-Identifier: MIT OR Apache-2.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/utils/cryptography/ECDSA.sol"";
import ""@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol"";
import ""@openzeppelin/contracts/utils/Strings.sol"";

error AccountMigrationLibrary_Cannot_Migrate_Account_To_Itself();
error AccountMigrationLibrary_Signature_Verification_Failed();

/**
 * @title A library which confirms account migration signatures.
 * @notice Checks for a valid signature authorizing the migration of an account to a new address.
 * @dev This is shared by both the NFT contracts and FNDNFTMarket, and the same signature authorizes both.
 */
library AccountMigrationLibrary {
  using ECDSA for bytes;
  using SignatureChecker for address;
  using Strings for uint256;

  /**
   * @notice Confirms the msg.sender is a Foundation operator and that the signature provided is valid.
   * @param originalAddress The address of the account to be migrated.
   * @param newAddress The new address representing this account.
   * @param signature Message `I authorize Foundation to migrate my account to ${newAccount.address.toLowerCase()}`
   * signed by the original account.
   */
  function requireAuthorizedAccountMigration(
    address originalAddress,
    address newAddress,
    bytes memory signature
  ) internal view {
    if (originalAddress == newAddress) {
      revert AccountMigrationLibrary_Cannot_Migrate_Account_To_Itself();
    }
    bytes32 hash = abi
      .encodePacked(""I authorize Foundation to migrate my account to "", _toAsciiString(newAddress))
      .toEthSignedMessageHash();
    if (!originalAddress.isValidSignatureNow(hash, signature)) {
      revert AccountMigrationLibrary_Signature_Verification_Failed();
    }
  }

  /**
   * @notice Converts an address into a string.
   * @dev From https://ethereum.stackexchange.com/questions/8346/convert-address-to-string
   */
  function _toAsciiString(address x) private pure returns (string memory) {
    unchecked {
      bytes memory s = new bytes(42);
      s[0] = ""0"";
      s[1] = ""x"";
      for (uint256 i = 0; i < 20; ++i) {
        bytes1 b = bytes1(uint8(uint256(uint160(x)) / (2**(8 * (19 - i)))));
        bytes1 hi = bytes1(uint8(b) / 16);
        bytes1 lo = bytes1(uint8(b) - 16 * uint8(hi));
        s[2 * i + 2] = _char(hi);
        s[2 * i + 3] = _char(lo);
      }
      return string(s);
    }
  }

  /**
   * @notice Converts a byte to a UTF-8 character.
   */
  function _char(bytes1 b) private pure returns (bytes1 c) {
    unchecked {
      if (uint8(b) < 10) return bytes1(uint8(b) + 0x30);
      else return bytes1(uint8(b) + 0x57);
    }
  }
}",670
RealWorld_BA_94_Constants_RealWord_20240826150756.log,94,Constants,8179,3949,12128,82.0,0.119875,"// SPDX-License-Identifier: MIT OR Apache-2.0

pragma solidity ^0.8.0;

/**
 * @title Constant values shared across mixins.
 */
abstract contract Constants {
  /**
   * @notice 100% in basis points.
   */
  uint256 internal constant BASIS_POINTS = 10000;

  /**
   * @notice Cap the number of royalty recipients to 5.
   * @dev A cap is required to ensure gas costs are not too high when a sale is settled.
   */
  uint256 internal constant MAX_ROYALTY_RECIPIENTS_INDEX = 4;

  /**
   * @notice The minimum increase of 10% required when making an offer or placing a bid.
   */
  uint256 internal constant MIN_PERCENT_INCREMENT_IN_BASIS_POINTS = 1000;

  /**
   * @notice The gas limit used when making external read-only calls.
   * @dev This helps to ensure that external calls does not prevent the market from executing.
   */
  uint256 internal constant READ_ONLY_GAS_LIMIT = 40000;

  /**
   * @notice The gas limit to send ETH to multiple recipients, enough for a 5-way split.
   */
  uint256 internal constant SEND_VALUE_GAS_LIMIT_MULTIPLE_RECIPIENTS = 210000;

  /**
   * @notice The gas limit to send ETH to a single recipient, enough for a contract with a simple receiver.
   */
  uint256 internal constant SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT = 20000;
}",315
RealWorld_BA_94_MockNFT_RealWord_20240826145952.log,94,MockNFT,4788,4367,9155,76.0,0.11128,"// SPDX-License-Identifier: MIT OR Apache-2.0

pragma solidity ^0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/token/ERC721/ERC721.sol"";

contract MockNFT is Ownable, ERC721 {
  uint256 private nextTokenId;

  constructor()
    ERC721(""MockNFT"", ""mNFT"") // solhint-disable-next-line no-empty-blocks
  {}

  function mint() external onlyOwner {
    _mint(msg.sender, ++nextTokenId);
  }
}",121
RealWorld_BA_94_FETHMarketMock_RealWord_20240826145834.log,94,FETHMarketMock,8227,5072,13299,76.0,0.142575,"// SPDX-License-Identifier: MIT OR Apache-2.0

pragma solidity ^0.8.0;

import ""../interfaces/IFethMarket.sol"";

contract FETHMarketMock {
  IFethMarket public feth;

  receive() external payable {
    require(msg.sender == address(feth), ""Only receive from FETH"");
  }

  function setFeth(address _feth) public {
    feth = IFethMarket(_feth);
  }

  function marketLockupFor(address account, uint256 amount) public payable {
    feth.marketLockupFor{ value: msg.value }(account, amount);
  }

  function marketWithdrawLocked(
    address account,
    uint256 expiration,
    uint256 amount
  ) public {
    feth.marketWithdrawLocked(account, expiration, amount);
  }

  function marketWithdrawFrom(address account, uint256 amount) public {
    feth.marketWithdrawFrom(account, amount);
  }

  function marketUnlockFor(
    address account,
    uint256 expiration,
    uint256 amount
  ) public {
    feth.marketUnlockFor(account, expiration, amount);
  }

  function marketChangeLockup(
    address unlockFrom,
    uint256 unlockExpiration,
    uint256 unlockAmount,
    address depositFor,
    uint256 depositAmount
  ) external payable {
    feth.marketChangeLockup{ value: msg.value }(unlockFrom, unlockExpiration, unlockAmount, depositFor, depositAmount);
  }
}",302
RealWorld_BA_94_IGetRoyalties_RealWord_20240826153721.log,94,IGetRoyalties,4146,3957,8103,79.0,0.09987,"// SPDX-License-Identifier: MIT OR Apache-2.0

pragma solidity ^0.8.0;

interface IGetRoyalties {
  function getRoyalties(uint256 tokenId)
    external
    view
    returns (address payable[] memory recipients, uint256[] memory feesInBasisPoints);
}",63
RealWorld_BA_94_IFethMarket_RealWord_20240826154022.log,94,IFethMarket,5763,4811,10574,68.0,0.125035,"// SPDX-License-Identifier: MIT OR Apache-2.0

pragma solidity ^0.8.0;

/**
 * @notice Interface for functions the market uses in FETH.
 */
interface IFethMarket {
  function marketLockupFor(address account, uint256 amount) external payable returns (uint256 expiration);

  function marketWithdrawFrom(address from, uint256 amount) external;

  function marketWithdrawLocked(
    address account,
    uint256 expiration,
    uint256 amount
  ) external;

  function marketUnlockFor(
    address account,
    uint256 expiration,
    uint256 amount
  ) external;

  function marketChangeLockup(
    address unlockFrom,
    uint256 unlockExpiration,
    uint256 unlockAmount,
    address depositFor,
    uint256 depositAmount
  ) external payable returns (uint256 expiration);
}",171
RealWorld_BA_96_Liquidity_RealWord_20240826173134.log,96,Liquidity,11384,5628,17012,78.0,0.16948,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.4;

import {ILiquidity} from './interfaces/ILiquidity.sol';
import {IConvenience} from './interfaces/IConvenience.sol';
import {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import {IPair} from '@timeswap-labs/timeswap-v1-core/contracts/interfaces/IPair.sol';
import {ERC20Permit} from './base/ERC20Permit.sol';
import {SafeMetadata} from './libraries/SafeMetadata.sol';
import {Strings} from '@openzeppelin/contracts/utils/Strings.sol';

contract Liquidity is ILiquidity, ERC20Permit {
    using SafeMetadata for IERC20;
    using Strings for uint256;

    IConvenience public immutable override convenience;
    IPair public immutable override pair;
    uint256 public immutable override maturity;

    uint8 public constant override decimals = 18;

    function name() external view override returns (string memory) {
        string memory assetName = pair.asset().safeName();
        string memory collateralName = pair.collateral().safeName();
        return
            string(
                abi.encodePacked('Timeswap Liquidity - ', assetName, ' - ', collateralName, ' - ', maturity.toString())
            );
    }

    function symbol() external view override returns (string memory) {
        string memory assetSymbol = pair.asset().safeSymbol();
        string memory collateralSymbol = pair.collateral().safeSymbol();
        return string(abi.encodePacked('TS-LIQ-', assetSymbol, '-', collateralSymbol, '-', maturity.toString()));
    }

    function totalSupply() external view override returns (uint256) {
        return pair.liquidityOf(maturity, address(this));
    }

    constructor(
        IConvenience _convenience,
        IPair _pair,
        uint256 _maturity
    ) ERC20Permit('Timeswap Liquidity') {
        convenience = _convenience;
        pair = _pair;
        maturity = _maturity;
    }

    modifier onlyConvenience() {
        require(msg.sender == address(convenience), 'E403');
        _;
    }

    function mint(address to, uint256 amount) external override onlyConvenience {
        _mint(to, amount);
    }

    function burn(address from, uint256 amount) external override onlyConvenience {
        _burn(from, amount);
    }
}",506
RealWorld_BA_96_DaiTestToken_RealWord_20240826174945.log,96,DaiTestToken,10603,5003,15606,70.0,0.153075,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.4;

contract DaiTestToken {
    // MODEL

    string public constant name = 'DAI TEST TOKEN';
    string public constant symbol = 'DAI';
    uint8 public immutable decimals = 18;

    address private constant ZERO = address(type(uint160).min);

    uint256 public totalSupply;
    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    // EVENT

    event Approval(address indexed _owner, address indexed _spender, uint256 _value);

    event Transfer(address indexed _from, address indexed _to, uint256 _value);

    // UPDATE

    function approve(address _spender, uint256 _value) external returns (bool) {
        _approve(msg.sender, _spender, _value);
        return true;
    }

    function transfer(address _to, uint256 _value) external returns (bool) {
        _transfer(msg.sender, _to, _value);
        return true;
    }

    function transferFrom(
        address _from,
        address _to,
        uint256 _value
    ) external returns (bool) {
        if (msg.sender != _from && allowance[_from][msg.sender] != type(uint256).max) {
            allowance[_from][msg.sender] -= _value;

            emit Approval(_from, msg.sender, allowance[_from][msg.sender]);
        }
        _transfer(_from, _to, _value);
        return true;
    }

    function mint(address _to, uint256 _value) external {
        totalSupply += _value;
        balanceOf[_to] += _value;
        emit Transfer(ZERO, _to, _value);
    }

    // HELPER

    function _approve(
        address _owner,
        address _spender,
        uint256 _value
    ) private {
        allowance[_owner][_spender] = _value;
        emit Approval(_owner, _spender, _value);
    }

    function _transfer(
        address _from,
        address _to,
        uint256 _value
    ) private {
        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(_from, _to, _value);
    }
}",478
RealWorld_BA_96_TimeswapFactory_RealWord_20240826170400.log,96,TimeswapFactory,12502,5312,17814,80.0,0.16875,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.4;

import {IFactory} from './interfaces/IFactory.sol';
import {IPair} from './interfaces/IPair.sol';
import {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import {TimeswapPair} from './TimeswapPair.sol';

/// @title Timeswap Factory
/// @author Timeswap Labs
/// @notice It is recommended to use Timeswap Convenience to interact with this contract.
/// @notice All error messages are coded and can be found in the documentation.
contract TimeswapFactory is IFactory {
    /* ===== MODEL ===== */

    /// @inheritdoc IFactory
    address public override owner;
    /// @inheritdoc IFactory
    address public override pendingOwner;
    /// @inheritdoc IFactory
    uint16 public immutable override fee;
    /// @inheritdoc IFactory
    uint16 public immutable override protocolFee;

    /// @inheritdoc IFactory
    mapping(IERC20 => mapping(IERC20 => IPair)) public override getPair;

    /* ===== INIT ===== */

    /// @param _owner The chosen owner address.
    /// @param _fee The chosen fee rate.
    /// @param _protocolFee The chosen protocol fee rate.
    constructor(
        address _owner,
        uint16 _fee,
        uint16 _protocolFee
    ) {
        require(_owner != address(0), 'E101');
        owner = _owner;
        fee = _fee;
        protocolFee = _protocolFee;
    }

    /* ===== UPDATE ===== */

    /// @inheritdoc IFactory
    function createPair(IERC20 asset, IERC20 collateral) external override returns (IPair pair) {
        require(asset != collateral, 'E103');
        require(asset != IERC20(address(0)) && collateral != IERC20(address(0)), 'E101');
        require(getPair[asset][collateral] == IPair(address(0)), 'E104');

        pair = new TimeswapPair{salt: keccak256(abi.encode(asset, collateral))}(asset, collateral, fee, protocolFee);

        getPair[asset][collateral] = pair;

        emit CreatePair(asset, collateral, pair);
    }

    /// @inheritdoc IFactory
    function setOwner(address _pendingOwner) external override {
        require(msg.sender == owner, 'E102');
        require(_pendingOwner != address(0), 'E101');
        pendingOwner = _pendingOwner;

        emit SetOwner(_pendingOwner);
    }

    /// @inheritdoc IFactory
    function acceptOwner() external override {
        require(msg.sender == pendingOwner, 'E102');
        owner = msg.sender;
        pendingOwner = address(0);

        emit AcceptOwner(msg.sender);
    }
}",581
RealWorld_BA_96_WETH9_RealWord_20240826174657.log,96,WETH9,10867,5992,16859,90.0,0.174175,"pragma solidity >= 0.8.1;

contract WETH9 {
    string public name     = ""Wrapped Ether"";
    string public symbol   = ""WETH"";
    uint8  public decimals = 18;

    event  Approval(address indexed src, address indexed guy, uint wad);
    event  Transfer(address indexed src, address indexed dst, uint wad);
    event  Deposit(address indexed dst, uint wad);
    event  Withdrawal(address indexed src, uint wad);

    mapping (address => uint)                       public  balanceOf;
    mapping (address => mapping (address => uint))  public  allowance;

    receive() external payable {
        deposit();
    }
    fallback() external payable {
        deposit();
    }
    function deposit() public payable {
        balanceOf[msg.sender] += msg.value;
        emit Deposit(msg.sender, msg.value);
    }
    function withdraw(uint wad) public {
        require(balanceOf[msg.sender] >= wad);
        balanceOf[msg.sender] -= wad;
        payable(msg.sender).transfer(wad);
        emit Withdrawal(msg.sender, wad);
    }

    function totalSupply() public view returns (uint) {
        return address(this).balance;
    }

    function approve(address guy, uint wad) public returns (bool) {
        allowance[msg.sender][guy] = wad;
        emit Approval(msg.sender, guy, wad);
        return true;
    }

    function transfer(address dst, uint wad) public returns (bool) {
        return transferFrom(msg.sender, dst, wad);
    }

    function transferFrom(address src, address dst, uint wad)
        public
        returns (bool)
    {
        require(balanceOf[src] >= wad);

        if (src != msg.sender && allowance[src][msg.sender] != type(uint256).max) {
            require(allowance[src][msg.sender] >= wad);
            allowance[src][msg.sender] -= wad;
        }

        balanceOf[src] -= wad;
        balanceOf[dst] += wad;

        emit Transfer(src, dst, wad);

        return true;
    }
}",447
RealWorld_BA_96_Array_RealWord_20240826170909.log,96,Array,3974,3940,7914,60.0,0.09867,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.4;

import {IPair} from '../interfaces/IPair.sol';

library Array {
    function insert(IPair.Due[] storage dues, IPair.Due memory dueOut) internal returns (uint256 id) {
        id = dues.length;   
        
        dues.push(dueOut);
        
    }
}",77
RealWorld_BA_96_TimeswapPair_RealWord_20240826170222.log,96,TimeswapPair,64039,5654,69693,96.0,0.433275,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.4;

import {IPair} from './interfaces/IPair.sol';
import {IFactory} from './interfaces/IFactory.sol';
import {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import {TimeswapMath} from './libraries/TimeswapMath.sol';
import {SafeERC20} from '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';
import {Array} from './libraries/Array.sol';
import {Callback} from './libraries/Callback.sol';
import {BlockNumber} from './libraries/BlockNumber.sol';

/// @title Timeswap Pair
/// @author Timeswap Labs
/// @notice It is recommended to use Timeswap Convenience to interact with this contract.
/// @notice All error messages are coded and can be found in the documentation.
contract TimeswapPair is IPair {
    using SafeERC20 for IERC20;
    using Array for Due[];

    /* ===== MODEL ===== */

    /// @inheritdoc IPair
    IFactory public immutable override factory;
    /// @inheritdoc IPair
    IERC20 public immutable override asset;
    /// @inheritdoc IPair
    IERC20 public immutable override collateral;
    /// @inheritdoc IPair
    uint16 public immutable override fee;
    /// @inheritdoc IPair
    uint16 public immutable override protocolFee;

    /// @inheritdoc IPair
    uint256 public override protocolFeeStored;

    /// @dev Stores the individual states of each Pool.
    mapping(uint256 => Pool) private pools;

    /// @dev Stores the access state for reentrancy guard.
    uint256 private locked = 1;

    /* ===== VIEW =====*/

    /// @inheritdoc IPair
    function feeStored(uint256 maturity)
        external
        view
        override
        returns (uint256) 
    {
        return pools[maturity].state.feeStored;
    }

    /// @inheritdoc IPair
    function constantProduct(uint256 maturity)
        external
        view
        override
        returns (uint112, uint112, uint112)
    {
        State storage state = pools[maturity].state;
        return (state.x, state.y, state.z);
    }

    /// @inheritdoc IPair
    function totalReserves(uint256 maturity) external view override returns (Tokens memory) {
        return pools[maturity].state.reserves;
    }

    /// @inheritdoc IPair
    function totalLiquidity(uint256 maturity) external view override returns (uint256) {
        return pools[maturity].state.totalLiquidity;
    }

    /// @inheritdoc IPair
    function liquidityOf(uint256 maturity, address owner) external view override returns (uint256) {
        return pools[maturity].liquidities[owner];
    }

    /// @inheritdoc IPair
    function totalClaims(uint256 maturity) external view override returns (Claims memory) {
        return pools[maturity].state.totalClaims;
    }

    /// @inheritdoc IPair
    function claimsOf(uint256 maturity, address owner) external view override returns (Claims memory) {
        return pools[maturity].claims[owner];
    }

    /// @inheritdoc IPair
    function totalDebtCreated(uint256 maturity) external view override returns (uint120) {
        return pools[maturity].state.totalDebtCreated;
    }

    /// @inheritdoc IPair
    function totalDuesOf(uint256 maturity, address owner) external view override returns (uint256) {
        return pools[maturity].dues[owner].length;
    }

    /// @inheritdoc IPair
    function dueOf(uint256 maturity, address owner, uint256 id) external view override returns (Due memory) {
        return pools[maturity].dues[owner][id];
    }

    /* ===== INIT ===== */

    /// @dev Initializes the Pair contract.
    /// @dev Called by the Timeswap factory contract.
    /// @param _asset The address of the ERC20 being lent and borrowed.
    /// @param _collateral The address of the ERC20 as the collateral.
    /// @param _fee The chosen fee rate.
    /// @param _protocolFee The chosen protocol fee rate.
    constructor(
        IERC20 _asset,
        IERC20 _collateral,
        uint16 _fee,
        uint16 _protocolFee
    ) {
        factory = IFactory(msg.sender);
        asset = _asset;
        collateral = _collateral;
        fee = _fee;
        protocolFee = _protocolFee;
    }

    /* ===== MODIFIER ===== */

    /// @dev The modifier for reentrancy guard.
    modifier lock() {
        require(locked == 1, 'E211');
        locked = 2;
        _;
        locked = 1;
    }

    /* ===== UPDATE ===== */

    /// @inheritdoc IPair
    function mint(MintParam calldata param)
        external
        override
        lock
        returns (
            uint256 assetIn,
            uint256 liquidityOut,
            uint256 id,
            Due memory dueOut
        )
    {   
        require(block.timestamp < param.maturity, 'E202');
        unchecked { require(param.maturity - block.timestamp < 0x100000000, 'E208'); }
        require(param.liquidityTo != address(0), 'E201');
        require(param.dueTo != address(0), 'E201');
        require(param.liquidityTo != address(this), 'E204');
        require(param.dueTo != address(this), 'E204');
        require(param.xIncrease != 0, 'E205');
        require(param.yIncrease != 0, 'E205');
        require(param.zIncrease != 0, 'E205');
        
        Pool storage pool = pools[param.maturity];

        uint256 feeStoredIncrease;
        (liquidityOut, dueOut, feeStoredIncrease) = TimeswapMath.mint(
            param.maturity,
            pool.state,
            param.xIncrease,
            param.yIncrease,
            param.zIncrease
        );

        require(liquidityOut != 0, 'E212');
        pool.state.totalLiquidity += liquidityOut;
        pool.liquidities[param.liquidityTo] += liquidityOut;

        pool.state.feeStored += feeStoredIncrease;


        id = pool.dues[param.dueTo].insert(dueOut);

        pool.state.reserves.asset += param.xIncrease;
        pool.state.reserves.collateral += dueOut.collateral;
        pool.state.totalDebtCreated += dueOut.debt;

        pool.state.x += param.xIncrease;
        pool.state.y += param.yIncrease;
        pool.state.z += param.zIncrease;

        assetIn = param.xIncrease;
        assetIn += feeStoredIncrease;
        Callback.mint(asset, collateral, assetIn, dueOut.collateral, param.data);

        emit Sync(param.maturity, pool.state.x, pool.state.y, pool.state.z);
        emit Mint(
            param.maturity, 
            msg.sender, 
            param.liquidityTo, 
            param.dueTo, 
            assetIn, 
            liquidityOut, 
            id, 
            dueOut,
            feeStoredIncrease
        );
    }

    /// @inheritdoc IPair
    function burn(BurnParam calldata param) 
        external 
        override 
        lock 
        returns (
            uint256 assetOut, 
            uint128 collateralOut
        ) 
    {
        require(block.timestamp >= param.maturity, 'E203');
        require(param.assetTo != address(0), 'E201');
        require(param.collateralTo != address(0), 'E201');
        require(param.assetTo != address(this), 'E204');
        require(param.collateralTo != address(this), 'E204');
        require(param.liquidityIn != 0, 'E205');

        Pool storage pool = pools[param.maturity];
        require(pool.state.totalLiquidity > 0, 'E206');

        uint128 _assetOut;
        uint256 feeOut;
        (_assetOut, collateralOut, feeOut) = TimeswapMath.burn(
            pool.state,
            param.liquidityIn
        );

        pool.state.totalLiquidity -= param.liquidityIn;

        pool.liquidities[msg.sender] -= param.liquidityIn;

        assetOut = _assetOut;
        assetOut += feeOut;

        if (assetOut != 0) {
            pool.state.reserves.asset -= _assetOut;
            pool.state.feeStored -= feeOut;
            asset.safeTransfer(param.assetTo, assetOut);
        }
        if (collateralOut != 0) {
            pool.state.reserves.collateral -= collateralOut;
            collateral.safeTransfer(param.collateralTo, collateralOut);
        }

        emit Burn(
            param.maturity,
            msg.sender, 
            param.assetTo, 
            param.collateralTo, 
            param.liquidityIn, 
            assetOut, 
            collateralOut,
            feeOut
        );
    }

    /// @inheritdoc IPair
    function lend(LendParam calldata param) 
        external 
        override 
        lock 
        returns (
            uint256 assetIn,
            Claims memory claimsOut
        ) 
    {
        require(block.timestamp < param.maturity, 'E202');
        require(param.bondTo != address(0), 'E201');
        require(param.insuranceTo != address(0), 'E201');
        require(param.bondTo != address(this), 'E204');
        require(param.insuranceTo != address(this), 'E204');
        require(param.xIncrease != 0, 'E205');

        Pool storage pool = pools[param.maturity];
        require(pool.state.totalLiquidity != 0, 'E206');

        uint256 feeStoredIncrease;
        uint256 protocolFeeStoredIncrease;
        (claimsOut, feeStoredIncrease, protocolFeeStoredIncrease) = TimeswapMath.lend(
            param.maturity,
            pool.state,
            param.xIncrease,
            param.yDecrease,
            param.zDecrease,
            fee,
            protocolFee
        );

        pool.state.feeStored += feeStoredIncrease;
        protocolFeeStored += protocolFeeStoredIncrease;

        pool.state.totalClaims.bondPrincipal += claimsOut.bondPrincipal;
        pool.state.totalClaims.bondInterest += claimsOut.bondInterest;
        pool.state.totalClaims.insurancePrincipal += claimsOut.insurancePrincipal;
        pool.state.totalClaims.insuranceInterest += claimsOut.insuranceInterest;

        pool.claims[param.bondTo].bondPrincipal += claimsOut.bondPrincipal;
        pool.claims[param.bondTo].bondInterest += claimsOut.bondInterest;
        pool.claims[param.insuranceTo].insurancePrincipal += claimsOut.insurancePrincipal;
        pool.claims[param.insuranceTo].insuranceInterest += claimsOut.insuranceInterest;

        pool.state.reserves.asset += param.xIncrease;

        pool.state.x += param.xIncrease;
        pool.state.y -= param.yDecrease;
        pool.state.z -= param.zDecrease;

        assetIn = param.xIncrease;
        assetIn += feeStoredIncrease;
        assetIn += protocolFeeStoredIncrease;

        Callback.lend(asset, assetIn, param.data);

        emit Sync(param.maturity, pool.state.x, pool.state.y, pool.state.z);
        emit Lend(
            param.maturity,
            msg.sender, 
            param.bondTo, 
            param.insuranceTo, 
            assetIn, 
            claimsOut,
            feeStoredIncrease,
            protocolFeeStoredIncrease
        );
    }

    /// @inheritdoc IPair
    function withdraw(WithdrawParam calldata param)
        external 
        override 
        lock 
        returns (
            Tokens memory tokensOut
        ) 
    {
        require(block.timestamp >= param.maturity, 'E203');
        require(param.assetTo != address(0), 'E201');
        require(param.collateralTo != address(0), 'E201');
        require(param.assetTo != address(this), 'E204');
        require(param.collateralTo != address(this), 'E204');
        require(
            param.claimsIn.bondPrincipal != 0 || 
            param.claimsIn.bondInterest != 0 ||
            param.claimsIn.insurancePrincipal != 0 ||
            param.claimsIn.insuranceInterest != 0, 
            'E205'
        );

        Pool storage pool = pools[param.maturity];

        tokensOut = TimeswapMath.withdraw(pool.state, param.claimsIn);

        pool.state.totalClaims.bondPrincipal -= param.claimsIn.bondPrincipal;
        pool.state.totalClaims.bondInterest -= param.claimsIn.bondInterest;
        pool.state.totalClaims.insurancePrincipal -= param.claimsIn.insurancePrincipal;
        pool.state.totalClaims.insuranceInterest -= param.claimsIn.insuranceInterest;

        Claims storage sender = pool.claims[msg.sender];

        sender.bondPrincipal -= param.claimsIn.bondPrincipal;
        sender.bondInterest -= param.claimsIn.bondInterest;
        sender.insurancePrincipal -= param.claimsIn.insurancePrincipal;
        sender.insuranceInterest -= param.claimsIn.insuranceInterest;

        if (tokensOut.asset != 0) {
            pool.state.reserves.asset -= tokensOut.asset;
            asset.safeTransfer(param.assetTo, tokensOut.asset);
        }
        if (tokensOut.collateral != 0) {
            pool.state.reserves.collateral -= tokensOut.collateral;
            collateral.safeTransfer(param.collateralTo, tokensOut.collateral);
        }

        emit Withdraw(
            param.maturity,
            msg.sender, 
            param.assetTo, 
            param.collateralTo, 
            param.claimsIn, 
            tokensOut
        );
    }

    /// @inheritdoc IPair
    function borrow(BorrowParam calldata param)
        external 
        override 
        lock 
        returns (
            uint256 assetOut,
            uint256 id, 
            Due memory dueOut
        ) 
    {
        require(block.timestamp < param.maturity, 'E202');
        require(param.assetTo != address(0), 'E201');
        require(param.dueTo != address(0), 'E201');
        require(param.assetTo != address(this), 'E204');
        require(param.dueTo != address(this), 'E204');
        require(param.xDecrease != 0, 'E205');

        Pool storage pool = pools[param.maturity];
        require(pool.state.totalLiquidity != 0, 'E206');

        uint256 feeStoredIncrease;
        uint256 protocolFeeStoredIncrease;
        (dueOut, feeStoredIncrease, protocolFeeStoredIncrease) = TimeswapMath.borrow(
            param.maturity,
            pool.state,
            param.xDecrease,
            param.yIncrease,
            param.zIncrease,
            fee,
            protocolFee
        );

        pool.state.feeStored += feeStoredIncrease;
        protocolFeeStored += protocolFeeStoredIncrease;

        id = pool.dues[param.dueTo].insert(dueOut);

        pool.state.reserves.asset -= param.xDecrease;
        pool.state.reserves.collateral += dueOut.collateral;
        pool.state.totalDebtCreated += dueOut.debt;

        pool.state.x -= param.xDecrease;
        pool.state.y += param.yIncrease;
        pool.state.z += param.zIncrease;

        assetOut = param.xDecrease;
        assetOut -= feeStoredIncrease;
        assetOut -= protocolFeeStoredIncrease;

        asset.safeTransfer(param.assetTo, assetOut);

        Callback.borrow(collateral, dueOut.collateral, param.data);

        emit Sync(param.maturity, pool.state.x, pool.state.y, pool.state.z);
        emit Borrow(
            param.maturity, 
            msg.sender, 
            param.assetTo, 
            param.dueTo, 
            assetOut, 
            id, 
            dueOut,
            feeStoredIncrease,
            protocolFeeStoredIncrease
        );
    }

    /// @inheritdoc IPair
    function pay(PayParam calldata param)
        external 
        override 
        lock 
        returns (
            uint128 assetIn, 
            uint128 collateralOut
        ) 
    {
        require(block.timestamp < param.maturity, 'E202');
        require(param.owner != address(0), 'E201');
        require(param.to != address(0), 'E201');
        require(param.to != address(this), 'E204');
        require(param.ids.length == param.assetsIn.length, 'E205');
        require(param.ids.length == param.collateralsOut.length, 'E205');

        Pool storage pool = pools[param.maturity];

        Due[] storage dues = pool.dues[param.owner];
        require(dues.length >= param.ids.length, 'E205');

        for (uint256 i; i < param.ids.length;) {
            Due storage due = dues[param.ids[i]];
            require(due.startBlock != BlockNumber.get(), 'E207');
            if (param.owner != msg.sender) require(param.collateralsOut[i] == 0, 'E213');
            require(uint256(assetIn) * due.collateral >= uint256(collateralOut) * due.debt, 'E303');
            due.debt -= param.assetsIn[i];
            due.collateral -= param.collateralsOut[i];
            assetIn += param.assetsIn[i];
            collateralOut += param.collateralsOut[i];
            unchecked { ++i; }
        }

        pool.state.reserves.asset += assetIn;
        pool.state.reserves.collateral -= collateralOut;

        if (collateralOut != 0) collateral.safeTransfer(param.to, collateralOut);

        if (assetIn != 0) Callback.pay(asset, assetIn, param.data);

        emit Pay(
            param.maturity, 
            msg.sender, 
            param.to, 
            param.owner, 
            param.ids, 
            param.assetsIn, 
            param.collateralsOut, 
            assetIn, 
            collateralOut
        );
    }

    /// @inheritdoc IPair
    function collectProtocolFee(address to) external override lock returns (uint256 protocolFeeOut) {
        require(msg.sender == factory.owner(), 'E216');

        protocolFeeOut = protocolFeeStored;
        protocolFeeStored = 0;

        asset.safeTransfer(to, protocolFeeOut);

        emit CollectProtocolFee(msg.sender, to, protocolFeeOut);
    }
}",3829
RealWorld_BA_96_IBorrow_RealWord_20240826185455.log,96,IBorrow,17831,5520,23351,82.0,0.199555,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.4;

import {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import {IConvenience} from '../interfaces/IConvenience.sol';
import {IFactory} from '@timeswap-labs/timeswap-v1-core/contracts/interfaces/IFactory.sol';
import {IPair} from '@timeswap-labs/timeswap-v1-core/contracts/interfaces/IPair.sol';

interface IBorrow {
    struct BorrowGivenDebt {
        IERC20 asset;
        IERC20 collateral;
        uint256 maturity;
        address assetTo;
        address dueTo;
        uint112 assetOut;
        uint112 debtIn;
        uint112 maxCollateral;
        uint256 deadline;
    }

    struct BorrowGivenDebtETHAsset {
        IERC20 collateral;
        uint256 maturity;
        address payable assetTo;
        address dueTo;
        uint112 assetOut;
        uint112 debtIn;
        uint112 maxCollateral;
        uint256 deadline;
    }

    struct BorrowGivenDebtETHCollateral {
        IERC20 asset;
        uint256 maturity;
        address assetTo;
        address dueTo;
        uint112 assetOut;
        uint112 debtIn;
        uint256 deadline;
    }

    struct _BorrowGivenDebt {
        IConvenience convenience;
        IFactory factory;
        IERC20 asset;
        IERC20 collateral;
        uint256 maturity;
        address from;
        address assetTo;
        address dueTo;
        uint112 assetOut;
        uint112 debtIn;
        uint112 maxCollateral;
        uint256 deadline;
    }
    struct BorrowGivenCollateral {
        IERC20 asset;
        IERC20 collateral;
        uint256 maturity;
        address assetTo;
        address dueTo;
        uint112 assetOut;
        uint112 collateralIn;
        uint112 maxDebt;
        uint256 deadline;
    }

    struct BorrowGivenCollateralETHAsset {
        IERC20 collateral;
        uint256 maturity;
        address payable assetTo;
        address dueTo;
        uint112 assetOut;
        uint112 collateralIn;
        uint112 maxDebt;
        uint256 deadline;
    }

    struct BorrowGivenCollateralETHCollateral {
        IERC20 asset;
        uint256 maturity;
        address assetTo;
        address dueTo;
        uint112 assetOut;
        uint112 maxDebt;
        uint256 deadline;
    }

    struct _BorrowGivenCollateral {
        IConvenience convenience;
        IFactory factory;
        IERC20 asset;
        IERC20 collateral;
        uint256 maturity;
        address from;
        address assetTo;
        address dueTo;
        uint112 assetOut;
        uint112 collateralIn;
        uint112 maxDebt;
        uint256 deadline;
    }

    struct BorrowGivenPercent {
        IERC20 asset;
        IERC20 collateral;
        uint256 maturity;
        address assetTo;
        address dueTo;
        uint112 assetOut;
        uint40 percent;
        uint112 maxDebt;
        uint112 maxCollateral;
        uint256 deadline;
    }

    struct BorrowGivenPercentETHAsset {
        IERC20 collateral;
        uint256 maturity;
        address payable assetTo;
        address dueTo;
        uint112 assetOut;
        uint40 percent;
        uint112 maxDebt;
        uint112 maxCollateral;
        uint256 deadline;
    }

    struct BorrowGivenPercentETHCollateral {
        IERC20 asset;
        uint256 maturity;
        address assetTo;
        address dueTo;
        uint112 assetOut;
        uint40 percent;
        uint112 maxDebt;
        uint256 deadline;
    }

    struct _BorrowGivenPercent {
        IConvenience convenience;
        IFactory factory;
        IERC20 asset;
        IERC20 collateral;
        uint256 maturity;
        address from;
        address assetTo;
        address dueTo;
        uint112 assetOut;
        uint40 percent;
        uint112 maxDebt;
        uint112 maxCollateral;
        uint256 deadline;
    }

    struct _Borrow {
        IConvenience convenience;
        IPair pair;
        IERC20 asset;
        IERC20 collateral;
        uint256 maturity;
        address from;
        address assetTo;
        address dueTo;
        uint112 xDecrease;
        uint112 yIncrease;
        uint112 zIncrease;
        uint256 deadline;
    }
}",934
RealWorld_BA_96_LendMathCallee_RealWord_20240826174046.log,96,LendMathCallee,7923,5581,13504,79.0,0.151235,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.4;

import {LendMath} from '../libraries/LendMath.sol';
import {IPair} from '@timeswap-labs/timeswap-v1-core/contracts/interfaces/IPair.sol';

contract LendMathCallee {
    function givenBond(
        IPair pair,
        uint256 maturity,
        uint112 assetIn,
        uint128 bondOut
    )
        public
        view
        returns (
            uint256,
            uint112,
            uint112
        )
    {
        return LendMath.givenBond(pair, maturity, assetIn, bondOut);
    }

    function givenInsurance(
        IPair pair,
        uint256 maturity,
        uint112 assetIn,
        uint128 insuranceOut
    )
        public
        view
        returns (
            uint256,
            uint112,
            uint112
        )
    {
        return LendMath.givenInsurance(pair, maturity, assetIn, insuranceOut);
    }

    function givenPercent(
        IPair pair,
        uint256 maturity,
        uint112 assetIn,
        uint40 percent
    )
        public
        view
        returns (
            uint256,
            uint112,
            uint112
        )
    {
        return LendMath.givenPercent(pair, maturity, assetIn, percent);
    }
}",282
RealWorld_BA_96_MintMathCallee_RealWord_20240826173932.log,96,MintMathCallee,8455,5076,13531,71.0,0.143795,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.4;

import {MintMath} from '../libraries/MintMath.sol';
import {IPair} from '@timeswap-labs/timeswap-v1-core/contracts/interfaces/IPair.sol';

contract MintMathCallee {
    function givenNew(
        uint256 maturity,
        uint112 assetIn,
        uint112 debtIn,
        uint112 collateralIn
    )
        public
        view
        returns (
            uint256,
            uint112,
            uint112
        )
    {
        return MintMath.givenNew(maturity, assetIn, debtIn, collateralIn);
    }

    function givenAsset(
        IPair pair,
        uint256 maturity,
        uint112 assetIn
    )
        public
        view
        returns (
            uint256,
            uint112,
            uint112
        )
    {
        return MintMath.givenAsset(pair, maturity, assetIn);
    }

    function givenDebt(
        IPair pair,
        uint256 maturity,
        uint112 debtIn
    )
        public
        view
        returns (
            uint256,
            uint112,
            uint112
        )
    {
        return MintMath.givenDebt(pair, maturity, debtIn);
    }

    function givenCollateral(
        IPair pair,
        uint256 maturity,
        uint112 collateralIn
    )
        public
        view
        returns (
            uint256,
            uint112,
            uint112
        )
    {
        return MintMath.givenCollateral(pair, maturity, collateralIn);
    }
}",333
RealWorld_BA_96_ETH_RealWord_20240826180230.log,96,ETH,3742,3474,7216,55.0,0.08819,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.4;

library ETH {
    function transfer(address payable to, uint256 amount) internal {
        (bool success, ) = to.call{value: amount}('');
        require(success, 'E521');
    }
}",58
RealWorld_BA_96_IERC20Permit_RealWord_20240826183842.log,96,IERC20Permit,10485,5258,15743,89.0,0.157585,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.4;

import {IERC20Metadata} from '@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol';

interface IERC20Permit is IERC20Metadata {
    /**
     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,
     * given ``owner``'s signed approval.
     *
     * IMPORTANT: The same issues {IERC20-approve} has related to transaction
     * ordering also apply here.
     *
     * Emits an {Approval} event.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     * - `deadline` must be a timestamp in the future.
     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`
     * over the EIP712-formatted function arguments.
     * - the signature must use ``owner``'s current nonce (see {nonces}).
     *
     * For more information on the signature format, see the
     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP
     * section].
     */
    function permit(
        address owner,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external;

    /**
     * @dev Returns the current nonce for `owner`. This value must be
     * included whenever a signature is generated for {permit}.
     *
     * Every successful call to {permit} increases ``owner``'s nonce by one. This
     * prevents a signature from being used multiple times.
     */
    function nonces(address owner) external view returns (uint256);

    /**
     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.
     */
    // solhint-disable-next-line func-name-mixedcase
    function DOMAIN_SEPARATOR() external view returns (bytes32);
    }",451
RealWorld_BA_96_DateTimeCallee_RealWord_20240826174447.log,96,DateTimeCallee,4501,3403,7904,54.0,0.090565,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.4;

import {DateTime} from '../libraries/DateTime.sol';

contract DateTimeCallee {
    function timestampToDateTime(uint256 timestamp)
        public
        pure
        returns (
            uint256 year,
            uint256 month,
            uint256 day,
            uint256 hour,
            uint256 minute,
            uint256 second
        )
    {
        return DateTime.timestampToDateTime(timestamp);
    }
}",95
RealWorld_BA_96_IClaim_RealWord_20240826184140.log,96,IClaim,5630,4847,10477,71.0,0.12509,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.4;

import {IERC20Permit} from './IERC20Permit.sol';
import {IConvenience} from './IConvenience.sol';
import {IPair} from '@timeswap-labs/timeswap-v1-core/contracts/interfaces/IPair.sol';

/// @author Ricsson W. Ngo
interface IClaim is IERC20Permit {
    // VIEW

    function convenience() external returns (IConvenience);

    function pair() external returns (IPair);

    function maturity() external returns (uint256);

    // UPDATE

    function mint(address to, uint128 amount) external;

    function burn(address from, uint128 amount) external;
}",154
RealWorld_BA_96_DeployInsurances_RealWord_20240826182230.log,96,DeployInsurances,5766,4953,10719,72.0,0.12789,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.4;

import {IConvenience} from '../interfaces/IConvenience.sol';
import {IPair} from '@timeswap-labs/timeswap-v1-core/contracts/interfaces/IPair.sol';
import {InsuranceInterest} from '../InsuranceInterest.sol';
import {InsurancePrincipal} from '../InsurancePrincipal.sol';

library DeployInsurances {
    function deployInsurances(
        IConvenience.Native storage native,
        bytes32 salt,
        IConvenience convenience,
        IPair pair,
        uint256 maturity
    ) external {
        
        native.insuranceInterest = new InsuranceInterest{salt: salt}(convenience, pair, maturity);
        native.insurancePrincipal = new InsurancePrincipal{salt: salt}(convenience, pair, maturity);
    }
}",166
RealWorld_BA_96_IConvenience_RealWord_20240826185311.log,96,IConvenience,112502,5578,118080,102.0,0.67407,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.4;

import {IFactory} from '@timeswap-labs/timeswap-v1-core/contracts/interfaces/IFactory.sol';
import {IPair} from '@timeswap-labs/timeswap-v1-core/contracts/interfaces/IPair.sol';
import {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import {IMint} from './IMint.sol';
import {IBurn} from './IBurn.sol';
import {ILend} from './ILend.sol';
import {IWithdraw} from './IWithdraw.sol';
import {IBorrow} from './IBorrow.sol';
import {IPay} from './IPay.sol';
import {ILiquidity} from './ILiquidity.sol';
import {IClaim} from './IClaim.sol';
import {IDue} from './IDue.sol';
import {IWETH} from './IWETH.sol';
import {ITimeswapMintCallback} from '@timeswap-labs/timeswap-v1-core/contracts/interfaces/callback/ITimeswapMintCallback.sol';
import {ITimeswapLendCallback} from '@timeswap-labs/timeswap-v1-core/contracts/interfaces/callback/ITimeswapLendCallback.sol';
import {ITimeswapBorrowCallback} from '@timeswap-labs/timeswap-v1-core/contracts/interfaces/callback/ITimeswapBorrowCallback.sol';
import {ITimeswapPayCallback} from '@timeswap-labs/timeswap-v1-core/contracts/interfaces/callback/ITimeswapPayCallback.sol';
import {IDeployNatives} from './IDeployNatives.sol';
import {IDeployPair} from './IDeployPair.sol';

/// @title Timeswap Convenience Interface
/// @author Ricsson W. Ngo
interface IConvenience is
    IMint,
    ILend,
    IWithdraw,
    IBorrow,
    IPay,
    IBurn,
    ITimeswapMintCallback,
    ITimeswapLendCallback,
    ITimeswapBorrowCallback,
    ITimeswapPayCallback,
    IDeployPair,
    IDeployNatives
{
    struct Native {
        ILiquidity liquidity;
        IClaim bondInterest;
        IClaim bondPrincipal;
        IClaim insuranceInterest;
        IClaim insurancePrincipal;
        IDue collateralizedDebt;
    }

    /* ===== VIEW ===== */

    /// @dev Return the address of the factory contract used by this contract.
    /// @return The address of the factory contract.
    function factory() external returns (IFactory);

    /// @dev Return the address of the Wrapped ETH contract.
    /// @return The address of WETH.
    function weth() external returns (IWETH);

    /// @dev Return the addresses of the Liquidty, Bond, Insurance, Collateralized Debt token contracts.
    /// @return The addresses of the native token contracts.
    function getNative(
        IERC20 asset,
        IERC20 collateral,
        uint256 maturity
    ) external view returns (Native memory);

    /// @dev Create pair contracts.
    /// @param params The parameters for this function found in IDeployPair interface.
    function deployPair(IDeployPair.DeployPair calldata params) external;

    /// @dev Create native token contracts.
    /// @param params The parameters for this function found in IDeployNative interface.
    function deployNatives(IDeployNatives.DeployNatives calldata params) external;

    /// @dev Calls the mint function and creates a new pool.
    /// @dev If the pair does not exist, creates a new pair first.
    /// @dev Must have the asset ERC20 approve this contract before calling this function.
    /// @dev Must have the collateral ERC20 approve this contract before calling this function.
    /// @param params The parameters for this function found in IMint interface.
    /// @return assetIn The amount of asset ERC20 deposited.
    /// @return liquidityOut The amount of liquidity balance received by liquidityTo.
    /// @return id The array index of the collateralized debt received by dueTo.
    /// @return dueOut The collateralized debt received by dueTo.
    function newLiquidity(NewLiquidity calldata params)
        external
        returns (
            uint256 assetIn,
            uint256 liquidityOut,
            uint256 id,
            IPair.Due memory dueOut
        );

    /// @dev Calls the mint function and creates a new pool.
    /// @dev If the pair does not exist, creates a new pair first.
    /// @dev The asset deposited is ETH which will be wrapped as WETH.
    /// @dev Msg.value is the assetIn amount.
    /// @dev Must have the collateral ERC20 approve this contract before calling this function.
    /// @param params The parameters for this function found in IMint interface.
    /// @return assetIn The amount of asset ERC20 deposited.
    /// @return liquidityOut The amount of liquidity balance received by liquidityTo.
    /// @return id The array index of the collateralized debt received by dueTo.
    /// @return dueOut The collateralized debt received by dueTo.
    function newLiquidityETHAsset(NewLiquidityETHAsset calldata params)
        external
        payable
        returns (
            uint256 assetIn,
            uint256 liquidityOut,
            uint256 id,
            IPair.Due memory dueOut
        );

    /// @dev Calls the mint function and creates a new pool.
    /// @dev If the pair does not exist, creates a new pair first.
    /// @dev The collateral locked is ETH which will be wrapped as WETH.
    /// @dev Msg.value is the collateralIn amount.
    /// @dev Must have the asset ERC20 approve this contract before calling this function.
    /// @param params The parameters for this function found in IMint interface.
    /// @return assetIn The amount of asset ERC20 deposited.
    /// @return liquidityOut The amount of liquidity balance received by liquidityTo.
    /// @return id The array index of the collateralized debt received by dueTo.
    /// @return dueOut The collateralized debt received by dueTo.
    function newLiquidityETHCollateral(NewLiquidityETHCollateral calldata params)
        external
        payable
        returns (
            uint256 assetIn,
            uint256 liquidityOut,
            uint256 id,
            IPair.Due memory dueOut
        );

    /// @dev Calls the mint function and add more liquidity to an existing pool.
    /// @dev Must have the asset ERC20 approve this contract before calling this function.
    /// @dev Must have the collateral ERC20 approve this contract before calling this function.
    /// @param params The parameters for this function found in IMint interface.
    /// @return assetIn The amount of asset ERC20 deposited.
    /// @return liquidityOut The amount of liquidity balance received by liquidityTo.
    /// @return id The array index of the collateralized debt received by dueTo.
    /// @return dueOut The collateralized debt received by dueTo.
    function liquidityGivenAsset(LiquidityGivenAsset calldata params)
        external
        returns (
            uint256 assetIn,
            uint256 liquidityOut,
            uint256 id,
            IPair.Due memory dueOut
        );

    /// @dev Calls the mint function and add more liquidity to an existing pool.
    /// @dev The asset deposited is ETH which will be wrapped as WETH.
    /// @dev Msg.value is the assetIn amount.
    /// @dev Must have the collateral ERC20 approve this contract before calling this function.
    /// @param params The parameters for this function found in IMint interface.
    /// @return assetIn The amount of asset ERC20 deposited.
    /// @return liquidityOut The amount of liquidity balance received by liquidityTo.
    /// @return id The array index of the collateralized debt received by dueTo.
    /// @return dueOut The collateralized debt received by dueTo.
    function liquidityGivenAssetETHAsset(LiquidityGivenAssetETHAsset calldata params)
        external
        payable
        returns (
            uint256 assetIn,
            uint256 liquidityOut,
            uint256 id,
            IPair.Due memory dueOut
        );

    /// @dev Calls the mint function and add more liquidity to an existing pool.
    /// @dev The collateral ERC20 is the WETH contract.
    /// @dev The collateral locked is ETH which will be wrapped as WETH.
    /// @dev Msg.value is the maxCollateral amount. Any excess ETH will be returned to Msg.sender.
    /// @dev Must have the asset ERC20 approve this contract before calling this function.
    /// @param params The parameters for this function found in IMint interface.
    /// @return assetIn The amount of asset ERC20 deposited.
    /// @return liquidityOut The amount of liquidity balance received by liquidityTo.
    /// @return id The array index of the collateralized debt received by dueTo.
    /// @return dueOut The collateralized debt received by dueTo.
    function liquidityGivenAssetETHCollateral(LiquidityGivenAssetETHCollateral calldata params)
        external
        payable
        returns (
            uint256 assetIn,
            uint256 liquidityOut,
            uint256 id,
            IPair.Due memory dueOut
        );

    /// @dev Calls the mint function and add more liquidity to an existing pool.
    /// @dev Must have the asset ERC20 approve this contract before calling this function.
    /// @dev Must have the collateral ERC20 approve this contract before calling this function.
    /// @param params The parameters for this function found in IMint interface.
    /// @return assetIn The amount of asset ERC20 deposited.
    /// @return liquidityOut The amount of liquidity balance received by liquidityTo.
    /// @return id The array index of the collateralized debt received by dueTo.
    /// @return dueOut The collateralized debt received by dueTo.
    function liquidityGivenDebt(LiquidityGivenDebt calldata params)
        external
        returns (
            uint256 assetIn,
            uint256 liquidityOut,
            uint256 id,
            IPair.Due memory dueOut
        );

    /// @dev Calls the mint function and add more liquidity to an existing pool.
    /// @dev The asset deposited is ETH which will be wrapped as WETH.
    /// @dev Msg.value is the assetIn amount.
    /// @dev Must have the collateral ERC20 approve this contract before calling this function.
    /// @param params The parameters for this function found in IMint interface.
    /// @return assetIn The amount of asset ERC20 deposited.
    /// @return liquidityOut The amount of liquidity balance received by liquidityTo.
    /// @return id The array index of the collateralized debt received by dueTo.
    /// @return dueOut The collateralized debt received by dueTo.
    function liquidityGivenDebtETHAsset(LiquidityGivenDebtETHAsset calldata params)
        external
        payable
        returns (
            uint256 assetIn,
            uint256 liquidityOut,
            uint256 id,
            IPair.Due memory dueOut
        );

    /// @dev Calls the mint function and add more liquidity to an existing pool.
    /// @dev The collateral ERC20 is the WETH contract.
    /// @dev The collateral locked is ETH which will be wrapped as WETH.
    /// @dev Msg.value is the maxCollateral amount. Any excess ETH will be returned to Msg.sender.
    /// @dev Must have the asset ERC20 approve this contract before calling this function.
    /// @param params The parameters for this function found in IMint interface.
    /// @return assetIn The amount of asset ERC20 deposited.
    /// @return liquidityOut The amount of liquidity balance received by liquidityTo.
    /// @return id The array index of the collateralized debt received by dueTo.
    /// @return dueOut The collateralized debt received by dueTo.
    function liquidityGivenDebtETHCollateral(LiquidityGivenDebtETHCollateral calldata params)
        external
        payable
        returns (
            uint256 assetIn,
            uint256 liquidityOut,
            uint256 id,
            IPair.Due memory dueOut
        );

    /// @dev Calls the mint function and add more liquidity to an existing pool.
    /// @dev Must have the asset ERC20 approve this contract before calling this function.
    /// @dev Must have the collateral ERC20 approve this contract before calling this function.
    /// @param params The parameters for this function found in IMint interface.
    /// @return assetIn The amount of asset ERC20 deposited.
    /// @return liquidityOut The amount of liquidity balance received by liquidityTo.
    /// @return id The array index of the collateralized debt received by dueTo.
    /// @return dueOut The collateralized debt received by dueTo.
    function liquidityGivenCollateral(LiquidityGivenCollateral calldata params)
        external
        returns (
            uint256 assetIn,
            uint256 liquidityOut,
            uint256 id,
            IPair.Due memory dueOut
        );

    /// @dev Calls the mint function and add more liquidity to an existing pool.
    /// @dev The asset deposited is ETH which will be wrapped as WETH.
    /// @dev Msg.value is the assetIn amount.
    /// @dev Must have the collateral ERC20 approve this contract before calling this function.
    /// @param params The parameters for this function found in IMint interface.
    /// @return assetIn The amount of asset ERC20 deposited.
    /// @return liquidityOut The amount of liquidity balance received by liquidityTo.
    /// @return id The array index of the collateralized debt received by dueTo.
    /// @return dueOut The collateralized debt received by dueTo.
    function liquidityGivenCollateralETHAsset(LiquidityGivenCollateralETHAsset calldata params)
        external
        payable
        returns (
            uint256 assetIn,
            uint256 liquidityOut,
            uint256 id,
            IPair.Due memory dueOut
        );

    /// @dev Calls the mint function and add more liquidity to an existing pool.
    /// @dev The collateral ERC20 is the WETH contract.
    /// @dev The collateral locked is ETH which will be wrapped as WETH.
    /// @dev Msg.value is the maxCollateral amount. Any excess ETH will be returned to Msg.sender.
    /// @dev Must have the asset ERC20 approve this contract before calling this function.
    /// @param params The parameters for this function found in IMint interface.
    /// @return assetIn The amount of asset ERC20 deposited.
    /// @return liquidityOut The amount of liquidity balance received by liquidityTo.
    /// @return id The array index of the collateralized debt received by dueTo.
    /// @return dueOut The collateralized debt received by dueTo.
    function liquidityGivenCollateralETHCollateral(LiquidityGivenCollateralETHCollateral calldata params)
        external
        payable
        returns (
            uint256 assetIn,
            uint256 liquidityOut,
            uint256 id,
            IPair.Due memory dueOut
        );

    /// @dev Calls the burn funtion and withdraw liquiidty from a pool.
    /// @param params The parameters for this function found in IBurn interface.
    /// @return assetOut The amount of asset ERC20 received by assetTo.
    /// @return collateralOut The amount of collateral ERC20 received by collateralTo.
    function removeLiquidity(RemoveLiquidity calldata params)
        external
        returns (uint256 assetOut, uint128 collateralOut);

    /// @dev Calls the burn funtion and withdraw liquiidty from a pool.
    /// @dev The asset received is ETH which will be unwrapped from WETH.
    /// @param params The parameters for this function found in IBurn interface.
    /// @return assetOut The amount of asset ERC20 received by assetTo.
    /// @return collateralOut The amount of collateral ERC20 received by collateralTo.
    function removeLiquidityETHAsset(RemoveLiquidityETHAsset calldata params)
        external
        returns (uint256 assetOut, uint128 collateralOut);

    /// @dev Calls the burn funtion and withdraw liquiidty from a pool.
    /// @dev The collateral received is ETH which will be unwrapped from WETH.
    /// @param params The parameters for this function found in IBurn interface.
    /// @return assetOut The amount of asset ERC20 received by assetTo.
    /// @return collateralOut The amount of collateral ERC20 received by collateralTo.
    function removeLiquidityETHCollateral(RemoveLiquidityETHCollateral calldata params)
        external
        returns (uint256 assetOut, uint128 collateralOut);

    /// @dev Calls the lend function and deposit asset into a pool.
    /// @dev Calls given the bond received by bondTo.
    /// @dev Must have the asset ERC20 approve this contract before calling this function.
    /// @param params The parameters for this function found in ILend interface.
    /// @return assetIn The amount of asset ERC20 deposited.
    /// @return claimsOut The amount of bond ERC20 and insurance ERC20 received by bondTo and insuranceTo.
    function lendGivenBond(LendGivenBond calldata params)
        external
        returns (uint256 assetIn, IPair.Claims memory claimsOut);

    /// @dev Calls the lend function and deposit asset into a pool.
    /// @dev Calls given the bond received by bondTo.
    /// @dev The asset deposited is ETH which will be wrapped as WETH.
    /// @param params The parameters for this function found in ILend interface.
    /// @return assetIn The amount of asset ERC20 deposited.
    /// @return claimsOut The amount of bond ERC20 and insurance ERC20 received by bondTo and insuranceTo.
    function lendGivenBondETHAsset(LendGivenBondETHAsset calldata params)
        external
        payable
        returns (uint256 assetIn, IPair.Claims memory claimsOut);

    /// @dev Calls the lend function and deposit asset into a pool.
    /// @dev Calls given the bond received by bondTo.
    /// @dev Must have the asset ERC20 approve this contract before calling this function.
    /// @param params The parameters for this function found in ILend interface.
    /// @return assetIn The amount of asset ERC20 deposited.
    /// @return claimsOut The amount of bond ERC20 and insurance ERC20 received by bondTo and insuranceTo.
    function lendGivenBondETHCollateral(LendGivenBondETHCollateral calldata params)
        external
        payable
        returns (uint256 assetIn, IPair.Claims memory claimsOut);

    /// @dev Calls the lend function and deposit asset into a pool.
    /// @dev Calls given the insurance received by insuranceTo.
    /// @dev Must have the asset ERC20 approve this contract before calling this function.
    /// @param params The parameters for this function found in ILend interface.
    /// @return assetIn The amount of asset ERC20 deposited.
    /// @return claimsOut The amount of bond ERC20 and insurance ERC20 received by bondTo and insuranceTo.
    function lendGivenInsurance(LendGivenInsurance calldata params)
        external
        returns (uint256 assetIn, IPair.Claims memory claimsOut);

    /// @dev Calls the lend function and deposit asset into a pool.
    /// @dev Calls given the insurance received by insuranceTo.
    /// @dev The asset deposited is ETH which will be wrapped as WETH.
    /// @param params The parameters for this function found in ILend interface.
    /// @return assetIn The amount of asset ERC20 deposited.
    /// @return claimsOut The amount of bond ERC20 and insurance ERC20 received by bondTo and insuranceTo.
    function lendGivenInsuranceETHAsset(LendGivenInsuranceETHAsset calldata params)
        external
        payable
        returns (uint256 assetIn, IPair.Claims memory claimsOut);

    /// @dev Calls the lend function and deposit asset into a pool.
    /// @dev Calls given the insurance received by insuranceTo.
    /// @dev Must have the asset ERC20 approve this contract before calling this function.
    /// @param params The parameters for this function found in ILend interface.
    /// @return assetIn The amount of asset ERC20 deposited.
    /// @return claimsOut The amount of bond ERC20 and insurance ERC20 received by bondTo and insuranceTo.
    function lendGivenInsuranceETHCollateral(LendGivenInsuranceETHCollateral calldata params)
        external
        returns (uint256 assetIn, IPair.Claims memory claimsOut);

    /// @dev Calls the lend function and deposit asset into a pool.
    /// @dev Calls given percentage ratio of bond and insurance.
    /// @dev Must have the asset ERC20 approve this contract before calling this function.
    /// @param params The parameters for this function found in ILend interface.
    /// @return assetIn The amount of asset ERC20 deposited.
    /// @return claimsOut The amount of bond ERC20 and insurance ERC20 received by bondTo and insuranceTo.
    function lendGivenPercent(LendGivenPercent calldata params)
        external
        returns (uint256 assetIn, IPair.Claims memory claimsOut);

    /// @dev Calls the lend function and deposit asset into a pool.
    /// @dev Calls given percentage ratio of bond and insurance.
    /// @dev The asset deposited is ETH which will be wrapped as WETH.
    /// @param params The parameters for this function found in ILend interface.
    /// @return assetIn The amount of asset ERC20 deposited.
    /// @return claimsOut The amount of bond ERC20 and insurance ERC20 received by bondTo and insuranceTo.
    function lendGivenPercentETHAsset(LendGivenPercentETHAsset calldata params)
        external
        payable
        returns (uint256 assetIn, IPair.Claims memory claimsOut);

    /// @dev Calls the lend function and deposit asset into a pool.
    /// @dev Calls given percentage ratio of bond and insurance.
    /// @dev Must have the asset ERC20 approve this contract before calling this function.
    /// @param params The parameters for this function found in ILend interface.
    /// @return assetIn The amount of asset ERC20 deposited.
    /// @return claimsOut The amount of bond ERC20 and insurance ERC20 received by bondTo and insuranceTo.
    function lendGivenPercentETHCollateral(LendGivenPercentETHCollateral calldata params)
        external
        returns (uint256 assetIn, IPair.Claims memory claimsOut);

    /// @dev Calls the withdraw function and withdraw asset and collateral from a pool.
    /// @param params The parameters for this function found in IWithdraw interface.
    /// @return tokensOut The amount of asset ERC20 and collateral ERC20 received by assetTo and collateralTo.
    function collect(Collect calldata params) external returns (IPair.Tokens memory tokensOut);

    /// @dev Calls the withdraw function and withdraw asset and collateral from a pool.
    /// @dev The asset received is ETH which will be unwrapped from WETH.
    /// @param params The parameters for this function found in IWithdraw interface.
    /// @return tokensOut The amount of asset ERC20 and collateral ERC20 received by assetTo and collateralTo.
    function collectETHAsset(CollectETHAsset calldata params) external returns (IPair.Tokens memory tokensOut);

    /// @dev Calls the withdraw function and withdraw asset and collateral from a pool.
    /// @dev The collateral received is ETH which will be unwrapped from WETH.
    /// @param params The parameters for this function found in IWithdraw interface.
    /// @return tokensOut The amount of asset ERC20 and collateral ERC20 received by assetTo and collateralTo.
    function collectETHCollateral(CollectETHCollateral calldata params)
        external
        returns (IPair.Tokens memory tokensOut);

    /// @dev Calls the borrow function and borrow asset from a pool and locking collateral into the pool.
    /// @dev Calls given the debt received by dueTo.
    /// @dev Must have the collateral ERC20 approve this contract before calling this function.
    /// @param params The parameters for this function found in IBorrow interface.
    /// @return assetOut The amount of asset ERC20 received by assetTo.
    /// @return id The token id of collateralized debt ERC721 received by dueTo.
    /// @return dueOut The collateralized debt ERC721 received by dueTo.
    function borrowGivenDebt(BorrowGivenDebt calldata params)
        external
        returns (
            uint256 assetOut,
            uint256 id,
            IPair.Due memory dueOut
        );

    /// @dev Calls the borrow function and borrow asset from a pool and locking collateral into the pool.
    /// @dev Calls given the debt received by dueTo.
    /// @dev Must have the collateral ERC20 approve this contract before calling this function.
    /// @param params The parameters for this function found in IBorrow interface.
    /// @return assetOut The amount of asset ERC20 received by assetTo.
    /// @return id The token id of collateralized debt ERC721 received by dueTo.
    /// @return dueOut The collateralized debt ERC721 received by dueTo.
    function borrowGivenDebtETHAsset(BorrowGivenDebtETHAsset calldata params)
        external
        returns (
            uint256 assetOut,
            uint256 id,
            IPair.Due memory dueOut
        );

    /// @dev Calls the borrow function and borrow asset from a pool and locking collateral into the pool.
    /// @dev Calls given the debt received by dueTo.
    /// @dev The collateral locked is ETH which will be wrapped as WETH.
    /// @param params The parameters for this function found in IBorrow interface.
    /// @return assetOut The amount of asset ERC20 received by assetTo.
    /// @return id The token id of collateralized debt ERC721 received by dueTo.
    /// @return dueOut The collateralized debt ERC721 received by dueTo.
    function borrowGivenDebtETHCollateral(BorrowGivenDebtETHCollateral calldata params)
        external
        payable
        returns (
            uint256 assetOut,
            uint256 id,
            IPair.Due memory dueOut
        );

    /// @dev Calls the borrow function and borrow asset from a pool and locking collateral into the pool.
    /// @dev Calls given the collateral locked.
    /// @dev Must have the collateral ERC20 approve this contract before calling this function.
    /// @param params The parameters for this function found in IBorrow interface.
    /// @return assetOut The amount of asset ERC20 received by assetTo.
    /// @return id The token id of collateralized debt ERC721 received by dueTo.
    /// @return dueOut The collateralized debt ERC721 received by dueTo.
    function borrowGivenCollateral(BorrowGivenCollateral calldata params)
        external
        returns (
            uint256 assetOut,
            uint256 id,
            IPair.Due memory dueOut
        );

    /// @dev Calls the borrow function and borrow asset from a pool and locking collateral into the pool.
    /// @dev Calls given the collateral locked.
    /// @dev Must have the collateral ERC20 approve this contract before calling this function.
    /// @param params The parameters for this function found in IBorrow interface.
    /// @return assetOut The amount of asset ERC20 received by assetTo.
    /// @return id The token id of collateralized debt ERC721 received by dueTo.
    /// @return dueOut The collateralized debt ERC721 received by dueTo.
    function borrowGivenCollateralETHAsset(BorrowGivenCollateralETHAsset calldata params)
        external
        returns (
            uint256 assetOut,
            uint256 id,
            IPair.Due memory dueOut
        );

    /// @dev Calls the borrow function and borrow asset from a pool and locking collateral into the pool.
    /// @dev Calls given the collateral locked.
    /// @dev The collateral locked is ETH which will be wrapped as WETH.
    /// @param params The parameters for this function found in IBorrow interface.
    /// @return assetOut The amount of asset ERC20 received by assetTo.
    /// @return id The token id of collateralized debt ERC721 received by dueTo.
    /// @return dueOut The collateralized debt ERC721 received by dueTo.
    function borrowGivenCollateralETHCollateral(BorrowGivenCollateralETHCollateral calldata params)
        external
        payable
        returns (
            uint256 assetOut,
            uint256 id,
            IPair.Due memory dueOut
        );

    /// @dev Calls the borrow function and borrow asset from a pool and locking collateral into the pool.
    /// @dev Calls given percentage ratio of debt and collateral.
    /// @dev Must have the collateral ERC20 approve this contract before calling this function.
    /// @param params The parameters for this function found in IBorrow interface.
    /// @return assetOut The amount of asset ERC20 received by assetTo.
    /// @return id The token id of collateralized debt ERC721 received by dueTo.
    /// @return dueOut The collateralized debt ERC721 received by dueTo.
    function borrowGivenPercent(BorrowGivenPercent calldata params)
        external
        returns (
            uint256 assetOut,
            uint256 id,
            IPair.Due memory dueOut
        );

    /// @dev Calls the borrow function and borrow asset from a pool and locking collateral into the pool.
    /// @dev Calls given percentage ratio of debt and collateral.
    /// @dev Must have the collateral ERC20 approve this contract before calling this function.
    /// @param params The parameters for this function found in IBorrow interface.
    /// @return assetOut The amount of asset ERC20 received by assetTo.
    /// @return id The token id of collateralized debt ERC721 received by dueTo.
    /// @return dueOut The collateralized debt ERC721 received by dueTo.
    function borrowGivenPercentETHAsset(BorrowGivenPercentETHAsset calldata params)
        external
        returns (
            uint256 assetOut,
            uint256 id,
            IPair.Due memory dueOut
        );

    /// @dev Calls the borrow function and borrow asset from a pool and locking collateral into the pool.
    /// @dev Calls given percentage ratio of debt and collateral.
    /// @dev The collateral locked is ETH which will be wrapped as WETH.
    /// @param params The parameters for this function found in IBorrow interface.
    /// @return assetOut The amount of asset ERC20 received by assetTo.
    /// @return id The token id of collateralized debt ERC721 received by dueTo.
    /// @return dueOut The collateralized debt ERC721 received by dueTo.
    function borrowGivenPercentETHCollateral(BorrowGivenPercentETHCollateral calldata params)
        external
        payable
        returns (
            uint256 assetOut,
            uint256 id,
            IPair.Due memory dueOut
        );

    /// @dev Calls the pay function and withdraw collateral from a pool given debt is paid or being paid.
    /// @dev If there is debt being paid, must have the asset ERC20 approve this contract before calling this function.
    /// @dev Possible to pay debt of collateralized debt not owned by msg.sender, which means no collateral is withdraw.
    /// @param params The parameters for this function found in IPay interface.
    /// @return assetIn The total amount of asset ERC20 paid.
    /// @return collateralOut The total amount of collateral ERC20 receceived by to;
    function repay(Repay memory params) external returns (uint128 assetIn, uint128 collateralOut);

    /// @dev Calls the pay function and withdraw collateral from a pool given debt is paid or being paid.
    //// @dev The asset being paid is ETH which will be wrapped as WETH.
    /// @dev Possible to pay debt of collateralized debt not owned by msg.sender, which means no collateral is withdraw.
    /// @param params The parameters for this function found in IPay interface.
    /// @return assetIn The total amount of asset ERC20 paid.
    /// @return collateralOut The total amount of collateral ERC20 receceived by to;
    function repayETHAsset(RepayETHAsset memory params)
        external
        payable
        returns (uint128 assetIn, uint128 collateralOut);

    /// @dev Calls the pay function and withdraw collateral from a pool given debt is paid or being paid.
    /// @dev The collateral received is ETH which will be unwrapped from WETH.
    /// @dev If there is debt being paid, must have the asset ERC20 approve this contract before calling this function.
    /// @dev Possible to pay debt of collateralized debt not owned by msg.sender, which means no collateral is withdraw.
    /// @param params The parameters for this function found in IPay interface.
    /// @return assetIn The total amount of asset ERC20 paid.
    /// @return collateralOut The total amount of collateral ERC20 receceived by to;
    function repayETHCollateral(RepayETHCollateral memory params)
        external
        returns (uint128 assetIn, uint128 collateralOut);
}",6980
RealWorld_BA_96_ILend_RealWord_20240826185142.log,96,ILend,18005,6268,24273,87.0,0.215385,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.4;

import {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import {IConvenience} from '../interfaces/IConvenience.sol';
import {IFactory} from '@timeswap-labs/timeswap-v1-core/contracts/interfaces/IFactory.sol';
import {IPair} from '@timeswap-labs/timeswap-v1-core/contracts/interfaces/IPair.sol';

interface ILend {
    struct LendGivenBond {
        IERC20 asset;
        IERC20 collateral;
        uint256 maturity;
        address bondTo;
        address insuranceTo;
        uint112 assetIn;
        uint128 bondOut;
        uint128 minInsurance;
        uint256 deadline;
    }

    struct LendGivenBondETHAsset {
        IERC20 collateral;
        uint256 maturity;
        address bondTo;
        address insuranceTo;
        uint128 bondOut;
        uint128 minInsurance;
        uint256 deadline;
    }

    struct LendGivenBondETHCollateral {
        IERC20 asset;
        uint256 maturity;
        address bondTo;
        address insuranceTo;
        uint112 assetIn;
        uint128 bondOut;
        uint128 minInsurance;
        uint256 deadline;
    }

    struct _LendGivenBond {
        IConvenience convenience;
        IFactory factory;
        IERC20 asset;
        IERC20 collateral;
        uint256 maturity;
        address from;
        address bondTo;
        address insuranceTo;
        uint112 assetIn;
        uint128 bondOut;
        uint128 minInsurance;
        uint256 deadline;
    }

    struct LendGivenInsurance {
        IERC20 asset;
        IERC20 collateral;
        uint256 maturity;
        address bondTo;
        address insuranceTo;
        uint112 assetIn;
        uint128 insuranceOut;
        uint128 minBond;
        uint256 deadline;
    }

    struct LendGivenInsuranceETHAsset {
        IERC20 collateral;
        uint256 maturity;
        address bondTo;
        address insuranceTo;
        uint128 insuranceOut;
        uint128 minBond;
        uint256 deadline;
    }

    struct LendGivenInsuranceETHCollateral {
        IERC20 asset;
        uint256 maturity;
        address bondTo;
        address insuranceTo;
        uint112 assetIn;
        uint128 insuranceOut;
        uint128 minBond;
        uint256 deadline;
    }

    struct _LendGivenInsurance {
        IConvenience convenience;
        IFactory factory;
        IERC20 asset;
        IERC20 collateral;
        uint256 maturity;
        address from;
        address bondTo;
        address insuranceTo;
        uint112 assetIn;
        uint128 insuranceOut;
        uint128 minBond;
        uint256 deadline;
    }

    struct LendGivenPercent {
        IERC20 asset;
        IERC20 collateral;
        uint256 maturity;
        address bondTo;
        address insuranceTo;
        uint112 assetIn;
        uint40 percent;
        uint128 minBond;
        uint128 minInsurance;
        uint256 deadline;
    }

    struct LendGivenPercentETHAsset {
        IERC20 collateral;
        uint256 maturity;
        address bondTo;
        address insuranceTo;
        uint40 percent;
        uint128 minBond;
        uint128 minInsurance;
        uint256 deadline;
    }

    struct LendGivenPercentETHCollateral {
        IERC20 asset;
        uint256 maturity;
        address bondTo;
        address insuranceTo;
        uint112 assetIn;
        uint40 percent;
        uint128 minBond;
        uint128 minInsurance;
        uint256 deadline;
    }

    struct _LendGivenPercent {
        IConvenience convenience;
        IFactory factory;
        IERC20 asset;
        IERC20 collateral;
        uint256 maturity;
        address from;
        address bondTo;
        address insuranceTo;
        uint112 assetIn;
        uint40 percent;
        uint128 minBond;
        uint128 minInsurance;
        uint256 deadline;
    }

    struct _Lend {
        IConvenience convenience;
        IPair pair;
        IERC20 asset;
        IERC20 collateral;
        uint256 maturity;
        address from;
        address bondTo;
        address insuranceTo;
        uint112 xIncrease;
        uint112 yDecrease;
        uint112 zDecrease;
        uint256 deadline;
    }
}",919
RealWorld_BA_96_MintMath_RealWord_20240826181829.log,96,MintMath,18890,6067,24957,101.0,0.21579,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.4;

import {IPair} from '@timeswap-labs/timeswap-v1-core/contracts/interfaces/IPair.sol';
import {Math} from '@timeswap-labs/timeswap-v1-core/contracts/libraries/Math.sol';
import {ConstantProduct} from './ConstantProduct.sol';
import {SafeCast} from '@timeswap-labs/timeswap-v1-core/contracts/libraries/SafeCast.sol';
library MintMath {
    using Math for uint256;
    using ConstantProduct for IPair;
    using SafeCast for uint256;

    function givenNew(
        uint256 maturity,
        uint112 assetIn,
        uint112 debtIn,
        uint112 collateralIn
    )
        internal
        view
        returns (
            uint112 xIncrease,
            uint112 yIncrease,
            uint112 zIncrease
        )
    {
        xIncrease = assetIn;
        uint256 duration = maturity;
        duration -= block.timestamp;
        uint256 _yIncrease = debtIn;
        _yIncrease -= assetIn;
        _yIncrease <<= 32;
        _yIncrease /= duration;
        yIncrease = _yIncrease.toUint112();
        uint256 _zIncrease = collateralIn;
        _zIncrease <<= 25;
        uint256 denominator = duration;
        denominator += 0x2000000;
        _zIncrease /= denominator;
        zIncrease = _zIncrease.toUint112();
    }

    function givenAsset(
        IPair pair,
        uint256 maturity,
        uint112 assetIn
    )
        internal
        view
        returns (
            uint112 xIncrease,
            uint112 yIncrease,
            uint112 zIncrease
        )
    {
        ConstantProduct.CP memory cp = pair.get(maturity);

        uint256 _xIncrease = assetIn;
        _xIncrease *= cp.x;
        uint256 denominator = cp.x;
        denominator += pair.feeStored(maturity);
        _xIncrease /= denominator;
        xIncrease = _xIncrease.toUint112();

        uint256 _yIncrease = cp.y;
        _yIncrease *= assetIn;
        _yIncrease /= cp.x;
        yIncrease = _yIncrease.toUint112();

        uint256 _zIncrease = cp.z;
        _zIncrease *= assetIn;
        _zIncrease /= cp.x;
        zIncrease = _zIncrease.toUint112();
    }

    function givenDebt(
        IPair pair,
        uint256 maturity,
        uint112 debtIn
    )
        internal
        view
        returns (
            uint112 xIncrease,
            uint112 yIncrease,
            uint112 zIncrease
        )
    {
        ConstantProduct.CP memory cp = pair.get(maturity);

        uint256 _yIncrease = debtIn;
        _yIncrease *= cp.y;
        _yIncrease <<= 32;
        uint256 denominator = maturity;
        denominator -= block.timestamp;
        denominator *= cp.y;
        uint256 addend = cp.x;
        addend <<= 32;
        denominator += addend;
        _yIncrease /= denominator;
        yIncrease = _yIncrease.toUint112();

        uint256 _xIncrease = cp.x;
        _xIncrease *= _yIncrease;
        _xIncrease = _xIncrease.divUp(cp.y);
        xIncrease = _xIncrease.toUint112();

        uint256 _zIncrease = cp.z;
        _zIncrease *= _yIncrease;
        _zIncrease /= cp.y;
        zIncrease = _zIncrease.toUint112();
    }

    function givenCollateral(
        IPair pair,
        uint256 maturity,
        uint112 collateralIn
    )
        internal
        view
        returns (
            uint112 xIncrease,
            uint112 yIncrease,
            uint112 zIncrease
        )
    {
        ConstantProduct.CP memory cp = pair.get(maturity);

        uint256 _zIncrease = collateralIn;
        _zIncrease <<= 25;
        uint256 denominator = maturity;
        denominator -= block.timestamp;
        denominator += 0x2000000;
        _zIncrease /= denominator;
        zIncrease = _zIncrease.toUint112();

        uint256 _xIncrease = cp.x;
        _xIncrease *= _zIncrease;
        _xIncrease = _xIncrease.divUp(cp.z);
        xIncrease = _xIncrease.toUint112();

        uint256 _yIncrease = cp.y;
        _yIncrease *= _zIncrease;
        _yIncrease /= cp.z;
        yIncrease = _yIncrease.toUint112();
    }
}",951
RealWorld_BA_96_MsgValue_RealWord_20240826182612.log,96,MsgValue,5761,5087,10848,64.0,0.130545,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.4;

import {ETH} from './ETH.sol';
import {SafeCast} from '@timeswap-labs/timeswap-v1-core/contracts/libraries/SafeCast.sol';

library MsgValue {
    using SafeCast for uint256;

    function getUint112() internal returns (uint112 value) {
        value = msg.value.truncateUint112();
        unchecked {
            if (msg.value > value) ETH.transfer(payable(msg.sender), msg.value - value);
        }
    }
}",116
RealWorld_BA_96_Lend_RealWord_20240826175351.log,96,Lend,47423,4956,52379,78.0,0.336235,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.4;

import {IConvenience} from '../interfaces/IConvenience.sol';
import {IFactory} from '@timeswap-labs/timeswap-v1-core/contracts/interfaces/IFactory.sol';
import {IWETH} from '../interfaces/IWETH.sol';
import {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import {IPair} from '@timeswap-labs/timeswap-v1-core/contracts/interfaces/IPair.sol';
import {ILend} from '../interfaces/ILend.sol';
import {LendMath} from './LendMath.sol';
import {Deploy} from './Deploy.sol';
import {MsgValue} from './MsgValue.sol';

library Lend {
    using LendMath for IPair;
    using Deploy for IConvenience.Native;

    function lendGivenBond(
        mapping(IERC20 => mapping(IERC20 => mapping(uint256 => IConvenience.Native))) storage natives,
        IConvenience convenience,
        IFactory factory,
        ILend.LendGivenBond calldata params
    ) external returns (uint256 assetIn, IPair.Claims memory claimsOut) {
        (assetIn, claimsOut) = _lendGivenBond(
            natives,
            ILend._LendGivenBond(
                convenience,
                factory,
                params.asset,
                params.collateral,
                params.maturity,
                msg.sender,
                params.bondTo,
                params.insuranceTo,
                params.assetIn,
                params.bondOut,
                params.minInsurance,
                params.deadline
            )
        );
    }

    function lendGivenBondETHAsset(
        mapping(IERC20 => mapping(IERC20 => mapping(uint256 => IConvenience.Native))) storage natives,
        IConvenience convenience,
        IFactory factory,
        IWETH weth,
        ILend.LendGivenBondETHAsset calldata params
    ) external returns (uint256 assetIn, IPair.Claims memory claimsOut) {
        uint112 assetInETH = MsgValue.getUint112();

        (assetIn, claimsOut) = _lendGivenBond(
            natives,
            ILend._LendGivenBond(
                convenience,
                factory,
                weth,
                params.collateral,
                params.maturity,
                address(this),
                params.bondTo,
                params.insuranceTo,
                assetInETH,
                params.bondOut,
                params.minInsurance,
                params.deadline
            )
        );
    }

    function lendGivenBondETHCollateral(
        mapping(IERC20 => mapping(IERC20 => mapping(uint256 => IConvenience.Native))) storage natives,
        IConvenience convenience,
        IFactory factory,
        IWETH weth,
        ILend.LendGivenBondETHCollateral calldata params
    ) external returns (uint256 assetIn, IPair.Claims memory claimsOut) {
        (assetIn, claimsOut) = _lendGivenBond(
            natives,
            ILend._LendGivenBond(
                convenience,
                factory,
                params.asset,
                weth,
                params.maturity,
                msg.sender,
                params.bondTo,
                params.insuranceTo,
                params.assetIn,
                params.bondOut,
                params.minInsurance,
                params.deadline
            )
        );
    }

    function lendGivenInsurance(
        mapping(IERC20 => mapping(IERC20 => mapping(uint256 => IConvenience.Native))) storage natives,
        IConvenience convenience,
        IFactory factory,
        ILend.LendGivenInsurance calldata params
    ) external returns (uint256 assetIn, IPair.Claims memory claimsOut) {
        (assetIn, claimsOut) = _lendGivenInsurance(
            natives,
            ILend._LendGivenInsurance(
                convenience,
                factory,
                params.asset,
                params.collateral,
                params.maturity,
                msg.sender,
                params.bondTo,
                params.insuranceTo,
                params.assetIn,
                params.insuranceOut,
                params.minBond,
                params.deadline
            )
        );
    }

    function lendGivenInsuranceETHAsset(
        mapping(IERC20 => mapping(IERC20 => mapping(uint256 => IConvenience.Native))) storage natives,
        IConvenience convenience,
        IFactory factory,
        IWETH weth,
        ILend.LendGivenInsuranceETHAsset calldata params
    ) external returns (uint256 assetIn, IPair.Claims memory claimsOut) {
        uint112 assetInETH = MsgValue.getUint112();

        (assetIn, claimsOut) = _lendGivenInsurance(
            natives,
            ILend._LendGivenInsurance(
                convenience,
                factory,
                weth,
                params.collateral,
                params.maturity,
                address(this),
                params.bondTo,
                params.insuranceTo,
                assetInETH,
                params.insuranceOut,
                params.minBond,
                params.deadline
            )
        );
    }

    function lendGivenInsuranceETHCollateral(
        mapping(IERC20 => mapping(IERC20 => mapping(uint256 => IConvenience.Native))) storage natives,
        IConvenience convenience,
        IFactory factory,
        IWETH weth,
        ILend.LendGivenInsuranceETHCollateral calldata params
    ) external returns (uint256 assetIn, IPair.Claims memory claimsOut) {
        (assetIn, claimsOut) = _lendGivenInsurance(
            natives,
            ILend._LendGivenInsurance(
                convenience,
                factory,
                params.asset,
                weth,
                params.maturity,
                msg.sender,
                params.bondTo,
                params.insuranceTo,
                params.assetIn,
                params.insuranceOut,
                params.minBond,
                params.deadline
            )
        );
    }

    function lendGivenPercent(
        mapping(IERC20 => mapping(IERC20 => mapping(uint256 => IConvenience.Native))) storage natives,
        IConvenience convenience,
        IFactory factory,
        ILend.LendGivenPercent calldata params
    ) external returns (uint256 assetIn, IPair.Claims memory claimsOut) {
        (assetIn, claimsOut) = _lendGivenPercent(
            natives,
            ILend._LendGivenPercent(
                convenience,
                factory,
                params.asset,
                params.collateral,
                params.maturity,
                msg.sender,
                params.bondTo,
                params.insuranceTo,
                params.assetIn,
                params.percent,
                params.minBond,
                params.minInsurance,
                params.deadline
            )
        );
    }

    function lendGivenPercentETHAsset(
        mapping(IERC20 => mapping(IERC20 => mapping(uint256 => IConvenience.Native))) storage natives,
        IConvenience convenience,
        IFactory factory,
        IWETH weth,
        ILend.LendGivenPercentETHAsset calldata params
    ) external returns (uint256 assetIn, IPair.Claims memory claimsOut) {
        uint112 assetInETH = MsgValue.getUint112();

        (assetIn, claimsOut) = _lendGivenPercent(
            natives,
            ILend._LendGivenPercent(
                convenience,
                factory,
                weth,
                params.collateral,
                params.maturity,
                address(this),
                params.bondTo,
                params.insuranceTo,
                assetInETH,
                params.percent,
                params.minBond,
                params.minInsurance,
                params.deadline
            )
        );
    }

    function lendGivenPercentETHCollateral(
        mapping(IERC20 => mapping(IERC20 => mapping(uint256 => IConvenience.Native))) storage natives,
        IConvenience convenience,
        IFactory factory,
        IWETH weth,
        ILend.LendGivenPercentETHCollateral calldata params
    ) external returns (uint256 assetIn, IPair.Claims memory claimsOut) {
        (assetIn, claimsOut) = _lendGivenPercent(
            natives,
            ILend._LendGivenPercent(
                convenience,
                factory,
                params.asset,
                weth,
                params.maturity,
                msg.sender,
                params.bondTo,
                params.insuranceTo,
                params.assetIn,
                params.percent,
                params.minBond,
                params.minInsurance,
                params.deadline
            )
        );
    }

    function _lendGivenBond(
        mapping(IERC20 => mapping(IERC20 => mapping(uint256 => IConvenience.Native))) storage natives,
        ILend._LendGivenBond memory params
    ) private returns (uint256 assetIn, IPair.Claims memory claimsOut) {
        require(params.bondOut > params.assetIn, 'E517');

        IPair pair = params.factory.getPair(params.asset, params.collateral);
        require(address(pair) != address(0), 'E501');
        (uint112 xIncrease, uint112 yDecrease, uint112 zDecrease) = pair.givenBond(
            params.maturity,
            params.assetIn,
            params.bondOut
        );

        (assetIn, claimsOut) = _lend(
            natives,
            ILend._Lend(
                params.convenience,
                pair,
                params.asset,
                params.collateral,
                params.maturity,
                params.from,
                params.bondTo,
                params.insuranceTo,
                xIncrease,
                yDecrease,
                zDecrease,
                params.deadline
            )
        );

        require(uint128(claimsOut.insuranceInterest) + claimsOut.insurancePrincipal >= params.minInsurance, 'E515');
    }

    function _lendGivenInsurance(
        mapping(IERC20 => mapping(IERC20 => mapping(uint256 => IConvenience.Native))) storage natives,
        ILend._LendGivenInsurance memory params
    ) private returns (uint256 assetIn, IPair.Claims memory claimsOut) {
        IPair pair = params.factory.getPair(params.asset, params.collateral);
        require(address(pair) != address(0), 'E501');

        (uint112 xIncrease, uint112 yDecrease, uint112 zDecrease) = pair.givenInsurance(
            params.maturity,
            params.assetIn,
            params.insuranceOut
        );

        (assetIn, claimsOut) = _lend(
            natives,
            ILend._Lend(
                params.convenience,
                pair,
                params.asset,
                params.collateral,
                params.maturity,
                params.from,
                params.bondTo,
                params.insuranceTo,
                xIncrease,
                yDecrease,
                zDecrease,
                params.deadline
            )
        );

        require(uint128(claimsOut.bondInterest) + claimsOut.bondPrincipal >= params.minBond, 'E514');
    }

    function _lendGivenPercent(
        mapping(IERC20 => mapping(IERC20 => mapping(uint256 => IConvenience.Native))) storage natives,
        ILend._LendGivenPercent memory params
    ) private returns (uint256 assetIn, IPair.Claims memory claimsOut) {
        require(params.percent <= 0x100000000, 'E505');

        IPair pair = params.factory.getPair(params.asset, params.collateral);
        require(address(pair) != address(0), 'E501');

        (uint112 xIncrease, uint112 yDecrease, uint112 zDecrease) = pair.givenPercent(
            params.maturity,
            params.assetIn,
            params.percent
        );

        (assetIn, claimsOut) = _lend(
            natives,
            ILend._Lend(
                params.convenience,
                pair,
                params.asset,
                params.collateral,
                params.maturity,
                params.from,
                params.bondTo,
                params.insuranceTo,
                xIncrease,
                yDecrease,
                zDecrease,
                params.deadline
            )
        );

        require(uint128(claimsOut.bondInterest) + claimsOut.bondPrincipal >= params.minBond, 'E514');
        require(uint128(claimsOut.insuranceInterest) + claimsOut.insurancePrincipal >= params.minInsurance, 'E515');
    }

    function _lend(
        mapping(IERC20 => mapping(IERC20 => mapping(uint256 => IConvenience.Native))) storage natives,
        ILend._Lend memory params
    ) private returns (uint256 assetIn, IPair.Claims memory claimsOut) {
        require(params.deadline >= block.timestamp, 'E504');
        require(params.maturity > block.timestamp, 'E508');

        IConvenience.Native storage native = natives[params.asset][params.collateral][params.maturity];
        if (address(native.liquidity) == address(0))
            native.deploy(params.convenience, params.pair, params.asset, params.collateral, params.maturity);

        (assetIn, claimsOut) = params.pair.lend(
            IPair.LendParam(
                params.maturity,
                address(this),
                address(this),
                params.xIncrease,
                params.yDecrease,
                params.zDecrease,
                bytes(abi.encode(params.asset, params.collateral, params.from))
            )
        );

        native.bondInterest.mint(params.bondTo, claimsOut.bondInterest);
        native.bondPrincipal.mint(params.bondTo, claimsOut.bondPrincipal);
        native.insuranceInterest.mint(params.insuranceTo, claimsOut.insuranceInterest);
        native.insurancePrincipal.mint(params.insuranceTo, claimsOut.insurancePrincipal);
    }
}",2799
RealWorld_BA_96_TimeswapFactory_RealWord_20240826175057.log,96,TimeswapFactory,3291,5142,8433,87.0,0.119295,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.4;
import '@timeswap-labs/timeswap-v1-core/contracts/TimeswapFactory.sol';",36
RealWorld_BA_96_BondPrincipal_RealWord_20240826172849.log,96,BondPrincipal,11259,5008,16267,77.0,0.156455,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.4;

import {IClaim} from './interfaces/IClaim.sol';
import {IConvenience} from './interfaces/IConvenience.sol';
import {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import {IPair} from '@timeswap-labs/timeswap-v1-core/contracts/interfaces/IPair.sol';
import {ERC20Permit} from './base/ERC20Permit.sol';
import {SafeMetadata} from './libraries/SafeMetadata.sol';
import {Strings} from '@openzeppelin/contracts/utils/Strings.sol';

contract BondPrincipal is IClaim, ERC20Permit {
    using SafeMetadata for IERC20;
    using Strings for uint256;

    IConvenience public immutable override convenience;
    IPair public immutable override pair;
    uint256 public immutable override maturity;

    function name() external view override returns (string memory) {
        string memory assetName = pair.asset().safeName();
        string memory collateralName = pair.collateral().safeName();
        return
            string(
                abi.encodePacked(
                    'Timeswap Bond Principal - ',
                    assetName,
                    ' - ',
                    collateralName,
                    ' - ',
                    maturity.toString()
                )
            );
    }

    function symbol() external view override returns (string memory) {
        string memory assetSymbol = pair.asset().safeSymbol();
        string memory collateralSymbol = pair.collateral().safeSymbol();
        return string(abi.encodePacked('TS-BND-PRI-', assetSymbol, '-', collateralSymbol, '-', maturity.toString()));
    }

    function decimals() external view override returns (uint8) {
        return pair.asset().safeDecimals();
    }

    function totalSupply() external view override returns (uint256) {
        return pair.claimsOf(maturity, address(convenience)).bondPrincipal;
    }

    constructor(
        IConvenience _convenience,
        IPair _pair,
        uint256 _maturity
    ) ERC20Permit('Timeswap Bond Principal') {
        convenience = _convenience;
        pair = _pair;
        maturity = _maturity;
    }

    modifier onlyConvenience() {
        require(msg.sender == address(convenience), 'E403');
        _;
    }

    function mint(address to, uint128 amount) external override onlyConvenience {
        _mint(to, amount);
    }

    function burn(address from, uint128 amount) external override onlyConvenience {
        _burn(from, amount);
    }
}",532
RealWorld_BA_96_ConstantProduct_RealWord_20240826182500.log,96,ConstantProduct,4910,4432,9342,70.0,0.11319,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.4;

import {IPair} from '@timeswap-labs/timeswap-v1-core/contracts/interfaces/IPair.sol';

library ConstantProduct {
    struct CP {
        uint112 x;
        uint112 y;
        uint112 z;
    }

    function get(IPair pair, uint256 maturity) internal view returns (CP memory cp) {
        (uint112 x, uint112 y, uint112 z) = pair.constantProduct(maturity);
        cp = CP(x, y, z);
    }
}",119
RealWorld_BA_96_IBurn_RealWord_20240826183557.log,96,IBurn,6717,5387,12104,78.0,0.141325,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.4;

import {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import {IFactory} from '@timeswap-labs/timeswap-v1-core/contracts/interfaces/IFactory.sol';

interface IBurn {
    struct RemoveLiquidity {
        IERC20 asset;
        IERC20 collateral;
        uint256 maturity;
        address assetTo;
        address collateralTo;
        uint256 liquidityIn;
    }

    struct RemoveLiquidityETHAsset {
        IERC20 collateral;
        uint256 maturity;
        address payable assetTo;
        address collateralTo;
        uint256 liquidityIn;
    }

    struct RemoveLiquidityETHCollateral {
        IERC20 asset;
        uint256 maturity;
        address assetTo;
        address payable collateralTo;
        uint256 liquidityIn;
    }

    struct _RemoveLiquidity {
        IFactory factory;
        IERC20 asset;
        IERC20 collateral;
        uint256 maturity;
        address assetTo;
        address collateralTo;
        uint256 liquidityIn;
    }
}",238
RealWorld_BA_96_NFTSVG_RealWord_20240826181336.log,96,NFTSVG,0,0,0,,0.0,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.4;

library NFTSVG {
    struct SVGParams {
        string tokenId;
        string svgTitle;
        string assetInfo;
        string collateralInfo;
        string debtRequired;
        string collateralLocked;
        string maturityDate;
        string maturityTimestampString;
        string tokenColors;
        bool isMatured;
    }

    function constructSVG(SVGParams memory params) public pure returns (string memory) {
        string memory colorScheme = params.isMatured
            ? '.G{stop-color:#3C3C3C}.H{fill:#959595}.I{stop-color:#000000}.J{stop-color:#FFFFFF}'
            : '.G{stop-color:#20087E}.H{fill:#5457D7}.I{stop-color:#61F6FF}.J{stop-color:#3C43FF}';

        string memory svg = string(
            abi.encodePacked(
                '<svg width=""290"" height=""500"" xmlns=""http://www.w3.org/2000/svg"" xmlns:xlink=""http://www.w3.org/1999/xlink""><style type=""text/css"" ><![CDATA[.B{fill-rule:evenodd}',
                params.tokenColors,
                colorScheme,
                ']]></style><g clip-path=""url(#mainclip)""><rect width=""290"" height=""500"" fill=""url(\'#background\')""/><rect y=""409"" width=""290"" height=""90"" fill=""#141330"" fill-opacity=""0.4""/><rect y=""408"" width=""290"" height=""2"" fill=""url(#divider)""/></g><text y=""70px"" x=""145"" fill=""white"" font-family=""arial"" font-weight=""500"" font-size=""24px"" text-anchor=""middle"">'
            )
        );

        svg = string(
            abi.encodePacked(
                svg,
                params.svgTitle,
                '</text><text y=""95px"" x=""145"" fill=""white"" font-family=""arial"" font-weight=""400"" font-size=""12px"" text-anchor=""middle"">',
                params.maturityDate,
                '</text>'
            )
        );

        if (!params.isMatured) {
            string memory maturityInfo = string(abi.encodePacked('MATURITY: ', params.maturityTimestampString));
            svg = string(
                abi.encodePacked(
                    svg,
                    '<text y=""115px"" x=""145"" fill=""white"" font-family=""arial"" font-weight=""300"" font-size=""10px"" text-anchor=""middle"" opacity=""50%"">',
                    maturityInfo,
                    '</text>'
                )
            );
        } else {
            svg = string(
                abi.encodePacked(
                    svg,
                    '<rect width=""74"" height=""22"" rx=""13"" y=""110"" x=""107"" text-anchor=""middle"" fill=""#FFFFFF"" /><text y=""125px"" x=""145"" fill=""black"" font-family=""arial"" font-weight=""600"" font-size=""10px"" letter-spacing=""1"" text-anchor=""middle"">MATURED</text>'
                )
            );
        }

        svg = string(
            abi.encodePacked(
                svg,
                '<text text-rendering=""optimizeSpeed""><textPath startOffset=""-100%"" fill=""white"" font-family=""\'Courier New\', monospace"" font-size=""10px"" xlink:href=""#text-path-a"">',
                params.assetInfo,
                '<animate additive=""sum"" attributeName=""startOffset"" from=""0%"" to=""100%"" begin=""0s"" dur=""30s"" repeatCount=""indefinite"" /></textPath><textPath startOffset=""0%"" fill=""white"" font-family=""\'Courier New\', monospace"" font-size=""10px"" xlink:href=""#text-path-a"">',
                params.assetInfo,
                '<animate additive=""sum"" attributeName=""startOffset"" from=""0%"" to=""100%"" begin=""0s"" dur=""30s"" repeatCount=""indefinite"" /></textPath><textPath startOffset=""50%"" fill=""white"" font-family=""\'Courier New\', monospace"" font-size=""10px"" xlink:href=""#text-path-a"">'
            )
        );
        svg = string(
            abi.encodePacked(
                svg,
                params.collateralInfo,
                '<animate additive=""sum"" attributeName=""startOffset"" from=""0%"" to=""100%"" begin=""0s"" dur=""30s"" repeatCount=""indefinite"" /></textPath><textPath startOffset=""-50%"" fill=""white"" font-family=""\'Courier New\', monospace"" font-size=""10px"" xlink:href=""#text-path-a"">',
                params.collateralInfo,
                '<animate additive=""sum"" attributeName=""startOffset"" from=""0%"" to=""100%"" begin=""0s"" dur=""30s"" repeatCount=""indefinite"" /></textPath></text><text y=""435px"" x=""12"" fill=""white"" font-family=""arial"" font-weight=""400"" font-size=""13px"" opacity=""60%"">ID:</text><text y=""435px"" x=""278"" fill=""white"" font-family=""arial"" font-weight=""500"" font-size=""13px"" text-anchor=""end"">'
            )
        );
        svg = string(
            abi.encodePacked(
                svg,
                params.tokenId,
                '</text><text y=""460px"" x=""12"" fill=""white"" font-family=""arial"" font-weight=""400"" font-size=""13px"" opacity=""60%"">Debt required:</text><text y=""460px"" x=""278"" fill=""white"" font-family=""arial"" font-weight=""500"" font-size=""13px"" text-anchor=""end"">',
                params.debtRequired,
                '</text><text y=""484px"" x=""12"" fill=""white"" font-family=""arial"" font-weight=""400"" font-size=""13px"" opacity=""60%"">Collateral locked:</text><text y=""484px"" x=""278"" fill=""white"" font-family=""arial"" font-weight=""500"" font-size=""13px"" text-anchor=""end"">',
                params.collateralLocked,
                '</text><g filter=""url(#filter0_f)""><path d=""M253 319.5C253 346.838 204.871 369 145.5 369C86.1294 369 38 346.838 38 319.5C38 292.162 86.1294 270 145.5 270C204.871 270 253 292.162 253 319.5Z"" class=""H""/></g>'
            )
        );
        svg = string(
            abi.encodePacked(
                svg,
                '<path d=""M144.235 272.663h4.147v11.255h-4.147zm62.092 19.456l2.074 2.089-16.76 5.627-2.074-2.089zm-26.564-14.565l3.591 1.206-9.676 9.747-3.591-1.206zm37.046 34.903v2.412h-19.353v-2.412zm-33.454 36.11l-3.591 1.206-9.676-9.747 3.591-1.206zm25.046-15.448l-2.074 2.089-16.76-5.627 2.074-2.089zm-64.165 10.289h4.147v11.255h-4.147zm-43.258-15.916l2.074 2.089-16.76 5.627-2.074-2.089zm17.962 11.328l3.591 1.206-9.676 9.747-3.591-1.206zm-25.778-26.157v2.412H73.809v-2.412zm28.915-26.253l-3.591 1.206-9.676-9.747 3.591-1.206zm-20.434 10.881l-2.074 2.089-16.76-5.627 2.074-2.089z"" fill=""#6fa4d4""/><path d=""M198.383 344.249C211.892 336.376 220 325.646 220 314s-8.108-22.376-21.617-30.249C184.898 275.893 166.204 271 145.5 271s-39.398 4.893-52.883 12.751C79.108 291.624 71 302.354 71 314s8.108 22.376 21.617 30.249C106.102 352.107 124.796 357 145.5 357s39.398-4.893 52.883-12.751zM145.5 358c41.698 0 75.5-19.699 75.5-44s-33.802-44-75.5-44S70 289.699 70 314s33.803 44 75.5 44zm56.402-10.206C216.307 339.026 225 327.049 225 314s-8.693-25.026-23.098-33.794C187.516 271.449 167.577 266 145.5 266s-42.016 5.449-56.402 14.206C74.694 288.974 66 300.951 66 314s8.694 25.026 23.098 33.794C103.484 356.551 123.423 362 145.5 362s42.016-5.449 56.402-14.206zM145.5 363c44.459 0 80.5-21.938 80.5-49s-36.041-49-80.5-49S65 286.938 65 314s36.041 49 80.5 49z"" fill-rule=""evenodd"" fill=""#6fa4d5""/><path d=""M189.764 303.604c0 14.364-19.951 26.008-44.562 26.008-24.343 0-44.127-11.392-44.555-25.54v6.92.363c0 14.38 19.951 26.022 44.562 26.022s44.562-11.642 44.562-26.022v-.363-7.574h-.008l.001.186z"" fill=""#7fc2e2""/><path d=""M145.202 326.408c21.834 0 39.533-10.256 39.533-22.906s-17.699-22.906-39.533-22.906-39.533 10.255-39.533 22.906 17.7 22.906 39.533 22.906z"" fill=""#020136""/><path d=""M189.764 303.604c0 14.364-19.951 26.008-44.562 26.008s-44.562-11.644-44.562-26.008 19.951-26.008 44.562-26.008 44.562 11.644 44.562 26.008zm-5.029-.102c0 12.65-17.699 22.906-39.533 22.906s-39.533-10.255-39.533-22.906 17.699-22.906 39.533-22.906 39.533 10.256 39.533 22.906z"" fill=""#4f95b8"" class=""B""/><path d=""M184.753 303.84v-5.406c0-18.859-10.806-36.185-28.114-45.047l-3.987-2.053a2.31 2.31 0 0 1-.975-.848 2.46 2.46 0 0 1-.39-1.259 2.47 2.47 0 0 1 .316-1.282c.216-.384.536-.699.924-.908l6.693-3.887c15.85-9.252 25.533-25.798 25.533-43.637V184h-78.996v15.095c0 18.065 9.925 34.782 26.098 43.959l6.772 3.846a2.34 2.34 0 0 1 .937.911c.223.39.334.839.321 1.293s-.15.894-.395 1.27-.588.671-.988.851l-4.105 2.053c-17.598 8.772-28.64 26.249-28.64 45.32v4.948c-.624 6.062 3.212 12.255 11.581 16.901 15.515 8.616 40.595 8.664 56.011.096 8.238-4.584 12.008-10.688 11.404-16.703h0z"" fill=""#fff"" fill-opacity="".3""/><path d=""M154.382 238.266c3.037-5.261 3.007-10.965-.062-12.737l2.734 1.579c3.069 1.772 3.098 7.476.061 12.737s-7.992 8.088-11.061 6.316l-2.734-1.579c3.069 1.772 8.025-1.055 11.062-6.315v-.001z"" class=""D""/><path d=""M154.382 238.266c3.037-5.261 3.007-10.965-.062-12.737s-8.024 1.055-11.061 6.316-3.008 10.965.061 12.737 8.025-1.055 11.062-6.315v-.001zm-1.402-.809c2.27-3.932 2.252-8.2-.045-9.526s-6.004.792-8.274 4.724-2.247 8.192.051 9.519 5.998-.784 8.268-4.716v-.001z"" class=""B C""/><path d=""M152.935 227.929c2.297 1.326 2.315 5.595.045 9.526s-5.971 6.042-8.268 4.716-2.321-5.587-.051-9.519 5.975-6.051 8.273-4.724l.001.001z"" class=""D""/><path d=""M148.854 232.173l1.827-2.157c.303-.364.664-.269.607.154l-.349 2.545c-.021.163.023.302.121.349l1.488.806c.241.139.107.695-.237.951l-2.028 1.534a.91.91 0 0 0-.316.438l-.91 2.656c-.155.449-.597.692-.75.437l-.938-1.578c-.031-.052-.08-.09-.139-.107s-.121-.01-.174.019l-2.043.841c-.35.139-.475-.274-.238-.686l1.458-2.525a.81.81 0 0 0 .118-.492l-.345-2.136a.8.8 0 0 1 .142-.539.81.81 0 0 1 .457-.318l1.85.033a.56.56 0 0 0 .223-.071.57.57 0 0 0 .176-.155v.001z"" class=""C""/><path d=""M166.548 230.55c4.318-4.272 5.796-9.782 3.303-12.302l2.221 2.245c2.492 2.519 1.014 8.029-3.304 12.301s-9.844 5.691-12.336 3.171l-2.221-2.245c2.492 2.52 8.018 1.102 12.337-3.17z"" class=""D""/><path d=""M166.548 230.549c4.318-4.272 5.796-9.782 3.303-12.302s-8.017-1.101-12.336 3.171-5.797 9.782-3.304 12.301 8.018 1.102 12.337-3.17zm-1.139-1.151c3.228-3.193 4.338-7.314 2.472-9.2s-6-.821-9.227 2.371-4.33 7.308-2.464 9.194 5.993.827 9.22-2.366l-.001.001z"" class=""B C""/><path d=""M167.881 220.199c1.866 1.886.755 6.008-2.472 9.2s-7.354 4.252-9.22 2.366-.763-6.002 2.464-9.194 7.36-4.258 9.227-2.371l.001-.001z"" class=""D""/><path d=""M162.824 223.215l2.332-1.599c.388-.271.711-.084.545.308l-1.008 2.363c-.064.152-.057.298.024.369l1.222 1.17c.196.198-.08.699-.48.854l-2.361.944c-.172.067-.318.186-.421.339l-1.579 2.321c-.268.392-.758.51-.839.224l-.488-1.77c-.015-.059-.052-.109-.104-.141s-.115-.04-.174-.026l-2.193.271c-.375.042-.386-.39-.048-.725l2.072-2.05a.81.81 0 0 0 .244-.443l.231-2.151a.81.81 0 0 1 .28-.483c.148-.123.333-.188.524-.186l1.776.52c.078.013.158.01.234-.009a.56.56 0 0 0 .211-.103v.003z"" class=""C""/><path d=""M131.352 236.907c4.692 3.858 10.325 4.762 12.576 2.024l-2.005 2.439c-2.251 2.738-7.883 1.832-12.575-2.025s-6.67-9.208-4.419-11.946l2.005-2.439c-2.251 2.738-.274 8.089 4.419 11.947h-.001z"" class=""D""/><path d=""M131.352 236.907c4.692 3.858 10.325 4.762 12.576 2.024s.273-8.088-4.419-11.946-10.324-4.763-12.575-2.025-.274 8.089 4.419 11.947h-.001zm1.028-1.251c3.507 2.883 7.721 3.564 9.405 1.515s.202-6.052-3.305-8.935-7.714-3.558-9.399-1.508-.208 6.046 3.299 8.929v-.001z"" class=""B C""/><path d=""M141.785 237.172c-1.685 2.049-5.898 1.368-9.405-1.515s-4.983-6.879-3.299-8.929 5.892-1.374 9.399 1.509 4.991 6.885 3.305 8.935z"" class=""D""/><path d=""M138.267 232.451l1.829 2.156c.309.359.156.699-.251.574l-2.454-.76c-.157-.048-.302-.026-.364.062l-1.039 1.335c-.177.215-.703-.008-.899-.39l-1.181-2.252c-.084-.164-.217-.298-.381-.384l-2.471-1.333c-.417-.227-.585-.702-.309-.812l1.71-.667c.057-.021.103-.064.128-.12s.03-.117.009-.174l-.495-2.153c-.08-.368.349-.424.716-.122l2.252 1.851a.81.81 0 0 0 .466.197l2.164.009a.81.81 0 0 1 .509.228c.138.134.221.312.239.503l-.336 1.82a.59.59 0 0 0 .033.232c.026.074.069.142.124.2h.001z"" class=""C""/><path d=""M119.071 225.508c3.876 4.677 9.235 6.633 11.964 4.372l-2.431 2.015c-2.729 2.261-8.087.305-11.963-4.373s-4.803-10.306-2.074-12.567l2.431-2.015c-2.729 2.261-1.802 7.89 2.073 12.568z"" class=""D""/><path d=""M119.071 225.508c3.876 4.677 9.235 6.633 11.964 4.372s1.802-7.89-2.074-12.567-9.234-6.634-11.963-4.373-1.802 7.89 2.073 12.568zm1.247-1.033c2.897 3.496 6.905 4.964 8.947 3.271s1.346-5.904-1.551-9.4-6.9-4.956-8.942-3.263-1.351 5.896 1.546 9.392h0z"" class=""B C""/><path d=""M129.265 227.745c-2.043 1.693-6.051.225-8.947-3.271s-3.589-7.699-1.546-9.392 6.045-.233 8.942 3.263 3.595 7.707 1.551 9.4h0z"" class=""D""/><path d=""M126.705 222.444l1.387 2.463c.235.411.021.716-.355.516l-2.265-1.212c-.145-.077-.292-.083-.369-.008l-1.273 1.114c-.214.177-.689-.141-.809-.553l-.733-2.435a.9.9 0 0 0-.301-.449l-2.173-1.777c-.367-.302-.441-.8-.149-.856l1.806-.331c.06-.01.114-.043.15-.092s.05-.111.041-.171l-.078-2.208c-.009-.377.423-.35.726.016l1.86 2.245a.81.81 0 0 0 .42.282l2.123.419c.186.049.347.163.456.32s.158.349.139.539l-.674 1.723c-.02.077-.023.156-.012.234s.041.152.084.219l-.001.002z"" class=""C""/><path d=""M140.196 225.21c5.607 2.338 11.261 1.576 12.624-1.695l-1.215 2.914c-1.364 3.271-7.017 4.031-12.624 1.694s-9.046-6.888-7.682-10.16l1.215-2.914c-1.364 3.271 2.075 7.823 7.682 10.161h0z"" class=""D""/><path d=""M140.196 225.211c5.607 2.337 11.261 1.576 12.624-1.695s-2.075-7.822-7.682-10.16-11.26-1.577-12.624 1.694 2.075 7.823 7.682 10.161h0zm.623-1.494c4.19 1.747 8.421 1.182 9.442-1.266s-1.555-5.853-5.746-7.599-8.413-1.178-9.434 1.271 1.547 5.848 5.737 7.595l.001-.001z"" class=""B C""/><path d=""M150.261 222.449c-1.021 2.449-5.252 3.013-9.442 1.266s-6.758-5.146-5.737-7.595 5.243-3.018 9.434-1.271 6.767 5.15 5.746 7.6h-.001z"" class=""D""/><path d=""M145.528 218.948l2.374 1.535c.4.254.352.624-.074.622l-2.569-.019c-.165 0-.297.062-.331.164l-.609 1.579c-.107.257-.675.196-.973-.114l-1.781-1.815a.9.9 0 0 0-.475-.257l-2.751-.562c-.465-.097-.763-.503-.53-.688l1.445-1.133c.048-.037.079-.091.088-.151s-.006-.121-.041-.17l-1.096-1.919c-.183-.329.211-.507.65-.324l2.691 1.122c.157.071.334.09.503.054l2.074-.616c.187-.043.383-.017.553.072a.81.81 0 0 1 .374.412l.205 1.839c.018.077.052.149.099.213a.57.57 0 0 0 .176.155h0l-.002.001z"" class=""C""/><path d=""M147.623 266.948c3.037-5.26 3.007-10.965-.062-12.737l2.734 1.579c3.069 1.772 3.098 7.476.061 12.737s-7.992 8.087-11.061 6.315l-2.734-1.579c3.069 1.772 8.025-1.054 11.062-6.315h0z"" class=""F""/><path d=""M147.623 266.948c3.037-5.26 3.007-10.965-.062-12.737s-8.024 1.055-11.061 6.315-3.008 10.965.061 12.737 8.025-1.054 11.062-6.315zm-1.402-.809c2.27-3.932 2.252-8.2-.045-9.526s-6.004.791-8.274 4.723-2.247 8.192.051 9.519 5.998-.785 8.268-4.716h0z"" class=""B E""/><path d=""M146.176 256.612c2.297 1.327 2.315 5.595.045 9.527s-5.971 6.042-8.268 4.716-2.321-5.587-.051-9.519 5.975-6.051 8.273-4.724h.001z"" class=""F""/><path d=""M142.095 260.856l1.827-2.157c.303-.364.664-.269.607.153l-.349 2.546c-.021.163.023.302.121.349l1.488.806c.241.139.107.695-.237.951l-2.028 1.534c-.148.11-.258.263-.316.438l-.91 2.656c-.155.449-.597.692-.75.437l-.938-1.578c-.031-.052-.08-.091-.139-.107a.23.23 0 0 0-.174.02l-2.043.84c-.35.14-.475-.274-.238-.686l1.458-2.525a.81.81 0 0 0 .118-.492l-.345-2.136c-.019-.191.032-.381.142-.539a.81.81 0 0 1 .457-.318l1.85.034c.078-.009.154-.033.223-.071s.129-.091.176-.155h0z"" class=""E""/><use xlink:href=""#B"" class=""F""/><path d=""M124 306.844c6.075 0 11-2.879 11-6.423S130.075 294 124 294s-11 2.877-11 6.421 4.926 6.423 11 6.423zm0-1.619c4.54 0 8.228-2.15 8.228-4.803s-3.688-4.803-8.228-4.803-8.218 2.151-8.218 4.803 3.678 4.803 8.218 4.803z"" class=""B E""/><use xlink:href=""#C"" class=""F""/><use xlink:href=""#D"" class=""E""/><use xlink:href=""#B"" x=""6"" y=""9"" class=""F""/><path d=""M130 315.844c6.075 0 11-2.879 11-6.423S136.075 303 130 303s-11 2.877-11 6.421 4.926 6.423 11 6.423zm0-1.619c4.54 0 8.228-2.15 8.228-4.803s-3.688-4.803-8.228-4.803-8.218 2.151-8.218 4.803 3.678 4.803 8.218 4.803z"" class=""B E""/><use xlink:href=""#C"" x=""6"" y=""9"" class=""F""/><use xlink:href=""#D"" x=""6"" y=""9"" class=""E""/><use xlink:href=""#B"" x=""29"" y=""12"" class=""F""/><path d=""M153 318.844c6.075 0 11-2.879 11-6.423S159.075 306 153 306s-11 2.877-11 6.421 4.926 6.423 11 6.423zm0-1.619c4.54 0 8.228-2.15 8.228-4.803s-3.688-4.803-8.228-4.803-8.218 2.151-8.218 4.803 3.678 4.803 8.218 4.803z"" class=""B E""/><use xlink:href=""#C"" x=""29"" y=""12"" class=""F""/><use xlink:href=""#D"" x=""29"" y=""12"" class=""E""/><use xlink:href=""#E"" class=""F""/><path d=""M165 304.844c6.074 0 11-2.879 11-6.423S171.074 292 165 292s-11 2.877-11 6.421 4.926 6.423 11 6.423zm0-1.619c4.54 0 8.227-2.15 8.227-4.803s-3.687-4.803-8.227-4.803-8.218 2.151-8.218 4.803 3.678 4.803 8.218 4.803z"" class=""B E""/><use xlink:href=""#F"" class=""F""/><path d=""M167.512 297.01l2.781.504c.467.081.565.44.171.603l-2.378.97c-.152.064-.251.172-.242.28l.045 1.691c0 .278-.548.44-.942.27l-2.342-.99c-.17-.073-.357-.092-.538-.054l-2.755.539c-.466.09-.898-.17-.754-.431l.898-1.601c.03-.053.038-.115.023-.174a.23.23 0 0 0-.104-.141l-1.75-1.349c-.295-.233 0-.549.476-.549h2.915c.173.005.343-.045.485-.143l1.678-1.367a.8.8 0 0 1 .537-.147.81.81 0 0 1 .504.237l.897 1.619c.046.064.105.118.172.158a.56.56 0 0 0 .223.075h0z"" class=""E""/><use xlink:href=""#E"" x=""-6"" y=""7"" class=""F""/><path d=""M159 311.844c6.074 0 11-2.879 11-6.423S165.074 299 159 299s-11 2.877-11 6.421 4.926 6.423 11 6.423zm0-1.619c4.54 0 8.227-2.15 8.227-4.803s-3.687-4.803-8.227-4.803-8.218 2.151-8.218 4.803 3.678 4.803 8.218 4.803z"" class=""B E""/><use xlink:href=""#F"" x=""-6"" y=""7"" class=""F""/><path d=""M161.512 304.01l2.781.504c.467.081.565.44.171.603l-2.378.97c-.152.064-.251.172-.242.28l.045 1.691c0 .278-.548.44-.942.27l-2.342-.99c-.17-.073-.357-.092-.538-.054l-2.755.539c-.466.09-.898-.17-.754-.431l.898-1.601c.03-.053.038-.115.023-.174s-.052-.11-.103-.141l-1.75-1.349c-.296-.233 0-.549.476-.549h2.915c.173.005.343-.045.485-.143l1.678-1.367a.8.8 0 0 1 .537-.147.81.81 0 0 1 .504.237l.897 1.619c.046.064.105.118.172.158a.56.56 0 0 0 .223.075h-.001z"" class=""E""/><path d=""M189.764 174.008c0 14.364-19.951 26.008-44.562 26.008-24.343 0-44.127-11.392-44.555-25.54v6.928.356c0 14.38 19.951 26.022 44.562 26.022s44.562-11.641 44.562-26.022v-.356-7.581h-.008l.001.185z"" fill=""#2f2be1"" class=""B""/><path d=""M144.5 194c19.054 0 34.5-8.954 34.5-20s-15.446-20-34.5-20-34.5 8.954-34.5 20 15.446 20 34.5 20z"" fill=""#232277""/><path d=""M189.764 174.008c0 14.364-19.951 26.008-44.562 26.008s-44.562-11.644-44.562-26.008S120.591 148 145.202 148s44.562 11.644 44.562 26.008zM179 174c0 11.046-15.446 20-34.5 20s-34.5-8.954-34.5-20 15.446-20 34.5-20 34.5 8.954 34.5 20z"" fill=""#504df7"" class=""B""/><path d=""M155.683 172.788l-12.188 3.486c-1.635.467-3.657-.207-3.774-1.258l-.864-7.836c-.103-.91.257-1.804 1.034-2.582l.602-.601c.55-.55 1.813-.725 2.816-.39l15.507 5.168c1.007.336 1.373 1.053.823 1.604l-.601.601c-.778.777-1.939 1.404-3.355 1.808z"" fill=""#7b78ff""/><path d=""M133.955 172.081l12.187-3.485c1.635-.467 3.657.207 3.774 1.258l.865 7.835c.103.91-.258 1.805-1.036 2.583l-.601.601c-.55.55-1.813.725-2.817.39l-15.507-5.168c-1.006-.336-1.373-1.054-.823-1.604l.602-.601c.777-.777 1.939-1.404 3.356-1.809z"" fill=""#9fd2eb""/><path d=""M149.915 169.853c-.116-1.051-2.138-1.725-3.773-1.258l-6.91 1.977.492 4.444c.117 1.051 2.139 1.725 3.774 1.258l6.91-1.977-.493-4.444z"" fill=""#11429f""/><defs><filter id=""filter0_f"" x=""-32"" y=""200"" width=""355"" height=""239"" filterUnits=""userSpaceOnUse"" color-interpolation-filters=""sRGB""><feFlood flood-opacity=""0"" result=""BackgroundImageFix""/><feBlend mode=""normal"" in=""SourceGraphic"" in2=""BackgroundImageFix"" result=""shape""/><feGaussianBlur stdDeviation=""35"" result=""effect1_foregroundBlur""/></filter><linearGradient id=""background"" x1=""273.47"" y1=""-13.2813"" x2=""415.619"" y2=""339.655"" gradientUnits=""userSpaceOnUse""><stop stop-color=""#0B0B16""/><stop offset=""1"" class=""G""/></linearGradient><linearGradient id=""divider"" x1=""1.47345e-06"" y1=""409"" x2=""298.995"" y2=""410.864"" gradientUnits=""userSpaceOnUse""><stop class=""I""/><stop offset=""0.5"" class=""J""/><stop offset=""1"" class=""I""/></linearGradient><clipPath id=""mainclip""><rect width=""290"" height=""500"" rx=""20"" fill=""white""/></clipPath><path id=""text-path-a"" d=""M40 10 h228 a12,12 0 0 1 12 12 v364 a12,12 0 0 1 -12 12 h-246 a12 12 0 0 1 -12 -12 v-364 a12 12 0 0 1 12 -12 z"" /><path id=""B"" d=""M124 306.844c6.075 0 11-2.879 11-6.423v3.158c0 3.544-4.925 6.421-11 6.421s-11-2.877-11-6.421v-3.158c0 3.544 4.926 6.423 11 6.423z""/><path id=""C"" d=""M132.227 300.422c0 2.653-3.688 4.803-8.228 4.803s-8.218-2.15-8.218-4.803 3.678-4.803 8.218-4.803 8.228 2.15 8.228 4.803z""/><path id=""D"" d=""M126.512 299.01l2.782.504c.466.081.565.44.171.603l-2.379.97c-.152.064-.25.172-.242.28l.046 1.691c0 .278-.548.44-.942.27l-2.342-.99c-.169-.073-.357-.092-.538-.054l-2.755.539c-.466.09-.898-.17-.754-.431l.898-1.601c.03-.053.038-.115.023-.174s-.052-.11-.103-.141l-1.75-1.349c-.296-.233 0-.549.476-.549h2.915c.173.005.342-.045.485-.143l1.677-1.367a.8.8 0 0 1 .538-.147.81.81 0 0 1 .504.237l.897 1.619a.57.57 0 0 0 .395.233h-.002z""/><path id=""E"" d=""M165 304.844c6.074 0 11-2.879 11-6.423v3.158c0 3.544-4.926 6.421-11 6.421s-11-2.877-11-6.421v-3.158c0 3.544 4.926 6.423 11 6.423z""/><path id=""F"" d=""M173.227 298.422c0 2.653-3.687 4.803-8.227 4.803s-8.218-2.15-8.218-4.803 3.678-4.803 8.218-4.803 8.227 2.15 8.227 4.803z""/></defs></svg>'
            )
        );

        return svg;
    }
}",10052
RealWorld_BA_96_ERC721Permit_RealWord_20240826183318.log,96,ERC721Permit,10900,4953,15853,72.0,0.15356,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.4;

import {EIP712} from '@openzeppelin/contracts/utils/cryptography/draft-EIP712.sol';
import {IERC721Permit} from '../interfaces/IERC721Permit.sol';
import {ERC721} from './ERC721.sol';
import {IERC721Permit} from '../interfaces/IERC721Permit.sol';
import {Counters} from '@openzeppelin/contracts/utils/Counters.sol';
import {ECDSA} from '@openzeppelin/contracts/utils/cryptography/ECDSA.sol';

abstract contract ERC721Permit is IERC721Permit, ERC721, EIP712 {
    using Counters for Counters.Counter;

    mapping(uint256 => Counters.Counter) private _nonces;

    bytes32 public immutable _PERMIT_TYPEHASH =
        keccak256('Permit(address spender,uint256 tokenId,uint256 nonce,uint256 deadline)');

    constructor(string memory name) EIP712(name, '1') {}

    /// @inheritdoc IERC721Permit
    function permit(
        address spender,
        uint256 tokenId,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external override {
        address owner = _owners[tokenId];

        require(block.timestamp <= deadline, 'E602');

        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, spender, tokenId, _useNonce(tokenId), deadline));

        bytes32 hash = _hashTypedDataV4(structHash);

        address signer = ECDSA.recover(hash, v, r, s);
        require(signer != address(0), 'E606');
        require(signer == owner, 'E603');
        require(spender != owner, 'E605');

        _approve(spender, tokenId);
    }

    function nonces(uint256 tokenId) public view virtual returns (uint256) {
        return _nonces[tokenId].current();
    }

    function DOMAIN_SEPARATOR() external view override returns (bytes32) {
        return _domainSeparatorV4();
    }

    function _useNonce(uint256 tokenId) internal virtual returns (uint256 current) {
        Counters.Counter storage nonce = _nonces[tokenId];
        current = nonce.current();
        nonce.increment();
    }
}",485
RealWorld_BA_96_ERC20_RealWord_20240826182850.log,96,ERC20,10431,5289,15720,75.0,0.157935,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.4;

import {IERC20Metadata} from '@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol';

abstract contract ERC20 is IERC20Metadata {
    mapping(address => uint256) public override balanceOf;
    mapping(address => mapping(address => uint256)) public override allowance;

    function transfer(address to, uint256 amount) external override returns (bool) {
        _transfer(msg.sender, to, amount);

        return true;
    }

    function transferFrom(
        address from,
        address to,
        uint256 amount
    ) external override returns (bool) {
        _approve(from, msg.sender, allowance[from][msg.sender] - amount);
        _transfer(from, to, amount);

        return true;
    }

    function approve(address spender, uint256 amount) external override returns (bool) {
        _approve(msg.sender, spender, amount);

        return true;
    }

    function increaseAllowance(address spender, uint256 amount) external returns (bool) {
        _approve(msg.sender, spender, allowance[msg.sender][spender] + amount);

        return true;
    }

    function decreaseAllowance(address spender, uint256 amount) external returns (bool) {
        _approve(msg.sender, spender, allowance[msg.sender][spender] - amount);

        return true;
    }

    function _transfer(
        address from,
        address to,
        uint256 amount
    ) private {
        require(to != address(0), 'E601');

        balanceOf[from] -= amount;
        balanceOf[to] += amount;

        emit Transfer(from, to, amount);
    }

    function _approve(
        address owner,
        address spender,
        uint256 amount
    ) internal {
        allowance[owner][spender] = amount;

        emit Approval(owner, spender, amount);
    }

    function _mint(address to, uint256 amount) internal {
        require(to != address(0), 'E601');

        balanceOf[to] += amount;

        emit Transfer(address(0), to, amount);
    }

    function _burn(address from, uint256 amount) internal {
        balanceOf[from] -= amount;

        emit Transfer(from, address(0), amount);
    }
}",470
RealWorld_BA_96_FullMath_RealWord_20240826171109.log,96,FullMath,22453,5585,28038,80.0,0.223965,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.4;

library FullMath {
    function mul512(uint256 a, uint256 b) internal pure returns (uint256 prod0, uint256 prod1) {
        // 512-bit multiply [prod1 prod0] = a * b
        // Compute the product mod 2**256 and mod 2**256 - 1
        // then use the Chinese Remainder Theorem to reconstruct
        // the 512 bit result. The result is stored in two 256
        // variables such that product = prod1 * 2**256 + prod0
        assembly {
            let mm := mulmod(a, b, not(0))
            prod0 := mul(a, b)
            prod1 := sub(sub(mm, prod0), lt(mm, prod0))
        }
    }
    
    /// @notice Calculates floor(abdenominator) with full precision. Throws if result overflows a uint256 or denominator == 0
    /// @param a The multiplicand
    /// @param b The multiplier
    /// @param denominator The divisor
    /// @return result The 256-bit result
    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv
    function mulDiv(
        uint256 a,
        uint256 b,
        uint256 denominator
    ) internal pure returns (uint256 result) {
        unchecked {
            (uint256 prod0, uint256 prod1) = mul512(a, b);

            // Handle non-overflow cases, 256 by 256 division
            if (prod1 == 0) {
                require(denominator != 0);
                assembly {
                    result := div(prod0, denominator)
                }
                return result;
            }

            // Make sure the result is less than 2**256.
            // Also prevents denominator == 0
            require(denominator > prod1);

            ///////////////////////////////////////////////
            // 512 by 256 division.
            ///////////////////////////////////////////////

            // Make division exact by subtracting the remainder from [prod1 prod0]
            // Compute remainder using mulmod
            uint256 remainder;
            assembly {
                remainder := mulmod(a, b, denominator)
            }
            // Subtract 256 bit number from 512 bit number
            assembly {
                prod1 := sub(prod1, gt(remainder, prod0))
                prod0 := sub(prod0, remainder)
            }

            // Factor powers of two out of denominator
            // Compute largest power of two divisor of denominator.
            // Always >= 1.
            uint256 twos;
            twos = (0 - denominator) & denominator;
            // Divide denominator by power of two
            assembly {
                denominator := div(denominator, twos)
            }

            // Divide [prod1 prod0] by the factors of two
            assembly {
                prod0 := div(prod0, twos)
            }
            // Shift in bits from prod1 into prod0. For this we need
            // to flip `twos` such that it is 2**256 / twos.
            // If twos is zero, then it becomes one
            assembly {
                twos := add(div(sub(0, twos), twos), 1)
            }
            prod0 |= prod1 * twos;    

            // Invert denominator mod 2**256
            // Now that denominator is an odd number, it has an inverse
            // modulo 2**256 such that denominator * inv = 1 mod 2**256.
            // Compute the inverse by starting with a seed that is correct
            // correct for four bits. That is, denominator * inv = 1 mod 2**4
            uint256 inv;
            inv = (3 * denominator) ^ 2;

            // Now use Newton-Raphson iteration to improve the precision.
            // Thanks to Hensel's lifting lemma, this also works in modular
            // arithmetic, doubling the correct bits in each step.
            inv *= 2 - denominator * inv; // inverse mod 2**8
            inv *= 2 - denominator * inv; // inverse mod 2**16
            inv *= 2 - denominator * inv; // inverse mod 2**32
            inv *= 2 - denominator * inv; // inverse mod 2**64
            inv *= 2 - denominator * inv; // inverse mod 2**128
            inv *= 2 - denominator * inv; // inverse mod 2**256

            // Because the division is now exact we can divide by multiplying
            // with the modular inverse of denominator. This will give us the
            // correct result modulo 2**256. Since the precoditions guarantee
            // that the outcome is less than 2**256, this is the final result.
            // We don't need to compute the high bits of the result and prod1
            // is no longer required.
            result = prod0 * inv;

            return result;
        }
    }

    /// @notice Calculates ceil(abdenominator) with full precision. Throws if result overflows a uint256 or denominator == 0
    /// @param a The multiplicand
    /// @param b The multiplier
    /// @param denominator The divisor
    /// @return result The 256-bit result
    function mulDivUp(
        uint256 a,
        uint256 b,
        uint256 denominator
    ) internal pure returns (uint256 result) {
        result = mulDiv(a, b, denominator);
        if (mulmod(a, b, denominator) != 0) result++;
    }
}",1195
RealWorld_BA_96_ERC20Permit_RealWord_20240826183007.log,96,ERC20Permit,12580,5362,17942,85.0,0.17014,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.4;

import {IERC20Permit} from '../interfaces/IERC20Permit.sol';
import {ERC20} from './ERC20.sol';
import {EIP712} from '@openzeppelin/contracts/utils/cryptography/draft-EIP712.sol';
import {ECDSA} from '@openzeppelin/contracts/utils/cryptography/ECDSA.sol';
import {Counters} from '@openzeppelin/contracts/utils/Counters.sol';

abstract contract ERC20Permit is IERC20Permit, ERC20, EIP712 {
    using Counters for Counters.Counter;

    mapping(address => Counters.Counter) private _nonces;

    // solhint-disable-next-line var-name-mixedcase
    bytes32 private immutable _PERMIT_TYPEHASH =
        keccak256('Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)');

    /**
     * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `""1""`.
     *
     * It's a good idea to use the same `name` that is defined as the ERC20 token name.
     */
    constructor(string memory name) EIP712(name, '1') {}

    /**
     * @dev See {IERC20Permit-permit}.
     */
    function permit(
        address owner,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) public virtual override {
        require(block.timestamp <= deadline, 'E602');

        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));

        bytes32 hash = _hashTypedDataV4(structHash);

        address signer = ECDSA.recover(hash, v, r, s);
        require(signer == owner, 'E603');

        _approve(owner, spender, value);
    }

    /**
     * @dev See {IERC20Permit-nonces}.
     */
    function nonces(address owner) public view virtual override returns (uint256) {
        return _nonces[owner].current();
    }

    /**
     * @dev See {IERC20Permit-DOMAIN_SEPARATOR}.
     */
    // solhint-disable-next-line func-name-mixedcase
    function DOMAIN_SEPARATOR() external view override returns (bytes32) {
        return _domainSeparatorV4();
    }

    /**
     * @dev ""Consume a nonce"": return the current value and increment.
     *
     * _Available since v4.1._
     */
    function _useNonce(address owner) internal virtual returns (uint256 current) {
        Counters.Counter storage nonce = _nonces[owner];
        current = nonce.current();
        nonce.increment();
    }
}",605
RealWorld_BA_96_IFactory_RealWord_20240826171844.log,96,IFactory,13688,5337,19025,81.0,0.17518,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.4;

import {IPair} from './IPair.sol';
import {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';

interface IFactory {
    /* ===== EVENT ===== */

    /// @dev Emits when a new Timeswap Pair contract is created.
    /// @param asset The address of the ERC20 being lent and borrowed.
    /// @param collateral The address of the ERC20 used as collateral.
    /// @param pair The address of the Timeswap Pair contract created.
    event CreatePair(IERC20 indexed asset, IERC20 indexed collateral, IPair pair);

    /// @dev Emits when a new pending owner is set.
    /// @param pendingOwner The address of the new pending owner.
    event SetOwner(address indexed pendingOwner);

    /// @dev Emits when the pending owner has accepted being the new owner.
    /// @param owner The address of the new owner.
    event AcceptOwner(address indexed owner);

    /* ===== VIEW ===== */

    /// @dev Return the address that receives the protocol fee.
    /// @return The address of the owner.
    function owner() external view returns (address);

    /// @dev Return the new pending address to replace the owner.
    /// @return The address of the pending owner.
    function pendingOwner() external view returns (address);

    /// @dev Return the fee per second earned by liquidity providers.
    /// @return The fee following UQ0.40 format.
    function fee() external view returns (uint16);

    /// @dev Return the protocol fee per second earned by the owner.
    /// @return The protocol fee per second following UQ0.40 format.
    function protocolFee() external view returns (uint16);

    /// @dev Returns the address of a deployed pair.
    /// @param asset The address of the ERC20 being lent and borrowed.
    /// @param collateral The address of the ERC20 used as collateral.
    /// @return pair The address of the Timeswap Pair contract.
    function getPair(IERC20 asset, IERC20 collateral) external view returns (IPair pair);

    /* ===== UPDATE ===== */

    /// @dev Creates a Timeswap Pool based on ERC20 pair parameters.
    /// @dev Cannot create a Timeswap Pool with the same pair parameters.
    /// @param asset The address of the ERC20 being lent and borrowed.
    /// @param collateral The address of the ERC20 as the collateral.
    /// @return pair The address of the Timeswap Pair contract.
    function createPair(IERC20 asset, IERC20 collateral) external returns (IPair pair);

    /// @dev Set the pending owner of the factory.
    /// @dev Can only be called by the current owner.
    /// @param _pendingOwner the chosen pending owner.
    function setOwner(address _pendingOwner) external;

    /// @dev Set the pending owner as the owner of the factory.
    /// @dev Reset the pending owner to zero.
    /// @dev Can only be called by the pending owner.
    function acceptOwner() external;
}",652
RealWorld_BA_96_IDeployPair_RealWord_20240826184737.log,96,IDeployPair,3926,4476,8402,69.0,0.10915,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.4;

import {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';

interface IDeployPair {
    struct DeployPair {
        IERC20 asset;
        IERC20 collateral;
    }
}",65
RealWorld_BA_96_Withdraw_RealWord_20240826180747.log,96,Withdraw,16498,5413,21911,87.0,0.19075,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.4;

import {IConvenience} from '../interfaces/IConvenience.sol';
import {IFactory} from '@timeswap-labs/timeswap-v1-core/contracts/interfaces/IFactory.sol';
import {IWETH} from '../interfaces/IWETH.sol';
import {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import {IPair} from '@timeswap-labs/timeswap-v1-core/contracts/interfaces/IPair.sol';
import {IWithdraw} from '../interfaces/IWithdraw.sol';
import {ETH} from './ETH.sol';

library Withdraw {
    function collect(
        mapping(IERC20 => mapping(IERC20 => mapping(uint256 => IConvenience.Native))) storage natives,
        IFactory factory,
        IWithdraw.Collect calldata params
    ) external returns (IPair.Tokens memory tokensOut) {
        tokensOut = _collect(
            natives,
            IWithdraw._Collect(
                factory,
                params.asset,
                params.collateral,
                params.maturity,
                params.assetTo,
                params.collateralTo,
                params.claimsIn
            )
        );
    }

    function collectETHAsset(
        mapping(IERC20 => mapping(IERC20 => mapping(uint256 => IConvenience.Native))) storage natives,
        IFactory factory,
        IWETH weth,
        IWithdraw.CollectETHAsset calldata params
    ) external returns (IPair.Tokens memory tokensOut) {
        tokensOut = _collect(
            natives,
            IWithdraw._Collect(
                factory,
                weth,
                params.collateral,
                params.maturity,
                address(this),
                params.collateralTo,
                params.claimsIn
            )
        );

        if (tokensOut.asset != 0) {
            weth.withdraw(tokensOut.asset);
            ETH.transfer(params.assetTo, tokensOut.asset);
        }
    }

    function collectETHCollateral(
        mapping(IERC20 => mapping(IERC20 => mapping(uint256 => IConvenience.Native))) storage natives,
        IFactory factory,
        IWETH weth,
        IWithdraw.CollectETHCollateral calldata params
    ) external returns (IPair.Tokens memory tokensOut) {
        tokensOut = _collect(
            natives,
            IWithdraw._Collect(
                factory,
                params.asset,
                weth,
                params.maturity,
                params.assetTo,
                address(this),
                params.claimsIn
            )
        );

        if (tokensOut.collateral != 0) {
            weth.withdraw(tokensOut.collateral);
            ETH.transfer(params.collateralTo, tokensOut.collateral);
        }
    }

    function _collect(
        mapping(IERC20 => mapping(IERC20 => mapping(uint256 => IConvenience.Native))) storage natives,
        IWithdraw._Collect memory params
    ) private returns (IPair.Tokens memory tokensOut) {
        IPair pair = params.factory.getPair(params.asset, params.collateral);
        require(address(pair) != address(0), 'E501');

        IConvenience.Native memory native = natives[params.asset][params.collateral][params.maturity];
        require(address(native.liquidity) != address(0), 'E502');

        tokensOut = pair.withdraw(
            IPair.WithdrawParam(params.maturity, params.assetTo, params.collateralTo, params.claimsIn)
        );

        if (params.claimsIn.bondInterest != 0) native.bondInterest.burn(msg.sender, params.claimsIn.bondInterest);
        if (params.claimsIn.bondPrincipal != 0) native.bondPrincipal.burn(msg.sender, params.claimsIn.bondPrincipal);
        if (params.claimsIn.insuranceInterest != 0)
            native.insuranceInterest.burn(msg.sender, params.claimsIn.insuranceInterest);
        if (params.claimsIn.insurancePrincipal != 0)
            native.insurancePrincipal.burn(msg.sender, params.claimsIn.insurancePrincipal);
    }
}",842
RealWorld_BA_96_BorrowMathCallee_RealWord_20240826173809.log,96,BorrowMathCallee,7525,5262,12787,81.0,0.142865,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.4;

import {BorrowMath} from '../libraries/BorrowMath.sol';
import {IPair} from '@timeswap-labs/timeswap-v1-core/contracts/interfaces/IPair.sol';

contract BorrowMathCallee {
    function givenDebt(
        IPair pair,
        uint256 maturity,
        uint112 assetOut,
        uint112 debtIn
    )
        public
        view
        returns (
            uint256,
            uint112,
            uint112
        )
    {
        return BorrowMath.givenDebt(pair, maturity, assetOut, debtIn);
    }

    function givenCollateral(
        IPair pair,
        uint256 maturity,
        uint112 assetOut,
        uint112 collateralIn
    )
        public
        view
        returns (
            uint256,
            uint112,
            uint112
        )
    {
        return BorrowMath.givenCollateral(pair, maturity, assetOut, collateralIn);
    }

    function givenPercent(
        IPair pair,
        uint256 maturity,
        uint112 assetOut,
        uint40 percent
    )
        public
        view
        returns (
            uint256,
            uint112,
            uint112
        )
    {
        return BorrowMath.givenPercent(pair, maturity, assetOut, percent);
    }
}",282
RealWorld_BA_96_IERC721Permit_RealWord_20240826184253.log,96,IERC721Permit,8167,5059,13226,67.0,0.142015,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.4;

import {IERC721Extended} from './IERC721Extended.sol';

interface IERC721Permit is IERC721Extended {
    // /// @notice The permit typehash used in the permit signature
    // /// @return The typehash for the permit
    // function PERMIT_TYPEHASH() external pure returns (bytes32);

    /// @notice The domain separator used in the permit signature
    /// @return The domain seperator used in encoding of permit signature
    function DOMAIN_SEPARATOR() external view returns (bytes32);

    /// @notice Approve of a specific token ID for spending by spender via signature
    /// @param spender The account that is being approved
    /// @param tokenId The ID of the token that is being approved for spending
    /// @param deadline The deadline timestamp by which the call must be mined for the approve to work
    /// @param v Must produce valid secp256k1 signature from the holder along with `r` and `s`
    /// @param r Must produce valid secp256k1 signature from the holder along with `v` and `s`
    /// @param s Must produce valid secp256k1 signature from the holder along with `r` and `v`
    function permit(
        address spender,
        uint256 tokenId,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external;
}",309
RealWorld_BA_96_IERC721Extended_RealWord_20240826184626.log,96,IERC721Extended,4639,4534,9173,68.0,0.113875,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.4;

import {IERC721Metadata} from '@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol';
import {IERC721Enumerable} from '@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol';

interface IERC721Extended is IERC721Metadata, IERC721Enumerable {
    function assetDecimals() external view returns (uint8);

    function collateralDecimals() external view returns (uint8);
}",111
RealWorld_BA_96_Callback_RealWord_20240826171232.log,96,Callback,12120,5220,17340,86.0,0.165,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.4;

import {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import {ITimeswapMintCallback} from '../interfaces/callback/ITimeswapMintCallback.sol';
import {ITimeswapLendCallback} from '../interfaces/callback/ITimeswapLendCallback.sol';
import {ITimeswapBorrowCallback} from '../interfaces/callback/ITimeswapBorrowCallback.sol';
import {ITimeswapPayCallback} from '../interfaces/callback/ITimeswapPayCallback.sol';
import {SafeBalance} from './SafeBalance.sol';
import {SafeCast} from './SafeCast.sol';

library Callback {
    using SafeBalance for IERC20;
    using SafeCast for uint256;

    function mint(
        IERC20 asset,
        IERC20 collateral,
        uint256 assetIn,
        uint112 collateralIn,
        bytes calldata data
    ) internal {
        uint256 assetReserve = asset.safeBalance();
        uint256 collateralReserve = collateral.safeBalance();
        ITimeswapMintCallback(msg.sender).timeswapMintCallback(assetIn, collateralIn, data);
        uint256 _assetReserve = asset.safeBalance();
        uint256 _collateralReserve = collateral.safeBalance();
        require(_assetReserve >= assetReserve + assetIn, 'E304');
        require(_collateralReserve >= collateralReserve + collateralIn, 'E305');
    }

    function lend(
        IERC20 asset,
        uint256 assetIn,
        bytes calldata data
    ) internal {
        uint256 assetReserve = asset.safeBalance();
        ITimeswapLendCallback(msg.sender).timeswapLendCallback(assetIn, data);
        uint256 _assetReserve = asset.safeBalance();
        require(_assetReserve >= assetReserve + assetIn, 'E304');
    }

    function borrow(
        IERC20 collateral,
        uint112 collateralIn,
        bytes calldata data
    ) internal {
        uint256 collateralReserve = collateral.safeBalance();
        ITimeswapBorrowCallback(msg.sender).timeswapBorrowCallback(collateralIn, data);
        uint256 _collateralReserve = collateral.safeBalance();
        require(_collateralReserve >= collateralReserve + collateralIn, 'E305');
    }
    
    function pay(
        IERC20 asset,
        uint128 assetIn,
        bytes calldata data
    ) internal {
        uint256 assetReserve = asset.safeBalance();
        ITimeswapPayCallback(msg.sender).timeswapPayCallback(assetIn, data);
        uint256 _assetReserve = asset.safeBalance();
        require(_assetReserve >= assetReserve + assetIn, 'E304');
    }
}",584
RealWorld_BA_96_NFTTokenURIScaffold_RealWord_20240826180059.log,96,NFTTokenURIScaffold,47260,5911,53171,88.0,0.35452,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.4;

import {IPair} from '@timeswap-labs/timeswap-v1-core/contracts/interfaces/IPair.sol';
import {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import {SafeMetadata} from './SafeMetadata.sol';
import {Strings} from '@openzeppelin/contracts/utils/Strings.sol';
import {DateTime} from './DateTime.sol';
import './Base64.sol';
import {NFTSVG} from './NFTSVG.sol';

library NFTTokenURIScaffold {
    using SafeMetadata for IERC20;
    using Strings for uint256;

    function tokenURI(
        uint256 id,
        IPair pair,
        IPair.Due memory due,
        uint256 maturity
    ) public view returns (string memory) {
        string memory uri = constructTokenSVG(
            address(pair.asset()),
            address(pair.collateral()),
            id.toString(),
            weiToPrecisionString(due.debt, pair.asset().safeDecimals()),
            weiToPrecisionString(due.collateral, pair.collateral().safeDecimals()),
            getReadableDateString(maturity),
            maturity
        );

        string memory description = string(
            abi.encodePacked(
                'This collateralized debt position represents a debt of ',
                weiToPrecisionString(due.debt, pair.asset().safeDecimals()),
                ' ',
                pair.asset().safeSymbol(),
                ' borrowed against a collateral of ',
                weiToPrecisionString(due.collateral, pair.collateral().safeDecimals()),
                ' ',
                pair.collateral().safeSymbol(),
                '. This position will expire on ',
                maturity.toString(),
                ' unix epoch time.\\nThe owner of this NFT has the option to pay the debt before maturity time to claim the locked collateral. In case the owner choose to default on the debt payment, the collateral will be forfeited'
            )
        );
        description = string(
            abi.encodePacked(
                description,
                '\\n\\nAsset Address: ',
                addressToString(address(pair.asset())),
                '\\nCollateral Address: ',
                addressToString(address(pair.collateral())),
                '\\nDebt Required: ',
                weiToPrecisionLongString(due.debt, pair.asset().safeDecimals()),
                ' ',
                IERC20(pair.asset()).safeSymbol(),
                '\\nCollateral Locked: ',
                weiToPrecisionLongString(due.collateral, pair.collateral().safeDecimals()),
                ' ',
                IERC20(pair.collateral()).safeSymbol()
            )
        );

        string memory name = 'Timeswap Collateralized Debt';

        return (constructTokenURI(name, description, uri));
    }

    function constructTokenURI(
        string memory name,
        string memory description,
        string memory imageSVG
    ) internal pure returns (string memory) {
        return
            string(
                abi.encodePacked(
                    'data:application/json;base64,',
                    Base64.encode(
                        bytes(
                            abi.encodePacked(
                                '{""name"":""',
                                name,
                                '"", ""description"":""',
                                description,
                                '"", ""image"": ""',
                                'data:image/svg+xml;base64,',
                                Base64.encode(bytes(imageSVG)),
                                '""}'
                            )
                        )
                    )
                )
            );
    }

    function constructTokenSVG(
        address asset,
        address collateral,
        string memory tokenId,
        string memory assetAmount,
        string memory collateralAmount,
        string memory maturityDate,
        uint256 maturityTimestamp
    ) internal view returns (string memory) {
        NFTSVG.SVGParams memory params = NFTSVG.SVGParams({
            tokenId: tokenId,
            svgTitle: string(
                abi.encodePacked(
                    parseSymbol(IERC20(asset).safeSymbol()),
                    '/',
                    parseSymbol(IERC20(collateral).safeSymbol())
                )
            ),
            assetInfo: string(abi.encodePacked(parseSymbol(IERC20(asset).safeSymbol()), ': ', addressToString(asset))),
            collateralInfo: string(
                abi.encodePacked(parseSymbol(IERC20(collateral).safeSymbol()), ': ', addressToString(collateral))
            ),
            debtRequired: string(abi.encodePacked(assetAmount, ' ', parseSymbol(IERC20(asset).safeSymbol()))),
            collateralLocked: string(
                abi.encodePacked(collateralAmount, ' ', parseSymbol(IERC20(collateral).safeSymbol()))
            ),
            maturityDate: maturityDate,
            isMatured: block.timestamp > maturityTimestamp,
            maturityTimestampString: maturityTimestamp.toString(),
            tokenColors: getSVGCData(asset, collateral)
        });

        return NFTSVG.constructSVG(params);
    }

    function weiToPrecisionLongString(uint256 weiAmt, uint256 decimal) public pure returns (string memory) {
        if (decimal == 0) {
            return string(abi.encodePacked(weiAmt.toString(), '.00'));
        }

        uint256 significantDigits = weiAmt / (10**decimal);
        uint256 precisionDigits = weiAmt % (10**(decimal));

        if (precisionDigits == 0) {
            return string(abi.encodePacked(significantDigits.toString(), '.00'));
        }

        string memory precisionDigitsString = toStringTrimmed(precisionDigits);
        uint256 lengthDiff = decimal - bytes(precisionDigits.toString()).length;
        for (uint256 i; i < lengthDiff; i++) {
            precisionDigitsString = string(abi.encodePacked('0', precisionDigitsString));
        }

        return string(abi.encodePacked(significantDigits.toString(), '.', precisionDigitsString));
    }

    function weiToPrecisionString(uint256 weiAmt, uint256 decimal) public pure returns (string memory) {
        if (decimal == 0) {
            return string(abi.encodePacked(weiAmt.toString(), '.00'));
        }

        uint256 significantDigits = weiAmt / (10**decimal);
        if (significantDigits > 1e9) {
            string memory weiAmtString = weiAmt.toString();
            uint256 len = bytes(weiAmtString).length - 9;
            weiAmt = weiAmt / (10**len);
            return string(abi.encodePacked(weiAmt.toString(), '...'));
        }
        uint256 precisionDigits = weiAmt % (10**(decimal));
        precisionDigits = precisionDigits / (10**(decimal - 4));

        if (precisionDigits == 0) {
            return string(abi.encodePacked(significantDigits.toString(), '.00'));
        }

        string memory precisionDigitsString = toStringTrimmed(precisionDigits);
        uint256 lengthDiff = 4 - bytes(precisionDigits.toString()).length;
        for (uint256 i; i < lengthDiff; i++) {
            precisionDigitsString = string(abi.encodePacked('0', precisionDigitsString));
        }

        return string(abi.encodePacked(significantDigits.toString(), '.', precisionDigitsString));
    }

    function toStringTrimmed(uint256 value) internal pure returns (string memory) {
        if (value == 0) {
            return '0';
        }
        uint256 temp = value;
        uint256 digits;
        uint256 flag;
        while (temp != 0) {
            if (flag == 0 && temp % 10 == 0) {
                temp /= 10;
                continue;
            } else if (flag == 0 && temp % 10 != 0) {
                flag++;
                digits++;
            } else {
                digits++;
            }

            temp /= 10;
        }
        bytes memory buffer = new bytes(digits);
        flag = 0;
        while (value != 0) {
            if (flag == 0 && value % 10 == 0) {
                value /= 10;
                continue;
            } else if (flag == 0 && value % 10 != 0) {
                flag++;
                digits -= 1;
                buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));
            } else {
                digits -= 1;
                buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));
            }

            value /= 10;
        }
        return string(buffer);
    }

    function addressToString(address _addr) public pure returns (string memory) {
        bytes memory data = abi.encodePacked(_addr);
        bytes memory alphabet = '0123456789abcdef';

        bytes memory str = new bytes(2 + data.length * 2);
        str[0] = '0';
        str[1] = 'x';
        for (uint256 i; i < data.length; i++) {
            str[2 + i * 2] = alphabet[uint256(uint8(data[i] >> 4))];
            str[3 + i * 2] = alphabet[uint256(uint8(data[i] & 0x0f))];
        }
        return string(str);
    }

    function getSlice(
        uint256 begin,
        uint256 end,
        string memory text
    ) public pure returns (string memory) {
        bytes memory a = new bytes(end - begin + 1);
        for (uint256 i; i <= end - begin; i++) {
            a[i] = bytes(text)[i + begin - 1];
        }
        return string(a);
    }

    function parseSymbol(string memory symbol) public pure returns (string memory) {
        if (bytes(symbol).length > 5) {
            return getSlice(1, 5, symbol);
        }
        return symbol;
    }

    function getMonthString(uint256 _month) public pure returns (string memory) {
        string[12] memory months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
        return months[_month];
    }

    function getReadableDateString(uint256 timestamp) public pure returns (string memory) {
        (uint256 year, uint256 month, uint256 day, uint256 hour, uint256 minute, uint256 second) = DateTime
            .timestampToDateTime(timestamp);

        string memory result = string(
            abi.encodePacked(
                day.toString(),
                ' ',
                getMonthString(month - 1),
                ' ',
                year.toString(),
                ', ',
                padWithZero(hour),
                ':',
                padWithZero(minute),
                ':',
                padWithZero(second),
                ' UTC'
            )
        );
        return result;
    }

    function padWithZero(uint256 value) public pure returns (string memory) {
        if (value < 10) {
            return string(abi.encodePacked('0', value.toString()));
        }
        return value.toString();
    }

    function getLightColor(address token) public pure returns (string memory) {
        string[15] memory lightColors = [
            'F7BAF7',
            'F7C8BA',
            'FAE2BE',
            'BAE1F7',
            'EBF7BA',
            'CEF7BA',
            'CED2EF',
            'CABAF7',
            'BAF7E5',
            'BACFF7',
            'F7BAE3',
            'F7E9BA',
            'E0BAF7',
            'F7BACF',
            'FFFFFF'
        ];
        uint160 tokenValue = uint160(token) % 15;
        return (lightColors[tokenValue]);
    }

    function getDarkColor(address token) public pure returns (string memory) {
        string[15] memory darkColors = [
            'DF51EC',
            'EC7651',
            'ECAE51',
            '51B4EC',
            'A4C327',
            '59C327',
            '5160EC',
            '7951EC',
            '27C394',
            '5185EC',
            'EC51B8',
            'F4CB3A',
            'B151EC',
            'EC5184',
            'C5C0C2'
        ];
        uint160 tokenValue = uint160(token) % 15;
        return (darkColors[tokenValue]);
    }

    function getSVGCData(address asset, address collateral) public pure returns (string memory) {
        string memory token0LightColor = string(abi.encodePacked('.C{fill:#', getLightColor(asset), '}'));
        string memory token0DarkColor = string(abi.encodePacked('.D{fill:#', getDarkColor(asset), '}'));
        string memory token1LightColor = string(abi.encodePacked('.E{fill:#', getLightColor(collateral), '}'));
        string memory token1DarkColor = string(abi.encodePacked('.F{fill:#', getDarkColor(collateral), '}'));

        return string(abi.encodePacked(token0LightColor, token0DarkColor, token1LightColor, token1DarkColor));
    }
}",2712
RealWorld_BA_96_SquareRoot_RealWord_20240826175629.log,96,SquareRoot,5369,3610,8979,61.0,0.099045,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.4;

library SquareRoot {
    // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)
    function sqrt(uint256 x) internal pure returns (uint256 y) {
        uint256 z = (x + 1) / 2;
        y = x;
        while (z < y) {
            y = z;
            z = (x / z + z) / 2;
        }
    }

    function sqrtUp(uint256 x) internal pure returns (uint256 y) {
        y = sqrt(x);
        if (x % y != 0) y++;
    }
}",154
RealWorld_BA_96_IMint_RealWord_20240826184848.log,96,IMint,22328,5622,27950,85.0,0.22408,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.4;

import {IConvenience} from './IConvenience.sol';
import {IFactory} from '@timeswap-labs/timeswap-v1-core/contracts/interfaces/IFactory.sol';
import {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import {IPair} from '@timeswap-labs/timeswap-v1-core/contracts/interfaces/IPair.sol';

interface IMint {
    struct NewLiquidity {
        IERC20 asset;
        IERC20 collateral;
        uint256 maturity;
        address liquidityTo;
        address dueTo;
        uint112 assetIn;
        uint112 debtIn;
        uint112 collateralIn;
        uint256 deadline;
    }

    struct NewLiquidityETHAsset {
        IERC20 collateral;
        uint256 maturity;
        address liquidityTo;
        address dueTo;
        uint112 debtIn;
        uint112 collateralIn;
        uint256 deadline;
    }

    struct NewLiquidityETHCollateral {
        IERC20 asset;
        uint256 maturity;
        address liquidityTo;
        address dueTo;
        uint112 assetIn;
        uint112 debtIn;
        uint256 deadline;
    }

    struct _NewLiquidity {
        IConvenience convenience;
        IFactory factory;
        IERC20 asset;
        IERC20 collateral;
        uint256 maturity;
        address assetFrom;
        address collateralFrom;
        address liquidityTo;
        address dueTo;
        uint112 assetIn;
        uint112 debtIn;
        uint112 collateralIn;
        uint256 deadline;
    }

    struct LiquidityGivenAsset {
        IERC20 asset;
        IERC20 collateral;
        uint256 maturity;
        address liquidityTo;
        address dueTo;
        uint112 assetIn;
        uint256 minLiquidity;
        uint112 maxDebt;
        uint112 maxCollateral;
        uint256 deadline;
    }

    struct LiquidityGivenAssetETHAsset {
        IERC20 collateral;
        uint256 maturity;
        address liquidityTo;
        address dueTo;
        uint256 minLiquidity;
        uint112 maxDebt;
        uint112 maxCollateral;
        uint256 deadline;
    }

    struct LiquidityGivenAssetETHCollateral {
        IERC20 asset;
        uint256 maturity;
        address liquidityTo;
        address dueTo;
        uint112 assetIn;
        uint256 minLiquidity;
        uint112 maxDebt;
        uint256 deadline;
    }

    struct _LiquidityGivenAsset {
        IConvenience convenience;
        IFactory factory;
        IERC20 asset;
        IERC20 collateral;
        uint256 maturity;
        address assetFrom;
        address collateralFrom;
        address liquidityTo;
        address dueTo;
        uint112 assetIn;
        uint256 minLiquidity;
        uint112 maxDebt;
        uint112 maxCollateral;
        uint256 deadline;
    }

    struct LiquidityGivenDebt {
        IERC20 asset;
        IERC20 collateral;
        uint256 maturity;
        address liquidityTo;
        address dueTo;
        uint112 debtIn;
        uint256 minLiquidity;
        uint112 maxAsset;
        uint112 maxCollateral;
        uint256 deadline;
    }

    struct LiquidityGivenDebtETHAsset {
        IERC20 collateral;
        uint256 maturity;
        address liquidityTo;
        address dueTo;
        uint112 debtIn;
        uint256 minLiquidity;
        uint112 maxCollateral;
        uint256 deadline;
    }

    struct LiquidityGivenDebtETHCollateral {
        IERC20 asset;
        uint256 maturity;
        address liquidityTo;
        address dueTo;
        uint112 debtIn;
        uint256 minLiquidity;
        uint112 maxAsset;
        uint256 deadline;
    }

    struct _LiquidityGivenDebt {
        IConvenience convenience;
        IFactory factory;
        IERC20 asset;
        IERC20 collateral;
        uint256 maturity;
        address assetFrom;
        address collateralFrom;
        address liquidityTo;
        address dueTo;
        uint112 debtIn;
        uint256 minLiquidity;
        uint112 maxAsset;
        uint112 maxCollateral;
        uint256 deadline;
    }

    struct LiquidityGivenCollateral {
        IERC20 asset;
        IERC20 collateral;
        uint256 maturity;
        address liquidityTo;
        address dueTo;
        uint112 collateralIn;
        uint256 minLiquidity;
        uint112 maxAsset;
        uint112 maxDebt;
        uint256 deadline;
    }

    struct LiquidityGivenCollateralETHAsset {
        IERC20 collateral;
        uint256 maturity;
        address liquidityTo;
        address dueTo;
        uint112 collateralIn;
        uint256 minLiquidity;
        uint112 maxDebt;
        uint256 deadline;
    }

    struct LiquidityGivenCollateralETHCollateral {
        IERC20 asset;
        uint256 maturity;
        address liquidityTo;
        address dueTo;
        uint256 minLiquidity;
        uint112 maxAsset;
        uint112 maxDebt;
        uint256 deadline;
    }

    struct _LiquidityGivenCollateral {
        IConvenience convenience;
        IFactory factory;
        IERC20 asset;
        IERC20 collateral;
        uint256 maturity;
        address assetFrom;
        address collateralFrom;
        address liquidityTo;
        address dueTo;
        uint112 collateralIn;
        uint256 minLiquidity;
        uint112 maxAsset;
        uint112 maxDebt;
        uint256 deadline;
    }

    struct _Mint {
        IConvenience convenience;
        IPair pair;
        IERC20 asset;
        IERC20 collateral;
        uint256 maturity;
        address assetFrom;
        address collateralFrom;
        address liquidityTo;
        address dueTo;
        uint112 xIncrease;
        uint112 yIncrease;
        uint112 zIncrease;
        uint256 deadline;
    }
}",1262
RealWorld_BA_96_IDeployNatives_RealWord_20240826183432.log,96,IDeployNatives,4171,4538,8709,83.0,0.111615,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.4;

import {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';

interface IDeployNatives {
    struct DeployNatives {
        IERC20 asset;
        IERC20 collateral;
        uint256 maturity;
        uint256 deadline;
    }
}",77
RealWorld_BA_96_BorrowMath_RealWord_20240826181042.log,96,BorrowMath,27178,5931,33109,97.0,0.25451,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.4;

import {IPair} from '@timeswap-labs/timeswap-v1-core/contracts/interfaces/IPair.sol';
import {Math} from '@timeswap-labs/timeswap-v1-core/contracts/libraries/Math.sol';
import {SquareRoot} from './SquareRoot.sol';
import {FullMath} from '@timeswap-labs/timeswap-v1-core/contracts/libraries/FullMath.sol';
import {ConstantProduct} from './ConstantProduct.sol';
import {SafeCast} from '@timeswap-labs/timeswap-v1-core/contracts/libraries/SafeCast.sol';

library BorrowMath {
    using Math for uint256;
    using SquareRoot for uint256;
    using FullMath for uint256;
    using ConstantProduct for IPair;
    using ConstantProduct for ConstantProduct.CP;
    using SafeCast for uint256;

    uint256 private constant BASE = 0x10000000000;

    function givenDebt(
        IPair pair,
        uint256 maturity,
        uint112 assetOut,
        uint112 debtIn
    )
        internal
        view
        returns (
            uint112 xDecrease,
            uint112 yIncrease,
            uint112 zIncrease
        )
    {
        ConstantProduct.CP memory cp = pair.get(maturity);

        xDecrease = getX(pair, maturity, assetOut);

        uint256 xReserve = cp.x;
        xReserve -= xDecrease;

        uint256 _yIncrease = debtIn;
        _yIncrease -= xDecrease;
        _yIncrease <<= 32;
        uint256 denominator = maturity;
        denominator -= block.timestamp;
        _yIncrease /= denominator;
        yIncrease = _yIncrease.toUint112();

        uint256 yReserve = cp.y;
        yReserve += _yIncrease;

        uint256 zReserve = cp.x;
        zReserve *= cp.y;
        denominator = xReserve;
        denominator *= yReserve;
        zReserve = zReserve.mulDivUp(cp.z, denominator);

        uint256 _zIncrease = zReserve;
        _zIncrease -= cp.z;
        zIncrease = _zIncrease.toUint112();
    }

    function givenCollateral(
        IPair pair,
        uint256 maturity,
        uint112 assetOut,
        uint112 collateralIn
    )
        internal
        view
        returns (
            uint112 xDecrease,
            uint112 yIncrease,
            uint112 zIncrease
        )
    {
        ConstantProduct.CP memory cp = pair.get(maturity);

        xDecrease = getX(pair, maturity, assetOut);

        uint256 xReserve = cp.x;
        xReserve -= xDecrease;

        uint256 _zIncrease = collateralIn;
        _zIncrease = xReserve;
        uint256 subtrahend = cp.z;
        subtrahend *= xDecrease;
        _zIncrease -= subtrahend;
        _zIncrease <<= 25;
        uint256 denominator = maturity;
        denominator -= block.timestamp;
        denominator *= xReserve;
        _zIncrease /= denominator;
        zIncrease = _zIncrease.toUint112();

        uint256 zReserve = cp.z;
        zReserve += _zIncrease;

        uint256 yReserve = cp.x;
        yReserve *= cp.z;
        denominator = xReserve;
        denominator *= zReserve;
        yReserve = yReserve.mulDivUp(cp.y, denominator);

        uint256 _yIncrease = yReserve;
        _yIncrease -= cp.y;
        yIncrease = _yIncrease.toUint112();
    }

    function givenPercent(
        IPair pair,
        uint256 maturity,
        uint112 assetOut,
        uint40 percent
    )
        internal
        view
        returns (
            uint112 xDecrease,
            uint112 yIncrease,
            uint112 zIncrease
        )
    {
        ConstantProduct.CP memory cp = pair.get(maturity);

        xDecrease = getX(pair, maturity, assetOut);

        uint256 xReserve = cp.x;
        xReserve -= xDecrease;

        if (percent <= 0x80000000) {
            uint256 yMid = cp.y;
            yMid *= cp.y;
            yMid = yMid.mulDivUp(cp.x, xReserve);
            yMid = yMid.sqrtUp();
            yMid -= cp.y;

            uint256 _yIncrease = yMid;
            _yIncrease *= percent;
            _yIncrease = _yIncrease.shiftRightUp(31);
            yIncrease = _yIncrease.toUint112();

            uint256 yReserve = cp.y;
            yReserve += _yIncrease;

            uint256 zReserve = cp.x;
            zReserve *= cp.y;
            uint256 denominator = xReserve;
            denominator *= yReserve;
            zReserve = zReserve.mulDivUp(cp.z, denominator);

            uint256 _zIncrease = zReserve;
            _zIncrease -= cp.z;
            zIncrease = _zIncrease.toUint112();
        } else {
            percent = 0x100000000 - percent;

            uint256 zMid = cp.z;
            zMid *= cp.z;
            zMid = zMid.mulDivUp(cp.x, xReserve);
            zMid = zMid.sqrtUp();
            zMid -= cp.z;

            uint256 _zIncrease = zMid;
            _zIncrease *= percent;
            _zIncrease = _zIncrease.shiftRightUp(31);
            zIncrease = _zIncrease.toUint112();

            uint256 zReserve = cp.z;
            zReserve += _zIncrease;

            uint256 yReserve = cp.x;
            yReserve *= cp.z;
            uint256 denominator = xReserve;
            denominator *= zReserve;
            yReserve = yReserve.mulDivUp(cp.y, denominator);

            uint256 _yIncrease = yReserve;
            _yIncrease -= cp.y;
            yIncrease = _yIncrease.toUint112();
        }
    }

    function getX(
        IPair pair,
        uint256 maturity,
        uint112 assetOut
    ) private view returns (uint112 xDecrease) {
        // uint256 duration = maturity;
        // duration -= block.timestamp;

        uint256 totalFee = pair.fee();
        totalFee += pair.protocolFee();

        uint256 numerator = maturity;
        numerator -= block.timestamp;
        numerator *= totalFee;
        numerator += BASE;

        uint256 _xDecrease = assetOut;
        _xDecrease *= numerator;
        _xDecrease = _xDecrease.divUp(BASE);
        xDecrease = _xDecrease.toUint112();

        // uint256 numerator = duration;
        // numerator *= pair.fee();
        // numerator += BASE;

        // uint256 _xDecrease = assetOut;
        // _xDecrease *= numerator;
        // _xDecrease = _xDecrease.divUp(BASE);

        // numerator = duration;
        // numerator *= pair.protocolFee();
        // numerator += BASE;

        // _xDecrease *= numerator;
        // _xDecrease = _xDecrease.divUp(BASE);
        // xDecrease = _xDecrease.toUint112();
    }
}",1542
RealWorld_BA_96_IWETH_RealWord_20240826184515.log,96,IWETH,4674,4590,9264,68.0,0.11517,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.4;

import {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';

/// @title WETH9 Interface
/// @author Ricsson W. Ngo
interface IWETH is IERC20 {
    /* ===== UPDATE ===== */

    function deposit() external payable;

    function withdraw(uint256 amount) external;
}",88
RealWorld_BA_96_TestToken_RealWord_20240826170651.log,96,TestToken,4143,3864,8007,68.0,0.097995,"// SPDX-License-Identifier: MIT
pragma solidity >=0.8.1;

import '@openzeppelin/contracts/token/ERC20/ERC20.sol';

contract TestToken is ERC20 {
    constructor(
        string memory name_,
        string memory symbol_,
        uint256 amount
    ) ERC20(name_, symbol_) {
        _mint(msg.sender, amount);
    }
}",77
RealWorld_BA_96_MaticTestToken_RealWord_20240826174829.log,96,MaticTestToken,11047,4978,16025,74.0,0.154795,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.4;

contract MaticTestToken {
    // MODEL

    string public constant name = 'Matic TEST TOKEN';
    string public constant symbol = 'MATIC';
    uint8 public immutable decimals = 18;

    address private constant ZERO = address(type(uint160).min);

    uint256 public totalSupply;
    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    // EVENT

    event Approval(address indexed _owner, address indexed _spender, uint256 _value);

    event Transfer(address indexed _from, address indexed _to, uint256 _value);

    // UPDATE

    function approve(address _spender, uint256 _value) external returns (bool) {
        _approve(msg.sender, _spender, _value);
        return true;
    }

    function transfer(address _to, uint256 _value) external returns (bool) {
        _transfer(msg.sender, _to, _value);
        return true;
    }

    function transferFrom(
        address _from,
        address _to,
        uint256 _value
    ) external returns (bool) {
        if (msg.sender != _from && allowance[_from][msg.sender] != type(uint256).max) {
            allowance[_from][msg.sender] -= _value;

            emit Approval(_from, msg.sender, allowance[_from][msg.sender]);
        }
        _transfer(_from, _to, _value);
        return true;
    }

    function mint(address _to, uint256 _value) external {
        totalSupply += _value;
        balanceOf[_to] += _value;
        emit Transfer(ZERO, _to, _value);
    }

    // HELPER

    function _approve(
        address _owner,
        address _spender,
        uint256 _value
    ) private {
        allowance[_owner][_spender] = _value;
        emit Approval(_owner, _spender, _value);
    }

    function _transfer(
        address _from,
        address _to,
        uint256 _value
    ) private {
        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(_from, _to, _value);
    }
}",479
RealWorld_BA_96_ITimeswapMintCallback_RealWord_20240826172415.log,96,ITimeswapMintCallback,6654,5416,12070,91.0,0.14159,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.4;

/// @title Callback for ITimeswapPair#mint
/// @notice Any contract that calls ITimeswapPair#mint must implement this interface
interface ITimeswapMintCallback {
    /// @notice Called to `msg.sender` after initiating a mint from ITimeswapPair#mint.
    /// @dev In the implementation you must pay the asset token and collateral token owed for the mint transaction.
    /// The caller of this method must be checked to be a TimeswapPair deployed by the canonical TimeswapFactory.
    /// @param assetIn The amount of asset tokens owed due to the pool for the mint transaction.
    /// @param collateralIn The amount of collateral tokens owed due to the pool for the min transaction.
    /// @param data Any data passed through by the caller via the ITimeswapPair#mint call
    function timeswapMintCallback(
        uint256 assetIn,
        uint112 collateralIn,
        bytes calldata data
    ) external;
}",217
RealWorld_BA_96_SafeMetadata_RealWord_20240826181430.log,96,SafeMetadata,9255,5032,14287,68.0,0.146915,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.4;

import {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import {IERC20Metadata} from '@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol';

library SafeMetadata {
    function safeName(IERC20 token) internal view returns (string memory) {
        (bool success, bytes memory data) = address(token).staticcall(
            abi.encodeWithSelector(IERC20Metadata.name.selector)
        );
        return success ? returnDataToString(data) : 'Token';
    }

    function safeSymbol(IERC20 token) internal view returns (string memory) {
        (bool success, bytes memory data) = address(token).staticcall(
            abi.encodeWithSelector(IERC20Metadata.symbol.selector)
        );
        return success ? returnDataToString(data) : 'TKN';
    }

    function safeDecimals(IERC20 token) internal view returns (uint8) {
        (bool success, bytes memory data) = address(token).staticcall(
            abi.encodeWithSelector(IERC20Metadata.decimals.selector)
        );
        return success && data.length == 32 ? abi.decode(data, (uint8)) : 18;
    }

    function returnDataToString(bytes memory data) private pure returns (string memory) {
        if (data.length >= 64) {
            return abi.decode(data, (string));
        } else if (data.length == 32) {
            uint8 i = 0;
            while (i < 32 && data[i] != 0) {
                i++;
            }
            bytes memory bytesArray = new bytes(i);
            for (i = 0; i < 32 && data[i] != 0; i++) {
                bytesArray[i] = data[i];
            }
            return string(bytesArray);
        } else {
            return '???';
        }
    }
}",408
RealWorld_BA_96_BondInterest_RealWord_20240826173254.log,96,BondInterest,11676,5408,17084,86.0,0.16654,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.4;

import {IClaim} from './interfaces/IClaim.sol';
import {IConvenience} from './interfaces/IConvenience.sol';
import {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import {IPair} from '@timeswap-labs/timeswap-v1-core/contracts/interfaces/IPair.sol';
import {ERC20Permit} from './base/ERC20Permit.sol';
import {SafeMetadata} from './libraries/SafeMetadata.sol';
import {Strings} from '@openzeppelin/contracts/utils/Strings.sol';

contract BondInterest is IClaim, ERC20Permit {
    using SafeMetadata for IERC20;
    using Strings for uint256;

    IConvenience public immutable override convenience;
    IPair public immutable override pair;
    uint256 public immutable override maturity;

    function name() external view override returns (string memory) {
        string memory assetName = pair.asset().safeName();
        string memory collateralName = pair.collateral().safeName();
        return
            string(
                abi.encodePacked(
                    'Timeswap Bond Interest - ',
                    assetName,
                    ' - ',
                    collateralName,
                    ' - ',
                    maturity.toString()
                )
            );
    }

    function symbol() external view override returns (string memory) {
        string memory assetSymbol = pair.asset().safeSymbol();
        string memory collateralSymbol = pair.collateral().safeSymbol();
        return string(abi.encodePacked('TS-BND-INT-', assetSymbol, '-', collateralSymbol, '-', maturity.toString()));
    }

    function decimals() external view override returns (uint8) {
        return pair.asset().safeDecimals();
    }

    function totalSupply() external view override returns (uint256) {
        return pair.claimsOf(maturity, address(convenience)).bondInterest;
    }

    constructor(
        IConvenience _convenience,
        IPair _pair,
        uint256 _maturity
    ) ERC20Permit('Timeswap Bond Interest') {
        convenience = _convenience;
        pair = _pair;
        maturity = _maturity;
    }

    modifier onlyConvenience() {
        require(msg.sender == address(convenience), 'E403');
        _;
    }

    function mint(address to, uint128 amount) external override onlyConvenience {
        _mint(to, amount);
    }

    function burn(address from, uint128 amount) external override onlyConvenience {
        _burn(from, amount);
    }
}",532
RealWorld_BA_96_SafeCast_RealWord_20240826171400.log,96,SafeCast,5944,4706,10650,62.0,0.12384,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.4;

library SafeCast {
    function modUint32(uint256 x) internal pure returns (uint32 y) {
        y = uint32(x % 0x100000000);
    }
    
    function toUint112(uint256 x) internal pure returns (uint112 y) {
        require(x <= type(uint112).max);
        y = uint112(x);
    }

    function toUint128(uint256 x) internal pure returns (uint128 y) {
        require(x <= type(uint128).max);
        y = uint128(x);
    }

    function truncateUint112(uint256 x) internal pure returns (uint112 y) {
        if (x > type(uint112).max) return y = type(uint112).max;
        y = uint112(x);
    }
}",177
RealWorld_BA_96_DeployNative_RealWord_20240826182344.log,96,DeployNative,7840,5157,12997,74.0,0.14234,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.4;

import {IConvenience} from '../interfaces/IConvenience.sol';
import {IFactory} from '@timeswap-labs/timeswap-v1-core/contracts/interfaces/IFactory.sol';
import {IPair} from '@timeswap-labs/timeswap-v1-core/contracts/interfaces/IPair.sol';
import {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import {Deploy} from './Deploy.sol';
import {IDeployNatives} from '../interfaces/IDeployNatives.sol';

library DeployNative {
    using Deploy for IConvenience.Native;

    function deploy(
        mapping(IERC20 => mapping(IERC20 => mapping(uint256 => IConvenience.Native))) storage natives,
        IConvenience convenience,
        IFactory factory,
        IDeployNatives.DeployNatives memory params
    ) internal {
        require(params.deadline >= block.timestamp, 'E504');

        IPair pair = factory.getPair(params.asset, params.collateral);
        require(address(pair) != address(0), 'E501');

        IConvenience.Native storage native = natives[params.asset][params.collateral][params.maturity];
        require(address(native.liquidity) == address(0), 'E503');

        native.deploy(convenience, pair, params.asset, params.collateral, params.maturity);
    }
}",301
RealWorld_BA_96_DeployBonds_RealWord_20240826180502.log,96,DeployBonds,5556,4495,10051,75.0,0.11768,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.4;

import {IConvenience} from '../interfaces/IConvenience.sol';
import {IPair} from '@timeswap-labs/timeswap-v1-core/contracts/interfaces/IPair.sol';
import {BondInterest} from '../BondInterest.sol';
import {BondPrincipal} from '../BondPrincipal.sol';

library DeployBonds {
    function deployBonds(
        IConvenience.Native storage native,
        bytes32 salt,
        IConvenience convenience,
        IPair pair,
        uint256 maturity
    ) external {
        native.bondInterest = new BondInterest{salt: salt}(convenience, pair, maturity);
        native.bondPrincipal = new BondPrincipal{salt: salt}(convenience, pair, maturity);
    }
}",165
RealWorld_BA_96_ITimeswapPayCallback_RealWord_20240826172548.log,96,ITimeswapPayCallback,6231,4795,11026,79.0,0.127055,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.4;

/// @title Callback for ITimeswapPair#pay
/// @notice Any contract that calls ITimeswapPair#pay must implement this interface
interface ITimeswapPayCallback {
    /// @notice Called to `msg.sender` after initiating a pay from ITimeswapPair#pay.
    /// @dev In the implementation you must pay the asset token owed for the pay transaction.
    /// The caller of this method must be checked to be a TimeswapPair deployed by the canonical TimeswapFactory.
    /// @param assetIn The amount of asset tokens owed due to the pool for the pay transaction
    /// @param data Any data passed through by the caller via the ITimeswapPair#pay call
    function timeswapPayCallback(
        uint128 assetIn,
        bytes calldata data
    ) external;
}",185
RealWorld_BA_96_LendMath_RealWord_20240826181658.log,96,LendMath,28231,6404,34635,88.0,0.269235,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.4;

import {IPair} from '@timeswap-labs/timeswap-v1-core/contracts/interfaces/IPair.sol';
import {Math} from '@timeswap-labs/timeswap-v1-core/contracts/libraries/Math.sol';
import {SquareRoot} from './SquareRoot.sol';
import {FullMath} from '@timeswap-labs/timeswap-v1-core/contracts/libraries/FullMath.sol';
import {ConstantProduct} from './ConstantProduct.sol';
import {SafeCast} from '@timeswap-labs/timeswap-v1-core/contracts/libraries/SafeCast.sol';

library LendMath {
    using Math for uint256;
    using SquareRoot for uint256;
    using FullMath for uint256;
    using ConstantProduct for IPair;
    using ConstantProduct for ConstantProduct.CP;
    using SafeCast for uint256;

    uint256 private constant BASE = 0x10000000000;

    function givenBond(
        IPair pair,
        uint256 maturity,
        uint112 assetIn,
        uint128 bondOut
    )
        internal
        view
        returns (
            uint112 xIncrease,
            uint112 yDecrease,
            uint112 zDecrease
        )
    {
        ConstantProduct.CP memory cp = pair.get(maturity);

        xIncrease = getX(pair, maturity, assetIn);

        uint256 xReserve = cp.x;
        xReserve += xIncrease;

        uint256 _yDecrease = bondOut;
        _yDecrease -= xIncrease;
        _yDecrease <<= 32;
        uint256 denominator = maturity;
        denominator -= block.timestamp;
        _yDecrease = _yDecrease.divUp(denominator);
        yDecrease = _yDecrease.toUint112();

        uint256 yReserve = cp.y;
        yReserve -= _yDecrease;

        uint256 zReserve = cp.x;
        zReserve *= cp.y;
        denominator = xReserve;
        denominator *= yReserve;
        zReserve = zReserve.mulDivUp(cp.z, denominator);

        uint256 _zDecrease = cp.z;
        _zDecrease -= zReserve;
        zDecrease = _zDecrease.toUint112();
    }

    function givenInsurance(
        IPair pair,
        uint256 maturity,
        uint112 assetIn,
        uint128 insuranceOut
    )
        internal
        view
        returns (
            uint112 xIncrease,
            uint112 yDecrease,
            uint112 zDecrease
        )
    {
        ConstantProduct.CP memory cp = pair.get(maturity);

        xIncrease = getX(pair, maturity, assetIn);

        uint256 xReserve = cp.x;
        xReserve += xIncrease;

        uint256 _zDecrease = insuranceOut;
        _zDecrease *= xReserve;
        uint256 subtrahend = cp.z;
        subtrahend *= xIncrease;
        _zDecrease -= subtrahend;
        _zDecrease <<= 25;
        uint256 denominator = maturity;
        denominator -= block.timestamp;
        denominator *= xReserve;
        _zDecrease = _zDecrease.divUp(denominator);
        zDecrease = _zDecrease.toUint112();

        uint256 zReserve = cp.z;
        zReserve -= _zDecrease;

        uint256 yReserve = cp.x;
        yReserve *= cp.z;
        denominator = xReserve;
        denominator *= zReserve;
        yReserve = yReserve.mulDivUp(cp.y, denominator);

        uint256 _yDecrease = cp.y;
        _yDecrease -= yReserve;
        yDecrease = _yDecrease.toUint112();
    }

    function givenPercent(
        IPair pair,
        uint256 maturity,
        uint112 assetIn,
        uint40 percent
    )
        internal
        view
        returns (
            uint112 xIncrease,
            uint112 yDecrease,
            uint112 zDecrease
        )
    {
        ConstantProduct.CP memory cp = pair.get(maturity);

        xIncrease = getX(pair, maturity, assetIn);

        uint256 xReserve = cp.x;
        xReserve += xIncrease;

        if (percent <= 0x80000000) {
            uint256 yMid = cp.y;
            uint256 subtrahend = cp.y;
            subtrahend *= cp.y;
            subtrahend = subtrahend.mulDivUp(cp.x, xReserve);
            subtrahend = subtrahend.sqrtUp();
            yMid -= subtrahend;

            uint256 _yDecrease = yMid;
            _yDecrease *= percent;
            _yDecrease >>= 31;
            yDecrease = _yDecrease.toUint112();

            uint256 yReserve = cp.y;
            yReserve -= _yDecrease;

            uint256 zReserve = cp.x;
            zReserve *= cp.y;
            uint256 denominator = xReserve;
            denominator *= yReserve;
            zReserve = zReserve.mulDivUp(cp.z, denominator);

            uint256 _zDecrease = cp.z;
            _zDecrease -= zReserve;
            zDecrease = _zDecrease.toUint112();
        } else {
            percent = 0x100000000 - percent;

            uint256 zMid = cp.z;
            uint256 subtrahend = cp.z;
            subtrahend *= cp.z;
            subtrahend = subtrahend.mulDivUp(cp.x, xReserve);
            subtrahend = subtrahend.sqrtUp();
            zMid -= subtrahend;

            uint256 _zDecrease = zMid;
            _zDecrease *= percent;
            _zDecrease >>= 31;
            zDecrease = _zDecrease.toUint112();

            uint256 zReserve = cp.z;
            zReserve -= _zDecrease;

            uint256 yReserve = cp.x;
            yReserve *= cp.z;
            uint256 denominator = xReserve;
            denominator *= zReserve;
            yReserve = yReserve.mulDivUp(cp.y, denominator);

            uint256 _yDecrease = cp.y;
            _yDecrease -= yReserve;
            yDecrease = _yDecrease.toUint112();
        }
    }

    function getX(
        IPair pair,
        uint256 maturity,
        uint112 assetIn
    ) private view returns (uint112 xIncrease) {
        // uint256 duration = maturity;
        // duration -= block.timestamp;

        uint256 totalFee = pair.fee();
        totalFee += pair.protocolFee();

        uint256 denominator = maturity;
        denominator -= block.timestamp;
        denominator *= totalFee;
        denominator += BASE;

        uint256 _xIncrease = assetIn;
        _xIncrease *= BASE;
        _xIncrease /= denominator;
        xIncrease = _xIncrease.toUint112();

        // uint256 denominator = duration;
        // denominator *= pair.fee();
        // denominator += BASE;

        // uint256 _xIncrease = assetIn;
        // _xIncrease *= BASE;
        // _xIncrease /= denominator;

        // denominator = duration;
        // denominator *= pair.protocolFee();
        // denominator += BASE;

        // _xIncrease *= BASE;
        // _xIncrease /= denominator;
        // xIncrease = _xIncrease.toUint112();
    }
}",1598
RealWorld_BA_96_TimeswapConvenience_RealWord_20240826172710.log,96,TimeswapConvenience,76419,5547,81966,96.0,0.493035,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.4;

import {IConvenience} from './interfaces/IConvenience.sol';
import {IFactory} from '@timeswap-labs/timeswap-v1-core/contracts/interfaces/IFactory.sol';
import {IWETH} from './interfaces/IWETH.sol';
import {IDue} from './interfaces/IDue.sol';
import {IPair} from '@timeswap-labs/timeswap-v1-core/contracts/interfaces/IPair.sol';
import {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import {ITimeswapMintCallback} from '@timeswap-labs/timeswap-v1-core/contracts/interfaces/callback/ITimeswapMintCallback.sol';
import {ITimeswapLendCallback} from '@timeswap-labs/timeswap-v1-core/contracts/interfaces/callback/ITimeswapLendCallback.sol';
import {ITimeswapBorrowCallback} from '@timeswap-labs/timeswap-v1-core/contracts/interfaces/callback/ITimeswapBorrowCallback.sol';
import {ITimeswapPayCallback} from '@timeswap-labs/timeswap-v1-core/contracts/interfaces/callback/ITimeswapPayCallback.sol';
import {Mint} from './libraries/Mint.sol';
import {Burn} from './libraries/Burn.sol';
import {Lend} from './libraries/Lend.sol';
import {Withdraw} from './libraries/Withdraw.sol';
import {Borrow} from './libraries/Borrow.sol';
import {Pay} from './libraries/Pay.sol';
import {DeployNative} from './libraries/DeployNative.sol';
import {SafeTransfer} from './libraries/SafeTransfer.sol';

/// @title Timeswap Convenience
/// @author Timeswap Labs
/// @notice It is recommnded to use this contract to interact with Timeswap Core contract.
/// @notice All error messages are abbreviated and can be found in the documentation.
contract TimeswapConvenience is IConvenience {
    using SafeTransfer for IERC20;
    using Mint for mapping(IERC20 => mapping(IERC20 => mapping(uint256 => Native)));
    using Burn for mapping(IERC20 => mapping(IERC20 => mapping(uint256 => Native)));
    using Lend for mapping(IERC20 => mapping(IERC20 => mapping(uint256 => Native)));
    using Withdraw for mapping(IERC20 => mapping(IERC20 => mapping(uint256 => Native)));
    using Borrow for mapping(IERC20 => mapping(IERC20 => mapping(uint256 => Native)));
    using Pay for mapping(IERC20 => mapping(IERC20 => mapping(uint256 => Native)));
    using DeployNative for mapping(IERC20 => mapping(IERC20 => mapping(uint256 => Native)));

    /* ===== MODEL ===== */

    /// @inheritdoc IConvenience
    IFactory public immutable override factory;
    /// @inheritdoc IConvenience
    IWETH public immutable override weth;

    /// @dev Stores the addresses of the Liquidty, Bond, Insurance, Collateralized Debt token contracts.
    mapping(IERC20 => mapping(IERC20 => mapping(uint256 => Native))) private natives;

    /* ===== VIEW ===== */

    /// @inheritdoc IConvenience
    function getNative(
        IERC20 asset,
        IERC20 collateral,
        uint256 maturity
    ) external view override returns (Native memory) {
        return natives[asset][collateral][maturity];
    }

    /* ===== INIT ===== */

    /// @dev Initializes the Convenience contract.
    /// @param _factory The address of factory contract used by this contract.
    /// @param _weth The address of the Wrapped ETH contract.
    constructor(IFactory _factory, IWETH _weth) {
        require(address(_factory) != address(0), 'E601');
        require(address(_weth) != address(0), 'E601');
        require(address(_factory) != address(_weth), 'E612');

        factory = _factory;
        weth = _weth;
    }

    /* ===== UPDATE ===== */

    receive() external payable {
        require(msg.sender == address(weth));
    }

    /// @inheritdoc IConvenience
    function deployPair(DeployPair calldata params) external override {
        factory.createPair(params.asset, params.collateral);
    }

    /// @inheritdoc IConvenience
    function deployNatives(DeployNatives calldata params) external override {
        natives.deploy(this, factory, params);
    }

    /// @inheritdoc IConvenience
    function newLiquidity(NewLiquidity calldata params)
        external
        override
        returns (
            uint256 assetIn,
            uint256 liquidityOut,
            uint256 id,
            IPair.Due memory dueOut
        )
    {
        (assetIn, liquidityOut, id, dueOut) = natives.newLiquidity(this, factory, params);
    }

    /// @inheritdoc IConvenience
    function newLiquidityETHAsset(NewLiquidityETHAsset calldata params)
        external
        payable
        override
        returns (
            uint256 assetIn,
            uint256 liquidityOut,
            uint256 id,
            IPair.Due memory dueOut
        )
    {
        (assetIn, liquidityOut, id, dueOut) = natives.newLiquidityETHAsset(this, factory, weth, params);
    }

    /// @inheritdoc IConvenience
    function newLiquidityETHCollateral(NewLiquidityETHCollateral calldata params)
        external
        payable
        override
        returns (
            uint256 assetIn,
            uint256 liquidityOut,
            uint256 id,
            IPair.Due memory dueOut
        )
    {
        (assetIn, liquidityOut, id, dueOut) = natives.newLiquidityETHCollateral(this, factory, weth, params);
    }

    /// @inheritdoc IConvenience
    function liquidityGivenAsset(LiquidityGivenAsset calldata params)
        external
        override
        returns (
            uint256 assetIn,
            uint256 liquidityOut,
            uint256 id,
            IPair.Due memory dueOut
        )
    {
        (assetIn, liquidityOut, id, dueOut) = natives.liquidityGivenAsset(this, factory, params);
    }

    /// @inheritdoc IConvenience
    function liquidityGivenAssetETHAsset(LiquidityGivenAssetETHAsset calldata params)
        external
        payable
        override
        returns (
            uint256 assetIn,
            uint256 liquidityOut,
            uint256 id,
            IPair.Due memory dueOut
        )
    {
        (assetIn, liquidityOut, id, dueOut) = natives.liquidityGivenAssetETHAsset(this, factory, weth, params);
    }

    /// @inheritdoc IConvenience
    function liquidityGivenAssetETHCollateral(LiquidityGivenAssetETHCollateral calldata params)
        external
        payable
        override
        returns (
            uint256 assetIn,
            uint256 liquidityOut,
            uint256 id,
            IPair.Due memory dueOut
        )
    {
        (assetIn, liquidityOut, id, dueOut) = natives.liquidityGivenAssetETHCollateral(this, factory, weth, params);
    }

    /// @inheritdoc IConvenience
    function liquidityGivenDebt(LiquidityGivenDebt calldata params)
        external
        override
        returns (
            uint256 assetIn,
            uint256 liquidityOut,
            uint256 id,
            IPair.Due memory dueOut
        )
    {
        (assetIn, liquidityOut, id, dueOut) = natives.liquidityGivenDebt(this, factory, params);
    }

    /// @inheritdoc IConvenience
    function liquidityGivenDebtETHAsset(LiquidityGivenDebtETHAsset calldata params)
        external
        payable
        override
        returns (
            uint256 assetIn,
            uint256 liquidityOut,
            uint256 id,
            IPair.Due memory dueOut
        )
    {
        (assetIn, liquidityOut, id, dueOut) = natives.liquidityGivenDebtETHAsset(this, factory, weth, params);
    }

    /// @inheritdoc IConvenience
    function liquidityGivenDebtETHCollateral(LiquidityGivenDebtETHCollateral calldata params)
        external
        payable
        override
        returns (
            uint256 assetIn,
            uint256 liquidityOut,
            uint256 id,
            IPair.Due memory dueOut
        )
    {
        (assetIn, liquidityOut, id, dueOut) = natives.liquidityGivenDebtETHCollateral(this, factory, weth, params);
    }

    /// @inheritdoc IConvenience
    function liquidityGivenCollateral(LiquidityGivenCollateral calldata params)
        external
        override
        returns (
            uint256 assetIn,
            uint256 liquidityOut,
            uint256 id,
            IPair.Due memory dueOut
        )
    {
        (assetIn, liquidityOut, id, dueOut) = natives.liquidityGivenCollateral(this, factory, params);
    }

    /// @inheritdoc IConvenience
    function liquidityGivenCollateralETHAsset(LiquidityGivenCollateralETHAsset calldata params)
        external
        payable
        override
        returns (
            uint256 assetIn,
            uint256 liquidityOut,
            uint256 id,
            IPair.Due memory dueOut
        )
    {
        (assetIn, liquidityOut, id, dueOut) = natives.liquidityGivenCollateralETHAsset(this, factory, weth, params);
    }

    /// @inheritdoc IConvenience
    function liquidityGivenCollateralETHCollateral(LiquidityGivenCollateralETHCollateral calldata params)
        external
        payable
        override
        returns (
            uint256 assetIn,
            uint256 liquidityOut,
            uint256 id,
            IPair.Due memory dueOut
        )
    {
        (assetIn, liquidityOut, id, dueOut) = natives.liquidityGivenCollateralETHCollateral(
            this,
            factory,
            weth,
            params
        );
    }

    /// @inheritdoc IConvenience
    function removeLiquidity(RemoveLiquidity calldata params)
        external
        override
        returns (uint256 assetOut, uint128 collateralOut)
    {
        (assetOut, collateralOut) = natives.removeLiquidity(factory, params);
    }

    /// @inheritdoc IConvenience
    function removeLiquidityETHAsset(RemoveLiquidityETHAsset calldata params)
        external
        override
        returns (uint256 assetOut, uint128 collateralOut)
    {
        (assetOut, collateralOut) = natives.removeLiquidityETHAsset(factory, weth, params);
    }

    /// @inheritdoc IConvenience
    function removeLiquidityETHCollateral(RemoveLiquidityETHCollateral calldata params)
        external
        override
        returns (uint256 assetOut, uint128 collateralOut)
    {
        (assetOut, collateralOut) = natives.removeLiquidityETHCollateral(factory, weth, params);
    }

    /// @inheritdoc IConvenience
    function lendGivenBond(LendGivenBond calldata params)
        external
        override
        returns (uint256 assetIn, IPair.Claims memory claimsOut)
    {
        (assetIn, claimsOut) = natives.lendGivenBond(this, factory, params);
    }

    /// @inheritdoc IConvenience
    function lendGivenBondETHAsset(LendGivenBondETHAsset calldata params)
        external
        payable
        override
        returns (uint256 assetIn, IPair.Claims memory claimsOut)
    {
        (assetIn, claimsOut) = natives.lendGivenBondETHAsset(this, factory, weth, params);
    }

    /// @inheritdoc IConvenience
    function lendGivenBondETHCollateral(LendGivenBondETHCollateral calldata params)
        external
        payable
        override
        returns (uint256 assetIn, IPair.Claims memory claimsOut)
    {
        (assetIn, claimsOut) = natives.lendGivenBondETHCollateral(this, factory, weth, params);
    }

    /// @inheritdoc IConvenience
    function lendGivenInsurance(LendGivenInsurance calldata params)
        external
        override
        returns (uint256 assetIn, IPair.Claims memory claimsOut)
    {
        (assetIn, claimsOut) = natives.lendGivenInsurance(this, factory, params);
    }

    /// @inheritdoc IConvenience
    function lendGivenInsuranceETHAsset(LendGivenInsuranceETHAsset calldata params)
        external
        payable
        override
        returns (uint256 assetIn, IPair.Claims memory claimsOut)
    {
        (assetIn, claimsOut) = natives.lendGivenInsuranceETHAsset(this, factory, weth, params);
    }

    /// @inheritdoc IConvenience
    function lendGivenInsuranceETHCollateral(LendGivenInsuranceETHCollateral calldata params)
        external
        override
        returns (uint256 assetIn, IPair.Claims memory claimsOut)
    {
        (assetIn, claimsOut) = natives.lendGivenInsuranceETHCollateral(this, factory, weth, params);
    }

    /// @inheritdoc IConvenience
    function lendGivenPercent(LendGivenPercent calldata params)
        external
        override
        returns (uint256 assetIn, IPair.Claims memory claimsOut)
    {
        (assetIn, claimsOut) = natives.lendGivenPercent(this, factory, params);
    }

    /// @inheritdoc IConvenience
    function lendGivenPercentETHAsset(LendGivenPercentETHAsset calldata params)
        external
        payable
        override
        returns (uint256 assetIn, IPair.Claims memory claimsOut)
    {
        (assetIn, claimsOut) = natives.lendGivenPercentETHAsset(this, factory, weth, params);
    }

    /// @inheritdoc IConvenience
    function lendGivenPercentETHCollateral(LendGivenPercentETHCollateral calldata params)
        external
        override
        returns (uint256 assetIn, IPair.Claims memory claimsOut)
    {
        (assetIn, claimsOut) = natives.lendGivenPercentETHCollateral(this, factory, weth, params);
    }

    /// @inheritdoc IConvenience
    function collect(Collect calldata params) external override returns (IPair.Tokens memory tokensOut) {
        tokensOut = natives.collect(factory, params);
    }

    /// @inheritdoc IConvenience
    function collectETHAsset(CollectETHAsset calldata params)
        external
        override
        returns (IPair.Tokens memory tokensOut)
    {
        tokensOut = natives.collectETHAsset(factory, weth, params);
    }

    /// @inheritdoc IConvenience
    function collectETHCollateral(CollectETHCollateral calldata params)
        external
        override
        returns (IPair.Tokens memory tokensOut)
    {
        tokensOut = natives.collectETHCollateral(factory, weth, params);
    }

    /// @inheritdoc IConvenience
    function borrowGivenDebt(BorrowGivenDebt calldata params)
        external
        override
        returns (
            uint256 assetOut,
            uint256 id,
            IPair.Due memory dueOut
        )
    {
        (assetOut, id, dueOut) = natives.borrowGivenDebt(this, factory, params);
    }

    /// @inheritdoc IConvenience
    function borrowGivenDebtETHAsset(BorrowGivenDebtETHAsset calldata params)
        external
        override
        returns (
            uint256 assetOut,
            uint256 id,
            IPair.Due memory dueOut
        )
    {
        (assetOut, id, dueOut) = natives.borrowGivenDebtETHAsset(this, factory, weth, params);
    }

    /// @inheritdoc IConvenience
    function borrowGivenDebtETHCollateral(BorrowGivenDebtETHCollateral calldata params)
        external
        payable
        override
        returns (
            uint256 assetOut,
            uint256 id,
            IPair.Due memory dueOut
        )
    {
        (assetOut, id, dueOut) = natives.borrowGivenDebtETHCollateral(this, factory, weth, params);
    }

    /// @inheritdoc IConvenience
    function borrowGivenCollateral(BorrowGivenCollateral calldata params)
        external
        override
        returns (
            uint256 assetOut,
            uint256 id,
            IPair.Due memory dueOut
        )
    {
        (assetOut, id, dueOut) = natives.borrowGivenCollateral(this, factory, params);
    }

    /// @inheritdoc IConvenience
    function borrowGivenCollateralETHAsset(BorrowGivenCollateralETHAsset calldata params)
        external
        override
        returns (
            uint256 assetOut,
            uint256 id,
            IPair.Due memory dueOut
        )
    {
        (assetOut, id, dueOut) = natives.borrowGivenCollateralETHAsset(this, factory, weth, params);
    }

    /// @inheritdoc IConvenience
    function borrowGivenCollateralETHCollateral(BorrowGivenCollateralETHCollateral calldata params)
        external
        payable
        override
        returns (
            uint256 assetOut,
            uint256 id,
            IPair.Due memory dueOut
        )
    {
        (assetOut, id, dueOut) = natives.borrowGivenCollateralETHCollateral(this, factory, weth, params);
    }

    /// @inheritdoc IConvenience
    function borrowGivenPercent(BorrowGivenPercent calldata params)
        external
        override
        returns (
            uint256 assetOut,
            uint256 id,
            IPair.Due memory dueOut
        )
    {
        (assetOut, id, dueOut) = natives.borrowGivenPercent(this, factory, params);
    }

    /// @inheritdoc IConvenience
    function borrowGivenPercentETHAsset(BorrowGivenPercentETHAsset calldata params)
        external
        override
        returns (
            uint256 assetOut,
            uint256 id,
            IPair.Due memory dueOut
        )
    {
        (assetOut, id, dueOut) = natives.borrowGivenPercentETHAsset(this, factory, weth, params);
    }

    /// @inheritdoc IConvenience
    function borrowGivenPercentETHCollateral(BorrowGivenPercentETHCollateral calldata params)
        external
        payable
        override
        returns (
            uint256 assetOut,
            uint256 id,
            IPair.Due memory dueOut
        )
    {
        (assetOut, id, dueOut) = natives.borrowGivenPercentETHCollateral(this, factory, weth, params);
    }

    /// @inheritdoc IConvenience
    function repay(Repay memory params) external override returns (uint128 assetIn, uint128 collateralOut) {
        (assetIn, collateralOut) = natives.pay(factory, params);
    }

    /// @inheritdoc IConvenience
    function repayETHAsset(RepayETHAsset memory params)
        external
        payable
        override
        returns (uint128 assetIn, uint128 collateralOut)
    {
        (assetIn, collateralOut) = natives.payETHAsset(factory, weth, params);
    }

    /// @inheritdoc IConvenience
    function repayETHCollateral(RepayETHCollateral memory params)
        external
        override
        returns (uint128 assetIn, uint128 collateralOut)
    {
        (assetIn, collateralOut) = natives.payETHCollateral(factory, weth, params);
    }

    /// @inheritdoc ITimeswapMintCallback
    function timeswapMintCallback(
        uint256 assetIn,
        uint112 collateralIn,
        bytes calldata data
    ) external override {
        (IERC20 asset, IERC20 collateral, address assetFrom, address collateralFrom) = abi.decode(
            data,
            (IERC20, IERC20, address, address)
        );
        IPair pair = factory.getPair(asset, collateral);

        require(msg.sender == address(pair), 'E701');

        IWETH _weth = weth;

        if (assetFrom == address(this)) {
            _weth.deposit{value: assetIn}();
            asset.safeTransfer(pair, assetIn);
        } else {
            asset.safeTransferFrom(assetFrom, pair, assetIn);
        }

        if (collateralFrom == address(this)) {
            _weth.deposit{value: collateralIn}();
            collateral.safeTransfer(pair, collateralIn);
        } else {
            collateral.safeTransferFrom(collateralFrom, pair, collateralIn);
        }
    }

    /// @inheritdoc ITimeswapLendCallback
    function timeswapLendCallback(uint256 assetIn, bytes calldata data) external override {
        (IERC20 asset, IERC20 collateral, address from) = abi.decode(data, (IERC20, IERC20, address));
        IPair pair = factory.getPair(asset, collateral);

        require(msg.sender == address(pair), 'E701');

        if (from == address(this)) {
            weth.deposit{value: assetIn}();
            asset.safeTransfer(pair, assetIn);
        } else {
            asset.safeTransferFrom(from, pair, assetIn);
        }
    }

    /// @inheritdoc ITimeswapBorrowCallback
    function timeswapBorrowCallback(uint112 collateralIn, bytes calldata data) external override {
        (IERC20 asset, IERC20 collateral, address from) = abi.decode(data, (IERC20, IERC20, address));
        IPair pair = factory.getPair(asset, collateral);
        require(msg.sender == address(pair), 'E701');
        if (from == address(this)) {
            weth.deposit{value: collateralIn}();
            collateral.safeTransfer(pair, collateralIn);
        } else {
            collateral.safeTransferFrom(from, pair, collateralIn);
        }
    }

    /// @inheritdoc ITimeswapPayCallback
    function timeswapPayCallback(uint128 assetIn, bytes calldata data) external override {
        (IERC20 asset, IERC20 collateral, address from) = abi.decode(data, (IERC20, IERC20, address));

        IPair pair = factory.getPair(asset, collateral);
        require(msg.sender == address(pair), 'E701');

        if (from == address(this)) {
            weth.deposit{value: assetIn}();
            asset.safeTransfer(pair, assetIn);
        } else {
            asset.safeTransferFrom(from, pair, assetIn);
        }
    }
}",4769
RealWorld_BA_96_ERC721_RealWord_20240826183134.log,96,ERC721,28051,6730,34781,102.0,0.274855,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.4;

import {IERC721Extended} from '../interfaces/IERC721Extended.sol';
import {IERC721Receiver} from '@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol';

abstract contract ERC721 is IERC721Extended {
    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;
    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;
    bytes4 private constant _INTERFACE_ID_ERC721METADATA = 0x5b5e139f;
    bytes4 private constant _INTERFACE_ID_ERC721ENUMERABLE = 0x780e9d63;

    mapping(address => uint256) private _balances;
    mapping(uint256 => address) internal _owners;
    mapping(uint256 => address) private _tokenApprovals;
    mapping(address => mapping(address => bool)) private _operatorApprovals;
    mapping(address => mapping(uint256 => uint256)) private _ownedTokens;
    mapping(uint256 => uint256) private _ownedTokensIndex;

    function balanceOf(address owner) external view override returns (uint256) {
        require(owner != address(0), 'E613');
        return _balances[owner];
    }

    function ownerOf(uint256 id) external view override returns (address) {
        address owner = _owners[id];
        require(owner != address(0), 'E613');
        return owner;
    }

    function getApproved(uint256 id) external view override returns (address) {
        require(_owners[id] != address(0), 'E614');
        return _tokenApprovals[id];
    }

    function isApprovedForAll(address owner, address operator) external view override returns (bool) {
        return _operatorApprovals[owner][operator];
    }

    function tokenOfOwnerByIndex(address owner, uint256 id) external view override returns (uint256) {
        require(id < _balances[owner], 'E614');
        return _ownedTokens[owner][id];
    }

    function supportsInterface(bytes4 interfaceID) external pure override returns (bool) {
        return
            interfaceID == _INTERFACE_ID_ERC165 ||
            interfaceID == _INTERFACE_ID_ERC721 ||
            interfaceID == _INTERFACE_ID_ERC721METADATA ||
            interfaceID == _INTERFACE_ID_ERC721ENUMERABLE;
    }

    modifier isApproved(address owner, uint256 id) {
        require(
            owner == msg.sender || _tokenApprovals[id] == msg.sender || _operatorApprovals[owner][msg.sender],
            '611'
        );
        _;
    }

    function safeTransferFrom(
        address from,
        address to,
        uint256 id
    ) external override isApproved(from, id) {
        _safeTransfer(from, to, id, '');
    }

    function safeTransferFrom(
        address from,
        address to,
        uint256 id,
        bytes memory data
    ) external override isApproved(from, id) {
        _safeTransfer(from, to, id, data);
    }

    function transferFrom(
        address from,
        address to,
        uint256 id
    ) external override isApproved(from, id) {
        _transfer(from, to, id);
    }

    function approve(address to, uint256 id) external override {
        address owner = _owners[id];
        require(owner == msg.sender || _operatorApprovals[owner][msg.sender], '609');
        require(to != owner, 'E605');

        _approve(to, id);
    }

    function setApprovalForAll(address operator, bool approved) external override {
        require(operator != msg.sender, 'E607');

        _setApprovalForAll(operator, approved);
    }

    function _safeTransfer(
        address from,
        address to,
        uint256 id,
        bytes memory data
    ) private {
        _transfer(from, to, id);

        require(_checkOnERC721Received(from, to, id, data), 'E608');
    }

    function _approve(address to, uint256 id) internal {
        _tokenApprovals[id] = to;

        emit Approval(_owners[id], to, id);
    }

    function _setApprovalForAll(address operator, bool approved) private {
        _operatorApprovals[msg.sender][operator] = approved;

        emit ApprovalForAll(msg.sender, operator, approved);
    }

    function _safeMint(address to, uint256 id) internal {
        _mint(to, id);

        require(_checkOnERC721Received(address(0), to, id, ''), 'E610');
    }

    function _mint(address to, uint256 id) private {
        require(to != address(0), 'E601');
        require(_owners[id] == address(0), 'E604');

        uint256 length = _balances[to];
        _ownedTokens[to][length] = id;
        _ownedTokensIndex[id] = length;

        _balances[to]++;
        _owners[id] = to;

        emit Transfer(address(0), to, id);
    }

    function _transfer(
        address from,
        address to,
        uint256 id
    ) private {
        require(to != address(0), 'E601');

        if (from != to) {
            uint256 lastTokenIndex = _balances[from] - 1;
            uint256 tokenIndex = _ownedTokensIndex[id];

            if (lastTokenIndex != tokenIndex) {
                uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];

                _ownedTokens[from][tokenIndex] = lastTokenId;
                _ownedTokensIndex[lastTokenId] = tokenIndex;
            }

            delete _ownedTokens[from][lastTokenIndex];

            uint256 length = _balances[to];
            _ownedTokens[to][length] = id;
            _ownedTokensIndex[id] = length;
        }

        _owners[id] = to;
        _balances[from]--;
        _balances[to]++;

        _approve(address(0), id);

        emit Transfer(from, to, id);
    }

    function _checkOnERC721Received(
        address from,
        address to,
        uint256 id,
        bytes memory data
    ) private returns (bool) {
        uint256 size;
        assembly {
            size := extcodesize(to)
        }
        if (size == 0) {
            return true;
        } else {
            bytes memory returnData;
            (bool success, bytes memory _return) = to.call(
                abi.encodeWithSelector(IERC721Receiver(to).onERC721Received.selector, msg.sender, from, id, data)
            );
            if (success) {
                returnData = _return;
            } else if (_return.length != 0) {
                assembly {
                    let returnDataSize := mload(_return)
                    revert(add(32, _return), returnDataSize)
                }
            } else {
                revert('E610');
            }
            bytes4 retval = abi.decode(returnData, (bytes4));
            return (retval == 0x150b7a02);
        }
    }
}",1493
RealWorld_BA_96_Borrow_RealWord_20240826182718.log,96,Borrow,51912,5454,57366,90.0,0.36864,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.4;

import {IConvenience} from '../interfaces/IConvenience.sol';
import {IFactory} from '@timeswap-labs/timeswap-v1-core/contracts/interfaces/IFactory.sol';
import {IWETH} from '../interfaces/IWETH.sol';
import {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import {IPair} from '@timeswap-labs/timeswap-v1-core/contracts/interfaces/IPair.sol';
import {IBorrow} from '../interfaces/IBorrow.sol';
import {BorrowMath} from './BorrowMath.sol';
import {Deploy} from './Deploy.sol';
import {MsgValue} from './MsgValue.sol';
import {ETH} from './ETH.sol';

library Borrow {
    using BorrowMath for IPair;
    using Deploy for IConvenience.Native;

    function borrowGivenDebt(
        mapping(IERC20 => mapping(IERC20 => mapping(uint256 => IConvenience.Native))) storage natives,
        IConvenience convenience,
        IFactory factory,
        IBorrow.BorrowGivenDebt calldata params
    )
        external
        returns (
            uint256 assetOut,
            uint256 id,
            IPair.Due memory dueOut
        )
    {
        (assetOut, id, dueOut) = _borrowGivenDebt(
            natives,
            IBorrow._BorrowGivenDebt(
                convenience,
                factory,
                params.asset,
                params.collateral,
                params.maturity,
                msg.sender,
                params.assetTo,
                params.dueTo,
                params.assetOut,
                params.debtIn,
                params.maxCollateral,
                params.deadline
            )
        );
    }

    function borrowGivenDebtETHAsset(
        mapping(IERC20 => mapping(IERC20 => mapping(uint256 => IConvenience.Native))) storage natives,
        IConvenience convenience,
        IFactory factory,
        IWETH weth,
        IBorrow.BorrowGivenDebtETHAsset calldata params
    )
        external
        returns (
            uint256 assetOut,
            uint256 id,
            IPair.Due memory dueOut
        )
    {
        (assetOut, id, dueOut) = _borrowGivenDebt(
            natives,
            IBorrow._BorrowGivenDebt(
                convenience,
                factory,
                weth,
                params.collateral,
                params.maturity,
                msg.sender,
                address(this),
                params.dueTo,
                params.assetOut,
                params.debtIn,
                params.maxCollateral,
                params.deadline
            )
        );

        weth.withdraw(params.assetOut);
        ETH.transfer(params.assetTo, params.assetOut);
    }

    function borrowGivenDebtETHCollateral(
        mapping(IERC20 => mapping(IERC20 => mapping(uint256 => IConvenience.Native))) storage natives,
        IConvenience convenience,
        IFactory factory,
        IWETH weth,
        IBorrow.BorrowGivenDebtETHCollateral calldata params
    )
        external
        returns (
            uint256 assetOut,
            uint256 id,
            IPair.Due memory dueOut
        )
    {
        uint112 maxCollateral = MsgValue.getUint112();

        (assetOut, id, dueOut) = _borrowGivenDebt(
            natives,
            IBorrow._BorrowGivenDebt(
                convenience,
                factory,
                params.asset,
                weth,
                params.maturity,
                address(this),
                params.assetTo,
                params.dueTo,
                params.assetOut,
                params.debtIn,
                maxCollateral,
                params.deadline
            )
        );

        if (maxCollateral > dueOut.collateral) {
            uint256 excess;
            unchecked {
                excess -= dueOut.collateral;
            }
            ETH.transfer(payable(msg.sender), excess);
        }
    }

    function borrowGivenCollateral(
        mapping(IERC20 => mapping(IERC20 => mapping(uint256 => IConvenience.Native))) storage natives,
        IConvenience convenience,
        IFactory factory,
        IBorrow.BorrowGivenCollateral calldata params
    )
        external
        returns (
            uint256 assetOut,
            uint256 id,
            IPair.Due memory dueOut
        )
    {
        (assetOut, id, dueOut) = _borrowGivenCollateral(
            natives,
            IBorrow._BorrowGivenCollateral(
                convenience,
                factory,
                params.asset,
                params.collateral,
                params.maturity,
                msg.sender,
                params.assetTo,
                params.dueTo,
                params.assetOut,
                params.collateralIn,
                params.maxDebt,
                params.deadline
            )
        );
    }

    function borrowGivenCollateralETHAsset(
        mapping(IERC20 => mapping(IERC20 => mapping(uint256 => IConvenience.Native))) storage natives,
        IConvenience convenience,
        IFactory factory,
        IWETH weth,
        IBorrow.BorrowGivenCollateralETHAsset calldata params
    )
        external
        returns (
            uint256 assetOut,
            uint256 id,
            IPair.Due memory dueOut
        )
    {
        (assetOut, id, dueOut) = _borrowGivenCollateral(
            natives,
            IBorrow._BorrowGivenCollateral(
                convenience,
                factory,
                weth,
                params.collateral,
                params.maturity,
                msg.sender,
                address(this),
                params.dueTo,
                params.assetOut,
                params.collateralIn,
                params.maxDebt,
                params.deadline
            )
        );

        weth.withdraw(assetOut);
        ETH.transfer(payable(params.assetTo), assetOut);
    }

    function borrowGivenCollateralETHCollateral(
        mapping(IERC20 => mapping(IERC20 => mapping(uint256 => IConvenience.Native))) storage natives,
        IConvenience convenience,
        IFactory factory,
        IWETH weth,
        IBorrow.BorrowGivenCollateralETHCollateral calldata params
    )
        external
        returns (
            uint256 assetOut,
            uint256 id,
            IPair.Due memory dueOut
        )
    {
        uint112 collateralIn = MsgValue.getUint112();

        (assetOut, id, dueOut) = _borrowGivenCollateral(
            natives,
            IBorrow._BorrowGivenCollateral(
                convenience,
                factory,
                params.asset,
                weth,
                params.maturity,
                address(this),
                params.assetTo,
                params.dueTo,
                params.assetOut,
                collateralIn,
                params.maxDebt,
                params.deadline
            )
        );

        if (collateralIn > dueOut.collateral) {
            uint256 excess = collateralIn;
            unchecked {
                excess -= dueOut.collateral;
            }
            ETH.transfer(payable(msg.sender), excess);
        }
    }

    function borrowGivenPercent(
        mapping(IERC20 => mapping(IERC20 => mapping(uint256 => IConvenience.Native))) storage natives,
        IConvenience convenience,
        IFactory factory,
        IBorrow.BorrowGivenPercent calldata params
    )
        external
        returns (
            uint256 assetOut,
            uint256 id,
            IPair.Due memory dueOut
        )
    {
        (assetOut, id, dueOut) = _borrowGivenPercent(
            natives,
            IBorrow._BorrowGivenPercent(
                convenience,
                factory,
                params.asset,
                params.collateral,
                params.maturity,
                msg.sender,
                params.assetTo,
                params.dueTo,
                params.assetOut,
                params.percent,
                params.maxDebt,
                params.maxCollateral,
                params.deadline
            )
        );
    }

    function borrowGivenPercentETHAsset(
        mapping(IERC20 => mapping(IERC20 => mapping(uint256 => IConvenience.Native))) storage natives,
        IConvenience convenience,
        IFactory factory,
        IWETH weth,
        IBorrow.BorrowGivenPercentETHAsset calldata params
    )
        external
        returns (
            uint256 assetOut,
            uint256 id,
            IPair.Due memory dueOut
        )
    {
        (assetOut, id, dueOut) = _borrowGivenPercent(
            natives,
            IBorrow._BorrowGivenPercent(
                convenience,
                factory,
                weth,
                params.collateral,
                params.maturity,
                msg.sender,
                address(this),
                params.dueTo,
                params.assetOut,
                params.percent,
                params.maxDebt,
                params.maxCollateral,
                params.deadline
            )
        );

        weth.withdraw(assetOut);
        ETH.transfer(params.assetTo, assetOut);
    }

    function borrowGivenPercentETHCollateral(
        mapping(IERC20 => mapping(IERC20 => mapping(uint256 => IConvenience.Native))) storage natives,
        IConvenience convenience,
        IFactory factory,
        IWETH weth,
        IBorrow.BorrowGivenPercentETHCollateral calldata params
    )
        external
        returns (
            uint256 assetOut,
            uint256 id,
            IPair.Due memory dueOut
        )
    {
        uint112 maxCollateral = MsgValue.getUint112();

        (assetOut, id, dueOut) = _borrowGivenPercent(
            natives,
            IBorrow._BorrowGivenPercent(
                convenience,
                factory,
                params.asset,
                weth,
                params.maturity,
                address(this),
                params.assetTo,
                params.dueTo,
                params.assetOut,
                params.percent,
                params.maxDebt,
                maxCollateral,
                params.deadline
            )
        );

        if (maxCollateral > dueOut.collateral) {
            uint256 excess = maxCollateral;
            unchecked {
                excess -= dueOut.collateral;
            }
            ETH.transfer(payable(msg.sender), excess);
        }
    }

    function _borrowGivenDebt(
        mapping(IERC20 => mapping(IERC20 => mapping(uint256 => IConvenience.Native))) storage natives,
        IBorrow._BorrowGivenDebt memory params
    )
        private
        returns (
            uint256 assetOut,
            uint256 id,
            IPair.Due memory dueOut
        )
    {
        require(params.debtIn > params.assetOut, 'E518');

        IPair pair = params.factory.getPair(params.asset, params.collateral);
        require(address(pair) != address(0), 'E501');

        (uint112 xDecrease, uint112 yIncrease, uint112 zIncrease) = pair.givenDebt(
            params.maturity,
            params.assetOut,
            params.debtIn
        );

        (assetOut, id, dueOut) = _borrow(
            natives,
            IBorrow._Borrow(
                params.convenience,
                pair,
                params.asset,
                params.collateral,
                params.maturity,
                params.from,
                params.assetTo,
                params.dueTo,
                xDecrease,
                yIncrease,
                zIncrease,
                params.deadline
            )
        );

        require(dueOut.collateral <= params.maxCollateral, 'E513');
    }

    function _borrowGivenCollateral(
        mapping(IERC20 => mapping(IERC20 => mapping(uint256 => IConvenience.Native))) storage natives,
        IBorrow._BorrowGivenCollateral memory params
    )
        private
        returns (
            uint256 assetOut,
            uint256 id,
            IPair.Due memory dueOut
        )
    {
        IPair pair = params.factory.getPair(params.asset, params.collateral);
        require(address(pair) != address(0), 'E501');

        (uint112 xDecrease, uint112 yIncrease, uint112 zIncrease) = pair.givenCollateral(
            params.maturity,
            params.assetOut,
            params.collateralIn
        );

        (assetOut, id, dueOut) = _borrow(
            natives,
            IBorrow._Borrow(
                params.convenience,
                pair,
                params.asset,
                params.collateral,
                params.maturity,
                params.from,
                params.assetTo,
                params.dueTo,
                xDecrease,
                yIncrease,
                zIncrease,
                params.deadline
            )
        );

        require(dueOut.debt <= params.maxDebt, 'E512');
    }

    function _borrowGivenPercent(
        mapping(IERC20 => mapping(IERC20 => mapping(uint256 => IConvenience.Native))) storage natives,
        IBorrow._BorrowGivenPercent memory params
    )
        private
        returns (
            uint256 assetOut,
            uint256 id,
            IPair.Due memory dueOut
        )
    {
        require(params.percent <= 0x100000000, 'E505');

        IPair pair = params.factory.getPair(params.asset, params.collateral);
        require(address(pair) != address(0), 'E501');

        (uint112 xDecrease, uint112 yIncrease, uint112 zIncrease) = pair.givenPercent(
            params.maturity,
            params.assetOut,
            params.percent
        );

        (assetOut, id, dueOut) = _borrow(
            natives,
            IBorrow._Borrow(
                params.convenience,
                pair,
                params.asset,
                params.collateral,
                params.maturity,
                params.from,
                params.assetTo,
                params.dueTo,
                xDecrease,
                yIncrease,
                zIncrease,
                params.deadline
            )
        );


        require(dueOut.debt <= params.maxDebt, 'E512');
        require(dueOut.collateral <= params.maxCollateral, 'E513');
    }

    function _borrow(
        mapping(IERC20 => mapping(IERC20 => mapping(uint256 => IConvenience.Native))) storage natives,
        IBorrow._Borrow memory params
    )
        private
        returns (
            uint256 assetOut,
            uint256 id,
            IPair.Due memory dueOut
        )
    {
        require(params.deadline >= block.timestamp, 'E504');
        require(params.maturity > block.timestamp, 'E508');

        IConvenience.Native storage native = natives[params.asset][params.collateral][params.maturity];
        if (address(native.liquidity) == address(0))
            native.deploy(params.convenience, params.pair, params.asset, params.collateral, params.maturity);

        (assetOut, id, dueOut) = params.pair.borrow(
            IPair.BorrowParam(
                params.maturity,
                params.assetTo,
                address(this),
                params.xDecrease,
                params.yIncrease,
                params.zIncrease,
                bytes(abi.encode(params.asset, params.collateral, params.from))
            )
        );

        native.collateralizedDebt.mint(params.dueTo, id);
    }
}",3119
RealWorld_BA_96_Deploy_RealWord_20240826180917.log,96,Deploy,10477,5880,16357,82.0,0.169985,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.4;

import {IConvenience} from '../interfaces/IConvenience.sol';
import {IPair} from '@timeswap-labs/timeswap-v1-core/contracts/interfaces/IPair.sol';
import {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import {Strings} from '@openzeppelin/contracts/utils/Strings.sol';
import {DeployLiquidity} from './DeployLiquidity.sol';
import {DeployBonds} from './DeployBonds.sol';
import {DeployInsurances} from './DeployInsurances.sol';
import {DeployCollateralizedDebt} from './DeployCollateralizedDebt.sol';

library Deploy {
    using Strings for uint256;
    using DeployLiquidity for IConvenience.Native;
    using DeployBonds for IConvenience.Native;
    using DeployInsurances for IConvenience.Native;
    using DeployCollateralizedDebt for IConvenience.Native;

    /// @dev Emits when the new natives are deployed.
    /// @param asset The address of the asset ERC20 contract.
    /// @param collateral The address of the collateral ERC20 contract.
    /// @param maturity The unix timestamp maturity of the Pool.
    /// @param native The native ERC20 and ERC721 contracts deployed.
    event DeployNatives(IERC20 indexed asset, IERC20 indexed collateral, uint256 maturity, IConvenience.Native native);

    function deploy(
        IConvenience.Native storage native,
        IConvenience convenience,
        IPair pair,
        IERC20 asset,
        IERC20 collateral,
        uint256 maturity
    ) internal {
        bytes32 salt = keccak256(abi.encode(asset, collateral, maturity.toString()));
        native.deployLiquidity(salt, convenience, pair, maturity);
        native.deployBonds(salt, convenience, pair, maturity);
        native.deployInsurances(salt, convenience, pair, maturity);
        native.deployCollateralizedDebt(salt, convenience, pair, maturity);
        emit DeployNatives(asset, collateral, maturity, native);
    }
}",445
RealWorld_BA_96_Pay_RealWord_20240826181221.log,96,Pay,18428,5360,23788,72.0,0.19934,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.4;

import {IConvenience} from '../interfaces/IConvenience.sol';
import {IFactory} from '@timeswap-labs/timeswap-v1-core/contracts/interfaces/IFactory.sol';
import {IWETH} from '../interfaces/IWETH.sol';
import {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import {IPair} from '@timeswap-labs/timeswap-v1-core/contracts/interfaces/IPair.sol';
import {IPay} from '../interfaces/IPay.sol';
import {IDue} from '../interfaces/IDue.sol';
import {PayMath} from './PayMath.sol';
import {MsgValue} from './MsgValue.sol';
import {ETH} from './ETH.sol';

library Pay {
    using PayMath for IPair;

    function pay(
        mapping(IERC20 => mapping(IERC20 => mapping(uint256 => IConvenience.Native))) storage natives,
        IFactory factory,
        IPay.Repay memory params
    ) external returns (uint128 assetIn, uint128 collateralOut) {
        (assetIn, collateralOut) = _pay(
            natives,
            IPay._Repay(
                factory,
                params.asset,
                params.collateral,
                params.maturity,
                msg.sender,
                params.collateralTo,
                params.ids,
                params.maxAssetsIn,
                params.deadline
            )
        );
    }

    function payETHAsset(
        mapping(IERC20 => mapping(IERC20 => mapping(uint256 => IConvenience.Native))) storage natives,
        IFactory factory,
        IWETH weth,
        IPay.RepayETHAsset memory params
    ) external returns (uint128 assetIn, uint128 collateralOut) {
        uint128 maxAssetIn = MsgValue.getUint112();

        (assetIn, collateralOut) = _pay(
            natives,
            IPay._Repay(
                factory,
                weth,
                params.collateral,
                params.maturity,
                address(this),
                params.collateralTo,
                params.ids,
                params.maxAssetsIn,
                params.deadline
            )
        );

        if (maxAssetIn > assetIn) {
            uint256 excess = maxAssetIn;
            unchecked {
                excess -= assetIn;
            }
            ETH.transfer(payable(msg.sender), excess);
        }
    }

    function payETHCollateral(
        mapping(IERC20 => mapping(IERC20 => mapping(uint256 => IConvenience.Native))) storage natives,
        IFactory factory,
        IWETH weth,
        IPay.RepayETHCollateral memory params
    ) external returns (uint128 assetIn, uint128 collateralOut) {
        (assetIn, collateralOut) = _pay(
            natives,
            IPay._Repay(
                factory,
                params.asset,
                weth,
                params.maturity,
                msg.sender,
                address(this),
                params.ids,
                params.maxAssetsIn,
                params.deadline
            )
        );

        if (collateralOut != 0) {
            weth.withdraw(collateralOut);
            ETH.transfer(params.collateralTo, collateralOut);
        }
    }

    function _pay(
        mapping(IERC20 => mapping(IERC20 => mapping(uint256 => IConvenience.Native))) storage natives,
        IPay._Repay memory params
    ) private returns (uint128 assetIn, uint128 collateralOut) {
        require(params.deadline >= block.timestamp, 'E504');
        require(params.maturity > block.timestamp, 'E508');
        require(params.ids.length == params.maxAssetsIn.length, '520');

        IPair pair = params.factory.getPair(params.asset, params.collateral);
        require(address(pair) != address(0), 'E501');

        IDue collateralizedDebt = natives[params.asset][params.collateral][params.maturity].collateralizedDebt;
        require(address(collateralizedDebt) != address(0), 'E502');

        (uint112[] memory assetsIn, uint112[] memory collateralsOut) = pair.givenMaxAssetsIn(
            params.maturity,
            collateralizedDebt,
            params.ids,
            params.maxAssetsIn
        );

        (assetIn, collateralOut) = pair.pay(
            IPair.PayParam(
                params.maturity,
                params.collateralTo,
                address(this),
                params.ids,
                assetsIn,
                collateralsOut,
                bytes(abi.encode(params.asset, params.collateral, params.from, params.maturity))
            )
        );
    }
}",960
RealWorld_BA_96_TestToken_RealWord_20240826174544.log,96,TestToken,4083,3873,7956,70.0,0.097875,"// SPDX-License-Identifier: MIT
pragma solidity >=0.8.1;

import '@openzeppelin/contracts/token/ERC20/ERC20.sol';

contract TestToken is ERC20 {
    constructor(
        string memory name_,
        string memory symbol_,
        uint256 amount
    ) ERC20(name_, symbol_) {
        _mint(msg.sender, amount);
    }
}",77
RealWorld_BA_96_InsurancePrincipal_RealWord_20240826173422.log,96,InsurancePrincipal,11290,5532,16822,81.0,0.16709,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.4;

import {IClaim} from './interfaces/IClaim.sol';
import {IConvenience} from './interfaces/IConvenience.sol';
import {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import {IPair} from '@timeswap-labs/timeswap-v1-core/contracts/interfaces/IPair.sol';
import {ERC20Permit} from './base/ERC20Permit.sol';
import {SafeMetadata} from './libraries/SafeMetadata.sol';
import {Strings} from '@openzeppelin/contracts/utils/Strings.sol';

contract InsurancePrincipal is IClaim, ERC20Permit {
    using SafeMetadata for IERC20;
    using Strings for uint256;

    IConvenience public immutable override convenience;
    IPair public immutable override pair;
    uint256 public immutable override maturity;

    function name() external view override returns (string memory) {
        string memory assetName = pair.asset().safeName();
        string memory collateralName = pair.collateral().safeName();
        return
            string(
                abi.encodePacked(
                    'Timeswap Insurance Principal- ',
                    assetName,
                    ' - ',
                    collateralName,
                    ' - ',
                    maturity.toString()
                )
            );
    }

    function symbol() external view override returns (string memory) {
        string memory assetSymbol = pair.asset().safeSymbol();
        string memory collateralSymbol = pair.collateral().safeSymbol();
        return string(abi.encodePacked('TS-INS-PRI-', assetSymbol, '-', collateralSymbol, '-', maturity.toString()));
    }

    function decimals() external view override returns (uint8) {
        return pair.collateral().safeDecimals();
    }

    function totalSupply() external view override returns (uint256) {
        return pair.claimsOf(maturity, address(convenience)).insurancePrincipal;
    }

    constructor(
        IConvenience _convenience,
        IPair _pair,
        uint256 _maturity
    ) ERC20Permit('Timeswap Insurance Principal') {
        convenience = _convenience;
        pair = _pair;
        maturity = _maturity;
    }

    modifier onlyConvenience() {
        require(msg.sender == address(convenience), 'E403');
        _;
    }

    function mint(address to, uint128 amount) external override onlyConvenience {
        _mint(to, amount);
    }

    function burn(address from, uint128 amount) external override onlyConvenience {
        _burn(from, amount);
    }
}",533
RealWorld_BA_96_DeployLiquidity_RealWord_20240826180328.log,96,DeployLiquidity,5731,5556,11287,91.0,0.139775,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.4;

import {IConvenience} from '../interfaces/IConvenience.sol';
import {IPair} from '@timeswap-labs/timeswap-v1-core/contracts/interfaces/IPair.sol';
import {Liquidity} from '../Liquidity.sol';

library DeployLiquidity {
    function deployLiquidity(
        IConvenience.Native storage native,
        bytes32 salt,
        IConvenience convenience,
        IPair pair,
        uint256 maturity
    ) external {
        native.liquidity = new Liquidity{salt: salt}(convenience, pair, maturity);
    }
}",137
RealWorld_BA_96_PayMath_RealWord_20240826180619.log,96,PayMath,9019,5354,14373,86.0,0.152175,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.4;

import {IPair} from '@timeswap-labs/timeswap-v1-core/contracts/interfaces/IPair.sol';
import {IDue} from '../interfaces/IDue.sol';
import {SafeCast} from '@timeswap-labs/timeswap-v1-core/contracts/libraries/SafeCast.sol';

library PayMath {
    using SafeCast for uint256;

    function givenMaxAssetsIn(
        IPair pair,
        uint256 maturity,
        IDue collateralizedDebt,
        uint256[] memory ids,
        uint112[] memory maxAssetsIn
    ) internal view returns (uint112[] memory assetsIn, uint112[] memory collateralsOut) {
        uint256 length = ids.length;

        assetsIn = maxAssetsIn;
        collateralsOut = new uint112[](length);

        for (uint256 i; i < length; ) {
            IPair.Due memory due = pair.dueOf(maturity, address(this), ids[i]);

            if (assetsIn[i] > due.debt) assetsIn[i] = due.debt;
            if (msg.sender == collateralizedDebt.ownerOf(ids[i])) {
                uint256 _collateralOut = due.collateral;
                if (due.debt != 0) {
                    _collateralOut *= assetsIn[i];
                    _collateralOut /= due.debt;
                }
                collateralsOut[i] = _collateralOut.toUint112();
            }

            unchecked {
                ++i;
            }
        }
    }
}",331
RealWorld_BA_96_BlockNumber_RealWord_20240826171505.log,96,BlockNumber,4073,3988,8061,60.0,0.100125,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.4;

import {SafeCast} from './SafeCast.sol';

library BlockNumber {
    using SafeCast for uint256;

    function get() internal view returns (uint32 blockNumber) {
        blockNumber = block.number.modUint32();
    }
}",66
RealWorld_BA_96_SafeTransfer_RealWord_20240826181541.log,96,SafeTransfer,5806,4482,10288,75.0,0.11867,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.4;

import {IPair} from '@timeswap-labs/timeswap-v1-core/contracts/interfaces/IPair.sol';
import {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import {SafeERC20} from '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';

library SafeTransfer {
    using SafeERC20 for IERC20;

    function safeTransfer(
        IERC20 token,
        IPair to,
        uint256 amount
    ) internal {
        token.safeTransfer(address(to), amount);
    }

    function safeTransferFrom(
        IERC20 token,
        address from,
        IPair to,
        uint256 amount
    ) internal {
        token.safeTransferFrom(from, address(to), amount);
    }
}",182
RealWorld_BA_96_IPair_RealWord_20240826172007.log,96,IPair,66385,5503,71888,90.0,0.441985,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.4;

import {IFactory} from './IFactory.sol';
import {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';

interface IPair {
    /* ===== STRUCT ===== */

    struct Tokens {
        uint128 asset;
        uint128 collateral;
    }

    struct Claims {
        uint112 bondPrincipal;
        uint112 bondInterest;
        uint112 insurancePrincipal;
        uint112 insuranceInterest;
    }

    struct Due {
        uint112 debt;
        uint112 collateral;
        uint32 startBlock;
    }

    struct State {
        Tokens reserves;
        uint256 feeStored;
        uint256 totalLiquidity;
        Claims totalClaims;
        uint120 totalDebtCreated;
        uint112 x;
        uint112 y;
        uint112 z;
    }

    struct Pool {
        State state;
        mapping(address => uint256) liquidities;
        mapping(address => Claims) claims;
        mapping(address => Due[]) dues;
    }

    /// @param maturity The unix timestamp maturity of the Pool.
    /// @param liquidityTo The address of the receiver of liquidity balance.
    /// @param dueTo The addres of the receiver of collateralized debt balance.
    /// @param xIncrease The increase in the X state.
    /// @param yIncrease The increase in the Y state.
    /// @param zIncrease The increase in the Z state.
    /// @param data The data for callback.
    struct MintParam {
        uint256 maturity;
        address liquidityTo;
        address dueTo;
        uint112 xIncrease;
        uint112 yIncrease;
        uint112 zIncrease;
        bytes data;
    }

    /// @param maturity The unix timestamp maturity of the Pool.
    /// @param assetTo The address of the receiver of asset ERC20.
    /// @param collateralTo The addres of the receiver of collateral ERC20.
    /// @param liquidityIn The amount of liquidity balance burnt by the msg.sender.
    struct BurnParam {
        uint256 maturity;
        address assetTo;
        address collateralTo;
        uint256 liquidityIn;
    }

    /// @param maturity The unix timestamp maturity of the Pool.
    /// @param bondTo The address of the receiver of bond balance.
    /// @param insuranceTo The addres of the receiver of insurance balance.
    /// @param xIncrease The increase in x state and the amount of asset ERC20 sent.
    /// @param yDecrease The decrease in y state.
    /// @param zDecrease The decrease in z state.
    /// @param data The data for callback.
    struct LendParam {
        uint256 maturity;
        address bondTo;
        address insuranceTo;
        uint112 xIncrease;
        uint112 yDecrease;
        uint112 zDecrease;
        bytes data;
    }

    /// @param maturity The unix timestamp maturity of the Pool.
    /// @param assetTo The address of the receiver of asset ERC20.
    /// @param collateralTo The addres of the receiver of collateral ERC20.
    /// @param claimsIn The amount of bond balance and insurance balance burnt by the msg.sender.
    struct WithdrawParam {
        uint256 maturity;
        address assetTo;
        address collateralTo;
        Claims claimsIn;
    }

    /// @param maturity The unix timestamp maturity of the Pool.
    /// @param assetTo The address of the receiver of asset ERC20.
    /// @param dueTo The address of the receiver of collateralized debt.
    /// @param xDecrease The decrease in x state and amount of asset ERC20 received by assetTo.
    /// @param yIncrease The increase in y state.
    /// @param zIncrease The increase in z state.
    /// @param data The data for callback.
    struct BorrowParam {
        uint256 maturity;
        address assetTo;
        address dueTo;
        uint112 xDecrease;
        uint112 yIncrease;
        uint112 zIncrease;
        bytes data;
    }

    /// @param maturity The unix timestamp maturity of the Pool.
    /// @param to The address of the receiver of collateral ERC20.
    /// @param owner The addres of the owner of collateralized debt.
    /// @param ids The array indexes of collateralized debts.
    /// @param assetsIn The amount of asset ERC20 paid per collateralized debts.
    /// @param collateralsOut The amount of collateral ERC20 withdrawn per collaterlaized debts.
    /// @param data The data for callback.
    struct PayParam {
        uint256 maturity;
        address to;
        address owner;
        uint256[] ids;
        uint112[] assetsIn;
        uint112[] collateralsOut;
        bytes data;
    }

    /* ===== EVENT ===== */

    /// @dev Emits when the state gets updated.
    /// @param maturity The unix timestamp maturity of the Pool.
    /// @param x The new x state of the pool.
    /// @param y The new y state of the pool.
    /// @param z The new z state of the pool.
    event Sync(uint256 indexed maturity, uint112 x, uint112 y, uint112 z);

    /// @dev Emits when mint function is called.
    /// @param maturity The unix timestamp maturity of the Pool.
    /// @param sender The address of the caller.
    /// @param liquidityTo The address of the receiver of liquidity balance.
    /// @param dueTo The address of the receiver of collateralized debt balance.
    /// @param assetIn The increase in the X state.
    /// @param liquidityOut The amount of liquidity balance received by liquidityTo.
    /// @param id The array index of the collateralized debt received by dueTo.
    /// @param dueOut The collateralized debt received by dueTo.
    /// @param feeIn The amount of fee asset ERC20 deposited.
    event Mint(
        uint256 maturity,
        address indexed sender,
        address indexed liquidityTo,
        address indexed dueTo,
        uint256 assetIn,
        uint256 liquidityOut,
        uint256 id,
        Due dueOut,
        uint256 feeIn
    );

    /// @dev Emits when burn function is called.
    /// @param maturity The unix timestamp maturity of the Pool.
    /// @param sender The address of the caller.
    /// @param assetTo The address of the receiver of asset ERC20.
    /// @param collateralTo The addres of the receiver of collateral ERC20.
    /// @param liquidityIn The amount of liquidity balance burnt by the sender.
    /// @param assetOut The amount of asset ERC20 received.
    /// @param collateralOut The amount of collateral ERC20 received.
    /// @param feeOut The amount of fee asset ERC20 received.
    event Burn(
        uint256 maturity,
        address indexed sender,
        address indexed assetTo,
        address indexed collateralTo,
        uint256 liquidityIn,
        uint256 assetOut,
        uint128 collateralOut,
        uint256 feeOut
    );

    /// @dev Emits when lend function is called.
    /// @param maturity The unix timestamp maturity of the Pool.
    /// @param sender The address of the caller.
    /// @param bondTo The address of the receiver of bond balance.
    /// @param insuranceTo The addres of the receiver of insurance balance.
    /// @param assetIn The increase in X state.
    /// @param claimsOut The amount of bond balance and insurance balance received.
    /// @param feeIn The amount of fee paid by lender.
    /// @param protocolFeeIn The amount of protocol fee paid by lender.
    event Lend(
        uint256 maturity,
        address indexed sender,
        address indexed bondTo,
        address indexed insuranceTo,
        uint256 assetIn,
        Claims claimsOut,
        uint256 feeIn,
        uint256 protocolFeeIn
    );

    /// @dev Emits when withdraw function is called.
    /// @param maturity The unix timestamp maturity of the Pool.
    /// @param sender The address of the caller.
    /// @param assetTo The address of the receiver of asset ERC20.
    /// @param collateralTo The address of the receiver of collateral ERC20.
    /// @param claimsIn The amount of bond balance and insurance balance burnt by the sender.
    /// @param tokensOut The amount of asset ERC20 and collateral ERC20 received.
    event Withdraw(
        uint256 maturity,
        address indexed sender,
        address indexed assetTo,
        address indexed collateralTo,
        Claims claimsIn,
        Tokens tokensOut
    );

    /// @dev Emits when borrow function is called.
    /// @param maturity The unix timestamp maturity of the Pool.
    /// @param sender The address of the caller.
    /// @param assetTo The address of the receiver of asset ERC20.
    /// @param dueTo The address of the receiver of collateralized debt.
    /// @param assetOut The amount of asset ERC20 received by assetTo.
    /// @param id The array index of the collateralized debt received by dueTo.
    /// @param dueOut The collateralized debt received by dueTo.
    /// @param feeIn The amount of fee paid by lender.
    /// @param protocolFeeIn The amount of protocol fee paid by lender.
    event Borrow(
        uint256 maturity,
        address indexed sender,
        address indexed assetTo,
        address indexed dueTo,
        uint256 assetOut,
        uint256 id,
        Due dueOut,
        uint256 feeIn,
        uint256 protocolFeeIn
    );

    /// @dev Emits when pay function is called.
    /// @param maturity The unix timestamp maturity of the Pool.
    /// @param sender The address of the caller.
    /// @param to The address of the receiver of collateral ERC20.
    /// @param owner The address of the owner of collateralized debt.
    /// @param ids The array indexes of collateralized debts.
    /// @param assetsIn The amount of asset ERC20 paid per collateralized debts.
    /// @param collateralsOut The amount of collateral ERC20 withdrawn per collaterelized debts.
    /// @param assetIn The total amount of asset ERC20 paid.
    /// @param collateralOut The total amount of collateral ERC20 received.
    event Pay(
        uint256 maturity,
        address indexed sender,
        address indexed to,
        address indexed owner,
        uint256[] ids,
        uint112[] assetsIn,
        uint112[] collateralsOut,
        uint128 assetIn,
        uint128 collateralOut
    );

    /// @dev Emits when collectProtocolFee function is called
    /// @param sender The address of the caller.
    /// @param to The address of the receiver of asset ERC20.
    /// @param protocolFeeOut The amount of protocol fee asset ERC20 received.
    event CollectProtocolFee(
        address indexed sender,
        address indexed to,
        uint256 protocolFeeOut
    );

    /* ===== VIEW ===== */

    /// @dev Return the address of the factory contract that deployed this contract.
    /// @return The address of the factory contract.
    function factory() external view returns (IFactory);

    /// @dev Return the address of the ERC20 being lent and borrowed.
    /// @return The address of the asset ERC20.
    function asset() external view returns (IERC20);

    /// @dev Return the address of the ERC20 as collateral.
    /// @return The address of the collateral ERC20.
    function collateral() external view returns (IERC20);

    //// @dev Return the fee per second earned by liquidity providers.
    //// @return The transaction fee following the UQ0.40 format.
    function fee() external view returns (uint16);

    /// @dev Return the protocol fee per second earned by the owner.
    /// @return The protocol fee per second following the UQ0.40 format.
    function protocolFee() external view returns (uint16);

    /// @dev Return the fee stored of the Pool given maturity.
    /// @param maturity The unix timestamp maturity of the Pool.
    /// @return The fee in asset ERC20 stored in the Pool.
    function feeStored(uint256 maturity) external view returns (uint256);

    /// @dev Return the protocol fee stored.
    /// @return The protocol fee in asset ERC20 stored.
    function protocolFeeStored() external view returns (uint256);

    /// @dev Returns the Constant Product state of a Pool.
    /// @dev The Y state follows the UQ80.32 format.
    /// @param maturity The unix timestamp maturity of the Pool.
    /// @return x The x state.
    /// @return y The y state.
    /// @return z The z state.
    function constantProduct(uint256 maturity)
        external
        view
        returns (
            uint112 x,
            uint112 y,
            uint112 z
        );

    /// @dev Returns the asset ERC20 and collateral ERC20 balances of a Pool.
    /// @param maturity The unix timestamp maturity of the Pool.
    /// @return The asset ERC20 and collateral ERC20 locked.
    function totalReserves(uint256 maturity) external view returns (Tokens memory);

    /// @dev Returns the total liquidity supply of a Pool.
    /// @param maturity The unix timestamp maturity of the Pool.
    /// @return The total liquidity supply.
    function totalLiquidity(uint256 maturity) external view returns (uint256);

    /// @dev Returns the liquidity balance of a user in a Pool.
    /// @param maturity The unix timestamp maturity of the Pool.
    /// @param owner The address of the user.
    /// @return The liquidity balance.
    function liquidityOf(uint256 maturity, address owner) external view returns (uint256);

    /// @dev Returns the total claims of a Pool.
    /// @param maturity The unix timestamp maturity of the Pool.
    /// @return The total claims.
    function totalClaims(uint256 maturity) external view returns (Claims memory);

    /// @dev Returms the claims of a user in a Pool.
    /// @param maturity The unix timestamp maturity of the Pool.
    /// @param owner The address of the user.
    /// @return The claims balance.
    function claimsOf(uint256 maturity, address owner) external view returns (Claims memory);

    /// @dev Returns the total debt created.
    /// @param maturity The unix timestamp maturity of the Pool.
    /// @return The total asset ERC20 debt created.
    function totalDebtCreated(uint256 maturity) external view returns (uint120);

    /// @dev Returns the number of dues owned by owner.
    /// @param maturity The unix timestamp maturity of the Pool.
    /// @param owner The address of the user.
    function totalDuesOf(uint256 maturity, address owner) external view returns (uint256);

    /// @dev Returns a collateralized debt of a user in a Pool.
    /// @param maturity The unix timestamp maturity of the Pool.
    /// @param owner The address of the user.
    /// @param id The index of the collateralized debt
    /// @return The collateralized debt balance.
    function dueOf(uint256 maturity, address owner, uint256 id) external view returns (Due memory);

    /* ===== UPDATE ===== */

    /// @dev Add liquidity into a Pool by a liquidity provider.
    /// @dev Liquidity providers can be thought as making both lending and borrowing positions.
    /// @dev Must be called by a contract implementing the ITimeswapMintCallback interface.
    /// @param param The mint parameter found in the MintParam struct.
    /// @return assetIn The amount of asset ERC20 deposited.
    /// @return liquidityOut The amount of liquidity balance received by liquidityTo.
    /// @return id The array index of the collateralized debt received by dueTo.
    /// @return dueOut The collateralized debt received by dueTo.
    function mint(MintParam calldata param)
        external
        returns (
            uint256 assetIn,
            uint256 liquidityOut,
            uint256 id,
            Due memory dueOut
        );

    /// @dev Remove liquidity from a Pool by a liquidity provider.
    /// @dev Can only be called after the maturity of the Pool.
    /// @param param The burn parameter found in the BurnParam struct.
    /// @return assetOut The amount of asset ERC20 received.
    /// @return collateralOut The amount of collateral ERC20 received.
    function burn(BurnParam calldata param) 
        external 
        returns (
            uint256 assetOut,
            uint128 collateralOut 
        );

    /// @dev Lend asset ERC20 into the Pool.
    /// @dev Must be called by a contract implementing the ITimeswapLendCallback interface.
    /// @param param The lend parameter found in the LendParam struct.
    /// @return assetIn The amount of asset ERC20 deposited.
    /// @return claimsOut The amount of bond balance and insurance balance received.
    function lend(LendParam calldata param) 
        external 
        returns (
            uint256 assetIn,
            Claims memory claimsOut
        );

    /// @dev Withdraw asset ERC20 and/or collateral ERC20 for lenders.
    /// @dev Can only be called after the maturity of the Pool.
    /// @param param The withdraw parameter found in the WithdrawParam struct.
    /// @return tokensOut The amount of asset ERC20 and collateral ERC20 received.
    function withdraw(WithdrawParam calldata param)
        external 
        returns (
            Tokens memory tokensOut
        );

    /// @dev Borrow asset ERC20 from the Pool.
    /// @dev Must be called by a contract implementing the ITimeswapBorrowCallback interface.
    /// @param param The borrow parameter found in the BorrowParam struct.
    /// @return assetOut The amount of asset ERC20 received.
    /// @return id The array index of the collateralized debt received by dueTo.
    /// @return dueOut The collateralized debt received by dueTo.
    function borrow(BorrowParam calldata param)
        external 
        returns (
            uint256 assetOut,
            uint256 id, 
            Due memory dueOut
        );

    /// @dev Pay asset ERC20 into the Pool to repay debt for borrowers.
    /// @dev If there are asset paid, must be called by a contract implementing the ITimeswapPayCallback interface.
    /// @param param The pay parameter found in the PayParam struct.
    /// @return assetIn The total amount of asset ERC20 paid.
    /// @return collateralOut The total amount of collateral ERC20 received.
    function pay(PayParam calldata param)
        external 
        returns (
            uint128 assetIn, 
            uint128 collateralOut
        );

    /// @dev Collect the stored protocol fee.
    /// @dev Can only be called by the owner.
    /// @param to The receiver of the protocol fee.
    /// @return protocolFeeOut The total amount of protocol fee asset ERC20 received.
    function collectProtocolFee(address to) external returns (uint256 protocolFeeOut);
}",3960
RealWorld_BA_96_DeployCollateralizedDebt_RealWord_20240826175512.log,96,DeployCollateralizedDebt,5898,5265,11163,75.0,0.13479,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.4;

import {IConvenience} from '../interfaces/IConvenience.sol';
import {IPair} from '@timeswap-labs/timeswap-v1-core/contracts/interfaces/IPair.sol';
import {CollateralizedDebt} from '../CollateralizedDebt.sol';
library DeployCollateralizedDebt {
    function deployCollateralizedDebt(
        IConvenience.Native storage native,
        bytes32 salt,
        IConvenience convenience,
        IPair pair,
        uint256 maturity
    ) external {
        native.collateralizedDebt = new CollateralizedDebt{salt: salt}(convenience, pair, maturity);
    }
}",150
RealWorld_BA_96_Math_RealWord_20240826171011.log,96,Math,4656,3403,8059,55.0,0.09134,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.4;

library Math {
    function divUp(uint256 x, uint256 y) internal pure returns (uint256 z) {
        z = x / y;
        if (x % y != 0) z++;
    }

    function shiftRightUp(uint256 x, uint8 y) internal pure returns (uint256 z) {
        z = x >> y;
        if (x != z << y) z++;
    }

}",104
RealWorld_BA_96_TimeswapPairCallee_RealWord_20240826170522.log,96,TimeswapPairCallee,21778,5857,27635,87.0,0.22603,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.4;

import {IPair} from '../interfaces/IPair.sol';
import {IFactory} from '../interfaces/IFactory.sol';
import {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import {ITimeswapBorrowCallback} from '../interfaces/callback/ITimeswapBorrowCallback.sol';
import {ITimeswapLendCallback} from '../interfaces/callback/ITimeswapLendCallback.sol';
import {ITimeswapMintCallback} from '../interfaces/callback/ITimeswapMintCallback.sol';
import {ITimeswapPayCallback} from '../interfaces/callback/ITimeswapPayCallback.sol';



contract TimeswapPairCallee {
    IPair public immutable  pairContract;
    IFactory public immutable  factoryContract;

    constructor(address pair) {
        pairContract = IPair(pair);
        factoryContract = IPair(pair).factory();
    }
    
    struct PairCalleeInfo {
        IERC20 asset;
        IERC20 collateral;
        address from;
    }
    struct PairCalleeInfoMint {
        IERC20 asset;
        IERC20 collateral;
        address assetFrom;
        address collateralFrom;
    }

    function getData(address from) public view returns (bytes memory data) {
        data = abi.encode(PairCalleeInfo(pairContract.asset(),pairContract.collateral(),from));
    }

    function getDataMint(address from) public view returns (bytes memory data){
        data =  abi.encode(PairCalleeInfoMint(pairContract.asset(),pairContract.collateral(),from,from));
    }

    function mint(
        uint256 maturity,
        address liquidityTo,
        uint112 xIncrease,
        uint112 yIncrease,
        uint112 zIncrease
    )
        external 
        returns (
            uint256 assetIn,
            uint256 liquidityOut,
            uint256 id,
            IPair.Due memory dueOut
        )
    {   
        return pairContract.mint(
            IPair.MintParam(
                maturity,
                liquidityTo,
                address(this),
                xIncrease,
                yIncrease,
                zIncrease,
                getDataMint(msg.sender)
            )
        );
    }

    function lend(
        uint256 maturity,
        address bondTo,
        address insuranceTo,
        uint112 xIncrease,
        uint112 yDecrease,
        uint112 zDecrease
    ) external returns (uint256 assetIn, IPair.Claims memory claimsOut){
        return pairContract.lend(
            IPair.LendParam(
                maturity,
                bondTo,
                insuranceTo,
                xIncrease,
                yDecrease,
                zDecrease,
                getData(msg.sender)
            )
        );
    }

    function borrow(
        uint256 maturity,
        address assetTo,
        address dueTo,
        uint112 xDecrease,
        uint112 yIncrease,
        uint112 zIncrease
    ) external returns (uint256 assetOut, uint256 id, IPair.Due memory dueOut){
        return pairContract.borrow(
            IPair.BorrowParam(
                maturity,
                assetTo,
                dueTo,
                xDecrease,
                yIncrease,
                zIncrease,
                getData(msg.sender)
            )
        );
    }

    function pay(
        uint256 maturity,
        address to,
        address owner,
        uint256[] memory ids,
        uint112[] memory assetsIn,
        uint112[] memory collateralsOut
    ) external returns (uint128 assetIn, uint128 collateralOut){
        return pairContract.pay(
            IPair.PayParam(
                maturity,
                to,
                owner,
                ids,
                assetsIn,
                collateralsOut,
                getData(msg.sender)
            )
        );
    }

    function timeswapMintCallback(
        uint256 assetIn,
        uint112 collateralIn,
        bytes calldata data
    ) external {
        (IERC20 asset, IERC20 collateral, address assetFrom, address collateralFrom) = abi.decode(
            data,
            (IERC20, IERC20, address, address)
        );
        IPair pair = factoryContract.getPair(asset, collateral);

        require(msg.sender == address(pair), 'Invalid sender');
        asset.transferFrom(assetFrom, address(pair), assetIn);
        collateral.transferFrom(collateralFrom, address(pair), collateralIn);
    }

    function timeswapLendCallback(uint256 assetIn, bytes calldata data) external {
        (IERC20 asset, IERC20 collateral, address from) = abi.decode(
            data,
            (IERC20, IERC20, address)
        );
        IPair pair = factoryContract.getPair(asset, collateral);

        require(msg.sender == address(pair), 'Invalid sender');
        asset.transferFrom(from, address(pair), assetIn);
    }

    function timeswapBorrowCallback(uint112 collateralIn, bytes calldata data) external {
        (IERC20 asset, IERC20 collateral, address from) = abi.decode(
            data,
            (IERC20, IERC20, address)
        );
        IPair pair = factoryContract.getPair(asset, collateral);

        require(msg.sender == address(pair), 'Invalid sender');
        collateral.transferFrom(from, address(pair), collateralIn);
    }
    
    function timeswapPayCallback(
        uint128 assetIn,
        bytes calldata data
    ) external {
        (IERC20 asset, IERC20 collateral, address from) = abi.decode(
            data,
            (IERC20, IERC20, address)
        );
        IPair pair = factoryContract.getPair(asset, collateral);
        asset.transferFrom(from, address(pair), assetIn);
        
    }
}",1183
RealWorld_BA_96_TimeswapPairCallee_RealWord_20240826174208.log,96,TimeswapPairCallee,22731,5970,28701,94.0,0.233055,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.4;

import {IPair} from '@timeswap-labs/timeswap-v1-core/contracts/interfaces/IPair.sol';
import {IFactory} from '@timeswap-labs/timeswap-v1-core/contracts/interfaces/IFactory.sol';
import {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import {ITimeswapBorrowCallback} from '@timeswap-labs/timeswap-v1-core/contracts/interfaces/callback/ITimeswapBorrowCallback.sol';
import {ITimeswapLendCallback} from '@timeswap-labs/timeswap-v1-core/contracts/interfaces/callback/ITimeswapLendCallback.sol';
import {ITimeswapMintCallback} from '@timeswap-labs/timeswap-v1-core/contracts/interfaces/callback/ITimeswapMintCallback.sol';
import {ITimeswapPayCallback} from '@timeswap-labs/timeswap-v1-core/contracts/interfaces/callback/ITimeswapPayCallback.sol';

contract TimeswapPairCallee {
    IPair public immutable pairContract;
    IFactory public immutable factoryContract;

    constructor(address pair) {
        pairContract = IPair(pair);
        factoryContract = IPair(pair).factory();
    }

    struct PairCalleeInfo {
        IERC20 asset;
        IERC20 collateral;
        address from;
    }
    struct PairCalleeInfoMint {
        IERC20 asset;
        IERC20 collateral;
        address assetFrom;
        address collateralFrom;
    }

    function getData(address from) public view returns (bytes memory data) {
        data = abi.encode(PairCalleeInfo(pairContract.asset(), pairContract.collateral(), from));
    }

    function getDataMint(address from) public view returns (bytes memory data) {
        data = abi.encode(PairCalleeInfoMint(pairContract.asset(), pairContract.collateral(), from, from));
    }

    function mint(
        uint256 maturity,
        address liquidityTo,
        uint112 xIncrease,
        uint112 yIncrease,
        uint112 zIncrease
    )
        external
        returns (
            uint256 assetIn,
            uint256 liquidityOut,
            uint256 id,
            IPair.Due memory dueOut
        )
    {
        return
            pairContract.mint(
                IPair.MintParam(
                    maturity,
                    liquidityTo,
                    address(this),
                    xIncrease,
                    yIncrease,
                    zIncrease,
                    getDataMint(msg.sender)
                )
            );
    }

    function lend(
        uint256 maturity,
        address bondTo,
        address insuranceTo,
        uint112 xIncrease,
        uint112 yDecrease,
        uint112 zDecrease
    ) external returns (uint256 assetIn, IPair.Claims memory claimsOut) {
        return
            pairContract.lend(
                IPair.LendParam(maturity, bondTo, insuranceTo, xIncrease, yDecrease, zDecrease, getData(msg.sender))
            );
    }

    function borrow(
        uint256 maturity,
        address assetTo,
        address dueTo,
        uint112 xDecrease,
        uint112 yIncrease,
        uint112 zIncrease
    )
        external
        returns (
            uint256 assetOut,
            uint256 id,
            IPair.Due memory dueOut
        )
    {
        return
            pairContract.borrow(
                IPair.BorrowParam(maturity, assetTo, dueTo, xDecrease, yIncrease, zIncrease, getData(msg.sender))
            );
    }

    function pay(
        uint256 maturity,
        address to,
        address owner,
        uint256[] memory ids,
        uint112[] memory assetsIn,
        uint112[] memory collateralsOut
    ) external returns (uint128 assetIn, uint128 collateralOut) {
        return
            pairContract.pay(IPair.PayParam(maturity, to, owner, ids, assetsIn, collateralsOut, getData(msg.sender)));
    }

    function timeswapMintCallback(
        uint256 assetIn,
        uint112 collateralIn,
        bytes calldata data
    ) external {
        (IERC20 asset, IERC20 collateral, address assetFrom, address collateralFrom) = abi.decode(
            data,
            (IERC20, IERC20, address, address)
        );
        IPair pair = factoryContract.getPair(asset, collateral);

        require(msg.sender == address(pair), 'Invalid sender');
        asset.transferFrom(assetFrom, address(pair), assetIn);
        collateral.transferFrom(collateralFrom, address(pair), collateralIn);
    }

    function timeswapLendCallback(uint256 assetIn, bytes calldata data) external {
        (IERC20 asset, IERC20 collateral, address from) = abi.decode(data, (IERC20, IERC20, address));
        IPair pair = factoryContract.getPair(asset, collateral);

        require(msg.sender == address(pair), 'Invalid sender');
        asset.transferFrom(from, address(pair), assetIn);
    }

    function timeswapBorrowCallback(uint112 collateralIn, bytes calldata data) external {
        (IERC20 asset, IERC20 collateral, address from) = abi.decode(data, (IERC20, IERC20, address));
        IPair pair = factoryContract.getPair(asset, collateral);

        require(msg.sender == address(pair), 'Invalid sender');
        collateral.transferFrom(from, address(pair), collateralIn);
    }

    function timeswapPayCallback(uint128 assetIn, bytes calldata data) external {
        (IERC20 asset, IERC20 collateral, address from) = abi.decode(data, (IERC20, IERC20, address));
        IPair pair = factoryContract.getPair(asset, collateral);
        asset.transferFrom(from, address(pair), assetIn);
    }
}",1218
RealWorld_BA_96_ConstantProduct_RealWord_20240826171608.log,96,ConstantProduct,6590,5346,11936,71.0,0.13987,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.4;

import {IPair} from '../interfaces/IPair.sol';
import {FullMath} from './FullMath.sol';

library ConstantProduct {
    using FullMath for uint256;

    function checkConstantProduct(
        IPair.State memory state,
        uint112 xReserve,
        uint128 yAdjusted,
        uint128 zAdjusted
    ) internal pure {

        (uint256 prod0, uint256 prod1) = (uint256(yAdjusted) * zAdjusted).mul512(xReserve);
        (uint256 _prod0, uint256 _prod1) = ((uint256(state.y) * state.z)).mul512(state.x);

        require(prod1 >= _prod1, 'E301(1)');
        if (prod1 == _prod1) require(prod0 >= _prod0, 'E301(2)');
    }
}",189
RealWorld_BA_96_CollateralizedDebt_RealWord_20240826173009.log,96,CollateralizedDebt,14668,5436,20104,83.0,0.18206,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.4;

import {IDue} from './interfaces/IDue.sol';
import {IERC721Receiver} from '@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol';
import {IConvenience} from './interfaces/IConvenience.sol';
import {IPair} from '@timeswap-labs/timeswap-v1-core/contracts/interfaces/IPair.sol';
import {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import {ERC721Permit} from './base/ERC721Permit.sol';
import {SafeMetadata} from './libraries/SafeMetadata.sol';
import {Strings} from '@openzeppelin/contracts/utils/Strings.sol';
import {NFTTokenURIScaffold} from './libraries/NFTTokenURIScaffold.sol';

contract CollateralizedDebt is IDue, ERC721Permit {
    using Strings for uint256;
    using SafeMetadata for IERC20;

    IConvenience public immutable override convenience;
    IPair public immutable override pair;
    uint256 public immutable override maturity;

    function name() external view override returns (string memory) {
        string memory assetName = pair.asset().safeName();
        string memory collateralName = pair.collateral().safeName();
        return
            string(
                abi.encodePacked(
                    'Timeswap Collateralized Debt - ',
                    assetName,
                    ' - ',
                    collateralName,
                    ' - ',
                    maturity.toString()
                )
            );
    }

    function symbol() external view override returns (string memory) {
        string memory assetSymbol = pair.asset().safeSymbol();
        string memory collateralSymbol = pair.collateral().safeSymbol();
        return string(abi.encodePacked('TS-CDT-', assetSymbol, '-', collateralSymbol, '-', maturity.toString()));
    }

    function tokenURI(uint256 id) external view override returns (string memory) {
        require(_owners[id] != address(0), 'E404');
        return NFTTokenURIScaffold.tokenURI(id, pair, pair.dueOf(maturity, address(convenience), id), maturity);
    }

    function assetDecimals() external view override returns (uint8) {
        return pair.asset().safeDecimals();
    }

    function collateralDecimals() external view override returns (uint8) {
        return pair.collateral().safeDecimals();
    }

    function totalSupply() external view override returns (uint256) {
        return pair.totalDuesOf(maturity, address(convenience));
    }

    function tokenByIndex(uint256 id) external view override returns (uint256) {
        require(id < pair.totalDuesOf(maturity, address(convenience)), 'E614');
        return id;
    }

    function dueOf(uint256 id) external view override returns (IPair.Due memory) {
        return pair.dueOf(maturity, address(convenience), id);
    }

    constructor(
        IConvenience _convenience,
        IPair _pair,
        uint256 _maturity
    ) ERC721Permit('Timeswap Collateralized Debt') {
        convenience = _convenience;
        pair = _pair;
        maturity = _maturity;
    }

    modifier onlyConvenience() {
        require(msg.sender == address(convenience), 'E403');
        _;
    }

    function mint(address to, uint256 id) external override onlyConvenience {
        _safeMint(to, id);
    }
}",729
RealWorld_BA_96_MsgValueCallee_RealWord_20240826174345.log,96,MsgValueCallee,4491,4059,8550,60.0,0.103635,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.4;

import {SafeCast} from '@timeswap-labs/timeswap-v1-core/contracts/libraries/SafeCast.sol';
import {MsgValue} from '../libraries/MsgValue.sol';
contract MsgValueCallee{
    function getUint112() payable public{
        MsgValue.getUint112();
    }
}",80
RealWorld_BA_96_InsuranceInterest_RealWord_20240826173545.log,96,InsuranceInterest,11589,4911,16500,67.0,0.156165,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.4;

import {IClaim} from './interfaces/IClaim.sol';
import {IConvenience} from './interfaces/IConvenience.sol';
import {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import {IPair} from '@timeswap-labs/timeswap-v1-core/contracts/interfaces/IPair.sol';
import {ERC20Permit} from './base/ERC20Permit.sol';
import {SafeMetadata} from './libraries/SafeMetadata.sol';
import {Strings} from '@openzeppelin/contracts/utils/Strings.sol';

contract InsuranceInterest is IClaim, ERC20Permit {
    using SafeMetadata for IERC20;
    using Strings for uint256;

    IConvenience public immutable override convenience;
    IPair public immutable override pair;
    uint256 public immutable override maturity;

    function name() external view override returns (string memory) {
        string memory assetName = pair.asset().safeName();
        string memory collateralName = pair.collateral().safeName();
        return
            string(
                abi.encodePacked(
                    'Timeswap Insurance Interest- ',
                    assetName,
                    ' - ',
                    collateralName,
                    ' - ',
                    maturity.toString()
                )
            );
    }

    function symbol() external view override returns (string memory) {
        string memory assetSymbol = pair.asset().safeSymbol();
        string memory collateralSymbol = pair.collateral().safeSymbol();
        return string(abi.encodePacked('TS-INS-INT-', assetSymbol, '-', collateralSymbol, '-', maturity.toString()));
    }

    function decimals() external view override returns (uint8) {
        return pair.collateral().safeDecimals();
    }

    function totalSupply() external view override returns (uint256) {
        return pair.claimsOf(maturity, address(convenience)).insuranceInterest;
    }

    constructor(
        IConvenience _convenience,
        IPair _pair,
        uint256 _maturity
    ) ERC20Permit('Timeswap Insurance Interest') {
        convenience = _convenience;
        pair = _pair;
        maturity = _maturity;
    }

    modifier onlyConvenience() {
        require(msg.sender == address(convenience), 'E403');
        _;
    }

    function mint(address to, uint128 amount) external override onlyConvenience {
        _mint(to, amount);
    }

    function burn(address from, uint128 amount) external override onlyConvenience {
        _burn(from, amount);
    }
}",533
RealWorld_BA_96_ITimeswapLendCallback_RealWord_20240826172251.log,96,ITimeswapLendCallback,6274,5413,11687,82.0,0.13963,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.4;

/// @title Callback for ITimeswapPair#lend
/// @notice Any contract that calls ITimeswapPair#lend must implement this interface
interface ITimeswapLendCallback {
    /// @notice Called to `msg.sender` after initiating a lend from ITimeswapPair#lend.
    /// @dev In the implementation you must pay the asset token owed for the lend transaction.
    /// The caller of this method must be checked to be a TimeswapPair deployed by the canonical TimeswapFactory.
    /// @param assetIn The amount of asset tokens owed due to the pool for the lend transaction
    /// @param data Any data passed through by the caller via the ITimeswapPair#lend call
    function timeswapLendCallback(
        uint256 assetIn,
        bytes calldata data
    ) external;
}",191
RealWorld_BA_96_SafeTransferCallee_RealWord_20240826173654.log,96,SafeTransferCallee,5774,4978,10752,73.0,0.12843,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.4;

import {IPair} from '@timeswap-labs/timeswap-v1-core/contracts/interfaces/IPair.sol';
import {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import {SafeTransfer} from '../libraries/SafeTransfer.sol';

contract SafeTransferCallee{
    function safeTransfer(IERC20 token, IPair to, uint256 amount) public  {
        return SafeTransfer.safeTransfer(token, to, amount);
    }
    function safeTransferFrom( IERC20 token,
        address from,
        IPair to,
        uint256 amount) public{
            return SafeTransfer.safeTransferFrom(token, from, to, amount);
        }
}",161
RealWorld_BA_96_TimeswapMath_RealWord_20240826171721.log,96,TimeswapMath,51489,5688,57177,80.0,0.371205,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.4;

import {IPair} from '../interfaces/IPair.sol';
import {Math} from './Math.sol';
import {FullMath} from './FullMath.sol';
import {ConstantProduct} from './ConstantProduct.sol';
import {SafeCast} from './SafeCast.sol';
import {BlockNumber} from './BlockNumber.sol';

library TimeswapMath {
    using Math for uint256;
    using FullMath for uint256;
    using ConstantProduct for IPair.State;
    using SafeCast for uint256;

    uint256 private constant BASE = 0x10000000000;

    function mint(
        uint256 maturity,
        IPair.State memory state,
        uint112 xIncrease, 
        uint112 yIncrease, 
        uint112 zIncrease
    ) 
        external 
        view 
        returns(
            uint256 liquidityOut,
            IPair.Due memory dueOut,
            uint256 feeStoredIncrease
        )
    {
        if (state.totalLiquidity == 0) {
            liquidityOut = xIncrease;
            liquidityOut <<= 16;
        } else {
            uint256 fromX = state.totalLiquidity.mulDiv(xIncrease, state.x);
            uint256 fromY = state.totalLiquidity.mulDiv(yIncrease, state.y);
            uint256 fromZ = state.totalLiquidity.mulDiv(zIncrease, state.z);

            require(fromY <= fromX,'E214');
            require(fromZ <= fromX, 'E215');

            liquidityOut = fromY <= fromZ ? fromY : fromZ;

            feeStoredIncrease = state.feeStored.mulDivUp(liquidityOut, state.totalLiquidity);
        }

        uint256 _debtIn = maturity;
        _debtIn -= block.timestamp;
        _debtIn *= yIncrease;
        _debtIn = _debtIn.shiftRightUp(32);
        _debtIn += xIncrease;
        dueOut.debt = _debtIn.toUint112();

        uint256 _collateralIn = maturity;
        _collateralIn -= block.timestamp; 
        _collateralIn *= zIncrease;
        _collateralIn = _collateralIn.shiftRightUp(25); 
        _collateralIn += zIncrease; 
        dueOut.collateral = _collateralIn.toUint112();

        dueOut.startBlock = BlockNumber.get();
    }

    function burn(
        IPair.State memory state,
        uint256 liquidityIn
    )
        external
        pure
        returns (
            uint128 assetOut,
            uint128 collateralOut,
            uint256 feeOut
        )
    {
        uint256 totalAsset = state.reserves.asset;
        uint256 totalCollateral = state.reserves.collateral;
        uint256 totalBond = state.totalClaims.bondPrincipal;
        totalBond += state.totalClaims.bondInterest;

        if (totalAsset >= totalBond) {
            uint256 _assetOut = totalAsset;
            unchecked { _assetOut -= totalBond; }
            _assetOut = _assetOut.mulDiv(liquidityIn, state.totalLiquidity);
            assetOut = _assetOut.toUint128();

            uint256 _collateralOut = totalCollateral;
            _collateralOut = _collateralOut.mulDiv(liquidityIn, state.totalLiquidity);
            collateralOut = _collateralOut.toUint128();
        } else {
            uint256 deficit = totalBond;
            unchecked { deficit -= totalAsset; }

            uint256 totalInsurance = state.totalClaims.insurancePrincipal;
            totalInsurance += state.totalClaims.insuranceInterest;

            if (totalCollateral * totalBond > deficit * totalInsurance) {
                uint256 _collateralOut = totalCollateral;
                uint256 subtrahend = deficit;
                subtrahend *= totalInsurance;
                subtrahend = subtrahend.divUp(totalBond);
                _collateralOut -= subtrahend;
                _collateralOut = _collateralOut.mulDiv(liquidityIn, state.totalLiquidity);
                collateralOut = _collateralOut.toUint128();
            }
        }

        feeOut = state.feeStored.mulDiv(liquidityIn, state.totalLiquidity);
    }

    function lend(
        uint256 maturity,
        IPair.State memory state,
        uint112 xIncrease,
        uint112 yDecrease,
        uint112 zDecrease,
        uint16 fee,
        uint16 protocolFee
    )
        external
        view
        returns (
            IPair.Claims memory claimsOut,
            uint256 feeStoredIncrease,
            uint256 protocolFeeStoredIncrease
        ) 
    {   
        lendCheck(state, xIncrease, yDecrease, zDecrease);

        claimsOut.bondPrincipal = xIncrease;
        claimsOut.bondInterest = getBondInterest(maturity, yDecrease);
        claimsOut.insurancePrincipal = getInsurancePrincipal(state, xIncrease);
        claimsOut.insuranceInterest = getInsuranceInterest(maturity, zDecrease);

        (feeStoredIncrease, protocolFeeStoredIncrease) = lendGetFees(
            maturity,
            xIncrease,
            fee,
            protocolFee
        );
    }

    function lendCheck(
        IPair.State memory state,
        uint112 xIncrease,
        uint112 yDecrease,
        uint112 zDecrease
    ) private pure {
        uint112 xReserve = state.x + xIncrease;
        uint112 yReserve = state.y - yDecrease;
        uint112 zReserve = state.z - zDecrease;
        state.checkConstantProduct(xReserve, yReserve, zReserve);
    }

    function getBondInterest(
        uint256 maturity,
        uint112 yDecrease
    ) private view returns (uint112 bondInterestOut) {
        uint256 _bondInterestOut = maturity;
        _bondInterestOut -= block.timestamp;
        _bondInterestOut *= yDecrease;
        _bondInterestOut >>= 32;
        bondInterestOut = _bondInterestOut.toUint112();
    }

    function getInsurancePrincipal(
        IPair.State memory state,
        uint112 xIncrease
    ) private pure returns (uint112 insurancePrincipalOut) {
        uint256 _insurancePrincipalOut = state.z;
        _insurancePrincipalOut *= xIncrease;
        uint256 denominator = state.x;
        denominator += xIncrease;
        _insurancePrincipalOut /= denominator;
        insurancePrincipalOut = _insurancePrincipalOut.toUint112();
    }

    function getInsuranceInterest(
        uint256 maturity,
        uint112 zDecrease
    ) private view returns (uint112 insuranceInterestOut) {
        uint256 _insuranceInterestOut = maturity;
        _insuranceInterestOut -= block.timestamp;
        _insuranceInterestOut *= zDecrease;
        _insuranceInterestOut >>= 25;
        insuranceInterestOut = _insuranceInterestOut.toUint112();
    }

    function lendGetFees(
        uint256 maturity,
        uint112 xIncrease,
        uint16 fee,
        uint16 protocolFee
    ) private view returns (
        uint256 feeStoredIncrease,
        uint256 protocolFeeStoredIncrease
        )
    {
        uint256 totalFee = fee;
        totalFee += protocolFee;

        uint256 numerator = maturity;
        numerator -= block.timestamp;
        numerator *= totalFee;
        numerator += BASE;

        uint256 adjusted = xIncrease;
        adjusted *= numerator;
        adjusted = adjusted.divUp(BASE);
        uint256 totalFeeStoredIncrease = adjusted;
        unchecked { totalFeeStoredIncrease -= xIncrease; }

        feeStoredIncrease = totalFeeStoredIncrease;
        feeStoredIncrease *= fee;
        feeStoredIncrease /= totalFee;
        protocolFeeStoredIncrease = totalFeeStoredIncrease;
        unchecked { protocolFeeStoredIncrease -= feeStoredIncrease; }
    }

    function withdraw(
        IPair.State memory state,
        IPair.Claims memory claimsIn
    ) external pure returns (IPair.Tokens memory tokensOut) {
        uint256 totalAsset = state.reserves.asset;
        uint256 totalBondPrincipal = state.totalClaims.bondPrincipal;
        uint256 totalBondInterest = state.totalClaims.bondInterest;
        uint256 totalBond = totalBondPrincipal;
        totalBond += totalBondInterest;

        if (totalAsset >= totalBond) {
            tokensOut.asset = claimsIn.bondPrincipal;
            tokensOut.asset += claimsIn.bondInterest;
        } else {
            if (totalAsset >= totalBondPrincipal) {
                uint256 remaining = totalAsset;
                unchecked { remaining -= totalBondPrincipal; }
                uint256 _assetOut = claimsIn.bondInterest;
                _assetOut *= remaining;
                _assetOut /= totalBondInterest;
                _assetOut += claimsIn.bondPrincipal;
                tokensOut.asset = _assetOut.toUint128();
            } else {
                uint256 _assetOut = claimsIn.bondPrincipal;
                _assetOut *= totalAsset;
                _assetOut /= totalBondPrincipal;
                tokensOut.asset = _assetOut.toUint128();
            }
            
            uint256 deficit = totalBond;
            unchecked { deficit -= totalAsset; }

            uint256 totalInsurancePrincipal = state.totalClaims.insurancePrincipal;
            totalInsurancePrincipal *= deficit;
            uint256 totalInsuranceInterest = state.totalClaims.insuranceInterest;
            totalInsuranceInterest *= deficit;
            uint256 totalInsurance = totalInsurancePrincipal;
            totalInsurance += totalInsuranceInterest;

            uint256 totalCollateral = state.reserves.collateral;
            totalCollateral *= totalBond;

            if (totalCollateral >= totalInsurance) {
                uint256 _collateralOut = claimsIn.insurancePrincipal;
                _collateralOut += claimsIn.insuranceInterest;
                _collateralOut *= deficit;
                _collateralOut /= totalBond;
                tokensOut.collateral = _collateralOut.toUint128();
            } else if (totalCollateral >= totalInsurancePrincipal) {
                uint256 remaining = totalCollateral;
                unchecked { remaining -= totalInsurancePrincipal; }
                uint256 _collateralOut = claimsIn.insuranceInterest;
                _collateralOut *= deficit;
                uint256 denominator = totalInsuranceInterest;
                denominator *= totalBond;
                _collateralOut = _collateralOut.mulDiv(remaining, denominator);
                uint256 addend = claimsIn.insurancePrincipal;
                addend *= deficit;
                addend /= totalBond;
                _collateralOut += addend;
                tokensOut.collateral = _collateralOut.toUint128();
            } else {
                uint256 _collateralOut = claimsIn.insurancePrincipal;
                _collateralOut *= deficit;
                uint256 denominator = totalInsurancePrincipal;
                denominator *= totalBond;
                _collateralOut = _collateralOut.mulDiv(totalCollateral, denominator);
                tokensOut.collateral = _collateralOut.toUint128();
            }
        }
    }

    function borrow(
        uint256 maturity,
        IPair.State memory state,
        uint112 xDecrease,
        uint112 yIncrease,
        uint112 zIncrease,
        uint16 fee,
        uint16 protocolFee
    )
        external
        view
        returns (
            IPair.Due memory dueOut,
            uint256 feeStoredIncrease,
            uint256 protocolFeeStoredIncrease
        )
    {
        borrowCheck(state, xDecrease, yIncrease, zIncrease);

        dueOut.debt = getDebt(maturity, xDecrease, yIncrease);
        dueOut.collateral = getCollateral(maturity, state, xDecrease, zIncrease);
        dueOut.startBlock = BlockNumber.get();

        (feeStoredIncrease, protocolFeeStoredIncrease) = borrowGetFees(
            maturity,
            xDecrease,
            fee,
            protocolFee
        );
    }

    function borrowCheck(
        IPair.State memory state,
        uint112 xDecrease,
        uint112 yIncrease,
        uint112 zIncrease
    ) private pure {
        uint112 xReserve = state.x - xDecrease;
        uint112 yReserve = state.y + yIncrease;
        uint112 zReserve = state.z + zIncrease;
        state.checkConstantProduct(xReserve, yReserve, zReserve);

        uint256 yMax = xDecrease;
        yMax *= state.y;
        yMax = yMax.divUp(xReserve);
        require(yIncrease <= yMax, 'E214');

        uint256 zMax = xDecrease;
        zMax *= state.z;
        zMax = zMax.divUp(xReserve);
        require(zIncrease <= zMax, 'E215');
    }

    function getDebt(
        uint256 maturity,
        uint112 xDecrease,
        uint112 yIncrease
    ) private view returns (uint112 debtIn) {
        uint256 _debtIn = maturity;
        _debtIn -= block.timestamp;
        _debtIn *= yIncrease;
        _debtIn = _debtIn.shiftRightUp(32);
        _debtIn += xDecrease;
        debtIn = _debtIn.toUint112();
    }

    function getCollateral(
        uint256 maturity,
        IPair.State memory state,
        uint112 xDecrease,
        uint112 zIncrease
    ) private view returns (uint112 collateralIn) {
        uint256 _collateralIn = maturity;
        _collateralIn -= block.timestamp;
        _collateralIn *= zIncrease;
        _collateralIn = _collateralIn.shiftRightUp(25);
        uint256 minimum = state.z;
        minimum *= xDecrease;
        uint256 denominator = state.x;
        denominator -= xDecrease;
        minimum = minimum.divUp(denominator);
        _collateralIn += minimum;
        collateralIn = _collateralIn.toUint112();
    }

    function borrowGetFees(
        uint256 maturity,
        uint112 xDecrease,
        uint16 fee,
        uint16 protocolFee
    ) private view returns (
            uint256 feeStoredIncrease,
            uint256 protocolFeeStoredIncrease
        )
    {

        uint256 totalFee = fee;
        totalFee += protocolFee;

        uint256 denominator = maturity;
        denominator -= block.timestamp;
        denominator *= totalFee;
        denominator += BASE;

        uint256 adjusted = xDecrease;
        adjusted *= BASE;
        adjusted /= denominator;
        uint256 totalFeeStoredIncrease = xDecrease;
        unchecked { totalFeeStoredIncrease -= adjusted; }

        feeStoredIncrease = totalFeeStoredIncrease;
        feeStoredIncrease *= fee;
        feeStoredIncrease /= totalFee;
        protocolFeeStoredIncrease = totalFeeStoredIncrease;
        unchecked { protocolFeeStoredIncrease -= feeStoredIncrease; }
    }
}",3075
RealWorld_BA_96_Burn_RealWord_20240826182114.log,96,Burn,15354,5206,20560,73.0,0.18089,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.4;

import {IConvenience} from '../interfaces/IConvenience.sol';
import {IFactory} from '@timeswap-labs/timeswap-v1-core/contracts/interfaces/IFactory.sol';
import {IWETH} from '../interfaces/IWETH.sol';
import {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import {IPair} from '@timeswap-labs/timeswap-v1-core/contracts/interfaces/IPair.sol';
import {IBurn} from '../interfaces/IBurn.sol';
import {ETH} from './ETH.sol';

library Burn {
    function removeLiquidity(
        mapping(IERC20 => mapping(IERC20 => mapping(uint256 => IConvenience.Native))) storage natives,
        IFactory factory,
        IBurn.RemoveLiquidity calldata params
    ) external returns (uint256 assetOut, uint128 collateralOut) {
        (assetOut, collateralOut) = _removeLiquidity(
            natives,
            IBurn._RemoveLiquidity(
                factory,
                params.asset,
                params.collateral,
                params.maturity,
                params.assetTo,
                params.collateralTo,
                params.liquidityIn
            )
        );
    }

    function removeLiquidityETHAsset(
        mapping(IERC20 => mapping(IERC20 => mapping(uint256 => IConvenience.Native))) storage natives,
        IFactory factory,
        IWETH weth,
        IBurn.RemoveLiquidityETHAsset calldata params
    ) external returns (uint256 assetOut, uint128 collateralOut) {
        (assetOut, collateralOut) = _removeLiquidity(
            natives,
            IBurn._RemoveLiquidity(
                factory,
                weth,
                params.collateral,
                params.maturity,
                address(this),
                params.collateralTo,
                params.liquidityIn
            )
        );

        if (assetOut != 0) {
            weth.withdraw(assetOut);
            ETH.transfer(params.assetTo, assetOut);
        }
    }

    function removeLiquidityETHCollateral(
        mapping(IERC20 => mapping(IERC20 => mapping(uint256 => IConvenience.Native))) storage natives,
        IFactory factory,
        IWETH weth,
        IBurn.RemoveLiquidityETHCollateral calldata params
    ) external returns (uint256 assetOut, uint128 collateralOut) {
        (assetOut, collateralOut) = _removeLiquidity(
            natives,
            IBurn._RemoveLiquidity(
                factory,
                params.asset,
                weth,
                params.maturity,
                params.assetTo,
                address(this),
                params.liquidityIn
            )
        );

        if (collateralOut != 0) {
            weth.withdraw(collateralOut);
            ETH.transfer(params.collateralTo, collateralOut);
        }
    }

    function _removeLiquidity(
        mapping(IERC20 => mapping(IERC20 => mapping(uint256 => IConvenience.Native))) storage natives,
        IBurn._RemoveLiquidity memory params
    ) private returns (uint256 assetOut, uint128 collateralOut) {
        IPair pair = params.factory.getPair(params.asset, params.collateral);
        require(address(pair) != address(0), 'E501');

        IConvenience.Native memory native = natives[params.asset][params.collateral][params.maturity];
        require(address(native.liquidity) != address(0), 'E502');

        (assetOut, collateralOut) = pair.burn(
            IPair.BurnParam(params.maturity, params.assetTo, params.collateralTo, params.liquidityIn)
        );

        native.liquidity.burn(msg.sender, params.liquidityIn);
    }
}",797
RealWorld_BA_96_IDue_RealWord_20240826184403.log,96,IDue,5828,5037,10865,69.0,0.12988,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.4;

import {IERC721Permit} from './IERC721Permit.sol';
import {IConvenience} from './IConvenience.sol';
import {IPair} from '@timeswap-labs/timeswap-v1-core/contracts/interfaces/IPair.sol';

/// @author Ricsson W. Ngo
interface IDue is IERC721Permit {
    // VIEW

    function convenience() external returns (IConvenience);

    function pair() external returns (IPair);

    function maturity() external returns (uint256);

    function dueOf(uint256 id) external returns (IPair.Due memory);

    // UPDATE

    function mint(address to, uint256 id) external;
}",159
RealWorld_BA_96_SafeBalance_RealWord_20240826170801.log,96,SafeBalance,5217,4242,9459,66.0,0.110925,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.4;

import {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import {Address} from '@openzeppelin/contracts/utils/Address.sol';

library SafeBalance {
    using Address for address;

    function safeBalance(
        IERC20 token
    ) internal view returns (uint256) {
        bytes memory data =
            address(token).functionStaticCall(
                abi.encodeWithSelector(IERC20.balanceOf.selector, address(this)),
                ""balanceOf Call to IERC20 token not successful""
            );
        return abi.decode(data, (uint256));
    }
}",142
RealWorld_BA_96_ITimeswapBorrowCallback_RealWord_20240826172140.log,96,ITimeswapBorrowCallback,6223,3995,10218,68.0,0.111015,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.4;

/// @title Callback for ITimeswapPair#borrow
/// @notice Any contract that calls ITimeswapPair#borrow must implement this interface
interface ITimeswapBorrowCallback {
    /// @notice Called to `msg.sender` after initiating a borrow from ITimeswapPair#borrow.
    /// @dev In the implementation you must pay the collateral token owed for the borrow transaction.
    /// The caller of this method must be checked to be a TimeswapPair deployed by the canonical TimeswapFactory.
    /// @param collateralIn The amount of asset tokens owed due to the pool for the borrow transaction
    /// @param data Any data passed through by the caller via the ITimeswapPair#borrow call
    function timeswapBorrowCallback(
        uint112 collateralIn,
        bytes calldata data
    ) external;
}",187
RealWorld_BA_96_ILiquidity_RealWord_20240826183717.log,96,ILiquidity,5396,4555,9951,83.0,0.11808,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.4;

import {IERC20Permit} from './IERC20Permit.sol';
import {IConvenience} from './IConvenience.sol';
import {IPair} from '@timeswap-labs/timeswap-v1-core/contracts/interfaces/IPair.sol';

/// @author Ricsson W. Ngo
interface ILiquidity is IERC20Permit {
    // VIEW

    function convenience() external returns (IConvenience);

    function pair() external returns (IPair);

    function maturity() external returns (uint256);

    // UPDATE

    function mint(address to, uint256 amount) external;

    function burn(address from, uint256 amount) external;
}",155
RealWorld_BA_96_Mint_RealWord_20240826175937.log,96,Mint,71983,4600,76583,80.0,0.451915,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.4;

import {IConvenience} from '../interfaces/IConvenience.sol';
import {IFactory} from '@timeswap-labs/timeswap-v1-core/contracts/interfaces/IFactory.sol';
import {IWETH} from '../interfaces/IWETH.sol';
import {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import {IPair} from '@timeswap-labs/timeswap-v1-core/contracts/interfaces/IPair.sol';
import {IMint} from '../interfaces/IMint.sol';
import {MintMath} from './MintMath.sol';
import {Deploy} from './Deploy.sol';
import {MsgValue} from './MsgValue.sol';
import {ETH} from './ETH.sol';

library Mint {
    using MintMath for IPair;
    using Deploy for IConvenience.Native;

    function newLiquidity(
        mapping(IERC20 => mapping(IERC20 => mapping(uint256 => IConvenience.Native))) storage natives,
        IConvenience convenience,
        IFactory factory,
        IMint.NewLiquidity calldata params
    )
        external
        returns (
            uint256 assetIn,
            uint256 liquidityOut,
            uint256 id,
            IPair.Due memory dueOut
        )
    {
        (assetIn, liquidityOut, id, dueOut) = _newLiquidity(
            natives,
            IMint._NewLiquidity(
                convenience,
                factory,
                params.asset,
                params.collateral,
                params.maturity,
                msg.sender,
                msg.sender,
                params.liquidityTo,
                params.dueTo,
                params.assetIn,
                params.debtIn,
                params.collateralIn,
                params.deadline
            )
        );
    }

    function newLiquidityETHAsset(
        mapping(IERC20 => mapping(IERC20 => mapping(uint256 => IConvenience.Native))) storage natives,
        IConvenience convenience,
        IFactory factory,
        IWETH weth,
        IMint.NewLiquidityETHAsset calldata params
    )
        external
        returns (
            uint256 assetIn,
            uint256 liquidityOut,
            uint256 id,
            IPair.Due memory dueOut
        )
    {
        uint112 assetInETH = MsgValue.getUint112();

        (assetIn, liquidityOut, id, dueOut) = _newLiquidity(
            natives,
            IMint._NewLiquidity(
                convenience,
                factory,
                weth,
                params.collateral,
                params.maturity,
                address(this),
                msg.sender,
                params.liquidityTo,
                params.dueTo,
                assetInETH,
                params.debtIn,
                params.collateralIn,
                params.deadline
            )
        );
    }

    function newLiquidityETHCollateral(
        mapping(IERC20 => mapping(IERC20 => mapping(uint256 => IConvenience.Native))) storage natives,
        IConvenience convenience,
        IFactory factory,
        IWETH weth,
        IMint.NewLiquidityETHCollateral calldata params
    )
        external
        returns (
            uint256 assetIn,
            uint256 liquidityOut,
            uint256 id,
            IPair.Due memory dueOut
        )
    {
        uint112 collateralIn = MsgValue.getUint112();

        (assetIn, liquidityOut, id, dueOut) = _newLiquidity(
            natives,
            IMint._NewLiquidity(
                convenience,
                factory,
                params.asset,
                weth,
                params.maturity,
                msg.sender,
                address(this),
                params.liquidityTo,
                params.dueTo,
                params.assetIn,
                params.debtIn,
                collateralIn,
                params.deadline
            )
        );
    }

    function liquidityGivenAsset(
        mapping(IERC20 => mapping(IERC20 => mapping(uint256 => IConvenience.Native))) storage natives,
        IConvenience convenience,
        IFactory factory,
        IMint.LiquidityGivenAsset calldata params
    )
        external
        returns (
            uint256 assetIn,
            uint256 liquidityOut,
            uint256 id,
            IPair.Due memory dueOut
        )
    {
        (assetIn, liquidityOut, id, dueOut) = _liquidityGivenAsset(
            natives,
            IMint._LiquidityGivenAsset(
                convenience,
                factory,
                params.asset,
                params.collateral,
                params.maturity,
                msg.sender,
                msg.sender,
                params.liquidityTo,
                params.dueTo,
                params.assetIn,
                params.minLiquidity,
                params.maxDebt,
                params.maxCollateral,
                params.deadline
            )
        );
    }

    function liquidityGivenAssetETHAsset(
        mapping(IERC20 => mapping(IERC20 => mapping(uint256 => IConvenience.Native))) storage natives,
        IConvenience convenience,
        IFactory factory,
        IWETH weth,
        IMint.LiquidityGivenAssetETHAsset calldata params
    )
        external
        returns (
            uint256 assetIn,
            uint256 liquidityOut,
            uint256 id,
            IPair.Due memory dueOut
        )
    {
        uint112 assetInETH = MsgValue.getUint112();

        (assetIn, liquidityOut, id, dueOut) = _liquidityGivenAsset(
            natives,
            IMint._LiquidityGivenAsset(
                convenience,
                factory,
                weth,
                params.collateral,
                params.maturity,
                address(this),
                msg.sender,
                params.liquidityTo,
                params.dueTo,
                assetInETH,
                params.minLiquidity,
                params.maxDebt,
                params.maxCollateral,
                params.deadline
            )
        );
    }

    function liquidityGivenAssetETHCollateral(
        mapping(IERC20 => mapping(IERC20 => mapping(uint256 => IConvenience.Native))) storage natives,
        IConvenience convenience,
        IFactory factory,
        IWETH weth,
        IMint.LiquidityGivenAssetETHCollateral calldata params
    )
        external
        returns (
            uint256 assetIn,
            uint256 liquidityOut,
            uint256 id,
            IPair.Due memory dueOut
        )
    {
        uint112 maxCollateral = MsgValue.getUint112();

        (assetIn, liquidityOut, id, dueOut) = _liquidityGivenAsset(
            natives,
            IMint._LiquidityGivenAsset(
                convenience,
                factory,
                params.asset,
                weth,
                params.maturity,
                msg.sender,
                address(this),
                params.liquidityTo,
                params.dueTo,
                params.assetIn,
                params.minLiquidity,
                params.maxDebt,
                maxCollateral,
                params.deadline
            )
        );

        if (maxCollateral > dueOut.collateral) {
            uint256 excess = maxCollateral;
            unchecked {
                excess -= dueOut.collateral;
            }
            ETH.transfer(payable(msg.sender), excess);
        }
    }

    function liquidityGivenDebt(
        mapping(IERC20 => mapping(IERC20 => mapping(uint256 => IConvenience.Native))) storage natives,
        IConvenience convenience,
        IFactory factory,
        IMint.LiquidityGivenDebt memory params
    )
        external
        returns (
            uint256 assetIn,
            uint256 liquidityOut,
            uint256 id,
            IPair.Due memory dueOut
        )
    {
        (assetIn, liquidityOut, id, dueOut) = _liquidityGivenDebt(
            natives,
            IMint._LiquidityGivenDebt(
                convenience,
                factory,
                params.asset,
                params.collateral,
                params.maturity,
                msg.sender,
                msg.sender,
                params.liquidityTo,
                params.dueTo,
                params.debtIn,
                params.minLiquidity,
                params.maxAsset,
                params.maxCollateral,
                params.deadline
            )
        );
    }

    function liquidityGivenDebtETHAsset(
        mapping(IERC20 => mapping(IERC20 => mapping(uint256 => IConvenience.Native))) storage natives,
        IConvenience convenience,
        IFactory factory,
        IWETH weth,
        IMint.LiquidityGivenDebtETHAsset memory params
    )
        external
        returns (
            uint256 assetIn,
            uint256 liquidityOut,
            uint256 id,
            IPair.Due memory dueOut
        )
    {
        uint112 maxAsset = MsgValue.getUint112();

        (assetIn, liquidityOut, id, dueOut) = _liquidityGivenDebt(
            natives,
            IMint._LiquidityGivenDebt(
                convenience,
                factory,
                weth,
                params.collateral,
                params.maturity,
                msg.sender,
                msg.sender,
                params.liquidityTo,
                params.dueTo,
                params.debtIn,
                params.minLiquidity,
                maxAsset,
                params.maxCollateral,
                params.deadline
            )
        );

        if (maxAsset > assetIn) {
            uint256 excess = maxAsset;
            unchecked {
                excess -= assetIn;
            }
            ETH.transfer(payable(msg.sender), excess);
        }
    }

    function liquidityGivenDebtETHCollateral(
        mapping(IERC20 => mapping(IERC20 => mapping(uint256 => IConvenience.Native))) storage natives,
        IConvenience convenience,
        IFactory factory,
        IWETH weth,
        IMint.LiquidityGivenDebtETHCollateral memory params
    )
        external
        returns (
            uint256 assetIn,
            uint256 liquidityOut,
            uint256 id,
            IPair.Due memory dueOut
        )
    {
        uint112 maxCollateral = MsgValue.getUint112();

        (assetIn, liquidityOut, id, dueOut) = _liquidityGivenDebt(
            natives,
            IMint._LiquidityGivenDebt(
                convenience,
                factory,
                params.asset,
                weth,
                params.maturity,
                msg.sender,
                msg.sender,
                params.liquidityTo,
                params.dueTo,
                params.debtIn,
                params.minLiquidity,
                params.maxAsset,
                maxCollateral,
                params.deadline
            )
        );

        if (maxCollateral > dueOut.collateral) {
            uint256 excess = maxCollateral;
            unchecked {
                excess -= dueOut.collateral;
            }
            ETH.transfer(payable(msg.sender), excess);
        }
    }

    function liquidityGivenCollateral(
        mapping(IERC20 => mapping(IERC20 => mapping(uint256 => IConvenience.Native))) storage natives,
        IConvenience convenience,
        IFactory factory,
        IMint.LiquidityGivenCollateral memory params
    )
        external
        returns (
            uint256 assetIn,
            uint256 liquidityOut,
            uint256 id,
            IPair.Due memory dueOut
        )
    {
        (assetIn, liquidityOut, id, dueOut) = _liquidityGivenCollateral(
            natives,
            IMint._LiquidityGivenCollateral(
                convenience,
                factory,
                params.asset,
                params.collateral,
                params.maturity,
                msg.sender,
                msg.sender,
                params.liquidityTo,
                params.dueTo,
                params.collateralIn,
                params.minLiquidity,
                params.maxAsset,
                params.maxDebt,
                params.deadline
            )
        );
    }

    function liquidityGivenCollateralETHAsset(
        mapping(IERC20 => mapping(IERC20 => mapping(uint256 => IConvenience.Native))) storage natives,
        IConvenience convenience,
        IFactory factory,
        IWETH weth,
        IMint.LiquidityGivenCollateralETHAsset memory params
    )
        external
        returns (
            uint256 assetIn,
            uint256 liquidityOut,
            uint256 id,
            IPair.Due memory dueOut
        )
    {
        uint112 maxAsset = MsgValue.getUint112();

        (assetIn, liquidityOut, id, dueOut) = _liquidityGivenCollateral(
            natives,
            IMint._LiquidityGivenCollateral(
                convenience,
                factory,
                weth,
                params.collateral,
                params.maturity,
                msg.sender,
                msg.sender,
                params.liquidityTo,
                params.dueTo,
                params.collateralIn,
                params.minLiquidity,
                maxAsset,
                params.maxDebt,
                params.deadline
            )
        );

        if (maxAsset > assetIn) {
            uint256 excess = maxAsset;
            unchecked {
                excess -= assetIn;
            }
            ETH.transfer(payable(msg.sender), excess);
        }
    }

    function liquidityGivenCollateralETHCollateral(
        mapping(IERC20 => mapping(IERC20 => mapping(uint256 => IConvenience.Native))) storage natives,
        IConvenience convenience,
        IFactory factory,
        IWETH weth,
        IMint.LiquidityGivenCollateralETHCollateral memory params
    )
        external
        returns (
            uint256 assetIn,
            uint256 liquidityOut,
            uint256 id,
            IPair.Due memory dueOut
        )
    {
        uint112 collateralIn = MsgValue.getUint112();

        (assetIn, liquidityOut, id, dueOut) = _liquidityGivenCollateral(
            natives,
            IMint._LiquidityGivenCollateral(
                convenience,
                factory,
                params.asset,
                weth,
                params.maturity,
                msg.sender,
                msg.sender,
                params.liquidityTo,
                params.dueTo,
                collateralIn,
                params.minLiquidity,
                params.maxAsset,
                params.maxDebt,
                params.deadline
            )
        );
    }

    function _newLiquidity(
        mapping(IERC20 => mapping(IERC20 => mapping(uint256 => IConvenience.Native))) storage natives,
        IMint._NewLiquidity memory params
    )
        private
        returns (
            uint256 assetIn,
            uint256 liquidityOut,
            uint256 id,
            IPair.Due memory dueOut
        )
    {
        require(params.debtIn > params.assetIn, 'E516');
        require(params.maturity > block.timestamp, 'E508');
        IPair pair = params.factory.getPair(params.asset, params.collateral);
        if (address(pair) == address(0)) pair = params.factory.createPair(params.asset, params.collateral);

        require(pair.totalLiquidity(params.maturity) == 0, 'E506');

        (uint112 xIncrease, uint112 yIncrease, uint112 zIncrease) = MintMath.givenNew(
            params.maturity,
            params.assetIn,
            params.debtIn,
            params.collateralIn
        );

        (assetIn, liquidityOut, id, dueOut) = _mint(
            natives,
            IMint._Mint(
                params.convenience,
                pair,
                params.asset,
                params.collateral,
                params.maturity,
                params.assetFrom,
                params.collateralFrom,
                params.liquidityTo,
                params.dueTo,
                xIncrease,
                yIncrease,
                zIncrease,
                params.deadline
            )
        );
    }

    function _liquidityGivenAsset(
        mapping(IERC20 => mapping(IERC20 => mapping(uint256 => IConvenience.Native))) storage natives,
        IMint._LiquidityGivenAsset memory params
    )
        private
        returns (
            uint256 assetIn,
            uint256 liquidityOut,
            uint256 id,
            IPair.Due memory dueOut
        )
    {
        IPair pair = params.factory.getPair(params.asset, params.collateral);
        if(address(pair)==address(0)){pair=params.factory.createPair(params.asset,params.collateral);}
        require(pair.totalLiquidity(params.maturity) != 0, 'E507');

        (uint112 xIncrease, uint112 yIncrease, uint112 zIncrease) = pair.givenAsset(params.maturity, params.assetIn);

        (assetIn, liquidityOut, id, dueOut) = _mint(
            natives,
            IMint._Mint(
                params.convenience,
                pair,
                params.asset,
                params.collateral,
                params.maturity,
                params.assetFrom,
                params.collateralFrom,
                params.liquidityTo,
                params.dueTo,
                xIncrease,
                yIncrease,
                zIncrease,
                params.deadline
            )
        );

        require(liquidityOut >= params.minLiquidity, 'E511');
        require(dueOut.debt <= params.maxDebt, 'E512');
        require(dueOut.collateral <= params.maxCollateral, 'E513');
    }

    function _liquidityGivenDebt(
        mapping(IERC20 => mapping(IERC20 => mapping(uint256 => IConvenience.Native))) storage natives,
        IMint._LiquidityGivenDebt memory params
    )
        private
        returns (
            uint256 assetIn,
            uint256 liquidityOut,
            uint256 id,
            IPair.Due memory dueOut
        )
    {
        IPair pair = params.factory.getPair(params.asset, params.collateral);
        require(address(pair) != address(0), 'E501');
        require(pair.totalLiquidity(params.maturity) != 0, 'E507');

        (uint112 xIncrease, uint112 yIncrease, uint112 zIncrease) = pair.givenDebt(params.maturity, params.debtIn);

        (assetIn, liquidityOut, id, dueOut) = _mint(
            natives,
            IMint._Mint(
                params.convenience,
                pair,
                params.asset,
                params.collateral,
                params.maturity,
                params.assetFrom,
                params.collateralFrom,
                params.liquidityTo,
                params.dueTo,
                xIncrease,
                yIncrease,
                zIncrease,
                params.deadline
            )
        );

        require(liquidityOut >= params.minLiquidity, 'E511');
        require(xIncrease <= params.maxAsset, 'E519');
        require(dueOut.collateral <= params.maxCollateral, 'E513');
    }

    function _liquidityGivenCollateral(
        mapping(IERC20 => mapping(IERC20 => mapping(uint256 => IConvenience.Native))) storage natives,
        IMint._LiquidityGivenCollateral memory params
    )
        private
        returns (
            uint256 assetIn,
            uint256 liquidityOut,
            uint256 id,
            IPair.Due memory dueOut
        )
    {
        IPair pair = params.factory.getPair(params.asset, params.collateral);
        require(address(pair) != address(0), 'E501');
        require(pair.totalLiquidity(params.maturity) != 0, 'E507');

        (uint112 xIncrease, uint112 yIncrease, uint112 zIncrease) = pair.givenCollateral(
            params.maturity,
            params.collateralIn
        );
        (assetIn, liquidityOut, id, dueOut) = _mint(
            natives,
            IMint._Mint(
                params.convenience,
                pair,
                params.asset,
                params.collateral,
                params.maturity,
                params.assetFrom,
                params.collateralFrom,
                params.liquidityTo,
                params.dueTo,
                xIncrease,
                yIncrease,
                zIncrease,
                params.deadline
            )
        );
        require(liquidityOut >= params.minLiquidity, 'E511');
        require(xIncrease <= params.maxAsset, 'E519');
        require(dueOut.debt <= params.maxDebt, 'E512');
    }

    function _mint(
        mapping(IERC20 => mapping(IERC20 => mapping(uint256 => IConvenience.Native))) storage natives,
        IMint._Mint memory params
    )
        private
        returns (
            uint256 assetIn,
            uint256 liquidityOut,
            uint256 id,
            IPair.Due memory dueOut
        )
    {
        require(params.deadline >= block.timestamp, 'E504');
        require(params.maturity > block.timestamp, 'E508');
        IConvenience.Native storage native = natives[params.asset][params.collateral][params.maturity];
        if (address(native.liquidity) == address(0))
            native.deploy(params.convenience, params.pair, params.asset, params.collateral, params.maturity);
        (assetIn, liquidityOut, id, dueOut) = params.pair.mint(
            IPair.MintParam(
                params.maturity,
                address(this),
                address(this),
                params.xIncrease,
                params.yIncrease,
                params.zIncrease,
                bytes(abi.encode(params.asset, params.collateral, params.assetFrom, params.collateralFrom))
            )
        );
        native.liquidity.mint(params.liquidityTo, liquidityOut);
        native.collateralizedDebt.mint(params.dueTo, id);
 
    }
}",4444
RealWorld_BA_96_DateTime_RealWord_20240826175732.log,96,DateTime,63290,4997,68287,123.0,0.41639,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

// ----------------------------------------------------------------------------
// BokkyPooBah's DateTime Library v1.01
//
// A gas-efficient Solidity date and time library
//
// https://github.com/bokkypoobah/BokkyPooBahsDateTimeLibrary
//
// Tested date range 1970/01/01 to 2345/12/31
//
// Conventions:
// Unit      | Range         | Notes
// :-------- |:-------------:|:-----
// timestamp | >= 0          | Unix timestamp, number of seconds since 1970/01/01 00:00:00 UTC
// year      | 1970 ... 2345 |
// month     | 1 ... 12      |
// day       | 1 ... 31      |
// hour      | 0 ... 23      |
// minute    | 0 ... 59      |
// second    | 0 ... 59      |
// dayOfWeek | 1 ... 7       | 1 = Monday, ..., 7 = Sunday
//
//
// Enjoy. (c) BokkyPooBah / Bok Consulting Pty Ltd 2018-2019. The MIT Licence.
// ----------------------------------------------------------------------------

library DateTime {
    uint256 constant SECONDS_PER_DAY = 86400;
    uint256 constant SECONDS_PER_HOUR = 3600;
    uint256 constant SECONDS_PER_MINUTE = 60;
    int256 constant OFFSET19700101 = 2440588;

    uint256 constant DOW_MON = 1;
    uint256 constant DOW_TUE = 2;
    uint256 constant DOW_WED = 3;
    uint256 constant DOW_THU = 4;
    uint256 constant DOW_FRI = 5;
    uint256 constant DOW_SAT = 6;
    uint256 constant DOW_SUN = 7;

    // ------------------------------------------------------------------------
    // Calculate the number of days from 1970/01/01 to year/month/day using
    // the date conversion algorithm from
    //   http://aa.usno.navy.mil/faq/docs/JD_Formula.php
    // and subtracting the offset 2440588 so that 1970/01/01 is day 0
    //
    // days = day
    //      - 32075
    //      + 1461 * (year + 4800 + (month - 14) / 12) / 4
    //      + 367 * (month - 2 - (month - 14) / 12 * 12) / 12
    //      - 3 * ((year + 4900 + (month - 14) / 12) / 100) / 4
    //      - offset
    // ------------------------------------------------------------------------
    function _daysFromDate(
        uint256 year,
        uint256 month,
        uint256 day
    ) internal pure returns (uint256 _days) {
        require(year >= 1970);
        int256 _year = int256(year);
        int256 _month = int256(month);
        int256 _day = int256(day);

        int256 __days = _day -
            32075 +
            (1461 * (_year + 4800 + (_month - 14) / 12)) /
            4 +
            (367 * (_month - 2 - ((_month - 14) / 12) * 12)) /
            12 -
            (3 * ((_year + 4900 + (_month - 14) / 12) / 100)) /
            4 -
            OFFSET19700101;

        _days = uint256(__days);
    }

    // ------------------------------------------------------------------------
    // Calculate year/month/day from the number of days since 1970/01/01 using
    // the date conversion algorithm from
    //   http://aa.usno.navy.mil/faq/docs/JD_Formula.php
    // and adding the offset 2440588 so that 1970/01/01 is day 0
    //
    // int L = days + 68569 + offset
    // int N = 4 * L / 146097
    // L = L - (146097 * N + 3) / 4
    // year = 4000 * (L + 1) / 1461001
    // L = L - 1461 * year / 4 + 31
    // month = 80 * L / 2447
    // dd = L - 2447 * month / 80
    // L = month / 11
    // month = month + 2 - 12 * L
    // year = 100 * (N - 49) + year + L
    // ------------------------------------------------------------------------
    function _daysToDate(uint256 _days)
        internal
        pure
        returns (
            uint256 year,
            uint256 month,
            uint256 day
        )
    {
        int256 __days = int256(_days);

        int256 L = __days + 68569 + OFFSET19700101;
        int256 N = (4 * L) / 146097;
        L = L - (146097 * N + 3) / 4;
        int256 _year = (4000 * (L + 1)) / 1461001;
        L = L - (1461 * _year) / 4 + 31;
        int256 _month = (80 * L) / 2447;
        int256 _day = L - (2447 * _month) / 80;
        L = _month / 11;
        _month = _month + 2 - 12 * L;
        _year = 100 * (N - 49) + _year + L;

        year = uint256(_year);
        month = uint256(_month);
        day = uint256(_day);
    }

    function timestampFromDate(
        uint256 year,
        uint256 month,
        uint256 day
    ) internal pure returns (uint256 timestamp) {
        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY;
    }

    function timestampFromDateTime(
        uint256 year,
        uint256 month,
        uint256 day,
        uint256 hour,
        uint256 minute,
        uint256 second
    ) internal pure returns (uint256 timestamp) {
        timestamp =
            _daysFromDate(year, month, day) *
            SECONDS_PER_DAY +
            hour *
            SECONDS_PER_HOUR +
            minute *
            SECONDS_PER_MINUTE +
            second;
    }

    function timestampToDate(uint256 timestamp)
        internal
        pure
        returns (
            uint256 year,
            uint256 month,
            uint256 day
        )
    {
        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);
    }

    function timestampToDateTime(uint256 timestamp)
        internal
        pure
        returns (
            uint256 year,
            uint256 month,
            uint256 day,
            uint256 hour,
            uint256 minute,
            uint256 second
        )
    {
        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);
        uint256 secs = timestamp % SECONDS_PER_DAY;
        hour = secs / SECONDS_PER_HOUR;
        secs = secs % SECONDS_PER_HOUR;
        minute = secs / SECONDS_PER_MINUTE;
        second = secs % SECONDS_PER_MINUTE;
    }

    function isValidDate(
        uint256 year,
        uint256 month,
        uint256 day
    ) internal pure returns (bool valid) {
        if (year >= 1970 && month != 0 && month <= 12) {
            if (day != 0 && day <= _getDaysInMonth(year, month)) {
                valid = true;
            }
        }
    }

    function isValidDateTime(
        uint256 year,
        uint256 month,
        uint256 day,
        uint256 hour,
        uint256 minute,
        uint256 second
    ) internal pure returns (bool valid) {
        if (isValidDate(year, month, day)) {
            if (hour < 24 && minute < 60 && second < 60) {
                valid = true;
            }
        }
    }

    function isLeapYear(uint256 timestamp) internal pure returns (bool leapYear) {
        (uint256 year, , ) = _daysToDate(timestamp / SECONDS_PER_DAY);
        leapYear = _isLeapYear(year);
    }

    function _isLeapYear(uint256 year) internal pure returns (bool leapYear) {
        leapYear = ((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0);
    }

    function isWeekDay(uint256 timestamp) internal pure returns (bool weekDay) {
        weekDay = getDayOfWeek(timestamp) <= DOW_FRI;
    }

    function isWeekEnd(uint256 timestamp) internal pure returns (bool weekEnd) {
        weekEnd = getDayOfWeek(timestamp) >= DOW_SAT;
    }

    function getDaysInMonth(uint256 timestamp) internal pure returns (uint256 daysInMonth) {
        (uint256 year, uint256 month, ) = _daysToDate(timestamp / SECONDS_PER_DAY);
        daysInMonth = _getDaysInMonth(year, month);
    }

    function _getDaysInMonth(uint256 year, uint256 month) internal pure returns (uint256 daysInMonth) {
        if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {
            daysInMonth = 31;
        } else if (month != 2) {
            daysInMonth = 30;
        } else {
            daysInMonth = _isLeapYear(year) ? 29 : 28;
        }
    }

    // 1 = Monday, 7 = Sunday
    function getDayOfWeek(uint256 timestamp) internal pure returns (uint256 dayOfWeek) {
        uint256 _days = timestamp / SECONDS_PER_DAY;
        dayOfWeek = ((_days + 3) % 7) + 1;
    }

    function getYear(uint256 timestamp) internal pure returns (uint256 year) {
        (year, , ) = _daysToDate(timestamp / SECONDS_PER_DAY);
    }

    function getMonth(uint256 timestamp) internal pure returns (uint256 month) {
        (, month, ) = _daysToDate(timestamp / SECONDS_PER_DAY);
    }

    function getDay(uint256 timestamp) internal pure returns (uint256 day) {
        (, , day) = _daysToDate(timestamp / SECONDS_PER_DAY);
    }

    function getHour(uint256 timestamp) internal pure returns (uint256 hour) {
        uint256 secs = timestamp % SECONDS_PER_DAY;
        hour = secs / SECONDS_PER_HOUR;
    }

    function getMinute(uint256 timestamp) internal pure returns (uint256 minute) {
        uint256 secs = timestamp % SECONDS_PER_HOUR;
        minute = secs / SECONDS_PER_MINUTE;
    }

    function getSecond(uint256 timestamp) internal pure returns (uint256 second) {
        second = timestamp % SECONDS_PER_MINUTE;
    }

    function addYears(uint256 timestamp, uint256 _years) internal pure returns (uint256 newTimestamp) {
        (uint256 year, uint256 month, uint256 day) = _daysToDate(timestamp / SECONDS_PER_DAY);
        year += _years;
        uint256 daysInMonth = _getDaysInMonth(year, month);
        if (day > daysInMonth) {
            day = daysInMonth;
        }
        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + (timestamp % SECONDS_PER_DAY);
        require(newTimestamp >= timestamp);
    }

    function addMonths(uint256 timestamp, uint256 _months) internal pure returns (uint256 newTimestamp) {
        (uint256 year, uint256 month, uint256 day) = _daysToDate(timestamp / SECONDS_PER_DAY);
        month += _months;
        year += (month - 1) / 12;
        month = ((month - 1) % 12) + 1;
        uint256 daysInMonth = _getDaysInMonth(year, month);
        if (day > daysInMonth) {
            day = daysInMonth;
        }
        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + (timestamp % SECONDS_PER_DAY);
        require(newTimestamp >= timestamp);
    }

    function addDays(uint256 timestamp, uint256 _days) internal pure returns (uint256 newTimestamp) {
        newTimestamp = timestamp + _days * SECONDS_PER_DAY;
        require(newTimestamp >= timestamp);
    }

    function addHours(uint256 timestamp, uint256 _hours) internal pure returns (uint256 newTimestamp) {
        newTimestamp = timestamp + _hours * SECONDS_PER_HOUR;
        require(newTimestamp >= timestamp);
    }

    function addMinutes(uint256 timestamp, uint256 _minutes) internal pure returns (uint256 newTimestamp) {
        newTimestamp = timestamp + _minutes * SECONDS_PER_MINUTE;
        require(newTimestamp >= timestamp);
    }

    function addSeconds(uint256 timestamp, uint256 _seconds) internal pure returns (uint256 newTimestamp) {
        newTimestamp = timestamp + _seconds;
        require(newTimestamp >= timestamp);
    }

    function subYears(uint256 timestamp, uint256 _years) internal pure returns (uint256 newTimestamp) {
        (uint256 year, uint256 month, uint256 day) = _daysToDate(timestamp / SECONDS_PER_DAY);
        year -= _years;
        uint256 daysInMonth = _getDaysInMonth(year, month);
        if (day > daysInMonth) {
            day = daysInMonth;
        }
        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + (timestamp % SECONDS_PER_DAY);
        require(newTimestamp <= timestamp);
    }

    function subMonths(uint256 timestamp, uint256 _months) internal pure returns (uint256 newTimestamp) {
        (uint256 year, uint256 month, uint256 day) = _daysToDate(timestamp / SECONDS_PER_DAY);
        uint256 yearMonth = year * 12 + (month - 1) - _months;
        year = yearMonth / 12;
        month = (yearMonth % 12) + 1;
        uint256 daysInMonth = _getDaysInMonth(year, month);
        if (day > daysInMonth) {
            day = daysInMonth;
        }
        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + (timestamp % SECONDS_PER_DAY);
        require(newTimestamp <= timestamp);
    }

    function subDays(uint256 timestamp, uint256 _days) internal pure returns (uint256 newTimestamp) {
        newTimestamp = timestamp - _days * SECONDS_PER_DAY;
        require(newTimestamp <= timestamp);
    }

    function subHours(uint256 timestamp, uint256 _hours) internal pure returns (uint256 newTimestamp) {
        newTimestamp = timestamp - _hours * SECONDS_PER_HOUR;
        require(newTimestamp <= timestamp);
    }

    function subMinutes(uint256 timestamp, uint256 _minutes) internal pure returns (uint256 newTimestamp) {
        newTimestamp = timestamp - _minutes * SECONDS_PER_MINUTE;
        require(newTimestamp <= timestamp);
    }

    function subSeconds(uint256 timestamp, uint256 _seconds) internal pure returns (uint256 newTimestamp) {
        newTimestamp = timestamp - _seconds;
        require(newTimestamp <= timestamp);
    }

    function diffYears(uint256 fromTimestamp, uint256 toTimestamp) internal pure returns (uint256 _years) {
        require(fromTimestamp <= toTimestamp);
        (uint256 fromYear, , ) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);
        (uint256 toYear, , ) = _daysToDate(toTimestamp / SECONDS_PER_DAY);
        _years = toYear - fromYear;
    }

    function diffMonths(uint256 fromTimestamp, uint256 toTimestamp) internal pure returns (uint256 _months) {
        require(fromTimestamp <= toTimestamp);
        (uint256 fromYear, uint256 fromMonth, ) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);
        (uint256 toYear, uint256 toMonth, ) = _daysToDate(toTimestamp / SECONDS_PER_DAY);
        _months = toYear * 12 + toMonth - fromYear * 12 - fromMonth;
    }

    function diffDays(uint256 fromTimestamp, uint256 toTimestamp) internal pure returns (uint256 _days) {
        require(fromTimestamp <= toTimestamp);
        _days = (toTimestamp - fromTimestamp) / SECONDS_PER_DAY;
    }

    function diffHours(uint256 fromTimestamp, uint256 toTimestamp) internal pure returns (uint256 _hours) {
        require(fromTimestamp <= toTimestamp);
        _hours = (toTimestamp - fromTimestamp) / SECONDS_PER_HOUR;
    }

    function diffMinutes(uint256 fromTimestamp, uint256 toTimestamp) internal pure returns (uint256 _minutes) {
        require(fromTimestamp <= toTimestamp);
        _minutes = (toTimestamp - fromTimestamp) / SECONDS_PER_MINUTE;
    }

    function diffSeconds(uint256 fromTimestamp, uint256 toTimestamp) internal pure returns (uint256 _seconds) {
        require(fromTimestamp <= toTimestamp);
        _seconds = toTimestamp - fromTimestamp;
    }
}",3713
RealWorld_BA_96_IWithdraw_RealWord_20240826185016.log,96,IWithdraw,7079,5182,12261,83.0,0.139035,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.4;

import {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import {IFactory} from '@timeswap-labs/timeswap-v1-core/contracts/interfaces/IFactory.sol';
import {IPair} from '@timeswap-labs/timeswap-v1-core/contracts/interfaces/IPair.sol';

interface IWithdraw {
    struct Collect {
        IERC20 asset;
        IERC20 collateral;
        uint256 maturity;
        address assetTo;
        address collateralTo;
        IPair.Claims claimsIn;
    }

    struct CollectETHAsset {
        IERC20 collateral;
        uint256 maturity;
        address payable assetTo;
        address collateralTo;
        IPair.Claims claimsIn;
    }

    struct CollectETHCollateral {
        IERC20 asset;
        uint256 maturity;
        address assetTo;
        address payable collateralTo;
        IPair.Claims claimsIn;
    }

    struct _Collect {
        IFactory factory;
        IERC20 asset;
        IERC20 collateral;
        uint256 maturity;
        address assetTo;
        address collateralTo;
        IPair.Claims claimsIn;
    }
}",254
RealWorld_BA_96_Base64_RealWord_20240826182013.log,96,Base64,12201,4587,16788,58.0,0.152745,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.4;

/// @title Base64
/// @author Brecht Devos - <brecht@loopring.org>
/// @notice Provides a function for encoding some bytes in base64
library Base64 {
    string internal constant TABLE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

    function encode(bytes memory data) internal pure returns (string memory) {
        if (data.length == 0) return '';
        
        // load the table into memory
        string memory table = TABLE;

        // multiply by 4/3 rounded up
        uint256 encodedLen = 4 * ((data.length + 2) / 3);

        // add some extra buffer at the end required for the writing
        string memory result = new string(encodedLen + 32);

        assembly {
            // set the actual output length
            mstore(result, encodedLen)
            
            // prepare the lookup table
            let tablePtr := add(table, 1)
            
            // input ptr
            let dataPtr := data
            let endPtr := add(dataPtr, mload(data))
            
            // result ptr, jump over length
            let resultPtr := add(result, 32)
            
            // run over the input, 3 bytes at a time
            for {} lt(dataPtr, endPtr) {}
            {
               dataPtr := add(dataPtr, 3)
               
               // read 3 bytes
               let input := mload(dataPtr)
               
               // write 4 characters
               mstore(resultPtr, shl(248, mload(add(tablePtr, and(shr(18, input), 0x3F)))))
               resultPtr := add(resultPtr, 1)
               mstore(resultPtr, shl(248, mload(add(tablePtr, and(shr(12, input), 0x3F)))))
               resultPtr := add(resultPtr, 1)
               mstore(resultPtr, shl(248, mload(add(tablePtr, and(shr( 6, input), 0x3F)))))
               resultPtr := add(resultPtr, 1)
               mstore(resultPtr, shl(248, mload(add(tablePtr, and(        input,  0x3F)))))
               resultPtr := add(resultPtr, 1)
            }
            
            // padding with '='
            switch mod(mload(data), 3)
            case 1 { mstore(sub(resultPtr, 2), shl(240, 0x3d3d)) }
            case 2 { mstore(sub(resultPtr, 1), shl(248, 0x3d)) }
        }
        
        return result;
    }
}",564
RealWorld_BA_96_IPay_RealWord_20240826184013.log,96,IPay,8083,5842,13925,85.0,0.157255,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.4;

import {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import {IFactory} from '@timeswap-labs/timeswap-v1-core/contracts/interfaces/IFactory.sol';

interface IPay {
    struct Repay {
        IERC20 asset;
        IERC20 collateral;
        uint256 maturity;
        address collateralTo;
        uint256[] ids;
        uint112[] maxAssetsIn;
        uint256 deadline;
    }

    struct RepayETHAsset {
        IERC20 collateral;
        uint256 maturity;
        address collateralTo;
        uint256[] ids;
        uint112[] maxAssetsIn;
        uint256 deadline;
    }

    struct RepayETHCollateral {
        IERC20 asset;
        uint256 maturity;
        address payable collateralTo;
        uint256[] ids;
        uint112[] maxAssetsIn;
        uint256 deadline;
    }

    struct _Repay {
        IFactory factory;
        IERC20 asset;
        IERC20 collateral;
        uint256 maturity;
        address from;
        address collateralTo;
        uint256[] ids;
        uint112[] maxAssetsIn;
        uint256 deadline;
    }
}",265
RealWorld_BA_96_TimeswapMath_RealWord_20240826175227.log,96,TimeswapMath,4083,5004,9087,81.0,0.120495,"// SPDX-License-Identifier: MIT
pragma solidity =0.8.4;
import '@timeswap-labs/timeswap-v1-core/contracts/libraries/TimeswapMath.sol';",38
RealWorld_BA_97_WhitelistPeriodManager_RealWord_20240826205329.log,97,WhitelistPeriodManager,40873,5624,46497,87.0,0.316845,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.0;

import ""@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";
import ""@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";

import ""../security/Pausable.sol"";
import ""./metatx/ERC2771ContextUpgradeable.sol"";
import ""./interfaces/ILiquidityProviders.sol"";
import ""./interfaces/ITokenManager.sol"";
import ""./interfaces/ILPToken.sol"";

contract WhitelistPeriodManager is Initializable, OwnableUpgradeable, Pausable, ERC2771ContextUpgradeable {
    ILiquidityProviders private liquidityProviders;
    ITokenManager private tokenManager;
    ILPToken private lpToken;
    bool public areWhiteListRestrictionsEnabled;

    /* LP Status */
    // EOA? -> status, stores addresses that we want to ignore, like staking contracts.
    mapping(address => bool) public isExcludedAddress;
    // Token -> TVL
    mapping(address => uint256) private totalLiquidity;
    // Token -> TVL
    mapping(address => mapping(address => uint256)) public totalLiquidityByLp;

    /* Caps */
    // Token Address -> Limit
    mapping(address => uint256) public perTokenTotalCap;
    // Token Address -> Limit
    mapping(address => uint256) public perTokenWalletCap;

    event ExcludedAddressStatusUpdated(address indexed lp, bool indexed status);
    event TotalCapUpdated(address indexed token, uint256 totalCap);
    event PerTokenWalletCap(address indexed token, uint256 perCommunityWalletCap);
    event WhiteListStatusUpdated(bool status);

    modifier onlyLiquidityPool() {
        require(_msgSender() == address(liquidityProviders), ""ERR__UNAUTHORIZED"");
        _;
    }

    modifier onlyLpNft() {
        require(_msgSender() == address(lpToken), ""ERR__UNAUTHORIZED"");
        _;
    }

    modifier tokenChecks(address tokenAddress) {
        require(tokenAddress != address(0), ""Token address cannot be 0"");
        require(_isSupportedToken(tokenAddress), ""Token not supported"");
        _;
    }

    /**
     * @dev initalizes the contract, acts as constructor
     * @param _trustedForwarder address of trusted forwarder
     */
    function initialize(
        address _trustedForwarder,
        address _liquidityProviders,
        address _tokenManager,
        address _lpToken,
        address _pauser
    ) public initializer {
        __ERC2771Context_init(_trustedForwarder);
        __Ownable_init();
        __Pausable_init(_pauser);
        areWhiteListRestrictionsEnabled = true;
        _setLiquidityProviders(_liquidityProviders);
        _setTokenManager(_tokenManager);
        _setLpToken(_lpToken);
    }

    function _isSupportedToken(address _token) internal view returns (bool) {
        return tokenManager.getTokensInfo(_token).supportedToken;
    }

    /**
     * @dev Internal Function which checks for various caps before allowing LP to add liqudity
     */
    function _beforeLiquidityAddition(
        address _lp,
        address _token,
        uint256 _amount
    ) internal {
        if (isExcludedAddress[_lp]) {
            return;
        }
        // Per Token Total Cap or PTTC
        require(ifEnabled(totalLiquidity[_token] + _amount <= perTokenTotalCap[_token]), ""ERR__LIQUIDITY_EXCEEDS_PTTC"");
        require(
            ifEnabled(totalLiquidityByLp[_token][_lp] + _amount <= perTokenWalletCap[_token]),
            ""ERR__LIQUIDITY_EXCEEDS_PTWC""
        );
        totalLiquidity[_token] += _amount;
        totalLiquidityByLp[_token][_lp] += _amount;
    }

    /**
     * @dev External Function which checks for various caps before allowing LP to add liqudity. Only callable by LiquidityPoolManager
     */
    function beforeLiquidityAddition(
        address _lp,
        address _token,
        uint256 _amount
    ) external onlyLiquidityPool whenNotPaused {
        _beforeLiquidityAddition(_lp, _token, _amount);
    }

    /**
     * @dev Internal Function which checks for various caps before allowing LP to remove liqudity
     */
    function _beforeLiquidityRemoval(
        address _lp,
        address _token,
        uint256 _amount
    ) internal {
        if (isExcludedAddress[_lp]) {
            return;
        }
        totalLiquidityByLp[_token][_lp] -= _amount;
        totalLiquidity[_token] -= _amount;
    }

    /**
     * @dev External Function which checks for various caps before allowing LP to remove liqudity. Only callable by LiquidityPoolManager
     */
    function beforeLiquidityRemoval(
        address _lp,
        address _token,
        uint256 _amount
    ) external onlyLiquidityPool whenNotPaused {
        _beforeLiquidityRemoval(_lp, _token, _amount);
    }

    /**
     * @dev External Function which checks for various caps before allowing LP to transfer their LpNFT. Only callable by LpNFT contract
     */
    function beforeLiquidityTransfer(
        address _from,
        address _to,
        address _token,
        uint256 _amount
    ) external onlyLpNft whenNotPaused {
        // Release limit from  _from
        _beforeLiquidityRemoval(_from, _token, _amount);

        // Block limit of _to
        _beforeLiquidityAddition(_to, _token, _amount);
    }

    function _setTokenManager(address _tokenManager) internal {
        tokenManager = ITokenManager(_tokenManager);
    }

    function setTokenManager(address _tokenManager) external onlyOwner {
        _setTokenManager(_tokenManager);
    }

    function _setLiquidityProviders(address _liquidityProviders) internal {
        liquidityProviders = ILiquidityProviders(_liquidityProviders);
    }

    function setLiquidityProviders(address _liquidityProviders) external onlyOwner {
        _setLiquidityProviders(_liquidityProviders);
    }

    function _setLpToken(address _lpToken) internal {
        lpToken = ILPToken(_lpToken);
    }

    function setLpToken(address _lpToken) external onlyOwner {
        _setLpToken(_lpToken);
    }

    function setIsExcludedAddressStatus(address[] memory _addresses, bool[] memory _status) external onlyOwner {
        require(_addresses.length == _status.length, ""ERR__LENGTH_MISMATCH"");
        for (uint256 i = 0; i < _addresses.length; ++i) {
            isExcludedAddress[_addresses[i]] = _status[i];
            emit ExcludedAddressStatusUpdated(_addresses[i], _status[i]);
        }
    }

    function setTotalCap(address _token, uint256 _totalCap) public tokenChecks(_token) onlyOwner {
        require(totalLiquidity[_token] <= _totalCap, ""ERR__TOTAL_CAP_LESS_THAN_SL"");
        require(_totalCap >= perTokenWalletCap[_token], ""ERR__TOTAL_CAP_LT_PTWC"");
        if (perTokenTotalCap[_token] != _totalCap) {
            perTokenTotalCap[_token] = _totalCap;
            emit TotalCapUpdated(_token, _totalCap);
        }
    }

    /**
     * @dev Special care must be taken when calling this function
     *      There are no checks for _perTokenWalletCap (since it's onlyOwner), but it's essential that it
     *      should be >= max lp provided by an lp.
     *      Checking this on chain will probably require implementing a bbst, which needs more bandwidth
     *      Call the view function getMaxCommunityLpPositon() separately before changing this value
     */
    function setPerTokenWalletCap(address _token, uint256 _perTokenWalletCap) public tokenChecks(_token) onlyOwner {
        require(_perTokenWalletCap <= perTokenTotalCap[_token], ""ERR__PWC_GT_PTTC"");
        if (perTokenWalletCap[_token] != _perTokenWalletCap) {
            perTokenWalletCap[_token] = _perTokenWalletCap;
            emit PerTokenWalletCap(_token, _perTokenWalletCap);
        }
    }

    function setCap(
        address _token,
        uint256 _totalCap,
        uint256 _perTokenWalletCap
    ) public onlyOwner {
        setTotalCap(_token, _totalCap);
        setPerTokenWalletCap(_token, _perTokenWalletCap);
    }

    function setCaps(
        address[] memory _tokens,
        uint256[] memory _totalCaps,
        uint256[] memory _perTokenWalletCaps
    ) external onlyOwner {
        require(
            _tokens.length == _totalCaps.length && _totalCaps.length == _perTokenWalletCaps.length,
            ""ERR__LENGTH_MISMACH""
        );
        for (uint256 i = 0; i < _tokens.length; ++i) {
            setCap(_tokens[i], _totalCaps[i], _perTokenWalletCaps[i]);
        }
    }

    /**
     * @dev Enables (or disables) reverts if liquidity exceeds caps.
     *      Even if this is disabled, the contract will continue to track LP's positions
     */
    function setAreWhiteListRestrictionsEnabled(bool _status) external onlyOwner {
        areWhiteListRestrictionsEnabled = _status;
        emit WhiteListStatusUpdated(_status);
    }

    /**
     * @dev Returns the maximum amount a single community LP has provided
     */
    function getMaxCommunityLpPositon(address _token) external view returns (uint256) {
        uint256 totalSupply = lpToken.totalSupply();
        uint256 maxLp = 0;
        for (uint256 i = 1; i <= totalSupply; ++i) {
            uint256 liquidity = totalLiquidityByLp[_token][lpToken.ownerOf(i)];
            if (liquidity > maxLp) {
                maxLp = liquidity;
            }
        }
        return maxLp;
    }

    /**
     * @dev returns the value of if (areWhiteListEnabled) then (_cond)
     */
    function ifEnabled(bool _cond) private view returns (bool) {
        return !areWhiteListRestrictionsEnabled || (areWhiteListRestrictionsEnabled && _cond);
    }

    /**
     * @dev Meta-Transaction Helper, returns msgSender
     */
    function _msgSender()
        internal
        view
        virtual
        override(ContextUpgradeable, ERC2771ContextUpgradeable)
        returns (address)
    {
        return ERC2771ContextUpgradeable._msgSender();
    }

    /**
     * @dev Meta-Transaction Helper, returns msgData
     */
    function _msgData()
        internal
        view
        virtual
        override(ContextUpgradeable, ERC2771ContextUpgradeable)
        returns (bytes calldata)
    {
        return ERC2771ContextUpgradeable._msgData();
    }
}",2422
RealWorld_BA_97_Polygon.ETH_RealWord_20240826210257.log,97,Polygon.ETH,78891,5458,84349,99.0,0.503615,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.0;

import ""../SvgHelperBase.sol"";

contract PolygonETH is SvgHelperBase {
    using Strings for uint256;

    constructor(uint256 _decimals) SvgHelperBase(_decimals) {}

    function getTokenSvg(
        uint256 _tokenId,
        uint256 _suppliedLiquidity,
        uint256 _totalSuppliedLiquidity
    ) public view virtual override returns (string memory) {
        string memory tokenId = _tokenId.toString();
        string memory suppliedLiquidity = _divideByPowerOf10(_suppliedLiquidity, tokenDecimals, 3);
        string memory sharePercent = _calculatePercentage(_suppliedLiquidity, _totalSuppliedLiquidity);
        return
            string(
                abi.encodePacked(
                    '<svg version=""1.1"" id=""prefix__Layer_1"" xmlns=""http://www.w3.org/2000/svg"" x=""0"" y=""0"" viewBox=""0 0 405 405"" xml:space=""preserve""><style>.prefix__st15,.prefix__st2{fill:#fff}.prefix__st15{fill-opacity:.602}.prefix__st26{font-family:&apos;Courier&apos;}.prefix__st27{font-size:24px}</style><radialGradient id=""prefix__SVGID_1_"" cx=""-908.612"" cy=""-47.221"" r=""1"" gradientTransform=""matrix(0 327.499 327.499 0 15667.466 297569.594)"" gradientUnits=""userSpaceOnUse""><stop offset=""0"" stop-color=""#8247e5""/><stop offset=""1""/></radialGradient><path d=""M30 0h345c16.57 0 30 13.43 30 30v345c0 16.57-13.43 30-30 30H30c-16.57 0-30-13.43-30-30V30C0 13.43 13.43 0 30 0z"" fill=""url(#prefix__SVGID_1_)""/><radialGradient id=""prefix__SVGID_00000141442605033164902770000000811733122206392226_"" cx=""-908.323"" cy=""-44.569"" r=""1"" gradientTransform=""matrix(0 270.995 167.538 0 7669.416 246228.469)"" gradientUnits=""userSpaceOnUse""><stop offset=""0"" stop-color=""#fff""/><stop offset="".711"" stop-color=""#627eea""/><stop offset=""1"" stop-opacity=""0""/><stop offset=""1"" stop-opacity=""0""/></radialGradient><path d=""M214.93 95.88c-5.94-8.8-18.93-8.8-24.87 0-43.56 64.49-70.9 107.33-70.9 149.07 0 45.6 37.28 82.55 83.33 82.55s83.33-36.95 83.33-82.55c.01-41.74-27.33-84.58-70.89-149.07z"" fill=""url(#prefix__SVGID_00000141442605033164902770000000811733122206392226_)""/><path class=""prefix__st2"" d=""M271.41 338.62a.8.8 0 00-.59-.24h-1.66a.8.8 0 00-.59.24.8.8 0 00-.24.59v5c0 .11-.02.22-.06.32-.04.1-.1.2-.18.27a.8.8 0 01-.59.24h-8.33c-.11 0-.22-.02-.32-.06s-.2-.1-.27-.18-.14-.17-.18-.27a.866.866 0 01-.06-.32v-5a.8.8 0 00-.24-.59.8.8 0 00-.59-.24h-1.67c-.22 0-.43.09-.59.24s-.24.37-.24.59v15a.8.8 0 00.24.59.8.8 0 00.59.24h1.67a.8.8 0 00.59-.24.8.8 0 00.24-.59v-5a.8.8 0 01.24-.59.8.8 0 01.59-.24h8.33a.8.8 0 01.59.24.8.8 0 01.24.59v5c0 .11.02.22.06.32.04.1.1.2.18.27s.17.14.27.18.21.06.32.06h1.66c.11 0 .22-.02.32-.06.1-.04.2-.1.27-.18s.14-.17.18-.27c.04-.1.06-.21.06-.32v-15c0-.11-.02-.22-.06-.32-.04-.11-.1-.2-.18-.27zM321.41 341.91a.8.8 0 00-.59-.24h-5.83v.04h-2.5a.8.8 0 01-.59-.24.8.8 0 01-.24-.59v-5a.8.8 0 00-.24-.59.8.8 0 00-.59-.24h-1.66c-.11 0-.22.02-.32.06-.1.04-.2.1-.27.18a.8.8 0 00-.24.59v18.33c0 .11.02.22.06.32.04.1.1.2.18.27a.8.8 0 00.59.24h1.66c.11 0 .22-.02.32-.06.1-.04.2-.1.27-.18a.8.8 0 00.24-.59v-8.33a.8.8 0 01.24-.59.8.8 0 01.59-.24h5a.8.8 0 01.59.24.8.8 0 01.24.59v8.33c0 .11.02.22.06.32.04.1.1.2.18.27a.8.8 0 00.59.24h1.66c.11 0 .22-.02.32-.06.1-.04.2-.1.27-.18a.8.8 0 00.24-.59v-11.7c0-.11-.02-.22-.06-.32a.624.624 0 00-.17-.28zM338.08 341.91a.8.8 0 00-.59-.24h-11.67c-.11 0-.22.02-.32.06a.98.98 0 00-.27.18.8.8 0 00-.24.59v11.66a.8.8 0 00.24.59.8.8 0 00.59.24h11.67a.8.8 0 00.59-.24.8.8 0 00.24-.59v-1.66c0-.11-.02-.22-.06-.32-.04-.1-.1-.2-.18-.27a.8.8 0 00-.59-.24h-8.33c-.22 0-.43-.09-.59-.24-.16-.16-.24-.37-.24-.59s.09-.43.24-.59c.16-.16.37-.24.59-.24h8.33a.8.8 0 00.59-.24.8.8 0 00.24-.59v-6.66c0-.11-.02-.22-.06-.32a.841.841 0 00-.18-.29zm-3.16 4.24a.8.8 0 01-.18.27.8.8 0 01-.59.24h-5a.8.8 0 01-.59-.24.8.8 0 01-.24-.59.8.8 0 01.24-.59.8.8 0 01.59-.24h5a.8.8 0 01.59.24.8.8 0 01.24.59c0 .11-.02.22-.06.32zM354.74 341.91a.8.8 0 00-.59-.24l-2.5.04h-9.17a.8.8 0 00-.59.24.8.8 0 00-.24.59v11.66c0 .11.02.22.06.32.04.1.1.2.18.27a.8.8 0 00.59.24h1.67a.8.8 0 00.59-.24.8.8 0 00.24-.59v-8.33a.8.8 0 01.24-.59.8.8 0 01.59-.24h5c.11 0 .22.02.32.06.1.04.2.1.27.18a.8.8 0 01.24.59v8.33c0 .11.02.22.06.32.04.1.1.2.18.27a.8.8 0 00.59.24h1.67a.8.8 0 00.59-.24.8.8 0 00.24-.59v-11.7c0-.11-.02-.22-.06-.32a.65.65 0 00-.17-.27zM288.08 341.91a.8.8 0 00-.59-.24h-1.67c-.11 0-.22.02-.32.06a.98.98 0 00-.27.18.8.8 0 00-.24.59v8.33a.8.8 0 01-.24.59.8.8 0 01-.59.24h-5c-.11 0-.22-.02-.32-.06-.1-.04-.2-.1-.27-.18a.8.8 0 01-.24-.59v-8.33c0-.11-.02-.22-.06-.32-.04-.1-.1-.2-.18-.27a.8.8 0 00-.59-.24h-1.67c-.11 0-.22.02-.32.06a.98.98 0 00-.27.18.8.8 0 00-.24.59v11.66a.8.8 0 00.24.59.8.8 0 00.59.24h8.34c.22 0 .43.09.59.24.16.16.24.37.24.59s-.09.43-.24.59c-.16.16-.37.24-.59.24h-5c-.11 0-.22.02-.32.06s-.2.1-.27.18-.14.17-.18.27c-.04.1-.06.21-.06.32v1.66c0 .11.02.22.06.32.04.1.1.2.18.27s.17.14.27.18.21.06.32.06h8.33a.8.8 0 00.59-.24.8.8 0 00.24-.59v-16.66c0-.11-.02-.22-.06-.32-.05-.08-.12-.17-.19-.25zM304.74 341.91a.8.8 0 00-.59-.24h-11.67a.8.8 0 00-.59.24.8.8 0 00-.24.59v16.66c0 .11.02.22.06.32.04.1.1.2.18.27a.8.8 0 00.59.24h1.67a.8.8 0 00.59-.24.8.8 0 00.24-.59v-3.33a.8.8 0 01.24-.59.8.8 0 01.59-.24h8.34a.8.8 0 00.59-.24.8.8 0 00.24-.59v-11.66a.866.866 0 00-.24-.6zm-3.09 8.93a.8.8 0 01-.52.77c-.1.04-.21.06-.32.06h-5a.8.8 0 01-.59-.24.8.8 0 01-.24-.59v-5a.8.8 0 01.24-.59.8.8 0 01.59-.24h5a.866.866 0 01.6.24.8.8 0 01.24.59v5zM329.97 96.59c.28 0 .57-.05.83-.16s.5-.27.7-.47a2.116 2.116 0 00.63-1.53V81.49a2.182 2.182 0 00-.62-1.52 2.105 2.105 0 00-1.52-.63h-4.31c-.57 0-1.12.23-1.52.63-.4.4-.63.95-.63 1.52v4.31c0 .28-.05.57-.16.83s-.27.5-.47.7a2.116 2.116 0 01-1.53.63h-4.31c-.28 0-.57-.05-.83-.16s-.5-.27-.7-.47a2.116 2.116 0 01-.63-1.53V64.24c0-.28.05-.57.16-.83s.27-.5.47-.7a2.116 2.116 0 011.53-.63h1.25c.42 0 .84-.12 1.2-.36.35-.24.63-.57.79-.97a2.138 2.138 0 00-.49-2.33l-7.68-7.76c-.2-.21-.44-.37-.7-.48a2.124 2.124 0 00-1.66 0c-.26.11-.5.27-.7.48l-7.72 7.76c-.3.3-.51.68-.59 1.09s-.04.85.12 1.24.43.73.78.96c.35.24.76.37 1.19.37h1.25c.29 0 .57.05.83.16s.5.27.7.47c.2.2.36.44.47.7.11.26.16.55.16.83v30.2c0 .28.05.57.16.83s.27.5.47.7a2.116 2.116 0 001.53.63h21.55z""/><path class=""prefix__st2"" d=""M324.14 70.08a2.116 2.116 0 001.53.63h4.31c.28 0 .57-.05.83-.16s.5-.27.7-.47a2.116 2.116 0 00.63-1.53v-4.31c0-.28.05-.57.16-.83s.27-.5.47-.7a2.116 2.116 0 011.53-.63h4.32c.28 0 .57.05.83.16s.5.27.7.47c.2.2.36.44.47.7.11.26.16.55.16.83v21.57c0 .28-.05.57-.16.83s-.27.5-.47.7a2.116 2.116 0 01-1.53.63h-1.26c-.42 0-.84.13-1.2.36-.35.24-.63.57-.79.97-.16.39-.2.83-.11 1.24.09.42.3.8.6 1.1l7.73 7.72c.2.2.44.37.7.48a2.124 2.124 0 002.36-.48l7.72-7.72c.3-.3.5-.69.58-1.1.08-.42.04-.85-.12-1.24a2.12 2.12 0 00-.79-.96c-.35-.24-.77-.36-1.19-.36h-1.29c-.28 0-.57-.05-.83-.16s-.5-.27-.7-.47a2.116 2.116 0 01-.63-1.53V55.6c0-.28-.05-.57-.16-.83s-.27-.5-.47-.7c-.2-.2-.44-.36-.7-.47-.26-.11-.55-.16-.83-.16h-21.57c-.28 0-.57.05-.83.16s-.5.27-.7.47a2.116 2.116 0 00-.63 1.53v12.95c0 .28.05.57.16.83s.27.5.47.7z""/><text transform=""translate(73.686 67)"" class=""prefix__st2 prefix__st26 prefix__st27"">',
                    suppliedLiquidity,
                    ' ETH</text><text transform=""rotate(-90 213.61 143.092)"" class=""prefix__st2 prefix__st26 prefix__st27"">',
                    sharePercent,
                    '%</text><path fill=""none"" stroke=""#fff"" stroke-miterlimit=""10"" d=""M61.86 267.12V114.71""/><text transform=""translate(79.915 355)"" class=""prefix__st2 prefix__st26"" font-size=""10"">ID: ',
                    tokenId,
                    '</text><path d=""M128.52 77.23H56.69c-2.76 0-5 2.24-5 5v7.47c0 2.76 2.24 5 5 5h71.83c2.76 0 5-2.24 5-5v-7.47c0-2.76-2.24-5-5-5z"" fill=""#8247e5""/><text transform=""translate(56.685 89.706)"" class=""prefix__st2"" font-size=""12"" font-family=""Courier-Bold"">ON POLYGON</text><g><circle cx=""60.19"" cy=""58.5"" r=""8.5"" fill-rule=""evenodd"" clip-rule=""evenodd"" fill=""#627eea""/><path class=""prefix__st15"" d=""M60.45 52.12v4.71l3.98 1.78-3.98-6.49z""/><path class=""prefix__st2"" d=""M60.45 52.12l-3.98 6.49 3.98-1.78v-4.71z""/><path class=""prefix__st15"" d=""M60.45 61.67v3.2l3.99-5.51-3.99 2.31z""/><path class=""prefix__st2"" d=""M60.45 64.87v-3.2l-3.98-2.31 3.98 5.51z""/><path d=""M60.45 60.93l3.98-2.31-3.98-1.78v4.09z"" fill=""#fff"" fill-opacity="".2""/><path class=""prefix__st15"" d=""M56.47 58.62l3.98 2.31v-4.09l-3.98 1.78z""/></g></svg>'
                )
            );
    }

    function getChainName() public pure override returns (string memory) {
        return ""Polygon"";
    }
}",4672
RealWorld_BA_97_Avalanche.USDC_RealWord_20240826210957.log,97,Avalanche.USDC,85643,5212,90855,93.0,0.532455,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.0;

import ""../SvgHelperBase.sol"";

contract AvalancheUSDC is SvgHelperBase {
    using Strings for uint256;

    constructor(uint256 _decimals) SvgHelperBase(_decimals) {}

    function getTokenSvg(
        uint256 _tokenId,
        uint256 _suppliedLiquidity,
        uint256 _totalSuppliedLiquidity
    ) public view virtual override returns (string memory) {
        string memory tokenId = _tokenId.toString();
        string memory suppliedLiquidity = _divideByPowerOf10(_suppliedLiquidity, tokenDecimals, 3);
        string memory sharePercent = _calculatePercentage(_suppliedLiquidity, _totalSuppliedLiquidity);
        return
            string(
                abi.encodePacked(
                    '<svg version=""1.1"" id=""prefix__Layer_1"" xmlns=""http://www.w3.org/2000/svg"" x=""0"" y=""0"" viewBox=""0 0 405 405"" xml:space=""preserve""><style>.prefix__st2{fill:#fff}.prefix__st31{font-family:&apos;Courier&apos;}.prefix__st32{font-size:24px}</style><radialGradient id=""prefix__SVGID_1_"" cx=""-452.223"" cy=""-503.611"" r=""1"" gradientTransform=""matrix(0 327.499 327.499 0 165134.5 148102.563)"" gradientUnits=""userSpaceOnUse""><stop offset=""0"" stop-color=""#e84142""/><stop offset=""1""/></radialGradient><path d=""M30 0h345c16.57 0 30 13.43 30 30v345c0 16.57-13.43 30-30 30H30c-16.57 0-30-13.43-30-30V30C0 13.43 13.43 0 30 0z"" fill=""url(#prefix__SVGID_1_)""/><radialGradient id=""prefix__SVGID_00000112620898175617978930000002313274521866282382_"" cx=""-451.644"" cy=""-502.284"" r=""1"" gradientTransform=""matrix(0 270.995 167.538 0 84354.203 122470.75)"" gradientUnits=""userSpaceOnUse""><stop offset=""0"" stop-color=""#fff""/><stop offset="".711"" stop-color=""#2775ca""/><stop offset=""1"" stop-opacity=""0""/><stop offset=""1"" stop-opacity=""0""/></radialGradient><path d=""M214.93 95.88c-5.94-8.8-18.93-8.8-24.87 0-43.56 64.49-70.9 107.33-70.9 149.07 0 45.6 37.28 82.55 83.33 82.55s83.33-36.95 83.33-82.55c.01-41.74-27.33-84.58-70.89-149.07z"" fill=""url(#prefix__SVGID_00000112620898175617978930000002313274521866282382_)""/><path class=""prefix__st2"" d=""M271.41 338.62a.8.8 0 00-.59-.24h-1.66a.8.8 0 00-.59.24.8.8 0 00-.24.59v5c0 .11-.02.22-.06.32-.04.1-.1.2-.18.27a.8.8 0 01-.59.24h-8.33c-.11 0-.22-.02-.32-.06s-.2-.1-.27-.18-.14-.17-.18-.27a.866.866 0 01-.06-.32v-5a.8.8 0 00-.24-.59.8.8 0 00-.59-.24h-1.67c-.22 0-.43.09-.59.24s-.24.37-.24.59v15a.8.8 0 00.24.59.8.8 0 00.59.24h1.67a.8.8 0 00.59-.24.8.8 0 00.24-.59v-5a.8.8 0 01.24-.59.8.8 0 01.59-.24h8.33a.8.8 0 01.59.24.8.8 0 01.24.59v5c0 .11.02.22.06.32.04.1.1.2.18.27s.17.14.27.18.21.06.32.06h1.66c.11 0 .22-.02.32-.06.1-.04.2-.1.27-.18s.14-.17.18-.27c.04-.1.06-.21.06-.32v-15c0-.11-.02-.22-.06-.32-.04-.11-.1-.2-.18-.27zM321.41 341.91a.8.8 0 00-.59-.24h-5.83v.04h-2.5a.8.8 0 01-.59-.24.8.8 0 01-.24-.59v-5a.8.8 0 00-.24-.59.8.8 0 00-.59-.24h-1.66c-.11 0-.22.02-.32.06-.1.04-.2.1-.27.18a.8.8 0 00-.24.59v18.33c0 .11.02.22.06.32.04.1.1.2.18.27a.8.8 0 00.59.24h1.66c.11 0 .22-.02.32-.06.1-.04.2-.1.27-.18a.8.8 0 00.24-.59v-8.33a.8.8 0 01.24-.59.8.8 0 01.59-.24h5a.8.8 0 01.59.24.8.8 0 01.24.59v8.33c0 .11.02.22.06.32.04.1.1.2.18.27a.8.8 0 00.59.24h1.66c.11 0 .22-.02.32-.06.1-.04.2-.1.27-.18a.8.8 0 00.24-.59v-11.7c0-.11-.02-.22-.06-.32a.624.624 0 00-.17-.28zM338.08 341.91a.8.8 0 00-.59-.24h-11.67c-.11 0-.22.02-.32.06a.98.98 0 00-.27.18.8.8 0 00-.24.59v11.66a.8.8 0 00.24.59.8.8 0 00.59.24h11.67a.8.8 0 00.59-.24.8.8 0 00.24-.59v-1.66c0-.11-.02-.22-.06-.32-.04-.1-.1-.2-.18-.27a.8.8 0 00-.59-.24h-8.33c-.22 0-.43-.09-.59-.24-.16-.16-.24-.37-.24-.59s.09-.43.24-.59c.16-.16.37-.24.59-.24h8.33a.8.8 0 00.59-.24.8.8 0 00.24-.59v-6.66c0-.11-.02-.22-.06-.32a.841.841 0 00-.18-.29zm-3.16 4.24a.8.8 0 01-.18.27.8.8 0 01-.59.24h-5a.8.8 0 01-.59-.24.8.8 0 01-.24-.59.8.8 0 01.24-.59.8.8 0 01.59-.24h5a.8.8 0 01.59.24.8.8 0 01.24.59c0 .11-.02.22-.06.32zM354.74 341.91a.8.8 0 00-.59-.24l-2.5.04h-9.17a.8.8 0 00-.59.24.8.8 0 00-.24.59v11.66c0 .11.02.22.06.32.04.1.1.2.18.27a.8.8 0 00.59.24h1.67a.8.8 0 00.59-.24.8.8 0 00.24-.59v-8.33a.8.8 0 01.24-.59.8.8 0 01.59-.24h5c.11 0 .22.02.32.06.1.04.2.1.27.18a.8.8 0 01.24.59v8.33c0 .11.02.22.06.32.04.1.1.2.18.27a.8.8 0 00.59.24h1.67a.8.8 0 00.59-.24.8.8 0 00.24-.59v-11.7c0-.11-.02-.22-.06-.32a.65.65 0 00-.17-.27zM288.08 341.91a.8.8 0 00-.59-.24h-1.67c-.11 0-.22.02-.32.06a.98.98 0 00-.27.18.8.8 0 00-.24.59v8.33a.8.8 0 01-.24.59.8.8 0 01-.59.24h-5c-.11 0-.22-.02-.32-.06-.1-.04-.2-.1-.27-.18a.8.8 0 01-.24-.59v-8.33c0-.11-.02-.22-.06-.32-.04-.1-.1-.2-.18-.27a.8.8 0 00-.59-.24h-1.67c-.11 0-.22.02-.32.06a.98.98 0 00-.27.18.8.8 0 00-.24.59v11.66a.8.8 0 00.24.59.8.8 0 00.59.24h8.34c.22 0 .43.09.59.24.16.16.24.37.24.59s-.09.43-.24.59c-.16.16-.37.24-.59.24h-5c-.11 0-.22.02-.32.06s-.2.1-.27.18-.14.17-.18.27c-.04.1-.06.21-.06.32v1.66c0 .11.02.22.06.32.04.1.1.2.18.27s.17.14.27.18.21.06.32.06h8.33a.8.8 0 00.59-.24.8.8 0 00.24-.59v-16.66c0-.11-.02-.22-.06-.32-.05-.08-.12-.17-.19-.25zM304.74 341.91a.8.8 0 00-.59-.24h-11.67a.8.8 0 00-.59.24.8.8 0 00-.24.59v16.66c0 .11.02.22.06.32.04.1.1.2.18.27a.8.8 0 00.59.24h1.67a.8.8 0 00.59-.24.8.8 0 00.24-.59v-3.33a.8.8 0 01.24-.59.8.8 0 01.59-.24h8.34a.8.8 0 00.59-.24.8.8 0 00.24-.59v-11.66a.866.866 0 00-.24-.6zm-3.09 8.93a.8.8 0 01-.52.77c-.1.04-.21.06-.32.06h-5a.8.8 0 01-.59-.24.8.8 0 01-.24-.59v-5a.8.8 0 01.24-.59.8.8 0 01.59-.24h5a.866.866 0 01.6.24.8.8 0 01.24.59v5zM329.97 96.59c.28 0 .57-.05.83-.16s.5-.27.7-.47a2.116 2.116 0 00.63-1.53V81.49a2.182 2.182 0 00-.62-1.52 2.105 2.105 0 00-1.52-.63h-4.31c-.57 0-1.12.23-1.52.63-.4.4-.63.95-.63 1.52v4.31c0 .28-.05.57-.16.83s-.27.5-.47.7a2.116 2.116 0 01-1.53.63h-4.31c-.28 0-.57-.05-.83-.16s-.5-.27-.7-.47a2.116 2.116 0 01-.63-1.53V64.24c0-.28.05-.57.16-.83s.27-.5.47-.7a2.116 2.116 0 011.53-.63h1.25c.42 0 .84-.12 1.2-.36.35-.24.63-.57.79-.97a2.138 2.138 0 00-.49-2.33l-7.68-7.76c-.2-.21-.44-.37-.7-.48a2.124 2.124 0 00-1.66 0c-.26.11-.5.27-.7.48l-7.72 7.76c-.3.3-.51.68-.59 1.09s-.04.85.12 1.24.43.73.78.96c.35.24.76.37 1.19.37h1.25c.29 0 .57.05.83.16s.5.27.7.47c.2.2.36.44.47.7.11.26.16.55.16.83v30.2c0 .28.05.57.16.83s.27.5.47.7a2.116 2.116 0 001.53.63h21.55z""/><path class=""prefix__st2"" d=""M324.14 70.08a2.116 2.116 0 001.53.63h4.31c.28 0 .57-.05.83-.16s.5-.27.7-.47a2.116 2.116 0 00.63-1.53v-4.31c0-.28.05-.57.16-.83s.27-.5.47-.7a2.116 2.116 0 011.53-.63h4.32c.28 0 .57.05.83.16s.5.27.7.47c.2.2.36.44.47.7.11.26.16.55.16.83v21.57c0 .28-.05.57-.16.83s-.27.5-.47.7a2.116 2.116 0 01-1.53.63h-1.26c-.42 0-.84.13-1.2.36-.35.24-.63.57-.79.97-.16.39-.2.83-.11 1.24.09.42.3.8.6 1.1l7.73 7.72c.2.2.44.37.7.48a2.124 2.124 0 002.36-.48l7.72-7.72c.3-.3.5-.69.58-1.1.08-.42.04-.85-.12-1.24a2.12 2.12 0 00-.79-.96c-.35-.24-.77-.36-1.19-.36h-1.29c-.28 0-.57-.05-.83-.16s-.5-.27-.7-.47a2.116 2.116 0 01-.63-1.53V55.6c0-.28-.05-.57-.16-.83s-.27-.5-.47-.7c-.2-.2-.44-.36-.7-.47-.26-.11-.55-.16-.83-.16h-21.57c-.28 0-.57.05-.83.16s-.5.27-.7.47a2.116 2.116 0 00-.63 1.53v12.95c0 .28.05.57.16.83s.27.5.47.7z""/><text transform=""translate(73.686 67)"" class=""prefix__st2 prefix__st31 prefix__st32"">',
                    suppliedLiquidity,
                    ' USDC</text><text transform=""rotate(-90 213.61 143.092)"" class=""prefix__st2 prefix__st31 prefix__st32"">',
                    sharePercent,
                    '%</text><path fill=""none"" stroke=""#fff"" stroke-miterlimit=""10"" d=""M61.86 267.12V114.71""/><text transform=""translate(79.915 355)"" class=""prefix__st2 prefix__st31"" font-size=""10"">ID: ',
                    tokenId,
                    '</text><g><path d=""M60.19 67c4.71 0 8.5-3.79 8.5-8.5S64.9 50 60.19 50s-8.5 3.79-8.5 8.5 3.79 8.5 8.5 8.5z"" fill=""#2775ca""/><path class=""prefix__st2"" d=""M62.52 59.85c0-1.24-.74-1.66-2.23-1.84-1.06-.14-1.27-.42-1.27-.92s.35-.81 1.06-.81c.64 0 .99.21 1.17.74.04.11.14.18.25.18h.57c.14 0 .25-.11.25-.25v-.04c-.14-.78-.78-1.38-1.59-1.45v-.86c0-.14-.11-.25-.28-.28h-.55c-.14 0-.25.11-.28.28v.81c-1.06.14-1.74.85-1.74 1.74 0 1.17.71 1.63 2.2 1.81.99.18 1.31.39 1.31.96s-.5.96-1.17.96c-.92 0-1.24-.39-1.35-.92-.04-.14-.14-.21-.25-.21h-.6c-.14 0-.25.11-.25.25v.04c.14.89.71 1.52 1.88 1.7v.85c0 .14.11.25.28.28h.53c.14 0 .25-.11.28-.28v-.85c1.07-.19 1.78-.94 1.78-1.89z""/><path class=""prefix__st2"" d=""M58.38 63.56c-2.76-.99-4.18-4.07-3.15-6.8.53-1.49 1.7-2.62 3.15-3.15.14-.07.21-.18.21-.35v-.5c0-.14-.07-.25-.21-.28-.04 0-.11 0-.14.04a6.354 6.354 0 00-4.14 8 6.364 6.364 0 004.14 4.14c.14.07.28 0 .32-.14.04-.04.04-.07.04-.14v-.5c-.01-.1-.11-.24-.22-.32zm3.75-11.05c-.14-.07-.28 0-.32.14-.04.04-.04.07-.04.14v.5c0 .14.11.28.21.35 2.76.99 4.18 4.07 3.15 6.8a5.225 5.225 0 01-3.15 3.15c-.14.07-.21.18-.21.35v.5c0 .14.07.25.21.28.04 0 .11 0 .14-.04a6.354 6.354 0 004.14-8c-.62-2.01-2.18-3.53-4.13-4.17z""/></g><g><path d=""M142.44 77.23H56.69c-2.76 0-5 2.24-5 5v7.47c0 2.76 2.24 5 5 5h85.75c2.76 0 5-2.24 5-5v-7.47c0-2.76-2.24-5-5-5z"" fill=""#e84142""/><text transform=""translate(56.685 89.706)"" class=""prefix__st2"" font-size=""12"" font-family=""Courier-Bold"">ON AVALANCHE</text></g></svg>'
                )
            );
    }

    function getChainName() public pure override returns (string memory) {
        return ""Avalanche"";
    }
}",5175
RealWorld_BA_97_LiquidityProvidersMaliciousReentrant_RealWord_20240826213921.log,97,LiquidityProvidersMaliciousReentrant,6817,4666,11483,85.0,0.127405,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.0;
import ""../hyphen/LiquidityPool.sol"";

contract LiquidityProvidersMaliciousReentrant {
    LiquidityPool public lpool;
    address private constant NATIVE = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;
    address private owner;
    modifier onlyOwner() {
        require(owner == msg.sender, ""Unauthorized"");
        _;
    }

    constructor(address _lpaddress) {
        owner = msg.sender;
        lpool = LiquidityPool(payable(_lpaddress));
    }

    fallback() external payable {
        if (address(lpool).balance >= 1 ether) {
            lpool.transfer(NATIVE, address(this), 1 ether);
        }
    }

    receive() external payable {
        if (address(lpool).balance >= 1 ether) {
            lpool.transfer(NATIVE, address(this), 1 ether);
        }
    }

    function getBalance(address target) public view returns (uint256) {
        return target.balance;
    }

    function destruct() external onlyOwner {
        selfdestruct(payable(owner));
    }
}",250
RealWorld_BA_97_TokenMintingReentrancy_RealWord_20240826214531.log,97,TokenMintingReentrancy,6438,4297,10735,79.0,0.11813,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.0;
import ""../hyphen/LiquidityProviders.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol"";

contract TokenMintingReentrancy is IERC721ReceiverUpgradeable {
    LiquidityProviders public liquidityproviders;

    constructor(address _lproviders) {
        liquidityproviders = LiquidityProviders(payable(_lproviders));
    }

    function onERC721Received(
        address,
        address,
        uint256 tokenId,
        bytes calldata
    ) external override returns (bytes4) {
        if (tokenId < 10) {
            liquidityproviders.addNativeLiquidity{value: 1e12}();
        }
        return IERC721ReceiverUpgradeable.onERC721Received.selector;
    }

    receive() external payable {}

    function attack() external payable {
        liquidityproviders.addNativeLiquidity{value: msg.value}();
    }
}",207
RealWorld_BA_97_Ethereum.USDC_RealWord_20240826211634.log,97,Ethereum.USDC,85730,5140,90870,93.0,0.53145,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.0;

import ""../SvgHelperBase.sol"";

contract EthereumUSDC is SvgHelperBase {
    using Strings for uint256;

    constructor(uint256 _decimals) SvgHelperBase(_decimals) {}

    function getTokenSvg(
        uint256 _tokenId,
        uint256 _suppliedLiquidity,
        uint256 _totalSuppliedLiquidity
    ) public view virtual override returns (string memory) {
        string memory tokenId = _tokenId.toString();
        string memory suppliedLiquidity = _divideByPowerOf10(_suppliedLiquidity, tokenDecimals, 3);
        string memory sharePercent = _calculatePercentage(_suppliedLiquidity, _totalSuppliedLiquidity);
        return
            string(
                abi.encodePacked(
                    '<svg version=""1.1"" id=""prefix__Layer_1"" xmlns=""http://www.w3.org/2000/svg"" x=""0"" y=""0"" viewBox=""0 0 405 405"" xml:space=""preserve""><style>.prefix__st2{fill:#fff}.prefix__st11{font-family:&apos;Courier&apos;}.prefix__st12{font-size:24px}</style><radialGradient id=""prefix__SVGID_1_"" cx=""-455.002"" cy=""406.389"" r=""1"" gradientTransform=""matrix(0 327.499 327.499 0 -132889.578 149012.563)"" gradientUnits=""userSpaceOnUse""><stop offset=""0"" stop-color=""#8c8c8c""/><stop offset=""1""/></radialGradient><path d=""M30 0h345c16.57 0 30 13.43 30 30v345c0 16.57-13.43 30-30 30H30c-16.57 0-30-13.43-30-30V30C0 13.43 13.43 0 30 0z"" fill=""url(#prefix__SVGID_1_)""/><radialGradient id=""prefix__SVGID_00000027595528782364205150000006743997006181374859_"" cx=""-455.002"" cy=""407.716"" r=""1"" gradientTransform=""matrix(0 270.995 167.538 0 -68105.375 123380.75)"" gradientUnits=""userSpaceOnUse""><stop offset=""0"" stop-color=""#fff""/><stop offset="".711"" stop-color=""#2775ca""/><stop offset=""1"" stop-opacity=""0""/><stop offset=""1"" stop-opacity=""0""/></radialGradient><path d=""M214.93 95.88c-5.94-8.8-18.93-8.8-24.87 0-43.56 64.49-70.9 107.33-70.9 149.07 0 45.6 37.28 82.55 83.33 82.55s83.33-36.95 83.33-82.55c.01-41.74-27.33-84.58-70.89-149.07z"" fill=""url(#prefix__SVGID_00000027595528782364205150000006743997006181374859_)""/><path class=""prefix__st2"" d=""M271.41 338.62a.8.8 0 00-.59-.24h-1.66a.8.8 0 00-.59.24.8.8 0 00-.24.59v5c0 .11-.02.22-.06.32-.04.1-.1.2-.18.27a.8.8 0 01-.59.24h-8.33c-.11 0-.22-.02-.32-.06s-.2-.1-.27-.18-.14-.17-.18-.27a.866.866 0 01-.06-.32v-5a.8.8 0 00-.24-.59.8.8 0 00-.59-.24h-1.67c-.22 0-.43.09-.59.24s-.24.37-.24.59v15a.8.8 0 00.24.59.8.8 0 00.59.24h1.67a.8.8 0 00.59-.24.8.8 0 00.24-.59v-5a.8.8 0 01.24-.59.8.8 0 01.59-.24h8.33a.8.8 0 01.59.24.8.8 0 01.24.59v5c0 .11.02.22.06.32.04.1.1.2.18.27s.17.14.27.18.21.06.32.06h1.66c.11 0 .22-.02.32-.06.1-.04.2-.1.27-.18s.14-.17.18-.27c.04-.1.06-.21.06-.32v-15c0-.11-.02-.22-.06-.32-.04-.11-.1-.2-.18-.27zM321.41 341.91a.8.8 0 00-.59-.24h-5.83v.04h-2.5a.8.8 0 01-.59-.24.8.8 0 01-.24-.59v-5a.8.8 0 00-.24-.59.8.8 0 00-.59-.24h-1.66c-.11 0-.22.02-.32.06-.1.04-.2.1-.27.18a.8.8 0 00-.24.59v18.33c0 .11.02.22.06.32.04.1.1.2.18.27a.8.8 0 00.59.24h1.66c.11 0 .22-.02.32-.06.1-.04.2-.1.27-.18a.8.8 0 00.24-.59v-8.33a.8.8 0 01.24-.59.8.8 0 01.59-.24h5a.8.8 0 01.59.24.8.8 0 01.24.59v8.33c0 .11.02.22.06.32.04.1.1.2.18.27a.8.8 0 00.59.24h1.66c.11 0 .22-.02.32-.06.1-.04.2-.1.27-.18a.8.8 0 00.24-.59v-11.7c0-.11-.02-.22-.06-.32a.624.624 0 00-.17-.28zM338.08 341.91a.8.8 0 00-.59-.24h-11.67c-.11 0-.22.02-.32.06a.98.98 0 00-.27.18.8.8 0 00-.24.59v11.66a.8.8 0 00.24.59.8.8 0 00.59.24h11.67a.8.8 0 00.59-.24.8.8 0 00.24-.59v-1.66c0-.11-.02-.22-.06-.32-.04-.1-.1-.2-.18-.27a.8.8 0 00-.59-.24h-8.33c-.22 0-.43-.09-.59-.24-.16-.16-.24-.37-.24-.59s.09-.43.24-.59c.16-.16.37-.24.59-.24h8.33a.8.8 0 00.59-.24.8.8 0 00.24-.59v-6.66c0-.11-.02-.22-.06-.32a.841.841 0 00-.18-.29zm-3.16 4.24a.8.8 0 01-.18.27.8.8 0 01-.59.24h-5a.8.8 0 01-.59-.24.8.8 0 01-.24-.59.8.8 0 01.24-.59.8.8 0 01.59-.24h5a.8.8 0 01.59.24.8.8 0 01.24.59c0 .11-.02.22-.06.32zM354.74 341.91a.8.8 0 00-.59-.24l-2.5.04h-9.17a.8.8 0 00-.59.24.8.8 0 00-.24.59v11.66c0 .11.02.22.06.32.04.1.1.2.18.27a.8.8 0 00.59.24h1.67a.8.8 0 00.59-.24.8.8 0 00.24-.59v-8.33a.8.8 0 01.24-.59.8.8 0 01.59-.24h5c.11 0 .22.02.32.06.1.04.2.1.27.18a.8.8 0 01.24.59v8.33c0 .11.02.22.06.32.04.1.1.2.18.27a.8.8 0 00.59.24h1.67a.8.8 0 00.59-.24.8.8 0 00.24-.59v-11.7c0-.11-.02-.22-.06-.32a.65.65 0 00-.17-.27zM288.08 341.91a.8.8 0 00-.59-.24h-1.67c-.11 0-.22.02-.32.06a.98.98 0 00-.27.18.8.8 0 00-.24.59v8.33a.8.8 0 01-.24.59.8.8 0 01-.59.24h-5c-.11 0-.22-.02-.32-.06-.1-.04-.2-.1-.27-.18a.8.8 0 01-.24-.59v-8.33c0-.11-.02-.22-.06-.32-.04-.1-.1-.2-.18-.27a.8.8 0 00-.59-.24h-1.67c-.11 0-.22.02-.32.06a.98.98 0 00-.27.18.8.8 0 00-.24.59v11.66a.8.8 0 00.24.59.8.8 0 00.59.24h8.34c.22 0 .43.09.59.24.16.16.24.37.24.59s-.09.43-.24.59c-.16.16-.37.24-.59.24h-5c-.11 0-.22.02-.32.06s-.2.1-.27.18-.14.17-.18.27c-.04.1-.06.21-.06.32v1.66c0 .11.02.22.06.32.04.1.1.2.18.27s.17.14.27.18.21.06.32.06h8.33a.8.8 0 00.59-.24.8.8 0 00.24-.59v-16.66c0-.11-.02-.22-.06-.32-.05-.08-.12-.17-.19-.25zM304.74 341.91a.8.8 0 00-.59-.24h-11.67a.8.8 0 00-.59.24.8.8 0 00-.24.59v16.66c0 .11.02.22.06.32.04.1.1.2.18.27a.8.8 0 00.59.24h1.67a.8.8 0 00.59-.24.8.8 0 00.24-.59v-3.33a.8.8 0 01.24-.59.8.8 0 01.59-.24h8.34a.8.8 0 00.59-.24.8.8 0 00.24-.59v-11.66a.866.866 0 00-.24-.6zm-3.09 8.93a.8.8 0 01-.52.77c-.1.04-.21.06-.32.06h-5a.8.8 0 01-.59-.24.8.8 0 01-.24-.59v-5a.8.8 0 01.24-.59.8.8 0 01.59-.24h5a.866.866 0 01.6.24.8.8 0 01.24.59v5zM329.97 96.59c.28 0 .57-.05.83-.16s.5-.27.7-.47a2.116 2.116 0 00.63-1.53V81.49a2.182 2.182 0 00-.62-1.52 2.105 2.105 0 00-1.52-.63h-4.31c-.57 0-1.12.23-1.52.63-.4.4-.63.95-.63 1.52v4.31c0 .28-.05.57-.16.83s-.27.5-.47.7a2.116 2.116 0 01-1.53.63h-4.31c-.28 0-.57-.05-.83-.16s-.5-.27-.7-.47a2.116 2.116 0 01-.63-1.53V64.24c0-.28.05-.57.16-.83s.27-.5.47-.7a2.116 2.116 0 011.53-.63h1.25c.42 0 .84-.12 1.2-.36.35-.24.63-.57.79-.97a2.138 2.138 0 00-.49-2.33l-7.68-7.76c-.2-.21-.44-.37-.7-.48a2.124 2.124 0 00-1.66 0c-.26.11-.5.27-.7.48l-7.72 7.76c-.3.3-.51.68-.59 1.09s-.04.85.12 1.24.43.73.78.96c.35.24.76.37 1.19.37h1.25c.29 0 .57.05.83.16s.5.27.7.47c.2.2.36.44.47.7.11.26.16.55.16.83v30.2c0 .28.05.57.16.83s.27.5.47.7a2.116 2.116 0 001.53.63h21.55z""/><path class=""prefix__st2"" d=""M324.14 70.08a2.116 2.116 0 001.53.63h4.31c.28 0 .57-.05.83-.16s.5-.27.7-.47a2.116 2.116 0 00.63-1.53v-4.31c0-.28.05-.57.16-.83s.27-.5.47-.7a2.116 2.116 0 011.53-.63h4.32c.28 0 .57.05.83.16s.5.27.7.47c.2.2.36.44.47.7.11.26.16.55.16.83v21.57c0 .28-.05.57-.16.83s-.27.5-.47.7a2.116 2.116 0 01-1.53.63h-1.26c-.42 0-.84.13-1.2.36-.35.24-.63.57-.79.97-.16.39-.2.83-.11 1.24.09.42.3.8.6 1.1l7.73 7.72c.2.2.44.37.7.48a2.124 2.124 0 002.36-.48l7.72-7.72c.3-.3.5-.69.58-1.1.08-.42.04-.85-.12-1.24a2.12 2.12 0 00-.79-.96c-.35-.24-.77-.36-1.19-.36h-1.29c-.28 0-.57-.05-.83-.16s-.5-.27-.7-.47a2.116 2.116 0 01-.63-1.53V55.6c0-.28-.05-.57-.16-.83s-.27-.5-.47-.7c-.2-.2-.44-.36-.7-.47-.26-.11-.55-.16-.83-.16h-21.57c-.28 0-.57.05-.83.16s-.5.27-.7.47a2.116 2.116 0 00-.63 1.53v12.95c0 .28.05.57.16.83s.27.5.47.7z""/><text transform=""translate(73.686 67)"" class=""prefix__st2 prefix__st11 prefix__st12"">',
                    suppliedLiquidity,
                    ' USDC</text><text transform=""rotate(-90 213.61 143.092)"" class=""prefix__st2 prefix__st11 prefix__st12"">',
                    sharePercent,
                    '%</text><path fill=""none"" stroke=""#fff"" stroke-miterlimit=""10"" d=""M61.86 267.12V114.71""/><text transform=""translate(79.915 355)"" class=""prefix__st2 prefix__st11"" font-size=""10"">ID: ',
                    tokenId,
                    '</text><g><path d=""M60.19 67c4.71 0 8.5-3.79 8.5-8.5S64.9 50 60.19 50s-8.5 3.79-8.5 8.5 3.79 8.5 8.5 8.5z"" fill=""#2775ca""/><path class=""prefix__st2"" d=""M62.52 59.85c0-1.24-.74-1.66-2.23-1.84-1.06-.14-1.27-.42-1.27-.92s.35-.81 1.06-.81c.64 0 .99.21 1.17.74.04.11.14.18.25.18h.57c.14 0 .25-.11.25-.25v-.04c-.14-.78-.78-1.38-1.59-1.45v-.86c0-.14-.11-.25-.28-.28h-.55c-.14 0-.25.11-.28.28v.81c-1.06.14-1.74.85-1.74 1.74 0 1.17.71 1.63 2.2 1.81.99.18 1.31.39 1.31.96s-.5.96-1.17.96c-.92 0-1.24-.39-1.35-.92-.04-.14-.14-.21-.25-.21h-.6c-.14 0-.25.11-.25.25v.04c.14.89.71 1.52 1.88 1.7v.85c0 .14.11.25.28.28h.53c.14 0 .25-.11.28-.28v-.85c1.07-.19 1.78-.94 1.78-1.89z""/><path class=""prefix__st2"" d=""M58.38 63.56c-2.76-.99-4.18-4.07-3.15-6.8.53-1.49 1.7-2.62 3.15-3.15.14-.07.21-.18.21-.35v-.5c0-.14-.07-.25-.21-.28-.04 0-.11 0-.14.04a6.354 6.354 0 00-4.14 8 6.364 6.364 0 004.14 4.14c.14.07.28 0 .32-.14.04-.04.04-.07.04-.14v-.5c-.01-.1-.11-.24-.22-.32zm3.75-11.05c-.14-.07-.28 0-.32.14-.04.04-.04.07-.04.14v.5c0 .14.11.28.21.35 2.76.99 4.18 4.07 3.15 6.8a5.225 5.225 0 01-3.15 3.15c-.14.07-.21.18-.21.35v.5c0 .14.07.25.21.28.04 0 .11 0 .14-.04a6.354 6.354 0 004.14-8c-.62-2.01-2.18-3.53-4.13-4.17z""/></g><g><path d=""M136.03 77.23H56.69c-2.76 0-5 2.24-5 5v7.47c0 2.76 2.24 5 5 5h79.34c2.76 0 5-2.24 5-5v-7.47c0-2.76-2.24-5-5-5z"" fill=""#8c8c8c""/><text transform=""translate(56.685 89.706)"" class=""prefix__st2"" font-size=""12"" font-family=""Courier-Bold"">ON ETHEREUM</text></g></svg>'
                )
            );
    }

    function getChainName() public pure override returns (string memory) {
        return ""Ethereum"";
    }
}",5180
RealWorld_BA_97_IWhiteListPeriodManager_RealWord_20240826213550.log,97,IWhiteListPeriodManager,10409,5713,16122,105.0,0.166305,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.0;

interface IWhiteListPeriodManager {
    function areWhiteListRestrictionsEnabled() external view returns (bool);

    function beforeLiquidityAddition(
        address _lp,
        address _token,
        uint256 _amount
    ) external;

    function beforeLiquidityRemoval(
        address _lp,
        address _token,
        uint256 _amount
    ) external;

    function beforeLiquidityTransfer(
        address _from,
        address _to,
        address _token,
        uint256 _amount
    ) external;

    function getMaxCommunityLpPositon(address _token) external view returns (uint256);

    function initialize(
        address _trustedForwarder,
        address _liquidityProviders,
        address _tokenManager
    ) external;

    function isExcludedAddress(address) external view returns (bool);

    function isTrustedForwarder(address forwarder) external view returns (bool);

    function owner() external view returns (address);

    function paused() external view returns (bool);

    function perTokenTotalCap(address) external view returns (uint256);

    function perTokenWalletCap(address) external view returns (uint256);

    function renounceOwnership() external;

    function setAreWhiteListRestrictionsEnabled(bool _status) external;

    function setCap(
        address _token,
        uint256 _totalCap,
        uint256 _perTokenWalletCap
    ) external;

    function setCaps(
        address[] memory _tokens,
        uint256[] memory _totalCaps,
        uint256[] memory _perTokenWalletCaps
    ) external;

    function setIsExcludedAddressStatus(address[] memory _addresses, bool[] memory _status) external;

    function setLiquidityProviders(address _liquidityProviders) external;

    function setPerTokenWalletCap(address _token, uint256 _perTokenWalletCap) external;

    function setTokenManager(address _tokenManager) external;

    function setTotalCap(address _token, uint256 _totalCap) external;

    function transferOwnership(address newOwner) external;
}",443
RealWorld_BA_97_ILiquidityPool_RealWord_20240826213215.log,97,ILiquidityPool,12684,5768,18452,105.0,0.17878,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.0;

interface ILiquidityPool {
    function baseGas() external view returns (uint256);

    function changePauser(address newPauser) external;

    function checkHashStatus(
        address tokenAddress,
        uint256 amount,
        address receiver,
        bytes memory depositHash
    ) external view returns (bytes32 hashSendTransaction, bool status);

    function depositConfig(uint256, address) external view returns (uint256 min, uint256 max);

    function depositErc20(
        uint256 toChainId,
        address tokenAddress,
        address receiver,
        uint256 amount,
        string memory tag
    ) external;

    function depositNative(
        address receiver,
        uint256 toChainId,
        string memory tag
    ) external;

    function gasFeeAccumulated(address, address) external view returns (uint256);

    function gasFeeAccumulatedByToken(address) external view returns (uint256);

    function getCurrentLiquidity(address tokenAddress) external view returns (uint256 currentLiquidity);

    function getExecutorManager() external view returns (address);

    function getRewardAmount(uint256 amount, address tokenAddress) external view returns (uint256 rewardAmount);

    function getTransferFee(address tokenAddress, uint256 amount) external view returns (uint256 fee);

    function incentivePool(address) external view returns (uint256);

    function initialize(
        address _executorManagerAddress,
        address pauser,
        address _trustedForwarder,
        address _tokenManager,
        address _liquidityProviders
    ) external;

    function isPauser(address pauser) external view returns (bool);

    function isTrustedForwarder(address forwarder) external view returns (bool);

    function owner() external view returns (address);

    function paused() external view returns (bool);

    function processedHash(bytes32) external view returns (bool);

    function renounceOwnership() external;

    function renouncePauser() external;

    function transfer(address _tokenAddress, address receiver, uint256 _tokenAmount) external;

    function sendFundsToUser(
        address tokenAddress,
        uint256 amount,
        address receiver,
        bytes memory depositHash,
        uint256 tokenGasPrice,
        uint256 fromChainId
    ) external;

    function setBaseGas(uint128 gas) external;

    function setExecutorManager(address _executorManagerAddress) external;

    function setLiquidityProviders(address _liquidityProviders) external;

    function setTrustedForwarder(address trustedForwarder) external;

    function transferConfig(address) external view returns (uint256 min, uint256 max);

    function transferOwnership(address newOwner) external;

    function withdrawErc20GasFee(address tokenAddress) external;

    function withdrawNativeGasFee() external;
}",587
RealWorld_BA_97_Polygon.USDT_RealWord_20240826210618.log,97,Polygon.USDT,80065,5112,85177,89.0,0.502565,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.0;

import ""../SvgHelperBase.sol"";

contract PolygonUSDT is SvgHelperBase {
    using Strings for uint256;

    constructor(uint256 _decimals) SvgHelperBase(_decimals) {}

    function getTokenSvg(
        uint256 _tokenId,
        uint256 _suppliedLiquidity,
        uint256 _totalSuppliedLiquidity
    ) public view virtual override returns (string memory) {
        string memory tokenId = _tokenId.toString();
        string memory suppliedLiquidity = _divideByPowerOf10(_suppliedLiquidity, tokenDecimals, 3);
        string memory sharePercent = _calculatePercentage(_suppliedLiquidity, _totalSuppliedLiquidity);
        return
            string(
                abi.encodePacked(
                    '<svg version=""1.1"" id=""prefix__Layer_1"" xmlns=""http://www.w3.org/2000/svg"" x=""0"" y=""0"" viewBox=""0 0 405 405"" xml:space=""preserve""><style>.prefix__st2{fill:#fff}.prefix__st19{font-family:&apos;Courier&apos;}.prefix__st20{font-size:24px}</style><radialGradient id=""prefix__SVGID_1_"" cx=""1.388"" cy=""-50"" r=""1"" gradientTransform=""matrix(0 327.499 327.499 0 16577.465 -454.476)"" gradientUnits=""userSpaceOnUse""><stop offset=""0"" stop-color=""#8247e5""/><stop offset=""1""/></radialGradient><path d=""M30 0h345c16.57 0 30 13.43 30 30v345c0 16.57-13.43 30-30 30H30c-16.57 0-30-13.43-30-30V30C0 13.43 13.43 0 30 0z"" fill=""url(#prefix__SVGID_1_)""/><radialGradient id=""prefix__SVGID_00000050633384941599449990000003968045424753684663_"" cx=""1.677"" cy=""-50"" r=""1"" gradientTransform=""matrix(0 270.995 167.538 0 8579.416 -376.976)"" gradientUnits=""userSpaceOnUse""><stop offset=""0"" stop-color=""#fff""/><stop offset="".711"" stop-color=""#50af95""/><stop offset=""1"" stop-opacity=""0""/><stop offset=""1"" stop-opacity=""0""/></radialGradient><path d=""M214.93 95.88c-5.94-8.8-18.93-8.8-24.87 0-43.56 64.49-70.9 107.33-70.9 149.07 0 45.6 37.28 82.55 83.33 82.55s83.33-36.95 83.33-82.55c.01-41.74-27.33-84.58-70.89-149.07z"" fill=""url(#prefix__SVGID_00000050633384941599449990000003968045424753684663_)""/><path class=""prefix__st2"" d=""M271.41 338.62a.8.8 0 00-.59-.24h-1.66a.8.8 0 00-.59.24.8.8 0 00-.24.59v5c0 .11-.02.22-.06.32-.04.1-.1.2-.18.27a.8.8 0 01-.59.24h-8.33c-.11 0-.22-.02-.32-.06s-.2-.1-.27-.18-.14-.17-.18-.27a.866.866 0 01-.06-.32v-5a.8.8 0 00-.24-.59.8.8 0 00-.59-.24h-1.67c-.22 0-.43.09-.59.24s-.24.37-.24.59v15a.8.8 0 00.24.59.8.8 0 00.59.24h1.67a.8.8 0 00.59-.24.8.8 0 00.24-.59v-5a.8.8 0 01.24-.59.8.8 0 01.59-.24h8.33a.8.8 0 01.59.24.8.8 0 01.24.59v5c0 .11.02.22.06.32.04.1.1.2.18.27s.17.14.27.18.21.06.32.06h1.66c.11 0 .22-.02.32-.06.1-.04.2-.1.27-.18s.14-.17.18-.27c.04-.1.06-.21.06-.32v-15c0-.11-.02-.22-.06-.32-.04-.11-.1-.2-.18-.27zM321.41 341.91a.8.8 0 00-.59-.24h-5.83v.04h-2.5a.8.8 0 01-.59-.24.8.8 0 01-.24-.59v-5a.8.8 0 00-.24-.59.8.8 0 00-.59-.24h-1.66c-.11 0-.22.02-.32.06-.1.04-.2.1-.27.18a.8.8 0 00-.24.59v18.33c0 .11.02.22.06.32.04.1.1.2.18.27a.8.8 0 00.59.24h1.66c.11 0 .22-.02.32-.06.1-.04.2-.1.27-.18a.8.8 0 00.24-.59v-8.33a.8.8 0 01.24-.59.8.8 0 01.59-.24h5a.8.8 0 01.59.24.8.8 0 01.24.59v8.33c0 .11.02.22.06.32.04.1.1.2.18.27a.8.8 0 00.59.24h1.66c.11 0 .22-.02.32-.06.1-.04.2-.1.27-.18a.8.8 0 00.24-.59v-11.7c0-.11-.02-.22-.06-.32a.624.624 0 00-.17-.28zM338.08 341.91a.8.8 0 00-.59-.24h-11.67c-.11 0-.22.02-.32.06a.98.98 0 00-.27.18.8.8 0 00-.24.59v11.66a.8.8 0 00.24.59.8.8 0 00.59.24h11.67a.8.8 0 00.59-.24.8.8 0 00.24-.59v-1.66c0-.11-.02-.22-.06-.32-.04-.1-.1-.2-.18-.27a.8.8 0 00-.59-.24h-8.33c-.22 0-.43-.09-.59-.24-.16-.16-.24-.37-.24-.59s.09-.43.24-.59c.16-.16.37-.24.59-.24h8.33a.8.8 0 00.59-.24.8.8 0 00.24-.59v-6.66c0-.11-.02-.22-.06-.32a.841.841 0 00-.18-.29zm-3.16 4.24a.8.8 0 01-.18.27.8.8 0 01-.59.24h-5a.8.8 0 01-.59-.24.8.8 0 01-.24-.59.8.8 0 01.24-.59.8.8 0 01.59-.24h5a.8.8 0 01.59.24.8.8 0 01.24.59c0 .11-.02.22-.06.32zM354.74 341.91a.8.8 0 00-.59-.24l-2.5.04h-9.17a.8.8 0 00-.59.24.8.8 0 00-.24.59v11.66c0 .11.02.22.06.32.04.1.1.2.18.27a.8.8 0 00.59.24h1.67a.8.8 0 00.59-.24.8.8 0 00.24-.59v-8.33a.8.8 0 01.24-.59.8.8 0 01.59-.24h5c.11 0 .22.02.32.06.1.04.2.1.27.18a.8.8 0 01.24.59v8.33c0 .11.02.22.06.32.04.1.1.2.18.27a.8.8 0 00.59.24h1.67a.8.8 0 00.59-.24.8.8 0 00.24-.59v-11.7c0-.11-.02-.22-.06-.32a.65.65 0 00-.17-.27zM288.08 341.91a.8.8 0 00-.59-.24h-1.67c-.11 0-.22.02-.32.06a.98.98 0 00-.27.18.8.8 0 00-.24.59v8.33a.8.8 0 01-.24.59.8.8 0 01-.59.24h-5c-.11 0-.22-.02-.32-.06-.1-.04-.2-.1-.27-.18a.8.8 0 01-.24-.59v-8.33c0-.11-.02-.22-.06-.32-.04-.1-.1-.2-.18-.27a.8.8 0 00-.59-.24h-1.67c-.11 0-.22.02-.32.06a.98.98 0 00-.27.18.8.8 0 00-.24.59v11.66a.8.8 0 00.24.59.8.8 0 00.59.24h8.34c.22 0 .43.09.59.24.16.16.24.37.24.59s-.09.43-.24.59c-.16.16-.37.24-.59.24h-5c-.11 0-.22.02-.32.06s-.2.1-.27.18-.14.17-.18.27c-.04.1-.06.21-.06.32v1.66c0 .11.02.22.06.32.04.1.1.2.18.27s.17.14.27.18.21.06.32.06h8.33a.8.8 0 00.59-.24.8.8 0 00.24-.59v-16.66c0-.11-.02-.22-.06-.32-.05-.08-.12-.17-.19-.25zM304.74 341.91a.8.8 0 00-.59-.24h-11.67a.8.8 0 00-.59.24.8.8 0 00-.24.59v16.66c0 .11.02.22.06.32.04.1.1.2.18.27a.8.8 0 00.59.24h1.67a.8.8 0 00.59-.24.8.8 0 00.24-.59v-3.33a.8.8 0 01.24-.59.8.8 0 01.59-.24h8.34a.8.8 0 00.59-.24.8.8 0 00.24-.59v-11.66a.866.866 0 00-.24-.6zm-3.09 8.93a.8.8 0 01-.52.77c-.1.04-.21.06-.32.06h-5a.8.8 0 01-.59-.24.8.8 0 01-.24-.59v-5a.8.8 0 01.24-.59.8.8 0 01.59-.24h5a.866.866 0 01.6.24.8.8 0 01.24.59v5zM329.97 96.59c.28 0 .57-.05.83-.16s.5-.27.7-.47a2.116 2.116 0 00.63-1.53V81.49a2.182 2.182 0 00-.62-1.52 2.105 2.105 0 00-1.52-.63h-4.31c-.57 0-1.12.23-1.52.63-.4.4-.63.95-.63 1.52v4.31c0 .28-.05.57-.16.83s-.27.5-.47.7a2.116 2.116 0 01-1.53.63h-4.31c-.28 0-.57-.05-.83-.16s-.5-.27-.7-.47a2.116 2.116 0 01-.63-1.53V64.24c0-.28.05-.57.16-.83s.27-.5.47-.7a2.116 2.116 0 011.53-.63h1.25c.42 0 .84-.12 1.2-.36.35-.24.63-.57.79-.97a2.138 2.138 0 00-.49-2.33l-7.68-7.76c-.2-.21-.44-.37-.7-.48a2.124 2.124 0 00-1.66 0c-.26.11-.5.27-.7.48l-7.72 7.76c-.3.3-.51.68-.59 1.09s-.04.85.12 1.24.43.73.78.96c.35.24.76.37 1.19.37h1.25c.29 0 .57.05.83.16s.5.27.7.47c.2.2.36.44.47.7.11.26.16.55.16.83v30.2c0 .28.05.57.16.83s.27.5.47.7a2.116 2.116 0 001.53.63h21.55z""/><path class=""prefix__st2"" d=""M324.14 70.08a2.116 2.116 0 001.53.63h4.31c.28 0 .57-.05.83-.16s.5-.27.7-.47a2.116 2.116 0 00.63-1.53v-4.31c0-.28.05-.57.16-.83s.27-.5.47-.7a2.116 2.116 0 011.53-.63h4.32c.28 0 .57.05.83.16s.5.27.7.47c.2.2.36.44.47.7.11.26.16.55.16.83v21.57c0 .28-.05.57-.16.83s-.27.5-.47.7a2.116 2.116 0 01-1.53.63h-1.26c-.42 0-.84.13-1.2.36-.35.24-.63.57-.79.97-.16.39-.2.83-.11 1.24.09.42.3.8.6 1.1l7.73 7.72c.2.2.44.37.7.48a2.124 2.124 0 002.36-.48l7.72-7.72c.3-.3.5-.69.58-1.1.08-.42.04-.85-.12-1.24a2.12 2.12 0 00-.79-.96c-.35-.24-.77-.36-1.19-.36h-1.29c-.28 0-.57-.05-.83-.16s-.5-.27-.7-.47a2.116 2.116 0 01-.63-1.53V55.6c0-.28-.05-.57-.16-.83s-.27-.5-.47-.7c-.2-.2-.44-.36-.7-.47-.26-.11-.55-.16-.83-.16h-21.57c-.28 0-.57.05-.83.16s-.5.27-.7.47a2.116 2.116 0 00-.63 1.53v12.95c0 .28.05.57.16.83s.27.5.47.7z""/><text transform=""translate(73.686 67)"" class=""prefix__st2 prefix__st19 prefix__st20"">',
                    suppliedLiquidity,
                    ' USDT</text><text transform=""rotate(-90 213.61 143.092)"" class=""prefix__st2 prefix__st19 prefix__st20"">',
                    sharePercent,
                    '%</text><path fill=""none"" stroke=""#fff"" stroke-miterlimit=""10"" d=""M61.86 267.12V114.71""/><text transform=""translate(79.915 355)"" class=""prefix__st2 prefix__st19"" font-size=""10"">ID: ',
                    tokenId,
                    '</text><g fill-rule=""evenodd"" clip-rule=""evenodd""><path d=""M54.8 51.18l-3.1 6.51a.14.14 0 00.03.15l8.37 8.02c.05.05.13.05.18 0l8.37-8.02c.04-.04.05-.1.03-.15l-3.1-6.51a.136.136 0 00-.11-.07H54.91c-.05-.01-.09.02-.11.07z"" fill=""#50af95""/><path d=""M61.26 58.36c-.06 0-.37.02-1.06.02-.55 0-.94-.02-1.08-.02-2.13-.09-3.72-.46-3.72-.91 0-.44 1.59-.81 3.72-.91v1.45c.14.01.54.03 1.09.03.66 0 .99-.03 1.05-.03v-1.45c2.12.09 3.71.47 3.71.91s-1.59.81-3.71.91zm0-1.97v-1.3h2.97v-1.98h-8.07v1.98h2.96v1.3c-2.41.11-4.22.59-4.22 1.16s1.81 1.05 4.22 1.16v4.15h2.14v-4.15c2.4-.11 4.21-.59 4.21-1.16s-1.8-1.05-4.21-1.16zm0 0"" fill=""#fff""/></g><path d=""M128.52 77.23H56.69c-2.76 0-5 2.24-5 5v7.47c0 2.76 2.24 5 5 5h71.83c2.76 0 5-2.24 5-5v-7.47c0-2.76-2.24-5-5-5z"" fill=""#8247e5""/><text transform=""translate(56.685 89.706)"" class=""prefix__st2"" font-size=""12"" font-family=""Courier-Bold"">ON POLYGON</text></svg>'
                )
            );
    }

    function getChainName() public pure override returns (string memory) {
        return ""Polygon"";
    }
}",4779
RealWorld_BA_97_ERC2771ContextUpgradeable_RealWord_20240826212537.log,97,ERC2771ContextUpgradeable,9000,5078,14078,79.0,0.14656,"// SPDX-License-Identifier: MIT

pragma solidity 0.8.0;

import ""@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";

/**
 * @dev Context variant with ERC2771 support. 
 * Here _trustedForwarder is made internal instead of private
 * so it can be changed via Child contracts with a setter method.
 */
abstract contract ERC2771ContextUpgradeable is Initializable, ContextUpgradeable {
    address internal _trustedForwarder;

    function __ERC2771Context_init(address trustedForwarder) internal initializer {
        __Context_init_unchained();
        __ERC2771Context_init_unchained(trustedForwarder);
    }

    function __ERC2771Context_init_unchained(address trustedForwarder) internal initializer {
        _trustedForwarder = trustedForwarder;
    }

    function isTrustedForwarder(address forwarder) public view virtual returns (bool) {
        return forwarder == _trustedForwarder;
    }

    function _msgSender() internal view virtual override returns (address sender) {
        if (isTrustedForwarder(msg.sender)) {
            // The assembly code is more direct than the Solidity version using `abi.decode`.
            assembly {
                sender := shr(96, calldataload(sub(calldatasize(), 20)))
            }
        } else {
            return super._msgSender();
        }
    }

    function _msgData() internal view virtual override returns (bytes calldata) {
        if (isTrustedForwarder(msg.sender)) {
            return msg.data[:msg.data.length - 20];
        } else {
            return super._msgData();
        }
    }
    uint256[49] private __gap;
}",372
RealWorld_BA_97_Polygon.BICO_RealWord_20240826210120.log,97,Polygon.BICO,82568,5333,87901,95.0,0.5195,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.0;

import ""../SvgHelperBase.sol"";

contract PolygonBICO is SvgHelperBase {
    using Strings for uint256;

    constructor(uint256 _decimals) SvgHelperBase(_decimals) {}

    function getTokenSvg(
        uint256 _tokenId,
        uint256 _suppliedLiquidity,
        uint256 _totalSuppliedLiquidity
    ) public view virtual override returns (string memory) {
        string memory tokenId = _tokenId.toString();
        string memory suppliedLiquidity = _divideByPowerOf10(_suppliedLiquidity, tokenDecimals, 3);
        string memory sharePercent = _calculatePercentage(_suppliedLiquidity, _totalSuppliedLiquidity);
        return
            string(
                abi.encodePacked(
                    '<svg version=""1.1"" id=""prefix__Layer_1"" xmlns=""http://www.w3.org/2000/svg"" x=""0"" y=""0"" viewBox=""0 0 405 405"" xml:space=""preserve""><style>.prefix__st2{fill:#fff}.prefix__st22{font-family:&apos;Courier&apos;}.prefix__st23{font-size:24px}</style><radialGradient id=""prefix__SVGID_1_"" cx=""456.388"" cy=""-51.389"" r=""1"" gradientTransform=""matrix(0 327.499 327.499 0 17032.465 -149466.516)"" gradientUnits=""userSpaceOnUse""><stop offset=""0"" stop-color=""#8247e5""/><stop offset=""1""/></radialGradient><path d=""M30 0h345c16.57 0 30 13.43 30 30v345c0 16.57-13.43 30-30 30H30c-16.57 0-30-13.43-30-30V30C0 13.43 13.43 0 30 0z"" fill=""url(#prefix__SVGID_1_)""/><radialGradient id=""prefix__SVGID_00000168091924376873730230000003268479974706684840_"" cx=""456.677"" cy=""-52.716"" r=""1"" gradientTransform=""matrix(0 270.995 167.538 0 9034.416 -123679.695)"" gradientUnits=""userSpaceOnUse""><stop offset=""0"" stop-color=""#fff""/><stop offset="".711"" stop-color=""#d85111""/><stop offset=""1"" stop-opacity=""0""/><stop offset=""1"" stop-opacity=""0""/></radialGradient><path d=""M214.93 95.88c-5.94-8.8-18.93-8.8-24.87 0-43.56 64.49-70.9 107.33-70.9 149.07 0 45.6 37.28 82.55 83.33 82.55s83.33-36.95 83.33-82.55c.01-41.74-27.33-84.58-70.89-149.07z"" fill=""url(#prefix__SVGID_00000168091924376873730230000003268479974706684840_)""/><path class=""prefix__st2"" d=""M271.41 338.62a.8.8 0 00-.59-.24h-1.66a.8.8 0 00-.59.24.8.8 0 00-.24.59v5c0 .11-.02.22-.06.32-.04.1-.1.2-.18.27a.8.8 0 01-.59.24h-8.33c-.11 0-.22-.02-.32-.06s-.2-.1-.27-.18-.14-.17-.18-.27a.866.866 0 01-.06-.32v-5a.8.8 0 00-.24-.59.8.8 0 00-.59-.24h-1.67c-.22 0-.43.09-.59.24s-.24.37-.24.59v15a.8.8 0 00.24.59.8.8 0 00.59.24h1.67a.8.8 0 00.59-.24.8.8 0 00.24-.59v-5a.8.8 0 01.24-.59.8.8 0 01.59-.24h8.33a.8.8 0 01.59.24.8.8 0 01.24.59v5c0 .11.02.22.06.32.04.1.1.2.18.27s.17.14.27.18.21.06.32.06h1.66c.11 0 .22-.02.32-.06.1-.04.2-.1.27-.18s.14-.17.18-.27c.04-.1.06-.21.06-.32v-15c0-.11-.02-.22-.06-.32-.04-.11-.1-.2-.18-.27zM321.41 341.91a.8.8 0 00-.59-.24h-5.83v.04h-2.5a.8.8 0 01-.59-.24.8.8 0 01-.24-.59v-5a.8.8 0 00-.24-.59.8.8 0 00-.59-.24h-1.66c-.11 0-.22.02-.32.06-.1.04-.2.1-.27.18a.8.8 0 00-.24.59v18.33c0 .11.02.22.06.32.04.1.1.2.18.27a.8.8 0 00.59.24h1.66c.11 0 .22-.02.32-.06.1-.04.2-.1.27-.18a.8.8 0 00.24-.59v-8.33a.8.8 0 01.24-.59.8.8 0 01.59-.24h5a.8.8 0 01.59.24.8.8 0 01.24.59v8.33c0 .11.02.22.06.32.04.1.1.2.18.27a.8.8 0 00.59.24h1.66c.11 0 .22-.02.32-.06.1-.04.2-.1.27-.18a.8.8 0 00.24-.59v-11.7c0-.11-.02-.22-.06-.32a.624.624 0 00-.17-.28zM338.08 341.91a.8.8 0 00-.59-.24h-11.67c-.11 0-.22.02-.32.06a.98.98 0 00-.27.18.8.8 0 00-.24.59v11.66a.8.8 0 00.24.59.8.8 0 00.59.24h11.67a.8.8 0 00.59-.24.8.8 0 00.24-.59v-1.66c0-.11-.02-.22-.06-.32-.04-.1-.1-.2-.18-.27a.8.8 0 00-.59-.24h-8.33c-.22 0-.43-.09-.59-.24-.16-.16-.24-.37-.24-.59s.09-.43.24-.59c.16-.16.37-.24.59-.24h8.33a.8.8 0 00.59-.24.8.8 0 00.24-.59v-6.66c0-.11-.02-.22-.06-.32a.841.841 0 00-.18-.29zm-3.16 4.24a.8.8 0 01-.18.27.8.8 0 01-.59.24h-5a.8.8 0 01-.59-.24.8.8 0 01-.24-.59.8.8 0 01.24-.59.8.8 0 01.59-.24h5a.8.8 0 01.59.24.8.8 0 01.24.59c0 .11-.02.22-.06.32zM354.74 341.91a.8.8 0 00-.59-.24l-2.5.04h-9.17a.8.8 0 00-.59.24.8.8 0 00-.24.59v11.66c0 .11.02.22.06.32.04.1.1.2.18.27a.8.8 0 00.59.24h1.67a.8.8 0 00.59-.24.8.8 0 00.24-.59v-8.33a.8.8 0 01.24-.59.8.8 0 01.59-.24h5c.11 0 .22.02.32.06.1.04.2.1.27.18a.8.8 0 01.24.59v8.33c0 .11.02.22.06.32.04.1.1.2.18.27a.8.8 0 00.59.24h1.67a.8.8 0 00.59-.24.8.8 0 00.24-.59v-11.7c0-.11-.02-.22-.06-.32a.65.65 0 00-.17-.27zM288.08 341.91a.8.8 0 00-.59-.24h-1.67c-.11 0-.22.02-.32.06a.98.98 0 00-.27.18.8.8 0 00-.24.59v8.33a.8.8 0 01-.24.59.8.8 0 01-.59.24h-5c-.11 0-.22-.02-.32-.06-.1-.04-.2-.1-.27-.18a.8.8 0 01-.24-.59v-8.33c0-.11-.02-.22-.06-.32-.04-.1-.1-.2-.18-.27a.8.8 0 00-.59-.24h-1.67c-.11 0-.22.02-.32.06a.98.98 0 00-.27.18.8.8 0 00-.24.59v11.66a.8.8 0 00.24.59.8.8 0 00.59.24h8.34c.22 0 .43.09.59.24.16.16.24.37.24.59s-.09.43-.24.59c-.16.16-.37.24-.59.24h-5c-.11 0-.22.02-.32.06s-.2.1-.27.18-.14.17-.18.27c-.04.1-.06.21-.06.32v1.66c0 .11.02.22.06.32.04.1.1.2.18.27s.17.14.27.18.21.06.32.06h8.33a.8.8 0 00.59-.24.8.8 0 00.24-.59v-16.66c0-.11-.02-.22-.06-.32-.05-.08-.12-.17-.19-.25zM304.74 341.91a.8.8 0 00-.59-.24h-11.67a.8.8 0 00-.59.24.8.8 0 00-.24.59v16.66c0 .11.02.22.06.32.04.1.1.2.18.27a.8.8 0 00.59.24h1.67a.8.8 0 00.59-.24.8.8 0 00.24-.59v-3.33a.8.8 0 01.24-.59.8.8 0 01.59-.24h8.34a.8.8 0 00.59-.24.8.8 0 00.24-.59v-11.66a.866.866 0 00-.24-.6zm-3.09 8.93a.8.8 0 01-.52.77c-.1.04-.21.06-.32.06h-5a.8.8 0 01-.59-.24.8.8 0 01-.24-.59v-5a.8.8 0 01.24-.59.8.8 0 01.59-.24h5a.866.866 0 01.6.24.8.8 0 01.24.59v5zM329.97 96.59c.28 0 .57-.05.83-.16s.5-.27.7-.47a2.116 2.116 0 00.63-1.53V81.49a2.182 2.182 0 00-.62-1.52 2.105 2.105 0 00-1.52-.63h-4.31c-.57 0-1.12.23-1.52.63-.4.4-.63.95-.63 1.52v4.31c0 .28-.05.57-.16.83s-.27.5-.47.7a2.116 2.116 0 01-1.53.63h-4.31c-.28 0-.57-.05-.83-.16s-.5-.27-.7-.47a2.116 2.116 0 01-.63-1.53V64.24c0-.28.05-.57.16-.83s.27-.5.47-.7a2.116 2.116 0 011.53-.63h1.25c.42 0 .84-.12 1.2-.36.35-.24.63-.57.79-.97a2.138 2.138 0 00-.49-2.33l-7.68-7.76c-.2-.21-.44-.37-.7-.48a2.124 2.124 0 00-1.66 0c-.26.11-.5.27-.7.48l-7.72 7.76c-.3.3-.51.68-.59 1.09s-.04.85.12 1.24.43.73.78.96c.35.24.76.37 1.19.37h1.25c.29 0 .57.05.83.16s.5.27.7.47c.2.2.36.44.47.7.11.26.16.55.16.83v30.2c0 .28.05.57.16.83s.27.5.47.7a2.116 2.116 0 001.53.63h21.55z""/><path class=""prefix__st2"" d=""M324.14 70.08a2.116 2.116 0 001.53.63h4.31c.28 0 .57-.05.83-.16s.5-.27.7-.47a2.116 2.116 0 00.63-1.53v-4.31c0-.28.05-.57.16-.83s.27-.5.47-.7a2.116 2.116 0 011.53-.63h4.32c.28 0 .57.05.83.16s.5.27.7.47c.2.2.36.44.47.7.11.26.16.55.16.83v21.57c0 .28-.05.57-.16.83s-.27.5-.47.7a2.116 2.116 0 01-1.53.63h-1.26c-.42 0-.84.13-1.2.36-.35.24-.63.57-.79.97-.16.39-.2.83-.11 1.24.09.42.3.8.6 1.1l7.73 7.72c.2.2.44.37.7.48a2.124 2.124 0 002.36-.48l7.72-7.72c.3-.3.5-.69.58-1.1.08-.42.04-.85-.12-1.24a2.12 2.12 0 00-.79-.96c-.35-.24-.77-.36-1.19-.36h-1.29c-.28 0-.57-.05-.83-.16s-.5-.27-.7-.47a2.116 2.116 0 01-.63-1.53V55.6c0-.28-.05-.57-.16-.83s-.27-.5-.47-.7c-.2-.2-.44-.36-.7-.47-.26-.11-.55-.16-.83-.16h-21.57c-.28 0-.57.05-.83.16s-.5.27-.7.47a2.116 2.116 0 00-.63 1.53v12.95c0 .28.05.57.16.83s.27.5.47.7z""/><text transform=""translate(73.686 67)"" class=""prefix__st2 prefix__st22 prefix__st23"">',
                    suppliedLiquidity,
                    ' BICO</text><text transform=""rotate(-90 213.61 143.092)"" class=""prefix__st2 prefix__st22 prefix__st23"">',
                    sharePercent,
                    '%</text><path fill=""none"" stroke=""#fff"" stroke-miterlimit=""10"" d=""M61.86 267.12V114.71""/><text transform=""translate(79.915 355)"" class=""prefix__st2 prefix__st22"" font-size=""10"">ID: ',
                    tokenId,
                    '</text><path d=""M128.52 77.23H56.69c-2.76 0-5 2.24-5 5v7.47c0 2.76 2.24 5 5 5h71.83c2.76 0 5-2.24 5-5v-7.47c0-2.76-2.24-5-5-5z"" fill=""#8247e5""/><text transform=""translate(56.685 89.706)"" class=""prefix__st2"" font-size=""12"" font-family=""Courier-Bold"">ON POLYGON</text><g><circle cx=""60.19"" cy=""58.5"" r=""8.5""/><linearGradient id=""prefix__SVGID_00000065782961005422185070000012495441524963081905_"" gradientUnits=""userSpaceOnUse"" x1=""58.709"" y1=""66.872"" x2=""61.662"" y2=""50.128""><stop offset=""0"" stop-color=""#fff""/><stop offset=""1"" stop-color=""#fff""/></linearGradient><path d=""M60.19 50.75c4.27 0 7.75 3.48 7.75 7.75s-3.48 7.75-7.75 7.75-7.75-3.48-7.75-7.75 3.47-7.75 7.75-7.75m0-.75c-4.69 0-8.5 3.81-8.5 8.5s3.81 8.5 8.5 8.5 8.5-3.81 8.5-8.5-3.81-8.5-8.5-8.5z"" fill=""url(#prefix__SVGID_00000065782961005422185070000012495441524963081905_)""/><g><path d=""M61.53 54.53c-.31-.18-.68-.28-1.06-.28h-2.12c.59 0 1.06.48 1.06 1.06v3.19h1.06c.39 0 .75-.1 1.06-.29.23-.13.44-.31.6-.52.29-.36.46-.82.46-1.32 0-.78-.42-1.47-1.06-1.84z"" fill=""#d85111""/><path class=""prefix__st2"" d=""M62.14 57.69a2.131 2.131 0 01-1.66.81h-1.06v-3.19a1.06 1.06 0 00-2.12 0V62.75H61c.18 0 .36-.02.53-.05a2.66 2.66 0 002.12-2.6c.01-1.07-.62-1.98-1.51-2.41z""/></g></g></svg>'
                )
            );
    }

    function getChainName() public pure override returns (string memory) {
        return ""Polygon"";
    }
}",4923
RealWorld_BA_97_TokenManager_RealWord_20240826205640.log,97,TokenManager,22048,5406,27454,85.0,0.21836,"// SPDX-License-Identifier: MIT

pragma solidity 0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/Pausable.sol"";
import ""../metatx/ERC2771Context.sol"";
import ""../interfaces/ITokenManager.sol"";

contract TokenManager is ITokenManager, ERC2771Context, Ownable, Pausable {
    mapping(address => TokenInfo) public tokensInfo;

    event FeeChanged(address indexed tokenAddress, uint256 indexed equilibriumFee, uint256 indexed maxFee);

    modifier tokenChecks(address tokenAddress) {
        require(tokenAddress != address(0), ""Token address cannot be 0"");
        require(tokensInfo[tokenAddress].supportedToken, ""Token not supported"");

        _;
    }

    /**
     * First key is toChainId and second key is token address being deposited on current chain
     */
    mapping(uint256 => mapping(address => TokenConfig)) public depositConfig;

    /**
     * Store min/max amount of token to transfer based on token address
     */
    mapping(address => TokenConfig) public transferConfig;

    constructor(address trustedForwarder) ERC2771Context(trustedForwarder) {
        // Empty Constructor
    }

    function getEquilibriumFee(address tokenAddress) public view override returns (uint256) {
        return tokensInfo[tokenAddress].equilibriumFee;
    }

    function getMaxFee(address tokenAddress) public view override returns (uint256) {
        return tokensInfo[tokenAddress].maxFee;
    }

    function changeFee(
        address tokenAddress,
        uint256 _equilibriumFee,
        uint256 _maxFee
    ) external override onlyOwner whenNotPaused {
        require(_equilibriumFee != 0, ""Equilibrium Fee cannot be 0"");
        require(_maxFee != 0, ""Max Fee cannot be 0"");
        tokensInfo[tokenAddress].equilibriumFee = _equilibriumFee;
        tokensInfo[tokenAddress].maxFee = _maxFee;
        emit FeeChanged(tokenAddress, tokensInfo[tokenAddress].equilibriumFee, tokensInfo[tokenAddress].maxFee);
    }

    function setTokenTransferOverhead(address tokenAddress, uint256 gasOverhead)
        external
        tokenChecks(tokenAddress)
        onlyOwner
    {
        tokensInfo[tokenAddress].transferOverhead = gasOverhead;
    }

    /**
     * Set DepositConfig for the given combination of toChainId, tokenAddress.
     * This is used while depositing token in Liquidity Pool. Based on the destination chainid
     * min and max deposit amount is checked.
     */
    function setDepositConfig(
        uint256[] memory toChainId,
        address[] memory tokenAddresses,
        TokenConfig[] memory tokenConfig
    ) external onlyOwner {
        require(
            (toChainId.length == tokenAddresses.length) && (tokenAddresses.length == tokenConfig.length),
            "" ERR_ARRAY_LENGTH_MISMATCH""
        );
        for (uint256 index = 0; index < tokenConfig.length; ++index) {
            depositConfig[toChainId[index]][tokenAddresses[index]].min = tokenConfig[index].min;
            depositConfig[toChainId[index]][tokenAddresses[index]].max = tokenConfig[index].max;
        }
    }

    function addSupportedToken(
        address tokenAddress,
        uint256 minCapLimit,
        uint256 maxCapLimit,
        uint256 equilibriumFee,
        uint256 maxFee
    ) external onlyOwner {
        require(tokenAddress != address(0), ""Token address cannot be 0"");
        require(maxCapLimit > minCapLimit, ""maxCapLimit > minCapLimit"");
        tokensInfo[tokenAddress].supportedToken = true;
        transferConfig[tokenAddress].min = minCapLimit;
        transferConfig[tokenAddress].max = maxCapLimit;
        tokensInfo[tokenAddress].tokenConfig = transferConfig[tokenAddress];
        tokensInfo[tokenAddress].equilibriumFee = equilibriumFee;
        tokensInfo[tokenAddress].maxFee = maxFee;
    }

    function removeSupportedToken(address tokenAddress) external tokenChecks(tokenAddress) onlyOwner {
        tokensInfo[tokenAddress].supportedToken = false;
    }

    function updateTokenCap(
        address tokenAddress,
        uint256 minCapLimit,
        uint256 maxCapLimit
    ) external tokenChecks(tokenAddress) onlyOwner {
        require(maxCapLimit > minCapLimit, ""maxCapLimit > minCapLimit"");
        transferConfig[tokenAddress].min = minCapLimit;
        transferConfig[tokenAddress].max = maxCapLimit;
    }

    function getTokensInfo(address tokenAddress) public view override returns (TokenInfo memory) {
        TokenInfo memory tokenInfo = TokenInfo(
            tokensInfo[tokenAddress].transferOverhead,
            tokensInfo[tokenAddress].supportedToken,
            tokensInfo[tokenAddress].equilibriumFee,
            tokensInfo[tokenAddress].maxFee,
            transferConfig[tokenAddress]
        );
        return tokenInfo;
    }

    function getDepositConfig(uint256 toChainId, address tokenAddress)
        public
        view
        override
        returns (TokenConfig memory)
    {
        return depositConfig[toChainId][tokenAddress];
    }

    function getTransferConfig(address tokenAddress) public view override returns (TokenConfig memory) {
        return transferConfig[tokenAddress];
    }

    function _msgSender() internal view virtual override(Context, ERC2771Context) returns (address sender) {
        return ERC2771Context._msgSender();
    }

    function _msgData() internal view virtual override(Context, ERC2771Context) returns (bytes calldata) {
        return ERC2771Context._msgData();
    }
}",1169
RealWorld_BA_97_ILiquidityProviders_RealWord_20240826213737.log,97,ILiquidityProviders,11308,5397,16705,101.0,0.16448,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.0;

interface ILiquidityProviders {
    function BASE_DIVISOR() external view returns (uint256);

    function initialize(address _trustedForwarder, address _lpToken) external;

    function addLPFee(address _token, uint256 _amount) external;

    function addNativeLiquidity() external;

    function addTokenLiquidity(address _token, uint256 _amount) external;

    function claimFee(uint256 _nftId) external;

    function getFeeAccumulatedOnNft(uint256 _nftId) external view returns (uint256);

    function getSuppliedLiquidityByToken(address tokenAddress) external view returns (uint256);

    function getTokenPriceInLPShares(address _baseToken) external view returns (uint256);

    function getTotalLPFeeByToken(address tokenAddress) external view returns (uint256);

    function getTotalReserveByToken(address tokenAddress) external view returns (uint256);

    function getSuppliedLiquidity(uint256 _nftId) external view returns (uint256);

    function increaseNativeLiquidity(uint256 _nftId) external;

    function increaseTokenLiquidity(uint256 _nftId, uint256 _amount) external;

    function isTrustedForwarder(address forwarder) external view returns (bool);

    function owner() external view returns (address);

    function paused() external view returns (bool);

    function removeLiquidity(uint256 _nftId, uint256 amount) external;

    function renounceOwnership() external;

    function setLiquidityPool(address _liquidityPool) external;

    function setLpToken(address _lpToken) external;

    function setWhiteListPeriodManager(address _whiteListPeriodManager) external;

    function sharesToTokenAmount(uint256 _shares, address _tokenAddress) external view returns (uint256);

    function totalLPFees(address) external view returns (uint256);

    function totalLiquidity(address) external view returns (uint256);

    function totalReserve(address) external view returns (uint256);

    function totalSharesMinted(address) external view returns (uint256);

    function transferOwnership(address newOwner) external;

    function whiteListPeriodManager() external view returns (address);

    function increaseCurrentLiquidity(address tokenAddress, uint256 amount) external;

    function decreaseCurrentLiquidity(address tokenAddress, uint256 amount) external;

    function getCurrentLiquidity(address tokenAddress) external view returns (uint256);
}",534
RealWorld_BA_97_ExecutorManager_RealWord_20240826204849.log,97,ExecutorManager,10023,5082,15105,75.0,0.151755,"// SPDX-License-Identifier: MIT

pragma solidity 0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""./interfaces/IExecutorManager.sol"";

contract ExecutorManager is IExecutorManager, Ownable {
    address[] internal executors;
    mapping(address => bool) internal executorStatus;

    event ExecutorAdded(address executor, address owner);
    event ExecutorRemoved(address executor, address owner);

    // MODIFIERS
    modifier onlyExecutor() {
        require(executorStatus[msg.sender], ""You are not allowed to perform this operation"");
        _;
    }

    function getExecutorStatus(address executor) public view override returns (bool status) {
        status = executorStatus[executor];
    }

    function getAllExecutors() public view override returns (address[] memory) {
        return executors;
    }

    //Register new Executors
    function addExecutors(address[] calldata executorArray) external override onlyOwner {
        for (uint256 i = 0; i < executorArray.length; ++i) {
            addExecutor(executorArray[i]);
        }
    }

    // Register single executor
    function addExecutor(address executorAddress) public override onlyOwner {
        require(executorAddress != address(0), ""executor address can not be 0"");
        require(!executorStatus[executorAddress], ""Executor already registered"");
        executors.push(executorAddress);
        executorStatus[executorAddress] = true;
        emit ExecutorAdded(executorAddress, msg.sender);
    }

    //Remove registered Executors
    function removeExecutors(address[] calldata executorArray) external override onlyOwner {
        for (uint256 i = 0; i < executorArray.length; ++i) {
            removeExecutor(executorArray[i]);
        }
    }

    // Remove Register single executor
    function removeExecutor(address executorAddress) public override onlyOwner {
        require(executorAddress != address(0), ""executor address can not be 0"");
        executorStatus[executorAddress] = false;
        emit ExecutorRemoved(executorAddress, msg.sender);
    }
}",426
RealWorld_BA_97_ILPToken_RealWord_20240826213402.log,97,ILPToken,12360,5819,18179,105.0,0.17818,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.0;

import ""../structures/LpTokenMetadata.sol"";

interface ILPToken {
    function approve(address to, uint256 tokenId) external;

    function balanceOf(address _owner) external view returns (uint256);

    function exists(uint256 _tokenId) external view returns (bool);

    function getAllNftIdsByUser(address _owner) external view returns (uint256[] memory);

    function getApproved(uint256 tokenId) external view returns (address);

    function initialize(
        string memory _name,
        string memory _symbol,
        address _trustedForwarder
    ) external;

    function isApprovedForAll(address _owner, address operator) external view returns (bool);

    function isTrustedForwarder(address forwarder) external view returns (bool);

    function liquidityPoolAddress() external view returns (address);

    function mint(address _to) external returns (uint256);

    function name() external view returns (string memory);

    function owner() external view returns (address);

    function ownerOf(uint256 tokenId) external view returns (address);

    function paused() external view returns (bool);

    function renounceOwnership() external;

    function safeTransferFrom(
        address from,
        address to,
        uint256 tokenId
    ) external;

    function safeTransferFrom(
        address from,
        address to,
        uint256 tokenId,
        bytes memory _data
    ) external;

    function setApprovalForAll(address operator, bool approved) external;

    function setLiquidityPool(address _lpm) external;

    function setWhiteListPeriodManager(address _whiteListPeriodManager) external;

    function supportsInterface(bytes4 interfaceId) external view returns (bool);

    function symbol() external view returns (string memory);

    function tokenByIndex(uint256 index) external view returns (uint256);

    function tokenMetadata(uint256)
        external
        view
        returns (
            address token,
            uint256 totalSuppliedLiquidity,
            uint256 totalShares
        );

    function tokenOfOwnerByIndex(address _owner, uint256 index) external view returns (uint256);

    function tokenURI(uint256 tokenId) external view returns (string memory);

    function totalSupply() external view returns (uint256);

    function transferFrom(
        address from,
        address to,
        uint256 tokenId
    ) external;

    function transferOwnership(address newOwner) external;

    function updateTokenMetadata(uint256 _tokenId, LpTokenMetadata memory _lpTokenMetadata) external;

    function whiteListPeriodManager() external view returns (address);
}",540
RealWorld_BA_97_SvgHelperBase_RealWord_20240826205955.log,97,SvgHelperBase,23938,5676,29614,83.0,0.23321,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.0;

import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/Strings.sol"";
import ""base64-sol/base64.sol"";

abstract contract SvgHelperBase is Ownable {
    using Strings for uint256;

    uint256 public tokenDecimals;

    event BackgroundUrlUpdated(string newBackgroundUrl);
    event TokenDecimalsUpdated(uint256 newTokenDecimals);

    constructor(uint256 _tokenDecimals) Ownable() {
        tokenDecimals = _tokenDecimals;
    }

    function setTokenDecimals(uint256 _tokenDecimals) public onlyOwner {
        tokenDecimals = _tokenDecimals;
        emit TokenDecimalsUpdated(_tokenDecimals);
    }

    /// @notice Given an integer, returns the number of digits in it's decimal representation.
    /// @param _number The number to get the number of digits in.
    /// @return The number of digits in the decimal representation of the given number.
    function _getDigitsCount(uint256 _number) internal pure returns (uint256) {
        uint256 count = 0;
        while (_number > 0) {
            ++count;
            _number /= 10;
        }
        return count;
    }

    /// @notice Generates a string containing 0s of the given length.
    /// @param _length The length of the string to generate.
    /// @return A string of 0s of the given length.
    function _getZeroString(uint256 _length) internal pure returns (string memory) {
        if (_length == 0) {
            return """";
        }
        string memory result;
        for (uint256 i = 0; i < _length; ++i) {
            result = string(abi.encodePacked(result, ""0""));
        }
        return result;
    }

    /// @notice Truncate Digits from the right
    function _truncateDigitsFromRight(uint256 _number, uint256 _digitsCount) internal pure returns (uint256) {
        uint256 result = _number /= (10**_digitsCount);
        // Remove Leading Zeroes
        while (result != 0 && result % 10 == 0) {
            result /= 10;
        }
        return result;
    }

    /// @notice Return str(_value / 10^_power)
    function _divideByPowerOf10(
        uint256 _value,
        uint256 _power,
        uint256 _maxDigitsAfterDecimal
    ) internal pure returns (string memory) {
        uint256 integerPart = _value / 10**_power;
        uint256 leadingZeroesToAddBeforeDecimal = 0;
        uint256 fractionalPartTemp = _value % (10**_power);

        uint256 powerRemaining = _power;
        if (fractionalPartTemp != 0) {
            // Remove Leading Zeroes
            while (fractionalPartTemp != 0 && fractionalPartTemp % 10 == 0) {
                fractionalPartTemp /= 10;
                if (powerRemaining > 0) {
                    powerRemaining--;
                }
            }

            uint256 expectedFractionalDigits = powerRemaining;
            if (_getDigitsCount(fractionalPartTemp) < expectedFractionalDigits) {
                leadingZeroesToAddBeforeDecimal = expectedFractionalDigits - _getDigitsCount(fractionalPartTemp);
            }
        }

        if (fractionalPartTemp == 0) {
            return integerPart.toString();
        }
        uint256 digitsToTruncateCount = _getDigitsCount(fractionalPartTemp) + leadingZeroesToAddBeforeDecimal >
            _maxDigitsAfterDecimal
            ? _getDigitsCount(fractionalPartTemp) + leadingZeroesToAddBeforeDecimal - _maxDigitsAfterDecimal
            : 0;
        return
            string(
                abi.encodePacked(
                    integerPart.toString(),
                    ""."",
                    _getZeroString(leadingZeroesToAddBeforeDecimal),
                    _truncateDigitsFromRight(fractionalPartTemp, digitsToTruncateCount).toString()
                )
            );
    }

    function getAttributes(uint256 _suppliedLiquidity, uint256 _totalSuppliedLiquidity)
        public
        view
        virtual
        returns (string memory)
    {
        string memory suppliedLiquidity = _divideByPowerOf10(_suppliedLiquidity, tokenDecimals, 3);
        string memory sharePercent = _calculatePercentage(_suppliedLiquidity, _totalSuppliedLiquidity);
        return
            string(
                abi.encodePacked(
                    ""["",
                    '{ ""trait_type"": ""Supplied Liquidity"", ""display_type"": ""number"", ""value"": ',
                    suppliedLiquidity,
                    '},{ ""trait_type"": ""Share Percentage"", ""value"": ""',
                    sharePercent,
                    '%""}]'
                )
            );
    }

    function getDescription(uint256 _suppliedLiquidity, uint256 _totalSuppliedLiquidity)
        public
        view
        virtual
        returns (string memory)
    {
        return
            string(
                abi.encodePacked(
                    ""This NFT represents your position as Liquidity Provider on Hyphen Bridge on "",
                    getChainName(),
                    "". To visit the bridge, visit [Hyphen](https://hyphen.biconomy.io).""
                )
            );
    }

    /// @notice Return str(_value / _denom * 100)
    function _calculatePercentage(uint256 _num, uint256 _denom) internal pure returns (string memory) {
        return _divideByPowerOf10((_num * 10**(18 + 2)) / _denom, 18, 2);
    }

    function getTokenSvg(
        uint256 _tokenId,
        uint256 _suppliedLiquidity,
        uint256 _totalSuppliedLiquidity
    ) public view virtual returns (string memory);

    function getChainName() public view virtual returns (string memory);
}",1258
RealWorld_BA_97_Polygon.USDC_RealWord_20240826210438.log,97,Polygon.USDC,85584,4840,90424,98.0,0.52472,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.0;

import ""../SvgHelperBase.sol"";

contract PolygonUSDC is SvgHelperBase {
    using Strings for uint256;

    constructor(uint256 _decimals) SvgHelperBase(_decimals) {}

    function getTokenSvg(
        uint256 _tokenId,
        uint256 _suppliedLiquidity,
        uint256 _totalSuppliedLiquidity
    ) public view virtual override returns (string memory) {
        string memory tokenId = _tokenId.toString();
        string memory suppliedLiquidity = _divideByPowerOf10(_suppliedLiquidity, tokenDecimals, 3);
        string memory sharePercent = _calculatePercentage(_suppliedLiquidity, _totalSuppliedLiquidity);
        return
            string(
                abi.encodePacked(
                    '<svg version=""1.1"" id=""prefix__Layer_1"" xmlns=""http://www.w3.org/2000/svg"" x=""0"" y=""0"" viewBox=""0 0 405 405"" xml:space=""preserve""><style>.prefix__st2{fill:#fff}.prefix__st24{font-family:&apos;Courier&apos;}.prefix__st25{font-size:24px}</style><radialGradient id=""prefix__SVGID_1_"" cx=""-453.612"" cy=""-48.611"" r=""1"" gradientTransform=""matrix(0 327.499 327.499 0 16122.466 148557.563)"" gradientUnits=""userSpaceOnUse""><stop offset=""0"" stop-color=""#8247e5""/><stop offset=""1""/></radialGradient><path d=""M30 0h345c16.57 0 30 13.43 30 30v345c0 16.57-13.43 30-30 30H30c-16.57 0-30-13.43-30-30V30C0 13.43 13.43 0 30 0z"" fill=""url(#prefix__SVGID_1_)""/><radialGradient id=""prefix__SVGID_00000165226099336628332060000012643825665705734299_"" cx=""-453.323"" cy=""-47.284"" r=""1"" gradientTransform=""matrix(0 270.995 167.538 0 8124.416 122925.75)"" gradientUnits=""userSpaceOnUse""><stop offset=""0"" stop-color=""#fff""/><stop offset="".711"" stop-color=""#2775ca""/><stop offset=""1"" stop-opacity=""0""/><stop offset=""1"" stop-opacity=""0""/></radialGradient><path d=""M214.93 95.88c-5.94-8.8-18.93-8.8-24.87 0-43.56 64.49-70.9 107.33-70.9 149.07 0 45.6 37.28 82.55 83.33 82.55s83.33-36.95 83.33-82.55c.01-41.74-27.33-84.58-70.89-149.07z"" fill=""url(#prefix__SVGID_00000165226099336628332060000012643825665705734299_)""/><path class=""prefix__st2"" d=""M271.41 338.62a.8.8 0 00-.59-.24h-1.66a.8.8 0 00-.59.24.8.8 0 00-.24.59v5c0 .11-.02.22-.06.32-.04.1-.1.2-.18.27a.8.8 0 01-.59.24h-8.33c-.11 0-.22-.02-.32-.06s-.2-.1-.27-.18-.14-.17-.18-.27a.866.866 0 01-.06-.32v-5a.8.8 0 00-.24-.59.8.8 0 00-.59-.24h-1.67c-.22 0-.43.09-.59.24s-.24.37-.24.59v15a.8.8 0 00.24.59.8.8 0 00.59.24h1.67a.8.8 0 00.59-.24.8.8 0 00.24-.59v-5a.8.8 0 01.24-.59.8.8 0 01.59-.24h8.33a.8.8 0 01.59.24.8.8 0 01.24.59v5c0 .11.02.22.06.32.04.1.1.2.18.27s.17.14.27.18.21.06.32.06h1.66c.11 0 .22-.02.32-.06.1-.04.2-.1.27-.18s.14-.17.18-.27c.04-.1.06-.21.06-.32v-15c0-.11-.02-.22-.06-.32-.04-.11-.1-.2-.18-.27zM321.41 341.91a.8.8 0 00-.59-.24h-5.83v.04h-2.5a.8.8 0 01-.59-.24.8.8 0 01-.24-.59v-5a.8.8 0 00-.24-.59.8.8 0 00-.59-.24h-1.66c-.11 0-.22.02-.32.06-.1.04-.2.1-.27.18a.8.8 0 00-.24.59v18.33c0 .11.02.22.06.32.04.1.1.2.18.27a.8.8 0 00.59.24h1.66c.11 0 .22-.02.32-.06.1-.04.2-.1.27-.18a.8.8 0 00.24-.59v-8.33a.8.8 0 01.24-.59.8.8 0 01.59-.24h5a.8.8 0 01.59.24.8.8 0 01.24.59v8.33c0 .11.02.22.06.32.04.1.1.2.18.27a.8.8 0 00.59.24h1.66c.11 0 .22-.02.32-.06.1-.04.2-.1.27-.18a.8.8 0 00.24-.59v-11.7c0-.11-.02-.22-.06-.32a.624.624 0 00-.17-.28zM338.08 341.91a.8.8 0 00-.59-.24h-11.67c-.11 0-.22.02-.32.06a.98.98 0 00-.27.18.8.8 0 00-.24.59v11.66a.8.8 0 00.24.59.8.8 0 00.59.24h11.67a.8.8 0 00.59-.24.8.8 0 00.24-.59v-1.66c0-.11-.02-.22-.06-.32-.04-.1-.1-.2-.18-.27a.8.8 0 00-.59-.24h-8.33c-.22 0-.43-.09-.59-.24-.16-.16-.24-.37-.24-.59s.09-.43.24-.59c.16-.16.37-.24.59-.24h8.33a.8.8 0 00.59-.24.8.8 0 00.24-.59v-6.66c0-.11-.02-.22-.06-.32a.841.841 0 00-.18-.29zm-3.16 4.24a.8.8 0 01-.18.27.8.8 0 01-.59.24h-5a.8.8 0 01-.59-.24.8.8 0 01-.24-.59.8.8 0 01.24-.59.8.8 0 01.59-.24h5a.8.8 0 01.59.24.8.8 0 01.24.59c0 .11-.02.22-.06.32zM354.74 341.91a.8.8 0 00-.59-.24l-2.5.04h-9.17a.8.8 0 00-.59.24.8.8 0 00-.24.59v11.66c0 .11.02.22.06.32.04.1.1.2.18.27a.8.8 0 00.59.24h1.67a.8.8 0 00.59-.24.8.8 0 00.24-.59v-8.33a.8.8 0 01.24-.59.8.8 0 01.59-.24h5c.11 0 .22.02.32.06.1.04.2.1.27.18a.8.8 0 01.24.59v8.33c0 .11.02.22.06.32.04.1.1.2.18.27a.8.8 0 00.59.24h1.67a.8.8 0 00.59-.24.8.8 0 00.24-.59v-11.7c0-.11-.02-.22-.06-.32a.65.65 0 00-.17-.27zM288.08 341.91a.8.8 0 00-.59-.24h-1.67c-.11 0-.22.02-.32.06a.98.98 0 00-.27.18.8.8 0 00-.24.59v8.33a.8.8 0 01-.24.59.8.8 0 01-.59.24h-5c-.11 0-.22-.02-.32-.06-.1-.04-.2-.1-.27-.18a.8.8 0 01-.24-.59v-8.33c0-.11-.02-.22-.06-.32-.04-.1-.1-.2-.18-.27a.8.8 0 00-.59-.24h-1.67c-.11 0-.22.02-.32.06a.98.98 0 00-.27.18.8.8 0 00-.24.59v11.66a.8.8 0 00.24.59.8.8 0 00.59.24h8.34c.22 0 .43.09.59.24.16.16.24.37.24.59s-.09.43-.24.59c-.16.16-.37.24-.59.24h-5c-.11 0-.22.02-.32.06s-.2.1-.27.18-.14.17-.18.27c-.04.1-.06.21-.06.32v1.66c0 .11.02.22.06.32.04.1.1.2.18.27s.17.14.27.18.21.06.32.06h8.33a.8.8 0 00.59-.24.8.8 0 00.24-.59v-16.66c0-.11-.02-.22-.06-.32-.05-.08-.12-.17-.19-.25zM304.74 341.91a.8.8 0 00-.59-.24h-11.67a.8.8 0 00-.59.24.8.8 0 00-.24.59v16.66c0 .11.02.22.06.32.04.1.1.2.18.27a.8.8 0 00.59.24h1.67a.8.8 0 00.59-.24.8.8 0 00.24-.59v-3.33a.8.8 0 01.24-.59.8.8 0 01.59-.24h8.34a.8.8 0 00.59-.24.8.8 0 00.24-.59v-11.66a.866.866 0 00-.24-.6zm-3.09 8.93a.8.8 0 01-.52.77c-.1.04-.21.06-.32.06h-5a.8.8 0 01-.59-.24.8.8 0 01-.24-.59v-5a.8.8 0 01.24-.59.8.8 0 01.59-.24h5a.866.866 0 01.6.24.8.8 0 01.24.59v5zM329.97 96.59c.28 0 .57-.05.83-.16s.5-.27.7-.47a2.116 2.116 0 00.63-1.53V81.49a2.182 2.182 0 00-.62-1.52 2.105 2.105 0 00-1.52-.63h-4.31c-.57 0-1.12.23-1.52.63-.4.4-.63.95-.63 1.52v4.31c0 .28-.05.57-.16.83s-.27.5-.47.7a2.116 2.116 0 01-1.53.63h-4.31c-.28 0-.57-.05-.83-.16s-.5-.27-.7-.47a2.116 2.116 0 01-.63-1.53V64.24c0-.28.05-.57.16-.83s.27-.5.47-.7a2.116 2.116 0 011.53-.63h1.25c.42 0 .84-.12 1.2-.36.35-.24.63-.57.79-.97a2.138 2.138 0 00-.49-2.33l-7.68-7.76c-.2-.21-.44-.37-.7-.48a2.124 2.124 0 00-1.66 0c-.26.11-.5.27-.7.48l-7.72 7.76c-.3.3-.51.68-.59 1.09s-.04.85.12 1.24.43.73.78.96c.35.24.76.37 1.19.37h1.25c.29 0 .57.05.83.16s.5.27.7.47c.2.2.36.44.47.7.11.26.16.55.16.83v30.2c0 .28.05.57.16.83s.27.5.47.7a2.116 2.116 0 001.53.63h21.55z""/><path class=""prefix__st2"" d=""M324.14 70.08a2.116 2.116 0 001.53.63h4.31c.28 0 .57-.05.83-.16s.5-.27.7-.47a2.116 2.116 0 00.63-1.53v-4.31c0-.28.05-.57.16-.83s.27-.5.47-.7a2.116 2.116 0 011.53-.63h4.32c.28 0 .57.05.83.16s.5.27.7.47c.2.2.36.44.47.7.11.26.16.55.16.83v21.57c0 .28-.05.57-.16.83s-.27.5-.47.7a2.116 2.116 0 01-1.53.63h-1.26c-.42 0-.84.13-1.2.36-.35.24-.63.57-.79.97-.16.39-.2.83-.11 1.24.09.42.3.8.6 1.1l7.73 7.72c.2.2.44.37.7.48a2.124 2.124 0 002.36-.48l7.72-7.72c.3-.3.5-.69.58-1.1.08-.42.04-.85-.12-1.24a2.12 2.12 0 00-.79-.96c-.35-.24-.77-.36-1.19-.36h-1.29c-.28 0-.57-.05-.83-.16s-.5-.27-.7-.47a2.116 2.116 0 01-.63-1.53V55.6c0-.28-.05-.57-.16-.83s-.27-.5-.47-.7c-.2-.2-.44-.36-.7-.47-.26-.11-.55-.16-.83-.16h-21.57c-.28 0-.57.05-.83.16s-.5.27-.7.47a2.116 2.116 0 00-.63 1.53v12.95c0 .28.05.57.16.83s.27.5.47.7z""/><text transform=""translate(73.686 67)"" class=""prefix__st2 prefix__st24 prefix__st25"">',
                    suppliedLiquidity,
                    ' USDC</text><text transform=""rotate(-90 213.61 143.092)"" class=""prefix__st2 prefix__st24 prefix__st25"">',
                    sharePercent,
                    '%</text><path fill=""none"" stroke=""#fff"" stroke-miterlimit=""10"" d=""M61.86 267.12V114.71""/><text transform=""translate(79.915 355)"" class=""prefix__st2 prefix__st24"" font-size=""10"">ID: ',
                    tokenId,
                    '</text><path d=""M128.52 77.23H56.69c-2.76 0-5 2.24-5 5v7.47c0 2.76 2.24 5 5 5h71.83c2.76 0 5-2.24 5-5v-7.47c0-2.76-2.24-5-5-5z"" fill=""#8247e5""/><text transform=""translate(56.685 89.706)"" class=""prefix__st2"" font-size=""12"" font-family=""Courier-Bold"">ON POLYGON</text><g><path d=""M60.19 67c4.71 0 8.5-3.79 8.5-8.5S64.9 50 60.19 50s-8.5 3.79-8.5 8.5 3.79 8.5 8.5 8.5z"" fill=""#2775ca""/><path class=""prefix__st2"" d=""M62.52 59.85c0-1.24-.74-1.66-2.23-1.84-1.06-.14-1.27-.42-1.27-.92s.35-.81 1.06-.81c.64 0 .99.21 1.17.74.04.11.14.18.25.18h.57c.14 0 .25-.11.25-.25v-.04c-.14-.78-.78-1.38-1.59-1.45v-.86c0-.14-.11-.25-.28-.28h-.55c-.14 0-.25.11-.28.28v.81c-1.06.14-1.74.85-1.74 1.74 0 1.17.71 1.63 2.2 1.81.99.18 1.31.39 1.31.96s-.5.96-1.17.96c-.92 0-1.24-.39-1.35-.92-.04-.14-.14-.21-.25-.21h-.6c-.14 0-.25.11-.25.25v.04c.14.89.71 1.52 1.88 1.7v.85c0 .14.11.25.28.28h.53c.14 0 .25-.11.28-.28v-.85c1.07-.19 1.78-.94 1.78-1.89z""/><path class=""prefix__st2"" d=""M58.38 63.56c-2.76-.99-4.18-4.07-3.15-6.8.53-1.49 1.7-2.62 3.15-3.15.14-.07.21-.18.21-.35v-.5c0-.14-.07-.25-.21-.28-.04 0-.11 0-.14.04a6.354 6.354 0 00-4.14 8 6.364 6.364 0 004.14 4.14c.14.07.28 0 .32-.14.04-.04.04-.07.04-.14v-.5c-.01-.1-.11-.24-.22-.32zm3.75-11.05c-.14-.07-.28 0-.32.14-.04.04-.04.07-.04.14v.5c0 .14.11.28.21.35 2.76.99 4.18 4.07 3.15 6.8a5.225 5.225 0 01-3.15 3.15c-.14.07-.21.18-.21.35v.5c0 .14.07.25.21.28.04 0 .11 0 .14-.04a6.354 6.354 0 004.14-8c-.62-2.01-2.18-3.53-4.13-4.17z""/></g></svg>'
                )
            );
    }

    function getChainName() public pure override returns (string memory) {
        return ""Polygon"";
    }
}",5169
RealWorld_BA_97_ISvgHelper_RealWord_20240826212658.log,97,ISvgHelper,6413,5176,11589,99.0,0.135585,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.0;

interface ISvgHelper {
    function backgroundUrl() external view returns (string memory);

    function getTokenSvg(
        uint256 _tokenId,
        uint256 _suppliedLiquidity,
        uint256 _totalSuppliedLiquidity
    ) external view returns (string memory);

    function getAttributes(uint256 _suppliedLiquidity, uint256 _totalSuppliedLiquidity)
        external
        view
        returns (string memory);

    function getDescription(uint256 _suppliedLiquidity, uint256 _totalSuppliedLiquidity)
        external
        view
        returns (string memory);

    function getChainName() external view returns (string memory);

    function owner() external view returns (address);

    function renounceOwnership() external;

    function setBackgroundPngUrl(string memory _backgroundPngUrl) external;

    function transferOwnership(address newOwner) external;
}",201
RealWorld_BA_97_Ethereum.ETH_RealWord_20240826211810.log,97,Ethereum.ETH,78585,5259,83844,93.0,0.498105,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.0;

import ""../SvgHelperBase.sol"";

contract EthereumETH is SvgHelperBase {
    using Strings for uint256;

    constructor(uint256 _decimals) SvgHelperBase(_decimals) {}

    function getTokenSvg(
        uint256 _tokenId,
        uint256 _suppliedLiquidity,
        uint256 _totalSuppliedLiquidity
    ) public view virtual override returns (string memory) {
        string memory tokenId = _tokenId.toString();
        string memory suppliedLiquidity = _divideByPowerOf10(_suppliedLiquidity, tokenDecimals, 3);
        string memory sharePercent = _calculatePercentage(_suppliedLiquidity, _totalSuppliedLiquidity);
        return
            string(
                abi.encodePacked(
                    '<svg version=""1.1"" id=""prefix__Layer_1"" xmlns=""http://www.w3.org/2000/svg"" x=""0"" y=""0"" viewBox=""0 0 405 405"" xml:space=""preserve""><style>.prefix__st15,.prefix__st2{fill:#fff}.prefix__st15{fill-opacity:.602}.prefix__st26{font-family:&apos;Courier&apos;}.prefix__st27{font-size:24px}</style><radialGradient id=""prefix__SVGID_1_"" cx=""-455.002"" cy=""406.389"" r=""1"" gradientTransform=""matrix(0 327.499 327.499 0 -132889.578 149012.563)"" gradientUnits=""userSpaceOnUse""><stop offset=""0"" stop-color=""#8c8c8c""/><stop offset=""1""/></radialGradient><path d=""M30 0h345c16.57 0 30 13.43 30 30v345c0 16.57-13.43 30-30 30H30c-16.57 0-30-13.43-30-30V30C0 13.43 13.43 0 30 0z"" fill=""url(#prefix__SVGID_1_)""/><radialGradient id=""prefix__SVGID_00000141442605033164902770000000811733122206392226_"" cx=""-908.323"" cy=""-44.569"" r=""1"" gradientTransform=""matrix(0 270.995 167.538 0 7669.416 246228.469)"" gradientUnits=""userSpaceOnUse""><stop offset=""0"" stop-color=""#fff""/><stop offset="".711"" stop-color=""#627eea""/><stop offset=""1"" stop-opacity=""0""/><stop offset=""1"" stop-opacity=""0""/></radialGradient><path d=""M214.93 95.88c-5.94-8.8-18.93-8.8-24.87 0-43.56 64.49-70.9 107.33-70.9 149.07 0 45.6 37.28 82.55 83.33 82.55s83.33-36.95 83.33-82.55c.01-41.74-27.33-84.58-70.89-149.07z"" fill=""url(#prefix__SVGID_00000141442605033164902770000000811733122206392226_)""/><path class=""prefix__st2"" d=""M271.41 338.62a.8.8 0 00-.59-.24h-1.66a.8.8 0 00-.59.24.8.8 0 00-.24.59v5c0 .11-.02.22-.06.32-.04.1-.1.2-.18.27a.8.8 0 01-.59.24h-8.33c-.11 0-.22-.02-.32-.06s-.2-.1-.27-.18-.14-.17-.18-.27a.866.866 0 01-.06-.32v-5a.8.8 0 00-.24-.59.8.8 0 00-.59-.24h-1.67c-.22 0-.43.09-.59.24s-.24.37-.24.59v15a.8.8 0 00.24.59.8.8 0 00.59.24h1.67a.8.8 0 00.59-.24.8.8 0 00.24-.59v-5a.8.8 0 01.24-.59.8.8 0 01.59-.24h8.33a.8.8 0 01.59.24.8.8 0 01.24.59v5c0 .11.02.22.06.32.04.1.1.2.18.27s.17.14.27.18.21.06.32.06h1.66c.11 0 .22-.02.32-.06.1-.04.2-.1.27-.18s.14-.17.18-.27c.04-.1.06-.21.06-.32v-15c0-.11-.02-.22-.06-.32-.04-.11-.1-.2-.18-.27zM321.41 341.91a.8.8 0 00-.59-.24h-5.83v.04h-2.5a.8.8 0 01-.59-.24.8.8 0 01-.24-.59v-5a.8.8 0 00-.24-.59.8.8 0 00-.59-.24h-1.66c-.11 0-.22.02-.32.06-.1.04-.2.1-.27.18a.8.8 0 00-.24.59v18.33c0 .11.02.22.06.32.04.1.1.2.18.27a.8.8 0 00.59.24h1.66c.11 0 .22-.02.32-.06.1-.04.2-.1.27-.18a.8.8 0 00.24-.59v-8.33a.8.8 0 01.24-.59.8.8 0 01.59-.24h5a.8.8 0 01.59.24.8.8 0 01.24.59v8.33c0 .11.02.22.06.32.04.1.1.2.18.27a.8.8 0 00.59.24h1.66c.11 0 .22-.02.32-.06.1-.04.2-.1.27-.18a.8.8 0 00.24-.59v-11.7c0-.11-.02-.22-.06-.32a.624.624 0 00-.17-.28zM338.08 341.91a.8.8 0 00-.59-.24h-11.67c-.11 0-.22.02-.32.06a.98.98 0 00-.27.18.8.8 0 00-.24.59v11.66a.8.8 0 00.24.59.8.8 0 00.59.24h11.67a.8.8 0 00.59-.24.8.8 0 00.24-.59v-1.66c0-.11-.02-.22-.06-.32-.04-.1-.1-.2-.18-.27a.8.8 0 00-.59-.24h-8.33c-.22 0-.43-.09-.59-.24-.16-.16-.24-.37-.24-.59s.09-.43.24-.59c.16-.16.37-.24.59-.24h8.33a.8.8 0 00.59-.24.8.8 0 00.24-.59v-6.66c0-.11-.02-.22-.06-.32a.841.841 0 00-.18-.29zm-3.16 4.24a.8.8 0 01-.18.27.8.8 0 01-.59.24h-5a.8.8 0 01-.59-.24.8.8 0 01-.24-.59.8.8 0 01.24-.59.8.8 0 01.59-.24h5a.8.8 0 01.59.24.8.8 0 01.24.59c0 .11-.02.22-.06.32zM354.74 341.91a.8.8 0 00-.59-.24l-2.5.04h-9.17a.8.8 0 00-.59.24.8.8 0 00-.24.59v11.66c0 .11.02.22.06.32.04.1.1.2.18.27a.8.8 0 00.59.24h1.67a.8.8 0 00.59-.24.8.8 0 00.24-.59v-8.33a.8.8 0 01.24-.59.8.8 0 01.59-.24h5c.11 0 .22.02.32.06.1.04.2.1.27.18a.8.8 0 01.24.59v8.33c0 .11.02.22.06.32.04.1.1.2.18.27a.8.8 0 00.59.24h1.67a.8.8 0 00.59-.24.8.8 0 00.24-.59v-11.7c0-.11-.02-.22-.06-.32a.65.65 0 00-.17-.27zM288.08 341.91a.8.8 0 00-.59-.24h-1.67c-.11 0-.22.02-.32.06a.98.98 0 00-.27.18.8.8 0 00-.24.59v8.33a.8.8 0 01-.24.59.8.8 0 01-.59.24h-5c-.11 0-.22-.02-.32-.06-.1-.04-.2-.1-.27-.18a.8.8 0 01-.24-.59v-8.33c0-.11-.02-.22-.06-.32-.04-.1-.1-.2-.18-.27a.8.8 0 00-.59-.24h-1.67c-.11 0-.22.02-.32.06a.98.98 0 00-.27.18.8.8 0 00-.24.59v11.66a.8.8 0 00.24.59.8.8 0 00.59.24h8.34c.22 0 .43.09.59.24.16.16.24.37.24.59s-.09.43-.24.59c-.16.16-.37.24-.59.24h-5c-.11 0-.22.02-.32.06s-.2.1-.27.18-.14.17-.18.27c-.04.1-.06.21-.06.32v1.66c0 .11.02.22.06.32.04.1.1.2.18.27s.17.14.27.18.21.06.32.06h8.33a.8.8 0 00.59-.24.8.8 0 00.24-.59v-16.66c0-.11-.02-.22-.06-.32-.05-.08-.12-.17-.19-.25zM304.74 341.91a.8.8 0 00-.59-.24h-11.67a.8.8 0 00-.59.24.8.8 0 00-.24.59v16.66c0 .11.02.22.06.32.04.1.1.2.18.27a.8.8 0 00.59.24h1.67a.8.8 0 00.59-.24.8.8 0 00.24-.59v-3.33a.8.8 0 01.24-.59.8.8 0 01.59-.24h8.34a.8.8 0 00.59-.24.8.8 0 00.24-.59v-11.66a.866.866 0 00-.24-.6zm-3.09 8.93a.8.8 0 01-.52.77c-.1.04-.21.06-.32.06h-5a.8.8 0 01-.59-.24.8.8 0 01-.24-.59v-5a.8.8 0 01.24-.59.8.8 0 01.59-.24h5a.866.866 0 01.6.24.8.8 0 01.24.59v5zM329.97 96.59c.28 0 .57-.05.83-.16s.5-.27.7-.47a2.116 2.116 0 00.63-1.53V81.49a2.182 2.182 0 00-.62-1.52 2.105 2.105 0 00-1.52-.63h-4.31c-.57 0-1.12.23-1.52.63-.4.4-.63.95-.63 1.52v4.31c0 .28-.05.57-.16.83s-.27.5-.47.7a2.116 2.116 0 01-1.53.63h-4.31c-.28 0-.57-.05-.83-.16s-.5-.27-.7-.47a2.116 2.116 0 01-.63-1.53V64.24c0-.28.05-.57.16-.83s.27-.5.47-.7a2.116 2.116 0 011.53-.63h1.25c.42 0 .84-.12 1.2-.36.35-.24.63-.57.79-.97a2.138 2.138 0 00-.49-2.33l-7.68-7.76c-.2-.21-.44-.37-.7-.48a2.124 2.124 0 00-1.66 0c-.26.11-.5.27-.7.48l-7.72 7.76c-.3.3-.51.68-.59 1.09s-.04.85.12 1.24.43.73.78.96c.35.24.76.37 1.19.37h1.25c.29 0 .57.05.83.16s.5.27.7.47c.2.2.36.44.47.7.11.26.16.55.16.83v30.2c0 .28.05.57.16.83s.27.5.47.7a2.116 2.116 0 001.53.63h21.55z""/><path class=""prefix__st2"" d=""M324.14 70.08a2.116 2.116 0 001.53.63h4.31c.28 0 .57-.05.83-.16s.5-.27.7-.47a2.116 2.116 0 00.63-1.53v-4.31c0-.28.05-.57.16-.83s.27-.5.47-.7a2.116 2.116 0 011.53-.63h4.32c.28 0 .57.05.83.16s.5.27.7.47c.2.2.36.44.47.7.11.26.16.55.16.83v21.57c0 .28-.05.57-.16.83s-.27.5-.47.7a2.116 2.116 0 01-1.53.63h-1.26c-.42 0-.84.13-1.2.36-.35.24-.63.57-.79.97-.16.39-.2.83-.11 1.24.09.42.3.8.6 1.1l7.73 7.72c.2.2.44.37.7.48a2.124 2.124 0 002.36-.48l7.72-7.72c.3-.3.5-.69.58-1.1.08-.42.04-.85-.12-1.24a2.12 2.12 0 00-.79-.96c-.35-.24-.77-.36-1.19-.36h-1.29c-.28 0-.57-.05-.83-.16s-.5-.27-.7-.47a2.116 2.116 0 01-.63-1.53V55.6c0-.28-.05-.57-.16-.83s-.27-.5-.47-.7c-.2-.2-.44-.36-.7-.47-.26-.11-.55-.16-.83-.16h-21.57c-.28 0-.57.05-.83.16s-.5.27-.7.47a2.116 2.116 0 00-.63 1.53v12.95c0 .28.05.57.16.83s.27.5.47.7z""/><text transform=""translate(73.686 67)"" class=""prefix__st2 prefix__st26 prefix__st27"">',
                    suppliedLiquidity,
                    ' ETH</text><text transform=""rotate(-90 213.61 143.092)"" class=""prefix__st2 prefix__st26 prefix__st27"">',
                    sharePercent,
                    '%</text><path fill=""none"" stroke=""#fff"" stroke-miterlimit=""10"" d=""M61.86 267.12V114.71""/><text transform=""translate(79.915 355)"" class=""prefix__st2 prefix__st26"" font-size=""10"">ID: ',
                    tokenId,
                    '</text><g><path d=""M136.03 77.23H56.69c-2.76 0-5 2.24-5 5v7.47c0 2.76 2.24 5 5 5h79.34c2.76 0 5-2.24 5-5v-7.47c0-2.76-2.24-5-5-5z"" fill=""#8c8c8c""/><text transform=""translate(56.685 89.706)"" class=""prefix__st2"" font-size=""12"" font-family=""Courier-Bold"">ON ETHEREUM</text></g><g><circle cx=""60.19"" cy=""58.5"" r=""8.5"" fill-rule=""evenodd"" clip-rule=""evenodd"" fill=""#627eea""/><path class=""prefix__st15"" d=""M60.45 52.12v4.71l3.98 1.78-3.98-6.49z""/><path class=""prefix__st2"" d=""M60.45 52.12l-3.98 6.49 3.98-1.78v-4.71z""/><path class=""prefix__st15"" d=""M60.45 61.67v3.2l3.99-5.51-3.99 2.31z""/><path class=""prefix__st2"" d=""M60.45 64.87v-3.2l-3.98-2.31 3.98 5.51z""/><path d=""M60.45 60.93l3.98-2.31-3.98-1.78v4.09z"" fill=""#fff"" fill-opacity="".2""/><path class=""prefix__st15"" d=""M56.47 58.62l3.98 2.31v-4.09l-3.98 1.78z""/></g></svg>'
                )
            );
    }

    function getChainName() public pure override returns (string memory) {
        return ""Ethereum"";
    }
}",4683
RealWorld_BA_97_Pausable_RealWord_20240826214652.log,97,Pausable,12914,4921,17835,100.0,0.16299,"// SPDX-License-Identifier: MIT

pragma solidity 0.8.0;

import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";
import ""@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol"";

/**
 * @dev Contract module which allows children to implement an emergency stop
 * mechanism that can be triggered by an authorized account.
 *
 * This module is used through inheritance. It will make available the
 * modifiers `whenNotPaused` and `whenPaused`, which can be applied to
 * the functions of your contract. Note that they will not be pausable by
 * simply including this module, only once the modifiers are put in place.
 */
abstract contract Pausable is Initializable, PausableUpgradeable {
    address private _pauser;

    event PauserChanged(address indexed previousPauser, address indexed newPauser);

    /**
     * @dev The pausable constructor sets the original `pauser` of the contract to the sender
     * account & Initializes the contract in unpaused state..
     */
    function __Pausable_init(address pauser) internal initializer {
        require(pauser != address(0), ""Pauser Address cannot be 0"");
        __Pausable_init();
        _pauser = pauser;
    }

    /**
     * @return true if `msg.sender` is the owner of the contract.
     */
    function isPauser(address pauser) public view returns (bool) {
        return pauser == _pauser;
    }

    /**
     * @dev Throws if called by any account other than the pauser.
     */
    modifier onlyPauser() {
        require(isPauser(msg.sender), ""Only pauser is allowed to perform this operation"");
        _;
    }

    /**
     * @dev Allows the current pauser to transfer control of the contract to a newPauser.
     * @param newPauser The address to transfer pauserShip to.
     */
    function changePauser(address newPauser) public onlyPauser {
        _changePauser(newPauser);
    }

    /**
     * @dev Transfers control of the contract to a newPauser.
     * @param newPauser The address to transfer ownership to.
     */
    function _changePauser(address newPauser) internal {
        require(newPauser != address(0));
        emit PauserChanged(_pauser, newPauser);
        _pauser = newPauser;
    }

    function renouncePauser() external virtual onlyPauser {
        emit PauserChanged(_pauser, address(0));
        _pauser = address(0);
    }

    function pause() public onlyPauser {
        _pause();
    }

    function unpause() public onlyPauser {
        _unpause();
    }
}",587
RealWorld_BA_97_Avalanche.BICO_RealWord_20240826211304.log,97,Avalanche.BICO,82632,5372,88004,113.0,0.5206,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.0;

import ""../SvgHelperBase.sol"";

contract AvalancheBICO is SvgHelperBase {
    using Strings for uint256;

    constructor(uint256 _decimals) SvgHelperBase(_decimals) {}

    function getTokenSvg(
        uint256 _tokenId,
        uint256 _suppliedLiquidity,
        uint256 _totalSuppliedLiquidity
    ) public view virtual override returns (string memory) {
        string memory tokenId = _tokenId.toString();
        string memory suppliedLiquidity = _divideByPowerOf10(_suppliedLiquidity, tokenDecimals, 3);
        string memory sharePercent = _calculatePercentage(_suppliedLiquidity, _totalSuppliedLiquidity);
        return
            string(
                abi.encodePacked(
                    '<svg version=""1.1"" id=""prefix__Layer_1"" xmlns=""http://www.w3.org/2000/svg"" x=""0"" y=""0"" viewBox=""0 0 405 405"" xml:space=""preserve""><style>.prefix__st2{fill:#fff}.prefix__st38{font-family:&apos;Courier&apos;}.prefix__st39{font-size:24px}</style><radialGradient id=""prefix__SVGID_1_"" cx=""457.777"" cy=""-506.389"" r=""1"" gradientTransform=""matrix(0 327.499 327.499 0 166044.5 -149921.516)"" gradientUnits=""userSpaceOnUse""><stop offset=""0"" stop-color=""#e84142""/><stop offset=""1""/></radialGradient><path d=""M30 0h345c16.57 0 30 13.43 30 30v345c0 16.57-13.43 30-30 30H30c-16.57 0-30-13.43-30-30V30C0 13.43 13.43 0 30 0z"" fill=""url(#prefix__SVGID_1_)""/><radialGradient id=""prefix__SVGID_00000047027802228991556750000014900804184815511974_"" cx=""458.356"" cy=""-507.716"" r=""1"" gradientTransform=""matrix(0 270.995 167.538 0 85264.203 -124134.695)"" gradientUnits=""userSpaceOnUse""><stop offset=""0"" stop-color=""#fff""/><stop offset="".711"" stop-color=""#d85111""/><stop offset=""1"" stop-opacity=""0""/><stop offset=""1"" stop-opacity=""0""/></radialGradient><path d=""M214.93 95.88c-5.94-8.8-18.93-8.8-24.87 0-43.56 64.49-70.9 107.33-70.9 149.07 0 45.6 37.28 82.55 83.33 82.55s83.33-36.95 83.33-82.55c.01-41.74-27.33-84.58-70.89-149.07z"" fill=""url(#prefix__SVGID_00000047027802228991556750000014900804184815511974_)""/><path class=""prefix__st2"" d=""M271.41 338.62a.8.8 0 00-.59-.24h-1.66a.8.8 0 00-.59.24.8.8 0 00-.24.59v5c0 .11-.02.22-.06.32-.04.1-.1.2-.18.27a.8.8 0 01-.59.24h-8.33c-.11 0-.22-.02-.32-.06s-.2-.1-.27-.18-.14-.17-.18-.27a.866.866 0 01-.06-.32v-5a.8.8 0 00-.24-.59.8.8 0 00-.59-.24h-1.67c-.22 0-.43.09-.59.24s-.24.37-.24.59v15a.8.8 0 00.24.59.8.8 0 00.59.24h1.67a.8.8 0 00.59-.24.8.8 0 00.24-.59v-5a.8.8 0 01.24-.59.8.8 0 01.59-.24h8.33a.8.8 0 01.59.24.8.8 0 01.24.59v5c0 .11.02.22.06.32.04.1.1.2.18.27s.17.14.27.18.21.06.32.06h1.66c.11 0 .22-.02.32-.06.1-.04.2-.1.27-.18s.14-.17.18-.27c.04-.1.06-.21.06-.32v-15c0-.11-.02-.22-.06-.32-.04-.11-.1-.2-.18-.27zM321.41 341.91a.8.8 0 00-.59-.24h-5.83v.04h-2.5a.8.8 0 01-.59-.24.8.8 0 01-.24-.59v-5a.8.8 0 00-.24-.59.8.8 0 00-.59-.24h-1.66c-.11 0-.22.02-.32.06-.1.04-.2.1-.27.18a.8.8 0 00-.24.59v18.33c0 .11.02.22.06.32.04.1.1.2.18.27a.8.8 0 00.59.24h1.66c.11 0 .22-.02.32-.06.1-.04.2-.1.27-.18a.8.8 0 00.24-.59v-8.33a.8.8 0 01.24-.59.8.8 0 01.59-.24h5a.8.8 0 01.59.24.8.8 0 01.24.59v8.33c0 .11.02.22.06.32.04.1.1.2.18.27a.8.8 0 00.59.24h1.66c.11 0 .22-.02.32-.06.1-.04.2-.1.27-.18a.8.8 0 00.24-.59v-11.7c0-.11-.02-.22-.06-.32a.624.624 0 00-.17-.28zM338.08 341.91a.8.8 0 00-.59-.24h-11.67c-.11 0-.22.02-.32.06a.98.98 0 00-.27.18.8.8 0 00-.24.59v11.66a.8.8 0 00.24.59.8.8 0 00.59.24h11.67a.8.8 0 00.59-.24.8.8 0 00.24-.59v-1.66c0-.11-.02-.22-.06-.32-.04-.1-.1-.2-.18-.27a.8.8 0 00-.59-.24h-8.33c-.22 0-.43-.09-.59-.24-.16-.16-.24-.37-.24-.59s.09-.43.24-.59c.16-.16.37-.24.59-.24h8.33a.8.8 0 00.59-.24.8.8 0 00.24-.59v-6.66c0-.11-.02-.22-.06-.32a.841.841 0 00-.18-.29zm-3.16 4.24a.8.8 0 01-.18.27.8.8 0 01-.59.24h-5a.8.8 0 01-.59-.24.8.8 0 01-.24-.59.8.8 0 01.24-.59.8.8 0 01.59-.24h5a.8.8 0 01.59.24.8.8 0 01.24.59c0 .11-.02.22-.06.32zM354.74 341.91a.8.8 0 00-.59-.24l-2.5.04h-9.17a.8.8 0 00-.59.24.8.8 0 00-.24.59v11.66c0 .11.02.22.06.32.04.1.1.2.18.27a.8.8 0 00.59.24h1.67a.8.8 0 00.59-.24.8.8 0 00.24-.59v-8.33a.8.8 0 01.24-.59.8.8 0 01.59-.24h5c.11 0 .22.02.32.06.1.04.2.1.27.18a.8.8 0 01.24.59v8.33c0 .11.02.22.06.32.04.1.1.2.18.27a.8.8 0 00.59.24h1.67a.8.8 0 00.59-.24.8.8 0 00.24-.59v-11.7c0-.11-.02-.22-.06-.32a.65.65 0 00-.17-.27zM288.08 341.91a.8.8 0 00-.59-.24h-1.67c-.11 0-.22.02-.32.06a.98.98 0 00-.27.18.8.8 0 00-.24.59v8.33a.8.8 0 01-.24.59.8.8 0 01-.59.24h-5c-.11 0-.22-.02-.32-.06-.1-.04-.2-.1-.27-.18a.8.8 0 01-.24-.59v-8.33c0-.11-.02-.22-.06-.32-.04-.1-.1-.2-.18-.27a.8.8 0 00-.59-.24h-1.67c-.11 0-.22.02-.32.06a.98.98 0 00-.27.18.8.8 0 00-.24.59v11.66a.8.8 0 00.24.59.8.8 0 00.59.24h8.34c.22 0 .43.09.59.24.16.16.24.37.24.59s-.09.43-.24.59c-.16.16-.37.24-.59.24h-5c-.11 0-.22.02-.32.06s-.2.1-.27.18-.14.17-.18.27c-.04.1-.06.21-.06.32v1.66c0 .11.02.22.06.32.04.1.1.2.18.27s.17.14.27.18.21.06.32.06h8.33a.8.8 0 00.59-.24.8.8 0 00.24-.59v-16.66c0-.11-.02-.22-.06-.32-.05-.08-.12-.17-.19-.25zM304.74 341.91a.8.8 0 00-.59-.24h-11.67a.8.8 0 00-.59.24.8.8 0 00-.24.59v16.66c0 .11.02.22.06.32.04.1.1.2.18.27a.8.8 0 00.59.24h1.67a.8.8 0 00.59-.24.8.8 0 00.24-.59v-3.33a.8.8 0 01.24-.59.8.8 0 01.59-.24h8.34a.8.8 0 00.59-.24.8.8 0 00.24-.59v-11.66a.866.866 0 00-.24-.6zm-3.09 8.93a.8.8 0 01-.52.77c-.1.04-.21.06-.32.06h-5a.8.8 0 01-.59-.24.8.8 0 01-.24-.59v-5a.8.8 0 01.24-.59.8.8 0 01.59-.24h5a.866.866 0 01.6.24.8.8 0 01.24.59v5zM329.97 96.59c.28 0 .57-.05.83-.16s.5-.27.7-.47a2.116 2.116 0 00.63-1.53V81.49a2.182 2.182 0 00-.62-1.52 2.105 2.105 0 00-1.52-.63h-4.31c-.57 0-1.12.23-1.52.63-.4.4-.63.95-.63 1.52v4.31c0 .28-.05.57-.16.83s-.27.5-.47.7a2.116 2.116 0 01-1.53.63h-4.31c-.28 0-.57-.05-.83-.16s-.5-.27-.7-.47a2.116 2.116 0 01-.63-1.53V64.24c0-.28.05-.57.16-.83s.27-.5.47-.7a2.116 2.116 0 011.53-.63h1.25c.42 0 .84-.12 1.2-.36.35-.24.63-.57.79-.97a2.138 2.138 0 00-.49-2.33l-7.68-7.76c-.2-.21-.44-.37-.7-.48a2.124 2.124 0 00-1.66 0c-.26.11-.5.27-.7.48l-7.72 7.76c-.3.3-.51.68-.59 1.09s-.04.85.12 1.24.43.73.78.96c.35.24.76.37 1.19.37h1.25c.29 0 .57.05.83.16s.5.27.7.47c.2.2.36.44.47.7.11.26.16.55.16.83v30.2c0 .28.05.57.16.83s.27.5.47.7a2.116 2.116 0 001.53.63h21.55z""/><path class=""prefix__st2"" d=""M324.14 70.08a2.116 2.116 0 001.53.63h4.31c.28 0 .57-.05.83-.16s.5-.27.7-.47a2.116 2.116 0 00.63-1.53v-4.31c0-.28.05-.57.16-.83s.27-.5.47-.7a2.116 2.116 0 011.53-.63h4.32c.28 0 .57.05.83.16s.5.27.7.47c.2.2.36.44.47.7.11.26.16.55.16.83v21.57c0 .28-.05.57-.16.83s-.27.5-.47.7a2.116 2.116 0 01-1.53.63h-1.26c-.42 0-.84.13-1.2.36-.35.24-.63.57-.79.97-.16.39-.2.83-.11 1.24.09.42.3.8.6 1.1l7.73 7.72c.2.2.44.37.7.48a2.124 2.124 0 002.36-.48l7.72-7.72c.3-.3.5-.69.58-1.1.08-.42.04-.85-.12-1.24a2.12 2.12 0 00-.79-.96c-.35-.24-.77-.36-1.19-.36h-1.29c-.28 0-.57-.05-.83-.16s-.5-.27-.7-.47a2.116 2.116 0 01-.63-1.53V55.6c0-.28-.05-.57-.16-.83s-.27-.5-.47-.7c-.2-.2-.44-.36-.7-.47-.26-.11-.55-.16-.83-.16h-21.57c-.28 0-.57.05-.83.16s-.5.27-.7.47a2.116 2.116 0 00-.63 1.53v12.95c0 .28.05.57.16.83s.27.5.47.7z""/><text transform=""translate(73.686 67)"" class=""prefix__st2 prefix__st38 prefix__st39"">',
                    suppliedLiquidity,
                    ' BICO</text><text transform=""rotate(-90 213.61 143.093)"" class=""prefix__st2 prefix__st38 prefix__st39"">',
                    sharePercent,
                    '%</text><path fill=""none"" stroke=""#fff"" stroke-miterlimit=""10"" d=""M61.86 267.12V114.71""/><text transform=""translate(79.915 355)"" class=""prefix__st2 prefix__st38"" font-size=""10"">ID: ',
                    tokenId,
                    '</text><g><path d=""M142.44 77.23H56.69c-2.76 0-5 2.24-5 5v7.47c0 2.76 2.24 5 5 5h85.75c2.76 0 5-2.24 5-5v-7.47c0-2.76-2.24-5-5-5z"" fill=""#e84142""/><text transform=""translate(56.685 89.706)"" class=""prefix__st2"" font-size=""12"" font-family=""Courier-Bold"">ON AVALANCHE</text></g><g><circle cx=""60.19"" cy=""58.5"" r=""8.5""/><linearGradient id=""prefix__SVGID_00000129165268976242144260000016321246092256663168_"" gradientUnits=""userSpaceOnUse"" x1=""58.709"" y1=""66.872"" x2=""61.662"" y2=""50.128""><stop offset=""0"" stop-color=""#fff""/><stop offset=""1"" stop-color=""#fff""/></linearGradient><path d=""M60.19 50.75c4.27 0 7.75 3.48 7.75 7.75s-3.48 7.75-7.75 7.75-7.75-3.48-7.75-7.75 3.47-7.75 7.75-7.75m0-.75c-4.69 0-8.5 3.81-8.5 8.5s3.81 8.5 8.5 8.5 8.5-3.81 8.5-8.5-3.81-8.5-8.5-8.5z"" fill=""url(#prefix__SVGID_00000129165268976242144260000016321246092256663168_)""/><g><path d=""M61.53 54.53c-.31-.18-.68-.28-1.06-.28h-2.12c.59 0 1.06.48 1.06 1.06v3.19h1.06c.39 0 .75-.1 1.06-.29.23-.13.44-.31.6-.52.29-.36.46-.82.46-1.32 0-.78-.42-1.47-1.06-1.84z"" fill=""#d85111""/><path class=""prefix__st2"" d=""M62.14 57.69a2.131 2.131 0 01-1.66.81h-1.06v-3.19a1.06 1.06 0 00-2.12 0V62.75H61c.18 0 .36-.02.53-.05a2.66 2.66 0 002.12-2.6c.01-1.07-.62-1.98-1.51-2.41z""/></g></g></svg>'
                )
            );
    }

    function getChainName() public pure override returns (string memory) {
        return ""Avalanche"";
    }
}",4929
RealWorld_BA_97_IERC20Permit_RealWord_20240826214834.log,97,IERC20Permit,6131,4843,10974,78.0,0.127515,"// SPDX-License-Identifier: Apache-2.0
pragma solidity 0.8.0;

import ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"";

interface IERC20Detailed is IERC20Upgradeable {
  function name() external view returns(string memory);
  function decimals() external view returns(uint256);
}

interface IERC20Nonces is IERC20Detailed {
  function nonces(address holder) external view returns(uint);
}

interface IERC20Permit is IERC20Nonces {
  function permit(address holder, address spender, uint256 nonce, uint256 expiry,
                  bool allowed, uint8 v, bytes32 r, bytes32 s) external;

  function permit(address holder, address spender, uint256 value, uint256 expiry,
                  uint8 v, bytes32 r, bytes32 s) external;
}",181
RealWorld_BA_97_LiquidityProviders_RealWord_20240826205006.log,97,LiquidityProviders,72298,5624,77922,101.0,0.47397,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.0;

import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";
import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol"";
import ""./metatx/ERC2771ContextUpgradeable.sol"";

import ""../security/Pausable.sol"";
import ""./interfaces/ILPToken.sol"";
import ""./interfaces/ITokenManager.sol"";
import ""./interfaces/IWhiteListPeriodManager.sol"";
import ""./interfaces/ILiquidityPool.sol"";

contract LiquidityProviders is
    Initializable,
    ReentrancyGuardUpgradeable,
    ERC2771ContextUpgradeable,
    OwnableUpgradeable,
    Pausable
{
    using SafeERC20Upgradeable for IERC20Upgradeable;

    address internal constant NATIVE = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;
    uint256 public constant BASE_DIVISOR = 10**18;

    ILPToken internal lpToken;
    ILiquidityPool internal liquidityPool;
    ITokenManager internal tokenManager;
    IWhiteListPeriodManager internal whiteListPeriodManager;

    event LiquidityAdded(address indexed tokenAddress, uint256 indexed amount, address indexed lp);
    event LiquidityRemoved(address indexed tokenAddress, uint256 indexed amount, address indexed lp);
    event FeeClaimed(address indexed tokenAddress, uint256 indexed fee, address indexed lp, uint256 sharesBurnt);
    event FeeAdded(address indexed tokenAddress, uint256 indexed fee);
    event EthReceived(address indexed sender, uint256 value);
    event CurrentLiquidityChanged(address indexed token, uint256 indexed oldValue, uint256 indexed newValue);

    // LP Fee Distribution
    mapping(address => uint256) public totalReserve; // Include Liquidity + Fee accumulated
    mapping(address => uint256) public totalLiquidity; // Include Liquidity only
    mapping(address => uint256) public currentLiquidity; // Include current liquidity, updated on every in and out transfer
    mapping(address => uint256) public totalLPFees;
    mapping(address => uint256) public totalSharesMinted;

    /**
     * @dev Modifier for checking to validate a NFTId and it's ownership
     * @param _tokenId token id to validate
     * @param _transactor typically msgSender(), passed to verify against owner of _tokenId
     */
    modifier onlyValidLpToken(uint256 _tokenId, address _transactor) {
        (address token, , ) = lpToken.tokenMetadata(_tokenId);
        require(lpToken.exists(_tokenId), ""ERR__TOKEN_DOES_NOT_EXIST"");
        require(lpToken.ownerOf(_tokenId) == _transactor, ""ERR__TRANSACTOR_DOES_NOT_OWN_NFT"");
        _;
    }

    /**
     * @dev Modifier for checking if msg.sender in liquiditypool
     */
    modifier onlyLiquidityPool() {
        require(_msgSender() == address(liquidityPool), ""ERR__UNAUTHORIZED"");
        _;
    }

    modifier tokenChecks(address tokenAddress) {
        require(tokenAddress != address(0), ""Token address cannot be 0"");
        require(_isSupportedToken(tokenAddress), ""Token not supported"");
        _;
    }

    /**
     * @dev initalizes the contract, acts as constructor
     * @param _trustedForwarder address of trusted forwarder
     */
    function initialize(
        address _trustedForwarder,
        address _lpToken,
        address _tokenManager,
        address _pauser
    ) public initializer {
        __ERC2771Context_init(_trustedForwarder);
        __Ownable_init();
        __Pausable_init(_pauser);
        __ReentrancyGuard_init();
        _setLPToken(_lpToken);
        _setTokenManager(_tokenManager);
    }

    function _isSupportedToken(address _token) internal view returns (bool) {
        return tokenManager.getTokensInfo(_token).supportedToken;
    }

    function getTotalReserveByToken(address tokenAddress) public view returns (uint256) {
        return totalReserve[tokenAddress];
    }

    function getSuppliedLiquidityByToken(address tokenAddress) public view returns (uint256) {
        return totalLiquidity[tokenAddress];
    }

    function getTotalLPFeeByToken(address tokenAddress) public view returns (uint256) {
        return totalLPFees[tokenAddress];
    }

    function getCurrentLiquidity(address tokenAddress) public view returns (uint256) {
        return currentLiquidity[tokenAddress];
    }

    /**
     * @dev To be called post initialization, used to set address of NFT Contract
     * @param _lpToken address of lpToken
     */
    function setLpToken(address _lpToken) external onlyOwner {
        _setLPToken(_lpToken);
    }

    /**
     * Internal method to set LP token contract.
     */
    function _setLPToken(address _lpToken) internal {
        lpToken = ILPToken(_lpToken);
    }

    function increaseCurrentLiquidity(address tokenAddress, uint256 amount) public onlyLiquidityPool {
        _increaseCurrentLiquidity(tokenAddress, amount);
    }

    function decreaseCurrentLiquidity(address tokenAddress, uint256 amount) public onlyLiquidityPool {
        _decreaseCurrentLiquidity(tokenAddress, amount);
    }

    function _increaseCurrentLiquidity(address tokenAddress, uint256 amount) private {
        currentLiquidity[tokenAddress] += amount;
        emit CurrentLiquidityChanged(tokenAddress, currentLiquidity[tokenAddress]-amount, currentLiquidity[tokenAddress]);
    }

    function _decreaseCurrentLiquidity(address tokenAddress, uint256 amount) private {
        currentLiquidity[tokenAddress] -= amount;
        emit CurrentLiquidityChanged(tokenAddress, currentLiquidity[tokenAddress]+amount, currentLiquidity[tokenAddress]);
    }

    /**
     * Public method to set TokenManager contract.
     */
    function setTokenManager(address _tokenManager) external onlyOwner {
        _setTokenManager(_tokenManager);
    }

    /**
     * Internal method to set TokenManager contract.
     */
    function _setTokenManager(address _tokenManager) internal {
        tokenManager = ITokenManager(_tokenManager);
    }

    /**
     * @dev To be called post initialization, used to set address of WhiteListPeriodManager Contract
     * @param _whiteListPeriodManager address of WhiteListPeriodManager
     */
    function setWhiteListPeriodManager(address _whiteListPeriodManager) external onlyOwner {
        whiteListPeriodManager = IWhiteListPeriodManager(_whiteListPeriodManager);
    }

    /**
     * @dev To be called post initialization, used to set address of LiquidityPool Contract
     * @param _liquidityPool address of LiquidityPool
     */
    function setLiquidityPool(address _liquidityPool) external onlyOwner {
        liquidityPool = ILiquidityPool(_liquidityPool);
    }

    /**
     * @dev Returns price of Base token in terms of LP Shares
     * @param _baseToken address of baseToken
     * @return Price of Base token in terms of LP Shares
     */
    function getTokenPriceInLPShares(address _baseToken) public view returns (uint256) {
        uint256 supply = totalSharesMinted[_baseToken];
        if (supply > 0) {
            return totalSharesMinted[_baseToken] / totalReserve[_baseToken];
        }
        return BASE_DIVISOR;
    }

    /**
     * @dev Converts shares to token amount
     */

    function sharesToTokenAmount(uint256 _shares, address _tokenAddress) public view returns (uint256) {
        return (_shares * totalReserve[_tokenAddress]) / totalSharesMinted[_tokenAddress];
    }

    /**
     * @dev Returns the fee accumulated on a given NFT
     * @param _nftId Id of NFT
     * @return accumulated fee
     */
    function getFeeAccumulatedOnNft(uint256 _nftId) public view returns (uint256) {
        require(lpToken.exists(_nftId), ""ERR__INVALID_NFT"");

        (address _tokenAddress, uint256 nftSuppliedLiquidity, uint256 totalNFTShares) = lpToken.tokenMetadata(_nftId);

        if (totalNFTShares == 0) {
            return 0;
        }
        // Calculate rewards accumulated
        uint256 eligibleLiquidity = sharesToTokenAmount(totalNFTShares, _tokenAddress);
        uint256 lpFeeAccumulated;

        // Handle edge cases where eligibleLiquidity is less than what was supplied by very small amount 
        if(nftSuppliedLiquidity > eligibleLiquidity) {
            lpFeeAccumulated = 0;
        } else {
            unchecked {
                lpFeeAccumulated = eligibleLiquidity - nftSuppliedLiquidity;
            }
        }
        return lpFeeAccumulated;
    }

    /**
     * @dev Records fee being added to total reserve
     * @param _token Address of Token for which LP fee is being added
     * @param _amount Amount being added
     */
    function addLPFee(address _token, uint256 _amount) external onlyLiquidityPool tokenChecks(_token) whenNotPaused {
        totalReserve[_token] += _amount;
        totalLPFees[_token] += _amount;
        emit FeeAdded(_token, _amount);
    }

    /**
     * @dev Internal function to add liquidity to a new NFT
     */
    function _addLiquidity(address _token, uint256 _amount) internal {
        require(_amount > 0, ""ERR__AMOUNT_IS_0"");
        uint256 nftId = lpToken.mint(_msgSender());
        LpTokenMetadata memory data = LpTokenMetadata(_token, 0, 0);
        lpToken.updateTokenMetadata(nftId, data);
        _increaseLiquidity(nftId, _amount);
    }

    /**
     * @dev Function to mint a new NFT for a user, add native liquidity and store the
     *      record in the newly minted NFT
     */
    function addNativeLiquidity() external payable nonReentrant tokenChecks(NATIVE) whenNotPaused {
        (bool success, ) = address(liquidityPool).call{value: msg.value}("""");
        require(success, ""ERR__NATIVE_TRANSFER_FAILED"");
        _addLiquidity(NATIVE, msg.value);
    }

    /**
     * @dev Function to mint a new NFT for a user, add token liquidity and store the
     *      record in the newly minted NFT
     * @param _token Address of token for which liquidity is to be added
     * @param _amount Amount of liquidity added
     */
    function addTokenLiquidity(address _token, uint256 _amount)
        external
        nonReentrant
        tokenChecks(_token)
        whenNotPaused
    {
        require(_token != NATIVE, ""ERR__WRONG_FUNCTION"");
        require(
            IERC20Upgradeable(_token).allowance(_msgSender(), address(this)) >= _amount,
            ""ERR__INSUFFICIENT_ALLOWANCE""
        );
        SafeERC20Upgradeable.safeTransferFrom(IERC20Upgradeable(_token), _msgSender(), address(liquidityPool), _amount);
        _addLiquidity(_token, _amount);
    }

    /**
     * @dev Internal helper function to increase liquidity in a given NFT
     */
    function _increaseLiquidity(uint256 _nftId, uint256 _amount) internal onlyValidLpToken(_nftId, _msgSender()) {
        (address token, uint256 totalSuppliedLiquidity, uint256 totalShares) = lpToken.tokenMetadata(_nftId);

        require(_amount > 0, ""ERR__AMOUNT_IS_0"");
        whiteListPeriodManager.beforeLiquidityAddition(_msgSender(), token, _amount);

        uint256 mintedSharesAmount;
        // Adding liquidity in the pool for the first time
        if (totalReserve[token] == 0) {
            mintedSharesAmount = BASE_DIVISOR * _amount;
        } else {
            mintedSharesAmount = (_amount * totalSharesMinted[token]) / totalReserve[token];
        }

        require(mintedSharesAmount >= BASE_DIVISOR, ""ERR__AMOUNT_BELOW_MIN_LIQUIDITY"");

        totalLiquidity[token] += _amount;
        totalReserve[token] += _amount;
        totalSharesMinted[token] += mintedSharesAmount;

        LpTokenMetadata memory data = LpTokenMetadata(
            token,
            totalSuppliedLiquidity + _amount,
            totalShares + mintedSharesAmount
        );
        lpToken.updateTokenMetadata(_nftId, data);

        // Increase the current liquidity
        _increaseCurrentLiquidity(token, _amount);
        emit LiquidityAdded(token, _amount, _msgSender());
    }

    /**
     * @dev Function to allow LPs to add ERC20 token liquidity to existing NFT
     * @param _nftId ID of NFT for updating the balances
     * @param _amount Token amount to be added
     */
    function increaseTokenLiquidity(uint256 _nftId, uint256 _amount) external nonReentrant whenNotPaused {
        (address token, , ) = lpToken.tokenMetadata(_nftId);
        require(_isSupportedToken(token), ""ERR__TOKEN_NOT_SUPPORTED"");
        require(token != NATIVE, ""ERR__WRONG_FUNCTION"");
        require(
            IERC20Upgradeable(token).allowance(_msgSender(), address(this)) >= _amount,
            ""ERR__INSUFFICIENT_ALLOWANCE""
        );
        SafeERC20Upgradeable.safeTransferFrom(IERC20Upgradeable(token), _msgSender(), address(liquidityPool), _amount);
        _increaseLiquidity(_nftId, _amount);
    }

    /**
     * @dev Function to allow LPs to add native token liquidity to existing NFT
     */
    function increaseNativeLiquidity(uint256 _nftId) external payable nonReentrant whenNotPaused {
        (address token, , ) = lpToken.tokenMetadata(_nftId);
        require(_isSupportedToken(NATIVE), ""ERR__TOKEN_NOT_SUPPORTED"");
        require(token == NATIVE, ""ERR__WRONG_FUNCTION"");
        (bool success, ) = address(liquidityPool).call{value: msg.value}("""");
        require(success, ""ERR__NATIVE_TRANSFER_FAILED"");
        _increaseLiquidity(_nftId, msg.value);
    }

    /**
     * @dev Function to allow LPs to remove their liquidity from an existing NFT
     *      Also automatically redeems any earned fee
     */
    function removeLiquidity(uint256 _nftId, uint256 _amount)
        external
        nonReentrant
        onlyValidLpToken(_nftId, _msgSender())
        whenNotPaused
    {
        (address _tokenAddress, uint256 nftSuppliedLiquidity, uint256 totalNFTShares) = lpToken.tokenMetadata(_nftId);
        require(_isSupportedToken(_tokenAddress), ""ERR__TOKEN_NOT_SUPPORTED"");

        require(_amount != 0, ""ERR__INVALID_AMOUNT"");
        require(nftSuppliedLiquidity >= _amount, ""ERR__INSUFFICIENT_LIQUIDITY"");
        whiteListPeriodManager.beforeLiquidityRemoval(_msgSender(), _tokenAddress, _amount);
        // Claculate how much shares represent input amount
        uint256 lpSharesForInputAmount = _amount * getTokenPriceInLPShares(_tokenAddress);

        // Calculate rewards accumulated
        uint256 eligibleLiquidity = sharesToTokenAmount(totalNFTShares, _tokenAddress);
        
        uint256 lpFeeAccumulated;

        // Handle edge cases where eligibleLiquidity is less than what was supplied by very small amount 
        if(nftSuppliedLiquidity > eligibleLiquidity) {
            lpFeeAccumulated = 0;
        } else {
            unchecked {
                lpFeeAccumulated = eligibleLiquidity - nftSuppliedLiquidity;
            }
        }
        // Calculate amount of lp shares that represent accumulated Fee
        uint256 lpSharesRepresentingFee = lpFeeAccumulated * getTokenPriceInLPShares(_tokenAddress);

        totalLPFees[_tokenAddress] -= lpFeeAccumulated;
        uint256 amountToWithdraw = _amount + lpFeeAccumulated;
        uint256 lpSharesToBurn = lpSharesForInputAmount + lpSharesRepresentingFee;

        // Handle round off errors to avoid dust lp token in contract
        if (totalNFTShares - lpSharesToBurn < BASE_DIVISOR) {
            lpSharesToBurn = totalNFTShares;
        }
        totalReserve[_tokenAddress] -= amountToWithdraw;
        totalLiquidity[_tokenAddress] -= _amount;
        totalSharesMinted[_tokenAddress] -= lpSharesToBurn;

        _decreaseCurrentLiquidity(_tokenAddress, _amount);

        _burnSharesFromNft(_nftId, lpSharesToBurn, _amount, _tokenAddress);

        _transferFromLiquidityPool(_tokenAddress, _msgSender(), amountToWithdraw);

        emit LiquidityRemoved(_tokenAddress, amountToWithdraw, _msgSender());
    }

    /**
     * @dev Function to allow LPs to claim the fee earned on their NFT
     * @param _nftId ID of NFT where liquidity is recorded
     */
    function claimFee(uint256 _nftId) external onlyValidLpToken(_nftId, _msgSender()) whenNotPaused nonReentrant {
        (address _tokenAddress, uint256 nftSuppliedLiquidity, uint256 totalNFTShares) = lpToken.tokenMetadata(_nftId);
        require(_isSupportedToken(_tokenAddress), ""ERR__TOKEN_NOT_SUPPORTED"");

        uint256 lpSharesForSuppliedLiquidity = nftSuppliedLiquidity * getTokenPriceInLPShares(_tokenAddress);

        // Calculate rewards accumulated
        uint256 eligibleLiquidity = sharesToTokenAmount(totalNFTShares, _tokenAddress);
        uint256 lpFeeAccumulated = eligibleLiquidity - nftSuppliedLiquidity;
        require(lpFeeAccumulated > 0, ""ERR__NO_REWARDS_TO_CLAIM"");
        // Calculate amount of lp shares that represent accumulated Fee
        uint256 lpSharesRepresentingFee = totalNFTShares - lpSharesForSuppliedLiquidity;

        totalReserve[_tokenAddress] -= lpFeeAccumulated;
        totalSharesMinted[_tokenAddress] -= lpSharesRepresentingFee;
        totalLPFees[_tokenAddress] -= lpFeeAccumulated;

        _burnSharesFromNft(_nftId, lpSharesRepresentingFee, 0, _tokenAddress);
        _transferFromLiquidityPool(_tokenAddress, _msgSender(), lpFeeAccumulated);
        emit FeeClaimed(_tokenAddress, lpFeeAccumulated, _msgSender(), lpSharesRepresentingFee);
    }

    /**
     * @dev Internal Function to burn LP shares and remove liquidity from existing NFT
     */
    function _burnSharesFromNft(
        uint256 _nftId,
        uint256 _shares,
        uint256 _tokenAmount,
        address _tokenAddress
    ) internal {
        (, uint256 nftSuppliedLiquidity, uint256 nftShares) = lpToken.tokenMetadata(_nftId);
        nftShares -= _shares;
        nftSuppliedLiquidity -= _tokenAmount;

        lpToken.updateTokenMetadata(_nftId, LpTokenMetadata(_tokenAddress, nftSuppliedLiquidity, nftShares));
    }

    function _transferFromLiquidityPool(
        address _tokenAddress,
        address _receiver,
        uint256 _tokenAmount
    ) internal {
        liquidityPool.transfer(_tokenAddress, _receiver, _tokenAmount);
    }

    function getSuppliedLiquidity(uint256 _nftId) external view returns (uint256) {
        (, uint256 totalSuppliedLiquidity, ) = lpToken.tokenMetadata(_nftId);
        return totalSuppliedLiquidity;
    }

    function _msgSender()
        internal
        view
        virtual
        override(ContextUpgradeable, ERC2771ContextUpgradeable)
        returns (address sender)
    {
        return ERC2771ContextUpgradeable._msgSender();
    }

    function _msgData()
        internal
        view
        virtual
        override(ContextUpgradeable, ERC2771ContextUpgradeable)
        returns (bytes calldata)
    {
        return ERC2771ContextUpgradeable._msgData();
    }

    receive() external payable {
        emit EthReceived(_msgSender(), msg.value);
    }
}",4555
RealWorld_BA_97_LPToken_RealWord_20240826205808.log,97,LPToken,28350,6126,34476,105.0,0.26427,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.0;
pragma abicoder v2;

import ""@openzeppelin/contracts-upgradeable/metatx/ERC2771ContextUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721EnumerableUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721URIStorageUpgradeable.sol"";
import ""base64-sol/base64.sol"";
import ""../interfaces/ISvgHelper.sol"";
import ""../interfaces/IWhiteListPeriodManager.sol"";
import ""../interfaces/ILiquidityProviders.sol"";
import ""../../security/Pausable.sol"";
import ""../structures/LpTokenMetadata.sol"";

contract LPToken is
    OwnableUpgradeable,
    ReentrancyGuardUpgradeable,
    ERC721EnumerableUpgradeable,
    ERC721URIStorageUpgradeable,
    ERC2771ContextUpgradeable,
    Pausable
{
    address internal constant NATIVE = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;

    address public liquidityProvidersAddress;
    IWhiteListPeriodManager public whiteListPeriodManager;
    mapping(uint256 => LpTokenMetadata) public tokenMetadata;
    mapping(address => ISvgHelper) public svgHelpers;

    event LiquidityProvidersUpdated(address indexed lpm);
    event WhiteListPeriodManagerUpdated(address indexed manager);
    event SvgHelperUpdated(address indexed tokenAddress, ISvgHelper indexed svgHelper);

    function initialize(
        string memory _name,
        string memory _symbol,
        address _trustedForwarder,
        address _pauser
    ) public initializer {
        __Ownable_init();
        __ERC721_init(_name, _symbol);
        __ERC721Enumerable_init();
        __Pausable_init(_pauser);
        __ERC721URIStorage_init();
        __ReentrancyGuard_init();
        __ERC2771Context_init(_trustedForwarder);
    }

    modifier onlyHyphenPools() {
        require(_msgSender() == liquidityProvidersAddress, ""ERR_UNAUTHORIZED"");
        _;
    }

    function setSvgHelper(address _tokenAddress, ISvgHelper _svgHelper) public onlyOwner {
        require(_svgHelper != ISvgHelper(address(0)), ""ERR_INVALID_SVG_HELPER"");
        require(_tokenAddress != address(0), ""ERR_INVALID_TOKEN_ADDRESS"");
        svgHelpers[_tokenAddress] = _svgHelper;
        emit SvgHelperUpdated(_tokenAddress, _svgHelper);
    }

    function setLiquidityProviders(address _liquidityProviders) external onlyOwner {
        require(_liquidityProviders != address(0), ""ERR_INVALID_LIQUIDITY_PROVIDERS"");
        liquidityProvidersAddress = _liquidityProviders;
        emit LiquidityProvidersUpdated(_liquidityProviders);
    }

    function setWhiteListPeriodManager(address _whiteListPeriodManager) external onlyOwner {
        require(_whiteListPeriodManager != address(0), ""ERR_INVALID_WHITELIST_PERIOD_MANAGER"");
        whiteListPeriodManager = IWhiteListPeriodManager(_whiteListPeriodManager);
        emit WhiteListPeriodManagerUpdated(_whiteListPeriodManager);
    }

    function getAllNftIdsByUser(address _owner) public view returns (uint256[] memory) {
        uint256[] memory nftIds = new uint256[](balanceOf(_owner));
        for (uint256 i = 0; i < nftIds.length; ++i) {
            nftIds[i] = tokenOfOwnerByIndex(_owner, i);
        }
        return nftIds;
    }

    function mint(address _to) external onlyHyphenPools whenNotPaused nonReentrant returns (uint256) {
        uint256 tokenId = totalSupply() + 1;
        _safeMint(_to, tokenId);
        return tokenId;
    }

    function updateTokenMetadata(uint256 _tokenId, LpTokenMetadata memory _lpTokenMetadata)
        external
        onlyHyphenPools
        whenNotPaused
    {
        require(_exists(_tokenId), ""ERR__TOKEN_DOES_NOT_EXIST"");
        tokenMetadata[_tokenId] = _lpTokenMetadata;
    }

    function exists(uint256 _tokenId) public view returns (bool) {
        return _exists(_tokenId);
    }

    function supportsInterface(bytes4 interfaceId)
        public
        view
        virtual
        override(ERC721Upgradeable, ERC721EnumerableUpgradeable)
        returns (bool)
    {
        return super.supportsInterface(interfaceId);
    }

    function tokenURI(uint256 tokenId)
        public
        view
        virtual
        override(ERC721Upgradeable, ERC721URIStorageUpgradeable)
        returns (string memory)
    {
        address tokenAddress = tokenMetadata[tokenId].token;
        require(svgHelpers[tokenAddress] != ISvgHelper(address(0)), ""ERR__SVG_HELPER_NOT_REGISTERED"");

        ISvgHelper svgHelper = ISvgHelper(svgHelpers[tokenAddress]);

        string memory svgData = svgHelper.getTokenSvg(
            tokenId,
            tokenMetadata[tokenId].suppliedLiquidity,
            ILiquidityProviders(liquidityProvidersAddress).totalReserve(tokenAddress)
        );

        string memory description = svgHelper.getDescription(
            tokenMetadata[tokenId].suppliedLiquidity,
            ILiquidityProviders(liquidityProvidersAddress).totalReserve(tokenAddress)
        );

        string memory attributes = svgHelper.getAttributes(
            tokenMetadata[tokenId].suppliedLiquidity,
            ILiquidityProviders(liquidityProvidersAddress).totalReserve(tokenAddress)
        );

        string memory json = Base64.encode(
            bytes(
                string(
                    abi.encodePacked(
                        '{""name"": ""',
                        name(),
                        '"", ""description"": ""',
                        description,
                        '"", ""image"": ""data:image/svg+xml;base64,',
                        Base64.encode(bytes(svgData)),
                        '"", ""attributes"": ',
                        attributes,
                        ""}""
                    )
                )
            )
        );
        return string(abi.encodePacked(""data:application/json;base64,"", json));
    }

    function _msgSender()
        internal
        view
        virtual
        override(ContextUpgradeable, ERC2771ContextUpgradeable)
        returns (address)
    {
        return ERC2771ContextUpgradeable._msgSender();
    }

    function _msgData()
        internal
        view
        virtual
        override(ContextUpgradeable, ERC2771ContextUpgradeable)
        returns (bytes calldata)
    {
        return ERC2771ContextUpgradeable._msgData();
    }

    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 tokenId
    ) internal virtual override(ERC721EnumerableUpgradeable, ERC721Upgradeable) whenNotPaused {
        super._beforeTokenTransfer(from, to, tokenId);

        // Only call whitelist period manager for NFT Transfers, not mint and burns
        if (from != address(0) && to != address(0)) {
            whiteListPeriodManager.beforeLiquidityTransfer(
                from,
                to,
                tokenMetadata[tokenId].token,
                tokenMetadata[tokenId].suppliedLiquidity
            );
        }
    }

    function _burn(uint256 tokenId) internal virtual override(ERC721URIStorageUpgradeable, ERC721Upgradeable) {
        ERC721URIStorageUpgradeable._burn(tokenId);
    }
}",1569
RealWorld_BA_97_LiquidityProvidersTest_RealWord_20240826214229.log,97,LiquidityProvidersTest,6141,4851,10992,83.0,0.127725,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.0;

import ""../hyphen/LiquidityProviders.sol"";
import ""hardhat/console.sol"";

contract LiquidityProvidersTest is LiquidityProviders {
    using SafeERC20Upgradeable for IERC20Upgradeable;

    function addLpFeeTesting(address _token, uint256 _amount) external payable {
        totalReserve[_token] += _amount;
        totalLPFees[_token] += _amount;

        if (_token == NATIVE) {
            (bool success, ) = address(liquidityPool).call{value: msg.value}("""");
            require(success, ""ERR__NATIVE_TRANSFER_FAILED"");
        } else {
            IERC20Upgradeable(_token).safeTransferFrom(msg.sender, address(liquidityPool), _amount);
        }
    }
}",174
RealWorld_BA_97_LiquidityFarming_RealWord_20240826205150.log,97,LiquidityFarming,61108,5601,66709,97.0,0.41756,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.0;

import ""@openzeppelin/contracts-upgradeable/interfaces/IERC721ReceiverUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";
import ""@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol"";
import ""./metatx/ERC2771ContextUpgradeable.sol"";

import ""../security/Pausable.sol"";
import ""./interfaces/ILPToken.sol"";
import ""./interfaces/ILiquidityProviders.sol"";

contract HyphenLiquidityFarming is
    Initializable,
    ERC2771ContextUpgradeable,
    OwnableUpgradeable,
    Pausable,
    ReentrancyGuardUpgradeable,
    IERC721ReceiverUpgradeable
{
    using SafeERC20Upgradeable for IERC20Upgradeable;

    ILPToken public lpToken;
    ILiquidityProviders public liquidityProviders;

    struct NFTInfo {
        address payable staker;
        uint256 rewardDebt;
        uint256 unpaidRewards;
        bool isStaked;
    }

    struct PoolInfo {
        uint256 accTokenPerShare;
        uint256 lastRewardTime;
    }

    struct RewardsPerSecondEntry {
        uint256 rewardsPerSecond;
        uint256 timestamp;
    }

    /// @notice Mapping to track the rewarder pool.
    mapping(address => PoolInfo) public poolInfo;

    /// @notice Info of each NFT that is staked.
    mapping(uint256 => NFTInfo) public nftInfo;

    /// @notice Reward rate per base token
    //mapping(address => uint256) public rewardPerSecond;

    /// @notice Reward Token
    mapping(address => address) public rewardTokens;

    /// @notice Staker => NFTs staked
    mapping(address => uint256[]) public nftIdsStaked;

    /// @notice Token => Total Shares Staked
    mapping(address => uint256) public totalSharesStaked;

    /// @notice Token => Reward Rate Updation history
    mapping(address => RewardsPerSecondEntry[]) public rewardRateLog;

    uint256 private constant ACC_TOKEN_PRECISION = 1e12;
    address internal constant NATIVE = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;

    event LogDeposit(address indexed user, address indexed baseToken, uint256 nftId);
    event LogWithdraw(address indexed user, address baseToken, uint256 nftId, address indexed to);
    event LogOnReward(address indexed user, address indexed baseToken, uint256 amount, address indexed to);
    event LogUpdatePool(address indexed baseToken, uint256 lastRewardTime, uint256 lpSupply, uint256 accToken1PerShare);
    event LogRewardPerSecond(address indexed baseToken, uint256 rewardPerSecond);
    event LogRewardPoolInitialized(address _baseToken, address _rewardToken, uint256 _rewardPerSecond);
    event LogNativeReceived(address indexed sender, uint256 value);

    function initialize(
        address _trustedForwarder,
        address _pauser,
        ILiquidityProviders _liquidityProviders,
        ILPToken _lpToken
    ) public initializer {
        __ERC2771Context_init(_trustedForwarder);
        __Ownable_init();
        __Pausable_init(_pauser);
        __ReentrancyGuard_init();
        liquidityProviders = _liquidityProviders;
        lpToken = _lpToken;
    }

    /// @notice Initialize the rewarder pool.
    /// @param _baseToken Base token to be used for the rewarder pool.
    /// @param _rewardToken Reward token to be used for the rewarder pool.
    /// @param _rewardPerSecond Reward rate per base token.
    function initalizeRewardPool(
        address _baseToken,
        address _rewardToken,
        uint256 _rewardPerSecond
    ) external onlyOwner {
        require(rewardTokens[_baseToken] == address(0), ""ERR__POOL_ALREADY_INITIALIZED"");
        require(_baseToken != address(0), ""ERR__BASE_TOKEN_IS_ZERO"");
        require(_rewardToken != address(0), ""ERR_REWARD_TOKEN_IS_ZERO"");
        rewardTokens[_baseToken] = _rewardToken;
        rewardRateLog[_baseToken].push(RewardsPerSecondEntry(_rewardPerSecond, block.timestamp));
        emit LogRewardPoolInitialized(_baseToken, _rewardToken, _rewardPerSecond);
    }

    function _sendErc20AndGetSentAmount(
        IERC20Upgradeable _token,
        uint256 _amount,
        address _to
    ) private returns (uint256) {
        uint256 recepientBalance = _token.balanceOf(_to);
        _token.safeTransfer(_to, _amount);
        return _token.balanceOf(_to) - recepientBalance;
    }

    /// @notice Update the reward state of a nft, and if possible send reward funds to _to.
    /// @param _nftId NFT ID that is being locked
    /// @param _to Address to which rewards will be credited.
    function _sendRewardsForNft(uint256 _nftId, address payable _to) internal {
        NFTInfo storage nft = nftInfo[_nftId];
        require(nft.isStaked, ""ERR__NFT_NOT_STAKED"");

        (address baseToken, , uint256 amount) = lpToken.tokenMetadata(_nftId);
        amount /= liquidityProviders.BASE_DIVISOR();

        PoolInfo memory pool = updatePool(baseToken);
        uint256 pending;
        uint256 amountSent;
        if (amount > 0) {
            pending = ((amount * pool.accTokenPerShare) / ACC_TOKEN_PRECISION) - nft.rewardDebt + nft.unpaidRewards;
            if (rewardTokens[baseToken] == NATIVE) {
                uint256 balance = address(this).balance;
                if (pending > balance) {
                    unchecked {
                        nft.unpaidRewards = pending - balance;
                    }
                    (bool success, ) = _to.call{value: balance}("""");
                    require(success, ""ERR__NATIVE_TRANSFER_FAILED"");
                    amountSent = balance;
                } else {
                    nft.unpaidRewards = 0;
                    (bool success, ) = _to.call{value: pending}("""");
                    require(success, ""ERR__NATIVE_TRANSFER_FAILED"");
                    amountSent = pending;
                }
            } else {
                IERC20Upgradeable rewardToken = IERC20Upgradeable(rewardTokens[baseToken]);
                uint256 balance = rewardToken.balanceOf(address(this));
                if (pending > balance) {
                    unchecked {
                        nft.unpaidRewards = pending - balance;
                    }
                    amountSent = _sendErc20AndGetSentAmount(rewardToken, balance, _to);
                } else {
                    nft.unpaidRewards = 0;
                    amountSent = _sendErc20AndGetSentAmount(rewardToken, pending, _to);
                }
            }
        }
        nft.rewardDebt = (amount * pool.accTokenPerShare) / ACC_TOKEN_PRECISION;
        emit LogOnReward(_msgSender(), baseToken, amountSent, _to);
    }

    /// @notice Sets the sushi per second to be distributed. Can only be called by the owner.
    /// @param _rewardPerSecond The amount of Sushi to be distributed per second.
    function setRewardPerSecond(address _baseToken, uint256 _rewardPerSecond) public onlyOwner {
        rewardRateLog[_baseToken].push(RewardsPerSecondEntry(_rewardPerSecond, block.timestamp));
        emit LogRewardPerSecond(_baseToken, _rewardPerSecond);
    }

    /// @notice Allows owner to reclaim/withdraw any tokens (including reward tokens) held by this contract
    /// @param _token Token to reclaim, use 0x00 for Ethereum
    /// @param _amount Amount of tokens to reclaim
    /// @param _to Receiver of the tokens, first of his name, rightful heir to the lost tokens,
    /// reightful owner of the extra tokens, and ether, protector of mistaken transfers, mother of token reclaimers,
    /// the Khaleesi of the Great Token Sea, the Unburnt, the Breaker of blockchains.
    function reclaimTokens(
        address _token,
        uint256 _amount,
        address payable _to
    ) external nonReentrant onlyOwner {
        require(_to != address(0), ""ERR__TO_IS_ZERO"");
        if (_token == NATIVE) {
            (bool success, ) = payable(_to).call{value: _amount}("""");
            require(success, ""ERR__NATIVE_TRANSFER_FAILED"");
        } else {
            IERC20Upgradeable(_token).safeTransfer(_to, _amount);
        }
    }

    /// @notice Deposit LP tokens
    /// @param _nftId LP token nftId to deposit.
    function deposit(uint256 _nftId, address payable _to) external whenNotPaused nonReentrant {
        address msgSender = _msgSender();

        require(
            lpToken.isApprovedForAll(msgSender, address(this)) || lpToken.getApproved(_nftId) == address(this),
            ""ERR__NOT_APPROVED""
        );

        (address baseToken, , uint256 amount) = lpToken.tokenMetadata(_nftId);
        amount /= liquidityProviders.BASE_DIVISOR();

        require(rewardTokens[baseToken] != address(0), ""ERR__POOL_NOT_INITIALIZED"");
        require(rewardRateLog[baseToken].length != 0, ""ERR__POOL_NOT_INITIALIZED"");

        NFTInfo storage nft = nftInfo[_nftId];
        require(!nft.isStaked, ""ERR__NFT_ALREADY_STAKED"");

        lpToken.safeTransferFrom(msgSender, address(this), _nftId);

        PoolInfo memory pool = updatePool(baseToken);
        nft.isStaked = true;
        nft.staker = _to;
        nft.rewardDebt = (amount * pool.accTokenPerShare) / ACC_TOKEN_PRECISION;

        nftIdsStaked[_to].push(_nftId);
        totalSharesStaked[baseToken] += amount;

        emit LogDeposit(msgSender, baseToken, _nftId);
    }

    /// @notice Withdraw LP tokens
    /// @param _nftId LP token nftId to withdraw.
    /// @param _to The receiver of `amount` withdraw benefit.
    function withdraw(uint256 _nftId, address payable _to) external whenNotPaused nonReentrant {
        address msgSender = _msgSender();
        uint256 nftsStakedLength = nftIdsStaked[msgSender].length;
        uint256 index;
        for (index = 0; index < nftsStakedLength; ++index) {
            if (nftIdsStaked[msgSender][index] == _nftId) {
                break;
            }
        }

        require(index != nftsStakedLength, ""ERR__NFT_NOT_STAKED"");
        nftIdsStaked[msgSender][index] = nftIdsStaked[msgSender][nftIdsStaked[msgSender].length - 1];
        nftIdsStaked[msgSender].pop();

        _sendRewardsForNft(_nftId, _to);
        delete nftInfo[_nftId];

        (address baseToken, , uint256 amount) = lpToken.tokenMetadata(_nftId);
        amount /= liquidityProviders.BASE_DIVISOR();
        totalSharesStaked[baseToken] -= amount;

        lpToken.safeTransferFrom(address(this), msgSender, _nftId);

        emit LogWithdraw(msgSender, baseToken, _nftId, _to);
    }

    /// @notice Extract all rewards without withdrawing LP tokens
    /// @param _nftId LP token nftId for which rewards are to be withdrawn
    /// @param _to The receiver of withdraw benefit.
    function extractRewards(uint256 _nftId, address payable _to) external whenNotPaused nonReentrant {
        require(nftInfo[_nftId].staker == _msgSender(), ""ERR__NOT_OWNER"");
        _sendRewardsForNft(_nftId, _to);
    }

    /// @notice Calculates an up to date value of accTokenPerShare
    /// @notice An updated value of accTokenPerShare is comitted to storage every time a new NFT is deposited, withdrawn or rewards are extracted
    function getUpdatedAccTokenPerShare(address _baseToken) public view returns (uint256) {
        uint256 accumulator = 0;
        uint256 lastUpdatedTime = poolInfo[_baseToken].lastRewardTime;
        uint256 counter = block.timestamp;
        uint256 i = rewardRateLog[_baseToken].length - 1;
        while (true) {
            if (lastUpdatedTime >= counter) {
                break;
            }
            unchecked {
                accumulator +=
                    rewardRateLog[_baseToken][i].rewardsPerSecond *
                    (counter - max(lastUpdatedTime, rewardRateLog[_baseToken][i].timestamp));
            }
            counter = rewardRateLog[_baseToken][i].timestamp;
            if (i == 0) {
                break;
            }
            --i;
        }

        // We know that during all the periods that were included in the current iterations,
        // the value of totalSharesStaked[_baseToken] would not have changed, as we only consider the
        // updates to the pool that happened after the lastUpdatedTime.
        accumulator = (accumulator * ACC_TOKEN_PRECISION) / totalSharesStaked[_baseToken];
        return accumulator + poolInfo[_baseToken].accTokenPerShare;
    }

    /// @notice View function to see pending Token
    /// @param _nftId NFT for which pending tokens are to be viewed
    /// @return pending reward for a given user.
    function pendingToken(uint256 _nftId) external view returns (uint256) {
        NFTInfo storage nft = nftInfo[_nftId];
        if (!nft.isStaked) {
            return 0;
        }

        (address baseToken, , uint256 amount) = lpToken.tokenMetadata(_nftId);
        amount /= liquidityProviders.BASE_DIVISOR();

        PoolInfo memory pool = poolInfo[baseToken];
        uint256 accToken1PerShare = pool.accTokenPerShare;
        if (block.timestamp > pool.lastRewardTime && totalSharesStaked[baseToken] != 0) {
            accToken1PerShare = getUpdatedAccTokenPerShare(baseToken);
        }
        return ((amount * accToken1PerShare) / ACC_TOKEN_PRECISION) - nft.rewardDebt + nft.unpaidRewards;
    }

    /// @notice Update reward variables of the given pool.
    /// @return pool Returns the pool that was updated.
    function updatePool(address _baseToken) public whenNotPaused returns (PoolInfo memory pool) {
        pool = poolInfo[_baseToken];
        if (block.timestamp > pool.lastRewardTime) {
            if (totalSharesStaked[_baseToken] > 0) {
                pool.accTokenPerShare = getUpdatedAccTokenPerShare(_baseToken);
            }
            pool.lastRewardTime = block.timestamp;
            poolInfo[_baseToken] = pool;
            emit LogUpdatePool(_baseToken, pool.lastRewardTime, totalSharesStaked[_baseToken], pool.accTokenPerShare);
        }
    }

    /// @notice View function to see the tokens staked by a given user.
    /// @param _user Address of user.
    function getNftIdsStaked(address _user) public view returns (uint256[] memory nftIds) {
        nftIds = nftIdsStaked[_user];
    }

    function getRewardRatePerSecond(address _baseToken) public view returns (uint256) {
        return rewardRateLog[_baseToken][rewardRateLog[_baseToken].length - 1].rewardsPerSecond;
    }

    function onERC721Received(
        address,
        address,
        uint256,
        bytes calldata
    ) external pure override(IERC721ReceiverUpgradeable) returns (bytes4) {
        return bytes4(keccak256(""onERC721Received(address,address,uint256,bytes)""));
    }

    function _msgSender()
        internal
        view
        virtual
        override(ContextUpgradeable, ERC2771ContextUpgradeable)
        returns (address sender)
    {
        return ERC2771ContextUpgradeable._msgSender();
    }

    function _msgData()
        internal
        view
        virtual
        override(ContextUpgradeable, ERC2771ContextUpgradeable)
        returns (bytes calldata)
    {
        return ERC2771ContextUpgradeable._msgData();
    }

    receive() external payable {
        emit LogNativeReceived(_msgSender(), msg.value);
    }

    function max(uint256 _a, uint256 _b) private pure returns (uint256) {
        return _a >= _b ? _a : _b;
    }
}",3691
RealWorld_BA_97_Avalanche.USDT_RealWord_20240826210750.log,97,Avalanche.USDT,80864,5812,86676,125.0,0.52056,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.0;

import ""../SvgHelperBase.sol"";

contract AvalancheUSDT is SvgHelperBase {
    using Strings for uint256;

    constructor(uint256 _decimals) SvgHelperBase(_decimals) {}

    function getTokenSvg(
        uint256 _tokenId,
        uint256 _suppliedLiquidity,
        uint256 _totalSuppliedLiquidity
    ) public view virtual override returns (string memory) {
        string memory tokenId = _tokenId.toString();
        string memory suppliedLiquidity = _divideByPowerOf10(_suppliedLiquidity, tokenDecimals, 3);
        string memory sharePercent = _calculatePercentage(_suppliedLiquidity, _totalSuppliedLiquidity);
        return
            string(
                abi.encodePacked(
                    '<svg version=""1.1"" id=""prefix__Layer_1"" xmlns=""http://www.w3.org/2000/svg"" x=""0"" y=""0"" viewBox=""0 0 405 405"" xml:space=""preserve""><style>.prefix__st2{fill:#fff}.prefix__st28{font-family:&apos;Courier&apos;}.prefix__st29{font-size:24px}</style><radialGradient id=""prefix__SVGID_1_"" cx=""2.777"" cy=""-505"" r=""1"" gradientTransform=""matrix(0 327.499 327.499 0 165589.5 -909.476)"" gradientUnits=""userSpaceOnUse""><stop offset=""0"" stop-color=""#e84142""/><stop offset=""1""/></radialGradient><path d=""M30 0h345c16.57 0 30 13.43 30 30v345c0 16.57-13.43 30-30 30H30c-16.57 0-30-13.43-30-30V30C0 13.43 13.43 0 30 0z"" fill=""url(#prefix__SVGID_1_)""/><radialGradient id=""prefix__SVGID_00000096046149083906169040000006838268896560026277_"" cx=""3.356"" cy=""-505"" r=""1"" gradientTransform=""matrix(0 270.995 167.538 0 84809.203 -831.976)"" gradientUnits=""userSpaceOnUse""><stop offset=""0"" stop-color=""#fff""/><stop offset="".711"" stop-color=""#50af95""/><stop offset=""1"" stop-opacity=""0""/><stop offset=""1"" stop-opacity=""0""/></radialGradient><path d=""M214.93 95.88c-5.94-8.8-18.93-8.8-24.87 0-43.56 64.49-70.9 107.33-70.9 149.07 0 45.6 37.28 82.55 83.33 82.55s83.33-36.95 83.33-82.55c.01-41.74-27.33-84.58-70.89-149.07z"" fill=""url(#prefix__SVGID_00000096046149083906169040000006838268896560026277_)""/><path class=""prefix__st2"" d=""M271.41 338.62a.8.8 0 00-.59-.24h-1.66a.8.8 0 00-.59.24.8.8 0 00-.24.59v5c0 .11-.02.22-.06.32-.04.1-.1.2-.18.27a.8.8 0 01-.59.24h-8.33c-.11 0-.22-.02-.32-.06s-.2-.1-.27-.18-.14-.17-.18-.27a.866.866 0 01-.06-.32v-5a.8.8 0 00-.24-.59.8.8 0 00-.59-.24h-1.67c-.22 0-.43.09-.59.24s-.24.37-.24.59v15a.8.8 0 00.24.59.8.8 0 00.59.24h1.67a.8.8 0 00.59-.24.8.8 0 00.24-.59v-5a.8.8 0 01.24-.59.8.8 0 01.59-.24h8.33a.8.8 0 01.59.24.8.8 0 01.24.59v5c0 .11.02.22.06.32.04.1.1.2.18.27s.17.14.27.18.21.06.32.06h1.66c.11 0 .22-.02.32-.06.1-.04.2-.1.27-.18s.14-.17.18-.27c.04-.1.06-.21.06-.32v-15c0-.11-.02-.22-.06-.32-.04-.11-.1-.2-.18-.27zM321.41 341.91a.8.8 0 00-.59-.24h-5.83v.04h-2.5a.8.8 0 01-.59-.24.8.8 0 01-.24-.59v-5a.8.8 0 00-.24-.59.8.8 0 00-.59-.24h-1.66c-.11 0-.22.02-.32.06-.1.04-.2.1-.27.18a.8.8 0 00-.24.59v18.33c0 .11.02.22.06.32.04.1.1.2.18.27a.8.8 0 00.59.24h1.66c.11 0 .22-.02.32-.06.1-.04.2-.1.27-.18a.8.8 0 00.24-.59v-8.33a.8.8 0 01.24-.59.8.8 0 01.59-.24h5a.8.8 0 01.59.24.8.8 0 01.24.59v8.33c0 .11.02.22.06.32.04.1.1.2.18.27a.8.8 0 00.59.24h1.66c.11 0 .22-.02.32-.06.1-.04.2-.1.27-.18a.8.8 0 00.24-.59v-11.7c0-.11-.02-.22-.06-.32a.624.624 0 00-.17-.28zM338.08 341.91a.8.8 0 00-.59-.24h-11.67c-.11 0-.22.02-.32.06a.98.98 0 00-.27.18.8.8 0 00-.24.59v11.66a.8.8 0 00.24.59.8.8 0 00.59.24h11.67a.8.8 0 00.59-.24.8.8 0 00.24-.59v-1.66c0-.11-.02-.22-.06-.32-.04-.1-.1-.2-.18-.27a.8.8 0 00-.59-.24h-8.33c-.22 0-.43-.09-.59-.24-.16-.16-.24-.37-.24-.59s.09-.43.24-.59c.16-.16.37-.24.59-.24h8.33a.8.8 0 00.59-.24.8.8 0 00.24-.59v-6.66c0-.11-.02-.22-.06-.32a.841.841 0 00-.18-.29zm-3.16 4.24a.8.8 0 01-.18.27.8.8 0 01-.59.24h-5a.8.8 0 01-.59-.24.8.8 0 01-.24-.59.8.8 0 01.24-.59.8.8 0 01.59-.24h5a.8.8 0 01.59.24.8.8 0 01.24.59c0 .11-.02.22-.06.32zM354.74 341.91a.8.8 0 00-.59-.24l-2.5.04h-9.17a.8.8 0 00-.59.24.8.8 0 00-.24.59v11.66c0 .11.02.22.06.32.04.1.1.2.18.27a.8.8 0 00.59.24h1.67a.8.8 0 00.59-.24.8.8 0 00.24-.59v-8.33a.8.8 0 01.24-.59.8.8 0 01.59-.24h5c.11 0 .22.02.32.06.1.04.2.1.27.18a.8.8 0 01.24.59v8.33c0 .11.02.22.06.32.04.1.1.2.18.27a.8.8 0 00.59.24h1.67a.8.8 0 00.59-.24.8.8 0 00.24-.59v-11.7c0-.11-.02-.22-.06-.32a.65.65 0 00-.17-.27zM288.08 341.91a.8.8 0 00-.59-.24h-1.67c-.11 0-.22.02-.32.06a.98.98 0 00-.27.18.8.8 0 00-.24.59v8.33a.8.8 0 01-.24.59.8.8 0 01-.59.24h-5c-.11 0-.22-.02-.32-.06-.1-.04-.2-.1-.27-.18a.8.8 0 01-.24-.59v-8.33c0-.11-.02-.22-.06-.32-.04-.1-.1-.2-.18-.27a.8.8 0 00-.59-.24h-1.67c-.11 0-.22.02-.32.06a.98.98 0 00-.27.18.8.8 0 00-.24.59v11.66a.8.8 0 00.24.59.8.8 0 00.59.24h8.34c.22 0 .43.09.59.24.16.16.24.37.24.59s-.09.43-.24.59c-.16.16-.37.24-.59.24h-5c-.11 0-.22.02-.32.06s-.2.1-.27.18-.14.17-.18.27c-.04.1-.06.21-.06.32v1.66c0 .11.02.22.06.32.04.1.1.2.18.27s.17.14.27.18.21.06.32.06h8.33a.8.8 0 00.59-.24.8.8 0 00.24-.59v-16.66c0-.11-.02-.22-.06-.32-.05-.08-.12-.17-.19-.25zM304.74 341.91a.8.8 0 00-.59-.24h-11.67a.8.8 0 00-.59.24.8.8 0 00-.24.59v16.66c0 .11.02.22.06.32.04.1.1.2.18.27a.8.8 0 00.59.24h1.67a.8.8 0 00.59-.24.8.8 0 00.24-.59v-3.33a.8.8 0 01.24-.59.8.8 0 01.59-.24h8.34a.8.8 0 00.59-.24.8.8 0 00.24-.59v-11.66a.866.866 0 00-.24-.6zm-3.09 8.93a.8.8 0 01-.52.77c-.1.04-.21.06-.32.06h-5a.8.8 0 01-.59-.24.8.8 0 01-.24-.59v-5a.8.8 0 01.24-.59.8.8 0 01.59-.24h5a.866.866 0 01.6.24.8.8 0 01.24.59v5zM329.97 96.59c.28 0 .57-.05.83-.16s.5-.27.7-.47a2.116 2.116 0 00.63-1.53V81.49a2.182 2.182 0 00-.62-1.52 2.105 2.105 0 00-1.52-.63h-4.31c-.57 0-1.12.23-1.52.63-.4.4-.63.95-.63 1.52v4.31c0 .28-.05.57-.16.83s-.27.5-.47.7a2.116 2.116 0 01-1.53.63h-4.31c-.28 0-.57-.05-.83-.16s-.5-.27-.7-.47a2.116 2.116 0 01-.63-1.53V64.24c0-.28.05-.57.16-.83s.27-.5.47-.7a2.116 2.116 0 011.53-.63h1.25c.42 0 .84-.12 1.2-.36.35-.24.63-.57.79-.97a2.138 2.138 0 00-.49-2.33l-7.68-7.76c-.2-.21-.44-.37-.7-.48a2.124 2.124 0 00-1.66 0c-.26.11-.5.27-.7.48l-7.72 7.76c-.3.3-.51.68-.59 1.09s-.04.85.12 1.24.43.73.78.96c.35.24.76.37 1.19.37h1.25c.29 0 .57.05.83.16s.5.27.7.47c.2.2.36.44.47.7.11.26.16.55.16.83v30.2c0 .28.05.57.16.83s.27.5.47.7a2.116 2.116 0 001.53.63h21.55z""/><path class=""prefix__st2"" d=""M324.14 70.08a2.116 2.116 0 001.53.63h4.31c.28 0 .57-.05.83-.16s.5-.27.7-.47a2.116 2.116 0 00.63-1.53v-4.31c0-.28.05-.57.16-.83s.27-.5.47-.7a2.116 2.116 0 011.53-.63h4.32c.28 0 .57.05.83.16s.5.27.7.47c.2.2.36.44.47.7.11.26.16.55.16.83v21.57c0 .28-.05.57-.16.83s-.27.5-.47.7a2.116 2.116 0 01-1.53.63h-1.26c-.42 0-.84.13-1.2.36-.35.24-.63.57-.79.97-.16.39-.2.83-.11 1.24.09.42.3.8.6 1.1l7.73 7.72c.2.2.44.37.7.48a2.124 2.124 0 002.36-.48l7.72-7.72c.3-.3.5-.69.58-1.1.08-.42.04-.85-.12-1.24a2.12 2.12 0 00-.79-.96c-.35-.24-.77-.36-1.19-.36h-1.29c-.28 0-.57-.05-.83-.16s-.5-.27-.7-.47a2.116 2.116 0 01-.63-1.53V55.6c0-.28-.05-.57-.16-.83s-.27-.5-.47-.7c-.2-.2-.44-.36-.7-.47-.26-.11-.55-.16-.83-.16h-21.57c-.28 0-.57.05-.83.16s-.5.27-.7.47a2.116 2.116 0 00-.63 1.53v12.95c0 .28.05.57.16.83s.27.5.47.7z""/><text transform=""translate(73.686 67)"" class=""prefix__st2 prefix__st28 prefix__st29"">',
                    suppliedLiquidity,
                    ' USDT</text><text transform=""rotate(-90 213.61 143.092)"" class=""prefix__st2 prefix__st28 prefix__st29"">',
                    sharePercent,
                    '%</text><path fill=""none"" stroke=""#fff"" stroke-miterlimit=""10"" d=""M61.86 267.12V114.71""/><text transform=""translate(79.915 355)"" class=""prefix__st2 prefix__st28"" font-size=""10"">ID: ',
                    tokenId,
                    '</text><g fill-rule=""evenodd"" clip-rule=""evenodd""><path d=""M54.8 51.18l-3.1 6.51a.14.14 0 00.03.15l8.37 8.02c.05.05.13.05.18 0l8.37-8.02c.04-.04.05-.1.03-.15l-3.1-6.51a.136.136 0 00-.11-.07H54.91c-.05-.01-.09.02-.11.07z"" fill=""#50af95""/><path d=""M61.26 58.36c-.06 0-.37.02-1.06.02-.55 0-.94-.02-1.08-.02-2.13-.09-3.72-.46-3.72-.91 0-.44 1.59-.81 3.72-.91v1.45c.14.01.54.03 1.09.03.66 0 .99-.03 1.05-.03v-1.45c2.12.09 3.71.47 3.71.91s-1.59.81-3.71.91zm0-1.97v-1.3h2.97v-1.98h-8.07v1.98h2.96v1.3c-2.41.11-4.22.59-4.22 1.16s1.81 1.05 4.22 1.16v4.15h2.14v-4.15c2.4-.11 4.21-.59 4.21-1.16s-1.8-1.05-4.21-1.16zm0 0"" fill=""#fff""/></g><g><path d=""M142.44 77.23H56.69c-2.76 0-5 2.24-5 5v7.47c0 2.76 2.24 5 5 5h85.75c2.76 0 5-2.24 5-5v-7.47c0-2.76-2.24-5-5-5z"" fill=""#e84142""/><text transform=""translate(56.685 89.706)"" class=""prefix__st2"" font-size=""12"" font-family=""Courier-Bold"">ON AVALANCHE</text></g></svg>'
                )
            );
    }

    function getChainName() public pure override returns (string memory) {
        return ""Avalanche"";
    }
}",4785
RealWorld_BA_97_Ethereum.BICO_RealWord_20240826211945.log,97,Ethereum.BICO,82683,5133,87816,96.0,0.516075,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.0;

import ""../SvgHelperBase.sol"";

contract EthereumBICO is SvgHelperBase {
    using Strings for uint256;

    constructor(uint256 _decimals) SvgHelperBase(_decimals) {}

    function getTokenSvg(
        uint256 _tokenId,
        uint256 _suppliedLiquidity,
        uint256 _totalSuppliedLiquidity
    ) public view virtual override returns (string memory) {
        string memory tokenId = _tokenId.toString();
        string memory suppliedLiquidity = _divideByPowerOf10(_suppliedLiquidity, tokenDecimals, 3);
        string memory sharePercent = _calculatePercentage(_suppliedLiquidity, _totalSuppliedLiquidity);
        return
            string(
                abi.encodePacked(
                    '<svg version=""1.1"" id=""prefix__Layer_1"" xmlns=""http://www.w3.org/2000/svg"" x=""0"" y=""0"" viewBox=""0 0 405 405"" xml:space=""preserve""><style>.prefix__st2{fill:#fff}.prefix__st9{font-family:&apos;Courier&apos;}.prefix__st10{font-size:24px}</style><radialGradient id=""prefix__SVGID_1_"" cx=""454.998"" cy=""403.611"" r=""1"" gradientTransform=""scale(327.499 -327.499) rotate(-90 26.003 428.995)"" gradientUnits=""userSpaceOnUse""><stop offset=""0"" stop-color=""#8c8c8c""/><stop offset=""1""/></radialGradient><path d=""M30 0h345c16.57 0 30 13.43 30 30v345c0 16.57-13.43 30-30 30H30c-16.57 0-30-13.43-30-30V30C0 13.43 13.43 0 30 0z"" fill=""url(#prefix__SVGID_1_)""/><radialGradient id=""prefix__SVGID_00000149348912856748424340000004453863865774411953_"" cx=""454.998"" cy=""402.284"" r=""1"" gradientTransform=""matrix(0 270.995 167.538 0 -67195.375 -123224.695)"" gradientUnits=""userSpaceOnUse""><stop offset=""0"" stop-color=""#fff""/><stop offset="".711"" stop-color=""#d85111""/><stop offset=""1"" stop-opacity=""0""/><stop offset=""1"" stop-opacity=""0""/></radialGradient><path d=""M214.93 95.88c-5.94-8.8-18.93-8.8-24.87 0-43.56 64.49-70.9 107.33-70.9 149.07 0 45.6 37.28 82.55 83.33 82.55s83.33-36.95 83.33-82.55c.01-41.74-27.33-84.58-70.89-149.07z"" fill=""url(#prefix__SVGID_00000149348912856748424340000004453863865774411953_)""/><path class=""prefix__st2"" d=""M271.41 338.62a.8.8 0 00-.59-.24h-1.66a.8.8 0 00-.59.24.8.8 0 00-.24.59v5c0 .11-.02.22-.06.32-.04.1-.1.2-.18.27a.8.8 0 01-.59.24h-8.33c-.11 0-.22-.02-.32-.06s-.2-.1-.27-.18-.14-.17-.18-.27a.866.866 0 01-.06-.32v-5a.8.8 0 00-.24-.59.8.8 0 00-.59-.24h-1.67c-.22 0-.43.09-.59.24s-.24.37-.24.59v15a.8.8 0 00.24.59.8.8 0 00.59.24h1.67a.8.8 0 00.59-.24.8.8 0 00.24-.59v-5a.8.8 0 01.24-.59.8.8 0 01.59-.24h8.33a.8.8 0 01.59.24.8.8 0 01.24.59v5c0 .11.02.22.06.32.04.1.1.2.18.27s.17.14.27.18.21.06.32.06h1.66c.11 0 .22-.02.32-.06.1-.04.2-.1.27-.18s.14-.17.18-.27c.04-.1.06-.21.06-.32v-15c0-.11-.02-.22-.06-.32-.04-.11-.1-.2-.18-.27zM321.41 341.91a.8.8 0 00-.59-.24h-5.83v.04h-2.5a.8.8 0 01-.59-.24.8.8 0 01-.24-.59v-5a.8.8 0 00-.24-.59.8.8 0 00-.59-.24h-1.66c-.11 0-.22.02-.32.06-.1.04-.2.1-.27.18a.8.8 0 00-.24.59v18.33c0 .11.02.22.06.32.04.1.1.2.18.27a.8.8 0 00.59.24h1.66c.11 0 .22-.02.32-.06.1-.04.2-.1.27-.18a.8.8 0 00.24-.59v-8.33a.8.8 0 01.24-.59.8.8 0 01.59-.24h5a.8.8 0 01.59.24.8.8 0 01.24.59v8.33c0 .11.02.22.06.32.04.1.1.2.18.27a.8.8 0 00.59.24h1.66c.11 0 .22-.02.32-.06.1-.04.2-.1.27-.18a.8.8 0 00.24-.59v-11.7c0-.11-.02-.22-.06-.32a.624.624 0 00-.17-.28zM338.08 341.91a.8.8 0 00-.59-.24h-11.67c-.11 0-.22.02-.32.06a.98.98 0 00-.27.18.8.8 0 00-.24.59v11.66a.8.8 0 00.24.59.8.8 0 00.59.24h11.67a.8.8 0 00.59-.24.8.8 0 00.24-.59v-1.66c0-.11-.02-.22-.06-.32-.04-.1-.1-.2-.18-.27a.8.8 0 00-.59-.24h-8.33c-.22 0-.43-.09-.59-.24-.16-.16-.24-.37-.24-.59s.09-.43.24-.59c.16-.16.37-.24.59-.24h8.33a.8.8 0 00.59-.24.8.8 0 00.24-.59v-6.66c0-.11-.02-.22-.06-.32a.841.841 0 00-.18-.29zm-3.16 4.24a.8.8 0 01-.18.27.8.8 0 01-.59.24h-5a.8.8 0 01-.59-.24.8.8 0 01-.24-.59.8.8 0 01.24-.59.8.8 0 01.59-.24h5a.8.8 0 01.59.24.8.8 0 01.24.59c0 .11-.02.22-.06.32zM354.74 341.91a.8.8 0 00-.59-.24l-2.5.04h-9.17a.8.8 0 00-.59.24.8.8 0 00-.24.59v11.66c0 .11.02.22.06.32.04.1.1.2.18.27a.8.8 0 00.59.24h1.67a.8.8 0 00.59-.24.8.8 0 00.24-.59v-8.33a.8.8 0 01.24-.59.8.8 0 01.59-.24h5c.11 0 .22.02.32.06.1.04.2.1.27.18a.8.8 0 01.24.59v8.33c0 .11.02.22.06.32.04.1.1.2.18.27a.8.8 0 00.59.24h1.67a.8.8 0 00.59-.24.8.8 0 00.24-.59v-11.7c0-.11-.02-.22-.06-.32a.65.65 0 00-.17-.27zM288.08 341.91a.8.8 0 00-.59-.24h-1.67c-.11 0-.22.02-.32.06a.98.98 0 00-.27.18.8.8 0 00-.24.59v8.33a.8.8 0 01-.24.59.8.8 0 01-.59.24h-5c-.11 0-.22-.02-.32-.06-.1-.04-.2-.1-.27-.18a.8.8 0 01-.24-.59v-8.33c0-.11-.02-.22-.06-.32-.04-.1-.1-.2-.18-.27a.8.8 0 00-.59-.24h-1.67c-.11 0-.22.02-.32.06a.98.98 0 00-.27.18.8.8 0 00-.24.59v11.66a.8.8 0 00.24.59.8.8 0 00.59.24h8.34c.22 0 .43.09.59.24.16.16.24.37.24.59s-.09.43-.24.59c-.16.16-.37.24-.59.24h-5c-.11 0-.22.02-.32.06s-.2.1-.27.18-.14.17-.18.27c-.04.1-.06.21-.06.32v1.66c0 .11.02.22.06.32.04.1.1.2.18.27s.17.14.27.18.21.06.32.06h8.33a.8.8 0 00.59-.24.8.8 0 00.24-.59v-16.66c0-.11-.02-.22-.06-.32-.05-.08-.12-.17-.19-.25zM304.74 341.91a.8.8 0 00-.59-.24h-11.67a.8.8 0 00-.59.24.8.8 0 00-.24.59v16.66c0 .11.02.22.06.32.04.1.1.2.18.27a.8.8 0 00.59.24h1.67a.8.8 0 00.59-.24.8.8 0 00.24-.59v-3.33a.8.8 0 01.24-.59.8.8 0 01.59-.24h8.34a.8.8 0 00.59-.24.8.8 0 00.24-.59v-11.66a.866.866 0 00-.24-.6zm-3.09 8.93a.8.8 0 01-.52.77c-.1.04-.21.06-.32.06h-5a.8.8 0 01-.59-.24.8.8 0 01-.24-.59v-5a.8.8 0 01.24-.59.8.8 0 01.59-.24h5a.866.866 0 01.6.24.8.8 0 01.24.59v5zM329.97 96.59c.28 0 .57-.05.83-.16s.5-.27.7-.47a2.116 2.116 0 00.63-1.53V81.49a2.182 2.182 0 00-.62-1.52 2.105 2.105 0 00-1.52-.63h-4.31c-.57 0-1.12.23-1.52.63-.4.4-.63.95-.63 1.52v4.31c0 .28-.05.57-.16.83s-.27.5-.47.7a2.116 2.116 0 01-1.53.63h-4.31c-.28 0-.57-.05-.83-.16s-.5-.27-.7-.47a2.116 2.116 0 01-.63-1.53V64.24c0-.28.05-.57.16-.83s.27-.5.47-.7a2.116 2.116 0 011.53-.63h1.25c.42 0 .84-.12 1.2-.36.35-.24.63-.57.79-.97a2.138 2.138 0 00-.49-2.33l-7.68-7.76c-.2-.21-.44-.37-.7-.48a2.124 2.124 0 00-1.66 0c-.26.11-.5.27-.7.48l-7.72 7.76c-.3.3-.51.68-.59 1.09s-.04.85.12 1.24.43.73.78.96c.35.24.76.37 1.19.37h1.25c.29 0 .57.05.83.16s.5.27.7.47c.2.2.36.44.47.7.11.26.16.55.16.83v30.2c0 .28.05.57.16.83s.27.5.47.7a2.116 2.116 0 001.53.63h21.55z""/><path class=""prefix__st2"" d=""M324.14 70.08a2.116 2.116 0 001.53.63h4.31c.28 0 .57-.05.83-.16s.5-.27.7-.47a2.116 2.116 0 00.63-1.53v-4.31c0-.28.05-.57.16-.83s.27-.5.47-.7a2.116 2.116 0 011.53-.63h4.32c.28 0 .57.05.83.16s.5.27.7.47c.2.2.36.44.47.7.11.26.16.55.16.83v21.57c0 .28-.05.57-.16.83s-.27.5-.47.7a2.116 2.116 0 01-1.53.63h-1.26c-.42 0-.84.13-1.2.36-.35.24-.63.57-.79.97-.16.39-.2.83-.11 1.24.09.42.3.8.6 1.1l7.73 7.72c.2.2.44.37.7.48a2.124 2.124 0 002.36-.48l7.72-7.72c.3-.3.5-.69.58-1.1.08-.42.04-.85-.12-1.24a2.12 2.12 0 00-.79-.96c-.35-.24-.77-.36-1.19-.36h-1.29c-.28 0-.57-.05-.83-.16s-.5-.27-.7-.47a2.116 2.116 0 01-.63-1.53V55.6c0-.28-.05-.57-.16-.83s-.27-.5-.47-.7c-.2-.2-.44-.36-.7-.47-.26-.11-.55-.16-.83-.16h-21.57c-.28 0-.57.05-.83.16s-.5.27-.7.47a2.116 2.116 0 00-.63 1.53v12.95c0 .28.05.57.16.83s.27.5.47.7z""/><text transform=""translate(73.686 67)"" class=""prefix__st2 prefix__st9 prefix__st10"">',
                    suppliedLiquidity,
                    ' BICO</text><text transform=""rotate(-90 213.61 143.092)"" class=""prefix__st2 prefix__st9 prefix__st10"">',
                    sharePercent,
                    '%</text><path fill=""none"" stroke=""#fff"" stroke-miterlimit=""10"" d=""M61.86 267.12V114.71""/><text transform=""translate(79.915 355)"" class=""prefix__st2 prefix__st9"" font-size=""10"">ID: ',
                    tokenId,
                    '</text><g><path d=""M136.03 77.23H56.69c-2.76 0-5 2.24-5 5v7.47c0 2.76 2.24 5 5 5h79.34c2.76 0 5-2.24 5-5v-7.47c0-2.76-2.24-5-5-5z"" fill=""#8c8c8c""/><text transform=""translate(56.685 89.706)"" class=""prefix__st2"" font-size=""12"" font-family=""Courier-Bold"">ON ETHEREUM</text></g><g><circle cx=""60.19"" cy=""58.5"" r=""8.5""/><linearGradient id=""prefix__SVGID_00000121240735984433054910000011952518464616340407_"" gradientUnits=""userSpaceOnUse"" x1=""58.709"" y1=""66.872"" x2=""61.662"" y2=""50.128""><stop offset=""0"" stop-color=""#fff""/><stop offset=""1"" stop-color=""#fff""/></linearGradient><path d=""M60.19 50.75c4.27 0 7.75 3.48 7.75 7.75s-3.48 7.75-7.75 7.75-7.75-3.48-7.75-7.75 3.47-7.75 7.75-7.75m0-.75c-4.69 0-8.5 3.81-8.5 8.5s3.81 8.5 8.5 8.5 8.5-3.81 8.5-8.5-3.81-8.5-8.5-8.5z"" fill=""url(#prefix__SVGID_00000121240735984433054910000011952518464616340407_)""/><g><path d=""M61.53 54.53c-.31-.18-.68-.28-1.06-.28h-2.12c.59 0 1.06.48 1.06 1.06v3.19h1.06c.39 0 .75-.1 1.06-.29.23-.13.44-.31.6-.52.29-.36.46-.82.46-1.32 0-.78-.42-1.47-1.06-1.84z"" fill=""#d85111""/><path class=""prefix__st2"" d=""M62.14 57.69a2.131 2.131 0 01-1.66.81h-1.06v-3.19a1.06 1.06 0 00-2.12 0V62.75H61c.18 0 .36-.02.53-.05a2.66 2.66 0 002.12-2.6c.01-1.07-.62-1.98-1.51-2.41z""/></g></g></svg>'
                )
            );
    }

    function getChainName() public pure override returns (string memory) {
        return ""Ethereum"";
    }
}",4932
RealWorld_BA_97_LpTokenMetadata_RealWord_20240826212259.log,97,LpTokenMetadata,3660,4942,8602,77.0,0.11714,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.0;

struct LpTokenMetadata {
    address token;
    uint256 suppliedLiquidity;
    uint256 shares;
}",40
RealWorld_BA_97_ERC20Token_RealWord_20240826214048.log,97,ERC20Token,4879,4818,9697,98.0,0.120755,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.0;

import ""@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol"";

contract ERC20Token is ERC20Upgradeable {
  function initialize(string memory _name, string memory _symbol)
    public
    initializer
  {
    __ERC20_init(_name, _symbol);
  }

  function mint(address _to, uint256 _amount) external {
    _mint(_to, _amount);
  }
}",107
RealWorld_BA_97_imports_RealWord_20240826214354.log,97,imports,3307,5139,8446,95.0,0.119315,"// SPDX-License-Identifier: MIT
pragma solidity >=0.6.2;

import ""@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol"";",38
RealWorld_BA_97_LiquidityPoolProxy_RealWord_20240826212123.log,97,LiquidityPoolProxy,10099,4295,14394,94.0,0.136395,"// contracts/bico-token/bico/BicoToken.sol

// SPDX-License-Identifier: MIT
pragma solidity 0.8.2;

import ""@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol"";

/**
 * @dev This contract implements a proxy that is upgradeable by an admin.
 *
 * To avoid https://medium.com/nomic-labs-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357[proxy selector
 * clashing], which can potentially be used in an attack, this contract uses the
 * https://blog.openzeppelin.com/the-transparent-proxy-pattern/[transparent proxy pattern]. This pattern implies two
 * things that go hand in hand:
 *
 * 1. If any account other than the admin calls the proxy, the call will be forwarded to the implementation, even if
 * that call matches one of the admin functions exposed by the proxy itself.
 * 2. If the admin calls the proxy, it can access the admin functions, but its calls will never be forwarded to the
 * implementation. If the admin tries to call a function on the implementation it will fail with an error that says
 * ""admin cannot fallback to proxy target"".
 *
 * These properties mean that the admin account can only be used for admin actions like upgrading the proxy or changing
 * the admin, so it's best if it's a dedicated account that is not used for anything else. This will avoid headaches due
 * to sudden errors when trying to call a function from the proxy implementation.
 *
 * Our recommendation is for the dedicated account to be an instance of the {ProxyAdmin} contract. If set up this way,
 * you should think of the `ProxyAdmin` instance as the real administrative interface of your proxy.
 */
contract LiquidityPoolProxy is TransparentUpgradeableProxy {
    constructor(address _implementation, address _admin)
        TransparentUpgradeableProxy(_implementation, _admin, bytes(""""))
    {}

    function getAdmin() external view returns (address adm) {
        adm = _admin();
    }

    function getImplementation() external view returns (address impl) {
        impl = _implementation();
    }
}",440
RealWorld_BA_97_IExecutorManager_RealWord_20240826212839.log,97,IExecutorManager,5242,5285,10527,107.0,0.13191,"// SPDX-License-Identifier: MIT

pragma solidity 0.8.0;

interface IExecutorManager {
    function getExecutorStatus(address executor) external view returns (bool status);

    function getAllExecutors() external view returns (address[] memory);

    //Register new Executors
    function addExecutors(address[] calldata executorArray) external;

    // Register single executor
    function addExecutor(address executorAddress) external;

    //Remove registered Executors
    function removeExecutors(address[] calldata executorArray) external;

    // Remove Register single executor
    function removeExecutor(address executorAddress) external;
}",124
RealWorld_BA_97_Ethereum.USDT_RealWord_20240826211459.log,97,Ethereum.USDT,80269,5078,85347,93.0,0.502905,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.0;

import ""../SvgHelperBase.sol"";

contract EthereumUSDT is SvgHelperBase {
    using Strings for uint256;

    constructor(uint256 _decimals) SvgHelperBase(_decimals) {}

    function getTokenSvg(
        uint256 _tokenId,
        uint256 _suppliedLiquidity,
        uint256 _totalSuppliedLiquidity
    ) public view virtual override returns (string memory) {
        string memory tokenId = _tokenId.toString();
        string memory suppliedLiquidity = _divideByPowerOf10(_suppliedLiquidity, tokenDecimals, 3);
        string memory sharePercent = _calculatePercentage(_suppliedLiquidity, _totalSuppliedLiquidity);
        return
            string(
                abi.encodePacked(
                    '<svg version=""1.1"" id=""prefix__Layer_1"" xmlns=""http://www.w3.org/2000/svg"" x=""0"" y=""0"" viewBox=""0 0 405 405"" xml:space=""preserve""><style>.prefix__st2{fill:#fff}.prefix__st28{font-family:&apos;Courier&apos;}.prefix__st29{font-size:24px}</style><radialGradient id=""prefix__SVGID_1_"" cx=""-455.002"" cy=""406.389"" r=""1"" gradientTransform=""matrix(0 327.499 327.499 0 -132889.578 149012.563)"" gradientUnits=""userSpaceOnUse""><stop offset=""0"" stop-color=""#8c8c8c""/><stop offset=""1""/></radialGradient><path d=""M30 0h345c16.57 0 30 13.43 30 30v345c0 16.57-13.43 30-30 30H30c-16.57 0-30-13.43-30-30V30C0 13.43 13.43 0 30 0z"" fill=""url(#prefix__SVGID_1_)""/><radialGradient id=""prefix__SVGID_00000096046149083906169040000006838268896560026277_"" cx=""3.356"" cy=""-505"" r=""1"" gradientTransform=""matrix(0 270.995 167.538 0 84809.203 -831.976)"" gradientUnits=""userSpaceOnUse""><stop offset=""0"" stop-color=""#fff""/><stop offset="".711"" stop-color=""#50af95""/><stop offset=""1"" stop-opacity=""0""/><stop offset=""1"" stop-opacity=""0""/></radialGradient><path d=""M214.93 95.88c-5.94-8.8-18.93-8.8-24.87 0-43.56 64.49-70.9 107.33-70.9 149.07 0 45.6 37.28 82.55 83.33 82.55s83.33-36.95 83.33-82.55c.01-41.74-27.33-84.58-70.89-149.07z"" fill=""url(#prefix__SVGID_00000096046149083906169040000006838268896560026277_)""/><path class=""prefix__st2"" d=""M271.41 338.62a.8.8 0 00-.59-.24h-1.66a.8.8 0 00-.59.24.8.8 0 00-.24.59v5c0 .11-.02.22-.06.32-.04.1-.1.2-.18.27a.8.8 0 01-.59.24h-8.33c-.11 0-.22-.02-.32-.06s-.2-.1-.27-.18-.14-.17-.18-.27a.866.866 0 01-.06-.32v-5a.8.8 0 00-.24-.59.8.8 0 00-.59-.24h-1.67c-.22 0-.43.09-.59.24s-.24.37-.24.59v15a.8.8 0 00.24.59.8.8 0 00.59.24h1.67a.8.8 0 00.59-.24.8.8 0 00.24-.59v-5a.8.8 0 01.24-.59.8.8 0 01.59-.24h8.33a.8.8 0 01.59.24.8.8 0 01.24.59v5c0 .11.02.22.06.32.04.1.1.2.18.27s.17.14.27.18.21.06.32.06h1.66c.11 0 .22-.02.32-.06.1-.04.2-.1.27-.18s.14-.17.18-.27c.04-.1.06-.21.06-.32v-15c0-.11-.02-.22-.06-.32-.04-.11-.1-.2-.18-.27zM321.41 341.91a.8.8 0 00-.59-.24h-5.83v.04h-2.5a.8.8 0 01-.59-.24.8.8 0 01-.24-.59v-5a.8.8 0 00-.24-.59.8.8 0 00-.59-.24h-1.66c-.11 0-.22.02-.32.06-.1.04-.2.1-.27.18a.8.8 0 00-.24.59v18.33c0 .11.02.22.06.32.04.1.1.2.18.27a.8.8 0 00.59.24h1.66c.11 0 .22-.02.32-.06.1-.04.2-.1.27-.18a.8.8 0 00.24-.59v-8.33a.8.8 0 01.24-.59.8.8 0 01.59-.24h5a.8.8 0 01.59.24.8.8 0 01.24.59v8.33c0 .11.02.22.06.32.04.1.1.2.18.27a.8.8 0 00.59.24h1.66c.11 0 .22-.02.32-.06.1-.04.2-.1.27-.18a.8.8 0 00.24-.59v-11.7c0-.11-.02-.22-.06-.32a.624.624 0 00-.17-.28zM338.08 341.91a.8.8 0 00-.59-.24h-11.67c-.11 0-.22.02-.32.06a.98.98 0 00-.27.18.8.8 0 00-.24.59v11.66a.8.8 0 00.24.59.8.8 0 00.59.24h11.67a.8.8 0 00.59-.24.8.8 0 00.24-.59v-1.66c0-.11-.02-.22-.06-.32-.04-.1-.1-.2-.18-.27a.8.8 0 00-.59-.24h-8.33c-.22 0-.43-.09-.59-.24-.16-.16-.24-.37-.24-.59s.09-.43.24-.59c.16-.16.37-.24.59-.24h8.33a.8.8 0 00.59-.24.8.8 0 00.24-.59v-6.66c0-.11-.02-.22-.06-.32a.841.841 0 00-.18-.29zm-3.16 4.24a.8.8 0 01-.18.27.8.8 0 01-.59.24h-5a.8.8 0 01-.59-.24.8.8 0 01-.24-.59.8.8 0 01.24-.59.8.8 0 01.59-.24h5a.8.8 0 01.59.24.8.8 0 01.24.59c0 .11-.02.22-.06.32zM354.74 341.91a.8.8 0 00-.59-.24l-2.5.04h-9.17a.8.8 0 00-.59.24.8.8 0 00-.24.59v11.66c0 .11.02.22.06.32.04.1.1.2.18.27a.8.8 0 00.59.24h1.67a.8.8 0 00.59-.24.8.8 0 00.24-.59v-8.33a.8.8 0 01.24-.59.8.8 0 01.59-.24h5c.11 0 .22.02.32.06.1.04.2.1.27.18a.8.8 0 01.24.59v8.33c0 .11.02.22.06.32.04.1.1.2.18.27a.8.8 0 00.59.24h1.67a.8.8 0 00.59-.24.8.8 0 00.24-.59v-11.7c0-.11-.02-.22-.06-.32a.65.65 0 00-.17-.27zM288.08 341.91a.8.8 0 00-.59-.24h-1.67c-.11 0-.22.02-.32.06a.98.98 0 00-.27.18.8.8 0 00-.24.59v8.33a.8.8 0 01-.24.59.8.8 0 01-.59.24h-5c-.11 0-.22-.02-.32-.06-.1-.04-.2-.1-.27-.18a.8.8 0 01-.24-.59v-8.33c0-.11-.02-.22-.06-.32-.04-.1-.1-.2-.18-.27a.8.8 0 00-.59-.24h-1.67c-.11 0-.22.02-.32.06a.98.98 0 00-.27.18.8.8 0 00-.24.59v11.66a.8.8 0 00.24.59.8.8 0 00.59.24h8.34c.22 0 .43.09.59.24.16.16.24.37.24.59s-.09.43-.24.59c-.16.16-.37.24-.59.24h-5c-.11 0-.22.02-.32.06s-.2.1-.27.18-.14.17-.18.27c-.04.1-.06.21-.06.32v1.66c0 .11.02.22.06.32.04.1.1.2.18.27s.17.14.27.18.21.06.32.06h8.33a.8.8 0 00.59-.24.8.8 0 00.24-.59v-16.66c0-.11-.02-.22-.06-.32-.05-.08-.12-.17-.19-.25zM304.74 341.91a.8.8 0 00-.59-.24h-11.67a.8.8 0 00-.59.24.8.8 0 00-.24.59v16.66c0 .11.02.22.06.32.04.1.1.2.18.27a.8.8 0 00.59.24h1.67a.8.8 0 00.59-.24.8.8 0 00.24-.59v-3.33a.8.8 0 01.24-.59.8.8 0 01.59-.24h8.34a.8.8 0 00.59-.24.8.8 0 00.24-.59v-11.66a.866.866 0 00-.24-.6zm-3.09 8.93a.8.8 0 01-.52.77c-.1.04-.21.06-.32.06h-5a.8.8 0 01-.59-.24.8.8 0 01-.24-.59v-5a.8.8 0 01.24-.59.8.8 0 01.59-.24h5a.866.866 0 01.6.24.8.8 0 01.24.59v5zM329.97 96.59c.28 0 .57-.05.83-.16s.5-.27.7-.47a2.116 2.116 0 00.63-1.53V81.49a2.182 2.182 0 00-.62-1.52 2.105 2.105 0 00-1.52-.63h-4.31c-.57 0-1.12.23-1.52.63-.4.4-.63.95-.63 1.52v4.31c0 .28-.05.57-.16.83s-.27.5-.47.7a2.116 2.116 0 01-1.53.63h-4.31c-.28 0-.57-.05-.83-.16s-.5-.27-.7-.47a2.116 2.116 0 01-.63-1.53V64.24c0-.28.05-.57.16-.83s.27-.5.47-.7a2.116 2.116 0 011.53-.63h1.25c.42 0 .84-.12 1.2-.36.35-.24.63-.57.79-.97a2.138 2.138 0 00-.49-2.33l-7.68-7.76c-.2-.21-.44-.37-.7-.48a2.124 2.124 0 00-1.66 0c-.26.11-.5.27-.7.48l-7.72 7.76c-.3.3-.51.68-.59 1.09s-.04.85.12 1.24.43.73.78.96c.35.24.76.37 1.19.37h1.25c.29 0 .57.05.83.16s.5.27.7.47c.2.2.36.44.47.7.11.26.16.55.16.83v30.2c0 .28.05.57.16.83s.27.5.47.7a2.116 2.116 0 001.53.63h21.55z""/><path class=""prefix__st2"" d=""M324.14 70.08a2.116 2.116 0 001.53.63h4.31c.28 0 .57-.05.83-.16s.5-.27.7-.47a2.116 2.116 0 00.63-1.53v-4.31c0-.28.05-.57.16-.83s.27-.5.47-.7a2.116 2.116 0 011.53-.63h4.32c.28 0 .57.05.83.16s.5.27.7.47c.2.2.36.44.47.7.11.26.16.55.16.83v21.57c0 .28-.05.57-.16.83s-.27.5-.47.7a2.116 2.116 0 01-1.53.63h-1.26c-.42 0-.84.13-1.2.36-.35.24-.63.57-.79.97-.16.39-.2.83-.11 1.24.09.42.3.8.6 1.1l7.73 7.72c.2.2.44.37.7.48a2.124 2.124 0 002.36-.48l7.72-7.72c.3-.3.5-.69.58-1.1.08-.42.04-.85-.12-1.24a2.12 2.12 0 00-.79-.96c-.35-.24-.77-.36-1.19-.36h-1.29c-.28 0-.57-.05-.83-.16s-.5-.27-.7-.47a2.116 2.116 0 01-.63-1.53V55.6c0-.28-.05-.57-.16-.83s-.27-.5-.47-.7c-.2-.2-.44-.36-.7-.47-.26-.11-.55-.16-.83-.16h-21.57c-.28 0-.57.05-.83.16s-.5.27-.7.47a2.116 2.116 0 00-.63 1.53v12.95c0 .28.05.57.16.83s.27.5.47.7z""/><text transform=""translate(73.686 67)"" class=""prefix__st2 prefix__st28 prefix__st29"">',
                    suppliedLiquidity,
                    ' USDT</text><text transform=""rotate(-90 213.61 143.092)"" class=""prefix__st2 prefix__st28 prefix__st29"">',
                    sharePercent,
                    '%</text><path fill=""none"" stroke=""#fff"" stroke-miterlimit=""10"" d=""M61.86 267.12V114.71""/><text transform=""translate(79.915 355)"" class=""prefix__st2 prefix__st28"" font-size=""10"">ID: ',
                    tokenId,
                    '</text><g fill-rule=""evenodd"" clip-rule=""evenodd""><path d=""M54.8 51.18l-3.1 6.51a.14.14 0 00.03.15l8.37 8.02c.05.05.13.05.18 0l8.37-8.02c.04-.04.05-.1.03-.15l-3.1-6.51a.136.136 0 00-.11-.07H54.91c-.05-.01-.09.02-.11.07z"" fill=""#50af95""/><path d=""M61.26 58.36c-.06 0-.37.02-1.06.02-.55 0-.94-.02-1.08-.02-2.13-.09-3.72-.46-3.72-.91 0-.44 1.59-.81 3.72-.91v1.45c.14.01.54.03 1.09.03.66 0 .99-.03 1.05-.03v-1.45c2.12.09 3.71.47 3.71.91s-1.59.81-3.71.91zm0-1.97v-1.3h2.97v-1.98h-8.07v1.98h2.96v1.3c-2.41.11-4.22.59-4.22 1.16s1.81 1.05 4.22 1.16v4.15h2.14v-4.15c2.4-.11 4.21-.59 4.21-1.16s-1.8-1.05-4.21-1.16zm0 0"" fill=""#fff""/></g><g><path d=""M136.03 77.23H56.69c-2.76 0-5 2.24-5 5v7.47c0 2.76 2.24 5 5 5h79.34c2.76 0 5-2.24 5-5v-7.47c0-2.76-2.24-5-5-5z"" fill=""#8c8c8c""/><text transform=""translate(56.685 89.706)"" class=""prefix__st2"" font-size=""12"" font-family=""Courier-Bold"">ON ETHEREUM</text></g></svg>'
                )
            );
    }

    function getChainName() public pure override returns (string memory) {
        return ""Ethereum"";
    }
}",4793
RealWorld_BA_97_ITokenManager_RealWord_20240826213028.log,97,ITokenManager,6768,5246,12014,105.0,0.13876,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.0;

interface ITokenManager {

    struct TokenInfo {
        uint256 transferOverhead;
        bool supportedToken;
        uint256 equilibriumFee; // Percentage fee Represented in basis points
        uint256 maxFee; // Percentage fee Represented in basis points
        TokenConfig tokenConfig;
    }

    struct TokenConfig {
        uint256 min;
        uint256 max;
    }
    
    function getEquilibriumFee(address tokenAddress) external view returns (uint256);

    function getMaxFee(address tokenAddress) external view returns (uint256);

    function changeFee(
        address tokenAddress,
        uint256 _equilibriumFee,
        uint256 _maxFee
    ) external;

    function getTokensInfo(address tokenAddress) external view returns (TokenInfo memory);

    function getDepositConfig(uint256 toChainId, address tokenAddress) external view returns (TokenConfig memory);

    function getTransferConfig(address tokenAddress) external view returns (TokenConfig memory);
}",213
RealWorld_BA_97_ERC2771Context_RealWord_20240826212418.log,97,ERC2771Context,6867,4183,11050,76.0,0.117995,"// SPDX-License-Identifier: MIT

pragma solidity 0.8.0;

import ""@openzeppelin/contracts/utils/Context.sol"";

/**
 * @dev Context variant with ERC2771 support.
 */
abstract contract ERC2771Context is Context {
    address internal _trustedForwarder;

    constructor(address trustedForwarder) {
        _trustedForwarder = trustedForwarder;
    }

    function isTrustedForwarder(address forwarder) public view virtual returns (bool) {
        return forwarder == _trustedForwarder;
    }

    function _msgSender() internal view virtual override returns (address sender) {
        if (isTrustedForwarder(msg.sender)) {
            // The assembly code is more direct than the Solidity version using `abi.decode`.
            assembly {
                sender := shr(96, calldataload(sub(calldatasize(), 20)))
            }
        } else {
            return super._msgSender();
        }
    }

    function _msgData() internal view virtual override returns (bytes calldata) {
        if (isTrustedForwarder(msg.sender)) {
            return msg.data[:msg.data.length - 20];
        } else {
            return super._msgData();
        }
    }
}",252
RealWorld_BA_97_LiquidityPool_RealWord_20240826205458.log,97,LiquidityPool,66041,6050,72091,99.0,0.451205,"// SPDX-License-Identifier: MIT

pragma solidity 0.8.0;
pragma abicoder v2;

import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";
import ""@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"";
import ""./metatx/ERC2771ContextUpgradeable.sol"";
import ""../security/Pausable.sol"";
import ""./interfaces/IExecutorManager.sol"";
import ""./interfaces/ILiquidityProviders.sol"";
import ""../interfaces/IERC20Permit.sol"";
import ""./interfaces/ITokenManager.sol"";

contract LiquidityPool is ReentrancyGuardUpgradeable, Pausable, OwnableUpgradeable, ERC2771ContextUpgradeable {
    address private constant NATIVE = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;
    uint256 private constant BASE_DIVISOR = 10000000000; // Basis Points * 100 for better accuracy

    uint256 public baseGas;

    IExecutorManager private executorManager;
    ITokenManager public tokenManager;
    ILiquidityProviders public liquidityProviders;

    struct PermitRequest {
        uint256 nonce;
        uint256 expiry;
        bool allowed;
        uint8 v;
        bytes32 r;
        bytes32 s;
    }

    mapping(bytes32 => bool) public processedHash;
    mapping(address => uint256) public gasFeeAccumulatedByToken;

    // Gas fee accumulated by token address => executor address
    mapping(address => mapping(address => uint256)) public gasFeeAccumulated;

    // Incentive Pool amount per token address
    mapping(address => uint256) public incentivePool;

    event AssetSent(
        address indexed asset,
        uint256 indexed amount,
        uint256 indexed transferredAmount,
        address target,
        bytes depositHash,
        uint256 fromChainId
    );
    event FeeDetails(uint256 indexed lpFee, uint256 indexed transferFee, uint256 indexed gasFee);
    event Received(address indexed from, uint256 indexed amount);
    event Deposit(
        address indexed from,
        address indexed tokenAddress,
        address indexed receiver,
        uint256 toChainId,
        uint256 amount,
        uint256 reward,
        string tag
    );
    event GasFeeWithdraw(address indexed tokenAddress, address indexed owner, uint256 indexed amount);
    event TrustedForwarderChanged(address indexed forwarderAddress);
    event LiquidityProvidersChanged(address indexed liquidityProvidersAddress);
    event EthReceived(address, uint256);

    // MODIFIERS
    modifier onlyExecutor() {
        require(executorManager.getExecutorStatus(_msgSender()), ""Only executor is allowed"");
        _;
    }

    modifier onlyLiquidityProviders() {
        require(_msgSender() == address(liquidityProviders), ""Only liquidityProviders is allowed"");
        _;
    }

    modifier tokenChecks(address tokenAddress) {
        require(tokenAddress != address(0), ""Token address cannot be 0"");
        require(tokenManager.getTokensInfo(tokenAddress).supportedToken, ""Token not supported"");
        _;
    }

    function initialize(
        address _executorManagerAddress,
        address _pauser,
        address _trustedForwarder,
        address _tokenManager,
        address _liquidityProviders
    ) public initializer {
        require(_executorManagerAddress != address(0), ""ExecutorManager cannot be 0x0"");
        require(_trustedForwarder != address(0), ""TrustedForwarder cannot be 0x0"");
        require(_liquidityProviders != address(0), ""LiquidityProviders cannot be 0x0"");
        __ERC2771Context_init(_trustedForwarder);
        __ReentrancyGuard_init();
        __Ownable_init();
        __Pausable_init(_pauser);
        executorManager = IExecutorManager(_executorManagerAddress);
        tokenManager = ITokenManager(_tokenManager);
        liquidityProviders = ILiquidityProviders(_liquidityProviders);
        baseGas = 21000;
    }

    function setTrustedForwarder(address trustedForwarder) public onlyOwner {
        require(trustedForwarder != address(0), ""TrustedForwarder can't be 0"");
        _trustedForwarder = trustedForwarder;
        emit TrustedForwarderChanged(trustedForwarder);
    }

    function setLiquidityProviders(address _liquidityProviders) public onlyOwner {
        require(_liquidityProviders != address(0), ""LiquidityProviders can't be 0"");
        liquidityProviders = ILiquidityProviders(_liquidityProviders);
        emit LiquidityProvidersChanged(_liquidityProviders);
    }

    function setBaseGas(uint128 gas) external onlyOwner {
        baseGas = gas;
    }

    function getExecutorManager() public view returns (address) {
        return address(executorManager);
    }

    function setExecutorManager(address _executorManagerAddress) external onlyOwner {
        require(_executorManagerAddress != address(0), ""Executor Manager cannot be 0"");
        executorManager = IExecutorManager(_executorManagerAddress);
    }

    function getCurrentLiquidity(address tokenAddress) public view returns (uint256 currentLiquidity) {
        uint256 liquidityPoolBalance = liquidityProviders.getCurrentLiquidity(tokenAddress);
        
        currentLiquidity =
            liquidityPoolBalance -
            liquidityProviders.totalLPFees(tokenAddress) -
            gasFeeAccumulatedByToken[tokenAddress] -
            incentivePool[tokenAddress];
    }

    /**
     * @dev Function used to deposit tokens into pool to initiate a cross chain token transfer.
     * @param toChainId Chain id where funds needs to be transfered
     * @param tokenAddress ERC20 Token address that needs to be transfered
     * @param receiver Address on toChainId where tokens needs to be transfered
     * @param amount Amount of token being transfered
     */
    function depositErc20(
        uint256 toChainId,
        address tokenAddress,
        address receiver,
        uint256 amount,
        string memory tag
    ) public tokenChecks(tokenAddress) whenNotPaused nonReentrant {
        require(
            tokenManager.getDepositConfig(toChainId, tokenAddress).min <= amount &&
                tokenManager.getDepositConfig(toChainId, tokenAddress).max >= amount,
            ""Deposit amount not in Cap limit""
        );
        require(receiver != address(0), ""Receiver address cannot be 0"");
        require(amount != 0, ""Amount cannot be 0"");
        address sender = _msgSender();

        uint256 rewardAmount = getRewardAmount(amount, tokenAddress);
        if (rewardAmount != 0) {
            incentivePool[tokenAddress] = incentivePool[tokenAddress] - rewardAmount;
        }
        liquidityProviders.increaseCurrentLiquidity(tokenAddress, amount);
        SafeERC20Upgradeable.safeTransferFrom(IERC20Upgradeable(tokenAddress), sender, address(this), amount);
        // Emit (amount + reward amount) in event
        emit Deposit(sender, tokenAddress, receiver, toChainId, amount + rewardAmount, rewardAmount, tag);
    }

    function getRewardAmount(uint256 amount, address tokenAddress) public view returns (uint256 rewardAmount) {
        uint256 currentLiquidity = getCurrentLiquidity(tokenAddress);
        uint256 providedLiquidity = liquidityProviders.getSuppliedLiquidityByToken(tokenAddress);
        if (currentLiquidity < providedLiquidity) {
            uint256 liquidityDifference = providedLiquidity - currentLiquidity;
            if (amount >= liquidityDifference) {
                rewardAmount = incentivePool[tokenAddress];
            } else {
                // Multiply by 10000000000 to avoid 0 reward amount for small amount and liquidity difference
                rewardAmount = (amount * incentivePool[tokenAddress] * 10000000000) / liquidityDifference;
                rewardAmount = rewardAmount / 10000000000;
            }
        }
    }

    /**
     * DAI permit and Deposit.
     */
    function permitAndDepositErc20(
        address tokenAddress,
        address receiver,
        uint256 amount,
        uint256 toChainId,
        PermitRequest calldata permitOptions,
        string memory tag
    ) external {
        IERC20Permit(tokenAddress).permit(
            _msgSender(),
            address(this),
            permitOptions.nonce,
            permitOptions.expiry,
            permitOptions.allowed,
            permitOptions.v,
            permitOptions.r,
            permitOptions.s
        );
        depositErc20(toChainId, tokenAddress, receiver, amount, tag);
    }

    /**
     * EIP2612 and Deposit.
     */
    function permitEIP2612AndDepositErc20(
        address tokenAddress,
        address receiver,
        uint256 amount,
        uint256 toChainId,
        PermitRequest calldata permitOptions,
        string memory tag
    ) external {
        IERC20Permit(tokenAddress).permit(
            _msgSender(),
            address(this),
            amount,
            permitOptions.expiry,
            permitOptions.v,
            permitOptions.r,
            permitOptions.s
        );
        depositErc20(toChainId, tokenAddress, receiver, amount, tag);
    }

    /**
     * @dev Function used to deposit native token into pool to initiate a cross chain token transfer.
     * @param receiver Address on toChainId where tokens needs to be transfered
     * @param toChainId Chain id where funds needs to be transfered
     */
    function depositNative(
        address receiver,
        uint256 toChainId,
        string memory tag
    ) external payable whenNotPaused nonReentrant {
        require(
            tokenManager.getDepositConfig(toChainId, NATIVE).min <= msg.value &&
                tokenManager.getDepositConfig(toChainId, NATIVE).max >= msg.value,
            ""Deposit amount not in Cap limit""
        );
        require(receiver != address(0), ""Receiver address cannot be 0"");
        require(msg.value != 0, ""Amount cannot be 0"");

        uint256 rewardAmount = getRewardAmount(msg.value, NATIVE);
        if (rewardAmount != 0) {
            incentivePool[NATIVE] = incentivePool[NATIVE] - rewardAmount;
        }
        liquidityProviders.increaseCurrentLiquidity(NATIVE, msg.value);
        emit Deposit(_msgSender(), NATIVE, receiver, toChainId, msg.value + rewardAmount, rewardAmount, tag);
    }

    function sendFundsToUser(
        address tokenAddress,
        uint256 amount,
        address payable receiver,
        bytes memory depositHash,
        uint256 tokenGasPrice,
        uint256 fromChainId
    ) external nonReentrant onlyExecutor tokenChecks(tokenAddress) whenNotPaused {
        uint256 initialGas = gasleft();
        require(
            tokenManager.getTransferConfig(tokenAddress).min <= amount &&
                tokenManager.getTransferConfig(tokenAddress).max >= amount,
            ""Withdraw amnt not in Cap limits""
        );
        require(receiver != address(0), ""Bad receiver address"");

        (bytes32 hashSendTransaction, bool status) = checkHashStatus(tokenAddress, amount, receiver, depositHash);

        require(!status, ""Already Processed"");
        processedHash[hashSendTransaction] = true;

        uint256 amountToTransfer = getAmountToTransfer(initialGas, tokenAddress, amount, tokenGasPrice);
        liquidityProviders.decreaseCurrentLiquidity(tokenAddress, amountToTransfer);

        if (tokenAddress == NATIVE) {
            require(address(this).balance >= amountToTransfer, ""Not Enough Balance"");
            (bool success, ) = receiver.call{value: amountToTransfer}("""");
            require(success, ""Native Transfer Failed"");
        } else {
            require(IERC20Upgradeable(tokenAddress).balanceOf(address(this)) >= amountToTransfer, ""Not Enough Balance"");
            SafeERC20Upgradeable.safeTransfer(IERC20Upgradeable(tokenAddress), receiver, amountToTransfer);
        }

        emit AssetSent(tokenAddress, amount, amountToTransfer, receiver, depositHash, fromChainId);
    }

    /**
     * @dev Internal function to calculate amount of token that needs to be transfered afetr deducting all required fees.
     * Fee to be deducted includes gas fee, lp fee and incentive pool amount if needed.
     * @param initialGas Gas provided initially before any calculations began
     * @param tokenAddress Token address for which calculation needs to be done
     * @param amount Amount of token to be transfered before deducting the fee
     * @param tokenGasPrice Gas price in the token being transfered to be used to calculate gas fee
     * @return amountToTransfer Total amount to be transfered after deducting all fees.
     */
    function getAmountToTransfer(
        uint256 initialGas,
        address tokenAddress,
        uint256 amount,
        uint256 tokenGasPrice
    ) internal returns (uint256 amountToTransfer) {
        uint256 transferFeePerc = getTransferFee(tokenAddress, amount);
        uint256 lpFee;
        if (transferFeePerc > tokenManager.getTokensInfo(tokenAddress).equilibriumFee) {
            // Here add some fee to incentive pool also
            lpFee = (amount * tokenManager.getTokensInfo(tokenAddress).equilibriumFee) / BASE_DIVISOR;
            incentivePool[tokenAddress] =
                (incentivePool[tokenAddress] +
                    (amount * (transferFeePerc - tokenManager.getTokensInfo(tokenAddress).equilibriumFee))) /
                BASE_DIVISOR;
        } else {
            lpFee = (amount * transferFeePerc) / BASE_DIVISOR;
        }
        uint256 transferFeeAmount = (amount * transferFeePerc) / BASE_DIVISOR;

        liquidityProviders.addLPFee(tokenAddress, lpFee);

        uint256 totalGasUsed = initialGas - gasleft();
        totalGasUsed = totalGasUsed + tokenManager.getTokensInfo(tokenAddress).transferOverhead;
        totalGasUsed = totalGasUsed + baseGas;

        uint256 gasFee = totalGasUsed * tokenGasPrice;
        gasFeeAccumulatedByToken[tokenAddress] = gasFeeAccumulatedByToken[tokenAddress] + gasFee;
        gasFeeAccumulated[tokenAddress][_msgSender()] = gasFeeAccumulated[tokenAddress][_msgSender()] + gasFee;
        amountToTransfer = amount - (transferFeeAmount + gasFee);

        emit FeeDetails(lpFee, transferFeeAmount, gasFee);
    }

    function getTransferFee(address tokenAddress, uint256 amount) public view returns (uint256 fee) {
        uint256 currentLiquidity = getCurrentLiquidity(tokenAddress);
        uint256 providedLiquidity = liquidityProviders.getSuppliedLiquidityByToken(tokenAddress);

        uint256 resultingLiquidity = currentLiquidity - amount;

        uint256 equilibriumFee = tokenManager.getTokensInfo(tokenAddress).equilibriumFee;
        uint256 maxFee = tokenManager.getTokensInfo(tokenAddress).maxFee;
        // Fee is represented in basis points * 10 for better accuracy
        uint256 numerator = providedLiquidity * equilibriumFee * maxFee; // F(max) * F(e) * L(e)
        uint256 denominator = equilibriumFee * providedLiquidity + (maxFee - equilibriumFee) * resultingLiquidity; // F(e) * L(e) + (F(max) - F(e)) * L(r)

        if (denominator == 0) {
            fee = 0;
        } else {
            fee = numerator / denominator;
        }
    }

    function checkHashStatus(
        address tokenAddress,
        uint256 amount,
        address payable receiver,
        bytes memory depositHash
    ) public view returns (bytes32 hashSendTransaction, bool status) {
        hashSendTransaction = keccak256(abi.encode(tokenAddress, amount, receiver, keccak256(depositHash)));

        status = processedHash[hashSendTransaction];
    }

    function withdrawErc20GasFee(address tokenAddress) external onlyExecutor whenNotPaused nonReentrant {
        require(tokenAddress != NATIVE, ""Can't withdraw native token fee"");
        // uint256 gasFeeAccumulated = gasFeeAccumulatedByToken[tokenAddress];
        uint256 _gasFeeAccumulated = gasFeeAccumulated[tokenAddress][_msgSender()];
        require(_gasFeeAccumulated != 0, ""Gas Fee earned is 0"");
        gasFeeAccumulatedByToken[tokenAddress] = gasFeeAccumulatedByToken[tokenAddress] - _gasFeeAccumulated;
        gasFeeAccumulated[tokenAddress][_msgSender()] = 0;
        SafeERC20Upgradeable.safeTransfer(IERC20Upgradeable(tokenAddress), _msgSender(), _gasFeeAccumulated);
        emit GasFeeWithdraw(tokenAddress, _msgSender(), _gasFeeAccumulated);
    }

    function withdrawNativeGasFee() external onlyExecutor whenNotPaused nonReentrant {
        uint256 _gasFeeAccumulated = gasFeeAccumulated[NATIVE][_msgSender()];
        require(_gasFeeAccumulated != 0, ""Gas Fee earned is 0"");
        gasFeeAccumulatedByToken[NATIVE] = gasFeeAccumulatedByToken[NATIVE] - _gasFeeAccumulated;
        gasFeeAccumulated[NATIVE][_msgSender()] = 0;
        (bool success, ) = payable(_msgSender()).call{value: _gasFeeAccumulated}("""");
        require(success, ""Native Transfer Failed"");

        emit GasFeeWithdraw(address(this), _msgSender(), _gasFeeAccumulated);
    }

    function transfer(
        address _tokenAddress,
        address receiver,
        uint256 _tokenAmount
    ) external whenNotPaused onlyLiquidityProviders nonReentrant {
        require(receiver != address(0), ""Invalid receiver"");
        if (_tokenAddress == NATIVE) {
            require(address(this).balance >= _tokenAmount, ""ERR__INSUFFICIENT_BALANCE"");
            (bool success, ) = receiver.call{value: _tokenAmount}("""");
            require(success, ""ERR__NATIVE_TRANSFER_FAILED"");
        } else {
            IERC20Upgradeable baseToken = IERC20Upgradeable(_tokenAddress);
            require(baseToken.balanceOf(address(this)) >= _tokenAmount, ""ERR__INSUFFICIENT_BALANCE"");
            SafeERC20Upgradeable.safeTransfer(baseToken, receiver, _tokenAmount);
        }
    }

    function _msgSender()
        internal
        view
        virtual
        override(ContextUpgradeable, ERC2771ContextUpgradeable)
        returns (address sender)
    {
        return ERC2771ContextUpgradeable._msgSender();
    }

    function _msgData()
        internal
        view
        virtual
        override(ContextUpgradeable, ERC2771ContextUpgradeable)
        returns (bytes calldata)
    {
        return ERC2771ContextUpgradeable._msgData();
    }

    receive() external payable {
        emit EthReceived(_msgSender(), msg.value);
    }
}",4025
RealWorld_BA_97_Avalanche.ETH_RealWord_20240826211132.log,97,Avalanche.ETH,78521,5151,83672,90.0,0.495625,"// SPDX-License-Identifier: MIT
pragma solidity 0.8.0;

import ""../SvgHelperBase.sol"";

contract AvalancheETH is SvgHelperBase {
    using Strings for uint256;

    constructor(uint256 _decimals) SvgHelperBase(_decimals) {}

    function getTokenSvg(
        uint256 _tokenId,
        uint256 _suppliedLiquidity,
        uint256 _totalSuppliedLiquidity
    ) public view virtual override returns (string memory) {
        string memory tokenId = _tokenId.toString();
        string memory suppliedLiquidity = _divideByPowerOf10(_suppliedLiquidity, tokenDecimals, 3);
        string memory sharePercent = _calculatePercentage(_suppliedLiquidity, _totalSuppliedLiquidity);
        return
            string(
                abi.encodePacked(
                    '<svg version=""1.1"" id=""prefix__Layer_1"" xmlns=""http://www.w3.org/2000/svg"" x=""0"" y=""0"" viewBox=""0 0 405 405"" xml:space=""preserve""><style>.prefix__st15,.prefix__st2{fill:#fff}.prefix__st15{fill-opacity:.602}.prefix__st33{font-family:&apos;Courier&apos;}.prefix__st34{font-size:24px}</style><radialGradient id=""prefix__SVGID_1_"" cx=""-907.223"" cy=""-502.221"" r=""1"" gradientTransform=""matrix(0 327.499 327.499 0 164679.5 297114.594)"" gradientUnits=""userSpaceOnUse""><stop offset=""0"" stop-color=""#e84142""/><stop offset=""1""/></radialGradient><path d=""M30 0h345c16.57 0 30 13.43 30 30v345c0 16.57-13.43 30-30 30H30c-16.57 0-30-13.43-30-30V30C0 13.43 13.43 0 30 0z"" fill=""url(#prefix__SVGID_1_)""/><radialGradient id=""prefix__SVGID_00000116202745994131917800000004493405675274567581_"" cx=""-906.644"" cy=""-499.568"" r=""1"" gradientTransform=""matrix(0 270.995 167.538 0 83899.203 245773.469)"" gradientUnits=""userSpaceOnUse""><stop offset=""0"" stop-color=""#fff""/><stop offset="".711"" stop-color=""#627eea""/><stop offset=""1"" stop-opacity=""0""/><stop offset=""1"" stop-opacity=""0""/></radialGradient><path d=""M214.93 95.88c-5.94-8.8-18.93-8.8-24.87 0-43.56 64.49-70.9 107.33-70.9 149.07 0 45.6 37.28 82.55 83.33 82.55s83.33-36.95 83.33-82.55c.01-41.74-27.33-84.58-70.89-149.07z"" fill=""url(#prefix__SVGID_00000116202745994131917800000004493405675274567581_)""/><path class=""prefix__st2"" d=""M271.41 338.62a.8.8 0 00-.59-.24h-1.66a.8.8 0 00-.59.24.8.8 0 00-.24.59v5c0 .11-.02.22-.06.32-.04.1-.1.2-.18.27a.8.8 0 01-.59.24h-8.33c-.11 0-.22-.02-.32-.06s-.2-.1-.27-.18-.14-.17-.18-.27a.866.866 0 01-.06-.32v-5a.8.8 0 00-.24-.59.8.8 0 00-.59-.24h-1.67c-.22 0-.43.09-.59.24s-.24.37-.24.59v15a.8.8 0 00.24.59.8.8 0 00.59.24h1.67a.8.8 0 00.59-.24.8.8 0 00.24-.59v-5a.8.8 0 01.24-.59.8.8 0 01.59-.24h8.33a.8.8 0 01.59.24.8.8 0 01.24.59v5c0 .11.02.22.06.32.04.1.1.2.18.27s.17.14.27.18.21.06.32.06h1.66c.11 0 .22-.02.32-.06.1-.04.2-.1.27-.18s.14-.17.18-.27c.04-.1.06-.21.06-.32v-15c0-.11-.02-.22-.06-.32-.04-.11-.1-.2-.18-.27zM321.41 341.91a.8.8 0 00-.59-.24h-5.83v.04h-2.5a.8.8 0 01-.59-.24.8.8 0 01-.24-.59v-5a.8.8 0 00-.24-.59.8.8 0 00-.59-.24h-1.66c-.11 0-.22.02-.32.06-.1.04-.2.1-.27.18a.8.8 0 00-.24.59v18.33c0 .11.02.22.06.32.04.1.1.2.18.27a.8.8 0 00.59.24h1.66c.11 0 .22-.02.32-.06.1-.04.2-.1.27-.18a.8.8 0 00.24-.59v-8.33a.8.8 0 01.24-.59.8.8 0 01.59-.24h5a.8.8 0 01.59.24.8.8 0 01.24.59v8.33c0 .11.02.22.06.32.04.1.1.2.18.27a.8.8 0 00.59.24h1.66c.11 0 .22-.02.32-.06.1-.04.2-.1.27-.18a.8.8 0 00.24-.59v-11.7c0-.11-.02-.22-.06-.32a.624.624 0 00-.17-.28zM338.08 341.91a.8.8 0 00-.59-.24h-11.67c-.11 0-.22.02-.32.06a.98.98 0 00-.27.18.8.8 0 00-.24.59v11.66a.8.8 0 00.24.59.8.8 0 00.59.24h11.67a.8.8 0 00.59-.24.8.8 0 00.24-.59v-1.66c0-.11-.02-.22-.06-.32-.04-.1-.1-.2-.18-.27a.8.8 0 00-.59-.24h-8.33c-.22 0-.43-.09-.59-.24-.16-.16-.24-.37-.24-.59s.09-.43.24-.59c.16-.16.37-.24.59-.24h8.33a.8.8 0 00.59-.24.8.8 0 00.24-.59v-6.66c0-.11-.02-.22-.06-.32a.841.841 0 00-.18-.29zm-3.16 4.24a.8.8 0 01-.18.27.8.8 0 01-.59.24h-5a.8.8 0 01-.59-.24.8.8 0 01-.24-.59.8.8 0 01.24-.59.8.8 0 01.59-.24h5a.8.8 0 01.59.24.8.8 0 01.24.59c0 .11-.02.22-.06.32zM354.74 341.91a.8.8 0 00-.59-.24l-2.5.04h-9.17a.8.8 0 00-.59.24.8.8 0 00-.24.59v11.66c0 .11.02.22.06.32.04.1.1.2.18.27a.8.8 0 00.59.24h1.67a.8.8 0 00.59-.24.8.8 0 00.24-.59v-8.33a.8.8 0 01.24-.59.8.8 0 01.59-.24h5c.11 0 .22.02.32.06.1.04.2.1.27.18a.8.8 0 01.24.59v8.33c0 .11.02.22.06.32.04.1.1.2.18.27a.8.8 0 00.59.24h1.67a.8.8 0 00.59-.24.8.8 0 00.24-.59v-11.7c0-.11-.02-.22-.06-.32a.65.65 0 00-.17-.27zM288.08 341.91a.8.8 0 00-.59-.24h-1.67c-.11 0-.22.02-.32.06a.98.98 0 00-.27.18.8.8 0 00-.24.59v8.33a.8.8 0 01-.24.59.8.8 0 01-.59.24h-5c-.11 0-.22-.02-.32-.06-.1-.04-.2-.1-.27-.18a.8.8 0 01-.24-.59v-8.33c0-.11-.02-.22-.06-.32-.04-.1-.1-.2-.18-.27a.8.8 0 00-.59-.24h-1.67c-.11 0-.22.02-.32.06a.98.98 0 00-.27.18.8.8 0 00-.24.59v11.66a.8.8 0 00.24.59.8.8 0 00.59.24h8.34c.22 0 .43.09.59.24.16.16.24.37.24.59s-.09.43-.24.59c-.16.16-.37.24-.59.24h-5c-.11 0-.22.02-.32.06s-.2.1-.27.18-.14.17-.18.27c-.04.1-.06.21-.06.32v1.66c0 .11.02.22.06.32.04.1.1.2.18.27s.17.14.27.18.21.06.32.06h8.33a.8.8 0 00.59-.24.8.8 0 00.24-.59v-16.66c0-.11-.02-.22-.06-.32-.05-.08-.12-.17-.19-.25zM304.74 341.91a.8.8 0 00-.59-.24h-11.67a.8.8 0 00-.59.24.8.8 0 00-.24.59v16.66c0 .11.02.22.06.32.04.1.1.2.18.27a.8.8 0 00.59.24h1.67a.8.8 0 00.59-.24.8.8 0 00.24-.59v-3.33a.8.8 0 01.24-.59.8.8 0 01.59-.24h8.34a.8.8 0 00.59-.24.8.8 0 00.24-.59v-11.66a.866.866 0 00-.24-.6zm-3.09 8.93a.8.8 0 01-.52.77c-.1.04-.21.06-.32.06h-5a.8.8 0 01-.59-.24.8.8 0 01-.24-.59v-5a.8.8 0 01.24-.59.8.8 0 01.59-.24h5a.866.866 0 01.6.24.8.8 0 01.24.59v5zM329.97 96.59c.28 0 .57-.05.83-.16s.5-.27.7-.47a2.116 2.116 0 00.63-1.53V81.49a2.182 2.182 0 00-.62-1.52 2.105 2.105 0 00-1.52-.63h-4.31c-.57 0-1.12.23-1.52.63-.4.4-.63.95-.63 1.52v4.31c0 .28-.05.57-.16.83s-.27.5-.47.7a2.116 2.116 0 01-1.53.63h-4.31c-.28 0-.57-.05-.83-.16s-.5-.27-.7-.47a2.116 2.116 0 01-.63-1.53V64.24c0-.28.05-.57.16-.83s.27-.5.47-.7a2.116 2.116 0 011.53-.63h1.25c.42 0 .84-.12 1.2-.36.35-.24.63-.57.79-.97a2.138 2.138 0 00-.49-2.33l-7.68-7.76c-.2-.21-.44-.37-.7-.48a2.124 2.124 0 00-1.66 0c-.26.11-.5.27-.7.48l-7.72 7.76c-.3.3-.51.68-.59 1.09s-.04.85.12 1.24.43.73.78.96c.35.24.76.37 1.19.37h1.25c.29 0 .57.05.83.16s.5.27.7.47c.2.2.36.44.47.7.11.26.16.55.16.83v30.2c0 .28.05.57.16.83s.27.5.47.7a2.116 2.116 0 001.53.63h21.55z""/><path class=""prefix__st2"" d=""M324.14 70.08a2.116 2.116 0 001.53.63h4.31c.28 0 .57-.05.83-.16s.5-.27.7-.47a2.116 2.116 0 00.63-1.53v-4.31c0-.28.05-.57.16-.83s.27-.5.47-.7a2.116 2.116 0 011.53-.63h4.32c.28 0 .57.05.83.16s.5.27.7.47c.2.2.36.44.47.7.11.26.16.55.16.83v21.57c0 .28-.05.57-.16.83s-.27.5-.47.7a2.116 2.116 0 01-1.53.63h-1.26c-.42 0-.84.13-1.2.36-.35.24-.63.57-.79.97-.16.39-.2.83-.11 1.24.09.42.3.8.6 1.1l7.73 7.72c.2.2.44.37.7.48a2.124 2.124 0 002.36-.48l7.72-7.72c.3-.3.5-.69.58-1.1.08-.42.04-.85-.12-1.24a2.12 2.12 0 00-.79-.96c-.35-.24-.77-.36-1.19-.36h-1.29c-.28 0-.57-.05-.83-.16s-.5-.27-.7-.47a2.116 2.116 0 01-.63-1.53V55.6c0-.28-.05-.57-.16-.83s-.27-.5-.47-.7c-.2-.2-.44-.36-.7-.47-.26-.11-.55-.16-.83-.16h-21.57c-.28 0-.57.05-.83.16s-.5.27-.7.47a2.116 2.116 0 00-.63 1.53v12.95c0 .28.05.57.16.83s.27.5.47.7z""/><text transform=""translate(73.686 67)"" class=""prefix__st2 prefix__st33 prefix__st34"">',
                    suppliedLiquidity,
                    ' ETH</text><text transform=""rotate(-90 213.61 143.092)"" class=""prefix__st2 prefix__st33 prefix__st34"">',
                    sharePercent,
                    '%</text><path fill=""none"" stroke=""#fff"" stroke-miterlimit=""10"" d=""M61.86 267.12V114.71""/><text transform=""translate(79.915 355)"" class=""prefix__st2 prefix__st33"" font-size=""10"">ID: ',
                    tokenId,
                    '</text><g><circle cx=""60.19"" cy=""58.5"" r=""8.5"" fill-rule=""evenodd"" clip-rule=""evenodd"" fill=""#627eea""/><path class=""prefix__st15"" d=""M60.45 52.12v4.71l3.98 1.78-3.98-6.49z""/><path class=""prefix__st2"" d=""M60.45 52.12l-3.98 6.49 3.98-1.78v-4.71z""/><path class=""prefix__st15"" d=""M60.45 61.67v3.2l3.99-5.51-3.99 2.31z""/><path class=""prefix__st2"" d=""M60.45 64.87v-3.2l-3.98-2.31 3.98 5.51z""/><path d=""M60.45 60.93l3.98-2.31-3.98-1.78v4.09z"" fill=""#fff"" fill-opacity="".2""/><path class=""prefix__st15"" d=""M56.47 58.62l3.98 2.31v-4.09l-3.98 1.78z""/></g><g><path d=""M142.44 77.23H56.69c-2.76 0-5 2.24-5 5v7.47c0 2.76 2.24 5 5 5h85.75c2.76 0 5-2.24 5-5v-7.47c0-2.76-2.24-5-5-5z"" fill=""#e84142""/><text transform=""translate(56.685 89.706)"" class=""prefix__st2"" font-size=""12"" font-family=""Courier-Bold"">ON AVALANCHE</text></g></svg>'
                )
            );
    }

    function getChainName() public pure override returns (string memory) {
        return ""Avalanche"";
    }
}",4678
RealWorld_BA_98_Actions_RealWord_20240827001525.log,98,Actions,17318,5862,23180,106.0,0.20383,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.12;

enum ActionType {
    MintOption,
    MintSpread,
    Exercise,
    ClaimCollateral,
    Neutralize,
    QTokenPermit,
    CollateralTokenApproval,
    Call
}

struct ActionArgs {
    ActionType actionType; //type of action to perform
    address qToken; //qToken to exercise or mint
    address secondaryAddress; //secondary address depending on the action type
    address receiver; //receiving address of minting or function call
    uint256 amount; //amount of qTokens or collateral tokens
    uint256 collateralTokenId; //collateral token id for claiming collateral and neutralizing positions
    bytes data; //extra data for function calls
}

/// @title Library to parse arguments for actions to be executed by the Controller
/// @author Rolla
library Actions {
    function parseMintOptionArgs(ActionArgs memory _args)
        internal
        pure
        returns (
            address to,
            address qToken,
            uint256 amount
        )
    {
        require(_args.amount != 0, ""Actions: cannot mint 0 options"");

        to = _args.receiver;
        qToken = _args.qToken;
        amount = _args.amount;
    }

    function parseMintSpreadArgs(ActionArgs memory _args)
        internal
        pure
        returns (
            address qTokenToMint,
            address qTokenForCollateral,
            uint256 amount
        )
    {
        require(
            _args.amount != 0,
            ""Actions: cannot mint 0 options from spreads""
        );

        qTokenToMint = _args.qToken;
        qTokenForCollateral = _args.secondaryAddress;
        amount = _args.amount;
    }

    function parseExerciseArgs(ActionArgs memory _args)
        internal
        pure
        returns (address qToken, uint256 amount)
    {
        qToken = _args.qToken;
        amount = _args.amount;
    }

    function parseClaimCollateralArgs(ActionArgs memory _args)
        internal
        pure
        returns (uint256 collateralTokenId, uint256 amount)
    {
        collateralTokenId = _args.collateralTokenId;
        amount = _args.amount;
    }

    function parseNeutralizeArgs(ActionArgs memory _args)
        internal
        pure
        returns (uint256 collateralTokenId, uint256 amount)
    {
        collateralTokenId = _args.collateralTokenId;
        amount = _args.amount;
    }

    function parseQTokenPermitArgs(ActionArgs memory _args)
        internal
        pure
        returns (
            address qToken,
            address owner,
            address spender,
            uint256 value,
            uint256 deadline,
            uint8 v,
            bytes32 r,
            bytes32 s
        )
    {
        (v, r, s) = abi.decode(_args.data, (uint8, bytes32, bytes32));

        qToken = _args.qToken;
        owner = _args.secondaryAddress;
        spender = _args.receiver;
        value = _args.amount;
        deadline = _args.collateralTokenId;
    }

    function parseCollateralTokenApprovalArgs(ActionArgs memory _args)
        internal
        pure
        returns (
            address owner,
            address operator,
            bool approved,
            uint256 nonce,
            uint256 deadline,
            uint8 v,
            bytes32 r,
            bytes32 s
        )
    {
        (approved, v, r, s) = abi.decode(
            _args.data,
            (bool, uint8, bytes32, bytes32)
        );

        owner = _args.secondaryAddress;
        operator = _args.receiver;
        nonce = _args.amount;
        deadline = _args.collateralTokenId;
    }

    function parseCallArgs(ActionArgs memory _args)
        internal
        pure
        returns (address callee, bytes memory data)
    {
        require(
            _args.receiver != address(0),
            ""Actions: cannot make calls to the zero address""
        );

        callee = _args.receiver;
        data = _args.data;
    }
}",871
RealWorld_BA_98_BUSD_RealWord_20240827000035.log,98,BUSD,4288,3573,7861,76.0,0.0929,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.12;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

contract BUSD is ERC20 {
    // solhint-disable-next-line no-empty-blocks
    constructor() ERC20(""BUSD Token"", ""BUSD"") {}

    function mint(address account, uint256 amount) external {
        _mint(account, amount);
    }
}",93
RealWorld_BA_98_ActionsTester_RealWord_20240827001031.log,98,ActionsTester,9705,4693,14398,94.0,0.142385,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.12;

import ""../libraries/Actions.sol"";

contract ActionsTester {
    function testParseMintOptionArgs(ActionArgs memory args)
        external
        pure
        returns (
            address,
            address,
            uint256
        )
    {
        return Actions.parseMintOptionArgs(args);
    }

    function testParseMintSpreadArgs(ActionArgs memory args)
        external
        pure
        returns (
            address,
            address,
            uint256
        )
    {
        return Actions.parseMintSpreadArgs(args);
    }

    function testParseExerciseArgs(ActionArgs memory args)
        external
        pure
        returns (address, uint256)
    {
        return Actions.parseExerciseArgs(args);
    }

    function testParseClaimCollateralArgs(ActionArgs memory args)
        external
        pure
        returns (uint256, uint256)
    {
        return Actions.parseClaimCollateralArgs(args);
    }

    function testParseNeutralizeArgs(ActionArgs memory args)
        external
        pure
        returns (uint256, uint256)
    {
        return Actions.parseNeutralizeArgs(args);
    }

    function testParseQTokenPermitArgs(ActionArgs memory args)
        external
        pure
        returns (
            address,
            address,
            address,
            uint256,
            uint256,
            uint8,
            bytes32,
            bytes32
        )
    {
        return Actions.parseQTokenPermitArgs(args);
    }

    function testParseCollateralTokenApprovalArgs(ActionArgs memory args)
        external
        pure
        returns (
            address,
            address,
            bool,
            uint256,
            uint256,
            uint8,
            bytes32,
            bytes32
        )
    {
        return Actions.parseCollateralTokenApprovalArgs(args);
    }

    function testParseCallArgs(ActionArgs memory args)
        external
        pure
        returns (address, bytes memory)
    {
        return Actions.parseCallArgs(args);
    }
}",423
RealWorld_BA_98_ChainlinkFixedTimeOracleManager_RealWord_20240827003346.log,98,ChainlinkFixedTimeOracleManager,13914,5498,19412,94.0,0.17953,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.12;

import ""./ChainlinkOracleManager.sol"";
import ""../../interfaces/external/chainlink/IEACAggregatorProxy.sol"";
import ""../../interfaces/IChainlinkFixedTimeOracleManager.sol"";

/// @title For managing Chainlink oracles with updates at fixed times.
/// @author Rolla
/// @notice Update times are counted as seconds since the start of the day.
contract ChainlinkFixedTimeOracleManager is
    ChainlinkOracleManager,
    IChainlinkFixedTimeOracleManager
{
    mapping(uint256 => bool) public override chainlinkFixedTimeUpdates;

    /// @param _config address of quant central configuration
    /// @param _fallbackPeriodSeconds amount of seconds before fallback price submitter can submit
    constructor(
        address _config,
        uint8 _strikeAssetDecimals,
        uint256 _fallbackPeriodSeconds
    )
        ChainlinkOracleManager(
            _config,
            _strikeAssetDecimals,
            _fallbackPeriodSeconds
        )
    // solhint-disable-next-line no-empty-blocks
    {

    }

    /// @inheritdoc IChainlinkFixedTimeOracleManager
    function setFixedTimeUpdate(uint256 fixedTime, bool isValidTime)
        external
        override
    {
        require(
            config.hasRole(
                config.quantRoles(""ORACLE_MANAGER_ROLE""),
                msg.sender
            ),
            ""ChainlinkFixedTimeOracleManager: Only an oracle admin can add a fixed time for updates""
        );

        chainlinkFixedTimeUpdates[fixedTime] = isValidTime;

        emit FixedTimeUpdate(fixedTime, isValidTime);
    }

    /// @inheritdoc IProviderOracleManager
    function isValidOption(
        address,
        uint256 _expiryTime,
        uint256
    )
        public
        view
        override(ChainlinkOracleManager, IProviderOracleManager)
        returns (bool)
    {
        uint256 timeInSeconds = _expiryTime % 86400;
        return chainlinkFixedTimeUpdates[timeInSeconds];
    }

    /// @notice Gets the price and roundId for a given expiry time.
    /// @param aggregator address of the Chainlink aggregator proxy contract
    /// @param _expiryTimestamp option expiration timestamp in seconds since the Unix epoch
    /// @param _roundIdAfterExpiry id of the round right after the expiry
    /// @param _expiryRoundId id of the round right before or at the expiry
    function _getExpiryPrice(
        IEACAggregatorProxy aggregator,
        uint256 _expiryTimestamp,
        uint256 _roundIdAfterExpiry,
        uint256 _expiryRoundId
    ) internal view override returns (uint256 price, uint256 roundId) {
        if (
            aggregator.getTimestamp(uint256(_expiryRoundId)) == _expiryTimestamp
        ) {
            price = uint256(aggregator.getAnswer(_expiryRoundId));
            roundId = _expiryRoundId;
        } else {
            price = uint256(aggregator.getAnswer(_roundIdAfterExpiry));
            roundId = _roundIdAfterExpiry;
        }
    }
}",650
RealWorld_BA_98_ERC1155_RealWord_20240827002839.log,98,ERC1155,64607,5353,69960,93.0,0.430095,"// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.4.1 (token/ERC1155/ERC1155.sol)

pragma solidity 0.8.12;

import ""@openzeppelin/contracts/token/ERC1155/IERC1155.sol"";
import ""@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol"";
import ""@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol"";
import ""@openzeppelin/contracts/utils/Context.sol"";
import ""@openzeppelin/contracts/utils/introspection/ERC165.sol"";
import ""@openzeppelin/contracts/utils/Address.sol"";

/**
 * @dev Implementation of the basic standard multi-token.
 * See https://eips.ethereum.org/EIPS/eip-1155
 * Originally based on code by Enjin: https://github.com/enjin/erc-1155
 *
 * _Available since v3.1._
 */
contract ERC1155 is Context, ERC165, IERC1155, IERC1155MetadataURI {
    using Address for address;

    // Mapping from token ID to account balances
    mapping(uint256 => mapping(address => uint256)) private _balances;

    // Mapping from account to operator approvals
    mapping(address => mapping(address => bool)) internal _operatorApprovals;

    // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json
    string private _uri;

    /**
     * @dev See {_setURI}.
     */
    constructor(string memory uri_) {
        _setURI(uri_);
    }

    /**
     * @dev See {IERC165-supportsInterface}.
     */
    function supportsInterface(bytes4 interfaceId)
        public
        view
        virtual
        override(ERC165, IERC165)
        returns (bool)
    {
        return
            interfaceId == type(IERC1155).interfaceId ||
            interfaceId == type(IERC1155MetadataURI).interfaceId ||
            super.supportsInterface(interfaceId);
    }

    /**
     * @dev See {IERC1155MetadataURI-uri}.
     *
     * This implementation returns the same URI for *all* token types. It relies
     * on the token type ID substitution mechanism
     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].
     *
     * Clients calling this function must replace the `\{id\}` substring with the
     * actual token type ID.
     */
    function uri(uint256) public view virtual override returns (string memory) {
        return _uri;
    }

    /**
     * @dev See {IERC1155-balanceOf}.
     *
     * Requirements:
     *
     * - `account` cannot be the zero address.
     */
    function balanceOf(address account, uint256 id)
        public
        view
        virtual
        override
        returns (uint256)
    {
        require(
            account != address(0),
            ""ERC1155: balance query for the zero address""
        );
        return _balances[id][account];
    }

    /**
     * @dev See {IERC1155-balanceOfBatch}.
     *
     * Requirements:
     *
     * - `accounts` and `ids` must have the same length.
     */
    function balanceOfBatch(address[] memory accounts, uint256[] memory ids)
        public
        view
        virtual
        override
        returns (uint256[] memory)
    {
        require(
            accounts.length == ids.length,
            ""ERC1155: accounts and ids length mismatch""
        );

        uint256[] memory batchBalances = new uint256[](accounts.length);

        for (uint256 i = 0; i < accounts.length; ++i) {
            batchBalances[i] = balanceOf(accounts[i], ids[i]);
        }

        return batchBalances;
    }

    /**
     * @dev See {IERC1155-setApprovalForAll}.
     */
    function setApprovalForAll(address operator, bool approved)
        public
        virtual
        override
    {
        _setApprovalForAll(_msgSender(), operator, approved);
    }

    /**
     * @dev See {IERC1155-isApprovedForAll}.
     */
    function isApprovedForAll(address account, address operator)
        public
        view
        virtual
        override
        returns (bool)
    {
        return _operatorApprovals[account][operator];
    }

    /**
     * @dev See {IERC1155-safeTransferFrom}.
     */
    function safeTransferFrom(
        address from,
        address to,
        uint256 id,
        uint256 amount,
        bytes memory data
    ) public virtual override {
        require(
            from == _msgSender() || isApprovedForAll(from, _msgSender()),
            ""ERC1155: caller is not owner nor approved""
        );
        _safeTransferFrom(from, to, id, amount, data);
    }

    /**
     * @dev See {IERC1155-safeBatchTransferFrom}.
     */
    function safeBatchTransferFrom(
        address from,
        address to,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory data
    ) public virtual override {
        require(
            from == _msgSender() || isApprovedForAll(from, _msgSender()),
            ""ERC1155: transfer caller is not owner nor approved""
        );
        _safeBatchTransferFrom(from, to, ids, amounts, data);
    }

    /**
     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.
     *
     * Emits a {TransferSingle} event.
     *
     * Requirements:
     *
     * - `to` cannot be the zero address.
     * - `from` must have a balance of tokens of type `id` of at least `amount`.
     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the
     * acceptance magic value.
     */
    function _safeTransferFrom(
        address from,
        address to,
        uint256 id,
        uint256 amount,
        bytes memory data
    ) internal virtual {
        require(to != address(0), ""ERC1155: transfer to the zero address"");

        address operator = _msgSender();

        _beforeTokenTransfer(
            operator,
            from,
            to,
            _asSingletonArray(id),
            _asSingletonArray(amount),
            data
        );

        uint256 fromBalance = _balances[id][from];
        require(
            fromBalance >= amount,
            ""ERC1155: insufficient balance for transfer""
        );
        unchecked {
            _balances[id][from] = fromBalance - amount;
        }
        _balances[id][to] += amount;

        emit TransferSingle(operator, from, to, id, amount);

        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);
    }

    /**
     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_safeTransferFrom}.
     *
     * Emits a {TransferBatch} event.
     *
     * Requirements:
     *
     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the
     * acceptance magic value.
     */
    function _safeBatchTransferFrom(
        address from,
        address to,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory data
    ) internal virtual {
        require(
            ids.length == amounts.length,
            ""ERC1155: ids and amounts length mismatch""
        );
        require(to != address(0), ""ERC1155: transfer to the zero address"");

        address operator = _msgSender();

        _beforeTokenTransfer(operator, from, to, ids, amounts, data);

        for (uint256 i = 0; i < ids.length; ++i) {
            uint256 id = ids[i];
            uint256 amount = amounts[i];

            uint256 fromBalance = _balances[id][from];
            require(
                fromBalance >= amount,
                ""ERC1155: insufficient balance for transfer""
            );
            unchecked {
                _balances[id][from] = fromBalance - amount;
            }
            _balances[id][to] += amount;
        }

        emit TransferBatch(operator, from, to, ids, amounts);

        _doSafeBatchTransferAcceptanceCheck(
            operator,
            from,
            to,
            ids,
            amounts,
            data
        );
    }

    /**
     * @dev Sets a new URI for all token types, by relying on the token type ID
     * substitution mechanism
     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].
     *
     * By this mechanism, any occurrence of the `\{id\}` substring in either the
     * URI or any of the amounts in the JSON file at said URI will be replaced by
     * clients with the token type ID.
     *
     * For example, the `https://token-cdn-domain/\{id\}.json` URI would be
     * interpreted by clients as
     * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`
     * for token type ID 0x4cce0.
     *
     * See {uri}.
     *
     * Because these URIs cannot be meaningfully represented by the {URI} event,
     * this function emits no events.
     */
    function _setURI(string memory newuri) internal virtual {
        _uri = newuri;
    }

    /**
     * @dev Creates `amount` tokens of token type `id`, and assigns them to `to`.
     *
     * Emits a {TransferSingle} event.
     *
     * Requirements:
     *
     * - `to` cannot be the zero address.
     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the
     * acceptance magic value.
     */
    function _mint(
        address to,
        uint256 id,
        uint256 amount,
        bytes memory data
    ) internal virtual {
        require(to != address(0), ""ERC1155: mint to the zero address"");

        address operator = _msgSender();

        _beforeTokenTransfer(
            operator,
            address(0),
            to,
            _asSingletonArray(id),
            _asSingletonArray(amount),
            data
        );

        _balances[id][to] += amount;
        emit TransferSingle(operator, address(0), to, id, amount);

        _doSafeTransferAcceptanceCheck(
            operator,
            address(0),
            to,
            id,
            amount,
            data
        );
    }

    /**
     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.
     *
     * Requirements:
     *
     * - `ids` and `amounts` must have the same length.
     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the
     * acceptance magic value.
     */
    function _mintBatch(
        address to,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory data
    ) internal virtual {
        require(to != address(0), ""ERC1155: mint to the zero address"");
        require(
            ids.length == amounts.length,
            ""ERC1155: ids and amounts length mismatch""
        );

        address operator = _msgSender();

        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);

        for (uint256 i = 0; i < ids.length; i++) {
            _balances[ids[i]][to] += amounts[i];
        }

        emit TransferBatch(operator, address(0), to, ids, amounts);

        _doSafeBatchTransferAcceptanceCheck(
            operator,
            address(0),
            to,
            ids,
            amounts,
            data
        );
    }

    /**
     * @dev Destroys `amount` tokens of token type `id` from `from`
     *
     * Requirements:
     *
     * - `from` cannot be the zero address.
     * - `from` must have at least `amount` tokens of token type `id`.
     */
    function _burn(
        address from,
        uint256 id,
        uint256 amount
    ) internal virtual {
        require(from != address(0), ""ERC1155: burn from the zero address"");

        address operator = _msgSender();

        _beforeTokenTransfer(
            operator,
            from,
            address(0),
            _asSingletonArray(id),
            _asSingletonArray(amount),
            """"
        );

        uint256 fromBalance = _balances[id][from];
        require(fromBalance >= amount, ""ERC1155: burn amount exceeds balance"");
        unchecked {
            _balances[id][from] = fromBalance - amount;
        }

        emit TransferSingle(operator, from, address(0), id, amount);
    }

    /**
     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.
     *
     * Requirements:
     *
     * - `ids` and `amounts` must have the same length.
     */
    function _burnBatch(
        address from,
        uint256[] memory ids,
        uint256[] memory amounts
    ) internal virtual {
        require(from != address(0), ""ERC1155: burn from the zero address"");
        require(
            ids.length == amounts.length,
            ""ERC1155: ids and amounts length mismatch""
        );

        address operator = _msgSender();

        _beforeTokenTransfer(operator, from, address(0), ids, amounts, """");

        for (uint256 i = 0; i < ids.length; i++) {
            uint256 id = ids[i];
            uint256 amount = amounts[i];

            uint256 fromBalance = _balances[id][from];
            require(
                fromBalance >= amount,
                ""ERC1155: burn amount exceeds balance""
            );
            unchecked {
                _balances[id][from] = fromBalance - amount;
            }
        }

        emit TransferBatch(operator, from, address(0), ids, amounts);
    }

    /**
     * @dev Approve `operator` to operate on all of `owner` tokens
     *
     * Emits a {ApprovalForAll} event.
     */
    function _setApprovalForAll(
        address owner,
        address operator,
        bool approved
    ) internal virtual {
        require(owner != operator, ""ERC1155: setting approval status for self"");
        _operatorApprovals[owner][operator] = approved;
        emit ApprovalForAll(owner, operator, approved);
    }

    /**
     * @dev Hook that is called before any token transfer. This includes minting
     * and burning, as well as batched variants.
     *
     * The same hook is called on both single and batched variants. For single
     * transfers, the length of the `id` and `amount` arrays will be 1.
     *
     * Calling conditions (for each `id` and `amount` pair):
     *
     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens
     * of token type `id` will be  transferred to `to`.
     * - When `from` is zero, `amount` tokens of token type `id` will be minted
     * for `to`.
     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`
     * will be burned.
     * - `from` and `to` are never both zero.
     * - `ids` and `amounts` have the same, non-zero length.
     *
     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
     */
    function _beforeTokenTransfer(
        address operator,
        address from,
        address to,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory data
    ) internal virtual {}

    function _doSafeTransferAcceptanceCheck(
        address operator,
        address from,
        address to,
        uint256 id,
        uint256 amount,
        bytes memory data
    ) private {
        if (to.isContract()) {
            try
                IERC1155Receiver(to).onERC1155Received(
                    operator,
                    from,
                    id,
                    amount,
                    data
                )
            returns (bytes4 response) {
                if (response != IERC1155Receiver.onERC1155Received.selector) {
                    revert(""ERC1155: ERC1155Receiver rejected tokens"");
                }
            } catch Error(string memory reason) {
                revert(reason);
            } catch {
                revert(""ERC1155: transfer to non ERC1155Receiver implementer"");
            }
        }
    }

    function _doSafeBatchTransferAcceptanceCheck(
        address operator,
        address from,
        address to,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory data
    ) private {
        if (to.isContract()) {
            try
                IERC1155Receiver(to).onERC1155BatchReceived(
                    operator,
                    from,
                    ids,
                    amounts,
                    data
                )
            returns (bytes4 response) {
                if (
                    response != IERC1155Receiver.onERC1155BatchReceived.selector
                ) {
                    revert(""ERC1155: ERC1155Receiver rejected tokens"");
                }
            } catch Error(string memory reason) {
                revert(reason);
            } catch {
                revert(""ERC1155: transfer to non ERC1155Receiver implementer"");
            }
        }
    }

    function _asSingletonArray(uint256 element)
        private
        pure
        returns (uint256[] memory)
    {
        uint256[] memory array = new uint256[](1);
        array[0] = element;

        return array;
    }
}",3886
RealWorld_BA_98_CollateralToken_RealWord_20240826235238.log,98,CollateralToken,33504,5275,38779,88.0,0.27302,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.12;

import ""@openzeppelin/contracts/utils/cryptography/draft-EIP712.sol"";
import ""../external/openzeppelin/ERC1155.sol"";
import ""../interfaces/ICollateralToken.sol"";

/// @title Tokens representing a Quant user's short positions
/// @author Rolla
/// @notice Can be used by owners to claim their collateral
/// @dev This is a multi-token contract that implements the ERC1155 token standard:
/// https://eips.ethereum.org/EIPS/eip-1155
contract CollateralToken is ERC1155, ICollateralToken, EIP712 {
    /// @dev stores metadata for a CollateralToken with an specific id
    /// @param qTokenAddress address of the corresponding QToken
    /// @param qTokenAsCollateral QToken address of an option used as collateral in a spread
    struct CollateralTokenInfo {
        address qTokenAddress;
        address qTokenAsCollateral;
    }

    /// @inheritdoc ICollateralToken
    IQuantConfig public override quantConfig;

    /// @inheritdoc ICollateralToken
    mapping(uint256 => CollateralTokenInfo) public override idToInfo;

    /// @inheritdoc ICollateralToken
    uint256[] public override collateralTokenIds;

    // Signature nonce per address
    mapping(address => uint256) public nonces;

    // keccak256(
    //     ""metaSetApprovalForAll(address owner,address operator,bool approved,uint256 nonce,uint256 deadline)""
    // );
    bytes32 private constant _META_APPROVAL_TYPEHASH =
        0xf8f9aaf28cf20cd45b21061d07505fa1da285124284441ea655b9eb837ed89b7;

    /// @notice Initializes a new ERC1155 multi-token contract for representing
    /// users' short positions
    /// @param _quantConfig the address of the Quant system configuration contract
    /// @param _name name for the domain typehash in EIP712 meta transactions
    /// @param _version version for the domain typehash in EIP712 meta transactions
    /// @param uri_ URI for ERC1155 tokens metadata
    constructor(
        address _quantConfig,
        string memory _name,
        string memory _version,
        string memory uri_
    ) ERC1155(uri_) EIP712(_name, _version) {
        require(
            _quantConfig != address(0),
            ""CollateralToken: invalid QuantConfig address""
        );

        quantConfig = IQuantConfig(_quantConfig);
    }

    /// @inheritdoc ICollateralToken
    function createCollateralToken(
        address _qTokenAddress,
        address _qTokenAsCollateral
    ) external override returns (uint256 id) {
        id = getCollateralTokenId(_qTokenAddress, _qTokenAsCollateral);

        require(
            quantConfig.hasRole(
                quantConfig.quantRoles(""COLLATERAL_CREATOR_ROLE""),
                msg.sender
            ),
            ""CollateralToken: Only a collateral creator can create new CollateralTokens""
        );

        require(
            _qTokenAddress != _qTokenAsCollateral,
            ""CollateralToken: Can only create a collateral token with different tokens""
        );

        require(
            idToInfo[id].qTokenAddress == address(0),
            ""CollateralToken: this token has already been created""
        );

        idToInfo[id] = CollateralTokenInfo({
            qTokenAddress: _qTokenAddress,
            qTokenAsCollateral: _qTokenAsCollateral
        });

        collateralTokenIds.push(id);

        emit CollateralTokenCreated(
            _qTokenAddress,
            _qTokenAsCollateral,
            id,
            collateralTokenIds.length
        );
    }

    /// @inheritdoc ICollateralToken
    function mintCollateralToken(
        address recipient,
        uint256 collateralTokenId,
        uint256 amount
    ) external override {
        require(
            quantConfig.hasRole(
                quantConfig.quantRoles(""COLLATERAL_MINTER_ROLE""),
                msg.sender
            ),
            ""CollateralToken: Only a collateral minter can mint CollateralTokens""
        );

        emit CollateralTokenMinted(recipient, collateralTokenId, amount);

        _mint(recipient, collateralTokenId, amount, """");
    }

    /// @inheritdoc ICollateralToken
    function burnCollateralToken(
        address owner,
        uint256 collateralTokenId,
        uint256 amount
    ) external override {
        require(
            quantConfig.hasRole(
                quantConfig.quantRoles(""COLLATERAL_BURNER_ROLE""),
                msg.sender
            ),
            ""CollateralToken: Only a collateral burner can burn CollateralTokens""
        );
        _burn(owner, collateralTokenId, amount);

        emit CollateralTokenBurned(owner, collateralTokenId, amount);
    }

    /// @inheritdoc ICollateralToken
    function mintCollateralTokenBatch(
        address recipient,
        uint256[] calldata ids,
        uint256[] calldata amounts
    ) external override {
        require(
            quantConfig.hasRole(
                quantConfig.quantRoles(""COLLATERAL_MINTER_ROLE""),
                msg.sender
            ),
            ""CollateralToken: Only a collateral minter can mint CollateralTokens""
        );

        uint256 length = ids.length;
        for (uint256 i = 0; i < length; ) {
            emit CollateralTokenMinted(recipient, ids[i], amounts[i]);
            unchecked {
                ++i;
            }
        }

        _mintBatch(recipient, ids, amounts, """");
    }

    /// @inheritdoc ICollateralToken
    function burnCollateralTokenBatch(
        address owner,
        uint256[] calldata ids,
        uint256[] calldata amounts
    ) external override {
        require(
            quantConfig.hasRole(
                quantConfig.quantRoles(""COLLATERAL_BURNER_ROLE""),
                msg.sender
            ),
            ""CollateralToken: Only a collateral burner can burn CollateralTokens""
        );
        _burnBatch(owner, ids, amounts);

        uint256 length = ids.length;
        for (uint256 i = 0; i < length; ) {
            emit CollateralTokenBurned(owner, ids[i], amounts[i]);
            unchecked {
                ++i;
            }
        }
    }

    /// @inheritdoc ICollateralToken
    function metaSetApprovalForAll(
        address owner,
        address operator,
        bool approved,
        uint256 nonce,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external override {
        // solhint-disable-next-line not-rely-on-time
        require(
            block.timestamp <= deadline,
            ""CollateralToken: expired deadline""
        );

        require(nonce == nonces[owner], ""CollateralToken: invalid nonce"");

        bytes32 structHash = keccak256(
            abi.encode(
                _META_APPROVAL_TYPEHASH,
                owner,
                operator,
                approved,
                nonce,
                deadline
            )
        );

        bytes32 hash = _hashTypedDataV4(structHash);

        address signer = ecrecover(hash, v, r, s);
        require(signer == owner, ""CollateralToken: invalid signature"");

        nonces[owner]++;
        _operatorApprovals[owner][operator] = approved;
        emit ApprovalForAll(owner, operator, approved);
    }

    /// @inheritdoc ICollateralToken
    function getCollateralTokensLength()
        external
        view
        override
        returns (uint256)
    {
        return collateralTokenIds.length;
    }

    /// @inheritdoc ICollateralToken
    function getCollateralTokenInfo(uint256 id)
        external
        view
        override
        returns (QTokensDetails memory qTokensDetails)
    {
        CollateralTokenInfo memory info = idToInfo[id];

        require(
            info.qTokenAddress != address(0),
            ""CollateralToken: Invalid id""
        );

        IQToken.QTokenInfo memory shortDetails = IQToken(info.qTokenAddress)
            .getQTokenInfo();

        qTokensDetails.underlyingAsset = shortDetails.underlyingAsset;
        qTokensDetails.strikeAsset = shortDetails.strikeAsset;
        qTokensDetails.oracle = shortDetails.oracle;
        qTokensDetails.shortStrikePrice = shortDetails.strikePrice;
        qTokensDetails.expiryTime = shortDetails.expiryTime;
        qTokensDetails.isCall = shortDetails.isCall;

        if (info.qTokenAsCollateral != address(0)) {
            // the given id is for a CollateralToken representing a spread
            qTokensDetails.longStrikePrice = IQToken(info.qTokenAsCollateral)
                .strikePrice();
        }
    }

    /// @inheritdoc ICollateralToken
    function getCollateralTokenId(address _qToken, address _qTokenAsCollateral)
        public
        pure
        override
        returns (uint256 id)
    {
        id = uint256(keccak256(abi.encodePacked(_qToken, _qTokenAsCollateral)));
    }
}",1929
RealWorld_BA_98_AssetsRegistry.t_RealWord_20240827010403.log,98,AssetsRegistry.t,16591,5464,22055,110.0,0.192235,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.12;

import ""ds-test/test.sol"";
import ""contracts/options/AssetsRegistry.sol"";
import ""@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol"";
import ""contracts/QuantConfig.sol"";
import ""forge-std/stdlib.sol"";
import ""forge-std/Vm.sol"";
import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";

contract ERC20WithDecimals is ERC20 {
    uint8 private _decimals;

    constructor(
        string memory _name,
        string memory _symbol,
        uint8 decimals_
    ) ERC20(_name, _symbol) {
        _decimals = decimals_;
    }

    function decimals() public view virtual override returns (uint8) {
        return _decimals;
    }
}

contract SimpleERC20 {
    string private _name;
    string private _symbol;
    uint8 private _decimals;

    constructor(string memory name_, string memory symbol_) {
        _name = name_;
        _symbol = symbol_;
        _decimals = 18;
    }
}

contract AssetsRegistryTest is DSTest {
    Vm public constant vm = Vm(HEVM_ADDRESS);

    AssetsRegistry public assetsRegistry;

    event AssetAdded(
        address indexed underlying,
        string name,
        string symbol,
        uint8 decimals
    );

    function setUp() public {
        address quantConfig = address(new QuantConfig());
        assetsRegistry = new AssetsRegistry(quantConfig);
        vm.mockCall(
            quantConfig,
            abi.encodeWithSelector(AccessControlUpgradeable.hasRole.selector),
            abi.encode(true)
        );
    }

    function testAddAssetWithOptionalERC20Methods() public {
        string memory name = ""BTCB Token"";
        string memory symbol = ""BTCB"";
        uint8 decimals = 18;

        ERC20WithDecimals asset = new ERC20WithDecimals(name, symbol, decimals);

        assertEq(asset.name(), name);
        assertEq(asset.symbol(), symbol);
        assertEq(uint256(asset.decimals()), uint256(decimals));

        vm.expectEmit(true, false, false, true);

        emit AssetAdded(address(asset), name, symbol, decimals);

        assetsRegistry.addAssetWithOptionalERC20Methods(address(asset));

        address registeredAsset = assetsRegistry.registeredAssets(0);
        assertEq(registeredAsset, address(asset));

        (
            string memory registerdName,
            string memory registeredSymbol,
            uint8 registeredDecimals
        ) = assetsRegistry.assetProperties(registeredAsset);

        assertEq(registerdName, name);
        assertEq(registeredSymbol, symbol);
        assertEq(uint256(registeredDecimals), uint256(decimals));
    }

    function testAddAssetWithoutOptionalERC20Methods(
        string memory name,
        string memory symbol
    ) public {
        SimpleERC20 asset = new SimpleERC20(name, symbol);

        // Should revert when trying to call asset.name()
        vm.expectRevert(bytes(""""));

        assetsRegistry.addAssetWithOptionalERC20Methods(address(asset));
    }

    function testAddAssetAsNotRegistryMananger() public {
        vm.clearMockedCalls();

        string memory name = ""BUSD Token"";
        string memory symbol = ""BUSD"";
        uint8 decimals = 18;

        ERC20WithDecimals asset = new ERC20WithDecimals(name, symbol, decimals);

        vm.expectRevert(
            bytes(""AssetsRegistry: only asset registry managers can add assets"")
        );

        assetsRegistry.addAssetWithOptionalERC20Methods(address(asset));
    }

    function testAddSameAssetTwice() public {
        string memory name = ""Wrapped Ether"";
        string memory symbol = ""WETH"";
        uint8 decimals = 18;

        ERC20WithDecimals asset = new ERC20WithDecimals(name, symbol, decimals);

        assetsRegistry.addAssetWithOptionalERC20Methods(address(asset));

        vm.expectRevert(bytes(""AssetsRegistry: asset already added""));

        assetsRegistry.addAssetWithOptionalERC20Methods(address(asset));
    }
}",849
RealWorld_BA_98_ChainlinkOracleManager_RealWord_20240827003650.log,98,ChainlinkOracleManager,36064,5183,41247,99.0,0.28398,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.12;

import ""../../interfaces/external/chainlink/IEACAggregatorProxy.sol"";
import ""../PriceRegistry.sol"";
import ""./ProviderOracleManager.sol"";
import ""../../libraries/ProtocolValue.sol"";
import ""../../libraries/QuantMath.sol"";
import ""../../interfaces/IChainlinkOracleManager.sol"";

/// @title For managing chainlink oracles for assets and submitting chainlink prices to the registry
/// @author Rolla
/// @notice Once an oracle is added for an asset it can't be changed!
contract ChainlinkOracleManager is
    ProviderOracleManager,
    IChainlinkOracleManager
{
    using QuantMath for uint256;
    using QuantMath for QuantMath.FixedPointInt;

    struct BinarySearchResult {
        uint80 firstRound;
        uint80 lastRound;
        uint80 firstRoundProxy;
        uint80 lastRoundProxy;
    }

    uint256 public immutable override fallbackPeriodSeconds;
    uint8 public immutable override strikeAssetDecimals;
    uint8 public constant CHAINLINK_ORACLE_DECIMALS = 8;

    /// @param _config address of quant central configuration
    /// @param _fallbackPeriodSeconds amount of seconds before fallback price submitter can submit
    constructor(
        address _config,
        uint8 _strikeAssetDecimals,
        uint256 _fallbackPeriodSeconds
    ) ProviderOracleManager(_config) {
        fallbackPeriodSeconds = _fallbackPeriodSeconds;
        strikeAssetDecimals = _strikeAssetDecimals;
    }

    /// @inheritdoc IChainlinkOracleManager
    function setExpiryPriceInRegistryByRound(
        address _asset,
        uint256 _expiryTimestamp,
        uint256 _roundIdAfterExpiry
    ) external override {
        _setExpiryPriceInRegistryByRound(
            _asset,
            _expiryTimestamp,
            _roundIdAfterExpiry
        );
    }

    /// @inheritdoc IProviderOracleManager
    function setExpiryPriceInRegistry(
        address _asset,
        uint256 _expiryTimestamp,
        bytes memory
    ) external override(ProviderOracleManager, IProviderOracleManager) {
        //search and get round
        uint80 roundAfterExpiry = searchRoundToSubmit(_asset, _expiryTimestamp);

        //submit price to registry
        _setExpiryPriceInRegistryByRound(
            _asset,
            _expiryTimestamp,
            roundAfterExpiry
        );
    }

    /// @inheritdoc IOracleFallbackMechanism
    function setExpiryPriceInRegistryFallback(
        address _asset,
        uint256 _expiryTimestamp,
        uint256 _price
    ) external override {
        require(
            config.hasRole(
                config.quantRoles(""FALLBACK_PRICE_ROLE""),
                msg.sender
            ),
            ""ChainlinkOracleManager: Only the fallback price submitter can submit a fallback price""
        );

        require(
            block.timestamp >= _expiryTimestamp + fallbackPeriodSeconds,
            ""ChainlinkOracleManager: The fallback price period has not passed since the timestamp""
        );

        emit PriceRegistrySubmission(
            _asset,
            _expiryTimestamp,
            _price,
            0,
            msg.sender,
            true
        );

        PriceRegistry(
            config.protocolAddresses(ProtocolValue.encode(""priceRegistry""))
        ).setSettlementPrice(
                _asset,
                _expiryTimestamp,
                _price,
                CHAINLINK_ORACLE_DECIMALS
            );
    }

    /// @inheritdoc IProviderOracleManager
    function getCurrentPrice(address _asset)
        external
        view
        override(ProviderOracleManager, IProviderOracleManager)
        returns (uint256)
    {
        address assetOracle = getAssetOracle(_asset);
        IEACAggregatorProxy aggregator = IEACAggregatorProxy(assetOracle);
        int256 answer = aggregator.latestAnswer();
        require(
            answer > 0,
            ""ChainlinkOracleManager: No pricing data available""
        );

        return
            uint256(answer)
                .fromScaledUint(CHAINLINK_ORACLE_DECIMALS)
                .toScaledUint(strikeAssetDecimals, true);
    }

    /// @inheritdoc IProviderOracleManager
    function isValidOption(
        address,
        uint256,
        uint256
    )
        public
        view
        virtual
        override(ProviderOracleManager, IProviderOracleManager)
        returns (bool)
    {
        return true;
    }

    /// @inheritdoc IChainlinkOracleManager
    function searchRoundToSubmit(address _asset, uint256 _expiryTimestamp)
        public
        view
        override
        returns (uint80)
    {
        address assetOracle = getAssetOracle(_asset);

        IEACAggregatorProxy aggregator = IEACAggregatorProxy(assetOracle);

        require(
            aggregator.latestTimestamp() > _expiryTimestamp,
            ""ChainlinkOracleManager: The latest round timestamp is not after the expiry timestamp""
        );

        uint80 latestRound = uint80(aggregator.latestRound());

        uint16 phaseOffset = 64;
        uint16 phaseId = uint16(latestRound >> phaseOffset);

        uint80 lowestPossibleRound = uint80((phaseId << phaseOffset) | 1);
        uint80 highestPossibleRound = latestRound;
        uint80 firstId = lowestPossibleRound;
        uint80 lastId = highestPossibleRound;

        require(
            lastId > firstId,
            ""ChainlinkOracleManager: Not enough rounds to find round after""
        );

        //binary search until we find two values our desired timestamp lies between
        while (lastId - firstId != 1) {
            BinarySearchResult memory result = _binarySearchStep(
                aggregator,
                _expiryTimestamp,
                lowestPossibleRound,
                highestPossibleRound
            );

            lowestPossibleRound = result.firstRound;
            highestPossibleRound = result.lastRound;
            firstId = result.firstRoundProxy;
            lastId = result.lastRoundProxy;
        }

        return highestPossibleRound; //return round above
    }

    /// @notice Get the expiry price from chainlink asset oracle and store it in the price registry
    /// @param _asset asset to set price of
    /// @param _expiryTimestamp timestamp of price
    /// @param _roundIdAfterExpiry the chainlink round id immediately after the option expired
    function _setExpiryPriceInRegistryByRound(
        address _asset,
        uint256 _expiryTimestamp,
        uint256 _roundIdAfterExpiry
    ) internal {
        address assetOracle = getAssetOracle(_asset);

        IEACAggregatorProxy aggregator = IEACAggregatorProxy(assetOracle);

        require(
            aggregator.getTimestamp(uint256(_roundIdAfterExpiry)) >
                _expiryTimestamp,
            ""ChainlinkOracleManager: The round posted is not after the expiry timestamp""
        );

        uint16 phaseOffset = 64;
        uint16 phaseId = uint16(_roundIdAfterExpiry >> phaseOffset);

        uint64 expiryRound = uint64(_roundIdAfterExpiry) - 1;
        uint80 expiryRoundId = uint80(
            (uint256(phaseId) << phaseOffset) | expiryRound
        );

        require(
            aggregator.getTimestamp(uint256(expiryRoundId)) <= _expiryTimestamp,
            ""ChainlinkOracleManager: Expiry round prior to the one posted is after the expiry timestamp""
        );

        (uint256 price, uint256 roundId) = _getExpiryPrice(
            aggregator,
            _expiryTimestamp,
            _roundIdAfterExpiry,
            expiryRoundId
        );

        emit PriceRegistrySubmission(
            _asset,
            _expiryTimestamp,
            price,
            roundId,
            msg.sender,
            false
        );

        PriceRegistry(
            config.protocolAddresses(ProtocolValue.encode(""priceRegistry""))
        ).setSettlementPrice(
                _asset,
                _expiryTimestamp,
                price,
                CHAINLINK_ORACLE_DECIMALS
            );
    }

    function _getExpiryPrice(
        IEACAggregatorProxy aggregator,
        uint256,
        uint256,
        uint256 _expiryRoundId
    ) internal view virtual returns (uint256, uint256) {
        return (uint256(aggregator.getAnswer(_expiryRoundId)), _expiryRoundId);
    }

    /// @notice Performs a binary search step between the first and last round in the aggregator proxy
    /// @param _expiryTimestamp expiry timestamp to find the price at
    /// @param _firstRoundProxy the lowest possible round for the timestamp
    /// @param _lastRoundProxy the highest possible round for the timestamp
    /// @return a binary search result object representing lowest and highest possible rounds of the timestamp
    function _binarySearchStep(
        IEACAggregatorProxy aggregator,
        uint256 _expiryTimestamp,
        uint80 _firstRoundProxy,
        uint80 _lastRoundProxy
    ) internal view returns (BinarySearchResult memory) {
        uint16 phaseOffset = 64;
        uint16 phaseId = uint16(_lastRoundProxy >> phaseOffset);

        uint64 lastRoundId = uint64(_lastRoundProxy);
        uint64 firstRoundId = uint64(_firstRoundProxy);

        uint80 roundToCheck = uint80(
            (uint256(firstRoundId) + uint256(lastRoundId)) / 2
        );
        uint80 roundToCheckProxy = uint80(
            (uint256(phaseId) << phaseOffset) | roundToCheck
        );

        uint256 roundToCheckTimestamp = aggregator.getTimestamp(
            uint256(roundToCheckProxy)
        );

        if (roundToCheckTimestamp <= _expiryTimestamp) {
            return
                BinarySearchResult(
                    roundToCheckProxy,
                    _lastRoundProxy,
                    roundToCheck,
                    lastRoundId
                );
        }

        return
            BinarySearchResult(
                _firstRoundProxy,
                roundToCheckProxy,
                firstRoundId,
                roundToCheck
            );
    }
}",2072
RealWorld_BA_98_FundsCalculator_RealWord_20240827002141.log,98,FundsCalculator,49294,5468,54762,140.0,0.35583,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.12;

import ""./QuantMath.sol"";
import ""../options/QToken.sol"";
import ""../interfaces/IPriceRegistry.sol"";

/// @title For calculating collateral requirements and payouts for options and spreads
/// in a fixed point format
/// @author Rolla
library FundsCalculator {
    using QuantMath for uint256;
    using QuantMath for int256;
    using QuantMath for QuantMath.FixedPointInt;

    struct OptionPayoutInput {
        QuantMath.FixedPointInt strikePrice;
        QuantMath.FixedPointInt expiryPrice;
        QuantMath.FixedPointInt amount;
    }

    /// @notice Calculates payout of an option post-expiry from a qToken address
    /// @param _qToken the address of the qToken (option) which is being exercised
    /// @param _amount the amount of the qToken which is being exercised
    /// @param _optionsDecimals option decimals constant. qTokens have 18 decimals
    /// @param _strikeAssetDecimals the amount of decimals the strike asset has
    /// @param _expiryPrice the expiry price of the option with the amount of decimals
    /// @return payoutToken the address of the payout token
    /// @return payoutAmount the amount to be payed out as a fixed point type
    function getPayout(
        address _qToken,
        uint256 _amount,
        uint8 _optionsDecimals,
        uint8 _strikeAssetDecimals,
        IPriceRegistry.PriceWithDecimals memory _expiryPrice
    )
        internal
        view
        returns (
            address payoutToken,
            QuantMath.FixedPointInt memory payoutAmount
        )
    {
        QToken qToken = QToken(_qToken);
        bool isCall = qToken.isCall();

        payoutToken = isCall ? qToken.underlyingAsset() : qToken.strikeAsset();

        payoutAmount = getPayoutAmount(
            isCall,
            qToken.strikePrice(),
            _amount,
            _optionsDecimals,
            _strikeAssetDecimals,
            _expiryPrice
        );
    }

    /// @notice Calculates the collateral required to mint an option or a spread
    /// @param _qTokenToMint the desired qToken
    /// @param _qTokenForCollateral for spreads, this is the address of the qtoken to be used as collateral.
    /// for options, no collateral is provided so the zero address should be passed.
    /// @param _optionsAmount the amount of options/spread to mint
    /// @param _optionsDecimals option decimals constant. qTokens have 18 decimals
    /// @param _underlyingDecimals the amount of decimals the underlying asset has
    /// @param _strikeAssetDecimals the amount of decimals the strike asset has
    /// @return collateral the address of the collateral token required
    /// @return collateralAmount the collateral amount required as a fixed point type
    function getCollateralRequirement(
        address _qTokenToMint,
        address _qTokenForCollateral,
        uint256 _optionsAmount,
        uint8 _optionsDecimals,
        uint8 _underlyingDecimals,
        uint8 _strikeAssetDecimals
    )
        internal
        view
        returns (
            address collateral,
            QuantMath.FixedPointInt memory collateralAmount
        )
    {
        QToken qTokenToMint = QToken(_qTokenToMint);
        uint256 qTokenToMintStrikePrice = qTokenToMint.strikePrice();

        uint256 qTokenForCollateralStrikePrice;

        // check if we're getting the collateral requirement for a spread
        if (_qTokenForCollateral != address(0)) {
            QToken qTokenForCollateral = QToken(_qTokenForCollateral);
            qTokenForCollateralStrikePrice = qTokenForCollateral.strikePrice();

            // Check that expiries match
            require(
                qTokenToMint.expiryTime() == qTokenForCollateral.expiryTime(),
                ""Controller: Can't create spreads from options with different expiries""
            );

            // Check that the underlyings match
            require(
                qTokenToMint.underlyingAsset() ==
                    qTokenForCollateral.underlyingAsset(),
                ""Controller: Can't create spreads from options with different underlying assets""
            );

            // Check that the option types match
            require(
                qTokenToMint.isCall() == qTokenForCollateral.isCall(),
                ""Controller: Can't create spreads from options with different types""
            );

            // Check that the options have a matching oracle
            require(
                qTokenToMint.oracle() == qTokenForCollateral.oracle(),
                ""Controller: Can't create spreads from options with different oracles""
            );
        } else {
            // we're not getting the collateral requirement for a spread
            qTokenForCollateralStrikePrice = 0;
        }

        collateralAmount = getOptionCollateralRequirement(
            qTokenToMintStrikePrice,
            qTokenForCollateralStrikePrice,
            _optionsAmount,
            qTokenToMint.isCall(),
            _optionsDecimals,
            _underlyingDecimals,
            _strikeAssetDecimals
        );

        collateral = qTokenToMint.isCall()
            ? qTokenToMint.underlyingAsset()
            : qTokenToMint.strikeAsset();
    }

    /// @notice Calculates payout of an option post-expiry from qToken attributes
    /// @param _isCall true if the option is a call, false for a put
    /// @param _strikePrice the strike price of the option
    /// @param _amount the amount of options being exercised
    /// @param _optionsDecimals option decimals constant. qTokens have 18 decimals
    /// @param _strikeAssetDecimals the amount of decimals the strike asset has
    /// @param _expiryPrice the expiry price of the option with the amount of decimals
    /// @return payoutAmount the amount to be payed out as a fixed point type
    function getPayoutAmount(
        bool _isCall,
        uint256 _strikePrice,
        uint256 _amount,
        uint8 _optionsDecimals,
        uint8 _strikeAssetDecimals,
        IPriceRegistry.PriceWithDecimals memory _expiryPrice
    ) internal pure returns (QuantMath.FixedPointInt memory payoutAmount) {
        FundsCalculator.OptionPayoutInput memory payoutInput = FundsCalculator
            .OptionPayoutInput(
                _strikePrice.fromScaledUint(_strikeAssetDecimals),
                _expiryPrice.price.fromScaledUint(_expiryPrice.decimals),
                _amount.fromScaledUint(_optionsDecimals)
            );

        if (_isCall) {
            payoutAmount = getPayoutForCall(payoutInput);
        } else {
            payoutAmount = getPayoutForPut(payoutInput);
        }
    }

    /// @notice Calculates payout of a call given option payout inputs of strike, expiry and amount
    /// @param payoutInput strike, expiry and amount as fixed points
    /// @return payoutAmount the amount to be payed out as a fixed point type
    function getPayoutForCall(
        FundsCalculator.OptionPayoutInput memory payoutInput
    ) internal pure returns (QuantMath.FixedPointInt memory payoutAmount) {
        payoutAmount = payoutInput.expiryPrice.isGreaterThan(
            payoutInput.strikePrice
        )
            ? payoutInput
                .expiryPrice
                .sub(payoutInput.strikePrice)
                .mul(payoutInput.amount)
                .div(payoutInput.expiryPrice)
            : int256(0).fromUnscaledInt();
    }

    /// @notice Calculates payout of a put given option payout inputs of strike, expiry and amount
    /// @param payoutInput strike, expiry and amount as fixed points
    /// @return payoutAmount the amount to be payed out as a fixed point type
    function getPayoutForPut(
        FundsCalculator.OptionPayoutInput memory payoutInput
    ) internal pure returns (QuantMath.FixedPointInt memory payoutAmount) {
        payoutAmount = payoutInput.strikePrice.isGreaterThan(
            payoutInput.expiryPrice
        )
            ? (payoutInput.strikePrice.sub(payoutInput.expiryPrice)).mul(
                payoutInput.amount
            )
            : int256(0).fromUnscaledInt();
    }

    /// @notice Calculates the collateral required to mint an option or spread
    /// @param _qTokenToMintStrikePrice the strike price of the qToken being minted 
    /// @param _qTokenForCollateralStrikePrice the strike price of the qToken being used as
    /// collateral in the case of a spread
    /// @param _optionsAmount the amount of options/spread being minted
    /// @param _qTokenToMintIsCall whether or not the token to mint is a call. if a spread,
    /// the qToken as collateral is implicitly also a call. and for minting a put, the 
    /// qToken as collateral is implicitly also a put
    /// @param _optionsDecimals option decimals constant. qTokens have 18 decimals
    /// @param _underlyingDecimals the amount of decimals the underlying asset has
    /// @param _strikeAssetDecimals the amount of decimals the strike asset has
    /// @return collateralAmount the collateral amount required as a fixed point type    
    function getOptionCollateralRequirement(
        uint256 _qTokenToMintStrikePrice,
        uint256 _qTokenForCollateralStrikePrice,
        uint256 _optionsAmount,
        bool _qTokenToMintIsCall,
        uint8 _optionsDecimals,
        uint8 _underlyingDecimals,
        uint8 _strikeAssetDecimals
    ) internal pure returns (QuantMath.FixedPointInt memory collateralAmount) {
        QuantMath.FixedPointInt memory collateralPerOption;
        if (_qTokenToMintIsCall) {
            collateralPerOption = getCallCollateralRequirement(
                _qTokenToMintStrikePrice,
                _qTokenForCollateralStrikePrice,
                _underlyingDecimals,
                _strikeAssetDecimals
            );
        } else {
            collateralPerOption = getPutCollateralRequirement(
                _qTokenToMintStrikePrice,
                _qTokenForCollateralStrikePrice,
                _strikeAssetDecimals
            );
        }

        collateralAmount = _optionsAmount.fromScaledUint(_optionsDecimals).mul(
            collateralPerOption
        );
    }

    /// @notice Calculates the collateral required to mint a single PUT option or PUT spread
    /// @param _qTokenToMintStrikePrice the strike price of the PUT qToken being minted 
    /// @param _qTokenForCollateralStrikePrice the strike price of the PUT qToken being used as
    /// collateral in the case of a spread
    /// @param _strikeAssetDecimals the amount of decimals the strike asset has
    /// @return collateralPerOption the collateral amount required per option as a fixed point type
    function getPutCollateralRequirement(
        uint256 _qTokenToMintStrikePrice,
        uint256 _qTokenForCollateralStrikePrice,
        uint8 _strikeAssetDecimals
    )
        internal
        pure
        returns (QuantMath.FixedPointInt memory collateralPerOption)
    {
        QuantMath.FixedPointInt
            memory mintStrikePrice = _qTokenToMintStrikePrice.fromScaledUint(
                _strikeAssetDecimals
            );
        QuantMath.FixedPointInt
            memory collateralStrikePrice = _qTokenForCollateralStrikePrice
                .fromScaledUint(_strikeAssetDecimals);

        // Initially (non-spread) required collateral is the long strike price
        collateralPerOption = mintStrikePrice;

        if (_qTokenForCollateralStrikePrice > 0) {
            collateralPerOption = mintStrikePrice.isGreaterThan(
                collateralStrikePrice
            )
                ? mintStrikePrice.sub(collateralStrikePrice) // Put Credit Spread
                : int256(0).fromUnscaledInt(); // Put Debit Spread
        }
    }

    /// @notice Calculates the collateral required to mint a single CALL option or CALL spread
    /// @param _qTokenToMintStrikePrice the strike price of the CALL qToken being minted 
    /// @param _qTokenForCollateralStrikePrice the strike price of the CALL qToken being
    /// used as collateral in the case of a spread
    /// @param _underlyingDecimals the amount of decimals the underlying asset has
    /// @param _strikeAssetDecimals the amount of decimals the strike asset has
    /// @return collateralPerOption the collateral amount required per option as a fixed point type
    function getCallCollateralRequirement(
        uint256 _qTokenToMintStrikePrice,
        uint256 _qTokenForCollateralStrikePrice,
        uint8 _underlyingDecimals,
        uint8 _strikeAssetDecimals
    )
        internal
        pure
        returns (QuantMath.FixedPointInt memory collateralPerOption)
    {
        QuantMath.FixedPointInt
            memory mintStrikePrice = _qTokenToMintStrikePrice.fromScaledUint(
                _strikeAssetDecimals
            );
        QuantMath.FixedPointInt
            memory collateralStrikePrice = _qTokenForCollateralStrikePrice
                .fromScaledUint(_strikeAssetDecimals);

        // Initially (non-spread) required collateral is the long strike price
        collateralPerOption = (10**_underlyingDecimals).fromScaledUint(
            _underlyingDecimals
        );

        if (_qTokenForCollateralStrikePrice > 0) {
            collateralPerOption = mintStrikePrice.isGreaterThanOrEqual(
                collateralStrikePrice
            )
                ? int256(0).fromUnscaledInt() // Call Debit Spread
                : (collateralStrikePrice.sub(mintStrikePrice)).div(
                    collateralStrikePrice
                ); // Call Credit Spread
        }
    }
}",2959
RealWorld_BA_98_Controller_RealWord_20240826234107.log,98,Controller,73508,6065,79573,100.0,0.48884,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.12;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";
import ""./QuantConfig.sol"";
import ""./utils/EIP712MetaTransaction.sol"";
import ""./utils/OperateProxy.sol"";
import ""./interfaces/IQToken.sol"";
import ""./interfaces/IOracleRegistry.sol"";
import ""./interfaces/ICollateralToken.sol"";
import ""./interfaces/IController.sol"";
import ""./interfaces/IOperateProxy.sol"";
import ""./interfaces/IQuantCalculator.sol"";
import ""./interfaces/IOptionsFactory.sol"";
import ""./libraries/ProtocolValue.sol"";
import ""./libraries/QuantMath.sol"";
import ""./libraries/OptionsUtils.sol"";
import ""./libraries/Actions.sol"";

/// @title The main entry point in the Quant Protocol
/// @author Rolla
/// @notice Handles minting options and spreads, exercising, claiming collateral and neutralizing positions.
/// @dev This contract has no receive method, and also no way to recover tokens sent to it by accident.
/// Its balance of options or any other tokens are never used in any calculations, so there is no risk if that happens.
/// @dev This contract is an upgradeable proxy, and it supports meta transactions.
/// @dev The Controller holds all the collateral used to mint options. Options need to be created through the
/// OptionsFactory first.
contract Controller is
    IController,
    EIP712MetaTransaction,
    ReentrancyGuardUpgradeable
{
    using SafeERC20 for IERC20;
    using QuantMath for QuantMath.FixedPointInt;
    using Actions for ActionArgs;

    /// @inheritdoc IController
    address public override optionsFactory;

    /// @inheritdoc IController
    address public override operateProxy;

    /// @inheritdoc IController
    address public override quantCalculator;

    /// @inheritdoc IController
    function operate(ActionArgs[] memory _actions)
        external
        override
        nonReentrant
        returns (bool)
    {
        uint256 length = _actions.length;
        for (uint256 i = 0; i < length; ) {
            ActionArgs memory action = _actions[i];

            if (action.actionType == ActionType.MintOption) {
                (address to, address qToken, uint256 amount) = action
                    .parseMintOptionArgs();
                _mintOptionsPosition(to, qToken, amount);
            } else if (action.actionType == ActionType.MintSpread) {
                (
                    address qTokenToMint,
                    address qTokenForCollateral,
                    uint256 amount
                ) = action.parseMintSpreadArgs();
                _mintSpread(qTokenToMint, qTokenForCollateral, amount);
            } else if (action.actionType == ActionType.Exercise) {
                (address qToken, uint256 amount) = action.parseExerciseArgs();
                _exercise(qToken, amount);
            } else if (action.actionType == ActionType.ClaimCollateral) {
                (uint256 collateralTokenId, uint256 amount) = action
                    .parseClaimCollateralArgs();
                _claimCollateral(collateralTokenId, amount);
            } else if (action.actionType == ActionType.Neutralize) {
                (uint256 collateralTokenId, uint256 amount) = action
                    .parseNeutralizeArgs();
                _neutralizePosition(collateralTokenId, amount);
            } else if (action.actionType == ActionType.QTokenPermit) {
                (
                    address qToken,
                    address owner,
                    address spender,
                    uint256 value,
                    uint256 deadline,
                    uint8 v,
                    bytes32 r,
                    bytes32 s
                ) = action.parseQTokenPermitArgs();
                _qTokenPermit(qToken, owner, spender, value, deadline, v, r, s);
            } else if (
                action.actionType == ActionType.CollateralTokenApproval
            ) {
                (
                    address owner,
                    address operator,
                    bool approved,
                    uint256 nonce,
                    uint256 deadline,
                    uint8 v,
                    bytes32 r,
                    bytes32 s
                ) = action.parseCollateralTokenApprovalArgs();
                _collateralTokenApproval(
                    owner,
                    operator,
                    approved,
                    nonce,
                    deadline,
                    v,
                    r,
                    s
                );
            } else {
                require(
                    action.actionType == ActionType.Call,
                    ""Controller: Invalid action type""
                );
                (address callee, bytes memory data) = action.parseCallArgs();
                _call(callee, data);
            }

            unchecked {
                ++i;
            }
        }

        return true;
    }

    // @inheritdoc IController
    function initialize(
        string memory _name,
        string memory _version,
        address _optionsFactory,
        address _quantCalculator
    ) public override initializer {
        require(
            _optionsFactory != address(0),
            ""Controller: invalid OptionsFactory address""
        );
        require(
            _quantCalculator != address(0),
            ""Controller: invalid QuantCalculator address""
        );

        __ReentrancyGuard_init();
        EIP712MetaTransaction.initializeEIP712(_name, _version);
        optionsFactory = _optionsFactory;

        /// @dev Unless this line is removed, a new OperateProxy will be created
        /// during each upgrade. So make sure any application that requires approving
        /// the OperateProxy to spend funds is aware of this.
        operateProxy = address(new OperateProxy());

        quantCalculator = _quantCalculator;
    }

    /// @notice Mints options for a given QToken, which must have been previously created in
    /// the configured OptionsFactory.
    /// @dev The caller (or signer in case of meta transactions) must first approve the Controller
    /// to spend the collateral asset, and then this function can be called, pulling the collateral
    /// from the caller/signer and minting QTokens and CollateralTokens to the given `to` address.
    /// Note that QTokens represent a long position, giving holders the ability to exercise options
    /// after expiry, while CollateralTokens represent a short position, giving holders the ability
    /// to claim the collateral after expiry.
    /// @param _to The address to which the QTokens and CollateralTokens will be minted.
    /// @param _qToken The QToken that represents the long position for the option to be minted.
    /// @param _amount The amount of options to be minted.
    function _mintOptionsPosition(
        address _to,
        address _qToken,
        uint256 _amount
    ) internal returns (uint256) {
        IQToken qToken = IQToken(_qToken);

        // get the collateral required to mint the specified amount of options
        // the zero address is passed as the second argument as it's only used
        // for spreads
        (address collateral, uint256 collateralAmount) = IQuantCalculator(
            quantCalculator
        ).getCollateralRequirement(_qToken, address(0), _amount);

        _checkIfUnexpiredQToken(_qToken);

        // check if the oracle set during the option's creation through the OptionsFactory
        // is an active oracle in the OracleRegistry
        require(
            IOracleRegistry(
                IOptionsFactory(optionsFactory).quantConfig().protocolAddresses(
                    ProtocolValue.encode(""oracleRegistry"")
                )
            ).isOracleActive(qToken.oracle()),
            ""Controller: Can't mint an options position as the oracle is inactive""
        );

        // pull the required collateral from the caller/signer
        IERC20(collateral).safeTransferFrom(
            _msgSender(),
            address(this),
            collateralAmount
        );

        ICollateralToken collateralToken = IOptionsFactory(optionsFactory)
            .collateralToken();

        // Mint the options to the sender's address
        qToken.mint(_to, _amount);
        uint256 collateralTokenId = collateralToken.getCollateralTokenId(
            _qToken,
            address(0)
        );

        // There's no need to check if the collateralTokenId exists before minting because if the QToken is valid,
        // then it's guaranteed that the respective CollateralToken has already also been created by the OptionsFactory
        collateralToken.mintCollateralToken(_to, collateralTokenId, _amount);

        emit OptionsPositionMinted(
            _to,
            _msgSender(),
            _qToken,
            _amount,
            collateral,
            collateralAmount
        );

        return collateralTokenId;
    }

    /// @notice Creates a spread position from an option to long and another option to short.
    /// @dev The caller (or signer in case of meta transactions) must first approve the Controller
    /// to spend the collateral asset in cases of a debit spread.
    /// @param _qTokenToMint The QToken for the option to be long.
    /// @param _qTokenForCollateral The QToken for the option to be short.
    /// @param _amount The amount of long options to be minted.
    function _mintSpread(
        address _qTokenToMint,
        address _qTokenForCollateral,
        uint256 _amount
    ) internal returns (uint256) {
        require(
            _qTokenToMint != _qTokenForCollateral,
            ""Controller: Can only create a spread with different tokens""
        );

        IQToken qTokenToMint = IQToken(_qTokenToMint);
        IQToken qTokenForCollateral = IQToken(_qTokenForCollateral);

        // Calculate the extra collateral required to create the spread.
        // A positive value for debit spreads and zero for credit spreads.
        (address collateral, uint256 collateralAmount) = IQuantCalculator(
            quantCalculator
        ).getCollateralRequirement(
                _qTokenToMint,
                _qTokenForCollateral,
                _amount
            );

        _checkIfUnexpiredQToken(_qTokenToMint);
        _checkIfUnexpiredQToken(_qTokenForCollateral);

        // Burn the QToken being shorted
        qTokenForCollateral.burn(_msgSender(), _amount);

        // Transfer in any collateral required for the spread
        if (collateralAmount > 0) {
            IERC20(collateral).safeTransferFrom(
                _msgSender(),
                address(this),
                collateralAmount
            );
        }

        ICollateralToken collateralToken = IOptionsFactory(optionsFactory)
            .collateralToken();

        // Check if the CollateralToken representing this specific spread has already been created
        // Create it if it hasn't
        uint256 collateralTokenId = collateralToken.getCollateralTokenId(
            _qTokenToMint,
            _qTokenForCollateral
        );
        (, address qTokenAsCollateral) = collateralToken.idToInfo(
            collateralTokenId
        );
        if (qTokenAsCollateral == address(0)) {
            require(
                collateralTokenId ==
                    collateralToken.createCollateralToken(
                        _qTokenToMint,
                        _qTokenForCollateral
                    ),
                ""Controller: failed creating the collateral token to represent the spread""
            );
        }

        // Mint the tokens for the new spread position
        collateralToken.mintCollateralToken(
            _msgSender(),
            collateralTokenId,
            _amount
        );
        qTokenToMint.mint(_msgSender(), _amount);

        emit SpreadMinted(
            _msgSender(),
            _qTokenToMint,
            _qTokenForCollateral,
            _amount,
            collateral,
            collateralAmount
        );

        return collateralTokenId;
    }

    /// @notice Closes a long position after the option's expiry.
    /// @dev Pass an `_amount` of 0 to close the entire position.
    /// @param _qToken The QToken representing the long position to be closed.
    /// @param _amount The amount of options to exercise.
    function _exercise(address _qToken, uint256 _amount) internal {
        IQToken qToken = IQToken(_qToken);
        require(
            block.timestamp > qToken.expiryTime(),
            ""Controller: Can not exercise options before their expiry""
        );

        uint256 amountToExercise = _amount;
        // if the amount is 0, the entire position will be exercised
        if (amountToExercise == 0) {
            amountToExercise = qToken.balanceOf(_msgSender());
        }

        // Use the QuantCalculator to check how much the sender/signer is due.
        // Will only be a positive value for options that expired In The Money.
        (
            bool isSettled,
            address payoutToken,
            uint256 exerciseTotal
        ) = IQuantCalculator(quantCalculator).getExercisePayout(
                address(qToken),
                amountToExercise
            );

        require(isSettled, ""Controller: Cannot exercise unsettled options"");

        // Burn the long tokens
        qToken.burn(_msgSender(), amountToExercise);

        // Transfer any profit due after expiration
        if (exerciseTotal > 0) {
            IERC20(payoutToken).safeTransfer(_msgSender(), exerciseTotal);
        }

        emit OptionsExercised(
            _msgSender(),
            address(qToken),
            amountToExercise,
            exerciseTotal,
            payoutToken
        );
    }

    /// @notice Closes a short position after the option's expiry.
    /// @param _collateralTokenId ERC1155 token id representing the short position to be closed.
    /// @param _amount The size of the position to close.
    function _claimCollateral(uint256 _collateralTokenId, uint256 _amount)
        internal
    {
        uint256 collateralTokenId = _collateralTokenId;

        // Use the QuantCalculator to check how much collateral the sender/signer is due.
        (
            uint256 returnableCollateral,
            address collateralAsset,
            uint256 amountToClaim
        ) = IQuantCalculator(quantCalculator).calculateClaimableCollateral(
                collateralTokenId,
                _amount,
                _msgSender()
            );

        // Burn the short tokens
        IOptionsFactory(optionsFactory).collateralToken().burnCollateralToken(
            _msgSender(),
            collateralTokenId,
            amountToClaim
        );

        // Transfer any collateral due after expiration
        if (returnableCollateral > 0) {
            IERC20(collateralAsset).safeTransfer(
                _msgSender(),
                returnableCollateral
            );
        }

        emit CollateralClaimed(
            _msgSender(),
            collateralTokenId,
            amountToClaim,
            returnableCollateral,
            collateralAsset
        );
    }

    /// @notice Closes a neutral position, claiming all the collateral required to create it.
    /// @dev Unlike `_exercise` and `_claimCollateral`, this function does not require the option to be expired.
    /// @param _collateralTokenId ERC1155 token id representing the position to be closed.
    /// @param _amount The size of the position to close.
    function _neutralizePosition(uint256 _collateralTokenId, uint256 _amount)
        internal
    {
        /// @dev Put these values in the stack to save gas from having to read
        /// from calldata
        (uint256 collateralTokenId, uint256 amount) = (
            _collateralTokenId,
            _amount
        );

        ICollateralToken collateralToken = IOptionsFactory(optionsFactory)
            .collateralToken();
        (address qTokenShort, address qTokenLong) = collateralToken.idToInfo(
            collateralTokenId
        );

        //get the amount of CollateralTokens owned
        uint256 collateralTokensOwned = collateralToken.balanceOf(
            _msgSender(),
            collateralTokenId
        );

        //get the amount of QTokens owned
        uint256 qTokensOwned = IQToken(qTokenShort).balanceOf(_msgSender());

        // the size of the position that can be neutralized
        uint256 maxNeutralizable = qTokensOwned < collateralTokensOwned
            ? qTokensOwned
            : collateralTokensOwned;

        // make sure that the amount passed is not greater than the amount that can be neutralized
        uint256 amountToNeutralize;
        if (amount != 0) {
            require(
                amount <= maxNeutralizable,
                ""Controller: Tried to neutralize more than balance""
            );
            amountToNeutralize = amount;
        } else {
            amountToNeutralize = maxNeutralizable;
        }

        // use the QuantCalculator to check how much collateral the sender/signer is due
        // for closing the neutral position
        (address collateralType, uint256 collateralOwed) = IQuantCalculator(
            quantCalculator
        ).getNeutralizationPayout(qTokenShort, qTokenLong, amountToNeutralize);

        // burn the short tokens
        IQToken(qTokenShort).burn(_msgSender(), amountToNeutralize);

        // burn the long tokens
        collateralToken.burnCollateralToken(
            _msgSender(),
            collateralTokenId,
            amountToNeutralize
        );

        // tranfer the collateral owed
        IERC20(collateralType).safeTransfer(_msgSender(), collateralOwed);

        //give the user their long tokens (if any, in case of CollateralTokens representing a spread)
        if (qTokenLong != address(0)) {
            IQToken(qTokenLong).mint(_msgSender(), amountToNeutralize);
        }

        emit NeutralizePosition(
            _msgSender(),
            qTokenShort,
            amountToNeutralize,
            collateralOwed,
            collateralType,
            qTokenLong
        );
    }

    /// @notice Allows a QToken owner to approve a spender to transfer a specified amount of tokens on their behalf.
    /// @param _qToken The QToken to be approved.
    /// @param _spender The address of the spender.
    /// @param _value The amount of tokens to be approved for spending.
    /// @param _deadline Timestamp at which the permit signature expires.
    /// @param _v The signature's v value.
    /// @param _r The signature's r value.
    /// @param _s The signature's s value.
    function _qTokenPermit(
        address _qToken,
        address _owner,
        address _spender,
        uint256 _value,
        uint256 _deadline,
        uint8 _v,
        bytes32 _r,
        bytes32 _s
    ) internal {
        IQToken(_qToken).permit(
            _owner,
            _spender,
            _value,
            _deadline,
            _v,
            _r,
            _s
        );
    }

    /// @notice Allows a CollateralToken owner to either approve an operator address
    /// to spend all of their tokens on their behalf, or to remove a prior approval.
    /// @param _owner The address of the owner of the CollateralToken.
    /// @param _operator The address of the operator to be approved or removed.
    /// @param _approved Whether the operator is being approved or removed.
    /// @param _nonce The nonce for the approval through a meta transaction.
    /// @param _deadline Timestamp at which the approval signature expires.
    /// @param _v The signature's v value.
    /// @param _r The signature's r value.
    /// @param _s The signature's s value.
    function _collateralTokenApproval(
        address _owner,
        address _operator,
        bool _approved,
        uint256 _nonce,
        uint256 _deadline,
        uint8 _v,
        bytes32 _r,
        bytes32 _s
    ) internal {
        IOptionsFactory(optionsFactory).collateralToken().metaSetApprovalForAll(
                _owner,
                _operator,
                _approved,
                _nonce,
                _deadline,
                _v,
                _r,
                _s
            );
    }

    /// @notice Allows a sender/signer to make external calls to any other contract.
    /// @dev A separate OperateProxy contract is used to make the external calls so
    /// that the Controller, which holds funds and has special privileges in the Quant
    /// Protocol, is never the `msg.sender` in any of those external calls.
    /// @param _callee The address of the contract to be called.
    /// @param _data The calldata to be sent to the contract.
    function _call(address _callee, bytes memory _data) internal {
        IOperateProxy(operateProxy).callFunction(_callee, _data);
    }

    /// @notice Checks if the given QToken has not expired yet, reverting otherwise
    /// @param _qToken The address of the QToken to check.
    function _checkIfUnexpiredQToken(address _qToken) internal view {
        require(
            IQToken(_qToken).expiryTime() > block.timestamp,
            ""Controller: Cannot mint expired options""
        );
    }
}",4451
RealWorld_BA_98_ExternalQToken_RealWord_20240827000730.log,98,ExternalQToken,6206,4759,10965,87.0,0.12621,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.12;

import ""../options/QToken.sol"";

contract ExternalQToken is QToken {
    constructor(
        address _quantConfig,
        address _underlyingAsset,
        address _strikeAsset,
        address _oracle,
        uint256 _strikePrice,
        uint256 _expiryTime,
        bool _isCall
    )
        QToken(
            _quantConfig,
            _underlyingAsset,
            _strikeAsset,
            _oracle,
            _strikePrice,
            _expiryTime,
            _isCall
        )
    // solhint-disable-next-line no-empty-blocks
    {

    }

    function permissionlessMint(address account, uint256 amount) external {
        _mint(account, amount);
        emit QTokenMinted(account, amount);
    }
}",178
RealWorld_BA_98_BasicERC20_RealWord_20240827000441.log,98,BasicERC20,32686,5364,38050,95.0,0.27071,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.12;

import ""@openzeppelin/contracts/utils/Context.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

contract BasicERC20 is Context, IERC20 {
    mapping(address => uint256) private _balances;

    mapping(address => mapping(address => uint256)) private _allowances;

    uint256 private _totalSupply;

    /**
     * @dev See {IERC20-transfer}.
     *
     * Requirements:
     *
     * - `recipient` cannot be the zero address.
     * - the caller must have a balance of at least `amount`.
     */
    function transfer(address recipient, uint256 amount)
        public
        virtual
        override
        returns (bool)
    {
        _transfer(_msgSender(), recipient, amount);
        return true;
    }

    /**
     * @dev See {IERC20-approve}.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function approve(address spender, uint256 amount)
        public
        virtual
        override
        returns (bool)
    {
        _approve(_msgSender(), spender, amount);
        return true;
    }

    /**
     * @dev See {IERC20-transferFrom}.
     *
     * Emits an {Approval} event indicating the updated allowance. This is not
     * required by the EIP. See the note at the beginning of {ERC20}.
     *
     * Requirements:
     *
     * - `sender` and `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `amount`.
     * - the caller must have allowance for ``sender``'s tokens of at least
     * `amount`.
     */
    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) public virtual override returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(
            sender,
            _msgSender(),
            _allowances[sender][_msgSender()] -= amount
        );
        return true;
    }

    /**
     * @dev Atomically increases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to {approve} that can be used as a mitigation for
     * problems described in {IERC20-approve}.
     *
     * Emits an {Approval} event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     */
    function increaseAllowance(address spender, uint256 addedValue)
        public
        virtual
        returns (bool)
    {
        _approve(
            _msgSender(),
            spender,
            _allowances[_msgSender()][spender] + addedValue
        );
        return true;
    }

    /**
     * @dev Atomically decreases the allowance granted to `spender` by the caller.
     *
     * This is an alternative to {approve} that can be used as a mitigation for
     * problems described in {IERC20-approve}.
     *
     * Emits an {Approval} event indicating the updated allowance.
     *
     * Requirements:
     *
     * - `spender` cannot be the zero address.
     * - `spender` must have allowance for the caller of at least
     * `subtractedValue`.
     */
    function decreaseAllowance(address spender, uint256 subtractedValue)
        public
        virtual
        returns (bool)
    {
        _approve(
            _msgSender(),
            spender,
            _allowances[_msgSender()][spender] -= subtractedValue
        );
        return true;
    }

    /**
     * @dev See {IERC20-totalSupply}.
     */
    function totalSupply() public view virtual override returns (uint256) {
        return _totalSupply;
    }

    /**
     * @dev See {IERC20-balanceOf}.
     */
    function balanceOf(address account)
        public
        view
        virtual
        override
        returns (uint256)
    {
        return _balances[account];
    }

    /**
     * @dev See {IERC20-allowance}.
     */
    function allowance(address owner, address spender)
        public
        view
        virtual
        override
        returns (uint256)
    {
        return _allowances[owner][spender];
    }

    /**
     * @dev Moves tokens `amount` from `sender` to `recipient`.
     *
     * This is internal function is equivalent to {transfer}, and can be used to
     * e.g. implement automatic token fees, slashing mechanisms, etc.
     *
     * Emits a {Transfer} event.
     *
     * Requirements:
     *
     * - `sender` cannot be the zero address.
     * - `recipient` cannot be the zero address.
     * - `sender` must have a balance of at least `amount`.
     */
    function _transfer(
        address sender,
        address recipient,
        uint256 amount
    ) internal virtual {
        require(sender != address(0), ""ERC20: transfer from the zero address"");
        require(recipient != address(0), ""ERC20: transfer to the zero address"");

        _beforeTokenTransfer(sender, recipient, amount);

        _balances[sender] -= amount;
        _balances[recipient] += amount;
        emit Transfer(sender, recipient, amount);
    }

    /** @dev Creates `amount` tokens and assigns them to `account`, increasing
     * the total supply.
     *
     * Emits a {Transfer} event with `from` set to the zero address.
     *
     * Requirements:
     *
     * - `to` cannot be the zero address.
     */
    function _mint(address account, uint256 amount) internal virtual {
        require(account != address(0), ""ERC20: mint to the zero address"");

        _beforeTokenTransfer(address(0), account, amount);

        _totalSupply += amount;
        _balances[account] += amount;
        emit Transfer(address(0), account, amount);
    }

    /**
     * @dev Destroys `amount` tokens from `account`, reducing the
     * total supply.
     *
     * Emits a {Transfer} event with `to` set to the zero address.
     *
     * Requirements:
     *
     * - `account` cannot be the zero address.
     * - `account` must have at least `amount` tokens.
     */
    function _burn(address account, uint256 amount) internal virtual {
        require(account != address(0), ""ERC20: burn from the zero address"");

        _beforeTokenTransfer(account, address(0), amount);

        _balances[account] -= amount;
        _totalSupply -= amount;
        emit Transfer(account, address(0), amount);
    }

    /**
     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.
     *
     * This internal function is equivalent to `approve`, and can be used to
     * e.g. set automatic allowances for certain subsystems, etc.
     *
     * Emits an {Approval} event.
     *
     * Requirements:
     *
     * - `owner` cannot be the zero address.
     * - `spender` cannot be the zero address.
     */
    function _approve(
        address owner,
        address spender,
        uint256 amount
    ) internal virtual {
        require(owner != address(0), ""ERC20: approve from the zero address"");
        require(spender != address(0), ""ERC20: approve to the zero address"");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }

    /**
     * @dev Hook that is called before any transfer of tokens. This includes
     * minting and burning.
     *
     * Calling conditions:
     *
     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens
     * will be to transferred to `to`.
     * - when `from` is zero, `amount` tokens will be minted for `to`.
     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.
     * - `from` and `to` are never both zero.
     *
     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
     */
    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 amount // solhint-disable-next-line no-empty-blocks
    ) internal virtual {}
}",1835
RealWorld_BA_98_ControllerV2_RealWord_20240827001349.log,98,ControllerV2,50960,5842,56802,94.0,0.37164,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.12;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";
import ""../QuantConfig.sol"";
import ""../utils/EIP712MetaTransaction.sol"";
import ""../utils/OperateProxy.sol"";
import ""../interfaces/IQToken.sol"";
import ""../interfaces/IOracleRegistry.sol"";
import ""../interfaces/ICollateralToken.sol"";
import ""../interfaces/IController.sol"";
import ""../interfaces/IOperateProxy.sol"";
import ""../interfaces/IQuantCalculator.sol"";
import ""../interfaces/IOptionsFactory.sol"";
import ""../libraries/ProtocolValue.sol"";
import ""../libraries/QuantMath.sol"";
import ""../libraries/FundsCalculator.sol"";
import ""../libraries/OptionsUtils.sol"";
import ""../libraries/Actions.sol"";

contract ControllerV2 is
    IController,
    EIP712MetaTransaction,
    ReentrancyGuardUpgradeable
{
    using SafeERC20 for IERC20;
    using QuantMath for QuantMath.FixedPointInt;
    using Actions for ActionArgs;

    address public override optionsFactory;

    address public override operateProxy;

    address public override quantCalculator;

    uint256 public newV2StateVariable;

    function operate(ActionArgs[] memory _actions)
        external
        override
        nonReentrant
        returns (bool)
    {
        for (uint256 i = 0; i < _actions.length; i++) {
            ActionArgs memory action = _actions[i];

            if (action.actionType == ActionType.MintOption) {
                (address to, address qToken, uint256 amount) = action
                    .parseMintOptionArgs();
                _mintOptionsPosition(to, qToken, amount);
            } else if (action.actionType == ActionType.MintSpread) {
                (
                    address qTokenToMint,
                    address qTokenForCollateral,
                    uint256 amount
                ) = action.parseMintSpreadArgs();
                _mintSpread(qTokenToMint, qTokenForCollateral, amount);
            } else if (action.actionType == ActionType.Exercise) {
                (address qToken, uint256 amount) = action.parseExerciseArgs();
                _exercise(qToken, amount);
            } else if (action.actionType == ActionType.ClaimCollateral) {
                (uint256 collateralTokenId, uint256 amount) = action
                    .parseClaimCollateralArgs();
                _claimCollateral(collateralTokenId, amount);
            } else if (action.actionType == ActionType.Neutralize) {
                (uint256 collateralTokenId, uint256 amount) = action
                    .parseNeutralizeArgs();
                _neutralizePosition(collateralTokenId, amount);
            } else if (action.actionType == ActionType.QTokenPermit) {
                (
                    address qToken,
                    address owner,
                    address spender,
                    uint256 value,
                    uint256 deadline,
                    uint8 v,
                    bytes32 r,
                    bytes32 s
                ) = action.parseQTokenPermitArgs();
                _qTokenPermit(qToken, owner, spender, value, deadline, v, r, s);
            } else if (
                action.actionType == ActionType.CollateralTokenApproval
            ) {
                (
                    address owner,
                    address operator,
                    bool approved,
                    uint256 nonce,
                    uint256 deadline,
                    uint8 v,
                    bytes32 r,
                    bytes32 s
                ) = action.parseCollateralTokenApprovalArgs();
                _collateralTokenApproval(
                    owner,
                    operator,
                    approved,
                    nonce,
                    deadline,
                    v,
                    r,
                    s
                );
            } else {
                require(
                    action.actionType == ActionType.Call,
                    ""Controller: Invalid action type""
                );
                (address callee, bytes memory data) = action.parseCallArgs();
                _call(callee, data);
            }
        }

        return true;
    }

    function setNewV2StateVariable(uint256 _value) external {
        newV2StateVariable = _value;
    }

    function initialize(
        string memory _name,
        string memory _version,
        address _optionsFactory,
        address _quantCalculator
    ) public override initializer {
        require(
            _optionsFactory != address(0),
            ""Controller: invalid OptionsFactory address""
        );
        require(
            _quantCalculator != address(0),
            ""Controller: invalid QuantCalculator address""
        );

        __ReentrancyGuard_init();
        EIP712MetaTransaction.initializeEIP712(_name, _version);
        optionsFactory = _optionsFactory;
        operateProxy = address(new OperateProxy());
        quantCalculator = _quantCalculator;
    }

    function _mintOptionsPosition(
        address _to,
        address _qToken,
        uint256 _amount
    ) internal returns (uint256) {
        IQToken qToken = IQToken(_qToken);

        (address collateral, uint256 collateralAmount) = IQuantCalculator(
            quantCalculator
        ).getCollateralRequirement(_qToken, address(0), _amount);

        _checkIfUnexpiredQToken(_qToken);

        require(
            IOracleRegistry(
                IOptionsFactory(optionsFactory).quantConfig().protocolAddresses(
                    ProtocolValue.encode(""oracleRegistry"")
                )
            ).isOracleActive(qToken.oracle()),
            ""Controller: Can't mint an options position as the oracle is inactive""
        );

        IERC20(collateral).safeTransferFrom(
            _msgSender(),
            address(this),
            collateralAmount
        );

        ICollateralToken collateralToken = IOptionsFactory(optionsFactory)
            .collateralToken();

        // Mint the options to the sender's address
        qToken.mint(_to, _amount);
        uint256 collateralTokenId = collateralToken.getCollateralTokenId(
            _qToken,
            address(0)
        );

        // There's no need to check if the collateralTokenId exists before minting because if the QToken is valid,
        // then it's guaranteed that the respective CollateralToken has already also been created by the OptionsFactory
        collateralToken.mintCollateralToken(_to, collateralTokenId, _amount);

        emit OptionsPositionMinted(
            _to,
            _msgSender(),
            _qToken,
            _amount,
            collateral,
            collateralAmount
        );

        return collateralTokenId;
    }

    function _mintSpread(
        address _qTokenToMint,
        address _qTokenForCollateral,
        uint256 _amount
    ) internal returns (uint256) {
        require(
            _qTokenToMint != _qTokenForCollateral,
            ""Controller: Can only create a spread with different tokens""
        );

        IQToken qTokenToMint = IQToken(_qTokenToMint);
        IQToken qTokenForCollateral = IQToken(_qTokenForCollateral);

        (address collateral, uint256 collateralAmount) = IQuantCalculator(
            quantCalculator
        ).getCollateralRequirement(
                _qTokenToMint,
                _qTokenForCollateral,
                _amount
            );

        _checkIfUnexpiredQToken(_qTokenToMint);
        _checkIfUnexpiredQToken(_qTokenForCollateral);

        qTokenForCollateral.burn(_msgSender(), _amount);

        if (collateralAmount > 0) {
            IERC20(collateral).safeTransferFrom(
                _msgSender(),
                address(this),
                collateralAmount
            );
        }

        ICollateralToken collateralToken = IOptionsFactory(optionsFactory)
            .collateralToken();

        // Check if the corresponding CollateralToken has already been created
        // Create it if it hasn't
        uint256 collateralTokenId = collateralToken.getCollateralTokenId(
            _qTokenToMint,
            _qTokenForCollateral
        );
        (, address qTokenAsCollateral) = collateralToken.idToInfo(
            collateralTokenId
        );
        if (qTokenAsCollateral == address(0)) {
            require(
                collateralTokenId ==
                    collateralToken.createCollateralToken(
                        _qTokenToMint,
                        _qTokenForCollateral
                    ),
                ""Controller: failed creating the collateral token to represent the spread""
            );
        }

        collateralToken.mintCollateralToken(
            _msgSender(),
            collateralTokenId,
            _amount
        );

        qTokenToMint.mint(_msgSender(), _amount);

        emit SpreadMinted(
            _msgSender(),
            _qTokenToMint,
            _qTokenForCollateral,
            _amount,
            collateral,
            collateralAmount
        );

        return collateralTokenId;
    }

    function _exercise(address _qToken, uint256 _amount) internal {
        IQToken qToken = IQToken(_qToken);
        require(
            block.timestamp > qToken.expiryTime(),
            ""Controller: Can not exercise options before their expiry""
        );

        uint256 amountToExercise = _amount;
        if (amountToExercise == 0) {
            amountToExercise = qToken.balanceOf(_msgSender());
        }

        (
            bool isSettled,
            address payoutToken,
            uint256 exerciseTotal
        ) = IQuantCalculator(quantCalculator).getExercisePayout(
                address(qToken),
                amountToExercise
            );

        require(isSettled, ""Controller: Cannot exercise unsettled options"");

        qToken.burn(_msgSender(), amountToExercise);

        if (exerciseTotal > 0) {
            IERC20(payoutToken).safeTransfer(_msgSender(), exerciseTotal);
        }

        emit OptionsExercised(
            _msgSender(),
            address(qToken),
            amountToExercise,
            exerciseTotal,
            payoutToken
        );
    }

    function _claimCollateral(uint256 _collateralTokenId, uint256 _amount)
        internal
    {
        uint256 collateralTokenId = _collateralTokenId;

        (
            uint256 returnableCollateral,
            address collateralAsset,
            uint256 amountToClaim
        ) = IQuantCalculator(quantCalculator).calculateClaimableCollateral(
                collateralTokenId,
                _amount,
                _msgSender()
            );

        IOptionsFactory(optionsFactory).collateralToken().burnCollateralToken(
            _msgSender(),
            collateralTokenId,
            amountToClaim
        );

        if (returnableCollateral > 0) {
            IERC20(collateralAsset).safeTransfer(
                _msgSender(),
                returnableCollateral
            );
        }

        emit CollateralClaimed(
            _msgSender(),
            collateralTokenId,
            amountToClaim,
            returnableCollateral,
            collateralAsset
        );
    }

    function _neutralizePosition(uint256 _collateralTokenId, uint256 _amount)
        internal
    {
        (uint256 collateralTokenId, uint256 amount) = (
            _collateralTokenId,
            _amount
        );

        ICollateralToken collateralToken = IOptionsFactory(optionsFactory)
            .collateralToken();
        (address qTokenShort, address qTokenLong) = collateralToken.idToInfo(
            collateralTokenId
        );

        //get the amount of collateral tokens owned
        uint256 collateralTokensOwned = collateralToken.balanceOf(
            _msgSender(),
            collateralTokenId
        );

        //get the amount of qTokens owned
        uint256 qTokensOwned = IQToken(qTokenShort).balanceOf(_msgSender());

        //the amount of position that can be neutralized
        uint256 maxNeutralizable = qTokensOwned < collateralTokensOwned
            ? qTokensOwned
            : collateralTokensOwned;

        uint256 amountToNeutralize;

        if (amount != 0) {
            require(
                amount <= maxNeutralizable,
                ""Controller: Tried to neutralize more than balance""
            );
            amountToNeutralize = amount;
        } else {
            amountToNeutralize = maxNeutralizable;
        }

        (address collateralType, uint256 collateralOwed) = IQuantCalculator(
            quantCalculator
        ).getNeutralizationPayout(qTokenShort, qTokenLong, amountToNeutralize);

        IQToken(qTokenShort).burn(_msgSender(), amountToNeutralize);

        collateralToken.burnCollateralToken(
            _msgSender(),
            collateralTokenId,
            amountToNeutralize
        );

        IERC20(collateralType).safeTransfer(_msgSender(), collateralOwed);

        //give the user their long tokens (if any)
        if (qTokenLong != address(0)) {
            IQToken(qTokenLong).mint(_msgSender(), amountToNeutralize);
        }

        emit NeutralizePosition(
            _msgSender(),
            qTokenShort,
            amountToNeutralize,
            collateralOwed,
            collateralType,
            qTokenLong
        );
    }

    function _qTokenPermit(
        address _qToken,
        address _owner,
        address _spender,
        uint256 _value,
        uint256 _deadline,
        uint8 _v,
        bytes32 _r,
        bytes32 _s
    ) internal {
        IQToken(_qToken).permit(
            _owner,
            _spender,
            _value,
            _deadline,
            _v,
            _r,
            _s
        );
    }

    function _collateralTokenApproval(
        address _owner,
        address _operator,
        bool _approved,
        uint256 _nonce,
        uint256 _deadline,
        uint8 _v,
        bytes32 _r,
        bytes32 _s
    ) internal {
        IOptionsFactory(optionsFactory).collateralToken().metaSetApprovalForAll(
                _owner,
                _operator,
                _approved,
                _nonce,
                _deadline,
                _v,
                _r,
                _s
            );
    }

    function _call(address _callee, bytes memory _data) internal {
        IOperateProxy(operateProxy).callFunction(_callee, _data);
    }

    function _checkIfUnexpiredQToken(address _qToken) internal view {
        require(
            IQToken(_qToken).expiryTime() > block.timestamp,
            ""Controller: Cannot mint expired options""
        );
    }
}",3022
RealWorld_BA_98_ConfigTimelockController_RealWord_20240826235408.log,98,ConfigTimelockController,83585,6083,89668,122.0,0.539585,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.12;

import ""./TimelockController.sol"";
import ""../interfaces/IQuantConfig.sol"";
import ""../libraries/ProtocolValue.sol"";

/// @title Timelock controller contract for setting values in the QuantConfig and scheduling calls
/// to external contracts.
/// @author Rolla
/// @dev Built on top of OpenZeppelin's TimelockController.
contract ConfigTimelockController is TimelockController {
    mapping(bytes32 => uint256) public delays;

    mapping(bytes32 => uint256) private _timestamps;

    /// @notice The minimum delay for scheduled executions
    uint256 public minDelay;

    constructor(
        uint256 _minDelay,
        address[] memory _proposers,
        address[] memory _executors
    )
        TimelockController(_minDelay, _proposers, _executors)
    // solhint-disable-next-line no-empty-blocks
    {
        minDelay = _minDelay;
    }

    /// @notice Sets the delay for a specific protocol value
    /// @param _protocolValue the bytes32 encoded representation of the protocol value
    /// @param _newDelay the delay in seconds
    function setDelay(bytes32 _protocolValue, uint256 _newDelay)
        external
        onlyRole(EXECUTOR_ROLE)
    {
        // Delays must be greater than or equal to the minimum delay
        delays[_protocolValue] = _newDelay >= minDelay ? _newDelay : minDelay;
    }

    /// @inheritdoc TimelockController
    function schedule(
        address target,
        uint256 value,
        bytes memory data,
        bytes32 predecessor,
        bytes32 salt,
        uint256 delay,
        bool
    ) public virtual override onlyRole(PROPOSER_ROLE) {
        require(
            !_isProtocoValueSetter(data),
            ""ConfigTimelockController: Can not schedule changes to a protocol value with an arbitrary delay""
        );

        super.schedule(target, value, data, predecessor, salt, delay, false);
    }

    /// @notice Schedule a call to set a protocol address in the QuantConfig contract
    /// @param protocolAddress the encoded name of the protocol address variable to set in the config
    /// @param newAddress the new address value to set
    /// @param quantConfig the address of the QuantConfig contract
    /// @param eta timestamp from which the scheduled call can be executed
    function scheduleSetProtocolAddress(
        bytes32 protocolAddress,
        address newAddress,
        address quantConfig,
        uint256 eta
    ) public onlyRole(PROPOSER_ROLE) {
        bytes memory data = _encodeSetProtocolAddress(
            protocolAddress,
            newAddress,
            quantConfig
        );

        uint256 delay = _getProtocolValueDelay(
            quantConfig,
            protocolAddress,
            ProtocolValue.Type.Address
        );

        require(
            eta >= delay + block.timestamp,
            ""ConfigTimelockController: Estimated execution block must satisfy delay""
        );

        super.schedule(
            quantConfig,
            0,
            data,
            bytes32(0),
            bytes32(eta),
            delay,
            true
        );
    }

    /// @notice Schedule a call to set a protocol uint256 in the QuantConfig contract
    /// @param protocolUint256 the encoded name of the protocol uint256 variable to set in the config
    /// @param newUint256 the new uint256 value to set
    /// @param quantConfig the address of the QuantConfig contract
    /// @param eta timestamp from which the scheduled call can be executed
    function scheduleSetProtocolUint256(
        bytes32 protocolUint256,
        uint256 newUint256,
        address quantConfig,
        uint256 eta
    ) public onlyRole(PROPOSER_ROLE) {
        bytes memory data = _encodeSetProtocolUint256(
            protocolUint256,
            newUint256,
            quantConfig
        );

        uint256 delay = _getProtocolValueDelay(
            quantConfig,
            protocolUint256,
            ProtocolValue.Type.Uint256
        );

        require(
            eta >= delay + block.timestamp,
            ""ConfigTimelockController: Estimated execution block must satisfy delay""
        );

        super.schedule(
            quantConfig,
            0,
            data,
            bytes32(0),
            bytes32(eta),
            delay,
            true
        );
    }

    /// @notice Schedule a call to set a protocol boolean in the QuantConfig contract
    /// @param protocolBoolean the encoded name of the protocol boolean variable to set in the config
    /// @param newBoolean the new boolean value to set
    /// @param quantConfig the address of the QuantConfig contract
    /// @param eta timestamp from which the scheduled call can be executed
    function scheduleSetProtocolBoolean(
        bytes32 protocolBoolean,
        bool newBoolean,
        address quantConfig,
        uint256 eta
    ) public onlyRole(PROPOSER_ROLE) {
        bytes memory data = _encodeSetProtocolBoolean(
            protocolBoolean,
            newBoolean,
            quantConfig
        );

        uint256 delay = _getProtocolValueDelay(
            quantConfig,
            protocolBoolean,
            ProtocolValue.Type.Bool
        );

        require(
            eta >= delay + block.timestamp,
            ""ConfigTimelockController: Estimated execution block must satisfy delay""
        );
        super.schedule(
            quantConfig,
            0,
            data,
            bytes32(0),
            bytes32(eta),
            delay,
            true
        );
    }

    /// @notice Schedule a call to set a protocol role in the QuantConfig contract
    /// @param protocolRole the name of the protocol role variable to set in the config
    /// @param roleAdmin address to be the role admin
    /// @param quantConfig the address of the QuantConfig contract
    /// @param eta timestamp from which the scheduled call can be executed
    function scheduleSetProtocolRole(
        string calldata protocolRole,
        address roleAdmin,
        address quantConfig,
        uint256 eta
    ) public onlyRole(PROPOSER_ROLE) {
        bytes memory data = _encodeSetProtocolRole(
            protocolRole,
            roleAdmin,
            quantConfig
        );

        uint256 delay = _getProtocolValueDelay(
            quantConfig,
            keccak256(abi.encodePacked(protocolRole)),
            ProtocolValue.Type.Role
        );

        require(
            eta >= delay + block.timestamp,
            ""ConfigTimelockController: Estimated execution block must satisfy delay""
        );

        super.schedule(
            quantConfig,
            0,
            data,
            bytes32(0),
            bytes32(eta),
            delay,
            true
        );
    }

    /// @notice Schedule multiple contract calls
    /// @dev Cannot schedule calls to set protocol values in the QuantConfig
    /// @param targets array of contracts to receive the scheduled calls
    /// @param values array of values to be sent to the contracts
    /// @param datas array of data to be sent to the contracts
    /// @param predecessor extra 32 bytes to be used when hashing the operation batch
    /// @param salt salt to be used when hashing the operation batch
    /// @param delay execution delay in seconds
    function scheduleBatch(
        address[] memory targets,
        uint256[] memory values,
        bytes[] memory datas,
        bytes32 predecessor,
        bytes32 salt,
        uint256 delay
    ) public virtual override onlyRole(PROPOSER_ROLE) {
        uint256 length = targets.length;
        for (uint256 i = 0; i < length; ) {
            require(
                !_isProtocoValueSetter(datas[i]),
                ""ConfigTimelockController: Can not schedule changes to a protocol value with an arbitrary delay""
            );
            unchecked {
                ++i;
            }
        }

        super.scheduleBatch(targets, values, datas, predecessor, salt, delay);
    }

    /// @notice Schedule multiple calls to set protocol address values in the QuantConfig
    /// @param protocolValues array of protocol address values to be set
    /// @param newAddresses array of new addresses to be set
    /// @param quantConfig the address of the QuantConfig contract
    /// @param eta timestamp from which the scheduled calls can be executed
    function scheduleBatchSetProtocolAddress(
        bytes32[] calldata protocolValues,
        address[] calldata newAddresses,
        address quantConfig,
        uint256 eta
    ) public onlyRole(PROPOSER_ROLE) {
        uint256 length = protocolValues.length;

        require(
            length == newAddresses.length,
            ""ConfigTimelockController: length mismatch""
        );

        for (uint256 i = 0; i < length; ) {
            scheduleSetProtocolAddress(
                protocolValues[i],
                newAddresses[i],
                quantConfig,
                eta
            );
            unchecked {
                ++i;
            }
        }
    }

    /// @notice Schedule multiple calls to set protocol uint256 values in the QuantConfig
    /// @param protocolValues array of protocol uint256 values to be set
    /// @param newUints array of new uints to be set
    /// @param quantConfig the address of the QuantConfig contract
    /// @param eta timestamp from which the scheduled calls can be executed
    function scheduleBatchSetProtocolUints(
        bytes32[] calldata protocolValues,
        uint256[] calldata newUints,
        address quantConfig,
        uint256 eta
    ) public onlyRole(PROPOSER_ROLE) {
        uint256 length = protocolValues.length;

        require(
            length == newUints.length,
            ""ConfigTimelockController: length mismatch""
        );

        for (uint256 i = 0; i < length; ) {
            scheduleSetProtocolUint256(
                protocolValues[i],
                newUints[i],
                quantConfig,
                eta
            );
            unchecked {
                ++i;
            }
        }
    }

    /// @notice Schedule multiple calls to set protocol boolean values in the QuantConfig
    /// @param protocolValues array of protocol boolean values to be set
    /// @param newBooleans array of new booleans to be set
    /// @param quantConfig the address of the QuantConfig contract
    /// @param eta timestamp from which the scheduled calls can be executed
    function scheduleBatchSetProtocolBooleans(
        bytes32[] calldata protocolValues,
        bool[] calldata newBooleans,
        address quantConfig,
        uint256 eta
    ) public onlyRole(PROPOSER_ROLE) {
        uint256 length = protocolValues.length;

        require(
            length == newBooleans.length,
            ""ConfigTimelockController: length mismatch""
        );

        for (uint256 i = 0; i < length; ) {
            scheduleSetProtocolBoolean(
                protocolValues[i],
                newBooleans[i],
                quantConfig,
                eta
            );
            unchecked {
                ++i;
            }
        }
    }

    /// @notice Schedule multiple calls to set protocol roles in the QuantConfig
    /// @param protocolRoles array of protocol roles to be set
    /// @param roleAdmins array of role admins to be set
    /// @param quantConfig the address of the QuantConfig contract
    /// @param eta timestamp from which the scheduled calls can be executed
    function scheduleBatchSetProtocolRoles(
        string[] calldata protocolRoles,
        address[] calldata roleAdmins,
        address quantConfig,
        uint256 eta
    ) public onlyRole(PROPOSER_ROLE) {
        uint256 length = protocolRoles.length;

        require(
            length == roleAdmins.length,
            ""ConfigTimelockController: length mismatch""
        );

        for (uint256 i = 0; i < length; ) {
            scheduleSetProtocolRole(
                protocolRoles[i],
                roleAdmins[i],
                quantConfig,
                eta
            );
            unchecked {
                ++i;
            }
        }
    }

    /// @notice Execute a scheduled call to set a protocol address value in the QuantConfig
    /// @param protocolAddress the protocol address value to be set
    /// @param newAddress the new address to be set
    /// @param quantConfig the address of the QuantConfig contract
    /// @param eta timestamp from which the scheduled call can be executed
    function executeSetProtocolAddress(
        bytes32 protocolAddress,
        address newAddress,
        address quantConfig,
        uint256 eta
    ) public onlyRole(EXECUTOR_ROLE) {
        execute(
            quantConfig,
            0,
            _encodeSetProtocolAddress(protocolAddress, newAddress, quantConfig),
            bytes32(0),
            bytes32(eta)
        );
    }

    /// @notice Execute a scheduled call to set a protocol uint256 value in the QuantConfig
    /// @param protocolUint256 the protocol uint256 value to be set
    /// @param newUint256 the new uint to be set
    /// @param quantConfig the address of the QuantConfig contract
    /// @param eta timestamp from which the scheduled call can be executed
    function executeSetProtocolUint256(
        bytes32 protocolUint256,
        uint256 newUint256,
        address quantConfig,
        uint256 eta
    ) public onlyRole(EXECUTOR_ROLE) {
        execute(
            quantConfig,
            0,
            _encodeSetProtocolUint256(protocolUint256, newUint256, quantConfig),
            bytes32(0),
            bytes32(eta)
        );
    }

    /// @notice Execute a scheduled call to set a protocol boolean value in the QuantConfig
    /// @param protocolBoolean the protocol boolean value to be set
    /// @param newBoolean the new boolean to be set
    /// @param quantConfig the address of the QuantConfig contract
    /// @param eta timestamp from which the scheduled call can be executed
    function executeSetProtocolBoolean(
        bytes32 protocolBoolean,
        bool newBoolean,
        address quantConfig,
        uint256 eta
    ) public onlyRole(EXECUTOR_ROLE) {
        execute(
            quantConfig,
            0,
            _encodeSetProtocolBoolean(protocolBoolean, newBoolean, quantConfig),
            bytes32(0),
            bytes32(eta)
        );
    }

    /// @notice Execute a scheduled call to set a protocol role in the QuantConfig
    /// @param protocolRole the protocol role to be set
    /// @param roleAdmin the role admin to be set
    /// @param quantConfig the address of the QuantConfig contract
    /// @param eta timestamp from which the scheduled call can be executed
    function executeSetProtocolRole(
        string calldata protocolRole,
        address roleAdmin,
        address quantConfig,
        uint256 eta
    ) public onlyRole(EXECUTOR_ROLE) {
        execute(
            quantConfig,
            0,
            _encodeSetProtocolRole(protocolRole, roleAdmin, quantConfig),
            bytes32(0),
            bytes32(eta)
        );
    }

    /// @notice Execute multiple scheduled calls to set protocol address values in the QuantConfig
    /// @param protocolValues array of protocol address values to be set
    /// @param newAddresses array of new addresses to be set
    /// @param quantConfig the address of the QuantConfig contract
    /// @param eta timestamp from which the scheduled calls can be executed
    function executeBatchSetProtocolAddress(
        bytes32[] calldata protocolValues,
        address[] calldata newAddresses,
        address quantConfig,
        uint256 eta
    ) public onlyRole(EXECUTOR_ROLE) {
        uint256 length = protocolValues.length;

        require(
            length == newAddresses.length,
            ""ConfigTimelockController: length mismatch""
        );

        for (uint256 i = 0; i < length; ) {
            execute(
                quantConfig,
                0,
                _encodeSetProtocolAddress(
                    protocolValues[i],
                    newAddresses[i],
                    quantConfig
                ),
                bytes32(0),
                bytes32(eta)
            );
            unchecked {
                ++i;
            }
        }
    }

    /// @notice Execute multiple scheduled calls to set protocol uint256 values in the QuantConfig
    /// @param protocolValues array of protocol uint256 values to be set
    /// @param newUints array of new uints to be set
    /// @param quantConfig the address of the QuantConfig contract
    /// @param eta timestamp from which the scheduled calls can be executed
    function executeBatchSetProtocolUint256(
        bytes32[] calldata protocolValues,
        uint256[] calldata newUints,
        address quantConfig,
        uint256 eta
    ) public onlyRole(EXECUTOR_ROLE) {
        uint256 length = protocolValues.length;

        require(
            length == newUints.length,
            ""ConfigTimelockController: length mismatch""
        );

        for (uint256 i = 0; i < length; ) {
            execute(
                quantConfig,
                0,
                _encodeSetProtocolUint256(
                    protocolValues[i],
                    newUints[i],
                    quantConfig
                ),
                bytes32(0),
                bytes32(eta)
            );
            unchecked {
                ++i;
            }
        }
    }

    /// @notice Execute multiple scheduled calls to set protocol boolean values in the QuantConfig
    /// @param protocolValues array of protocol boolean values to be set
    /// @param newBooleans array of new booleans to be set
    /// @param quantConfig the address of the QuantConfig contract
    /// @param eta timestamp from which the scheduled calls can be executed
    function executeBatchSetProtocolBoolean(
        bytes32[] calldata protocolValues,
        bool[] calldata newBooleans,
        address quantConfig,
        uint256 eta
    ) public onlyRole(EXECUTOR_ROLE) {
        uint256 length = protocolValues.length;

        require(
            length == newBooleans.length,
            ""ConfigTimelockController: length mismatch""
        );

        for (uint256 i = 0; i < length; ) {
            execute(
                quantConfig,
                0,
                _encodeSetProtocolBoolean(
                    protocolValues[i],
                    newBooleans[i],
                    quantConfig
                ),
                bytes32(0),
                bytes32(eta)
            );
            unchecked {
                ++i;
            }
        }
    }

    /// @notice Execute multiple scheduled calls to set protocol roles in the QuantConfig
    /// @param protocolRoles array of protocol roles to be set
    /// @param roleAdmins array of role admins to be set
    /// @param quantConfig the address of the QuantConfig contract
    /// @param eta timestamp from which the scheduled calls can be executed
    function executeBatchSetProtocolRoles(
        string[] calldata protocolRoles,
        address[] calldata roleAdmins,
        address quantConfig,
        uint256 eta
    ) public onlyRole(EXECUTOR_ROLE) {
        uint256 length = protocolRoles.length;

        require(
            length == roleAdmins.length,
            ""ConfigTimelockController: length mismatch""
        );

        for (uint256 i = 0; i < length; ) {
            execute(
                quantConfig,
                0,
                _encodeSetProtocolRole(
                    protocolRoles[i],
                    roleAdmins[i],
                    quantConfig
                ),
                bytes32(0),
                bytes32(eta)
            );
            unchecked {
                ++i;
            }
        }
    }

    /// @notice Gets the delay to set a specific protocol value using the timelock
    /// @param quantConfig  the address of the QuantConfig contract
    /// @param protocolValue the protocol value to get the delay for
    /// @return the delay required to set the protocol value
    function _getProtocolValueDelay(
        address quantConfig,
        bytes32 protocolValue,
        ProtocolValue.Type protocolValueType
    ) internal view returns (uint256) {
        // There shouldn't be a delay when setting a protocol value for the first time
        if (
            !IQuantConfig(quantConfig).isProtocolValueSet(
                protocolValue,
                protocolValueType
            )
        ) {
            return 0;
        }

        uint256 storedDelay = delays[protocolValue];
        return storedDelay != 0 ? storedDelay : minDelay;
    }

    /// @notice Checks if a given calldata is for setting a protocol value, which could be used
    /// to bypass the minimum delay required to set a protocol value of a specific type
    /// @param data the calldata to check
    /// @return true if the calldata is for setting a protocol value, false otherwise
    /// @dev There could be a clash between the 4-byte selector for `setProtocolValue` functions
    /// and other external functions. That's unlikely to happen, but if it does, scheduling calls
    /// to those functions will always revert.
    function _isProtocoValueSetter(bytes memory data)
        internal
        pure
        returns (bool)
    {
        bytes4 selector;

        assembly {
            selector := mload(add(data, 32))
        }

        return
            selector == IQuantConfig(address(0)).setProtocolAddress.selector ||
            selector == IQuantConfig(address(0)).setProtocolUint256.selector ||
            selector == IQuantConfig(address(0)).setProtocolBoolean.selector;
    }

    /// @notice Encodes the calldata for setting a protocol address value
    /// @param _protocolAddress the protocol address value to be set
    /// @param _newAddress the new address to be set
    /// @param _quantConfig the address of the QuantConfig contract
    function _encodeSetProtocolAddress(
        bytes32 _protocolAddress,
        address _newAddress,
        address _quantConfig
    ) internal pure returns (bytes memory) {
        return
            abi.encodeWithSelector(
                IQuantConfig(_quantConfig).setProtocolAddress.selector,
                _protocolAddress,
                _newAddress
            );
    }

    /// @notice Encodes the calldata for setting a protocol uint256 value
    /// @param _protocolUint256 the protocol uint256 value to be set
    /// @param _newUint256 the new uint to be set
    /// @param _quantConfig the address of the QuantConfig contract
    function _encodeSetProtocolUint256(
        bytes32 _protocolUint256,
        uint256 _newUint256,
        address _quantConfig
    ) internal pure returns (bytes memory) {
        return
            abi.encodeWithSelector(
                IQuantConfig(_quantConfig).setProtocolUint256.selector,
                _protocolUint256,
                _newUint256
            );
    }

    /// @notice Encodes the calldata for setting a protocol boolean value
    /// @param _protocolBoolean the protocol boolean value to be set
    /// @param _newBoolean the new boolean to be set
    /// @param _quantConfig the address of the QuantConfig contract
    function _encodeSetProtocolBoolean(
        bytes32 _protocolBoolean,
        bool _newBoolean,
        address _quantConfig
    ) internal pure returns (bytes memory) {
        return
            abi.encodeWithSelector(
                IQuantConfig(_quantConfig).setProtocolBoolean.selector,
                _protocolBoolean,
                _newBoolean
            );
    }

    /// @notice Encodes the calldata for setting a protocol role
    /// @param _protocolRole the protocol role to be set
    /// @param _roleAdmin the role admin to be set
    /// @param _quantConfig the address of the QuantConfig contract
    function _encodeSetProtocolRole(
        string memory _protocolRole,
        address _roleAdmin,
        address _quantConfig
    ) internal pure returns (bytes memory) {
        return
            abi.encodeWithSelector(
                IQuantConfig(_quantConfig).setProtocolRole.selector,
                _protocolRole,
                _roleAdmin
            );
    }
}",5016
RealWorld_BA_98_IAssetsRegistry_RealWord_20240827004444.log,98,IAssetsRegistry,11236,5147,16383,76.0,0.15912,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity ^0.8.0;

interface IAssetsRegistry {
    /// @notice emitted when a new asset is added to the registry
    /// @param underlying address of the asset
    /// @param name name of the asset
    /// @param symbol symbol of the asset
    /// @param decimals the amount of decimals the asset has
    event AssetAdded(
        address indexed underlying,
        string name,
        string symbol,
        uint8 decimals
    );

    /// @notice Add a new asset to the registry
    /// @dev It will revert when trying to add an asset with the same address twice
    /// @dev Can only be called by addresses with the ASSETS_REGISTRY_MANAGER_ROLE role
    /// @param _underlying address of the asset
    /// @param _name name of the asset
    /// @param _symbol symbol of the asset
    /// @param _decimals the amount of decimals the asset has
    function addAsset(
        address _underlying,
        string calldata _name,
        string calldata _symbol,
        uint8 _decimals
    ) external;

    /// @notice Add a new asset to the registry, calling the optional ERC20 methods
    /// to get its name, symbol and decimals
    /// @param _underlying address of the asset
    function addAssetWithOptionalERC20Methods(address _underlying) external;

    /// @notice Returns the name, symbol and decimals of an asset that's already in the registry
    /// @dev Will return empty strings and zero for non-existent assets
    /// @return name asset's name
    /// @return symbol asset's symbol
    /// @return decimals asset's decimals
    function assetProperties(address asset)
        external
        view
        returns (
            string memory name,
            string memory symbol,
            uint8 decimals
        );

    /// @notice Returns the address of the asset at the given index
    /// @param index index of the asset in the registry
    /// @return asset address of the asset at the given index
    function registeredAssets(uint256 index)
        external
        view
        returns (address asset);

    /// @notice Returns the number of assets in the registry
    /// @return length number of assets in the registry
    function getAssetsLength() external view returns (uint256 length);
}",500
RealWorld_BA_98_AssetsRegistry_RealWord_20240826234557.log,98,AssetsRegistry,13596,5391,18987,89.0,0.1758,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.12;

import ""@openzeppelin/contracts/token/ERC20/ERC20.sol"";
import ""../interfaces/IQuantConfig.sol"";
import ""../interfaces/IAssetsRegistry.sol"";

/// @title For managing assets supported as underlying for options in the Quant Protocol
/// @author Rolla
contract AssetsRegistry is IAssetsRegistry {
    struct AssetProperties {
        string name;
        string symbol;
        uint8 decimals;
    }

    IQuantConfig private _quantConfig;

    /// @inheritdoc IAssetsRegistry
    mapping(address => AssetProperties) public override assetProperties;

    /// @inheritdoc IAssetsRegistry
    address[] public override registeredAssets;

    /// @dev Checks that the `msg.sender` has permission to add assets to the registry.
    /// @dev Also checks that the asset had not been added before.
    modifier validAsset(address _underlying) {
        require(
            _quantConfig.hasRole(
                _quantConfig.quantRoles(""ASSETS_REGISTRY_MANAGER_ROLE""),
                msg.sender
            ),
            ""AssetsRegistry: only asset registry managers can add assets""
        );

        require(
            bytes(assetProperties[_underlying].symbol).length == 0,
            ""AssetsRegistry: asset already added""
        );

        _;
    }

    /// @param quantConfig_ address of the Quant central configuration contract
    constructor(address quantConfig_) {
        require(
            quantConfig_ != address(0),
            ""AssetsRegistry: invalid QuantConfig address""
        );

        _quantConfig = IQuantConfig(quantConfig_);
    }

    /// @inheritdoc IAssetsRegistry
    function addAsset(
        address _underlying,
        string calldata _name,
        string calldata _symbol,
        uint8 _decimals
    ) external override validAsset(_underlying) {
        assetProperties[_underlying] = AssetProperties(
            _name,
            _symbol,
            _decimals
        );

        registeredAssets.push(_underlying);

        emit AssetAdded(_underlying, _name, _symbol, _decimals);
    }

    /// @inheritdoc IAssetsRegistry
    function addAssetWithOptionalERC20Methods(address _underlying)
        external
        override
        validAsset(_underlying)
    {
        string memory name = ERC20(_underlying).name();
        require(bytes(name).length > 0, ""AssetsRegistry: invalid empty name"");

        string memory symbol = ERC20(_underlying).symbol();
        require(
            bytes(symbol).length > 0,
            ""AssetsRegistry: invalid empty symbol""
        );

        uint8 decimals = ERC20(_underlying).decimals();
        require(decimals > 0, ""AssetsRegistry: invalid zero decimals"");

        assetProperties[_underlying] = AssetProperties(name, symbol, decimals);

        registeredAssets.push(_underlying);

        emit AssetAdded(_underlying, name, symbol, decimals);
    }

    /// @inheritdoc IAssetsRegistry
    function getAssetsLength() external view override returns (uint256) {
        return registeredAssets.length;
    }
}",642
RealWorld_BA_98_EIP712MetaTransaction_RealWord_20240827002707.log,98,EIP712MetaTransaction,30518,6231,36749,90.0,0.27721,"// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.12;

import ""@openzeppelin/contracts-upgradeable/utils/cryptography/draft-EIP712Upgradeable.sol"";
import ""@openzeppelin/contracts/utils/cryptography/ECDSA.sol"";
import ""../interfaces/IEIP712MetaTransaction.sol"";
import ""../interfaces/IController.sol"";
import ""../libraries/Actions.sol"";
import {ActionArgs} from ""../libraries/Actions.sol"";

/// @title Contract to be inherited by contracts that want to support meta transactions.
/// @author Rolla
contract EIP712MetaTransaction is EIP712Upgradeable {
    using ECDSA for bytes32;

    struct MetaAction {
        uint256 nonce;
        uint256 deadline;
        address from;
        ActionArgs[] actions;
    }

    bytes32 private constant _META_ACTION_TYPEHASH =
        keccak256(
            // solhint-disable-next-line max-line-length
            ""MetaAction(uint256 nonce,uint256 deadline,address from,ActionArgs[] actions)ActionArgs(uint8 actionType,address qToken,address secondaryAddress,address receiver,uint256 amount,uint256 collateralTokenId,bytes data)""
        );
    bytes32 private constant _ACTION_TYPEHASH =
        keccak256(
            // solhint-disable-next-line max-line-length
            ""ActionArgs(uint8 actionType,address qToken,address secondaryAddress,address receiver,uint256 amount,uint256 collateralTokenId,bytes data)""
        );

    mapping(address => uint256) private _nonces;

    /// @notice user readable name of signing domain for EIP712 (the protocol name)
    string public name;

    /// @notice the current major version of the signing domain for EIP712
    string public version;

    /// @notice emitted when a meta transaction is executed
    event MetaTransactionExecuted(
        address indexed userAddress,
        address payable indexed relayerAddress,
        uint256 nonce
    );

    /// @notice Given an encoded action and a signature, executes the action on behalf of the signer.
    /// @param metaAction The encoded action to be executed.
    /// @param r The r-value of the signature.
    /// @param s The s-value of the signature.
    /// @param v The v-value of the signature.
    /// @return The returned data from the low-level call.
    function executeMetaTransaction(
        MetaAction memory metaAction,
        bytes32 r,
        bytes32 s,
        uint8 v
    ) external payable returns (bytes memory) {
        require(
            _verify(metaAction.from, metaAction, r, s, v),
            ""signer and signature don't match""
        );

        uint256 currentNonce = _nonces[metaAction.from];

        // intentionally allow this to overflow to save gas,
        // and it's impossible for someone to do 2 ^ 256 - 1 meta txs
        unchecked {
            _nonces[metaAction.from] = currentNonce + 1;
        }

        // Append the metaAction.from at the end so that it can be extracted later
        // from the calling context (see _msgSender() below)
        (bool success, bytes memory returnData) = address(this).call(
            abi.encodePacked(
                abi.encodeWithSelector(
                    IController(address(this)).operate.selector,
                    metaAction.actions
                ),
                metaAction.from
            )
        );

        require(success, ""unsuccessful function call"");
        emit MetaTransactionExecuted(
            metaAction.from,
            payable(msg.sender),
            currentNonce
        );
        return returnData;
    }

    /// @notice Returns the current nonce for a user.
    /// @param user the address of the user to get the nonce for.
    /// @return nonce the current nonce for the user.
    function getNonce(address user) external view returns (uint256 nonce) {
        nonce = _nonces[user];
    }

    /// @notice initialize method for EIP712Upgradeable
    /// @dev called once after initial deployment and every upgrade.
    /// @param _name the user readable name of the signing domain for EIP712
    /// @param _version the current major version of the signing domain for EIP712
    function initializeEIP712(string memory _name, string memory _version)
        public
        initializer
    {
        name = _name;
        version = _version;

        __EIP712_init(_name, _version);
    }

    /// @notice Returns the address of the signer when called from this contract,
    /// otherwise returns the msg.sender
    /// @return sender the address of the signer or msg.sender
    function _msgSender() internal view returns (address sender) {
        if (msg.sender == address(this)) {
            bytes memory array = msg.data;
            uint256 index = msg.data.length;
            assembly {
                // Load the 32 bytes word from memory with the address on the lower 20 bytes, and mask those.
                sender := and(
                    mload(add(array, index)),
                    0xffffffffffffffffffffffffffffffffffffffff
                )
            }
        } else {
            sender = msg.sender;
        }
        return sender;
    }

    /// @notice Verifies that the signature is valid for a given user and action.
    /// @param user the address to check as the signer.
    /// @param metaAction the action struct to check.
    /// @param r the r-value of the signature.
    /// @param s the s-value of the signature.
    /// @param v the v-value of the signature.
    function _verify(
        address user,
        MetaAction memory metaAction,
        bytes32 r,
        bytes32 s,
        uint8 v
    ) internal view returns (bool) {
        require(metaAction.nonce == _nonces[user], ""invalid nonce"");

        require(metaAction.deadline >= block.timestamp, ""expired deadline"");

        address signer = _hashTypedDataV4(_hashMetaAction(metaAction)).recover(
            v,
            r,
            s
        );

        return signer == user;
    }

    /// @notice Hashes a given ActionArgs struct to be used with EIP712.
    /// @param action the ActionArgs struct to hash.
    /// @return the hash of the ActionArgs struct.
    function _hashAction(ActionArgs memory action)
        private
        pure
        returns (bytes32)
    {
        return
            keccak256(
                abi.encode(
                    _ACTION_TYPEHASH,
                    action.actionType,
                    action.qToken,
                    action.secondaryAddress,
                    action.receiver,
                    action.amount,
                    action.collateralTokenId,
                    keccak256(action.data)
                )
            );
    }

    /// @notice Hashes an array of ActionArgs structs to be used with EIP712.
    /// @param actions the array of ActionArgs structs to hash.
    /// @return the array of hashes for the ActionArgs structs.
    function _hashActions(ActionArgs[] memory actions)
        private
        pure
        returns (bytes32[] memory)
    {
        bytes32[] memory hashedActions = new bytes32[](actions.length);
        uint256 length = actions.length;
        for (uint256 i = 0; i < length; ) {
            hashedActions[i] = _hashAction(actions[i]);
            unchecked {
                ++i;
            }
        }
        return hashedActions;
    }

    /// @notice Hashes a MetaAction struct to be used with EIP712.
    /// @param metaAction the MetaAction struct to hash.
    /// @return the hash of the MetaAction struct.
    function _hashMetaAction(MetaAction memory metaAction)
        private
        pure
        returns (bytes32)
    {
        return
            keccak256(
                abi.encode(
                    _META_ACTION_TYPEHASH,
                    metaAction.nonce,
                    metaAction.deadline,
                    metaAction.from,
                    keccak256(
                        abi.encodePacked(_hashActions(metaAction.actions))
                    )
                )
            );
    }
}",1658
