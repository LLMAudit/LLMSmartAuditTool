Integer Overflow/Underflow Identified,Reentrancy Identified,Unchecked External Calls Identified,Unchecked Low-level Calls Identified,Transactions Order Dependence Identified,Timestamp Manipulation Identified,Predictable Randomness Identified,Unsafe `tx.origin` Identified,Unsafe Suicide Identified,Gas Limit Identified,Price Manipulation Identified,Assumption of Fixed-Length Array Identified,Lack of Withdrawal Function Identified,Lack of Authorization Identified,Potential Data Inconsistency Identified,Hash Collision Identified,Uninitialized Return Variable Identified,Misdeclared Constructor Identified,Missing 'onlyOwner' Modifier Identified,Misuse of `msg.value` within a Loop Identified,Precision Loss Identified,Redundant Conditional Check Identified,External Oracle Dependency Identified,Ownership Hijacking Identified,Centralization Risk Identified,Incorrect Funding Rate Calculation Identified,Flash Loan Fee Manipulation Identified,Misuse of Mapping Getter Identified,Lack of Getter Function Implementation Identified,Unnecessary Comparison Identified,Inconsistent Initialization Identified,Potential Inconsistency in Yield Source Swapping Identified,Incorrect Signer Verification Identified,Order of Inheritance Initialization Identified,Impracticality of Exact Match Identified,Inconsistent Base Tokens Identified,Handling Partial Withdrawals Identified,Fallback Function Identified,Unlimited Token Approval Identified,Lack of Input Validation Identified,DoS Vulnerability Identified
"<INFO> Integer Overflow/Underflow Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, along with recommended mitigation measures or fixes that do not require code upgrades.
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Reentrancy Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Unchecked External Calls Identified."".
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Unchecked Low-level Calls Identified."".
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Transactions Order Dependence Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, along with recommended mitigation measures or fixes that do not require code upgrades
'''
```
If you don't find any Transactions Order Dependence vulnerabilities, respond only with: ""","<INFO> Timestamp Manipulation Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Predictable Randomness Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Unsafe `tx.origin` Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Unsafe Suicide Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If NO Lack of Restriction on `selfdestruct` is found, respond only with: ""","<INFO> Gas Limit Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Price Manipulation Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code.
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Assumption of Fixed-Length Array Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code.
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Lack of Withdrawal Function Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If a secure withdrawal function is found and no issues are identified, respond only with: ""","<INFO> Lack of Authorization Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If NO Lack of Authorization vulnerabilities are found, respond only with: ""","<INFO> Potential Data Inconsistency Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If NO Potential Data Inconsistency vulnerabilities are found, respond only with: ""","<INFO> Hash Collision Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If NO Hash Collision vulnerabilities are found, respond only with: ""","<INFO> Uninitialized Return Variable Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If NO Uninitialized Return Variable vulnerabilities are found, respond only with: ""","<INFO> Misdeclared Constructor Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If NO Misdeclared Constructor vulnerabilities are found, respond only with: ""","<INFO> Missing 'onlyOwner' Modifier Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Misuse of `msg.value` within a Loop Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Precision Loss Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Redundant Conditional Check Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> External Oracle Dependency Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: """,,"<INFO> Centralization Risk Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Incorrect Funding Rate Calculation Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Flash Loan Fee Manipulation Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Misuse of Mapping Getter Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Lack of Getter Function Implementation Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Unnecessary Comparison Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Inconsistent Initialization Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Potential Inconsistency in Yield Source Swapping Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Incorrect Signer Verification Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Order of Inheritance Initialization Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Impracticality of Exact Match Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Inconsistent Base Tokens Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Handling Partial Withdrawals Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Fallback Function Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Unlimited Token Approval Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Lack of Input Validation Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> DoS Vulnerability Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, along with recommended mitigation measures or fixes that do not require code upgrades.
'''
```
If you don't find any vulnerabilities, respond only with: """
,,,"<INFO> Unchecked Low-level Calls Identified.

```
UNCHECKED LOW-LEVEL CALL
'''
The contract uses the `assert` function to check the result of the low-level call to `treasury.payout(_recipient, _amount)` in the `_payout` function. However, `assert` is not suitable for handling failures of external calls, as it will revert the entire transaction without providing a clear error message or a way to handle the failure gracefully. This can lead to loss of funds if the external contract fails to execute correctly.

Recommended Mitigation:
Replace the `assert` statement with a proper error handling mechanism. Use a `require` statement to check the return value of the low-level call, which will allow for a clearer error message and a more controlled failure. For example:
```
require(treasury.payout(_recipient, _amount), ""Payout failed"");
```
This way, if the payout fails, the transaction will revert with a specific error message, and the contract can handle the failure appropriately.
'''
```

```
UNCHECKED LOW-LEVEL CALL
'''
The contract also uses `assert` in the `_transferCard` function to check the result of the `nfthub.transferNft(_from, _to, _tokenId)` call. Similar to the previous case, using `assert` here can lead to issues if the transfer fails, as it does not provide a way to handle the failure gracefully.

Recommended Mitigation:
Change the `assert` to a `require` statement to ensure that the transfer is successful and provide a meaningful error message if it fails. For example:
```
require(nfthub.transferNft(_from, _to, _tokenId), ""NFT transfer failed"");
```
This will allow for better error handling and prevent potential loss of funds or unexpected behavior in the contract.
'''
```

```
UNCHECKED LOW-LEVEL CALL
'''
In the `_sponsor` function, the contract calls `treasury.sponsor(_sponsorAddress, _amount)` without checking the return value. If the `sponsor` function in the `treasury` contract fails, it could lead to unexpected behavior or loss of funds.

Recommended Mitigation:
Implement a `require` statement to check the return value of the `sponsor` call. For example:
```
require(treasury.sponsor(_sponsorAddress, _amount), ""Sponsorship failed"");
```
This ensures that the contract can handle the failure of the external call appropriately.
'''
```

[2024-02-08 10:43:57 INFO] **[Seminar Conclusion]**:

 ",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
,,,"<INFO> Unchecked Low-level Calls Identified.

```
UNCHECKED LOW-LEVEL CALL
'''
The contract uses the `assert` function to check the result of the low-level call to `treasury.payout(_recipient, _amount)` in the `_payout` function. However, `assert` is not suitable for handling failures of external calls, as it will revert the entire transaction without providing a clear error message or a way to handle the failure gracefully. This can lead to loss of funds if the external contract fails to execute correctly.

Recommended Mitigation:
Replace the `assert` statement with a proper error handling mechanism. Use a `require` statement to check the return value of the low-level call, which will allow for a clearer error message and a more controlled failure. For example:
```
require(treasury.payout(_recipient, _amount), ""Payout failed"");
```
This way, if the payout fails, the transaction will revert with a specific error message, and the contract can handle the failure appropriately.
'''
```

```
UNCHECKED LOW-LEVEL CALL
'''
The contract also uses `assert` in the `_transferCard` function to check the result of the `nfthub.transferNft(_from, _to, _tokenId)` call. Similar to the previous case, using `assert` here can lead to issues if the transfer fails, as it does not provide a way to handle the failure gracefully.

Recommended Mitigation:
Change the `assert` to a `require` statement to ensure that the transfer is successful and provide a meaningful error message if it fails. For example:
```
require(nfthub.transferNft(_from, _to, _tokenId), ""NFT transfer failed"");
```
This will allow for better error handling and prevent potential loss of funds or unexpected behavior in the contract.
'''
```

```
UNCHECKED LOW-LEVEL CALL
'''
In the `_sponsor` function, the contract calls `treasury.sponsor(_sponsorAddress, _amount)` without checking the return value. If the `sponsor` function in the `treasury` contract fails, it could lead to unexpected behavior or loss of funds.

Recommended Mitigation:
Implement a `require` statement to check the return value of the `sponsor` call. For example:
```
require(treasury.sponsor(_sponsorAddress, _amount), ""Sponsorship failed"");
```
This ensures that the contract can handle the failure of the external call appropriately.
'''
```

[2024-02-08 10:43:57 INFO] **[Execute Detail]**

execute SimplePhase:[TODDetector] in ComposedPhase:[CodeReview], cycle 1

[2024-02-08 10:43:58 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: AGPL-3.0 pragma solidity 0.8.4; import ""@openzeppelin/contracts/proxy/utils/Initializable.sol""; import ""@openzeppelin/contracts/utils/math/SafeCast.sol""; import ""hardhat/console.sol""; import ""./interfaces/IRealitio.sol""; import ""./interfaces/IRCFactory.sol""; import ""./interfaces/IRCTreasury.sol""; import ""./interfaces/IRCMarket.sol""; import ""./interfaces/IRCNftHubL2.sol""; import ""./interfaces/IRCOrderbook.sol""; import ""./lib/NativeMetaTransaction.sol""; /// @title Reality Cards Market /// @author Andrew Stanger &amp; Daniel Chilvers /// @notice If you have found a bug, please contact andrew@realitycards.io- no hack pls!! contract RCMarket is Initializable, NativeMetaTransaction, IRCMarket {     /╔═════════════════════════════════╗       ║            VARIABLES            ║       ╚═════════════════════════════════╝/ // CONTRACT SETUP /// @dev = how many outcomes/teams/NFTs etc uint256 public numberOfCards; uint256 public constant MAX_UINT256 = type(uint256).max; uint256 public constant MIN_RENTAL_VALUE = 1 ether; States public override state; /// @dev type of event. enum Mode {CLASSIC, WINNER_TAKES_ALL, SAFE_MODE} Mode public mode; /// @dev so the Factory can check it's a market bool public constant override isMarket = true; /// @dev counts the total NFTs minted across all events at the time market created /// @dev nft tokenId = card Id + totalNftMintCount uint256 public totalNftMintCount;  // CONTRACT VARIABLES IRCTreasury public treasury; IRCFactory public factory; IRCNftHubL2 public nfthub; IRCOrderbook public orderbook;  // PRICE, DEPOSITS, RENT /// @dev in wei mapping(uint256 =&gt; uint256) public cardPrice; /// @dev keeps track of all the rent paid by each user. So that it can be returned in case of an invalid market outcome. mapping(address =&gt; uint256) public rentCollectedPerUser; /// @dev keeps track of all the rent paid for each card, for card specific affiliate payout mapping(uint256 =&gt; uint256) public rentCollectedPerCard; /// @dev keeps track of the rent each user has paid for each card, for Safe mode payout mapping(address =&gt; mapping(uint256 =&gt; uint256))     public rentCollectedPerUserPerCard; /// @dev an easy way to track the above across all cards uint256 public totalRentCollected; /// @dev prevents user from exiting and re-renting in the same block (limits troll attacks) mapping(address =&gt; uint256) public exitedTimestamp;  // PARAMETERS /// @dev read from the Factory upon market creation, can not be changed for existing market /// @dev the minimum required price increase in % uint256 public minimumPriceIncreasePercent; /// @dev minimum rental duration (1 day divisor: i.e. 24 = 1 hour, 48 = 30 mins) uint256 public minRentalDayDivisor; /// @dev maximum number of times to calcualte rent in one transaction uint256 public maxRentIterations;  // TIME /// @dev how many seconds each user has held each card for, for determining winnings mapping(uint256 =&gt; mapping(address =&gt; uint256)) public timeHeld; /// @dev sums all the timeHelds for each. Used when paying out. Should always increment at the same time as timeHeld mapping(uint256 =&gt; uint256) public totalTimeHeld; /// @dev used to determine the rent due. Rent is due for the period (now - timeLastCollected), at which point timeLastCollected is set to now. mapping(uint256 =&gt; uint256) public timeLastCollected; /// @dev to track the max timeheld of each card (for giving NFT to winner) mapping(uint256 =&gt; uint256) public longestTimeHeld; /// @dev to track who has owned it the most (for giving NFT to winner) mapping(uint256 =&gt; address) public longestOwner; /// @dev to track the card timeHeldLimit for the current owner mapping(uint256 =&gt; uint256) public cardTimeLimit;  // TIMESTAMPS /// @dev when the market opens uint32 public marketOpeningTime; /// @dev when the market locks uint32 public override marketLockingTime; /// @dev when the question can be answered on realitio /// @dev only needed for circuit breaker uint32 public oracleResolutionTime;  // PAYOUT VARIABLES uint256 public winningOutcome; /// @dev prevent users withdrawing twice mapping(address =&gt; bool) public userAlreadyWithdrawn; /// @dev prevent users claiming twice mapping(uint256 =&gt; mapping(address =&gt; bool)) public userAlreadyClaimed; // cardID // user // bool /// @dev the artist address public artistAddress; uint256 public artistCut; bool public artistPaid; /// @dev the affiliate address public affiliateAddress; uint256 public affiliateCut; bool public affiliatePaid; /// @dev the winner uint256 public winnerCut; /// @dev the market creator address public marketCreatorAddress; uint256 public creatorCut; bool public creatorPaid; /// @dev card specific recipients address[] public cardAffiliateAddresses; uint256 public cardAffiliateCut; mapping(uint256 =&gt; bool) public cardAffiliatePaid;  // ORACLE VARIABLES bytes32 public questionId; bool public questionFinalised; address public arbitrator; uint32 public timeout; IRealitio public realitio; address public _realitioAddress;  /*╔═════════════════════════════════╗   ║             EVENTS              ║   ╚═════════════════════════════════╝*/  event LogNewOwner(uint256 indexed cardId, address indexed newOwner); event LogRentCollection(     uint256 rentCollected,     uint256 indexed newTimeHeld,     uint256 indexed cardId,     address indexed owner ); event LogContractLocked(bool indexed didTheEventFinish); event LogWinnerKnown(uint256 indexed winningOutcome); event LogWinningsPaid(address indexed paidTo, uint256 indexed amountPaid); event LogStakeholderPaid(     address indexed paidTo,     uint256 indexed amountPaid ); event LogRentReturned(     address indexed returnedTo,     uint256 indexed amountReturned ); event LogStateChange(uint256 indexed newState); event LogUpdateTimeHeldLimit(     address indexed owner,     uint256 newLimit,     uint256 cardId ); event LogSponsor(address indexed sponsor, uint256 indexed amount); event LogNftUpgraded(     uint256 indexed currentTokenId,     uint256 indexed newTokenId ); event LogPayoutDetails(     address indexed artistAddress,     address marketCreatorAddress,     address affiliateAddress,     address[] cardAffiliateAddresses,     uint256 indexed artistCut,     uint256 winnerCut,     uint256 creatorCut,     uint256 affiliateCut,     uint256 cardAffiliateCut ); event LogSettings(     uint256 indexed minRentalDayDivisor,     uint256 indexed minimumPriceIncreasePercent ); event LogLongestOwner(uint256 cardId, address longestOwner); event LogQuestionPostedToOracle(     address indexed marketAddress,     bytes32 indexed questionId );  /*╔═════════════════════════════════╗   ║           CONSTRUCTOR           ║   ╚═════════════════════════════════╝*/  /// @param _mode 0 = normal, 1 = winner takes all, 2 = Safe Mode /// @param _timestamps for market opening, locking, and oracle resolution /// @param _numberOfCards how many Cards in this market /// @param _totalNftMintCount total existing Cards across all markets excl this event's Cards /// @param _artistAddress where to send artist's cut, if any /// @param _affiliateAddress where to send affiliate's cut, if any /// @param _cardAffiliateAddresses where to send card specific affiliate's cut, if any /// @param _marketCreatorAddress where to send market creator's cut, if any /// @param _realitioQuestion the question posted to the Oracle function initialize(     uint256 _mode,     uint32[] memory _timestamps,     uint256 _numberOfCards,     uint256 _totalNftMintCount,     address _artistAddress,     address _affiliateAddress,     address[] memory _cardAffiliateAddresses,     address _marketCreatorAddress,     string calldata _realitioQuestion ) external override initializer {     assert(_mode &lt;= 2);      // initialise MetaTransactions     _initializeEIP712(""RealityCardsMarket"", ""1"");      // external contract variables:     factory = IRCFactory(msgSender());     treasury = factory.treasury();     nfthub = factory.nfthub();     orderbook = factory.orderbook();      // get adjustable parameters from the factory/treasury     uint256[5] memory _potDistribution = factory.getPotDistribution();     minRentalDayDivisor = treasury.minRentalDayDivisor();     minimumPriceIncreasePercent = factory.minimumPriceIncreasePercent();     maxRentIterations = factory.maxRentIterations();      // initialiiize!     winningOutcome = MAX_UINT256; // default invalid      // assign arguments to public variables     mode = Mode(_mode);     numberOfCards = _numberOfCards;     totalNftMintCount = _totalNftMintCount;     marketOpeningTime = _timestamps[0];     marketLockingTime = _timestamps[1];     oracleResolutionTime = _timestamps[2];     artistAddress = _artistAddress;     marketCreatorAddress = _marketCreatorAddress;     affiliateAddress = _affiliateAddress;     cardAffiliateAddresses = _cardAffiliateAddresses;     artistCut = _potDistribution[0];     winnerCut = _potDistribution[1];     creatorCut = _potDistribution[2];     affiliateCut = _potDistribution[3];     cardAffiliateCut = _potDistribution[4];     (realitio, arbitrator, timeout) = factory.getOracleSettings();      // reduce artist cut to zero if zero adddress set     if (_artistAddress == address(0)) {         artistCut = 0;     }      // reduce affiliate cut to zero if zero adddress set     if (_affiliateAddress == address(0)) {         affiliateCut = 0;     }      // check the validity of card affiliate array.     // if not valid, reduce payout to zero     if (_cardAffiliateAddresses.length == _numberOfCards) {         for (uint256 i = 0; i &lt; _numberOfCards; i++) {             if (_cardAffiliateAddresses[i] == address(0)) {                 cardAffiliateCut = 0;             }         }     } else {         cardAffiliateCut = 0;     }      // if winner takes all mode, set winnerCut to max     if (_mode == uint8(Mode.WINNER_TAKES_ALL)) {         winnerCut =             (((uint256(1000) - artistCut) - creatorCut) - affiliateCut) -             cardAffiliateCut;     }      // post question to Oracle     questionFinalised = false;     _postQuestionToOracle(_realitioQuestion, _timestamps[2]);      // move to OPEN immediately if market opening time in the past     if (marketOpeningTime &lt;= block.timestamp) {         _incrementState();     }      emit LogPayoutDetails(         _artistAddress,         _marketCreatorAddress,         _affiliateAddress,         cardAffiliateAddresses,         artistCut,         winnerCut,         creatorCut,         affiliateCut,         cardAffiliateCut     );     emit LogSettings(minRentalDayDivisor, minimumPriceIncreasePercent); }  /*╔═════════════════════════════════╗   ║            MODIFIERS            ║   ╚═════════════════════════════════╝*/  /// @notice automatically opens market if appropriate modifier autoUnlock() {     if (marketOpeningTime &lt;= block.timestamp &amp;&amp; state == States.CLOSED) {         _incrementState();     }     _; }  /// @notice automatically locks market if appropriate modifier autoLock() {     _;     if (marketLockingTime &lt;= block.timestamp) {         lockMarket();     } }  /// @dev can only be called by Card owners modifier onlyTokenOwner(uint256 _token) {     require(msgSender() == ownerOf(_token), ""Not owner"");     _; }  /*╔═════════════════════════════════╗   ║     NFT HUB CONTRACT CALLS      ║   ╚═════════════════════════════════╝*/  /// @notice send NFT to mainnet /// @dev upgrades not possible if market not approved function upgradeCard(uint256 _card) external onlyTokenOwner(_card) {     _checkState(States.WITHDRAW);     require(         !factory.trapIfUnapproved() ||             factory.isMarketApproved(address(this)),         ""Upgrade blocked""     );     uint256 _tokenId = _card + totalNftMintCount;     _transferCard(ownerOf(_card), address(this), _card); // contract becomes final resting place     nfthub.withdrawWithMetadata(_tokenId);     emit LogNftUpgraded(_card, _tokenId); }  /// @notice gets the owner of the NFT via their Card Id function ownerOf(uint256 _cardId) public view override returns (address) {     uint256 _tokenId = _cardId + totalNftMintCount;     return nfthub.ownerOf(_tokenId); }  /// @notice gets tokenURI via their Card Id function tokenURI(uint256 _cardId)     public     view     override     returns (string memory) {     uint256 _tokenId = _cardId + totalNftMintCount;     return nfthub.tokenURI(_tokenId); }  /// @notice transfer ERC 721 between users /// @dev called internally during contract open state function _transferCard(     address _from,     address _to,     uint256 _cardId ) internal {     require(         _from != address(0) &amp;&amp; _to != address(0),         ""Cannot send to/from zero address""     );     uint256 _tokenId = _cardId + totalNftMintCount;      assert(nfthub.transferNft(_from, _to, _tokenId));     emit LogNewOwner(_cardId, _to); }  /// @notice transfer ERC 721 between users /// @dev called externaly by Orderbook during contract open state function transferCard(     address _from,     address _to,     uint256 _cardId,     uint256 _price,     uint256 _timeLimit ) external override {     require(msgSender() == address(orderbook), ""Not orderbook"");     _checkState(States.OPEN);     if (_to != _from) {         _transferCard(_from, _to, _cardId);     }     cardTimeLimit[_cardId] = _timeLimit;     cardPrice[_cardId] = _price; }  /*╔═════════════════════════════════╗   ║        ORACLE FUNCTIONS         ║   ╚═════════════════════════════════╝*/  /// @dev called within initializer only function _postQuestionToOracle(     string calldata _question,     uint32 _oracleResolutionTime ) internal {     questionId = realitio.askQuestion(         2,         _question,         arbitrator,         timeout,         _oracleResolutionTime,         0     );     emit LogQuestionPostedToOracle(address(this), questionId); }  /// @notice has the oracle finalised function isFinalized() public view returns (bool) {     bool _isFinalized = realitio.isFinalized(questionId);     return _isFinalized; }  /// @dev sets the winning outcome /// @dev market.setWinner() will revert if done twice, because wrong state function getWinnerFromOracle() external {     require(isFinalized(), ""Oracle not finalised"");     // check market state to prevent market closing early     require(marketLockingTime &lt;= block.timestamp, ""Market not finished"");     questionFinalised = true;     bytes32 _winningOutcome = realitio.resultFor(questionId);     // call the market     setWinner(uint256(_winningOutcome)); }  /// @dev admin override of the oracle function setAmicableResolution(uint256 _winningOutcome) external {     require(msgSender() == factory.owner(), ""Not authorised"");     questionFinalised = true;     setWinner(_winningOutcome); }  /*╔═════════════════════════════════╗   ║  MARKET RESOLUTION FUNCTIONS    ║   ╚═════════════════════════════════╝*/  /// @notice checks whether the competition has ended, if so moves to LOCKED state /// @dev can be called by anyone /// @dev public because called within autoLock modifier &amp; setWinner function lockMarket() public {     _checkState(States.OPEN);     require(         marketLockingTime &lt;= block.timestamp,         ""Market has not finished""     );     // do a final rent collection before the contract is locked down      if (collectRentAllCards()) {         orderbook.closeMarket();         _incrementState();          for (uint256 i; i &lt; numberOfCards; i++) {             // bring the cards back to the market so the winners get the satisfcation of claiming them             _transferCard(ownerOf(i), address(this), i);             emit LogLongestOwner(i, longestOwner[i]);         }         emit LogContractLocked(true);     } }  /// @notice called by getWinnerFromOracle, sets the winner /// @param _winningOutcome the index of the winning card function setWinner(uint256 _winningOutcome) internal {     if (state == States.OPEN) {         // change the locking time to allow lockMarket to lock         marketLockingTime = SafeCast.toUint32(block.timestamp);         lockMarket();     }     if (state == States.LOCKED) {         // get the winner. This will revert if answer is not resolved.         winningOutcome = _winningOutcome;         _incrementState();         emit LogWinnerKnown(winningOutcome);     } }  /// @notice pays out winnings, or returns funds function withdraw() external {     _checkState(States.WITHDRAW);     require(!userAlreadyWithdrawn[msgSender()], ""Already withdrawn"");     userAlreadyWithdrawn[msgSender()] = true;     if (totalTimeHeld[winningOutcome] &gt; 0) {         _payoutWinnings();     } else {         _returnRent();     } }  /// @notice the longest owner of each NFT gets to keep it /// @dev LOCKED or WITHDRAW states are fine- does not need to wait for winner to be known /// @param _card the id of the card, the index function claimCard(uint256 _card) external {     _checkNotState(States.CLOSED);     _checkNotState(States.OPEN);     require(!userAlreadyClaimed[_card][msgSender()], ""Already claimed"");     userAlreadyClaimed[_card][msgSender()] = true;     require(longestOwner[_card] == msgSender(), ""Not longest owner"");     _transferCard(ownerOf(_card), longestOwner[_card], _card); }  /// @notice pays winnings function _payoutWinnings() internal {     uint256 _winningsToTransfer = 0;     uint256 _remainingCut =         ((((uint256(1000) - artistCut) - affiliateCut) - cardAffiliateCut) -             winnerCut) - creatorCut;     // calculate longest owner's extra winnings, if relevant     if (longestOwner[winningOutcome] == msgSender() &amp;&amp; winnerCut &gt; 0) {         _winningsToTransfer = (totalRentCollected * winnerCut) / (1000);     }     uint256 _remainingPot = 0;     if (mode == Mode.SAFE_MODE) {         // return all rent paid on winning card         _remainingPot =             ((totalRentCollected - rentCollectedPerCard[winningOutcome]) *                 _remainingCut) /             (1000);         _winningsToTransfer += rentCollectedPerUserPerCard[msgSender()][             winningOutcome         ];     } else {         // calculate normal winnings, if any         _remainingPot = (totalRentCollected * _remainingCut) / (1000);     }     uint256 _winnersTimeHeld = timeHeld[winningOutcome][msgSender()];     uint256 _numerator = _remainingPot * _winnersTimeHeld;     _winningsToTransfer =         _winningsToTransfer +         (_numerator / totalTimeHeld[winningOutcome]);     require(_winningsToTransfer &gt; 0, ""Not a winner"");     _payout(msgSender(), _winningsToTransfer);     emit LogWinningsPaid(msgSender(), _winningsToTransfer); }  /// @notice returns all funds to users in case of invalid outcome function _returnRent() internal {     // deduct artist share and card specific share if relevant but NOT market creator share or winner's share (no winner, market creator does not deserve)     uint256 _remainingCut =         ((uint256(1000) - artistCut) - affiliateCut) - cardAffiliateCut;     uint256 _rentCollected = rentCollectedPerUser[msgSender()];     require(_rentCollected &gt; 0, ""Paid no rent"");     uint256 _rentCollectedAdjusted =         (_rentCollected * _remainingCut) / (1000);     _payout(msgSender(), _rentCollectedAdjusted);     emit LogRentReturned(msgSender(), _rentCollectedAdjusted); }  /// @notice all payouts happen through here function _payout(address _recipient, uint256 _amount) internal {     assert(treasury.payout(_recipient, _amount)); }  /// @dev the below functions pay stakeholders (artist, creator, affiliate, card specific affiliates) /// @dev they are not called within setWinner() because of the risk of an /// @dev ....  address being a contract which refuses payment, then nobody could get winnings /// @dev [hangover from when ether was native currency, keeping in case we return to this]  /// @notice pay artist function payArtist() external {     _checkState(States.WITHDRAW);     require(!artistPaid, ""Artist already paid"");     artistPaid = true;     _processStakeholderPayment(artistCut, artistAddress); }  /// @notice pay market creator function payMarketCreator() external {     _checkState(States.WITHDRAW);     require(totalTimeHeld[winningOutcome] &gt; 0, ""No winner"");     require(!creatorPaid, ""Creator already paid"");     creatorPaid = true;     _processStakeholderPayment(creatorCut, marketCreatorAddress); }  /// @notice pay affiliate function payAffiliate() external {     _checkState(States.WITHDRAW);     require(!affiliatePaid, ""Affiliate already paid"");     affiliatePaid = true;     _processStakeholderPayment(affiliateCut, affiliateAddress); }  /// @notice pay card affiliate /// @dev does not call _processStakeholderPayment because it works differently function payCardAffiliate(uint256 _card) external {     _checkState(States.WITHDRAW);     require(!cardAffiliatePaid[_card], ""Card affiliate already paid"");     cardAffiliatePaid[_card] = true;     uint256 _cardAffiliatePayment =         (rentCollectedPerCard[_card] * cardAffiliateCut) / (1000);     if (_cardAffiliatePayment &gt; 0) {         _payout(cardAffiliateAddresses[_card], _cardAffiliatePayment);         emit LogStakeholderPaid(             cardAffiliateAddresses[_card],             _cardAffiliatePayment         );     } }  function _processStakeholderPayment(uint256 _cut, address _recipient)     internal {     if (_cut &gt; 0) {         uint256 _payment = (totalRentCollected * _cut) / (1000);         _payout(_recipient, _payment);         emit LogStakeholderPaid(_recipient, _payment);     } }  /*╔═════════════════════════════════╗   ║         CORE FUNCTIONS          ║   ╠═════════════════════════════════╣   ║             EXTERNAL            ║   ╚═════════════════════════════════╝*/  /// @dev basically functions that have _checkState(States.OPEN) on first line  /// @notice collects rent for all cards /// @dev cannot be external because it is called within the lockMarket function, therefore public function collectRentAllCards() public override returns (bool) {     _checkState(States.OPEN);     bool _success = true;     for (uint256 i = 0; i &lt; numberOfCards; i++) {         if (ownerOf(i) != address(this)) {             _success = _collectRent(i);         }         if (!_success) {             return false;         }     }     return true; }  /// @notice rent every Card at the minimum price /// @param _maxSumOfPrices a limit to the sum of the bids to place function rentAllCards(uint256 _maxSumOfPrices) external {     // check that not being front run     uint256 _actualSumOfPrices;     for (uint256 i = 0; i &lt; numberOfCards; i++) {         _actualSumOfPrices = _actualSumOfPrices + (cardPrice[i]);     }     require(_actualSumOfPrices &lt;= _maxSumOfPrices, ""Prices too high"");      for (uint256 i = 0; i &lt; numberOfCards; i++) {         if (ownerOf(i) != msgSender()) {             uint256 _newPrice;             if (cardPrice[i] &gt; 0) {                 _newPrice =                     (cardPrice[i] * (minimumPriceIncreasePercent + 100)) /                     100;             } else {                 _newPrice = MIN_RENTAL_VALUE;             }             newRental(_newPrice, 0, address(0), i);         }     } }  /// @notice to rent a Card /// @dev no event: it is emitted in _updateBid, _setNewOwner or _placeInList as appropriate /// @param _newPrice the price to rent the card for /// @param _timeHeldLimit an optional time limit to rent the card for /// @param _startingPosition where to start looking to insert the bid into the orderbook /// @param _card the index of the card to update function newRental(     uint256 _newPrice,     uint256 _timeHeldLimit,     address _startingPosition,     uint256 _card ) public autoUnlock() autoLock() {     if (state == States.OPEN) {         require(_newPrice &gt;= MIN_RENTAL_VALUE, ""Price below min"");         require(_card &lt; numberOfCards, ""Card does not exist"");          address _user = msgSender();          require(             exitedTimestamp[_user] != block.timestamp,             ""Cannot lose and re-rent in same block""         );         require(             !treasury.marketPaused(address(this)) &amp;&amp;                 !treasury.globalPause(),             ""Rentals are disabled""         );         bool _userStillForeclosed = treasury.isForeclosed(_user);         if (_userStillForeclosed) {             _userStillForeclosed = orderbook.removeUserFromOrderbook(_user);         }         if (!_userStillForeclosed) {             if (ownerOf(_card) == _user) {                 // the owner may only increase by more than X% or reduce their price                 uint256 _requiredPrice =                     (cardPrice[_card] *                         (minimumPriceIncreasePercent + 100)) / (100);                 require(                     _newPrice &gt;= _requiredPrice ||                         _newPrice &lt; cardPrice[_card],                     ""Invalid price""                 );             }              // do some cleaning up before we collect rent or check their bidRate             orderbook.removeOldBids(_user);              _collectRent(_card);              // check sufficient deposit             uint256 _userTotalBidRate =                 treasury.userTotalBids(_user) -                     (orderbook.getBidValue(_user, _card)) +                     _newPrice;             require(                 treasury.userDeposit(_user) &gt;=                     _userTotalBidRate / minRentalDayDivisor,                 ""Insufficient deposit""             );              _timeHeldLimit = _checkTimeHeldLimit(_timeHeldLimit);              // replaces _newBid and _updateBid             orderbook.addBidToOrderbook(                 _user,                 _card,                 _newPrice,                 _timeHeldLimit,                 _startingPosition             );              assert(treasury.updateLastRentalTime(_user));         }     } }  function _checkTimeHeldLimit(uint256 _timeHeldLimit)     internal     view     returns (uint256) {     if (_timeHeldLimit == 0) {         return 0;     } else {         uint256 _minRentalTime = uint256(1 days) / minRentalDayDivisor;         require(_timeHeldLimit &gt;= _minRentalTime, ""Limit too low"");         return _timeHeldLimit;     } }  /// @notice to change your timeHeldLimit without having to re-rent /// @param _timeHeldLimit an optional time limit to rent the card for /// @param _card the index of the card to update function updateTimeHeldLimit(uint256 _timeHeldLimit, uint256 _card)     external {     _checkState(States.OPEN);     address _user = msgSender();      if (_collectRent(_card)) {         _timeHeldLimit = _checkTimeHeldLimit(_timeHeldLimit);          orderbook.setTimeHeldlimit(_user, _card, _timeHeldLimit);          if (ownerOf(_card) == _user) {             cardTimeLimit[_card] = _timeHeldLimit;         }          emit LogUpdateTimeHeldLimit(_user, _timeHeldLimit, _card);     } }  /// @notice stop renting all cards function exitAll() external override {     for (uint256 i = 0; i &lt; numberOfCards; i++) {         exit(i);     } }  /// @notice stop renting a card and/or remove from orderbook /// @dev public because called by exitAll() /// @dev doesn't need to be current owner so user can prevent ownership returning to them /// @dev does not apply minimum rental duration, because it returns ownership to the next user /// @param _card The card index to exit function exit(uint256 _card) public override {     _checkState(States.OPEN);     address _msgSender = msgSender();      // block frontrunning attack     exitedTimestamp[_msgSender] = block.timestamp;      // collectRent first     _collectRent(_card);      if (ownerOf(_card) == _msgSender) {         // if current owner, find a new one         orderbook.findNewOwner(_card, block.timestamp);         assert(!orderbook.bidExists(_msgSender, address(this), _card));     } else {         // if not owner, just delete from orderbook         if (orderbook.bidExists(_msgSender, address(this), _card)) {             orderbook.removeBidFromOrderbook(_msgSender, _card);         }     } }  /// @notice ability to add liqudity to the pot without being able to win. /// @dev called by user, sponsor is msgSender function sponsor(uint256 _amount) external override {     address _creator = msgSender();     treasury.checkSponsorship(_creator, _amount);     _sponsor(_creator, _amount); }  /// @notice ability to add liqudity to the pot without being able to win. /// @dev called by Factory during market creation /// @param _sponsorAddress the msgSender of createMarket in the Factory function sponsor(address _sponsorAddress, uint256 _amount)     external     override {     _sponsor(_sponsorAddress, _amount); }  /// @dev actually processes the sponsorship function _sponsor(address _sponsorAddress, uint256 _amount) internal {     _checkNotState(States.LOCKED);     _checkNotState(States.WITHDRAW);     require(_amount &gt; 0, ""Must send something"");     // send tokens to the Treasury     require(treasury.sponsor(_sponsorAddress, _amount));     totalRentCollected = totalRentCollected + _amount;     // just so user can get it back if invalid outcome     rentCollectedPerUser[_sponsorAddress] =         rentCollectedPerUser[_sponsorAddress] +         _amount;     // allocate equally to each card, in case card specific affiliates     for (uint256 i = 0; i &lt; numberOfCards; i++) {         rentCollectedPerCard[i] =             rentCollectedPerCard[i] +             (_amount / numberOfCards);     }     emit LogSponsor(_sponsorAddress, _amount); }  /*╔═════════════════════════════════╗   ║         CORE FUNCTIONS          ║   ╠═════════════════════════════════╣   ║             INTERNAL            ║   ╚═════════════════════════════════╝*/  /// @notice collects rent for a specific card /// @dev also calculates and updates how long the current user has held the card for /// @dev is not a problem if called externally, but making internal over public to save gas function _collectRentAction(uint256 _card)     internal     returns (bool shouldContinue) {     address _user = ownerOf(_card);     uint256 _timeOfThisCollection = block.timestamp;      // don't collect rent beyond the locking time     if (marketLockingTime &lt;= block.timestamp) {         _timeOfThisCollection = marketLockingTime;     }      //only collect rent if the card is owned (ie, if owned by the contract this implies unowned)     // AND if the last collection was in the past (ie, don't do 2+ rent collections in the same block)     if (         _user != address(this) &amp;&amp;         timeLastCollected[_card] &lt; _timeOfThisCollection     ) {         // User rent collect and fetch the time the user foreclosed, 0 means they didn't foreclose yet         uint256 _timeUserForeclosed =             treasury.collectRentUser(_user, block.timestamp);          // Calculate the card timeLimitTimestamp         uint256 _cardTimeLimitTimestamp =             timeLastCollected[_card] + cardTimeLimit[_card];          // input bools         bool _foreclosed = _timeUserForeclosed != 0;         bool _limitHit =             cardTimeLimit[_card] != 0 &amp;&amp;                 _cardTimeLimitTimestamp &lt; block.timestamp;         bool _marketLocked = marketLockingTime &lt;= block.timestamp;          // outputs         bool _newOwner;         uint256 _refundTime; // seconds of rent to refund the user          /* Permutations of the events: Foreclosure, Time limit and Market Locking         ┌───────────┬─┬─┬─┬─┬─┬─┬─┬─┐         │Case       │1│2│3│4│5│6│7│8│         ├───────────┼─┼─┼─┼─┼─┼─┼─┼─┤         │Foreclosure│0│0│0│0│1│1│1│1│         │Time Limit │0│0│1│1│0│0│1│1│         │Market Lock│0│1│0│1│0│1│0│1│         └───────────┴─┴─┴─┴─┴─┴─┴─┴─┘         */          if (!_foreclosed &amp;&amp; !_limitHit &amp;&amp; !_marketLocked) {             // CASE 1             // didn't foreclose AND             // didn't hit time limit AND             // didn't lock market             // THEN simple rent collect, same owner             _timeOfThisCollection = _timeOfThisCollection;             _newOwner = false;             _refundTime = 0;         } else if (!_foreclosed &amp;&amp; !_limitHit &amp;&amp; _marketLocked) {             // CASE 2             // didn't foreclose AND             // didn't hit time limit AND             // did lock market             // THEN refund rent between locking and now             _timeOfThisCollection = marketLockingTime;             _newOwner = false;             _refundTime = block.timestamp - marketLockingTime;         } else if (!_foreclosed &amp;&amp; _limitHit &amp;&amp; !_marketLocked) {             // CASE 3             // didn't foreclose AND             // did hit time limit AND             // didn't lock market             // THEN refund rent between time limit and now             _timeOfThisCollection = _cardTimeLimitTimestamp;             _newOwner = true;             _refundTime = block.timestamp - _cardTimeLimitTimestamp;         } else if (!_foreclosed &amp;&amp; _limitHit &amp;&amp; _marketLocked) {             // CASE 4             // didn't foreclose AND             // did hit time limit AND             // did lock market             // THEN refund rent between the earliest event and now             if (_cardTimeLimitTimestamp &lt; marketLockingTime) {                 // time limit hit before market locked                 _timeOfThisCollection = _cardTimeLimitTimestamp;                 _newOwner = true;                 _refundTime = block.timestamp - _cardTimeLimitTimestamp;             } else {                 // market locked before time limit hit                 _timeOfThisCollection = marketLockingTime;                 _newOwner = false;                 _refundTime = block.timestamp - marketLockingTime;             }         } else if (_foreclosed &amp;&amp; !_limitHit &amp;&amp; !_marketLocked) {             // CASE 5             // did foreclose AND             // didn't hit time limit AND             // didn't lock market             // THEN rent OK, find new owner             _timeOfThisCollection = _timeUserForeclosed;             _newOwner = true;             _refundTime = 0;         } else if (_foreclosed &amp;&amp; !_limitHit &amp;&amp; _marketLocked) {             // CASE 6             // did foreclose AND             // didn't hit time limit AND             // did lock market             // THEN if foreclosed first rent ok, otherwise refund after locking             if (_timeUserForeclosed &lt; marketLockingTime) {                 // user foreclosed before market locked                 _timeOfThisCollection = _timeUserForeclosed;                 _newOwner = true;                 _refundTime = 0;             } else {                 // market locked before user foreclosed                 _timeOfThisCollection = marketLockingTime;                 _newOwner = false;                 _refundTime = block.timestamp - marketLockingTime;             }         } else if (_foreclosed &amp;&amp; _limitHit &amp;&amp; !_marketLocked) {             // CASE 7             // did foreclose AND             // did hit time limit AND             // didn't lock market             // THEN if foreclosed first rent ok, otherwise refund after limit             if (_timeUserForeclosed &lt; _cardTimeLimitTimestamp) {                 // user foreclosed before time limit                 _timeOfThisCollection = _timeUserForeclosed;                 _newOwner = true;                 _refundTime = 0;             } else {                 // time limit hit before user foreclosed                 _timeOfThisCollection = _cardTimeLimitTimestamp;                 _newOwner = true;                 _refundTime = _timeUserForeclosed - _cardTimeLimitTimestamp;             }         } else {             // CASE 8             // did foreclose AND             // did hit time limit AND             // did lock market             // THEN (╯°益°)╯彡┻━┻             if (                 _timeUserForeclosed &lt;= _cardTimeLimitTimestamp &amp;&amp;                 _timeUserForeclosed &lt; marketLockingTime             ) {                 // user foreclosed first (or at same time as time limit)                 _timeOfThisCollection = _timeUserForeclosed;                 _newOwner = true;                 _refundTime = 0;             } else if (                 _cardTimeLimitTimestamp &lt; _timeUserForeclosed &amp;&amp;                 _cardTimeLimitTimestamp &lt; marketLockingTime             ) {                 // time limit hit first                 _timeOfThisCollection = _cardTimeLimitTimestamp;                 _newOwner = true;                 _refundTime = _timeUserForeclosed - _cardTimeLimitTimestamp;             } else {                 // market locked first                 _timeOfThisCollection = marketLockingTime;                 _newOwner = false;                 _refundTime = _timeUserForeclosed - marketLockingTime;             }         }         if (_refundTime != 0) {             uint256 _refundAmount =                 (_refundTime * cardPrice[_card]) / 1 days;             treasury.refundUser(_user, _refundAmount);         }         _processRentCollection(_user, _card, _timeOfThisCollection); // where the rent collection actually happens          if (_newOwner) {             orderbook.findNewOwner(_card, _timeOfThisCollection);             return true;         }     } else {         // timeLastCollected is updated regardless of whether the card is owned, so that the clock starts ticking         // ... when the first owner buys it, because this function is run before ownership changes upon calling newRental         timeLastCollected[_card] = _timeOfThisCollection;     }     return false; }  /// @dev _collectRentAction goes back one owner at a time, this function repeatedly calls /// @dev ... _collectRentAction until the backlog of next owners has been processed, or maxRentIterations hit function _collectRent(uint256 _card)     internal     returns (bool didUpdateEverything) {     uint32 counter = 0;     bool shouldContinue = true;     while (counter &lt; maxRentIterations &amp;&amp; shouldContinue) {         shouldContinue = _collectRentAction(_card);         counter++;     }     return !shouldContinue; }  /// @dev processes actual rent collection and updates the state function _processRentCollection(     address _user,     uint256 _card,     uint256 _timeOfCollection ) internal {     uint256 _rentOwed =         (cardPrice[_card] *             (_timeOfCollection - timeLastCollected[_card])) / 1 days;     treasury.payRent(_rentOwed);     uint256 _timeHeldToIncrement =         (_timeOfCollection - timeLastCollected[_card]);      // if the user has a timeLimit, adjust it as necessary     if (cardTimeLimit[_card] != 0) {         orderbook.reduceTimeHeldLimit(_user, _card, _timeHeldToIncrement);         cardTimeLimit[_card] -= _timeHeldToIncrement;     }     timeHeld[_card][_user] += _timeHeldToIncrement;     totalTimeHeld[_card] += _timeHeldToIncrement;     rentCollectedPerUser[_user] += _rentOwed;     rentCollectedPerCard[_card] += _rentOwed;     rentCollectedPerUserPerCard[_user][_card] += _rentOwed;     totalRentCollected += _rentOwed;     timeLastCollected[_card] = _timeOfCollection;      // longest owner tracking     if (timeHeld[_card][_user] &gt; longestTimeHeld[_card]) {         longestTimeHeld[_card] = timeHeld[_card][_user];         longestOwner[_card] = _user;     }     emit LogRentCollection(_rentOwed, timeHeld[_card][_user], _card, _user); }  function _checkState(States currentState) internal view {     require(state == currentState, ""Incorrect state""); }  function _checkNotState(States currentState) internal view {     require(state != currentState, ""Incorrect state""); }  /// @dev should only be called thrice function _incrementState() internal {     assert(uint256(state) &lt; 4);     state = States(uint256(state) + (1));     emit LogStateChange(uint256(state)); }  /*╔═════════════════════════════════╗   ║        CIRCUIT BREAKER          ║   ╚═════════════════════════════════╝*/  /// @dev in case Oracle never resolves for any reason /// @dev does not set a winner so same as invalid outcome /// @dev market does not need to be locked, just in case lockMarket bugs out function circuitBreaker() external {     require(         block.timestamp &gt; (uint256(oracleResolutionTime) + (12 weeks)),         ""Too early""     );     _incrementState();     orderbook.closeMarket();     state = States.WITHDRAW; } /*      ▲       ▲ ▲            */  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: ""{task}"". Ideas: ""{ideas}"". As the {assistant_role}, your primary objective is to perform a thorough and detailed inspection of the provided contract code, with a particular focus on identifying vulnerabilities related to Transactions Order Dependence. Transactions Order Dependence vulnerabilities can result in unintended consequences and create opportunities for malicious actors to exploit transaction sequencing. Please conduct a thorough analysis, considering the following information: 1. Review the contract's code logic to identify any potential areas where the order of transaction execution might have an impact on the contract's behavior.   Examine critical functions, particularly those involving fund transfers or resource allocation, to ensure they are not susceptible to Transactions Order Dependence.   Investigate scenarios in which gas prices can be manipulated to change the order of transaction execution.   If you identify Transactions Order Dependence, respond with: "" Transactions Order Dependence Identified."" For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE ''' DETAILED DESCRIPTION of the vulnerability, along with recommended mitigation measures or fixes that do not require code upgrades ''' If you don't find any Transactions Order Dependence vulnerabilities, respond only with: "" NO Transactions Order Dependence."" |
| **phase_name** | TODDetector |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 1, 'modification_conclusion': '', 'cycle_index': 1, 'task': '// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.4;\n\nimport ""@openzeppelin/contracts/proxy/utils/Initializable.sol"";\nimport ""@openzeppelin/contracts/utils/math/SafeCast.sol"";\nimport ""hardhat/console.sol"";\nimport ""./interfaces/IRealitio.sol"";\nimport ""./interfaces/IRCFactory.sol"";\nimport ""./interfaces/IRCTreasury.sol"";\nimport ""./interfaces/IRCMarket.sol"";\nimport ""./interfaces/IRCNftHubL2.sol"";\nimport ""./interfaces/IRCOrderbook.sol"";\nimport ""./lib/NativeMetaTransaction.sol"";\n\n/// @title Reality Cards Market\n/// @author Andrew Stanger &amp; Daniel Chilvers\n/// @notice If you have found a bug, please contact andrew@realitycards.io- no hack pls!!\ncontract RCMarket is Initializable, NativeMetaTransaction, IRCMarket {\n    /╔═════════════════════════════════╗\n      ║            VARIABLES            ║\n      ╚═════════════════════════════════╝/\n\n    // CONTRACT SETUP\n    /// @dev = how many outcomes/teams/NFTs etc\n    uint256 public numberOfCards;\n    uint256 public constant MAX_UINT256 = type(uint256).max;\n    uint256 public constant MIN_RENTAL_VALUE = 1 ether;\n    States public override state;\n    /// @dev type of event.\n    enum Mode {CLASSIC, WINNER_TAKES_ALL, SAFE_MODE}\n    Mode public mode;\n    /// @dev so the Factory can check it\'s a market\n    bool public constant override isMarket = true;\n    /// @dev counts the total NFTs minted across all events at the time market created\n    /// @dev nft tokenId = card Id + totalNftMintCount\n    uint256 public totalNftMintCount;\n\n    // CONTRACT VARIABLES\n    IRCTreasury public treasury;\n    IRCFactory public factory;\n    IRCNftHubL2 public nfthub;\n    IRCOrderbook public orderbook;\n\n    // PRICE, DEPOSITS, RENT\n    /// @dev in wei\n    mapping(uint256 =&gt; uint256) public cardPrice;\n    /// @dev keeps track of all the rent paid by each user. So that it can be returned in case of an invalid market outcome.\n    mapping(address =&gt; uint256) public rentCollectedPerUser;\n    /// @dev keeps track of all the rent paid for each card, for card specific affiliate payout\n    mapping(uint256 =&gt; uint256) public rentCollectedPerCard;\n    /// @dev keeps track of the rent each user has paid for each card, for Safe mode payout\n    mapping(address =&gt; mapping(uint256 =&gt; uint256))\n        public rentCollectedPerUserPerCard;\n    /// @dev an easy way to track the above across all cards\n    uint256 public totalRentCollected;\n    /// @dev prevents user from exiting and re-renting in the same block (limits troll attacks)\n    mapping(address =&gt; uint256) public exitedTimestamp;\n\n    // PARAMETERS\n    /// @dev read from the Factory upon market creation, can not be changed for existing market\n    /// @dev the minimum required price increase in %\n    uint256 public minimumPriceIncreasePercent;\n    /// @dev minimum rental duration (1 day divisor: i.e. 24 = 1 hour, 48 = 30 mins)\n    uint256 public minRentalDayDivisor;\n    /// @dev maximum number of times to calcualte rent in one transaction\n    uint256 public maxRentIterations;\n\n    // TIME\n    /// @dev how many seconds each user has held each card for, for determining winnings\n    mapping(uint256 =&gt; mapping(address =&gt; uint256)) public timeHeld;\n    /// @dev sums all the timeHelds for each. Used when paying out. Should always increment at the same time as timeHeld\n    mapping(uint256 =&gt; uint256) public totalTimeHeld;\n    /// @dev used to determine the rent due. Rent is due for the period (now - timeLastCollected), at which point timeLastCollected is set to now.\n    mapping(uint256 =&gt; uint256) public timeLastCollected;\n    /// @dev to track the max timeheld of each card (for giving NFT to winner)\n    mapping(uint256 =&gt; uint256) public longestTimeHeld;\n    /// @dev to track who has owned it the most (for giving NFT to winner)\n    mapping(uint256 =&gt; address) public longestOwner;\n    /// @dev to track the card timeHeldLimit for the current owner\n    mapping(uint256 =&gt; uint256) public cardTimeLimit;\n\n    // TIMESTAMPS\n    /// @dev when the market opens\n    uint32 public marketOpeningTime;\n    /// @dev when the market locks\n    uint32 public override marketLockingTime;\n    /// @dev when the question can be answered on realitio\n    /// @dev only needed for circuit breaker\n    uint32 public oracleResolutionTime;\n\n    // PAYOUT VARIABLES\n    uint256 public winningOutcome;\n    /// @dev prevent users withdrawing twice\n    mapping(address =&gt; bool) public userAlreadyWithdrawn;\n    /// @dev prevent users claiming twice\n    mapping(uint256 =&gt; mapping(address =&gt; bool)) public userAlreadyClaimed; // cardID // user // bool\n    /// @dev the artist\n    address public artistAddress;\n    uint256 public artistCut;\n    bool public artistPaid;\n    /// @dev the affiliate\n    address public affiliateAddress;\n    uint256 public affiliateCut;\n    bool public affiliatePaid;\n    /// @dev the winner\n    uint256 public winnerCut;\n    /// @dev the market creator\n    address public marketCreatorAddress;\n    uint256 public creatorCut;\n    bool public creatorPaid;\n    /// @dev card specific recipients\n    address[] public cardAffiliateAddresses;\n    uint256 public cardAffiliateCut;\n    mapping(uint256 =&gt; bool) public cardAffiliatePaid;\n\n    // ORACLE VARIABLES\n    bytes32 public questionId;\n    bool public questionFinalised;\n    address public arbitrator;\n    uint32 public timeout;\n    IRealitio public realitio;\n    address public realitioAddress;\n\n    /╔═════════════════════════════════╗\n      ║             EVENTS              ║\n      ╚═════════════════════════════════╝/\n\n    event LogNewOwner(uint256 indexed cardId, address indexed newOwner);\n    event LogRentCollection(\n        uint256 rentCollected,\n        uint256 indexed newTimeHeld,\n        uint256 indexed cardId,\n        address indexed owner\n    );\n    event LogContractLocked(bool indexed didTheEventFinish);\n    event LogWinnerKnown(uint256 indexed winningOutcome);\n    event LogWinningsPaid(address indexed paidTo, uint256 indexed amountPaid);\n    event LogStakeholderPaid(\n        address indexed paidTo,\n        uint256 indexed amountPaid\n    );\n    event LogRentReturned(\n        address indexed returnedTo,\n        uint256 indexed amountReturned\n    );\n    event LogStateChange(uint256 indexed newState);\n    event LogUpdateTimeHeldLimit(\n        address indexed owner,\n        uint256 newLimit,\n        uint256 cardId\n    );\n    event LogSponsor(address indexed sponsor, uint256 indexed amount);\n    event LogNftUpgraded(\n        uint256 indexed currentTokenId,\n        uint256 indexed newTokenId\n    );\n    event LogPayoutDetails(\n        address indexed artistAddress,\n        address marketCreatorAddress,\n        address affiliateAddress,\n        address[] cardAffiliateAddresses,\n        uint256 indexed artistCut,\n        uint256 winnerCut,\n        uint256 creatorCut,\n        uint256 affiliateCut,\n        uint256 cardAffiliateCut\n    );\n    event LogSettings(\n        uint256 indexed minRentalDayDivisor,\n        uint256 indexed minimumPriceIncreasePercent\n    );\n    event LogLongestOwner(uint256 cardId, address longestOwner);\n    event LogQuestionPostedToOracle(\n        address indexed marketAddress,\n        bytes32 indexed questionId\n    );\n\n    /╔═════════════════════════════════╗\n      ║           CONSTRUCTOR           ║\n      ╚═════════════════════════════════╝/\n\n    /// @param _mode 0 = normal, 1 = winner takes all, 2 = Safe Mode\n    /// @param _timestamps for market opening, locking, and oracle resolution\n    /// @param _numberOfCards how many Cards in this market\n    /// @param _totalNftMintCount total existing Cards across all markets excl this event\'s Cards\n    /// @param _artistAddress where to send artist\'s cut, if any\n    /// @param _affiliateAddress where to send affiliate\'s cut, if any\n    /// @param _cardAffiliateAddresses where to send card specific affiliate\'s cut, if any\n    /// @param _marketCreatorAddress where to send market creator\'s cut, if any\n    /// @param _realitioQuestion the question posted to the Oracle\n    function initialize(\n        uint256 _mode,\n        uint32[] memory _timestamps,\n        uint256 _numberOfCards,\n        uint256 _totalNftMintCount,\n        address _artistAddress,\n        address _affiliateAddress,\n        address[] memory _cardAffiliateAddresses,\n        address _marketCreatorAddress,\n        string calldata _realitioQuestion\n    ) external override initializer {\n        assert(_mode &lt;= 2);\n\n        // initialise MetaTransactions\n        _initializeEIP712(""RealityCardsMarket"", ""1"");\n\n        // external contract variables:\n        factory = IRCFactory(msgSender());\n        treasury = factory.treasury();\n        nfthub = factory.nfthub();\n        orderbook = factory.orderbook();\n\n        // get adjustable parameters from the factory/treasury\n        uint256[5] memory _potDistribution = factory.getPotDistribution();\n        minRentalDayDivisor = treasury.minRentalDayDivisor();\n        minimumPriceIncreasePercent = factory.minimumPriceIncreasePercent();\n        maxRentIterations = factory.maxRentIterations();\n\n        // initialiiize!\n        winningOutcome = MAX_UINT256; // default invalid\n\n        // assign arguments to public variables\n        mode = Mode(_mode);\n        numberOfCards = _numberOfCards;\n        totalNftMintCount = _totalNftMintCount;\n        marketOpeningTime = _timestamps[0];\n        marketLockingTime = _timestamps[1];\n        oracleResolutionTime = _timestamps[2];\n        artistAddress = _artistAddress;\n        marketCreatorAddress = _marketCreatorAddress;\n        affiliateAddress = _affiliateAddress;\n        cardAffiliateAddresses = _cardAffiliateAddresses;\n        artistCut = _potDistribution[0];\n        winnerCut = _potDistribution[1];\n        creatorCut = _potDistribution[2];\n        affiliateCut = _potDistribution[3];\n        cardAffiliateCut = _potDistribution[4];\n        (realitio, arbitrator, timeout) = factory.getOracleSettings();\n\n        // reduce artist cut to zero if zero adddress set\n        if (_artistAddress == address(0)) {\n            artistCut = 0;\n        }\n\n        // reduce affiliate cut to zero if zero adddress set\n        if (_affiliateAddress == address(0)) {\n            affiliateCut = 0;\n        }\n\n        // check the validity of card affiliate array.\n        // if not valid, reduce payout to zero\n        if (_cardAffiliateAddresses.length == _numberOfCards) {\n            for (uint256 i = 0; i &lt; _numberOfCards; i++) {\n                if (_cardAffiliateAddresses[i] == address(0)) {\n                    cardAffiliateCut = 0;\n                }\n            }\n        } else {\n            cardAffiliateCut = 0;\n        }\n\n        // if winner takes all mode, set winnerCut to max\n        if (_mode == uint8(Mode.WINNER_TAKES_ALL)) {\n            winnerCut =\n                (((uint256(1000) - artistCut) - creatorCut) - affiliateCut) -\n                cardAffiliateCut;\n        }\n\n        // post question to Oracle\n        questionFinalised = false;\n        _postQuestionToOracle(_realitioQuestion, _timestamps[2]);\n\n        // move to OPEN immediately if market opening time in the past\n        if (marketOpeningTime &lt;= block.timestamp) {\n            _incrementState();\n        }\n\n        emit LogPayoutDetails(\n            _artistAddress,\n            _marketCreatorAddress,\n            _affiliateAddress,\n            cardAffiliateAddresses,\n            artistCut,\n            winnerCut,\n            creatorCut,\n            affiliateCut,\n            cardAffiliateCut\n        );\n        emit LogSettings(minRentalDayDivisor, minimumPriceIncreasePercent);\n    }\n\n    /╔═════════════════════════════════╗\n      ║            MODIFIERS            ║\n      ╚═════════════════════════════════╝/\n\n    /// @notice automatically opens market if appropriate\n    modifier autoUnlock() {\n        if (marketOpeningTime &lt;= block.timestamp &amp;&amp; state == States.CLOSED) {\n            _incrementState();\n        }\n        ;\n    }\n\n    /// @notice automatically locks market if appropriate\n    modifier autoLock() {\n        ;\n        if (marketLockingTime &lt;= block.timestamp) {\n            lockMarket();\n        }\n    }\n\n    /// @dev can only be called by Card owners\n    modifier onlyTokenOwner(uint256 _token) {\n        require(msgSender() == ownerOf(_token), ""Not owner"");\n        ;\n    }\n\n    /╔═════════════════════════════════╗\n      ║     NFT HUB CONTRACT CALLS      ║\n      ╚═════════════════════════════════╝/\n\n    /// @notice send NFT to mainnet\n    /// @dev upgrades not possible if market not approved\n    function upgradeCard(uint256 _card) external onlyTokenOwner(_card) {\n        _checkState(States.WITHDRAW);\n        require(\n            !factory.trapIfUnapproved() ||\n                factory.isMarketApproved(address(this)),\n            ""Upgrade blocked""\n        );\n        uint256 _tokenId = _card + totalNftMintCount;\n        _transferCard(ownerOf(_card), address(this), _card); // contract becomes final resting place\n        nfthub.withdrawWithMetadata(_tokenId);\n        emit LogNftUpgraded(_card, _tokenId);\n    }\n\n    /// @notice gets the owner of the NFT via their Card Id\n    function ownerOf(uint256 _cardId) public view override returns (address) {\n        uint256 _tokenId = _cardId + totalNftMintCount;\n        return nfthub.ownerOf(_tokenId);\n    }\n\n    /// @notice gets tokenURI via their Card Id\n    function tokenURI(uint256 _cardId)\n        public\n        view\n        override\n        returns (string memory)\n    {\n        uint256 _tokenId = _cardId + totalNftMintCount;\n        return nfthub.tokenURI(_tokenId);\n    }\n\n    /// @notice transfer ERC 721 between users\n    /// @dev called internally during contract open state\n    function _transferCard(\n        address _from,\n        address _to,\n        uint256 _cardId\n    ) internal {\n        require(\n            _from != address(0) &amp;&amp; _to != address(0),\n            ""Cannot send to/from zero address""\n        );\n        uint256 _tokenId = _cardId + totalNftMintCount;\n\n        assert(nfthub.transferNft(_from, _to, _tokenId));\n        emit LogNewOwner(_cardId, _to);\n    }\n\n    /// @notice transfer ERC 721 between users\n    /// @dev called externaly by Orderbook during contract open state\n    function transferCard(\n        address _from,\n        address _to,\n        uint256 _cardId,\n        uint256 _price,\n        uint256 _timeLimit\n    ) external override {\n        require(msgSender() == address(orderbook), ""Not orderbook"");\n        _checkState(States.OPEN);\n        if (_to != _from) {\n            _transferCard(_from, _to, _cardId);\n        }\n        cardTimeLimit[_cardId] = _timeLimit;\n        cardPrice[_cardId] = _price;\n    }\n\n    /╔═════════════════════════════════╗\n      ║        ORACLE FUNCTIONS         ║\n      ╚═════════════════════════════════╝/\n\n    /// @dev called within initializer only\n    function _postQuestionToOracle(\n        string calldata _question,\n        uint32 _oracleResolutionTime\n    ) internal {\n        questionId = realitio.askQuestion(\n            2,\n            _question,\n            arbitrator,\n            timeout,\n            _oracleResolutionTime,\n            0\n        );\n        emit LogQuestionPostedToOracle(address(this), questionId);\n    }\n\n    /// @notice has the oracle finalised\n    function isFinalized() public view returns (bool) {\n        bool _isFinalized = realitio.isFinalized(questionId);\n        return _isFinalized;\n    }\n\n    /// @dev sets the winning outcome\n    /// @dev market.setWinner() will revert if done twice, because wrong state\n    function getWinnerFromOracle() external {\n        require(isFinalized(), ""Oracle not finalised"");\n        // check market state to prevent market closing early\n        require(marketLockingTime &lt;= block.timestamp, ""Market not finished"");\n        questionFinalised = true;\n        bytes32 _winningOutcome = realitio.resultFor(questionId);\n        // call the market\n        setWinner(uint256(_winningOutcome));\n    }\n\n    /// @dev admin override of the oracle\n    function setAmicableResolution(uint256 _winningOutcome) external {\n        require(msgSender() == factory.owner(), ""Not authorised"");\n        questionFinalised = true;\n        setWinner(_winningOutcome);\n    }\n\n    /╔═════════════════════════════════╗\n      ║  MARKET RESOLUTION FUNCTIONS    ║\n      ╚═════════════════════════════════╝/\n\n    /// @notice checks whether the competition has ended, if so moves to LOCKED state\n    /// @dev can be called by anyone\n    /// @dev public because called within autoLock modifier &amp; setWinner\n    function lockMarket() public {\n        _checkState(States.OPEN);\n        require(\n            marketLockingTime &lt;= block.timestamp,\n            ""Market has not finished""\n        );\n        // do a final rent collection before the contract is locked down\n\n        if (collectRentAllCards()) {\n            orderbook.closeMarket();\n            _incrementState();\n\n            for (uint256 i; i &lt; numberOfCards; i++) {\n                // bring the cards back to the market so the winners get the satisfcation of claiming them\n                _transferCard(ownerOf(i), address(this), i);\n                emit LogLongestOwner(i, longestOwner[i]);\n            }\n            emit LogContractLocked(true);\n        }\n    }\n\n    /// @notice called by getWinnerFromOracle, sets the winner\n    /// @param _winningOutcome the index of the winning card\n    function setWinner(uint256 _winningOutcome) internal {\n        if (state == States.OPEN) {\n            // change the locking time to allow lockMarket to lock\n            marketLockingTime = SafeCast.toUint32(block.timestamp);\n            lockMarket();\n        }\n        if (state == States.LOCKED) {\n            // get the winner. This will revert if answer is not resolved.\n            winningOutcome = _winningOutcome;\n            _incrementState();\n            emit LogWinnerKnown(winningOutcome);\n        }\n    }\n\n    /// @notice pays out winnings, or returns funds\n    function withdraw() external {\n        _checkState(States.WITHDRAW);\n        require(!userAlreadyWithdrawn[msgSender()], ""Already withdrawn"");\n        userAlreadyWithdrawn[msgSender()] = true;\n        if (totalTimeHeld[winningOutcome] &gt; 0) {\n            _payoutWinnings();\n        } else {\n            _returnRent();\n        }\n    }\n\n    /// @notice the longest owner of each NFT gets to keep it\n    /// @dev LOCKED or WITHDRAW states are fine- does not need to wait for winner to be known\n    /// @param _card the id of the card, the index\n    function claimCard(uint256 _card) external {\n        _checkNotState(States.CLOSED);\n        _checkNotState(States.OPEN);\n        require(!userAlreadyClaimed[_card][msgSender()], ""Already claimed"");\n        userAlreadyClaimed[_card][msgSender()] = true;\n        require(longestOwner[_card] == msgSender(), ""Not longest owner"");\n        _transferCard(ownerOf(_card), longestOwner[_card], _card);\n    }\n\n    /// @notice pays winnings\n    function _payoutWinnings() internal {\n        uint256 _winningsToTransfer = 0;\n        uint256 _remainingCut =\n            ((((uint256(1000) - artistCut) - affiliateCut) - cardAffiliateCut) -\n                winnerCut) - creatorCut;\n        // calculate longest owner\'s extra winnings, if relevant\n        if (longestOwner[winningOutcome] == msgSender() &amp;&amp; winnerCut &gt; 0) {\n            _winningsToTransfer = (totalRentCollected * winnerCut) / (1000);\n        }\n        uint256 _remainingPot = 0;\n        if (mode == Mode.SAFE_MODE) {\n            // return all rent paid on winning card\n            _remainingPot =\n                ((totalRentCollected - rentCollectedPerCard[winningOutcome]) \n                    _remainingCut) /\n                (1000);\n            _winningsToTransfer += rentCollectedPerUserPerCard[msgSender()][\n                winningOutcome\n            ];\n        } else {\n            // calculate normal winnings, if any\n            _remainingPot = (totalRentCollected * _remainingCut) / (1000);\n        }\n        uint256 _winnersTimeHeld = timeHeld[winningOutcome][msgSender()];\n        uint256 _numerator = _remainingPot * _winnersTimeHeld;\n        _winningsToTransfer =\n            _winningsToTransfer +\n            (_numerator / totalTimeHeld[winningOutcome]);\n        require(_winningsToTransfer &gt; 0, ""Not a winner"");\n        _payout(msgSender(), _winningsToTransfer);\n        emit LogWinningsPaid(msgSender(), _winningsToTransfer);\n    }\n\n    /// @notice returns all funds to users in case of invalid outcome\n    function _returnRent() internal {\n        // deduct artist share and card specific share if relevant but NOT market creator share or winner\'s share (no winner, market creator does not deserve)\n        uint256 _remainingCut =\n            ((uint256(1000) - artistCut) - affiliateCut) - cardAffiliateCut;\n        uint256 _rentCollected = rentCollectedPerUser[msgSender()];\n        require(_rentCollected &gt; 0, ""Paid no rent"");\n        uint256 _rentCollectedAdjusted =\n            (_rentCollected * _remainingCut) / (1000);\n        _payout(msgSender(), _rentCollectedAdjusted);\n        emit LogRentReturned(msgSender(), _rentCollectedAdjusted);\n    }\n\n    /// @notice all payouts happen through here\n    function _payout(address _recipient, uint256 _amount) internal {\n        assert(treasury.payout(_recipient, _amount));\n    }\n\n    /// @dev the below functions pay stakeholders (artist, creator, affiliate, card specific affiliates)\n    /// @dev they are not called within setWinner() because of the risk of an\n    /// @dev ....  address being a contract which refuses payment, then nobody could get winnings\n    /// @dev [hangover from when ether was native currency, keeping in case we return to this]\n\n    /// @notice pay artist\n    function payArtist() external {\n        _checkState(States.WITHDRAW);\n        require(!artistPaid, ""Artist already paid"");\n        artistPaid = true;\n        _processStakeholderPayment(artistCut, artistAddress);\n    }\n\n    /// @notice pay market creator\n    function payMarketCreator() external {\n        _checkState(States.WITHDRAW);\n        require(totalTimeHeld[winningOutcome] &gt; 0, ""No winner"");\n        require(!creatorPaid, ""Creator already paid"");\n        creatorPaid = true;\n        _processStakeholderPayment(creatorCut, marketCreatorAddress);\n    }\n\n    /// @notice pay affiliate\n    function payAffiliate() external {\n        _checkState(States.WITHDRAW);\n        require(!affiliatePaid, ""Affiliate already paid"");\n        affiliatePaid = true;\n        _processStakeholderPayment(affiliateCut, affiliateAddress);\n    }\n\n    /// @notice pay card affiliate\n    /// @dev does not call _processStakeholderPayment because it works differently\n    function payCardAffiliate(uint256 _card) external {\n        _checkState(States.WITHDRAW);\n        require(!cardAffiliatePaid[_card], ""Card affiliate already paid"");\n        cardAffiliatePaid[_card] = true;\n        uint256 _cardAffiliatePayment =\n            (rentCollectedPerCard[_card] * cardAffiliateCut) / (1000);\n        if (_cardAffiliatePayment &gt; 0) {\n            _payout(cardAffiliateAddresses[_card], _cardAffiliatePayment);\n            emit LogStakeholderPaid(\n                cardAffiliateAddresses[_card],\n                _cardAffiliatePayment\n            );\n        }\n    }\n\n    function _processStakeholderPayment(uint256 _cut, address _recipient)\n        internal\n    {\n        if (_cut &gt; 0) {\n            uint256 _payment = (totalRentCollected * _cut) / (1000);\n            _payout(_recipient, _payment);\n            emit LogStakeholderPaid(_recipient, _payment);\n        }\n    }\n\n    /╔═════════════════════════════════╗\n      ║         CORE FUNCTIONS          ║\n      ╠═════════════════════════════════╣\n      ║             EXTERNAL            ║\n      ╚═════════════════════════════════╝/\n\n    /// @dev basically functions that have _checkState(States.OPEN) on first line\n\n    /// @notice collects rent for all cards\n    /// @dev cannot be external because it is called within the lockMarket function, therefore public\n    function collectRentAllCards() public override returns (bool) {\n        _checkState(States.OPEN);\n        bool _success = true;\n        for (uint256 i = 0; i &lt; numberOfCards; i++) {\n            if (ownerOf(i) != address(this)) {\n                _success = _collectRent(i);\n            }\n            if (!_success) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /// @notice rent every Card at the minimum price\n    /// @param _maxSumOfPrices a limit to the sum of the bids to place\n    function rentAllCards(uint256 _maxSumOfPrices) external {\n        // check that not being front run\n        uint256 _actualSumOfPrices;\n        for (uint256 i = 0; i &lt; numberOfCards; i++) {\n            _actualSumOfPrices = _actualSumOfPrices + (cardPrice[i]);\n        }\n        require(_actualSumOfPrices &lt;= _maxSumOfPrices, ""Prices too high"");\n\n        for (uint256 i = 0; i &lt; numberOfCards; i++) {\n            if (ownerOf(i) != msgSender()) {\n                uint256 _newPrice;\n                if (cardPrice[i] &gt; 0) {\n                    _newPrice =\n                        (cardPrice[i] * (minimumPriceIncreasePercent + 100)) /\n                        100;\n                } else {\n                    _newPrice = MIN_RENTAL_VALUE;\n                }\n                newRental(_newPrice, 0, address(0), i);\n            }\n        }\n    }\n\n    /// @notice to rent a Card\n    /// @dev no event: it is emitted in _updateBid, _setNewOwner or _placeInList as appropriate\n    /// @param _newPrice the price to rent the card for\n    /// @param _timeHeldLimit an optional time limit to rent the card for\n    /// @param _startingPosition where to start looking to insert the bid into the orderbook\n    /// @param _card the index of the card to update\n    function newRental(\n        uint256 _newPrice,\n        uint256 _timeHeldLimit,\n        address _startingPosition,\n        uint256 _card\n    ) public autoUnlock() autoLock() {\n        if (state == States.OPEN) {\n            require(_newPrice &gt;= MIN_RENTAL_VALUE, ""Price below min"");\n            require(_card &lt; numberOfCards, ""Card does not exist"");\n\n            address _user = msgSender();\n\n            require(\n                exitedTimestamp[_user] != block.timestamp,\n                ""Cannot lose and re-rent in same block""\n            );\n            require(\n                !treasury.marketPaused(address(this)) &amp;&amp;\n                    !treasury.globalPause(),\n                ""Rentals are disabled""\n            );\n            bool _userStillForeclosed = treasury.isForeclosed(_user);\n            if (_userStillForeclosed) {\n                _userStillForeclosed = orderbook.removeUserFromOrderbook(_user);\n            }\n            if (!_userStillForeclosed) {\n                if (ownerOf(_card) == _user) {\n                    // the owner may only increase by more than X% or reduce their price\n                    uint256 _requiredPrice =\n                        (cardPrice[_card] \n                            (minimumPriceIncreasePercent + 100)) / (100);\n                    require(\n                        _newPrice &gt;= _requiredPrice ||\n                            _newPrice &lt; cardPrice[_card],\n                        ""Invalid price""\n                    );\n                }\n\n                // do some cleaning up before we collect rent or check their bidRate\n                orderbook.removeOldBids(_user);\n\n                _collectRent(_card);\n\n                // check sufficient deposit\n                uint256 _userTotalBidRate =\n                    treasury.userTotalBids(_user) -\n                        (orderbook.getBidValue(_user, _card)) +\n                        _newPrice;\n                require(\n                    treasury.userDeposit(_user) &gt;=\n                        _userTotalBidRate / minRentalDayDivisor,\n                    ""Insufficient deposit""\n                );\n\n                _timeHeldLimit = _checkTimeHeldLimit(_timeHeldLimit);\n\n                // replaces _newBid and _updateBid\n                orderbook.addBidToOrderbook(\n                    _user,\n                    _card,\n                    _newPrice,\n                    _timeHeldLimit,\n                    _startingPosition\n                );\n\n                assert(treasury.updateLastRentalTime(_user));\n            }\n        }\n    }\n\n    function _checkTimeHeldLimit(uint256 _timeHeldLimit)\n        internal\n        view\n        returns (uint256)\n    {\n        if (_timeHeldLimit == 0) {\n            return 0;\n        } else {\n            uint256 _minRentalTime = uint256(1 days) / minRentalDayDivisor;\n            require(_timeHeldLimit &gt;= _minRentalTime, ""Limit too low"");\n            return _timeHeldLimit;\n        }\n    }\n\n    /// @notice to change your timeHeldLimit without having to re-rent\n    /// @param _timeHeldLimit an optional time limit to rent the card for\n    /// @param _card the index of the card to update\n    function updateTimeHeldLimit(uint256 _timeHeldLimit, uint256 _card)\n        external\n    {\n        _checkState(States.OPEN);\n        address _user = msgSender();\n\n        if (_collectRent(_card)) {\n            _timeHeldLimit = _checkTimeHeldLimit(_timeHeldLimit);\n\n            orderbook.setTimeHeldlimit(_user, _card, _timeHeldLimit);\n\n            if (ownerOf(_card) == _user) {\n                cardTimeLimit[_card] = _timeHeldLimit;\n            }\n\n            emit LogUpdateTimeHeldLimit(_user, _timeHeldLimit, _card);\n        }\n    }\n\n    /// @notice stop renting all cards\n    function exitAll() external override {\n        for (uint256 i = 0; i &lt; numberOfCards; i++) {\n            exit(i);\n        }\n    }\n\n    /// @notice stop renting a card and/or remove from orderbook\n    /// @dev public because called by exitAll()\n    /// @dev doesn\'t need to be current owner so user can prevent ownership returning to them\n    /// @dev does not apply minimum rental duration, because it returns ownership to the next user\n    /// @param _card The card index to exit\n    function exit(uint256 _card) public override {\n        _checkState(States.OPEN);\n        address _msgSender = msgSender();\n\n        // block frontrunning attack\n        exitedTimestamp[_msgSender] = block.timestamp;\n\n        // collectRent first\n        _collectRent(_card);\n\n        if (ownerOf(_card) == _msgSender) {\n            // if current owner, find a new one\n            orderbook.findNewOwner(_card, block.timestamp);\n            assert(!orderbook.bidExists(_msgSender, address(this), _card));\n        } else {\n            // if not owner, just delete from orderbook\n            if (orderbook.bidExists(_msgSender, address(this), _card)) {\n                orderbook.removeBidFromOrderbook(_msgSender, _card);\n            }\n        }\n    }\n\n    /// @notice ability to add liqudity to the pot without being able to win.\n    /// @dev called by user, sponsor is msgSender\n    function sponsor(uint256 _amount) external override {\n        address _creator = msgSender();\n        treasury.checkSponsorship(_creator, _amount);\n        _sponsor(_creator, _amount);\n    }\n\n    /// @notice ability to add liqudity to the pot without being able to win.\n    /// @dev called by Factory during market creation\n    /// @param _sponsorAddress the msgSender of createMarket in the Factory\n    function sponsor(address _sponsorAddress, uint256 _amount)\n        external\n        override\n    {\n        _sponsor(_sponsorAddress, _amount);\n    }\n\n    /// @dev actually processes the sponsorship\n    function _sponsor(address _sponsorAddress, uint256 _amount) internal {\n        _checkNotState(States.LOCKED);\n        _checkNotState(States.WITHDRAW);\n        require(_amount &gt; 0, ""Must send something"");\n        // send tokens to the Treasury\n        require(treasury.sponsor(_sponsorAddress, _amount));\n        totalRentCollected = totalRentCollected + _amount;\n        // just so user can get it back if invalid outcome\n        rentCollectedPerUser[_sponsorAddress] =\n            rentCollectedPerUser[_sponsorAddress] +\n            _amount;\n        // allocate equally to each card, in case card specific affiliates\n        for (uint256 i = 0; i &lt; numberOfCards; i++) {\n            rentCollectedPerCard[i] =\n                rentCollectedPerCard[i] +\n                (_amount / numberOfCards);\n        }\n        emit LogSponsor(_sponsorAddress, _amount);\n    }\n\n    /╔═════════════════════════════════╗\n      ║         CORE FUNCTIONS          ║\n      ╠═════════════════════════════════╣\n      ║             INTERNAL            ║\n      ╚═════════════════════════════════╝/\n\n    /// @notice collects rent for a specific card\n    /// @dev also calculates and updates how long the current user has held the card for\n    /// @dev is not a problem if called externally, but making internal over public to save gas\n    function _collectRentAction(uint256 _card)\n        internal\n        returns (bool shouldContinue)\n    {\n        address _user = ownerOf(_card);\n        uint256 _timeOfThisCollection = block.timestamp;\n\n        // don\'t collect rent beyond the locking time\n        if (marketLockingTime &lt;= block.timestamp) {\n            _timeOfThisCollection = marketLockingTime;\n        }\n\n        //only collect rent if the card is owned (ie, if owned by the contract this implies unowned)\n        // AND if the last collection was in the past (ie, don\'t do 2+ rent collections in the same block)\n        if (\n            _user != address(this) &amp;&amp;\n            timeLastCollected[_card] &lt; _timeOfThisCollection\n        ) {\n            // User rent collect and fetch the time the user foreclosed, 0 means they didn\'t foreclose yet\n            uint256 _timeUserForeclosed =\n                treasury.collectRentUser(_user, block.timestamp);\n\n            // Calculate the card timeLimitTimestamp\n            uint256 _cardTimeLimitTimestamp =\n                timeLastCollected[_card] + cardTimeLimit[_card];\n\n            // input bools\n            bool _foreclosed = _timeUserForeclosed != 0;\n            bool _limitHit =\n                cardTimeLimit[_card] != 0 &amp;&amp;\n                    _cardTimeLimitTimestamp &lt; block.timestamp;\n            bool _marketLocked = marketLockingTime &lt;= block.timestamp;\n\n            // outputs\n            bool _newOwner;\n            uint256 _refundTime; // seconds of rent to refund the user\n\n            / Permutations of the events: Foreclosure, Time limit and Market Locking\n            ┌───────────┬─┬─┬─┬─┬─┬─┬─┬─┐\n            │Case       │1│2│3│4│5│6│7│8│\n            ├───────────┼─┼─┼─┼─┼─┼─┼─┼─┤\n            │Foreclosure│0│0│0│0│1│1│1│1│\n            │Time Limit │0│0│1│1│0│0│1│1│\n            │Market Lock│0│1│0│1│0│1│0│1│\n            └───────────┴─┴─┴─┴─┴─┴─┴─┴─┘\n            /\n\n            if (!_foreclosed &amp;&amp; !_limitHit &amp;&amp; !_marketLocked) {\n                // CASE 1\n                // didn\'t foreclose AND\n                // didn\'t hit time limit AND\n                // didn\'t lock market\n                // THEN simple rent collect, same owner\n                _timeOfThisCollection = _timeOfThisCollection;\n                _newOwner = false;\n                _refundTime = 0;\n            } else if (!_foreclosed &amp;&amp; !_limitHit &amp;&amp; _marketLocked) {\n                // CASE 2\n                // didn\'t foreclose AND\n                // didn\'t hit time limit AND\n                // did lock market\n                // THEN refund rent between locking and now\n                _timeOfThisCollection = marketLockingTime;\n                _newOwner = false;\n                _refundTime = block.timestamp - marketLockingTime;\n            } else if (!_foreclosed &amp;&amp; _limitHit &amp;&amp; !_marketLocked) {\n                // CASE 3\n                // didn\'t foreclose AND\n                // did hit time limit AND\n                // didn\'t lock market\n                // THEN refund rent between time limit and now\n                _timeOfThisCollection = _cardTimeLimitTimestamp;\n                _newOwner = true;\n                _refundTime = block.timestamp - _cardTimeLimitTimestamp;\n            } else if (!_foreclosed &amp;&amp; _limitHit &amp;&amp; _marketLocked) {\n                // CASE 4\n                // didn\'t foreclose AND\n                // did hit time limit AND\n                // did lock market\n                // THEN refund rent between the earliest event and now\n                if (_cardTimeLimitTimestamp &lt; marketLockingTime) {\n                    // time limit hit before market locked\n                    _timeOfThisCollection = _cardTimeLimitTimestamp;\n                    _newOwner = true;\n                    _refundTime = block.timestamp - _cardTimeLimitTimestamp;\n                } else {\n                    // market locked before time limit hit\n                    _timeOfThisCollection = marketLockingTime;\n                    _newOwner = false;\n                    _refundTime = block.timestamp - marketLockingTime;\n                }\n            } else if (_foreclosed &amp;&amp; !_limitHit &amp;&amp; !_marketLocked) {\n                // CASE 5\n                // did foreclose AND\n                // didn\'t hit time limit AND\n                // didn\'t lock market\n                // THEN rent OK, find new owner\n                _timeOfThisCollection = _timeUserForeclosed;\n                _newOwner = true;\n                _refundTime = 0;\n            } else if (_foreclosed &amp;&amp; !_limitHit &amp;&amp; _marketLocked) {\n                // CASE 6\n                // did foreclose AND\n                // didn\'t hit time limit AND\n                // did lock market\n                // THEN if foreclosed first rent ok, otherwise refund after locking\n                if (_timeUserForeclosed &lt; marketLockingTime) {\n                    // user foreclosed before market locked\n                    _timeOfThisCollection = _timeUserForeclosed;\n                    _newOwner = true;\n                    _refundTime = 0;\n                } else {\n                    // market locked before user foreclosed\n                    _timeOfThisCollection = marketLockingTime;\n                    _newOwner = false;\n                    _refundTime = block.timestamp - marketLockingTime;\n                }\n            } else if (_foreclosed &amp;&amp; _limitHit &amp;&amp; !_marketLocked) {\n                // CASE 7\n                // did foreclose AND\n                // did hit time limit AND\n                // didn\'t lock market\n                // THEN if foreclosed first rent ok, otherwise refund after limit\n                if (_timeUserForeclosed &lt; _cardTimeLimitTimestamp) {\n                    // user foreclosed before time limit\n                    _timeOfThisCollection = _timeUserForeclosed;\n                    _newOwner = true;\n                    _refundTime = 0;\n                } else {\n                    // time limit hit before user foreclosed\n                    _timeOfThisCollection = _cardTimeLimitTimestamp;\n                    _newOwner = true;\n                    _refundTime = _timeUserForeclosed - _cardTimeLimitTimestamp;\n                }\n            } else {\n                // CASE 8\n                // did foreclose AND\n                // did hit time limit AND\n                // did lock market\n                // THEN (╯°益°)╯彡┻━┻\n                if (\n                    _timeUserForeclosed &lt;= _cardTimeLimitTimestamp &amp;&amp;\n                    _timeUserForeclosed &lt; marketLockingTime\n                ) {\n                    // user foreclosed first (or at same time as time limit)\n                    _timeOfThisCollection = _timeUserForeclosed;\n                    _newOwner = true;\n                    _refundTime = 0;\n                } else if (\n                    _cardTimeLimitTimestamp &lt; _timeUserForeclosed &amp;&amp;\n                    _cardTimeLimitTimestamp &lt; marketLockingTime\n                ) {\n                    // time limit hit first\n                    _timeOfThisCollection = _cardTimeLimitTimestamp;\n                    _newOwner = true;\n                    _refundTime = _timeUserForeclosed - _cardTimeLimitTimestamp;\n                } else {\n                    // market locked first\n                    _timeOfThisCollection = marketLockingTime;\n                    _newOwner = false;\n                    _refundTime = _timeUserForeclosed - marketLockingTime;\n                }\n            }\n            if (_refundTime != 0) {\n                uint256 _refundAmount =\n                    (_refundTime * cardPrice[_card]) / 1 days;\n                treasury.refundUser(_user, _refundAmount);\n            }\n            _processRentCollection(_user, _card, _timeOfThisCollection); // where the rent collection actually happens\n\n            if (_newOwner) {\n                orderbook.findNewOwner(_card, _timeOfThisCollection);\n                return true;\n            }\n        } else {\n            // timeLastCollected is updated regardless of whether the card is owned, so that the clock starts ticking\n            // ... when the first owner buys it, because this function is run before ownership changes upon calling newRental\n            timeLastCollected[_card] = _timeOfThisCollection;\n        }\n        return false;\n    }\n\n    /// @dev _collectRentAction goes back one owner at a time, this function repeatedly calls\n    /// @dev ... _collectRentAction until the backlog of next owners has been processed, or maxRentIterations hit\n    function _collectRent(uint256 _card)\n        internal\n        returns (bool didUpdateEverything)\n    {\n        uint32 counter = 0;\n        bool shouldContinue = true;\n        while (counter &lt; maxRentIterations &amp;&amp; shouldContinue) {\n            shouldContinue = _collectRentAction(_card);\n            counter++;\n        }\n        return !shouldContinue;\n    }\n\n    /// @dev processes actual rent collection and updates the state\n    function _processRentCollection(\n        address _user,\n        uint256 _card,\n        uint256 _timeOfCollection\n    ) internal {\n        uint256 _rentOwed =\n            (cardPrice[_card] \n                (_timeOfCollection - timeLastCollected[_card])) / 1 days;\n        treasury.payRent(_rentOwed);\n        uint256 _timeHeldToIncrement =\n            (_timeOfCollection - timeLastCollected[_card]);\n\n        // if the user has a timeLimit, adjust it as necessary\n        if (cardTimeLimit[_card] != 0) {\n            orderbook.reduceTimeHeldLimit(_user, _card, _timeHeldToIncrement);\n            cardTimeLimit[_card] -= _timeHeldToIncrement;\n        }\n        timeHeld[_card][_user] += _timeHeldToIncrement;\n        totalTimeHeld[_card] += _timeHeldToIncrement;\n        rentCollectedPerUser[_user] += _rentOwed;\n        rentCollectedPerCard[_card] += _rentOwed;\n        rentCollectedPerUserPerCard[_user][_card] += _rentOwed;\n        totalRentCollected += _rentOwed;\n        timeLastCollected[_card] = _timeOfCollection;\n\n        // longest owner tracking\n        if (timeHeld[_card][_user] &gt; longestTimeHeld[_card]) {\n            longestTimeHeld[_card] = timeHeld[_card][_user];\n            longestOwner[_card] = _user;\n        }\n        emit LogRentCollection(_rentOwed, timeHeld[_card][_user], _card, _user);\n    }\n\n    function _checkState(States currentState) internal view {\n        require(state == currentState, ""Incorrect state"");\n    }\n\n    function _checkNotState(States currentState) internal view {\n        require(state != currentState, ""Incorrect state"");\n    }\n\n    /// @dev should only be called thrice\n    function _incrementState() internal {\n        assert(uint256(state) &lt; 4);\n        state = States(uint256(state) + (1));\n        emit LogStateChange(uint256(state));\n    }\n\n    /╔═════════════════════════════════╗\n      ║        CIRCUIT BREAKER          ║\n      ╚═════════════════════════════════╝/\n\n    /// @dev in case Oracle never resolves for any reason\n    /// @dev does not set a winner so same as invalid outcome\n    /// @dev market does not need to be locked, just in case lockMarket bugs out\n    function circuitBreaker() external {\n        require(\n            block.timestamp &gt; (uint256(oracleResolutionTime) + (12 weeks)),\n            ""Too early""\n        );\n        _incrementState();\n        orderbook.closeMarket();\n        state = States.WITHDRAW;\n    }\n    /\n         ▲  \n        ▲ ▲ \n              */\n}\n', 'ideas': ' Unchecked Low-level Calls Identified.\n\n\nUNCHECKED LOW-LEVEL CALL\n\'\'\'\nThe contract uses the `assert` function to check the result of the low-level call to `treasury.payout(_recipient, _amount)` in the `_payout` function. However, `assert` is not suitable for handling failures of external calls, as it will revert the entire transaction without providing a clear error message or a way to handle the failure gracefully. This can lead to loss of funds if the external contract fails to execute correctly.\n\nRecommended Mitigation:\nReplace the `assert` statement with a proper error handling mechanism. Use a `require` statement to check the return value of the low-level call, which will allow for a clearer error message and a more controlled failure. For example:\n\nrequire(treasury.payout(_recipient, _amount), ""Payout failed"");\n\nThis way, if the payout fails, the transaction will revert with a specific error message, and the contract can handle the failure appropriately.\n\'\'\'\n\n\n\nUNCHECKED LOW-LEVEL CALL\n\'\'\'\nThe contract also uses `assert` in the `_transferCard` function to check the result of the `nfthub.transferNft(_from, _to, _tokenId)` call. Similar to the previous case, using `assert` here can lead to issues if the transfer fails, as it does not provide a way to handle the failure gracefully.\n\nRecommended Mitigation:\nChange the `assert` to a `require` statement to ensure that the transfer is successful and provide a meaningful error message if it fails. For example:\n\nrequire(nfthub.transferNft(_from, _to, _tokenId), ""NFT transfer failed"");\n\nThis will allow for better error handling and prevent potential loss of funds or unexpected behavior in the contract.\n\'\'\'\n\n\n\nUNCHECKED LOW-LEVEL CALL\n\'\'\'\nIn the `_sponsor` function, the contract calls `treasury.sponsor(_sponsorAddress, _amount)` without checking the return value. If the `sponsor` function in the `treasury` contract fails, it could lead to unexpected behavior or loss of funds.\n\nRecommended Mitigation:\nImplement a `require` statement to check the return value of the `sponsor` call. For example:\n\nrequire(treasury.sponsor(_sponsorAddress, _amount), ""Sponsorship failed"");\n\nThis ensures that the contract can handle the failure of the external call appropriately.\n\'\'\'\n'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-02-08 10:43:58 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **task_prompt** | // SPDX-License-Identifier: AGPL-3.0 pragma solidity 0.8.4; import ""@openzeppelin/contracts/proxy/utils/Initializable.sol""; import ""@openzeppelin/contracts/utils/math/SafeCast.sol""; import ""hardhat/console.sol""; import ""./interfaces/IRealitio.sol""; import ""./interfaces/IRCFactory.sol""; import ""./interfaces/IRCTreasury.sol""; import ""./interfaces/IRCMarket.sol""; import ""./interfaces/IRCNftHubL2.sol""; import ""./interfaces/IRCOrderbook.sol""; import ""./lib/NativeMetaTransaction.sol""; /// @title Reality Cards Market /// @author Andrew Stanger &amp; Daniel Chilvers /// @notice If you have found a bug, please contact andrew@realitycards.io- no hack pls!! contract RCMarket is Initializable, NativeMetaTransaction, IRCMarket {     /╔═════════════════════════════════╗       ║            VARIABLES            ║       ╚═════════════════════════════════╝/ // CONTRACT SETUP /// @dev = how many outcomes/teams/NFTs etc uint256 public numberOfCards; uint256 public constant MAX_UINT256 = type(uint256).max; uint256 public constant MIN_RENTAL_VALUE = 1 ether; States public override state; /// @dev type of event. enum Mode {CLASSIC, WINNER_TAKES_ALL, SAFE_MODE} Mode public mode; /// @dev so the Factory can check it's a market bool public constant override isMarket = true; /// @dev counts the total NFTs minted across all events at the time market created /// @dev nft tokenId = card Id + totalNftMintCount uint256 public totalNftMintCount;  // CONTRACT VARIABLES IRCTreasury public treasury; IRCFactory public factory; IRCNftHubL2 public nfthub; IRCOrderbook public orderbook;  // PRICE, DEPOSITS, RENT /// @dev in wei mapping(uint256 =&gt; uint256) public cardPrice; /// @dev keeps track of all the rent paid by each user. So that it can be returned in case of an invalid market outcome. mapping(address =&gt; uint256) public rentCollectedPerUser; /// @dev keeps track of all the rent paid for each card, for card specific affiliate payout mapping(uint256 =&gt; uint256) public rentCollectedPerCard; /// @dev keeps track of the rent each user has paid for each card, for Safe mode payout mapping(address =&gt; mapping(uint256 =&gt; uint256))     public rentCollectedPerUserPerCard; /// @dev an easy way to track the above across all cards uint256 public totalRentCollected; /// @dev prevents user from exiting and re-renting in the same block (limits troll attacks) mapping(address =&gt; uint256) public exitedTimestamp;  // PARAMETERS /// @dev read from the Factory upon market creation, can not be changed for existing market /// @dev the minimum required price increase in % uint256 public minimumPriceIncreasePercent; /// @dev minimum rental duration (1 day divisor: i.e. 24 = 1 hour, 48 = 30 mins) uint256 public minRentalDayDivisor; /// @dev maximum number of times to calcualte rent in one transaction uint256 public maxRentIterations;  // TIME /// @dev how many seconds each user has held each card for, for determining winnings mapping(uint256 =&gt; mapping(address =&gt; uint256)) public timeHeld; /// @dev sums all the timeHelds for each. Used when paying out. Should always increment at the same time as timeHeld mapping(uint256 =&gt; uint256) public totalTimeHeld; /// @dev used to determine the rent due. Rent is due for the period (now - timeLastCollected), at which point timeLastCollected is set to now. mapping(uint256 =&gt; uint256) public timeLastCollected; /// @dev to track the max timeheld of each card (for giving NFT to winner) mapping(uint256 =&gt; uint256) public longestTimeHeld; /// @dev to track who has owned it the most (for giving NFT to winner) mapping(uint256 =&gt; address) public longestOwner; /// @dev to track the card timeHeldLimit for the current owner mapping(uint256 =&gt; uint256) public cardTimeLimit;  // TIMESTAMPS /// @dev when the market opens uint32 public marketOpeningTime; /// @dev when the market locks uint32 public override marketLockingTime; /// @dev when the question can be answered on realitio /// @dev only needed for circuit breaker uint32 public oracleResolutionTime;  // PAYOUT VARIABLES uint256 public winningOutcome; /// @dev prevent users withdrawing twice mapping(address =&gt; bool) public userAlreadyWithdrawn; /// @dev prevent users claiming twice mapping(uint256 =&gt; mapping(address =&gt; bool)) public userAlreadyClaimed; // cardID // user // bool /// @dev the artist address public artistAddress; uint256 public artistCut; bool public artistPaid; /// @dev the affiliate address public affiliateAddress; uint256 public affiliateCut; bool public affiliatePaid; /// @dev the winner uint256 public winnerCut; /// @dev the market creator address public marketCreatorAddress; uint256 public creatorCut; bool public creatorPaid; /// @dev card specific recipients address[] public cardAffiliateAddresses; uint256 public cardAffiliateCut; mapping(uint256 =&gt; bool) public cardAffiliatePaid;  // ORACLE VARIABLES bytes32 public questionId; bool public questionFinalised; address public arbitrator; uint32 public timeout; IRealitio public realitio; address public _realitioAddress;  /*╔═════════════════════════════════╗   ║             EVENTS              ║   ╚═════════════════════════════════╝*/  event LogNewOwner(uint256 indexed cardId, address indexed newOwner); event LogRentCollection(     uint256 rentCollected,     uint256 indexed newTimeHeld,     uint256 indexed cardId,     address indexed owner ); event LogContractLocked(bool indexed didTheEventFinish); event LogWinnerKnown(uint256 indexed winningOutcome); event LogWinningsPaid(address indexed paidTo, uint256 indexed amountPaid); event LogStakeholderPaid(     address indexed paidTo,     uint256 indexed amountPaid ); event LogRentReturned(     address indexed returnedTo,     uint256 indexed amountReturned ); event LogStateChange(uint256 indexed newState); event LogUpdateTimeHeldLimit(     address indexed owner,     uint256 newLimit,     uint256 cardId ); event LogSponsor(address indexed sponsor, uint256 indexed amount); event LogNftUpgraded(     uint256 indexed currentTokenId,     uint256 indexed newTokenId ); event LogPayoutDetails(     address indexed artistAddress,     address marketCreatorAddress,     address affiliateAddress,     address[] cardAffiliateAddresses,     uint256 indexed artistCut,     uint256 winnerCut,     uint256 creatorCut,     uint256 affiliateCut,     uint256 cardAffiliateCut ); event LogSettings(     uint256 indexed minRentalDayDivisor,     uint256 indexed minimumPriceIncreasePercent ); event LogLongestOwner(uint256 cardId, address longestOwner); event LogQuestionPostedToOracle(     address indexed marketAddress,     bytes32 indexed questionId );  /*╔═════════════════════════════════╗   ║           CONSTRUCTOR           ║   ╚═════════════════════════════════╝*/  /// @param _mode 0 = normal, 1 = winner takes all, 2 = Safe Mode /// @param _timestamps for market opening, locking, and oracle resolution /// @param _numberOfCards how many Cards in this market /// @param _totalNftMintCount total existing Cards across all markets excl this event's Cards /// @param _artistAddress where to send artist's cut, if any /// @param _affiliateAddress where to send affiliate's cut, if any /// @param _cardAffiliateAddresses where to send card specific affiliate's cut, if any /// @param _marketCreatorAddress where to send market creator's cut, if any /// @param _realitioQuestion the question posted to the Oracle function initialize(     uint256 _mode,     uint32[] memory _timestamps,     uint256 _numberOfCards,     uint256 _totalNftMintCount,     address _artistAddress,     address _affiliateAddress,     address[] memory _cardAffiliateAddresses,     address _marketCreatorAddress,     string calldata _realitioQuestion ) external override initializer {     assert(_mode &lt;= 2);      // initialise MetaTransactions     _initializeEIP712(""RealityCardsMarket"", ""1"");      // external contract variables:     factory = IRCFactory(msgSender());     treasury = factory.treasury();     nfthub = factory.nfthub();     orderbook = factory.orderbook();      // get adjustable parameters from the factory/treasury     uint256[5] memory _potDistribution = factory.getPotDistribution();     minRentalDayDivisor = treasury.minRentalDayDivisor();     minimumPriceIncreasePercent = factory.minimumPriceIncreasePercent();     maxRentIterations = factory.maxRentIterations();      // initialiiize!     winningOutcome = MAX_UINT256; // default invalid      // assign arguments to public variables     mode = Mode(_mode);     numberOfCards = _numberOfCards;     totalNftMintCount = _totalNftMintCount;     marketOpeningTime = _timestamps[0];     marketLockingTime = _timestamps[1];     oracleResolutionTime = _timestamps[2];     artistAddress = _artistAddress;     marketCreatorAddress = _marketCreatorAddress;     affiliateAddress = _affiliateAddress;     cardAffiliateAddresses = _cardAffiliateAddresses;     artistCut = _potDistribution[0];     winnerCut = _potDistribution[1];     creatorCut = _potDistribution[2];     affiliateCut = _potDistribution[3];     cardAffiliateCut = _potDistribution[4];     (realitio, arbitrator, timeout) = factory.getOracleSettings();      // reduce artist cut to zero if zero adddress set     if (_artistAddress == address(0)) {         artistCut = 0;     }      // reduce affiliate cut to zero if zero adddress set     if (_affiliateAddress == address(0)) {         affiliateCut = 0;     }      // check the validity of card affiliate array.     // if not valid, reduce payout to zero     if (_cardAffiliateAddresses.length == _numberOfCards) {         for (uint256 i = 0; i &lt; _numberOfCards; i++) {             if (_cardAffiliateAddresses[i] == address(0)) {                 cardAffiliateCut = 0;             }         }     } else {         cardAffiliateCut = 0;     }      // if winner takes all mode, set winnerCut to max     if (_mode == uint8(Mode.WINNER_TAKES_ALL)) {         winnerCut =             (((uint256(1000) - artistCut) - creatorCut) - affiliateCut) -             cardAffiliateCut;     }      // post question to Oracle     questionFinalised = false;     _postQuestionToOracle(_realitioQuestion, _timestamps[2]);      // move to OPEN immediately if market opening time in the past     if (marketOpeningTime &lt;= block.timestamp) {         _incrementState();     }      emit LogPayoutDetails(         _artistAddress,         _marketCreatorAddress,         _affiliateAddress,         cardAffiliateAddresses,         artistCut,         winnerCut,         creatorCut,         affiliateCut,         cardAffiliateCut     );     emit LogSettings(minRentalDayDivisor, minimumPriceIncreasePercent); }  /*╔═════════════════════════════════╗   ║            MODIFIERS            ║   ╚═════════════════════════════════╝*/  /// @notice automatically opens market if appropriate modifier autoUnlock() {     if (marketOpeningTime &lt;= block.timestamp &amp;&amp; state == States.CLOSED) {         _incrementState();     }     _; }  /// @notice automatically locks market if appropriate modifier autoLock() {     _;     if (marketLockingTime &lt;= block.timestamp) {         lockMarket();     } }  /// @dev can only be called by Card owners modifier onlyTokenOwner(uint256 _token) {     require(msgSender() == ownerOf(_token), ""Not owner"");     _; }  /*╔═════════════════════════════════╗   ║     NFT HUB CONTRACT CALLS      ║   ╚═════════════════════════════════╝*/  /// @notice send NFT to mainnet /// @dev upgrades not possible if market not approved function upgradeCard(uint256 _card) external onlyTokenOwner(_card) {     _checkState(States.WITHDRAW);     require(         !factory.trapIfUnapproved() ||             factory.isMarketApproved(address(this)),         ""Upgrade blocked""     );     uint256 _tokenId = _card + totalNftMintCount;     _transferCard(ownerOf(_card), address(this), _card); // contract becomes final resting place     nfthub.withdrawWithMetadata(_tokenId);     emit LogNftUpgraded(_card, _tokenId); }  /// @notice gets the owner of the NFT via their Card Id function ownerOf(uint256 _cardId) public view override returns (address) {     uint256 _tokenId = _cardId + totalNftMintCount;     return nfthub.ownerOf(_tokenId); }  /// @notice gets tokenURI via their Card Id function tokenURI(uint256 _cardId)     public     view     override     returns (string memory) {     uint256 _tokenId = _cardId + totalNftMintCount;     return nfthub.tokenURI(_tokenId); }  /// @notice transfer ERC 721 between users /// @dev called internally during contract open state function _transferCard(     address _from,     address _to,     uint256 _cardId ) internal {     require(         _from != address(0) &amp;&amp; _to != address(0),         ""Cannot send to/from zero address""     );     uint256 _tokenId = _cardId + totalNftMintCount;      assert(nfthub.transferNft(_from, _to, _tokenId));     emit LogNewOwner(_cardId, _to); }  /// @notice transfer ERC 721 between users /// @dev called externaly by Orderbook during contract open state function transferCard(     address _from,     address _to,     uint256 _cardId,     uint256 _price,     uint256 _timeLimit ) external override {     require(msgSender() == address(orderbook), ""Not orderbook"");     _checkState(States.OPEN);     if (_to != _from) {         _transferCard(_from, _to, _cardId);     }     cardTimeLimit[_cardId] = _timeLimit;     cardPrice[_cardId] = _price; }  /*╔═════════════════════════════════╗   ║        ORACLE FUNCTIONS         ║   ╚═════════════════════════════════╝*/  /// @dev called within initializer only function _postQuestionToOracle(     string calldata _question,     uint32 _oracleResolutionTime ) internal {     questionId = realitio.askQuestion(         2,         _question,         arbitrator,         timeout,         _oracleResolutionTime,         0     );     emit LogQuestionPostedToOracle(address(this), questionId); }  /// @notice has the oracle finalised function isFinalized() public view returns (bool) {     bool _isFinalized = realitio.isFinalized(questionId);     return _isFinalized; }  /// @dev sets the winning outcome /// @dev market.setWinner() will revert if done twice, because wrong state function getWinnerFromOracle() external {     require(isFinalized(), ""Oracle not finalised"");     // check market state to prevent market closing early     require(marketLockingTime &lt;= block.timestamp, ""Market not finished"");     questionFinalised = true;     bytes32 _winningOutcome = realitio.resultFor(questionId);     // call the market     setWinner(uint256(_winningOutcome)); }  /// @dev admin override of the oracle function setAmicableResolution(uint256 _winningOutcome) external {     require(msgSender() == factory.owner(), ""Not authorised"");     questionFinalised = true;     setWinner(_winningOutcome); }  /*╔═════════════════════════════════╗   ║  MARKET RESOLUTION FUNCTIONS    ║   ╚═════════════════════════════════╝*/  /// @notice checks whether the competition has ended, if so moves to LOCKED state /// @dev can be called by anyone /// @dev public because called within autoLock modifier &amp; setWinner function lockMarket() public {     _checkState(States.OPEN);     require(         marketLockingTime &lt;= block.timestamp,         ""Market has not finished""     );     // do a final rent collection before the contract is locked down      if (collectRentAllCards()) {         orderbook.closeMarket();         _incrementState();          for (uint256 i; i &lt; numberOfCards; i++) {             // bring the cards back to the market so the winners get the satisfcation of claiming them             _transferCard(ownerOf(i), address(this), i);             emit LogLongestOwner(i, longestOwner[i]);         }         emit LogContractLocked(true);     } }  /// @notice called by getWinnerFromOracle, sets the winner /// @param _winningOutcome the index of the winning card function setWinner(uint256 _winningOutcome) internal {     if (state == States.OPEN) {         // change the locking time to allow lockMarket to lock         marketLockingTime = SafeCast.toUint32(block.timestamp);         lockMarket();     }     if (state == States.LOCKED) {         // get the winner. This will revert if answer is not resolved.         winningOutcome = _winningOutcome;         _incrementState();         emit LogWinnerKnown(winningOutcome);     } }  /// @notice pays out winnings, or returns funds function withdraw() external {     _checkState(States.WITHDRAW);     require(!userAlreadyWithdrawn[msgSender()], ""Already withdrawn"");     userAlreadyWithdrawn[msgSender()] = true;     if (totalTimeHeld[winningOutcome] &gt; 0) {         _payoutWinnings();     } else {         _returnRent();     } }  /// @notice the longest owner of each NFT gets to keep it /// @dev LOCKED or WITHDRAW states are fine- does not need to wait for winner to be known /// @param _card the id of the card, the index function claimCard(uint256 _card) external {     _checkNotState(States.CLOSED);     _checkNotState(States.OPEN);     require(!userAlreadyClaimed[_card][msgSender()], ""Already claimed"");     userAlreadyClaimed[_card][msgSender()] = true;     require(longestOwner[_card] == msgSender(), ""Not longest owner"");     _transferCard(ownerOf(_card), longestOwner[_card], _card); }  /// @notice pays winnings function _payoutWinnings() internal {     uint256 _winningsToTransfer = 0;     uint256 _remainingCut =         ((((uint256(1000) - artistCut) - affiliateCut) - cardAffiliateCut) -             winnerCut) - creatorCut;     // calculate longest owner's extra winnings, if relevant     if (longestOwner[winningOutcome] == msgSender() &amp;&amp; winnerCut &gt; 0) {         _winningsToTransfer = (totalRentCollected * winnerCut) / (1000);     }     uint256 _remainingPot = 0;     if (mode == Mode.SAFE_MODE) {         // return all rent paid on winning card         _remainingPot =             ((totalRentCollected - rentCollectedPerCard[winningOutcome]) *                 _remainingCut) /             (1000);         _winningsToTransfer += rentCollectedPerUserPerCard[msgSender()][             winningOutcome         ];     } else {         // calculate normal winnings, if any         _remainingPot = (totalRentCollected * _remainingCut) / (1000);     }     uint256 _winnersTimeHeld = timeHeld[winningOutcome][msgSender()];     uint256 _numerator = _remainingPot * _winnersTimeHeld;     _winningsToTransfer =         _winningsToTransfer +         (_numerator / totalTimeHeld[winningOutcome]);     require(_winningsToTransfer &gt; 0, ""Not a winner"");     _payout(msgSender(), _winningsToTransfer);     emit LogWinningsPaid(msgSender(), _winningsToTransfer); }  /// @notice returns all funds to users in case of invalid outcome function _returnRent() internal {     // deduct artist share and card specific share if relevant but NOT market creator share or winner's share (no winner, market creator does not deserve)     uint256 _remainingCut =         ((uint256(1000) - artistCut) - affiliateCut) - cardAffiliateCut;     uint256 _rentCollected = rentCollectedPerUser[msgSender()];     require(_rentCollected &gt; 0, ""Paid no rent"");     uint256 _rentCollectedAdjusted =         (_rentCollected * _remainingCut) / (1000);     _payout(msgSender(), _rentCollectedAdjusted);     emit LogRentReturned(msgSender(), _rentCollectedAdjusted); }  /// @notice all payouts happen through here function _payout(address _recipient, uint256 _amount) internal {     assert(treasury.payout(_recipient, _amount)); }  /// @dev the below functions pay stakeholders (artist, creator, affiliate, card specific affiliates) /// @dev they are not called within setWinner() because of the risk of an /// @dev ....  address being a contract which refuses payment, then nobody could get winnings /// @dev [hangover from when ether was native currency, keeping in case we return to this]  /// @notice pay artist function payArtist() external {     _checkState(States.WITHDRAW);     require(!artistPaid, ""Artist already paid"");     artistPaid = true;     _processStakeholderPayment(artistCut, artistAddress); }  /// @notice pay market creator function payMarketCreator() external {     _checkState(States.WITHDRAW);     require(totalTimeHeld[winningOutcome] &gt; 0, ""No winner"");     require(!creatorPaid, ""Creator already paid"");     creatorPaid = true;     _processStakeholderPayment(creatorCut, marketCreatorAddress); }  /// @notice pay affiliate function payAffiliate() external {     _checkState(States.WITHDRAW);     require(!affiliatePaid, ""Affiliate already paid"");     affiliatePaid = true;     _processStakeholderPayment(affiliateCut, affiliateAddress); }  /// @notice pay card affiliate /// @dev does not call _processStakeholderPayment because it works differently function payCardAffiliate(uint256 _card) external {     _checkState(States.WITHDRAW);     require(!cardAffiliatePaid[_card], ""Card affiliate already paid"");     cardAffiliatePaid[_card] = true;     uint256 _cardAffiliatePayment =         (rentCollectedPerCard[_card] * cardAffiliateCut) / (1000);     if (_cardAffiliatePayment &gt; 0) {         _payout(cardAffiliateAddresses[_card], _cardAffiliatePayment);         emit LogStakeholderPaid(             cardAffiliateAddresses[_card],             _cardAffiliatePayment         );     } }  function _processStakeholderPayment(uint256 _cut, address _recipient)     internal {     if (_cut &gt; 0) {         uint256 _payment = (totalRentCollected * _cut) / (1000);         _payout(_recipient, _payment);         emit LogStakeholderPaid(_recipient, _payment);     } }  /*╔═════════════════════════════════╗   ║         CORE FUNCTIONS          ║   ╠═════════════════════════════════╣   ║             EXTERNAL            ║   ╚═════════════════════════════════╝*/  /// @dev basically functions that have _checkState(States.OPEN) on first line  /// @notice collects rent for all cards /// @dev cannot be external because it is called within the lockMarket function, therefore public function collectRentAllCards() public override returns (bool) {     _checkState(States.OPEN);     bool _success = true;     for (uint256 i = 0; i &lt; numberOfCards; i++) {         if (ownerOf(i) != address(this)) {             _success = _collectRent(i);         }         if (!_success) {             return false;         }     }     return true; }  /// @notice rent every Card at the minimum price /// @param _maxSumOfPrices a limit to the sum of the bids to place function rentAllCards(uint256 _maxSumOfPrices) external {     // check that not being front run     uint256 _actualSumOfPrices;     for (uint256 i = 0; i &lt; numberOfCards; i++) {         _actualSumOfPrices = _actualSumOfPrices + (cardPrice[i]);     }     require(_actualSumOfPrices &lt;= _maxSumOfPrices, ""Prices too high"");      for (uint256 i = 0; i &lt; numberOfCards; i++) {         if (ownerOf(i) != msgSender()) {             uint256 _newPrice;             if (cardPrice[i] &gt; 0) {                 _newPrice =                     (cardPrice[i] * (minimumPriceIncreasePercent + 100)) /                     100;             } else {                 _newPrice = MIN_RENTAL_VALUE;             }             newRental(_newPrice, 0, address(0), i);         }     } }  /// @notice to rent a Card /// @dev no event: it is emitted in _updateBid, _setNewOwner or _placeInList as appropriate /// @param _newPrice the price to rent the card for /// @param _timeHeldLimit an optional time limit to rent the card for /// @param _startingPosition where to start looking to insert the bid into the orderbook /// @param _card the index of the card to update function newRental(     uint256 _newPrice,     uint256 _timeHeldLimit,     address _startingPosition,     uint256 _card ) public autoUnlock() autoLock() {     if (state == States.OPEN) {         require(_newPrice &gt;= MIN_RENTAL_VALUE, ""Price below min"");         require(_card &lt; numberOfCards, ""Card does not exist"");          address _user = msgSender();          require(             exitedTimestamp[_user] != block.timestamp,             ""Cannot lose and re-rent in same block""         );         require(             !treasury.marketPaused(address(this)) &amp;&amp;                 !treasury.globalPause(),             ""Rentals are disabled""         );         bool _userStillForeclosed = treasury.isForeclosed(_user);         if (_userStillForeclosed) {             _userStillForeclosed = orderbook.removeUserFromOrderbook(_user);         }         if (!_userStillForeclosed) {             if (ownerOf(_card) == _user) {                 // the owner may only increase by more than X% or reduce their price                 uint256 _requiredPrice =                     (cardPrice[_card] *                         (minimumPriceIncreasePercent + 100)) / (100);                 require(                     _newPrice &gt;= _requiredPrice ||                         _newPrice &lt; cardPrice[_card],                     ""Invalid price""                 );             }              // do some cleaning up before we collect rent or check their bidRate             orderbook.removeOldBids(_user);              _collectRent(_card);              // check sufficient deposit             uint256 _userTotalBidRate =                 treasury.userTotalBids(_user) -                     (orderbook.getBidValue(_user, _card)) +                     _newPrice;             require(                 treasury.userDeposit(_user) &gt;=                     _userTotalBidRate / minRentalDayDivisor,                 ""Insufficient deposit""             );              _timeHeldLimit = _checkTimeHeldLimit(_timeHeldLimit);              // replaces _newBid and _updateBid             orderbook.addBidToOrderbook(                 _user,                 _card,                 _newPrice,                 _timeHeldLimit,                 _startingPosition             );              assert(treasury.updateLastRentalTime(_user));         }     } }  function _checkTimeHeldLimit(uint256 _timeHeldLimit)     internal     view     returns (uint256) {     if (_timeHeldLimit == 0) {         return 0;     } else {         uint256 _minRentalTime = uint256(1 days) / minRentalDayDivisor;         require(_timeHeldLimit &gt;= _minRentalTime, ""Limit too low"");         return _timeHeldLimit;     } }  /// @notice to change your timeHeldLimit without having to re-rent /// @param _timeHeldLimit an optional time limit to rent the card for /// @param _card the index of the card to update function updateTimeHeldLimit(uint256 _timeHeldLimit, uint256 _card)     external {     _checkState(States.OPEN);     address _user = msgSender();      if (_collectRent(_card)) {         _timeHeldLimit = _checkTimeHeldLimit(_timeHeldLimit);          orderbook.setTimeHeldlimit(_user, _card, _timeHeldLimit);          if (ownerOf(_card) == _user) {             cardTimeLimit[_card] = _timeHeldLimit;         }          emit LogUpdateTimeHeldLimit(_user, _timeHeldLimit, _card);     } }  /// @notice stop renting all cards function exitAll() external override {     for (uint256 i = 0; i &lt; numberOfCards; i++) {         exit(i);     } }  /// @notice stop renting a card and/or remove from orderbook /// @dev public because called by exitAll() /// @dev doesn't need to be current owner so user can prevent ownership returning to them /// @dev does not apply minimum rental duration, because it returns ownership to the next user /// @param _card The card index to exit function exit(uint256 _card) public override {     _checkState(States.OPEN);     address _msgSender = msgSender();      // block frontrunning attack     exitedTimestamp[_msgSender] = block.timestamp;      // collectRent first     _collectRent(_card);      if (ownerOf(_card) == _msgSender) {         // if current owner, find a new one         orderbook.findNewOwner(_card, block.timestamp);         assert(!orderbook.bidExists(_msgSender, address(this), _card));     } else {         // if not owner, just delete from orderbook         if (orderbook.bidExists(_msgSender, address(this), _card)) {             orderbook.removeBidFromOrderbook(_msgSender, _card);         }     } }  /// @notice ability to add liqudity to the pot without being able to win. /// @dev called by user, sponsor is msgSender function sponsor(uint256 _amount) external override {     address _creator = msgSender();     treasury.checkSponsorship(_creator, _amount);     _sponsor(_creator, _amount); }  /// @notice ability to add liqudity to the pot without being able to win. /// @dev called by Factory during market creation /// @param _sponsorAddress the msgSender of createMarket in the Factory function sponsor(address _sponsorAddress, uint256 _amount)     external     override {     _sponsor(_sponsorAddress, _amount); }  /// @dev actually processes the sponsorship function _sponsor(address _sponsorAddress, uint256 _amount) internal {     _checkNotState(States.LOCKED);     _checkNotState(States.WITHDRAW);     require(_amount &gt; 0, ""Must send something"");     // send tokens to the Treasury     require(treasury.sponsor(_sponsorAddress, _amount));     totalRentCollected = totalRentCollected + _amount;     // just so user can get it back if invalid outcome     rentCollectedPerUser[_sponsorAddress] =         rentCollectedPerUser[_sponsorAddress] +         _amount;     // allocate equally to each card, in case card specific affiliates     for (uint256 i = 0; i &lt; numberOfCards; i++) {         rentCollectedPerCard[i] =             rentCollectedPerCard[i] +             (_amount / numberOfCards);     }     emit LogSponsor(_sponsorAddress, _amount); }  /*╔═════════════════════════════════╗   ║         CORE FUNCTIONS          ║   ╠═════════════════════════════════╣   ║             INTERNAL            ║   ╚═════════════════════════════════╝*/  /// @notice collects rent for a specific card /// @dev also calculates and updates how long the current user has held the card for /// @dev is not a problem if called externally, but making internal over public to save gas function _collectRentAction(uint256 _card)     internal     returns (bool shouldContinue) {     address _user = ownerOf(_card);     uint256 _timeOfThisCollection = block.timestamp;      // don't collect rent beyond the locking time     if (marketLockingTime &lt;= block.timestamp) {         _timeOfThisCollection = marketLockingTime;     }      //only collect rent if the card is owned (ie, if owned by the contract this implies unowned)     // AND if the last collection was in the past (ie, don't do 2+ rent collections in the same block)     if (         _user != address(this) &amp;&amp;         timeLastCollected[_card] &lt; _timeOfThisCollection     ) {         // User rent collect and fetch the time the user foreclosed, 0 means they didn't foreclose yet         uint256 _timeUserForeclosed =             treasury.collectRentUser(_user, block.timestamp);          // Calculate the card timeLimitTimestamp         uint256 _cardTimeLimitTimestamp =             timeLastCollected[_card] + cardTimeLimit[_card];          // input bools         bool _foreclosed = _timeUserForeclosed != 0;         bool _limitHit =             cardTimeLimit[_card] != 0 &amp;&amp;                 _cardTimeLimitTimestamp &lt; block.timestamp;         bool _marketLocked = marketLockingTime &lt;= block.timestamp;          // outputs         bool _newOwner;         uint256 _refundTime; // seconds of rent to refund the user          /* Permutations of the events: Foreclosure, Time limit and Market Locking         ┌───────────┬─┬─┬─┬─┬─┬─┬─┬─┐         │Case       │1│2│3│4│5│6│7│8│         ├───────────┼─┼─┼─┼─┼─┼─┼─┼─┤         │Foreclosure│0│0│0│0│1│1│1│1│         │Time Limit │0│0│1│1│0│0│1│1│         │Market Lock│0│1│0│1│0│1│0│1│         └───────────┴─┴─┴─┴─┴─┴─┴─┴─┘         */          if (!_foreclosed &amp;&amp; !_limitHit &amp;&amp; !_marketLocked) {             // CASE 1             // didn't foreclose AND             // didn't hit time limit AND             // didn't lock market             // THEN simple rent collect, same owner             _timeOfThisCollection = _timeOfThisCollection;             _newOwner = false;             _refundTime = 0;         } else if (!_foreclosed &amp;&amp; !_limitHit &amp;&amp; _marketLocked) {             // CASE 2             // didn't foreclose AND             // didn't hit time limit AND             // did lock market             // THEN refund rent between locking and now             _timeOfThisCollection = marketLockingTime;             _newOwner = false;             _refundTime = block.timestamp - marketLockingTime;         } else if (!_foreclosed &amp;&amp; _limitHit &amp;&amp; !_marketLocked) {             // CASE 3             // didn't foreclose AND             // did hit time limit AND             // didn't lock market             // THEN refund rent between time limit and now             _timeOfThisCollection = _cardTimeLimitTimestamp;             _newOwner = true;             _refundTime = block.timestamp - _cardTimeLimitTimestamp;         } else if (!_foreclosed &amp;&amp; _limitHit &amp;&amp; _marketLocked) {             // CASE 4             // didn't foreclose AND             // did hit time limit AND             // did lock market             // THEN refund rent between the earliest event and now             if (_cardTimeLimitTimestamp &lt; marketLockingTime) {                 // time limit hit before market locked                 _timeOfThisCollection = _cardTimeLimitTimestamp;                 _newOwner = true;                 _refundTime = block.timestamp - _cardTimeLimitTimestamp;             } else {                 // market locked before time limit hit                 _timeOfThisCollection = marketLockingTime;                 _newOwner = false;                 _refundTime = block.timestamp - marketLockingTime;             }         } else if (_foreclosed &amp;&amp; !_limitHit &amp;&amp; !_marketLocked) {             // CASE 5             // did foreclose AND             // didn't hit time limit AND             // didn't lock market             // THEN rent OK, find new owner             _timeOfThisCollection = _timeUserForeclosed;             _newOwner = true;             _refundTime = 0;         } else if (_foreclosed &amp;&amp; !_limitHit &amp;&amp; _marketLocked) {             // CASE 6             // did foreclose AND             // didn't hit time limit AND             // did lock market             // THEN if foreclosed first rent ok, otherwise refund after locking             if (_timeUserForeclosed &lt; marketLockingTime) {                 // user foreclosed before market locked                 _timeOfThisCollection = _timeUserForeclosed;                 _newOwner = true;                 _refundTime = 0;             } else {                 // market locked before user foreclosed                 _timeOfThisCollection = marketLockingTime;                 _newOwner = false;                 _refundTime = block.timestamp - marketLockingTime;             }         } else if (_foreclosed &amp;&amp; _limitHit &amp;&amp; !_marketLocked) {             // CASE 7             // did foreclose AND             // did hit time limit AND             // didn't lock market             // THEN if foreclosed first rent ok, otherwise refund after limit             if (_timeUserForeclosed &lt; _cardTimeLimitTimestamp) {                 // user foreclosed before time limit                 _timeOfThisCollection = _timeUserForeclosed;                 _newOwner = true;                 _refundTime = 0;             } else {                 // time limit hit before user foreclosed                 _timeOfThisCollection = _cardTimeLimitTimestamp;                 _newOwner = true;                 _refundTime = _timeUserForeclosed - _cardTimeLimitTimestamp;             }         } else {             // CASE 8             // did foreclose AND             // did hit time limit AND             // did lock market             // THEN (╯°益°)╯彡┻━┻             if (                 _timeUserForeclosed &lt;= _cardTimeLimitTimestamp &amp;&amp;                 _timeUserForeclosed &lt; marketLockingTime             ) {                 // user foreclosed first (or at same time as time limit)                 _timeOfThisCollection = _timeUserForeclosed;                 _newOwner = true;                 _refundTime = 0;             } else if (                 _cardTimeLimitTimestamp &lt; _timeUserForeclosed &amp;&amp;                 _cardTimeLimitTimestamp &lt; marketLockingTime             ) {                 // time limit hit first                 _timeOfThisCollection = _cardTimeLimitTimestamp;                 _newOwner = true;                 _refundTime = _timeUserForeclosed - _cardTimeLimitTimestamp;             } else {                 // market locked first                 _timeOfThisCollection = marketLockingTime;                 _newOwner = false;                 _refundTime = _timeUserForeclosed - marketLockingTime;             }         }         if (_refundTime != 0) {             uint256 _refundAmount =                 (_refundTime * cardPrice[_card]) / 1 days;             treasury.refundUser(_user, _refundAmount);         }         _processRentCollection(_user, _card, _timeOfThisCollection); // where the rent collection actually happens          if (_newOwner) {             orderbook.findNewOwner(_card, _timeOfThisCollection);             return true;         }     } else {         // timeLastCollected is updated regardless of whether the card is owned, so that the clock starts ticking         // ... when the first owner buys it, because this function is run before ownership changes upon calling newRental         timeLastCollected[_card] = _timeOfThisCollection;     }     return false; }  /// @dev _collectRentAction goes back one owner at a time, this function repeatedly calls /// @dev ... _collectRentAction until the backlog of next owners has been processed, or maxRentIterations hit function _collectRent(uint256 _card)     internal     returns (bool didUpdateEverything) {     uint32 counter = 0;     bool shouldContinue = true;     while (counter &lt; maxRentIterations &amp;&amp; shouldContinue) {         shouldContinue = _collectRentAction(_card);         counter++;     }     return !shouldContinue; }  /// @dev processes actual rent collection and updates the state function _processRentCollection(     address _user,     uint256 _card,     uint256 _timeOfCollection ) internal {     uint256 _rentOwed =         (cardPrice[_card] *             (_timeOfCollection - timeLastCollected[_card])) / 1 days;     treasury.payRent(_rentOwed);     uint256 _timeHeldToIncrement =         (_timeOfCollection - timeLastCollected[_card]);      // if the user has a timeLimit, adjust it as necessary     if (cardTimeLimit[_card] != 0) {         orderbook.reduceTimeHeldLimit(_user, _card, _timeHeldToIncrement);         cardTimeLimit[_card] -= _timeHeldToIncrement;     }     timeHeld[_card][_user] += _timeHeldToIncrement;     totalTimeHeld[_card] += _timeHeldToIncrement;     rentCollectedPerUser[_user] += _rentOwed;     rentCollectedPerCard[_card] += _rentOwed;     rentCollectedPerUserPerCard[_user][_card] += _rentOwed;     totalRentCollected += _rentOwed;     timeLastCollected[_card] = _timeOfCollection;      // longest owner tracking     if (timeHeld[_card][_user] &gt; longestTimeHeld[_card]) {         longestTimeHeld[_card] = timeHeld[_card][_user];         longestOwner[_card] = _user;     }     emit LogRentCollection(_rentOwed, timeHeld[_card][_user], _card, _user); }  function _checkState(States currentState) internal view {     require(state == currentState, ""Incorrect state""); }  function _checkNotState(States currentState) internal view {     require(state != currentState, ""Incorrect state""); }  /// @dev should only be called thrice function _incrementState() internal {     assert(uint256(state) &lt; 4);     state = States(uint256(state) + (1));     emit LogStateChange(uint256(state)); }  /*╔═════════════════════════════════╗   ║        CIRCUIT BREAKER          ║   ╚═════════════════════════════════╝*/  /// @dev in case Oracle never resolves for any reason /// @dev does not set a winner so same as invalid outcome /// @dev market does not need to be locked, just in case lockMarket bugs out function circuitBreaker() external {     require(         block.timestamp &gt; (uint256(oracleResolutionTime) + (12 weeks)),         ""Too early""     );     _incrementState();     orderbook.closeMarket();     state = States.WITHDRAW; } /*      ▲       ▲ ▲            */  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-02-08 10:43:58 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: AGPL-3.0
pragma solidity 0.8.4;

import ""@openzeppelin/contracts/proxy/utils/Initializable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeCast.sol"";
import ""hardhat/console.sol"";
import ""./interfaces/IRealitio.sol"";
import ""./interfaces/IRCFactory.sol"";
import ""./interfaces/IRCTreasury.sol"";
import ""./interfaces/IRCMarket.sol"";
import ""./interfaces/IRCNftHubL2.sol"";
import ""./interfaces/IRCOrderbook.sol"";
import ""./lib/NativeMetaTransaction.sol"";

/// @title Reality Cards Market
/// @author Andrew Stanger & Daniel Chilvers
/// @notice If you have found a bug, please contact andrew@realitycards.io- no hack pls!!
contract RCMarket is Initializable, NativeMetaTransaction, IRCMarket {
    /*╔═════════════════════════════════╗
      ║            VARIABLES            ║
      ╚═════════════════════════════════╝*/

    // CONTRACT SETUP
    /// @dev = how many outcomes/teams/NFTs etc
    uint256 public numberOfCards;
    uint256 public constant MAX_UINT256 = type(uint256).max;
    uint256 public constant MIN_RENTAL_VALUE = 1 ether;
    States public override state;
    /// @dev type of event.
    enum Mode {CLASSIC, WINNER_TAKES_ALL, SAFE_MODE}
    Mode public mode;
    /// @dev so the Factory can check it's a market
    bool public constant override isMarket = true;
    /// @dev counts the total NFTs minted across all events at the time market created
    /// @dev nft tokenId = card Id + totalNftMintCount
    uint256 public totalNftMintCount;

    // CONTRACT VARIABLES
    IRCTreasury public treasury;
    IRCFactory public factory;
    IRCNftHubL2 public nfthub;
    IRCOrderbook public orderbook;

    // PRICE, DEPOSITS, RENT
    /// @dev in wei
    mapping(uint256 => uint256) public cardPrice;
    /// @dev keeps track of all the rent paid by each user. So that it can be returned in case of an invalid market outcome.
    mapping(address => uint256) public rentCollectedPerUser;
    /// @dev keeps track of all the rent paid for each card, for card specific affiliate payout
    mapping(uint256 => uint256) public rentCollectedPerCard;
    /// @dev keeps track of the rent each user has paid for each card, for Safe mode payout
    mapping(address => mapping(uint256 => uint256))
        public rentCollectedPerUserPerCard;
    /// @dev an easy way to track the above across all cards
    uint256 public totalRentCollected;
    /// @dev prevents user from exiting and re-renting in the same block (limits troll attacks)
    mapping(address => uint256) public exitedTimestamp;

    // PARAMETERS
    /// @dev read from the Factory upon market creation, can not be changed for existing market
    /// @dev the minimum required price increase in %
    uint256 public minimumPriceIncreasePercent;
    /// @dev minimum rental duration (1 day divisor: i.e. 24 = 1 hour, 48 = 30 mins)
    uint256 public minRentalDayDivisor;
    /// @dev maximum number of times to calcualte rent in one transaction
    uint256 public maxRentIterations;

    // TIME
    /// @dev how many seconds each user has held each card for, for determining winnings
    mapping(uint256 => mapping(address => uint256)) public timeHeld;
    /// @dev sums all the timeHelds for each. Used when paying out. Should always increment at the same time as timeHeld
    mapping(uint256 => uint256) public totalTimeHeld;
    /// @dev used to determine the rent due. Rent is due for the period (now - timeLastCollected), at which point timeLastCollected is set to now.
    mapping(uint256 => uint256) public timeLastCollected;
    /// @dev to track the max timeheld of each card (for giving NFT to winner)
    mapping(uint256 => uint256) public longestTimeHeld;
    /// @dev to track who has owned it the most (for giving NFT to winner)
    mapping(uint256 => address) public longestOwner;
    /// @dev to track the card timeHeldLimit for the current owner
    mapping(uint256 => uint256) public cardTimeLimit;

    // TIMESTAMPS
    /// @dev when the market opens
    uint32 public marketOpeningTime;
    /// @dev when the market locks
    uint32 public override marketLockingTime;
    /// @dev when the question can be answered on realitio
    /// @dev only needed for circuit breaker
    uint32 public oracleResolutionTime;

    // PAYOUT VARIABLES
    uint256 public winningOutcome;
    /// @dev prevent users withdrawing twice
    mapping(address => bool) public userAlreadyWithdrawn;
    /// @dev prevent users claiming twice
    mapping(uint256 => mapping(address => bool)) public userAlreadyClaimed; // cardID // user // bool
    /// @dev the artist
    address public artistAddress;
    uint256 public artistCut;
    bool public artistPaid;
    /// @dev the affiliate
    address public affiliateAddress;
    uint256 public affiliateCut;
    bool public affiliatePaid;
    /// @dev the winner
    uint256 public winnerCut;
    /// @dev the market creator
    address public marketCreatorAddress;
    uint256 public creatorCut;
    bool public creatorPaid;
    /// @dev card specific recipients
    address[] public cardAffiliateAddresses;
    uint256 public cardAffiliateCut;
    mapping(uint256 => bool) public cardAffiliatePaid;

    // ORACLE VARIABLES
    bytes32 public questionId;
    bool public questionFinalised;
    address public arbitrator;
    uint32 public timeout;
    IRealitio public realitio;
    address public _realitioAddress;

    /*╔═════════════════════════════════╗
      ║             EVENTS              ║
      ╚═════════════════════════════════╝*/

    event LogNewOwner(uint256 indexed cardId, address indexed newOwner);
    event LogRentCollection(
        uint256 rentCollected,
        uint256 indexed newTimeHeld,
        uint256 indexed cardId,
        address indexed owner
    );
    event LogContractLocked(bool indexed didTheEventFinish);
    event LogWinnerKnown(uint256 indexed winningOutcome);
    event LogWinningsPaid(address indexed paidTo, uint256 indexed amountPaid);
    event LogStakeholderPaid(
        address indexed paidTo,
        uint256 indexed amountPaid
    );
    event LogRentReturned(
        address indexed returnedTo,
        uint256 indexed amountReturned
    );
    event LogStateChange(uint256 indexed newState);
    event LogUpdateTimeHeldLimit(
        address indexed owner,
        uint256 newLimit,
        uint256 cardId
    );
    event LogSponsor(address indexed sponsor, uint256 indexed amount);
    event LogNftUpgraded(
        uint256 indexed currentTokenId,
        uint256 indexed newTokenId
    );
    event LogPayoutDetails(
        address indexed artistAddress,
        address marketCreatorAddress,
        address affiliateAddress,
        address[] cardAffiliateAddresses,
        uint256 indexed artistCut,
        uint256 winnerCut,
        uint256 creatorCut,
        uint256 affiliateCut,
        uint256 cardAffiliateCut
    );
    event LogSettings(
        uint256 indexed minRentalDayDivisor,
        uint256 indexed minimumPriceIncreasePercent
    );
    event LogLongestOwner(uint256 cardId, address longestOwner);
    event LogQuestionPostedToOracle(
        address indexed marketAddress,
        bytes32 indexed questionId
    );

    /*╔═════════════════════════════════╗
      ║           CONSTRUCTOR           ║
      ╚═════════════════════════════════╝*/

    /// @param _mode 0 = normal, 1 = winner takes all, 2 = Safe Mode
    /// @param _timestamps for market opening, locking, and oracle resolution
    /// @param _numberOfCards how many Cards in this market
    /// @param _totalNftMintCount total existing Cards across all markets excl this event's Cards
    /// @param _artistAddress where to send artist's cut, if any
    /// @param _affiliateAddress where to send affiliate's cut, if any
    /// @param _cardAffiliateAddresses where to send card specific affiliate's cut, if any
    /// @param _marketCreatorAddress where to send market creator's cut, if any
    /// @param _realitioQuestion the question posted to the Oracle
    function initialize(
        uint256 _mode,
        uint32[] memory _timestamps,
        uint256 _numberOfCards,
        uint256 _totalNftMintCount,
        address _artistAddress,
        address _affiliateAddress,
        address[] memory _cardAffiliateAddresses,
        address _marketCreatorAddress,
        string calldata _realitioQuestion
    ) external override initializer {
        assert(_mode <= 2);

        // initialise MetaTransactions
        _initializeEIP712(""RealityCardsMarket"", ""1"");

        // external contract variables:
        factory = IRCFactory(msgSender());
        treasury = factory.treasury();
        nfthub = factory.nfthub();
        orderbook = factory.orderbook();

        // get adjustable parameters from the factory/treasury
        uint256[5] memory _potDistribution = factory.getPotDistribution();
        minRentalDayDivisor = treasury.minRentalDayDivisor();
        minimumPriceIncreasePercent = factory.minimumPriceIncreasePercent();
        maxRentIterations = factory.maxRentIterations();

        // initialiiize!
        winningOutcome = MAX_UINT256; // default invalid

        // assign arguments to public variables
        mode = Mode(_mode);
        numberOfCards = _numberOfCards;
        totalNftMintCount = _totalNftMintCount;
        marketOpeningTime = _timestamps[0];
        marketLockingTime = _timestamps[1];
        oracleResolutionTime = _timestamps[2];
        artistAddress = _artistAddress;
        marketCreatorAddress = _marketCreatorAddress;
        affiliateAddress = _affiliateAddress;
        cardAffiliateAddresses = _cardAffiliateAddresses;
        artistCut = _potDistribution[0];
        winnerCut = _potDistribution[1];
        creatorCut = _potDistribution[2];
        affiliateCut = _potDistribution[3];
        cardAffiliateCut = _potDistribution[4];
        (realitio, arbitrator, timeout) = factory.getOracleSettings();

        // reduce artist cut to zero if zero adddress set
        if (_artistAddress == address(0)) {
            artistCut = 0;
        }

        // reduce affiliate cut to zero if zero adddress set
        if (_affiliateAddress == address(0)) {
            affiliateCut = 0;
        }

        // check the validity of card affiliate array.
        // if not valid, reduce payout to zero
        if (_cardAffiliateAddresses.length == _numberOfCards) {
            for (uint256 i = 0; i < _numberOfCards; i++) {
                if (_cardAffiliateAddresses[i] == address(0)) {
                    cardAffiliateCut = 0;
                }
            }
        } else {
            cardAffiliateCut = 0;
        }

        // if winner takes all mode, set winnerCut to max
        if (_mode == uint8(Mode.WINNER_TAKES_ALL)) {
            winnerCut =
                (((uint256(1000) - artistCut) - creatorCut) - affiliateCut) -
                cardAffiliateCut;
        }

        // post question to Oracle
        questionFinalised = false;
        _postQuestionToOracle(_realitioQuestion, _timestamps[2]);

        // move to OPEN immediately if market opening time in the past
        if (marketOpeningTime <= block.timestamp) {
            _incrementState();
        }

        emit LogPayoutDetails(
            _artistAddress,
            _marketCreatorAddress,
            _affiliateAddress,
            cardAffiliateAddresses,
            artistCut,
            winnerCut,
            creatorCut,
            affiliateCut,
            cardAffiliateCut
        );
        emit LogSettings(minRentalDayDivisor, minimumPriceIncreasePercent);
    }

    /*╔═════════════════════════════════╗
      ║            MODIFIERS            ║
      ╚═════════════════════════════════╝*/

    /// @notice automatically opens market if appropriate
    modifier autoUnlock() {
        if (marketOpeningTime <= block.timestamp && state == States.CLOSED) {
            _incrementState();
        }
        _;
    }

    /// @notice automatically locks market if appropriate
    modifier autoLock() {
        _;
        if (marketLockingTime <= block.timestamp) {
            lockMarket();
        }
    }

    /// @dev can only be called by Card owners
    modifier onlyTokenOwner(uint256 _token) {
        require(msgSender() == ownerOf(_token), ""Not owner"");
        _;
    }

    /*╔═════════════════════════════════╗
      ║     NFT HUB CONTRACT CALLS      ║
      ╚═════════════════════════════════╝*/

    /// @notice send NFT to mainnet
    /// @dev upgrades not possible if market not approved
    function upgradeCard(uint256 _card) external onlyTokenOwner(_card) {
        _checkState(States.WITHDRAW);
        require(
            !factory.trapIfUnapproved() ||
                factory.isMarketApproved(address(this)),
            ""Upgrade blocked""
        );
        uint256 _tokenId = _card + totalNftMintCount;
        _transferCard(ownerOf(_card), address(this), _card); // contract becomes final resting place
        nfthub.withdrawWithMetadata(_tokenId);
        emit LogNftUpgraded(_card, _tokenId);
    }

    /// @notice gets the owner of the NFT via their Card Id
    function ownerOf(uint256 _cardId) public view override returns (address) {
        uint256 _tokenId = _cardId + totalNftMintCount;
        return nfthub.ownerOf(_tokenId);
    }

    /// @notice gets tokenURI via their Card Id
    function tokenURI(uint256 _cardId)
        public
        view
        override
        returns (string memory)
    {
        uint256 _tokenId = _cardId + totalNftMintCount;
        return nfthub.tokenURI(_tokenId);
    }

    /// @notice transfer ERC 721 between users
    /// @dev called internally during contract open state
    function _transferCard(
        address _from,
        address _to,
        uint256 _cardId
    ) internal {
        require(
            _from != address(0) && _to != address(0),
            ""Cannot send to/from zero address""
        );
        uint256 _tokenId = _cardId + totalNftMintCount;

        assert(nfthub.transferNft(_from, _to, _tokenId));
        emit LogNewOwner(_cardId, _to);
    }

    /// @notice transfer ERC 721 between users
    /// @dev called externaly by Orderbook during contract open state
    function transferCard(
        address _from,
        address _to,
        uint256 _cardId,
        uint256 _price,
        uint256 _timeLimit
    ) external override {
        require(msgSender() == address(orderbook), ""Not orderbook"");
        _checkState(States.OPEN);
        if (_to != _from) {
            _transferCard(_from, _to, _cardId);
        }
        cardTimeLimit[_cardId] = _timeLimit;
        cardPrice[_cardId] = _price;
    }

    /*╔═════════════════════════════════╗
      ║        ORACLE FUNCTIONS         ║
      ╚═════════════════════════════════╝*/

    /// @dev called within initializer only
    function _postQuestionToOracle(
        string calldata _question,
        uint32 _oracleResolutionTime
    ) internal {
        questionId = realitio.askQuestion(
            2,
            _question,
            arbitrator,
            timeout,
            _oracleResolutionTime,
            0
        );
        emit LogQuestionPostedToOracle(address(this), questionId);
    }

    /// @notice has the oracle finalised
    function isFinalized() public view returns (bool) {
        bool _isFinalized = realitio.isFinalized(questionId);
        return _isFinalized;
    }

    /// @dev sets the winning outcome
    /// @dev market.setWinner() will revert if done twice, because wrong state
    function getWinnerFromOracle() external {
        require(isFinalized(), ""Oracle not finalised"");
        // check market state to prevent market closing early
        require(marketLockingTime <= block.timestamp, ""Market not finished"");
        questionFinalised = true;
        bytes32 _winningOutcome = realitio.resultFor(questionId);
        // call the market
        setWinner(uint256(_winningOutcome));
    }

    /// @dev admin override of the oracle
    function setAmicableResolution(uint256 _winningOutcome) external {
        require(msgSender() == factory.owner(), ""Not authorised"");
        questionFinalised = true;
        setWinner(_winningOutcome);
    }

    /*╔═════════════════════════════════╗
      ║  MARKET RESOLUTION FUNCTIONS    ║
      ╚═════════════════════════════════╝*/

    /// @notice checks whether the competition has ended, if so moves to LOCKED state
    /// @dev can be called by anyone
    /// @dev public because called within autoLock modifier & setWinner
    function lockMarket() public {
        _checkState(States.OPEN);
        require(
            marketLockingTime <= block.timestamp,
            ""Market has not finished""
        );
        // do a final rent collection before the contract is locked down

        if (collectRentAllCards()) {
            orderbook.closeMarket();
            _incrementState();

            for (uint256 i; i < numberOfCards; i++) {
                // bring the cards back to the market so the winners get the satisfcation of claiming them
                _transferCard(ownerOf(i), address(this), i);
                emit LogLongestOwner(i, longestOwner[i]);
            }
            emit LogContractLocked(true);
        }
    }

    /// @notice called by getWinnerFromOracle, sets the winner
    /// @param _winningOutcome the index of the winning card
    function setWinner(uint256 _winningOutcome) internal {
        if (state == States.OPEN) {
            // change the locking time to allow lockMarket to lock
            marketLockingTime = SafeCast.toUint32(block.timestamp);
            lockMarket();
        }
        if (state == States.LOCKED) {
            // get the winner. This will revert if answer is not resolved.
            winningOutcome = _winningOutcome;
            _incrementState();
            emit LogWinnerKnown(winningOutcome);
        }
    }

    /// @notice pays out winnings, or returns funds
    function withdraw() external {
        _checkState(States.WITHDRAW);
        require(!userAlreadyWithdrawn[msgSender()], ""Already withdrawn"");
        userAlreadyWithdrawn[msgSender()] = true;
        if (totalTimeHeld[winningOutcome] > 0) {
            _payoutWinnings();
        } else {
            _returnRent();
        }
    }

    /// @notice the longest owner of each NFT gets to keep it
    /// @dev LOCKED or WITHDRAW states are fine- does not need to wait for winner to be known
    /// @param _card the id of the card, the index
    function claimCard(uint256 _card) external {
        _checkNotState(States.CLOSED);
        _checkNotState(States.OPEN);
        require(!userAlreadyClaimed[_card][msgSender()], ""Already claimed"");
        userAlreadyClaimed[_card][msgSender()] = true;
        require(longestOwner[_card] == msgSender(), ""Not longest owner"");
        _transferCard(ownerOf(_card), longestOwner[_card], _card);
    }

    /// @notice pays winnings
    function _payoutWinnings() internal {
        uint256 _winningsToTransfer = 0;
        uint256 _remainingCut =
            ((((uint256(1000) - artistCut) - affiliateCut) - cardAffiliateCut) -
                winnerCut) - creatorCut;
        // calculate longest owner's extra winnings, if relevant
        if (longestOwner[winningOutcome] == msgSender() && winnerCut > 0) {
            _winningsToTransfer = (totalRentCollected * winnerCut) / (1000);
        }
        uint256 _remainingPot = 0;
        if (mode == Mode.SAFE_MODE) {
            // return all rent paid on winning card
            _remainingPot =
                ((totalRentCollected - rentCollectedPerCard[winningOutcome]) *
                    _remainingCut) /
                (1000);
            _winningsToTransfer += rentCollectedPerUserPerCard[msgSender()][
                winningOutcome
            ];
        } else {
            // calculate normal winnings, if any
            _remainingPot = (totalRentCollected * _remainingCut) / (1000);
        }
        uint256 _winnersTimeHeld = timeHeld[winningOutcome][msgSender()];
        uint256 _numerator = _remainingPot * _winnersTimeHeld;
        _winningsToTransfer =
            _winningsToTransfer +
            (_numerator / totalTimeHeld[winningOutcome]);
        require(_winningsToTransfer > 0, ""Not a winner"");
        _payout(msgSender(), _winningsToTransfer);
        emit LogWinningsPaid(msgSender(), _winningsToTransfer);
    }

    /// @notice returns all funds to users in case of invalid outcome
    function _returnRent() internal {
        // deduct artist share and card specific share if relevant but NOT market creator share or winner's share (no winner, market creator does not deserve)
        uint256 _remainingCut =
            ((uint256(1000) - artistCut) - affiliateCut) - cardAffiliateCut;
        uint256 _rentCollected = rentCollectedPerUser[msgSender()];
        require(_rentCollected > 0, ""Paid no rent"");
        uint256 _rentCollectedAdjusted =
            (_rentCollected * _remainingCut) / (1000);
        _payout(msgSender(), _rentCollectedAdjusted);
        emit LogRentReturned(msgSender(), _rentCollectedAdjusted);
    }

    /// @notice all payouts happen through here
    function _payout(address _recipient, uint256 _amount) internal {
        assert(treasury.payout(_recipient, _amount));
    }

    /// @dev the below functions pay stakeholders (artist, creator, affiliate, card specific affiliates)
    /// @dev they are not called within setWinner() because of the risk of an
    /// @dev ....  address being a contract which refuses payment, then nobody could get winnings
    /// @dev [hangover from when ether was native currency, keeping in case we return to this]

    /// @notice pay artist
    function payArtist() external {
        _checkState(States.WITHDRAW);
        require(!artistPaid, ""Artist already paid"");
        artistPaid = true;
        _processStakeholderPayment(artistCut, artistAddress);
    }

    /// @notice pay market creator
    function payMarketCreator() external {
        _checkState(States.WITHDRAW);
        require(totalTimeHeld[winningOutcome] > 0, ""No winner"");
        require(!creatorPaid, ""Creator already paid"");
        creatorPaid = true;
        _processStakeholderPayment(creatorCut, marketCreatorAddress);
    }

    /// @notice pay affiliate
    function payAffiliate() external {
        _checkState(States.WITHDRAW);
        require(!affiliatePaid, ""Affiliate already paid"");
        affiliatePaid = true;
        _processStakeholderPayment(affiliateCut, affiliateAddress);
    }

    /// @notice pay card affiliate
    /// @dev does not call _processStakeholderPayment because it works differently
    function payCardAffiliate(uint256 _card) external {
        _checkState(States.WITHDRAW);
        require(!cardAffiliatePaid[_card], ""Card affiliate already paid"");
        cardAffiliatePaid[_card] = true;
        uint256 _cardAffiliatePayment =
            (rentCollectedPerCard[_card] * cardAffiliateCut) / (1000);
        if (_cardAffiliatePayment > 0) {
            _payout(cardAffiliateAddresses[_card], _cardAffiliatePayment);
            emit LogStakeholderPaid(
                cardAffiliateAddresses[_card],
                _cardAffiliatePayment
            );
        }
    }

    function _processStakeholderPayment(uint256 _cut, address _recipient)
        internal
    {
        if (_cut > 0) {
            uint256 _payment = (totalRentCollected * _cut) / (1000);
            _payout(_recipient, _payment);
            emit LogStakeholderPaid(_recipient, _payment);
        }
    }

    /*╔═════════════════════════════════╗
      ║         CORE FUNCTIONS          ║
      ╠═════════════════════════════════╣
      ║             EXTERNAL            ║
      ╚═════════════════════════════════╝*/

    /// @dev basically functions that have _checkState(States.OPEN) on first line

    /// @notice collects rent for all cards
    /// @dev cannot be external because it is called within the lockMarket function, therefore public
    function collectRentAllCards() public override returns (bool) {
        _checkState(States.OPEN);
        bool _success = true;
        for (uint256 i = 0; i < numberOfCards; i++) {
            if (ownerOf(i) != address(this)) {
                _success = _collectRent(i);
            }
            if (!_success) {
                return false;
            }
        }
        return true;
    }

    /// @notice rent every Card at the minimum price
    /// @param _maxSumOfPrices a limit to the sum of the bids to place
    function rentAllCards(uint256 _maxSumOfPrices) external {
        // check that not being front run
        uint256 _actualSumOfPrices;
        for (uint256 i = 0; i < numberOfCards; i++) {
            _actualSumOfPrices = _actualSumOfPrices + (cardPrice[i]);
        }
        require(_actualSumOfPrices <= _maxSumOfPrices, ""Prices too high"");

        for (uint256 i = 0; i < numberOfCards; i++) {
            if (ownerOf(i) != msgSender()) {
                uint256 _newPrice;
                if (cardPrice[i] > 0) {
                    _newPrice =
                        (cardPrice[i] * (minimumPriceIncreasePercent + 100)) /
                        100;
                } else {
                    _newPrice = MIN_RENTAL_VALUE;
                }
                newRental(_newPrice, 0, address(0), i);
            }
        }
    }

    /// @notice to rent a Card
    /// @dev no event: it is emitted in _updateBid, _setNewOwner or _placeInList as appropriate
    /// @param _newPrice the price to rent the card for
    /// @param _timeHeldLimit an optional time limit to rent the card for
    /// @param _startingPosition where to start looking to insert the bid into the orderbook
    /// @param _card the index of the card to update
    function newRental(
        uint256 _newPrice,
        uint256 _timeHeldLimit,
        address _startingPosition,
        uint256 _card
    ) public autoUnlock() autoLock() {
        if (state == States.OPEN) {
            require(_newPrice >= MIN_RENTAL_VALUE, ""Price below min"");
            require(_card < numberOfCards, ""Card does not exist"");

            address _user = msgSender();

            require(
                exitedTimestamp[_user] != block.timestamp,
                ""Cannot lose and re-rent in same block""
            );
            require(
                !treasury.marketPaused(address(this)) &&
                    !treasury.globalPause(),
                ""Rentals are disabled""
            );
            bool _userStillForeclosed = treasury.isForeclosed(_user);
            if (_userStillForeclosed) {
                _userStillForeclosed = orderbook.removeUserFromOrderbook(_user);
            }
            if (!_userStillForeclosed) {
                if (ownerOf(_card) == _user) {
                    // the owner may only increase by more than X% or reduce their price
                    uint256 _requiredPrice =
                        (cardPrice[_card] *
                            (minimumPriceIncreasePercent + 100)) / (100);
                    require(
                        _newPrice >= _requiredPrice ||
                            _newPrice < cardPrice[_card],
                        ""Invalid price""
                    );
                }

                // do some cleaning up before we collect rent or check their bidRate
                orderbook.removeOldBids(_user);

                _collectRent(_card);

                // check sufficient deposit
                uint256 _userTotalBidRate =
                    treasury.userTotalBids(_user) -
                        (orderbook.getBidValue(_user, _card)) +
                        _newPrice;
                require(
                    treasury.userDeposit(_user) >=
                        _userTotalBidRate / minRentalDayDivisor,
                    ""Insufficient deposit""
                );

                _timeHeldLimit = _checkTimeHeldLimit(_timeHeldLimit);

                // replaces _newBid and _updateBid
                orderbook.addBidToOrderbook(
                    _user,
                    _card,
                    _newPrice,
                    _timeHeldLimit,
                    _startingPosition
                );

                assert(treasury.updateLastRentalTime(_user));
            }
        }
    }

    function _checkTimeHeldLimit(uint256 _timeHeldLimit)
        internal
        view
        returns (uint256)
    {
        if (_timeHeldLimit == 0) {
            return 0;
        } else {
            uint256 _minRentalTime = uint256(1 days) / minRentalDayDivisor;
            require(_timeHeldLimit >= _minRentalTime, ""Limit too low"");
            return _timeHeldLimit;
        }
    }

    /// @notice to change your timeHeldLimit without having to re-rent
    /// @param _timeHeldLimit an optional time limit to rent the card for
    /// @param _card the index of the card to update
    function updateTimeHeldLimit(uint256 _timeHeldLimit, uint256 _card)
        external
    {
        _checkState(States.OPEN);
        address _user = msgSender();

        if (_collectRent(_card)) {
            _timeHeldLimit = _checkTimeHeldLimit(_timeHeldLimit);

            orderbook.setTimeHeldlimit(_user, _card, _timeHeldLimit);

            if (ownerOf(_card) == _user) {
                cardTimeLimit[_card] = _timeHeldLimit;
            }

            emit LogUpdateTimeHeldLimit(_user, _timeHeldLimit, _card);
        }
    }

    /// @notice stop renting all cards
    function exitAll() external override {
        for (uint256 i = 0; i < numberOfCards; i++) {
            exit(i);
        }
    }

    /// @notice stop renting a card and/or remove from orderbook
    /// @dev public because called by exitAll()
    /// @dev doesn't need to be current owner so user can prevent ownership returning to them
    /// @dev does not apply minimum rental duration, because it returns ownership to the next user
    /// @param _card The card index to exit
    function exit(uint256 _card) public override {
        _checkState(States.OPEN);
        address _msgSender = msgSender();

        // block frontrunning attack
        exitedTimestamp[_msgSender] = block.timestamp;

        // collectRent first
        _collectRent(_card);

        if (ownerOf(_card) == _msgSender) {
            // if current owner, find a new one
            orderbook.findNewOwner(_card, block.timestamp);
            assert(!orderbook.bidExists(_msgSender, address(this), _card));
        } else {
            // if not owner, just delete from orderbook
            if (orderbook.bidExists(_msgSender, address(this), _card)) {
                orderbook.removeBidFromOrderbook(_msgSender, _card);
            }
        }
    }

    /// @notice ability to add liqudity to the pot without being able to win.
    /// @dev called by user, sponsor is msgSender
    function sponsor(uint256 _amount) external override {
        address _creator = msgSender();
        treasury.checkSponsorship(_creator, _amount);
        _sponsor(_creator, _amount);
    }

    /// @notice ability to add liqudity to the pot without being able to win.
    /// @dev called by Factory during market creation
    /// @param _sponsorAddress the msgSender of createMarket in the Factory
    function sponsor(address _sponsorAddress, uint256 _amount)
        external
        override
    {
        _sponsor(_sponsorAddress, _amount);
    }

    /// @dev actually processes the sponsorship
    function _sponsor(address _sponsorAddress, uint256 _amount) internal {
        _checkNotState(States.LOCKED);
        _checkNotState(States.WITHDRAW);
        require(_amount > 0, ""Must send something"");
        // send tokens to the Treasury
        require(treasury.sponsor(_sponsorAddress, _amount));
        totalRentCollected = totalRentCollected + _amount;
        // just so user can get it back if invalid outcome
        rentCollectedPerUser[_sponsorAddress] =
            rentCollectedPerUser[_sponsorAddress] +
            _amount;
        // allocate equally to each card, in case card specific affiliates
        for (uint256 i = 0; i < numberOfCards; i++) {
            rentCollectedPerCard[i] =
                rentCollectedPerCard[i] +
                (_amount / numberOfCards);
        }
        emit LogSponsor(_sponsorAddress, _amount);
    }

    /*╔═════════════════════════════════╗
      ║         CORE FUNCTIONS          ║
      ╠═════════════════════════════════╣
      ║             INTERNAL            ║
      ╚═════════════════════════════════╝*/

    /// @notice collects rent for a specific card
    /// @dev also calculates and updates how long the current user has held the card for
    /// @dev is not a problem if called externally, but making internal over public to save gas
    function _collectRentAction(uint256 _card)
        internal
        returns (bool shouldContinue)
    {
        address _user = ownerOf(_card);
        uint256 _timeOfThisCollection = block.timestamp;

        // don't collect rent beyond the locking time
        if (marketLockingTime <= block.timestamp) {
            _timeOfThisCollection = marketLockingTime;
        }

        //only collect rent if the card is owned (ie, if owned by the contract this implies unowned)
        // AND if the last collection was in the past (ie, don't do 2+ rent collections in the same block)
        if (
            _user != address(this) &&
            timeLastCollected[_card] < _timeOfThisCollection
        ) {
            // User rent collect and fetch the time the user foreclosed, 0 means they didn't foreclose yet
            uint256 _timeUserForeclosed =
                treasury.collectRentUser(_user, block.timestamp);

            // Calculate the card timeLimitTimestamp
            uint256 _cardTimeLimitTimestamp =
                timeLastCollected[_card] + cardTimeLimit[_card];

            // input bools
            bool _foreclosed = _timeUserForeclosed != 0;
            bool _limitHit =
                cardTimeLimit[_card] != 0 &&
                    _cardTimeLimitTimestamp < block.timestamp;
            bool _marketLocked = marketLockingTime <= block.timestamp;

            // outputs
            bool _newOwner;
            uint256 _refundTime; // seconds of rent to refund the user

            /* Permutations of the events: Foreclosure, Time limit and Market Locking
            ┌───────────┬─┬─┬─┬─┬─┬─┬─┬─┐
            │Case       │1│2│3│4│5│6│7│8│
            ├───────────┼─┼─┼─┼─┼─┼─┼─┼─┤
            │Foreclosure│0│0│0│0│1│1│1│1│
            │Time Limit │0│0│1│1│0│0│1│1│
            │Market Lock│0│1│0│1│0│1│0│1│
            └───────────┴─┴─┴─┴─┴─┴─┴─┴─┘
            */

            if (!_foreclosed && !_limitHit && !_marketLocked) {
                // CASE 1
                // didn't foreclose AND
                // didn't hit time limit AND
                // didn't lock market
                // THEN simple rent collect, same owner
                _timeOfThisCollection = _timeOfThisCollection;
                _newOwner = false;
                _refundTime = 0;
            } else if (!_foreclosed && !_limitHit && _marketLocked) {
                // CASE 2
                // didn't foreclose AND
                // didn't hit time limit AND
                // did lock market
                // THEN refund rent between locking and now
                _timeOfThisCollection = marketLockingTime;
                _newOwner = false;
                _refundTime = block.timestamp - marketLockingTime;
            } else if (!_foreclosed && _limitHit && !_marketLocked) {
                // CASE 3
                // didn't foreclose AND
                // did hit time limit AND
                // didn't lock market
                // THEN refund rent between time limit and now
                _timeOfThisCollection = _cardTimeLimitTimestamp;
                _newOwner = true;
                _refundTime = block.timestamp - _cardTimeLimitTimestamp;
            } else if (!_foreclosed && _limitHit && _marketLocked) {
                // CASE 4
                // didn't foreclose AND
                // did hit time limit AND
                // did lock market
                // THEN refund rent between the earliest event and now
                if (_cardTimeLimitTimestamp < marketLockingTime) {
                    // time limit hit before market locked
                    _timeOfThisCollection = _cardTimeLimitTimestamp;
                    _newOwner = true;
                    _refundTime = block.timestamp - _cardTimeLimitTimestamp;
                } else {
                    // market locked before time limit hit
                    _timeOfThisCollection = marketLockingTime;
                    _newOwner = false;
                    _refundTime = block.timestamp - marketLockingTime;
                }
            } else if (_foreclosed && !_limitHit && !_marketLocked) {
                // CASE 5
                // did foreclose AND
                // didn't hit time limit AND
                // didn't lock market
                // THEN rent OK, find new owner
                _timeOfThisCollection = _timeUserForeclosed;
                _newOwner = true;
                _refundTime = 0;
            } else if (_foreclosed && !_limitHit && _marketLocked) {
                // CASE 6
                // did foreclose AND
                // didn't hit time limit AND
                // did lock market
                // THEN if foreclosed first rent ok, otherwise refund after locking
                if (_timeUserForeclosed < marketLockingTime) {
                    // user foreclosed before market locked
                    _timeOfThisCollection = _timeUserForeclosed;
                    _newOwner = true;
                    _refundTime = 0;
                } else {
                    // market locked before user foreclosed
                    _timeOfThisCollection = marketLockingTime;
                    _newOwner = false;
                    _refundTime = block.timestamp - marketLockingTime;
                }
            } else if (_foreclosed && _limitHit && !_marketLocked) {
                // CASE 7
                // did foreclose AND
                // did hit time limit AND
                // didn't lock market
                // THEN if foreclosed first rent ok, otherwise refund after limit
                if (_timeUserForeclosed < _cardTimeLimitTimestamp) {
                    // user foreclosed before time limit
                    _timeOfThisCollection = _timeUserForeclosed;
                    _newOwner = true;
                    _refundTime = 0;
                } else {
                    // time limit hit before user foreclosed
                    _timeOfThisCollection = _cardTimeLimitTimestamp;
                    _newOwner = true;
                    _refundTime = _timeUserForeclosed - _cardTimeLimitTimestamp;
                }
            } else {
                // CASE 8
                // did foreclose AND
                // did hit time limit AND
                // did lock market
                // THEN (╯°益°)╯彡┻━┻
                if (
                    _timeUserForeclosed <= _cardTimeLimitTimestamp &&
                    _timeUserForeclosed < marketLockingTime
                ) {
                    // user foreclosed first (or at same time as time limit)
                    _timeOfThisCollection = _timeUserForeclosed;
                    _newOwner = true;
                    _refundTime = 0;
                } else if (
                    _cardTimeLimitTimestamp < _timeUserForeclosed &&
                    _cardTimeLimitTimestamp < marketLockingTime
                ) {
                    // time limit hit first
                    _timeOfThisCollection = _cardTimeLimitTimestamp;
                    _newOwner = true;
                    _refundTime = _timeUserForeclosed - _cardTimeLimitTimestamp;
                } else {
                    // market locked first
                    _timeOfThisCollection = marketLockingTime;
                    _newOwner = false;
                    _refundTime = _timeUserForeclosed - marketLockingTime;
                }
            }
            if (_refundTime != 0) {
                uint256 _refundAmount =
                    (_refundTime * cardPrice[_card]) / 1 days;
                treasury.refundUser(_user, _refundAmount);
            }
            _processRentCollection(_user, _card, _timeOfThisCollection); // where the rent collection actually happens

            if (_newOwner) {
                orderbook.findNewOwner(_card, _timeOfThisCollection);
                return true;
            }
        } else {
            // timeLastCollected is updated regardless of whether the card is owned, so that the clock starts ticking
            // ... when the first owner buys it, because this function is run before ownership changes upon calling newRental
            timeLastCollected[_card] = _timeOfThisCollection;
        }
        return false;
    }

    /// @dev _collectRentAction goes back one owner at a time, this function repeatedly calls
    /// @dev ... _collectRentAction until the backlog of next owners has been processed, or maxRentIterations hit
    function _collectRent(uint256 _card)
        internal
        returns (bool didUpdateEverything)
    {
        uint32 counter = 0;
        bool shouldContinue = true;
        while (counter < maxRentIterations && shouldContinue) {
            shouldContinue = _collectRentAction(_card);
            counter++;
        }
        return !shouldContinue;
    }

    /// @dev processes actual rent collection and updates the state
    function _processRentCollection(
        address _user,
        uint256 _card,
        uint256 _timeOfCollection
    ) internal {
        uint256 _rentOwed =
            (cardPrice[_card] *
                (_timeOfCollection - timeLastCollected[_card])) / 1 days;
        treasury.payRent(_rentOwed);
        uint256 _timeHeldToIncrement =
            (_timeOfCollection - timeLastCollected[_card]);

        // if the user has a timeLimit, adjust it as necessary
        if (cardTimeLimit[_card] != 0) {
            orderbook.reduceTimeHeldLimit(_user, _card, _timeHeldToIncrement);
            cardTimeLimit[_card] -= _timeHeldToIncrement;
        }
        timeHeld[_card][_user] += _timeHeldToIncrement;
        totalTimeHeld[_card] += _timeHeldToIncrement;
        rentCollectedPerUser[_user] += _rentOwed;
        rentCollectedPerCard[_card] += _rentOwed;
        rentCollectedPerUserPerCard[_user][_card] += _rentOwed;
        totalRentCollected += _rentOwed;
        timeLastCollected[_card] = _timeOfCollection;

        // longest owner tracking
        if (timeHeld[_card][_user] > longestTimeHeld[_card]) {
            longestTimeHeld[_card] = timeHeld[_card][_user];
            longestOwner[_card] = _user;
        }
        emit LogRentCollection(_rentOwed, timeHeld[_card][_user], _card, _user);
    }

    function _checkState(States currentState) internal view {
        require(state == currentState, ""Incorrect state"");
    }

    function _checkNotState(States currentState) internal view {
        require(state != currentState, ""Incorrect state"");
    }

    /// @dev should only be called thrice
    function _incrementState() internal {
        assert(uint256(state) < 4);
        state = States(uint256(state) + (1));
        emit LogStateChange(uint256(state));
    }

    /*╔═════════════════════════════════╗
      ║        CIRCUIT BREAKER          ║
      ╚═════════════════════════════════╝*/

    /// @dev in case Oracle never resolves for any reason
    /// @dev does not set a winner so same as invalid outcome
    /// @dev market does not need to be locked, just in case lockMarket bugs out
    function circuitBreaker() external {
        require(
            block.timestamp > (uint256(oracleResolutionTime) + (12 weeks)),
            ""Too early""
        );
        _incrementState();
        orderbook.closeMarket();
        state = States.WITHDRAW;
    }
    /*
         ▲  
        ▲ ▲ 
              */
}
.
To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs.]

Given the user's task and the brainstorming ideas provided:
Task: ""// SPDX-License-Identifier: AGPL-3.0
pragma solidity 0.8.4;

import ""@openzeppelin/contracts/proxy/utils/Initializable.sol"";
import ""@openzeppelin/contracts/utils/math/SafeCast.sol"";
import ""hardhat/console.sol"";
import ""./interfaces/IRealitio.sol"";
import ""./interfaces/IRCFactory.sol"";
import ""./interfaces/IRCTreasury.sol"";
import ""./interfaces/IRCMarket.sol"";
import ""./interfaces/IRCNftHubL2.sol"";
import ""./interfaces/IRCOrderbook.sol"";
import ""./lib/NativeMetaTransaction.sol"";

/// @title Reality Cards Market
/// @author Andrew Stanger & Daniel Chilvers
/// @notice If you have found a bug, please contact andrew@realitycards.io- no hack pls!!
contract RCMarket is Initializable, NativeMetaTransaction, IRCMarket {
    /*╔═════════════════════════════════╗
      ║            VARIABLES            ║
      ╚═════════════════════════════════╝*/

    // CONTRACT SETUP
    /// @dev = how many outcomes/teams/NFTs etc
    uint256 public numberOfCards;
    uint256 public constant MAX_UINT256 = type(uint256).max;
    uint256 public constant MIN_RENTAL_VALUE = 1 ether;
    States public override state;
    /// @dev type of event.
    enum Mode {CLASSIC, WINNER_TAKES_ALL, SAFE_MODE}
    Mode public mode;
    /// @dev so the Factory can check it's a market
    bool public constant override isMarket = true;
    /// @dev counts the total NFTs minted across all events at the time market created
    /// @dev nft tokenId = card Id + totalNftMintCount
    uint256 public totalNftMintCount;

    // CONTRACT VARIABLES
    IRCTreasury public treasury;
    IRCFactory public factory;
    IRCNftHubL2 public nfthub;
    IRCOrderbook public orderbook;

    // PRICE, DEPOSITS, RENT
    /// @dev in wei
    mapping(uint256 => uint256) public cardPrice;
    /// @dev keeps track of all the rent paid by each user. So that it can be returned in case of an invalid market outcome.
    mapping(address => uint256) public rentCollectedPerUser;
    /// @dev keeps track of all the rent paid for each card, for card specific affiliate payout
    mapping(uint256 => uint256) public rentCollectedPerCard;
    /// @dev keeps track of the rent each user has paid for each card, for Safe mode payout
    mapping(address => mapping(uint256 => uint256))
        public rentCollectedPerUserPerCard;
    /// @dev an easy way to track the above across all cards
    uint256 public totalRentCollected;
    /// @dev prevents user from exiting and re-renting in the same block (limits troll attacks)
    mapping(address => uint256) public exitedTimestamp;

    // PARAMETERS
    /// @dev read from the Factory upon market creation, can not be changed for existing market
    /// @dev the minimum required price increase in %
    uint256 public minimumPriceIncreasePercent;
    /// @dev minimum rental duration (1 day divisor: i.e. 24 = 1 hour, 48 = 30 mins)
    uint256 public minRentalDayDivisor;
    /// @dev maximum number of times to calcualte rent in one transaction
    uint256 public maxRentIterations;

    // TIME
    /// @dev how many seconds each user has held each card for, for determining winnings
    mapping(uint256 => mapping(address => uint256)) public timeHeld;
    /// @dev sums all the timeHelds for each. Used when paying out. Should always increment at the same time as timeHeld
    mapping(uint256 => uint256) public totalTimeHeld;
    /// @dev used to determine the rent due. Rent is due for the period (now - timeLastCollected), at which point timeLastCollected is set to now.
    mapping(uint256 => uint256) public timeLastCollected;
    /// @dev to track the max timeheld of each card (for giving NFT to winner)
    mapping(uint256 => uint256) public longestTimeHeld;
    /// @dev to track who has owned it the most (for giving NFT to winner)
    mapping(uint256 => address) public longestOwner;
    /// @dev to track the card timeHeldLimit for the current owner
    mapping(uint256 => uint256) public cardTimeLimit;

    // TIMESTAMPS
    /// @dev when the market opens
    uint32 public marketOpeningTime;
    /// @dev when the market locks
    uint32 public override marketLockingTime;
    /// @dev when the question can be answered on realitio
    /// @dev only needed for circuit breaker
    uint32 public oracleResolutionTime;

    // PAYOUT VARIABLES
    uint256 public winningOutcome;
    /// @dev prevent users withdrawing twice
    mapping(address => bool) public userAlreadyWithdrawn;
    /// @dev prevent users claiming twice
    mapping(uint256 => mapping(address => bool)) public userAlreadyClaimed; // cardID // user // bool
    /// @dev the artist
    address public artistAddress;
    uint256 public artistCut;
    bool public artistPaid;
    /// @dev the affiliate
    address public affiliateAddress;
    uint256 public affiliateCut;
    bool public affiliatePaid;
    /// @dev the winner
    uint256 public winnerCut;
    /// @dev the market creator
    address public marketCreatorAddress;
    uint256 public creatorCut;
    bool public creatorPaid;
    /// @dev card specific recipients
    address[] public cardAffiliateAddresses;
    uint256 public cardAffiliateCut;
    mapping(uint256 => bool) public cardAffiliatePaid;

    // ORACLE VARIABLES
    bytes32 public questionId;
    bool public questionFinalised;
    address public arbitrator;
    uint32 public timeout;
    IRealitio public realitio;
    address public _realitioAddress;

    /*╔═════════════════════════════════╗
      ║             EVENTS              ║
      ╚═════════════════════════════════╝*/

    event LogNewOwner(uint256 indexed cardId, address indexed newOwner);
    event LogRentCollection(
        uint256 rentCollected,
        uint256 indexed newTimeHeld,
        uint256 indexed cardId,
        address indexed owner
    );
    event LogContractLocked(bool indexed didTheEventFinish);
    event LogWinnerKnown(uint256 indexed winningOutcome);
    event LogWinningsPaid(address indexed paidTo, uint256 indexed amountPaid);
    event LogStakeholderPaid(
        address indexed paidTo,
        uint256 indexed amountPaid
    );
    event LogRentReturned(
        address indexed returnedTo,
        uint256 indexed amountReturned
    );
    event LogStateChange(uint256 indexed newState);
    event LogUpdateTimeHeldLimit(
        address indexed owner,
        uint256 newLimit,
        uint256 cardId
    );
    event LogSponsor(address indexed sponsor, uint256 indexed amount);
    event LogNftUpgraded(
        uint256 indexed currentTokenId,
        uint256 indexed newTokenId
    );
    event LogPayoutDetails(
        address indexed artistAddress,
        address marketCreatorAddress,
        address affiliateAddress,
        address[] cardAffiliateAddresses,
        uint256 indexed artistCut,
        uint256 winnerCut,
        uint256 creatorCut,
        uint256 affiliateCut,
        uint256 cardAffiliateCut
    );
    event LogSettings(
        uint256 indexed minRentalDayDivisor,
        uint256 indexed minimumPriceIncreasePercent
    );
    event LogLongestOwner(uint256 cardId, address longestOwner);
    event LogQuestionPostedToOracle(
        address indexed marketAddress,
        bytes32 indexed questionId
    );

    /*╔═════════════════════════════════╗
      ║           CONSTRUCTOR           ║
      ╚═════════════════════════════════╝*/

    /// @param _mode 0 = normal, 1 = winner takes all, 2 = Safe Mode
    /// @param _timestamps for market opening, locking, and oracle resolution
    /// @param _numberOfCards how many Cards in this market
    /// @param _totalNftMintCount total existing Cards across all markets excl this event's Cards
    /// @param _artistAddress where to send artist's cut, if any
    /// @param _affiliateAddress where to send affiliate's cut, if any
    /// @param _cardAffiliateAddresses where to send card specific affiliate's cut, if any
    /// @param _marketCreatorAddress where to send market creator's cut, if any
    /// @param _realitioQuestion the question posted to the Oracle
    function initialize(
        uint256 _mode,
        uint32[] memory _timestamps,
        uint256 _numberOfCards,
        uint256 _totalNftMintCount,
        address _artistAddress,
        address _affiliateAddress,
        address[] memory _cardAffiliateAddresses,
        address _marketCreatorAddress,
        string calldata _realitioQuestion
    ) external override initializer {
        assert(_mode <= 2);

        // initialise MetaTransactions
        _initializeEIP712(""RealityCardsMarket"", ""1"");

        // external contract variables:
        factory = IRCFactory(msgSender());
        treasury = factory.treasury();
        nfthub = factory.nfthub();
        orderbook = factory.orderbook();

        // get adjustable parameters from the factory/treasury
        uint256[5] memory _potDistribution = factory.getPotDistribution();
        minRentalDayDivisor = treasury.minRentalDayDivisor();
        minimumPriceIncreasePercent = factory.minimumPriceIncreasePercent();
        maxRentIterations = factory.maxRentIterations();

        // initialiiize!
        winningOutcome = MAX_UINT256; // default invalid

        // assign arguments to public variables
        mode = Mode(_mode);
        numberOfCards = _numberOfCards;
        totalNftMintCount = _totalNftMintCount;
        marketOpeningTime = _timestamps[0];
        marketLockingTime = _timestamps[1];
        oracleResolutionTime = _timestamps[2];
        artistAddress = _artistAddress;
        marketCreatorAddress = _marketCreatorAddress;
        affiliateAddress = _affiliateAddress;
        cardAffiliateAddresses = _cardAffiliateAddresses;
        artistCut = _potDistribution[0];
        winnerCut = _potDistribution[1];
        creatorCut = _potDistribution[2];
        affiliateCut = _potDistribution[3];
        cardAffiliateCut = _potDistribution[4];
        (realitio, arbitrator, timeout) = factory.getOracleSettings();

        // reduce artist cut to zero if zero adddress set
        if (_artistAddress == address(0)) {
            artistCut = 0;
        }

        // reduce affiliate cut to zero if zero adddress set
        if (_affiliateAddress == address(0)) {
            affiliateCut = 0;
        }

        // check the validity of card affiliate array.
        // if not valid, reduce payout to zero
        if (_cardAffiliateAddresses.length == _numberOfCards) {
            for (uint256 i = 0; i < _numberOfCards; i++) {
                if (_cardAffiliateAddresses[i] == address(0)) {
                    cardAffiliateCut = 0;
                }
            }
        } else {
            cardAffiliateCut = 0;
        }

        // if winner takes all mode, set winnerCut to max
        if (_mode == uint8(Mode.WINNER_TAKES_ALL)) {
            winnerCut =
                (((uint256(1000) - artistCut) - creatorCut) - affiliateCut) -
                cardAffiliateCut;
        }

        // post question to Oracle
        questionFinalised = false;
        _postQuestionToOracle(_realitioQuestion, _timestamps[2]);

        // move to OPEN immediately if market opening time in the past
        if (marketOpeningTime <= block.timestamp) {
            _incrementState();
        }

        emit LogPayoutDetails(
            _artistAddress,
            _marketCreatorAddress,
            _affiliateAddress,
            cardAffiliateAddresses,
            artistCut,
            winnerCut,
            creatorCut,
            affiliateCut,
            cardAffiliateCut
        );
        emit LogSettings(minRentalDayDivisor, minimumPriceIncreasePercent);
    }

    /*╔═════════════════════════════════╗
      ║            MODIFIERS            ║
      ╚═════════════════════════════════╝*/

    /// @notice automatically opens market if appropriate
    modifier autoUnlock() {
        if (marketOpeningTime <= block.timestamp && state == States.CLOSED) {
            _incrementState();
        }
        _;
    }

    /// @notice automatically locks market if appropriate
    modifier autoLock() {
        _;
        if (marketLockingTime <= block.timestamp) {
            lockMarket();
        }
    }

    /// @dev can only be called by Card owners
    modifier onlyTokenOwner(uint256 _token) {
        require(msgSender() == ownerOf(_token), ""Not owner"");
        _;
    }

    /*╔═════════════════════════════════╗
      ║     NFT HUB CONTRACT CALLS      ║
      ╚═════════════════════════════════╝*/

    /// @notice send NFT to mainnet
    /// @dev upgrades not possible if market not approved
    function upgradeCard(uint256 _card) external onlyTokenOwner(_card) {
        _checkState(States.WITHDRAW);
        require(
            !factory.trapIfUnapproved() ||
                factory.isMarketApproved(address(this)),
            ""Upgrade blocked""
        );
        uint256 _tokenId = _card + totalNftMintCount;
        _transferCard(ownerOf(_card), address(this), _card); // contract becomes final resting place
        nfthub.withdrawWithMetadata(_tokenId);
        emit LogNftUpgraded(_card, _tokenId);
    }

    /// @notice gets the owner of the NFT via their Card Id
    function ownerOf(uint256 _cardId) public view override returns (address) {
        uint256 _tokenId = _cardId + totalNftMintCount;
        return nfthub.ownerOf(_tokenId);
    }

    /// @notice gets tokenURI via their Card Id
    function tokenURI(uint256 _cardId)
        public
        view
        override
        returns (string memory)
    {
        uint256 _tokenId = _cardId + totalNftMintCount;
        return nfthub.tokenURI(_tokenId);
    }

    /// @notice transfer ERC 721 between users
    /// @dev called internally during contract open state
    function _transferCard(
        address _from,
        address _to,
        uint256 _cardId
    ) internal {
        require(
            _from != address(0) && _to != address(0),
            ""Cannot send to/from zero address""
        );
        uint256 _tokenId = _cardId + totalNftMintCount;

        assert(nfthub.transferNft(_from, _to, _tokenId));
        emit LogNewOwner(_cardId, _to);
    }

    /// @notice transfer ERC 721 between users
    /// @dev called externaly by Orderbook during contract open state
    function transferCard(
        address _from,
        address _to,
        uint256 _cardId,
        uint256 _price,
        uint256 _timeLimit
    ) external override {
        require(msgSender() == address(orderbook), ""Not orderbook"");
        _checkState(States.OPEN);
        if (_to != _from) {
            _transferCard(_from, _to, _cardId);
        }
        cardTimeLimit[_cardId] = _timeLimit;
        cardPrice[_cardId] = _price;
    }

    /*╔═════════════════════════════════╗
      ║        ORACLE FUNCTIONS         ║
      ╚═════════════════════════════════╝*/

    /// @dev called within initializer only
    function _postQuestionToOracle(
        string calldata _question,
        uint32 _oracleResolutionTime
    ) internal {
        questionId = realitio.askQuestion(
            2,
            _question,
            arbitrator,
            timeout,
            _oracleResolutionTime,
            0
        );
        emit LogQuestionPostedToOracle(address(this), questionId);
    }

    /// @notice has the oracle finalised
    function isFinalized() public view returns (bool) {
        bool _isFinalized = realitio.isFinalized(questionId);
        return _isFinalized;
    }

    /// @dev sets the winning outcome
    /// @dev market.setWinner() will revert if done twice, because wrong state
    function getWinnerFromOracle() external {
        require(isFinalized(), ""Oracle not finalised"");
        // check market state to prevent market closing early
        require(marketLockingTime <= block.timestamp, ""Market not finished"");
        questionFinalised = true;
        bytes32 _winningOutcome = realitio.resultFor(questionId);
        // call the market
        setWinner(uint256(_winningOutcome));
    }

    /// @dev admin override of the oracle
    function setAmicableResolution(uint256 _winningOutcome) external {
        require(msgSender() == factory.owner(), ""Not authorised"");
        questionFinalised = true;
        setWinner(_winningOutcome);
    }

    /*╔═════════════════════════════════╗
      ║  MARKET RESOLUTION FUNCTIONS    ║
      ╚═════════════════════════════════╝*/

    /// @notice checks whether the competition has ended, if so moves to LOCKED state
    /// @dev can be called by anyone
    /// @dev public because called within autoLock modifier & setWinner
    function lockMarket() public {
        _checkState(States.OPEN);
        require(
            marketLockingTime <= block.timestamp,
            ""Market has not finished""
        );
        // do a final rent collection before the contract is locked down

        if (collectRentAllCards()) {
            orderbook.closeMarket();
            _incrementState();

            for (uint256 i; i < numberOfCards; i++) {
                // bring the cards back to the market so the winners get the satisfcation of claiming them
                _transferCard(ownerOf(i), address(this), i);
                emit LogLongestOwner(i, longestOwner[i]);
            }
            emit LogContractLocked(true);
        }
    }

    /// @notice called by getWinnerFromOracle, sets the winner
    /// @param _winningOutcome the index of the winning card
    function setWinner(uint256 _winningOutcome) internal {
        if (state == States.OPEN) {
            // change the locking time to allow lockMarket to lock
            marketLockingTime = SafeCast.toUint32(block.timestamp);
            lockMarket();
        }
        if (state == States.LOCKED) {
            // get the winner. This will revert if answer is not resolved.
            winningOutcome = _winningOutcome;
            _incrementState();
            emit LogWinnerKnown(winningOutcome);
        }
    }

    /// @notice pays out winnings, or returns funds
    function withdraw() external {
        _checkState(States.WITHDRAW);
        require(!userAlreadyWithdrawn[msgSender()], ""Already withdrawn"");
        userAlreadyWithdrawn[msgSender()] = true;
        if (totalTimeHeld[winningOutcome] > 0) {
            _payoutWinnings();
        } else {
            _returnRent();
        }
    }

    /// @notice the longest owner of each NFT gets to keep it
    /// @dev LOCKED or WITHDRAW states are fine- does not need to wait for winner to be known
    /// @param _card the id of the card, the index
    function claimCard(uint256 _card) external {
        _checkNotState(States.CLOSED);
        _checkNotState(States.OPEN);
        require(!userAlreadyClaimed[_card][msgSender()], ""Already claimed"");
        userAlreadyClaimed[_card][msgSender()] = true;
        require(longestOwner[_card] == msgSender(), ""Not longest owner"");
        _transferCard(ownerOf(_card), longestOwner[_card], _card);
    }

    /// @notice pays winnings
    function _payoutWinnings() internal {
        uint256 _winningsToTransfer = 0;
        uint256 _remainingCut =
            ((((uint256(1000) - artistCut) - affiliateCut) - cardAffiliateCut) -
                winnerCut) - creatorCut;
        // calculate longest owner's extra winnings, if relevant
        if (longestOwner[winningOutcome] == msgSender() && winnerCut > 0) {
            _winningsToTransfer = (totalRentCollected * winnerCut) / (1000);
        }
        uint256 _remainingPot = 0;
        if (mode == Mode.SAFE_MODE) {
            // return all rent paid on winning card
            _remainingPot =
                ((totalRentCollected - rentCollectedPerCard[winningOutcome]) *
                    _remainingCut) /
                (1000);
            _winningsToTransfer += rentCollectedPerUserPerCard[msgSender()][
                winningOutcome
            ];
        } else {
            // calculate normal winnings, if any
            _remainingPot = (totalRentCollected * _remainingCut) / (1000);
        }
        uint256 _winnersTimeHeld = timeHeld[winningOutcome][msgSender()];
        uint256 _numerator = _remainingPot * _winnersTimeHeld;
        _winningsToTransfer =
            _winningsToTransfer +
            (_numerator / totalTimeHeld[winningOutcome]);
        require(_winningsToTransfer > 0, ""Not a winner"");
        _payout(msgSender(), _winningsToTransfer);
        emit LogWinningsPaid(msgSender(), _winningsToTransfer);
    }

    /// @notice returns all funds to users in case of invalid outcome
    function _returnRent() internal {
        // deduct artist share and card specific share if relevant but NOT market creator share or winner's share (no winner, market creator does not deserve)
        uint256 _remainingCut =
            ((uint256(1000) - artistCut) - affiliateCut) - cardAffiliateCut;
        uint256 _rentCollected = rentCollectedPerUser[msgSender()];
        require(_rentCollected > 0, ""Paid no rent"");
        uint256 _rentCollectedAdjusted =
            (_rentCollected * _remainingCut) / (1000);
        _payout(msgSender(), _rentCollectedAdjusted);
        emit LogRentReturned(msgSender(), _rentCollectedAdjusted);
    }

    /// @notice all payouts happen through here
    function _payout(address _recipient, uint256 _amount) internal {
        assert(treasury.payout(_recipient, _amount));
    }

    /// @dev the below functions pay stakeholders (artist, creator, affiliate, card specific affiliates)
    /// @dev they are not called within setWinner() because of the risk of an
    /// @dev ....  address being a contract which refuses payment, then nobody could get winnings
    /// @dev [hangover from when ether was native currency, keeping in case we return to this]

    /// @notice pay artist
    function payArtist() external {
        _checkState(States.WITHDRAW);
        require(!artistPaid, ""Artist already paid"");
        artistPaid = true;
        _processStakeholderPayment(artistCut, artistAddress);
    }

    /// @notice pay market creator
    function payMarketCreator() external {
        _checkState(States.WITHDRAW);
        require(totalTimeHeld[winningOutcome] > 0, ""No winner"");
        require(!creatorPaid, ""Creator already paid"");
        creatorPaid = true;
        _processStakeholderPayment(creatorCut, marketCreatorAddress);
    }

    /// @notice pay affiliate
    function payAffiliate() external {
        _checkState(States.WITHDRAW);
        require(!affiliatePaid, ""Affiliate already paid"");
        affiliatePaid = true;
        _processStakeholderPayment(affiliateCut, affiliateAddress);
    }

    /// @notice pay card affiliate
    /// @dev does not call _processStakeholderPayment because it works differently
    function payCardAffiliate(uint256 _card) external {
        _checkState(States.WITHDRAW);
        require(!cardAffiliatePaid[_card], ""Card affiliate already paid"");
        cardAffiliatePaid[_card] = true;
        uint256 _cardAffiliatePayment =
            (rentCollectedPerCard[_card] * cardAffiliateCut) / (1000);
        if (_cardAffiliatePayment > 0) {
            _payout(cardAffiliateAddresses[_card], _cardAffiliatePayment);
            emit LogStakeholderPaid(
                cardAffiliateAddresses[_card],
                _cardAffiliatePayment
            );
        }
    }

    function _processStakeholderPayment(uint256 _cut, address _recipient)
        internal
    {
        if (_cut > 0) {
            uint256 _payment = (totalRentCollected * _cut) / (1000);
            _payout(_recipient, _payment);
            emit LogStakeholderPaid(_recipient, _payment);
        }
    }

    /*╔═════════════════════════════════╗
      ║         CORE FUNCTIONS          ║
      ╠═════════════════════════════════╣
      ║             EXTERNAL            ║
      ╚═════════════════════════════════╝*/

    /// @dev basically functions that have _checkState(States.OPEN) on first line

    /// @notice collects rent for all cards
    /// @dev cannot be external because it is called within the lockMarket function, therefore public
    function collectRentAllCards() public override returns (bool) {
        _checkState(States.OPEN);
        bool _success = true;
        for (uint256 i = 0; i < numberOfCards; i++) {
            if (ownerOf(i) != address(this)) {
                _success = _collectRent(i);
            }
            if (!_success) {
                return false;
            }
        }
        return true;
    }

    /// @notice rent every Card at the minimum price
    /// @param _maxSumOfPrices a limit to the sum of the bids to place
    function rentAllCards(uint256 _maxSumOfPrices) external {
        // check that not being front run
        uint256 _actualSumOfPrices;
        for (uint256 i = 0; i < numberOfCards; i++) {
            _actualSumOfPrices = _actualSumOfPrices + (cardPrice[i]);
        }
        require(_actualSumOfPrices <= _maxSumOfPrices, ""Prices too high"");

        for (uint256 i = 0; i < numberOfCards; i++) {
            if (ownerOf(i) != msgSender()) {
                uint256 _newPrice;
                if (cardPrice[i] > 0) {
                    _newPrice =
                        (cardPrice[i] * (minimumPriceIncreasePercent + 100)) /
                        100;
                } else {
                    _newPrice = MIN_RENTAL_VALUE;
                }
                newRental(_newPrice, 0, address(0), i);
            }
        }
    }

    /// @notice to rent a Card
    /// @dev no event: it is emitted in _updateBid, _setNewOwner or _placeInList as appropriate
    /// @param _newPrice the price to rent the card for
    /// @param _timeHeldLimit an optional time limit to rent the card for
    /// @param _startingPosition where to start looking to insert the bid into the orderbook
    /// @param _card the index of the card to update
    function newRental(
        uint256 _newPrice,
        uint256 _timeHeldLimit,
        address _startingPosition,
        uint256 _card
    ) public autoUnlock() autoLock() {
        if (state == States.OPEN) {
            require(_newPrice >= MIN_RENTAL_VALUE, ""Price below min"");
            require(_card < numberOfCards, ""Card does not exist"");

            address _user = msgSender();

            require(
                exitedTimestamp[_user] != block.timestamp,
                ""Cannot lose and re-rent in same block""
            );
            require(
                !treasury.marketPaused(address(this)) &&
                    !treasury.globalPause(),
                ""Rentals are disabled""
            );
            bool _userStillForeclosed = treasury.isForeclosed(_user);
            if (_userStillForeclosed) {
                _userStillForeclosed = orderbook.removeUserFromOrderbook(_user);
            }
            if (!_userStillForeclosed) {
                if (ownerOf(_card) == _user) {
                    // the owner may only increase by more than X% or reduce their price
                    uint256 _requiredPrice =
                        (cardPrice[_card] *
                            (minimumPriceIncreasePercent + 100)) / (100);
                    require(
                        _newPrice >= _requiredPrice ||
                            _newPrice < cardPrice[_card],
                        ""Invalid price""
                    );
                }

                // do some cleaning up before we collect rent or check their bidRate
                orderbook.removeOldBids(_user);

                _collectRent(_card);

                // check sufficient deposit
                uint256 _userTotalBidRate =
                    treasury.userTotalBids(_user) -
                        (orderbook.getBidValue(_user, _card)) +
                        _newPrice;
                require(
                    treasury.userDeposit(_user) >=
                        _userTotalBidRate / minRentalDayDivisor,
                    ""Insufficient deposit""
                );

                _timeHeldLimit = _checkTimeHeldLimit(_timeHeldLimit);

                // replaces _newBid and _updateBid
                orderbook.addBidToOrderbook(
                    _user,
                    _card,
                    _newPrice,
                    _timeHeldLimit,
                    _startingPosition
                );

                assert(treasury.updateLastRentalTime(_user));
            }
        }
    }

    function _checkTimeHeldLimit(uint256 _timeHeldLimit)
        internal
        view
        returns (uint256)
    {
        if (_timeHeldLimit == 0) {
            return 0;
        } else {
            uint256 _minRentalTime = uint256(1 days) / minRentalDayDivisor;
            require(_timeHeldLimit >= _minRentalTime, ""Limit too low"");
            return _timeHeldLimit;
        }
    }

    /// @notice to change your timeHeldLimit without having to re-rent
    /// @param _timeHeldLimit an optional time limit to rent the card for
    /// @param _card the index of the card to update
    function updateTimeHeldLimit(uint256 _timeHeldLimit, uint256 _card)
        external
    {
        _checkState(States.OPEN);
        address _user = msgSender();

        if (_collectRent(_card)) {
            _timeHeldLimit = _checkTimeHeldLimit(_timeHeldLimit);

            orderbook.setTimeHeldlimit(_user, _card, _timeHeldLimit);

            if (ownerOf(_card) == _user) {
                cardTimeLimit[_card] = _timeHeldLimit;
            }

            emit LogUpdateTimeHeldLimit(_user, _timeHeldLimit, _card);
        }
    }

    /// @notice stop renting all cards
    function exitAll() external override {
        for (uint256 i = 0; i < numberOfCards; i++) {
            exit(i);
        }
    }

    /// @notice stop renting a card and/or remove from orderbook
    /// @dev public because called by exitAll()
    /// @dev doesn't need to be current owner so user can prevent ownership returning to them
    /// @dev does not apply minimum rental duration, because it returns ownership to the next user
    /// @param _card The card index to exit
    function exit(uint256 _card) public override {
        _checkState(States.OPEN);
        address _msgSender = msgSender();

        // block frontrunning attack
        exitedTimestamp[_msgSender] = block.timestamp;

        // collectRent first
        _collectRent(_card);

        if (ownerOf(_card) == _msgSender) {
            // if current owner, find a new one
            orderbook.findNewOwner(_card, block.timestamp);
            assert(!orderbook.bidExists(_msgSender, address(this), _card));
        } else {
            // if not owner, just delete from orderbook
            if (orderbook.bidExists(_msgSender, address(this), _card)) {
                orderbook.removeBidFromOrderbook(_msgSender, _card);
            }
        }
    }

    /// @notice ability to add liqudity to the pot without being able to win.
    /// @dev called by user, sponsor is msgSender
    function sponsor(uint256 _amount) external override {
        address _creator = msgSender();
        treasury.checkSponsorship(_creator, _amount);
        _sponsor(_creator, _amount);
    }

    /// @notice ability to add liqudity to the pot without being able to win.
    /// @dev called by Factory during market creation
    /// @param _sponsorAddress the msgSender of createMarket in the Factory
    function sponsor(address _sponsorAddress, uint256 _amount)
        external
        override
    {
        _sponsor(_sponsorAddress, _amount);
    }

    /// @dev actually processes the sponsorship
    function _sponsor(address _sponsorAddress, uint256 _amount) internal {
        _checkNotState(States.LOCKED);
        _checkNotState(States.WITHDRAW);
        require(_amount > 0, ""Must send something"");
        // send tokens to the Treasury
        require(treasury.sponsor(_sponsorAddress, _amount));
        totalRentCollected = totalRentCollected + _amount;
        // just so user can get it back if invalid outcome
        rentCollectedPerUser[_sponsorAddress] =
            rentCollectedPerUser[_sponsorAddress] +
            _amount;
        // allocate equally to each card, in case card specific affiliates
        for (uint256 i = 0; i < numberOfCards; i++) {
            rentCollectedPerCard[i] =
                rentCollectedPerCard[i] +
                (_amount / numberOfCards);
        }
        emit LogSponsor(_sponsorAddress, _amount);
    }

    /*╔═════════════════════════════════╗
      ║         CORE FUNCTIONS          ║
      ╠═════════════════════════════════╣
      ║             INTERNAL            ║
      ╚═════════════════════════════════╝*/

    /// @notice collects rent for a specific card
    /// @dev also calculates and updates how long the current user has held the card for
    /// @dev is not a problem if called externally, but making internal over public to save gas
    function _collectRentAction(uint256 _card)
        internal
        returns (bool shouldContinue)
    {
        address _user = ownerOf(_card);
        uint256 _timeOfThisCollection = block.timestamp;

        // don't collect rent beyond the locking time
        if (marketLockingTime <= block.timestamp) {
            _timeOfThisCollection = marketLockingTime;
        }

        //only collect rent if the card is owned (ie, if owned by the contract this implies unowned)
        // AND if the last collection was in the past (ie, don't do 2+ rent collections in the same block)
        if (
            _user != address(this) &&
            timeLastCollected[_card] < _timeOfThisCollection
        ) {
            // User rent collect and fetch the time the user foreclosed, 0 means they didn't foreclose yet
            uint256 _timeUserForeclosed =
                treasury.collectRentUser(_user, block.timestamp);

            // Calculate the card timeLimitTimestamp
            uint256 _cardTimeLimitTimestamp =
                timeLastCollected[_card] + cardTimeLimit[_card];

            // input bools
            bool _foreclosed = _timeUserForeclosed != 0;
            bool _limitHit =
                cardTimeLimit[_card] != 0 &&
                    _cardTimeLimitTimestamp < block.timestamp;
            bool _marketLocked = marketLockingTime <= block.timestamp;

            // outputs
            bool _newOwner;
            uint256 _refundTime; // seconds of rent to refund the user

            /* Permutations of the events: Foreclosure, Time limit and Market Locking
            ┌───────────┬─┬─┬─┬─┬─┬─┬─┬─┐
            │Case       │1│2│3│4│5│6│7│8│
            ├───────────┼─┼─┼─┼─┼─┼─┼─┼─┤
            │Foreclosure│0│0│0│0│1│1│1│1│
            │Time Limit │0│0│1│1│0│0│1│1│
            │Market Lock│0│1│0│1│0│1│0│1│
            └───────────┴─┴─┴─┴─┴─┴─┴─┴─┘
            */

            if (!_foreclosed && !_limitHit && !_marketLocked) {
                // CASE 1
                // didn't foreclose AND
                // didn't hit time limit AND
                // didn't lock market
                // THEN simple rent collect, same owner
                _timeOfThisCollection = _timeOfThisCollection;
                _newOwner = false;
                _refundTime = 0;
            } else if (!_foreclosed && !_limitHit && _marketLocked) {
                // CASE 2
                // didn't foreclose AND
                // didn't hit time limit AND
                // did lock market
                // THEN refund rent between locking and now
                _timeOfThisCollection = marketLockingTime;
                _newOwner = false;
                _refundTime = block.timestamp - marketLockingTime;
            } else if (!_foreclosed && _limitHit && !_marketLocked) {
                // CASE 3
                // didn't foreclose AND
                // did hit time limit AND
                // didn't lock market
                // THEN refund rent between time limit and now
                _timeOfThisCollection = _cardTimeLimitTimestamp;
                _newOwner = true;
                _refundTime = block.timestamp - _cardTimeLimitTimestamp;
            } else if (!_foreclosed && _limitHit && _marketLocked) {
                // CASE 4
                // didn't foreclose AND
                // did hit time limit AND
                // did lock market
                // THEN refund rent between the earliest event and now
                if (_cardTimeLimitTimestamp < marketLockingTime) {
                    // time limit hit before market locked
                    _timeOfThisCollection = _cardTimeLimitTimestamp;
                    _newOwner = true;
                    _refundTime = block.timestamp - _cardTimeLimitTimestamp;
                } else {
                    // market locked before time limit hit
                    _timeOfThisCollection = marketLockingTime;
                    _newOwner = false;
                    _refundTime = block.timestamp - marketLockingTime;
                }
            } else if (_foreclosed && !_limitHit && !_marketLocked) {
                // CASE 5
                // did foreclose AND
                // didn't hit time limit AND
                // didn't lock market
                // THEN rent OK, find new owner
                _timeOfThisCollection = _timeUserForeclosed;
                _newOwner = true;
                _refundTime = 0;
            } else if (_foreclosed && !_limitHit && _marketLocked) {
                // CASE 6
                // did foreclose AND
                // didn't hit time limit AND
                // did lock market
                // THEN if foreclosed first rent ok, otherwise refund after locking
                if (_timeUserForeclosed < marketLockingTime) {
                    // user foreclosed before market locked
                    _timeOfThisCollection = _timeUserForeclosed;
                    _newOwner = true;
                    _refundTime = 0;
                } else {
                    // market locked before user foreclosed
                    _timeOfThisCollection = marketLockingTime;
                    _newOwner = false;
                    _refundTime = block.timestamp - marketLockingTime;
                }
            } else if (_foreclosed && _limitHit && !_marketLocked) {
                // CASE 7
                // did foreclose AND
                // did hit time limit AND
                // didn't lock market
                // THEN if foreclosed first rent ok, otherwise refund after limit
                if (_timeUserForeclosed < _cardTimeLimitTimestamp) {
                    // user foreclosed before time limit
                    _timeOfThisCollection = _timeUserForeclosed;
                    _newOwner = true;
                    _refundTime = 0;
                } else {
                    // time limit hit before user foreclosed
                    _timeOfThisCollection = _cardTimeLimitTimestamp;
                    _newOwner = true;
                    _refundTime = _timeUserForeclosed - _cardTimeLimitTimestamp;
                }
            } else {
                // CASE 8
                // did foreclose AND
                // did hit time limit AND
                // did lock market
                // THEN (╯°益°)╯彡┻━┻
                if (
                    _timeUserForeclosed <= _cardTimeLimitTimestamp &&
                    _timeUserForeclosed < marketLockingTime
                ) {
                    // user foreclosed first (or at same time as time limit)
                    _timeOfThisCollection = _timeUserForeclosed;
                    _newOwner = true;
                    _refundTime = 0;
                } else if (
                    _cardTimeLimitTimestamp < _timeUserForeclosed &&
                    _cardTimeLimitTimestamp < marketLockingTime
                ) {
                    // time limit hit first
                    _timeOfThisCollection = _cardTimeLimitTimestamp;
                    _newOwner = true;
                    _refundTime = _timeUserForeclosed - _cardTimeLimitTimestamp;
                } else {
                    // market locked first
                    _timeOfThisCollection = marketLockingTime;
                    _newOwner = false;
                    _refundTime = _timeUserForeclosed - marketLockingTime;
                }
            }
            if (_refundTime != 0) {
                uint256 _refundAmount =
                    (_refundTime * cardPrice[_card]) / 1 days;
                treasury.refundUser(_user, _refundAmount);
            }
            _processRentCollection(_user, _card, _timeOfThisCollection); // where the rent collection actually happens

            if (_newOwner) {
                orderbook.findNewOwner(_card, _timeOfThisCollection);
                return true;
            }
        } else {
            // timeLastCollected is updated regardless of whether the card is owned, so that the clock starts ticking
            // ... when the first owner buys it, because this function is run before ownership changes upon calling newRental
            timeLastCollected[_card] = _timeOfThisCollection;
        }
        return false;
    }

    /// @dev _collectRentAction goes back one owner at a time, this function repeatedly calls
    /// @dev ... _collectRentAction until the backlog of next owners has been processed, or maxRentIterations hit
    function _collectRent(uint256 _card)
        internal
        returns (bool didUpdateEverything)
    {
        uint32 counter = 0;
        bool shouldContinue = true;
        while (counter < maxRentIterations && shouldContinue) {
            shouldContinue = _collectRentAction(_card);
            counter++;
        }
        return !shouldContinue;
    }

    /// @dev processes actual rent collection and updates the state
    function _processRentCollection(
        address _user,
        uint256 _card,
        uint256 _timeOfCollection
    ) internal {
        uint256 _rentOwed =
            (cardPrice[_card] *
                (_timeOfCollection - timeLastCollected[_card])) / 1 days;
        treasury.payRent(_rentOwed);
        uint256 _timeHeldToIncrement =
            (_timeOfCollection - timeLastCollected[_card]);

        // if the user has a timeLimit, adjust it as necessary
        if (cardTimeLimit[_card] != 0) {
            orderbook.reduceTimeHeldLimit(_user, _card, _timeHeldToIncrement);
            cardTimeLimit[_card] -= _timeHeldToIncrement;
        }
        timeHeld[_card][_user] += _timeHeldToIncrement;
        totalTimeHeld[_card] += _timeHeldToIncrement;
        rentCollectedPerUser[_user] += _rentOwed;
        rentCollectedPerCard[_card] += _rentOwed;
        rentCollectedPerUserPerCard[_user][_card] += _rentOwed;
        totalRentCollected += _rentOwed;
        timeLastCollected[_card] = _timeOfCollection;

        // longest owner tracking
        if (timeHeld[_card][_user] > longestTimeHeld[_card]) {
            longestTimeHeld[_card] = timeHeld[_card][_user];
            longestOwner[_card] = _user;
        }
        emit LogRentCollection(_rentOwed, timeHeld[_card][_user], _card, _user);
    }

    function _checkState(States currentState) internal view {
        require(state == currentState, ""Incorrect state"");
    }

    function _checkNotState(States currentState) internal view {
        require(state != currentState, ""Incorrect state"");
    }

    /// @dev should only be called thrice
    function _incrementState() internal {
        assert(uint256(state) < 4);
        state = States(uint256(state) + (1));
        emit LogStateChange(uint256(state));
    }

    /*╔═════════════════════════════════╗
      ║        CIRCUIT BREAKER          ║
      ╚═════════════════════════════════╝*/

    /// @dev in case Oracle never resolves for any reason
    /// @dev does not set a winner so same as invalid outcome
    /// @dev market does not need to be locked, just in case lockMarket bugs out
    function circuitBreaker() external {
        require(
            block.timestamp > (uint256(oracleResolutionTime) + (12 weeks)),
            ""Too early""
        );
        _incrementState();
        orderbook.closeMarket();
        state = States.WITHDRAW;
    }
    /*
         ▲  
        ▲ ▲ 
              */
}
"".
Ideas: "" Unchecked Low-level Calls Identified.

```
UNCHECKED LOW-LEVEL CALL
'''
The contract uses the `assert` function to check the result of the low-level call to `treasury.payout(_recipient, _amount)` in the `_payout` function. However, `assert` is not suitable for handling failures of external calls, as it will revert the entire transaction without providing a clear error message or a way to handle the failure gracefully. This can lead to loss of funds if the external contract fails to execute correctly.

Recommended Mitigation:
Replace the `assert` statement with a proper error handling mechanism. Use a `require` statement to check the return value of the low-level call, which will allow for a clearer error message and a more controlled failure. For example:
```
require(treasury.payout(_recipient, _amount), ""Payout failed"");
```
This way, if the payout fails, the transaction will revert with a specific error message, and the contract can handle the failure appropriately.
'''
```

```
UNCHECKED LOW-LEVEL CALL
'''
The contract also uses `assert` in the `_transferCard` function to check the result of the `nfthub.transferNft(_from, _to, _tokenId)` call. Similar to the previous case, using `assert` here can lead to issues if the transfer fails, as it does not provide a way to handle the failure gracefully.

Recommended Mitigation:
Change the `assert` to a `require` statement to ensure that the transfer is successful and provide a meaningful error message if it fails. For example:
```
require(nfthub.transferNft(_from, _to, _tokenId), ""NFT transfer failed"");
```
This will allow for better error handling and prevent potential loss of funds or unexpected behavior in the contract.
'''
```

```
UNCHECKED LOW-LEVEL CALL
'''
In the `_sponsor` function, the contract calls `treasury.sponsor(_sponsorAddress, _amount)` without checking the return value. If the `sponsor` function in the `treasury` contract fails, it could lead to unexpected behavior or loss of funds.

Recommended Mitigation:
Implement a `require` statement to check the return value of the `sponsor` call. For example:
```
require(treasury.sponsor(_sponsorAddress, _amount), ""Sponsorship failed"");
```
This ensures that the contract can handle the failure of the external call appropriately.
'''
```"".
As the Security Analyst, your primary objective is to perform a thorough and detailed inspection of the provided contract code, with a particular focus on identifying vulnerabilities related to Transactions Order Dependence. Transactions Order Dependence vulnerabilities can result in unintended consequences and create opportunities for malicious actors to exploit transaction sequencing.
Please conduct a thorough analysis, considering the following information:
1. Review the contract's code logic to identify any potential areas where the order of transaction execution might have an impact on the contract's behavior.

2. Examine critical functions, particularly those involving fund transfers or resource allocation, to ensure they are not susceptible to Transactions Order Dependence.

3. Investigate scenarios in which gas prices can be manipulated to change the order of transaction execution.

If you identify Transactions Order Dependence, respond with: """,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
