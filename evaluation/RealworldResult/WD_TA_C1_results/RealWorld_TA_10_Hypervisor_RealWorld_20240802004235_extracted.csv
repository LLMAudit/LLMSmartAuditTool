Integer Overflow/Underflow Identified,Reentrancy Identified,Unchecked External Calls Identified,Unchecked Low-level Calls Identified,Transactions Order Dependence Identified,Timestamp Manipulation Identified,Predictable Randomness Identified,Unsafe `tx.origin` Identified,Unsafe Suicide Identified,Gas Limit Identified,Price Manipulation Identified,Assumption of Fixed-Length Array Identified,Lack of Withdrawal Function Identified,Lack of Authorization Identified,Potential Data Inconsistency Identified,Hash Collision Identified,Uninitialized Return Variable Identified,Misdeclared Constructor Identified,Missing 'onlyOwner' Modifier Identified,Misuse of `msg.value` within a Loop Identified,Precision Loss Identified,Redundant Conditional Check Identified,External Oracle Dependency Identified,Ownership Hijacking Identified,Centralization Risk Identified,Incorrect Funding Rate Calculation Identified,Flash Loan Fee Manipulation Identified,Misuse of Mapping Getter Identified,Lack of Getter Function Implementation Identified,Unnecessary Comparison Identified,Inconsistent Initialization Identified,Potential Inconsistency in Yield Source Swapping Identified,Incorrect Signer Verification Identified,Order of Inheritance Initialization Identified,Impracticality of Exact Match Identified,Inconsistent Base Tokens Identified,Handling Partial Withdrawals Identified,Fallback Function Identified,Unlimited Token Approval Identified,Lack of Input Validation Identified,DoS Vulnerability Identified
"<INFO> Integer Overflow/Underflow Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, along with recommended mitigation measures or fixes that do not require code upgrades.
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Reentrancy Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Unchecked External Calls Identified."".
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Unchecked Low-level Calls Identified."".
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Transactions Order Dependence Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, along with recommended mitigation measures or fixes that do not require code upgrades
'''
```
If you don't find any Transactions Order Dependence vulnerabilities, respond only with: ""","<INFO> Timestamp Manipulation Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Predictable Randomness Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Unsafe `tx.origin` Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Unsafe Suicide Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If NO Lack of Restriction on `selfdestruct` is found, respond only with: ""","<INFO> Gas Limit Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Price Manipulation Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code.
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Assumption of Fixed-Length Array Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code.
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Lack of Withdrawal Function Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If a secure withdrawal function is found and no issues are identified, respond only with: ""","<INFO> Lack of Authorization Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If NO Lack of Authorization vulnerabilities are found, respond only with: ""","<INFO> Potential Data Inconsistency Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If NO Potential Data Inconsistency vulnerabilities are found, respond only with: ""","<INFO> Hash Collision Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If NO Hash Collision vulnerabilities are found, respond only with: ""","<INFO> Uninitialized Return Variable Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If NO Uninitialized Return Variable vulnerabilities are found, respond only with: ""","<INFO> Misdeclared Constructor Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If NO Misdeclared Constructor vulnerabilities are found, respond only with: ""","<INFO> Missing 'onlyOwner' Modifier Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Misuse of `msg.value` within a Loop Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Precision Loss Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Redundant Conditional Check Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> External Oracle Dependency Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: """,,"<INFO> Centralization Risk Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Incorrect Funding Rate Calculation Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Flash Loan Fee Manipulation Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Misuse of Mapping Getter Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Lack of Getter Function Implementation Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Unnecessary Comparison Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Inconsistent Initialization Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Potential Inconsistency in Yield Source Swapping Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Incorrect Signer Verification Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Order of Inheritance Initialization Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Impracticality of Exact Match Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Inconsistent Base Tokens Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Handling Partial Withdrawals Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Fallback Function Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Unlimited Token Approval Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> Lack of Input Validation Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code
'''
```
If you don't find any vulnerabilities, respond only with: ""","<INFO> DoS Vulnerability Identified.""
For each vulnerability identified, use the following format:
```
VULNERABILITY NAME or TYPE
'''
DETAILED DESCRIPTION of the vulnerability, along with recommended mitigation measures or fixes that do not require code upgrades.
'''
```
If you don't find any vulnerabilities, respond only with: """
,,,,,,,,,"<INFO> Gas Limit Identified.

**Lack of Gas Limit Considerations**
'''
The `calculateTotalStakeUnits` function iterates over the `stakes` array, which can potentially grow large if many stakes are made. If a user attempts to call this function with a vault that has a large number of stakes, it could lead to an out-of-gas error. This is particularly concerning in the `rageQuit` function, which calls `_updateTotalStakeUnits`, which in turn calls `calculateTotalStakeUnits`. If the stakes array is large, it could cause the transaction to fail due to exceeding the gas limit.

To mitigate this issue, consider implementing a maximum limit on the number of stakes that can be processed in a single transaction. Additionally, you could implement a mechanism to paginate through the stakes or allow users to withdraw stakes in smaller batches to avoid hitting gas limits.
'''

**Potential Denial-of-Service (DoS

[2024-02-08 00:43:45 INFO] **[Seminar Conclusion]**:

 ",,"<INFO> Assumption of Fixed-Length Array Identified.

```
VULNERABILITY NAME: Assumption of Fixed-Length Array in calculateTotalStakeUnits
'''
DETAILED DESCRIPTION: The function `calculateTotalStakeUnits` assumes that the length of the `stakes` array is fixed and iterates through it using a for loop. If the length of the `stakes` array is modified externally or if the array is empty, this could lead to out-of-bounds errors or incorrect calculations. The function does not check the length of the array before accessing its elements, which can lead to unintended behavior or data corruption.

RECOMMENDED MITIGATION/FIX: Implement a check at the beginning of the function to ensure that the `stakes` array is not empty before proceeding with the calculations. Additionally, consider using a `while` loop that checks the current length dynamically to avoid assumptions about the array's length.
'''

VULNERABILITY NAME: Assumption of Fixed-Length Array in unstakeAndClaim
'''
DETAILED DESCRIPTION: In the `unstake

[2024-02-08 00:43:57 INFO] **[Seminar Conclusion]**:

 ",,"<INFO> Lack of Authorization Identified.

```
LACK OF AUTHORIZATION
'''
The `rageQuit()` function allows any user to exit the Hypervisor without claiming rewards. This function is callable by any address that has a registered vault, as it does not have any access control modifiers restricting its invocation. This could potentially allow malicious actors to exploit this function to withdraw stakes without proper authorization, especially if they manage to create a vault.

Recommended Mitigation:
Implement an access control modifier to restrict the `rageQuit()` function to only allow calls from the owner of the vault. This can be done by checking if `msg.sender` is the owner of the vault before allowing the function to execute.
'''
```

```
LACK OF AUTHORIZATION
'''
The `unstakeAndClaim

[2024-02-08 00:44:09 INFO] **[Seminar Conclusion]**:

 ",,,,,,,,"<INFO> Redundant Conditional Check Identified.
```
REDUNDANT CONDITIONAL CHECK
'''
In the `isValidAddress` function, the check for `target != address(this)` is redundant because the function is already designed to validate addresses that are not the contract itself. Additionally, the check for `target != address(0)` is also redundant as it is

[2024-02-08 00:44:51 INFO] **[Seminar Conclusion]**:

 ",,,"<INFO> Centralization Risk Identified.

**Ownership Hijacking**
'''
The contract uses the Ownable pattern, which centralizes control in a single address (the owner). If the owner's private key is compromised, an attacker could gain full control over the contract, allowing them to execute any function that requires ownership, such as `fund`, `registerVaultFactory`, `removeVaultFactory`, and `rescueTokensFromRewardPool`. This poses a significant risk to the integrity of the contract and the funds within it.

**Recommended Mitigation/Fix:**
Implement a multi-signature wallet for critical functions that require ownership. This would distribute control among multiple trusted parties, reducing the risk of a single point of failure. Additionally, consider implementing a time-lock mechanism for sensitive operations to provide a buffer period during which stakeholders can react to potentially malicious actions.
'''

[2024-02-08 00:45:09 INFO] **[Seminar Conclusion]**:

 ",,,,,,,,,"<INFO> Order of Inheritance Initialization Identified.
```
ORDER OF INHERITANCE INITIALIZATION
'''
The contract `Hypervisor` inherits from two contracts: `Powered` and `Ownable`. In Solidity, the order of constructor execution is determined by the linearized order of inheritance, which may not match the order specified in the derived contract's constructor. This can lead to unexpected behavior if the constructors of the inherited contracts rely on state variables that are initialized in the derived contract's constructor.

In this case, if `Powered` and `Ownable` have their own state variables that are expected to be initialized before the derived contract's constructor logic executes, it could lead to incorrect initialization of those variables. 

To mitigate this issue, ensure that any state variables in the base contracts are initialized properly before they are used in the derived contract. This can be achieved by explicitly calling the constructors of the base contracts in the derived contract's constructor in the

[2024-02-08 00:46:08 INFO] **[Seminar Conclusion]**:

 ",,,,,,"<INFO> Lack of Input Validation Identified.

```
LACK OF INPUT VALIDATION IN STAKE FUNCTION
'''
In the `stake` function, there is a check for a non-zero amount, but there is no validation to ensure that the `vault` address is not a zero address before proceeding with the staking process. This could lead to unexpected behavior if a user attempts to stake to a zero address vault, potentially causing loss of funds or other unintended consequences.

Recommended Mitigation:
Add a validation check at the beginning of the `stake` function to ensure that the `vault` address is not the zero address:
require(vault != address(0), ""Hypervisor: vault address cannot be zero"");
'''

LACK OF INPUT VALIDATION IN UNSTAKEANDCLAIM FUNCTION
'''
In the `unstakeAndClaim` function, while there are checks for non-zero amounts

[2024-02-08 00:46:37 INFO] **[Seminar Conclusion]**:

 ",
,,,,,,,,,"<INFO> Gas Limit Identified.

**Lack of Gas Limit Considerations**
'''
The `calculateTotalStakeUnits` function iterates over the `stakes` array, which can potentially grow large if many stakes are made. If a user attempts to call this function with a vault that has a large number of stakes, it could lead to an out-of-gas error. This is particularly concerning in the `rageQuit` function, which calls `_updateTotalStakeUnits`, which in turn calls `calculateTotalStakeUnits`. If the stakes array is large, it could cause the transaction to fail due to exceeding the gas limit.

To mitigate this issue, consider implementing a maximum limit on the number of stakes that can be processed in a single transaction. Additionally, you could implement a mechanism to paginate through the stakes or allow users to withdraw stakes in smaller batches to avoid hitting gas limits.
'''

**Potential Denial-of-Service (DoS

[2024-02-08 00:43:45 INFO] **[Execute Detail]**

execute SimplePhase:[PriceManipulationDetector] in ComposedPhase:[CodeReview], cycle 1

[2024-02-08 00:43:45 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: GPL-3.0-only pragma solidity 0.7.6; pragma abicoder v2; import {SafeMath} from ""@openzeppelin/contracts/math/SafeMath.sol""; import {EnumerableSet} from ""@openzeppelin/contracts/utils/EnumerableSet.sol""; import {IERC20} from ""@openzeppelin/contracts/token/ERC20/IERC20.sol""; import {Ownable} from ""@openzeppelin/contracts/access/Ownable.sol""; import {TransferHelper} from ""@uniswap/lib/contracts/libraries/TransferHelper.sol""; import {IFactory} from ""../factory/IFactory.sol""; import {IInstanceRegistry} from ""../factory/InstanceRegistry.sol""; import {IUniversalVault} from ""../visor/Visor.sol""; import {IRewardPool} from ""./RewardPool.sol""; import {Powered} from ""./Powered.sol""; interface IRageQuit {     function rageQuit() external; } interface IHypervisor is IRageQuit {     / admin events / event HypervisorCreated(address rewardPool, address powerSwitch); event HypervisorFunded(uint256 amount, uint256 duration); event BonusTokenRegistered(address token); event VaultFactoryRegistered(address factory); event VaultFactoryRemoved(address factory);  /* user events */  event Staked(address vault, uint256 amount); event Unstaked(address vault, uint256 amount); event RewardClaimed(address vault, address recipient, address token, uint256 amount);  /* data types */  struct HypervisorData {     address stakingToken;     address rewardToken;     address rewardPool;     RewardScaling rewardScaling;     uint256 rewardSharesOutstanding;     uint256 totalStake;     uint256 totalStakeUnits;     uint256 lastUpdate;     RewardSchedule[] rewardSchedules; }  struct RewardSchedule {     uint256 duration;     uint256 start;     uint256 shares; }  struct VaultData {     uint256 totalStake;     StakeData[] stakes; }  struct StakeData {     uint256 amount;     uint256 timestamp; }  struct RewardScaling {     uint256 floor;     uint256 ceiling;     uint256 time; }  struct RewardOutput {     uint256 lastStakeAmount;     uint256 newStakesCount;     uint256 reward;     uint256 newTotalStakeUnits; }  /* user functions */  function stake(     address vault,     uint256 amount,     bytes calldata permission ) external;  function unstakeAndClaim(     address vault,     uint256 amount,     bytes calldata permission ) external;  /* getter functions */  function getHypervisorData() external view returns (HypervisorData memory hypervisor);  function getBonusTokenSetLength() external view returns (uint256 length);  function getBonusTokenAtIndex(uint256 index) external view returns (address bonusToken);  function getVaultFactorySetLength() external view returns (uint256 length);  function getVaultFactoryAtIndex(uint256 index) external view returns (address factory);  function getVaultData(address vault) external view returns (VaultData memory vaultData);  function isValidAddress(address target) external view returns (bool validity);  function isValidVault(address target) external view returns (bool validity);  function getCurrentUnlockedRewards() external view returns (uint256 unlockedRewards);  function getFutureUnlockedRewards(uint256 timestamp)     external     view     returns (uint256 unlockedRewards);  function getCurrentVaultReward(address vault) external view returns (uint256 reward);  function getCurrentStakeReward(address vault, uint256 stakeAmount)     external     view     returns (uint256 reward);  function getFutureVaultReward(address vault, uint256 timestamp)     external     view     returns (uint256 reward);  function getFutureStakeReward(     address vault,     uint256 stakeAmount,     uint256 timestamp ) external view returns (uint256 reward);  function getCurrentVaultStakeUnits(address vault) external view returns (uint256 stakeUnits);  function getFutureVaultStakeUnits(address vault, uint256 timestamp)     external     view     returns (uint256 stakeUnits);  function getCurrentTotalStakeUnits() external view returns (uint256 totalStakeUnits);  function getFutureTotalStakeUnits(uint256 timestamp)     external     view     returns (uint256 totalStakeUnits);  /* pure functions */  function calculateTotalStakeUnits(StakeData[] memory stakes, uint256 timestamp)     external     pure     returns (uint256 totalStakeUnits);  function calculateStakeUnits(     uint256 amount,     uint256 start,     uint256 end ) external pure returns (uint256 stakeUnits);  function calculateUnlockedRewards(     RewardSchedule[] memory rewardSchedules,     uint256 rewardBalance,     uint256 sharesOutstanding,     uint256 timestamp ) external pure returns (uint256 unlockedRewards);  function calculateRewardFromStakes(     StakeData[] memory stakes,     uint256 unstakeAmount,     uint256 unlockedRewards,     uint256 totalStakeUnits,     uint256 timestamp,     RewardScaling memory rewardScaling ) external pure returns (RewardOutput memory out);  function calculateReward(     uint256 unlockedRewards,     uint256 stakeAmount,     uint256 stakeDuration,     uint256 totalStakeUnits,     RewardScaling memory rewardScaling ) external pure returns (uint256 reward);  } /// @title Hypervisor /// @notice Reward distribution contract with time multiplier /// Access Control /// - Power controller: ///     Can power off / shutdown the Hypervisor ///     Can withdraw rewards from reward pool once shutdown /// - Proxy owner: ///     Can change arbitrary logic / state by upgrading the Hypervisor ///     Is unable to operate on user funds due to UniversalVault ///     Is unable to operate on reward pool funds when reward pool is offline / shutdown /// - Hypervisor admin: ///     Can add funds to the Hypervisor, register bonus tokens, and whitelist new vault factories ///     Is a subset of proxy owner permissions /// - User: ///     Can deposit / withdraw / ragequit /// Hypervisor State Machine /// - Online: ///     Hypervisor is operating normally, all functions are enabled /// - Offline: ///     Hypervisor is temporarely disabled for maintenance ///     User deposits and withdrawls are disabled, ragequit remains enabled ///     Users can withdraw their stake through rageQuit() but forego their pending reward ///     Should only be used when downtime required for an upgrade /// - Shutdown: ///     Hypervisor is permanently disabled ///     All functions are disabled with the exception of ragequit ///     Users can withdraw their stake through rageQuit() ///     Power controller can withdraw from the reward pool ///     Should only be used if Proxy Owner role is compromized contract Hypervisor is IHypervisor, Powered, Ownable {     using SafeMath for uint256;     using EnumerableSet for EnumerableSet.AddressSet; /* constants */  // An upper bound on the number of active stakes per vault is required to prevent // calls to rageQuit() from reverting. // With 30 stakes in a vault, ragequit costs 432811 gas which is conservatively lower // than the hardcoded limit of 500k gas on the vault. // This limit is configurable and could be increased in a future deployment. // Ultimately, to avoid a need for fixed upper bounds, the EVM would need to provide // an error code that allows for reliably catching out-of-gas errors on remote calls. uint256 public constant MAX_STAKES_PER_VAULT = 30; uint256 public constant MAX_REWARD_TOKENS = 50; uint256 public constant BASE_SHARES_PER_WEI = 1000000; uint256 public stakeLimit = 2500 ether;  /* storage */  HypervisorData private _hypervisor; mapping(address =&gt; VaultData) private _vaults; EnumerableSet.AddressSet private _bonusTokenSet; EnumerableSet.AddressSet private _vaultFactorySet;  /* initializer */  /// @notice Initizalize Hypervisor /// access control: only proxy constructor /// state machine: can only be called once /// state scope: set initialization variables /// token transfer: none /// @param ownerAddress address The admin address /// @param rewardPoolFactory address The factory to use for deploying the RewardPool /// @param powerSwitchFactory address The factory to use for deploying the PowerSwitch /// @param stakingToken address The address of the staking token for this Hypervisor /// @param rewardToken address The address of the reward token for this Hypervisor /// @param rewardScaling RewardScaling The config for reward scaling floor, ceiling, and time constructor(     address ownerAddress,     address rewardPoolFactory,     address powerSwitchFactory,     address stakingToken,     address rewardToken,     RewardScaling memory rewardScaling,     uint256 _stakeLimit ) {     // the scaling floor must be smaller than ceiling     require(rewardScaling.floor &lt;= rewardScaling.ceiling, ""Hypervisor: floor above ceiling"");      // setting rewardScalingTime to 0 would cause divide by zero error     // to disable reward scaling, use rewardScalingFloor == rewardScalingCeiling     require(rewardScaling.time != 0, ""Hypervisor: scaling time cannot be zero"");      // deploy power switch     address powerSwitch = IFactory(powerSwitchFactory).create(abi.encode(ownerAddress));      // deploy reward pool     address rewardPool = IFactory(rewardPoolFactory).create(abi.encode(powerSwitch));      // set internal configs     Ownable.transferOwnership(ownerAddress);     Powered._setPowerSwitch(powerSwitch);      // commit to storage     _hypervisor.stakingToken = stakingToken;     _hypervisor.rewardToken = rewardToken;     _hypervisor.rewardPool = rewardPool;     _hypervisor.rewardScaling = rewardScaling;      stakeLimit = _stakeLimit;      // emit event     emit HypervisorCreated(rewardPool, powerSwitch); }  /* getter functions */  function getBonusTokenSetLength() external view override returns (uint256 length) {     return _bonusTokenSet.length(); }  function getBonusTokenAtIndex(uint256 index)     external     view     override     returns (address bonusToken) {     return _bonusTokenSet.at(index); }  function getVaultFactorySetLength() external view override returns (uint256 length) {     return _vaultFactorySet.length(); }  function getVaultFactoryAtIndex(uint256 index)     external     view     override     returns (address factory) {     return _vaultFactorySet.at(index); }  function isValidVault(address target) public view override returns (bool validity) {     // validate target is created from whitelisted vault factory     for (uint256 index = 0; index &lt; _vaultFactorySet.length(); index++) {         if (IInstanceRegistry(_vaultFactorySet.at(index)).isInstance(target)) {             return true;         }     }     // explicit return     return false; }  function isValidAddress(address target) public view override returns (bool validity) {     // sanity check target for potential input errors     return         target != address(this) &amp;&amp;         target != address(0) &amp;&amp;         target != _hypervisor.stakingToken &amp;&amp;         target != _hypervisor.rewardToken &amp;&amp;         target != _hypervisor.rewardPool &amp;&amp;         !_bonusTokenSet.contains(target); }  /* Hypervisor getters */  function getHypervisorData() external view override returns (HypervisorData memory hypervisor) {     return _hypervisor; }  function getCurrentUnlockedRewards() public view override returns (uint256 unlockedRewards) {     // calculate reward available based on state     return getFutureUnlockedRewards(block.timestamp); }  function getFutureUnlockedRewards(uint256 timestamp)     public     view     override     returns (uint256 unlockedRewards) {     // get reward amount remaining     uint256 remainingRewards = IERC20(_hypervisor.rewardToken).balanceOf(_hypervisor.rewardPool);     // calculate reward available based on state     unlockedRewards = calculateUnlockedRewards(         _hypervisor.rewardSchedules,         remainingRewards,         _hypervisor.rewardSharesOutstanding,         timestamp     );     // explicit return     return unlockedRewards; }  function getCurrentTotalStakeUnits() public view override returns (uint256 totalStakeUnits) {     // calculate new stake units     return getFutureTotalStakeUnits(block.timestamp); }  function getFutureTotalStakeUnits(uint256 timestamp)     public     view     override     returns (uint256 totalStakeUnits) {     // return early if no change     if (timestamp == _hypervisor.lastUpdate) return _hypervisor.totalStakeUnits;     // calculate new stake units     uint256 newStakeUnits =         calculateStakeUnits(_hypervisor.totalStake, _hypervisor.lastUpdate, timestamp);     // add to cached total     totalStakeUnits = _hypervisor.totalStakeUnits.add(newStakeUnits);     // explicit return     return totalStakeUnits; }  /* vault getters */  function getVaultData(address vault)     external     view     override     returns (VaultData memory vaultData) {     return _vaults[vault]; }  function getCurrentVaultReward(address vault) external view override returns (uint256 reward) {     // calculate rewards     return         calculateRewardFromStakes(             _vaults[vault]                 .stakes,             _vaults[vault]                 .totalStake,             getCurrentUnlockedRewards(),             getCurrentTotalStakeUnits(),             block                 .timestamp,             _hypervisor                 .rewardScaling         )             .reward; }  function getFutureVaultReward(address vault, uint256 timestamp)     external     view     override     returns (uint256 reward) {     // calculate rewards     return         calculateRewardFromStakes(             _vaults[vault]                 .stakes,             _vaults[vault]                 .totalStake,             getFutureUnlockedRewards(timestamp),             getFutureTotalStakeUnits(timestamp),             timestamp,             _hypervisor                 .rewardScaling         )             .reward; }  function getCurrentStakeReward(address vault, uint256 stakeAmount)     external     view     override     returns (uint256 reward) {     // calculate rewards     return         calculateRewardFromStakes(             _vaults[vault]                 .stakes,             stakeAmount,             getCurrentUnlockedRewards(),             getCurrentTotalStakeUnits(),             block                 .timestamp,             _hypervisor                 .rewardScaling         )             .reward; }  function getFutureStakeReward(     address vault,     uint256 stakeAmount,     uint256 timestamp ) external view override returns (uint256 reward) {     // calculate rewards     return         calculateRewardFromStakes(             _vaults[vault]                 .stakes,             stakeAmount,             getFutureUnlockedRewards(timestamp),             getFutureTotalStakeUnits(timestamp),             timestamp,             _hypervisor                 .rewardScaling         )             .reward; }  function getCurrentVaultStakeUnits(address vault)     public     view     override     returns (uint256 stakeUnits) {     // calculate stake units     return getFutureVaultStakeUnits(vault, block.timestamp); }  function getFutureVaultStakeUnits(address vault, uint256 timestamp)     public     view     override     returns (uint256 stakeUnits) {     // calculate stake units     return calculateTotalStakeUnits(_vaults[vault].stakes, timestamp); }  /* pure functions */  function calculateTotalStakeUnits(StakeData[] memory stakes, uint256 timestamp)     public     pure     override     returns (uint256 totalStakeUnits) {     for (uint256 index; index &lt; stakes.length; index++) {         // reference stake         StakeData memory stakeData = stakes[index];         // calculate stake units         uint256 stakeUnits =             calculateStakeUnits(stakeData.amount, stakeData.timestamp, timestamp);         // add to running total         totalStakeUnits = totalStakeUnits.add(stakeUnits);     } }  function calculateStakeUnits(     uint256 amount,     uint256 start,     uint256 end ) public pure override returns (uint256 stakeUnits) {     // calculate duration     uint256 duration = end.sub(start);     // calculate stake units     stakeUnits = duration.mul(amount);     // explicit return     return stakeUnits; }  function calculateUnlockedRewards(     RewardSchedule[] memory rewardSchedules,     uint256 rewardBalance,     uint256 sharesOutstanding,     uint256 timestamp ) public pure override returns (uint256 unlockedRewards) {     // return 0 if no registered schedules     if (rewardSchedules.length == 0) {         return 0;     }      // calculate reward shares locked across all reward schedules     uint256 sharesLocked;     for (uint256 index = 0; index &lt; rewardSchedules.length; index++) {         // fetch reward schedule storage reference         RewardSchedule memory schedule = rewardSchedules[index];          // caculate amount of shares available on this schedule         // if (now - start) &lt; duration         //   sharesLocked = shares - (shares * (now - start) / duration)         // else         //   sharesLocked = 0         uint256 currentSharesLocked = 0;         if (timestamp.sub(schedule.start) &lt; schedule.duration) {             currentSharesLocked = schedule.shares.sub(                 schedule.shares.mul(timestamp.sub(schedule.start)).div(schedule.duration)             );         }          // add to running total         sharesLocked = sharesLocked.add(currentSharesLocked);     }      // convert shares to reward     // rewardLocked = sharesLocked * rewardBalance / sharesOutstanding     uint256 rewardLocked = sharesLocked.mul(rewardBalance).div(sharesOutstanding);      // calculate amount available     // unlockedRewards = rewardBalance - rewardLocked     unlockedRewards = rewardBalance.sub(rewardLocked);      // explicit return     return unlockedRewards; }  function calculateRewardFromStakes(     StakeData[] memory stakes,     uint256 unstakeAmount,     uint256 unlockedRewards,     uint256 totalStakeUnits,     uint256 timestamp,     RewardScaling memory rewardScaling ) public pure override returns (RewardOutput memory out) {     uint256 stakesToDrop = 0;     while (unstakeAmount &gt; 0) {         // fetch vault stake storage reference         StakeData memory lastStake = stakes[stakes.length.sub(stakesToDrop).sub(1)];          // calculate stake duration         uint256 stakeDuration = timestamp.sub(lastStake.timestamp);          uint256 currentAmount;         if (lastStake.amount &gt; unstakeAmount) {             // set current amount to remaining unstake amount             currentAmount = unstakeAmount;             // amount of last stake is reduced             out.lastStakeAmount = lastStake.amount.sub(unstakeAmount);         } else {             // set current amount to amount of last stake             currentAmount = lastStake.amount;             // add to stakes to drop             stakesToDrop += 1;         }          // update remaining unstakeAmount         unstakeAmount = unstakeAmount.sub(currentAmount);          // calculate reward amount         uint256 currentReward =             calculateReward(                 unlockedRewards,                 currentAmount,                 stakeDuration,                 totalStakeUnits,                 rewardScaling             );          // update cumulative reward         out.reward = out.reward.add(currentReward);          // update cached unlockedRewards         unlockedRewards = unlockedRewards.sub(currentReward);          // calculate time weighted stake         uint256 stakeUnits = currentAmount.mul(stakeDuration);          // update cached totalStakeUnits         totalStakeUnits = totalStakeUnits.sub(stakeUnits);     }      // explicit return     return         RewardOutput(             out.lastStakeAmount,             stakes.length.sub(stakesToDrop),             out.reward,             totalStakeUnits         ); }  function calculateReward(     uint256 unlockedRewards,     uint256 stakeAmount,     uint256 stakeDuration,     uint256 totalStakeUnits,     RewardScaling memory rewardScaling ) public pure override returns (uint256 reward) {     // calculate time weighted stake     uint256 stakeUnits = stakeAmount.mul(stakeDuration);      // calculate base reward     // baseReward = unlockedRewards * stakeUnits / totalStakeUnits     uint256 baseReward = 0;     if (totalStakeUnits != 0) {         // scale reward according to proportional weight         baseReward = unlockedRewards.mul(stakeUnits).div(totalStakeUnits);     }      // calculate scaled reward     // if no scaling or scaling period completed     //   reward = baseReward     // else     //   minReward = baseReward * scalingFloor / scalingCeiling     //   bonusReward = baseReward     //                 * (scalingCeiling - scalingFloor) / scalingCeiling     //                 * duration / scalingTime     //   reward = minReward + bonusReward     if (stakeDuration &gt;= rewardScaling.time || rewardScaling.floor == rewardScaling.ceiling) {         // no reward scaling applied         reward = baseReward;     } else {         // calculate minimum reward using scaling floor         uint256 minReward = baseReward.mul(rewardScaling.floor).div(rewardScaling.ceiling);          // calculate bonus reward with vested portion of scaling factor         uint256 bonusReward =             baseReward                 .mul(stakeDuration)                 .mul(rewardScaling.ceiling.sub(rewardScaling.floor))                 .div(rewardScaling.ceiling)                 .div(rewardScaling.time);          // add minimum reward and bonus reward         reward = minReward.add(bonusReward);     }      // explicit return     return reward; }  /* admin functions */  /// @notice Add funds to the Hypervisor /// access control: only admin /// state machine: ///   - can be called multiple times ///   - only online /// state scope: ///   - increase _hypervisor.rewardSharesOutstanding ///   - append to _hypervisor.rewardSchedules /// token transfer: transfer staking tokens from msg.sender to reward pool /// @param amount uint256 Amount of reward tokens to deposit /// @param duration uint256 Duration over which to linearly unlock rewards function fund(uint256 amount, uint256 duration) external onlyOwner onlyOnline {     // validate duration     require(duration != 0, ""Hypervisor: invalid duration"");      // create new reward shares     // if existing rewards on this Hypervisor     //   mint new shares proportional to % change in rewards remaining     //   newShares = remainingShares * newReward / remainingRewards     // else     //   mint new shares with BASE_SHARES_PER_WEI initial conversion rate     //   store as fixed point number with same  of decimals as reward token     uint256 newRewardShares;     if (_hypervisor.rewardSharesOutstanding &gt; 0) {         uint256 remainingRewards = IERC20(_hypervisor.rewardToken).balanceOf(_hypervisor.rewardPool);         newRewardShares = _hypervisor.rewardSharesOutstanding.mul(amount).div(remainingRewards);     } else {         newRewardShares = amount.mul(BASE_SHARES_PER_WEI);     }      // add reward shares to total     _hypervisor.rewardSharesOutstanding = _hypervisor.rewardSharesOutstanding.add(newRewardShares);      // store new reward schedule     _hypervisor.rewardSchedules.push(RewardSchedule(duration, block.timestamp, newRewardShares));      // transfer reward tokens to reward pool     TransferHelper.safeTransferFrom(         _hypervisor.rewardToken,         msg.sender,         _hypervisor.rewardPool,         amount     );      // emit event     emit HypervisorFunded(amount, duration); }  /// @notice Add vault factory to whitelist /// @dev use this function to enable stakes to vaults coming from the specified ///      factory contract /// access control: only admin /// state machine: ///   - can be called multiple times ///   - not shutdown /// state scope: ///   - append to _vaultFactorySet /// token transfer: none /// @param factory address The address of the vault factory function registerVaultFactory(address factory) external onlyOwner notShutdown {     // add factory to set     require(_vaultFactorySet.add(factory), ""Hypervisor: vault factory already registered"");      // emit event     emit VaultFactoryRegistered(factory); }  /// @notice Remove vault factory from whitelist /// @dev use this function to disable new stakes to vaults coming from the specified ///      factory contract. ///      note: vaults with existing stakes from this factory are sill able to unstake /// access control: only admin /// state machine: ///   - can be called multiple times ///   - not shutdown /// state scope: ///   - remove from _vaultFactorySet /// token transfer: none /// @param factory address The address of the vault factory function removeVaultFactory(address factory) external onlyOwner notShutdown {     // remove factory from set     require(_vaultFactorySet.remove(factory), ""Hypervisor: vault factory not registered"");      // emit event     emit VaultFactoryRemoved(factory); }  /// @notice Register bonus token for distribution /// @dev use this function to enable distribution of any ERC20 held by the RewardPool contract /// access control: only admin /// state machine: ///   - can be called multiple times ///   - only online /// state scope: ///   - append to _bonusTokenSet /// token transfer: none /// @param bonusToken address The address of the bonus token function registerBonusToken(address bonusToken) external onlyOwner onlyOnline {     // verify valid bonus token     _validateAddress(bonusToken);      // verify bonus token count     require(_bonusTokenSet.length() &lt; MAX_REWARD_TOKENS, ""Hypervisor: max bonus tokens reached "");      // add token to set     assert(_bonusTokenSet.add(bonusToken));      // emit event     emit BonusTokenRegistered(bonusToken); }  /// @notice Rescue tokens from RewardPool /// @dev use this function to rescue tokens from RewardPool contract ///      without distributing to stakers or triggering emergency shutdown /// access control: only admin /// state machine: ///   - can be called multiple times ///   - only online /// state scope: none /// token transfer: transfer requested token from RewardPool to recipient /// @param token address The address of the token to rescue /// @param recipient address The address of the recipient /// @param amount uint256 The amount of tokens to rescue function rescueTokensFromRewardPool(     address token,     address recipient,     uint256 amount ) external onlyOwner onlyOnline {     // verify recipient     _validateAddress(recipient);      // check not attempting to unstake reward token     require(token != _hypervisor.rewardToken, ""Hypervisor: invalid address"");      // check not attempting to wthdraw bonus token     require(!_bonusTokenSet.contains(token), ""Hypervisor: invalid address"");      // transfer tokens to recipient     IRewardPool(_hypervisor.rewardPool).sendERC20(token, recipient, amount); }  /* user functions */  /// @notice Stake tokens /// @dev anyone can stake to any vault if they have valid permission /// access control: anyone /// state machine: ///   - can be called multiple times ///   - only online ///   - when vault exists on this Hypervisor /// state scope: ///   - append to _vaults[vault].stakes ///   - increase _vaults[vault].totalStake ///   - increase _hypervisor.totalStake ///   - increase _hypervisor.totalStakeUnits ///   - increase _hypervisor.lastUpdate /// token transfer: transfer staking tokens from msg.sender to vault /// @param vault address The address of the vault to stake from /// @param amount uint256 The amount of staking tokens to stake function stake(     address vault,     uint256 amount,     bytes calldata permission ) external override onlyOnline {     // verify vault is valid     require(isValidVault(vault), ""Hypervisor: vault is not registered"");      // verify non-zero amount     require(amount != 0, ""Hypervisor: no amount staked"");      // fetch vault storage reference     VaultData storage vaultData = _vaults[vault];      // verify stakes boundary not reached     require(         vaultData.stakes.length &lt; MAX_STAKES_PER_VAULT,         ""Hypervisor: MAX_STAKES_PER_VAULT reached""     );      // update cached sum of stake units across all vaults     _updateTotalStakeUnits();      // store amount and timestamp     vaultData.stakes.push(StakeData(amount, block.timestamp));      // update cached total vault and Hypervisor amounts     vaultData.totalStake = vaultData.totalStake.add(amount);     // verify stake quantity without bounds     require(         stakeLimit == 0 || vaultData.totalStake &lt;= stakeLimit,         ""Hypervisor: Stake limit exceeded""     );     _hypervisor.totalStake = _hypervisor.totalStake.add(amount);      // call lock on vault     IUniversalVault(vault).lock(_hypervisor.stakingToken, amount, permission);      // emit event     emit Staked(vault, amount); }  /// @notice Unstake staking tokens and claim reward /// @dev rewards can only be claimed when unstaking /// access control: only owner of vault /// state machine: ///   - when vault exists on this Hypervisor ///   - after stake from vault ///   - can be called multiple times while sufficient stake remains ///   - only online /// state scope: ///   - decrease _hypervisor.rewardSharesOutstanding ///   - decrease _hypervisor.totalStake ///   - increase _hypervisor.lastUpdate ///   - modify _hypervisor.totalStakeUnits ///   - modify _vaults[vault].stakes ///   - decrease _vaults[vault].totalStake /// token transfer: ///   - transfer reward tokens from reward pool to recipient ///   - transfer bonus tokens from reward pool to recipient /// @param vault address The vault to unstake from /// @param amount uint256 The amount of staking tokens to unstake function unstakeAndClaim(     address vault,     uint256 amount,     bytes calldata permission ) external override onlyOnline {     // fetch vault storage reference     VaultData storage vaultData = _vaults[vault];      // verify non-zero amount     require(amount != 0, ""Hypervisor: no amount unstaked"");      address recipient = IUniversalVault(vault).owner();      // validate recipient     _validateAddress(recipient);      // check for sufficient vault stake amount     require(vaultData.totalStake &gt;= amount, ""Hypervisor: insufficient vault stake"");      // check for sufficient Hypervisor stake amount     // if this check fails, there is a bug in stake accounting     assert(_hypervisor.totalStake &gt;= amount);      // update cached sum of stake units across all vaults     _updateTotalStakeUnits();      // get reward amount remaining     uint256 remainingRewards = IERC20(_hypervisor.rewardToken).balanceOf(_hypervisor.rewardPool);      // calculate vested portion of reward pool     uint256 unlockedRewards =         calculateUnlockedRewards(             _hypervisor.rewardSchedules,             remainingRewards,             _hypervisor.rewardSharesOutstanding,             block.timestamp         );      // calculate vault time weighted reward with scaling     RewardOutput memory out =         calculateRewardFromStakes(             vaultData.stakes,             amount,             unlockedRewards,             _hypervisor.totalStakeUnits,             block.timestamp,             _hypervisor.rewardScaling         );      // update stake data in storage     if (out.newStakesCount == 0) {         // all stakes have been unstaked         delete vaultData.stakes;     } else {         // some stakes have been completely or partially unstaked         // delete fully unstaked stakes         while (vaultData.stakes.length &gt; out.newStakesCount) vaultData.stakes.pop();         // update partially unstaked stake         vaultData.stakes[out.newStakesCount.sub(1)].amount = out.lastStakeAmount;     }      // update cached stake totals     vaultData.totalStake = vaultData.totalStake.sub(amount);     _hypervisor.totalStake = _hypervisor.totalStake.sub(amount);     _hypervisor.totalStakeUnits = out.newTotalStakeUnits;      // unlock staking tokens from vault     IUniversalVault(vault).unlock(_hypervisor.stakingToken, amount, permission);      // emit event     emit Unstaked(vault, amount);      // only perform on non-zero reward     if (out.reward &gt; 0) {         // calculate shares to burn         // sharesToBurn = sharesOutstanding * reward / remainingRewards         uint256 sharesToBurn =             _hypervisor.rewardSharesOutstanding.mul(out.reward).div(remainingRewards);          // burn claimed shares         _hypervisor.rewardSharesOutstanding = _hypervisor.rewardSharesOutstanding.sub(sharesToBurn);          // transfer bonus tokens from reward pool to recipient         if (_bonusTokenSet.length() &gt; 0) {             for (uint256 index = 0; index &lt; _bonusTokenSet.length(); index++) {                 // fetch bonus token address reference                 address bonusToken = _bonusTokenSet.at(index);                  // calculate bonus token amount                 // bonusAmount = bonusRemaining * reward / remainingRewards                 uint256 bonusAmount =                     IERC20(bonusToken).balanceOf(_hypervisor.rewardPool).mul(out.reward).div(                         remainingRewards                     );                  // transfer bonus token                 IRewardPool(_hypervisor.rewardPool).sendERC20(bonusToken, recipient, bonusAmount);                  // emit event                 emit RewardClaimed(vault, recipient, bonusToken, bonusAmount);             }         }          // transfer reward tokens from reward pool to recipient         IRewardPool(_hypervisor.rewardPool).sendERC20(_hypervisor.rewardToken, recipient, out.reward);          // emit event         emit RewardClaimed(vault, recipient, _hypervisor.rewardToken, out.reward);     } }  /// @notice Exit Hypervisor without claiming reward /// @dev This function should never revert when correctly called by the vault. ///      A max number of stakes per vault is set with MAX_STAKES_PER_VAULT to ///      place an upper bound on the for loop in calculateTotalStakeUnits(). /// access control: only callable by the vault directly /// state machine: ///   - when vault exists on this Hypervisor ///   - when active stake from this vault ///   - any power state /// state scope: ///   - decrease _hypervisor.totalStake ///   - increase _hypervisor.lastUpdate ///   - modify _hypervisor.totalStakeUnits ///   - delete _vaults[vault] /// token transfer: none function rageQuit() external override {     // fetch vault storage reference     VaultData storage _vaultData = _vaults[msg.sender];      // revert if no active stakes     require(_vaultData.stakes.length != 0, ""Hypervisor: no stake"");      // update cached sum of stake units across all vaults     _updateTotalStakeUnits();      // emit event     emit Unstaked(msg.sender, _vaultData.totalStake);      // update cached totals     _hypervisor.totalStake = _hypervisor.totalStake.sub(_vaultData.totalStake);     _hypervisor.totalStakeUnits = _hypervisor.totalStakeUnits.sub(         calculateTotalStakeUnits(_vaultData.stakes, block.timestamp)     );      // delete stake data     delete _vaults[msg.sender]; }  /* convenience functions */  function _updateTotalStakeUnits() private {     // update cached totalStakeUnits     _hypervisor.totalStakeUnits = getCurrentTotalStakeUnits();     // update cached lastUpdate     _hypervisor.lastUpdate = block.timestamp; }  function _validateAddress(address target) private view {     // sanity check target for potential input errors     require(isValidAddress(target), ""Hypervisor: invalid address""); }  function _truncateStakesArray(StakeData[] memory array, uint256 newLength)     private     pure     returns (StakeData[] memory newArray) {     newArray = new StakeData[](newLength);     for (uint256 index = 0; index &lt; newLength; index++) {         newArray[index] = array[index];     }     return newArray; }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: ""{task}"". Ideas: ""{ideas}"". As the {assistant_role}, your primary objective is to conduct a comprehensive inspection of the provided contract code, with a particular focus on identifying vulnerabilities related to Price Manipulation. There are two cases where the contract may have Price Manipulation vulnerabilities: 1. When the contract allows arbitrary adjustment of token prices by a centralized authority without any checks or balances, potentially leading to unfair trades. 2. When the contract does not utilize decentralized or transparent mechanisms for determining token prices, allowing for potential exploitation by the controlling entity. If you identify all Price Manipulation vulnerabilities, respond with: "" Price Manipulation Identified."" For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE ''' DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code. ''' If you don't find any vulnerabilities, respond only with: "" No Price Manipulation."" |
| **phase_name** | PriceManipulationDetector |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 1, 'modification_conclusion': '', 'cycle_index': 1, 'task': '// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport {SafeMath} from ""@openzeppelin/contracts/math/SafeMath.sol"";\nimport {EnumerableSet} from ""@openzeppelin/contracts/utils/EnumerableSet.sol"";\nimport {IERC20} from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";\nimport {Ownable} from ""@openzeppelin/contracts/access/Ownable.sol"";\nimport {TransferHelper} from ""@uniswap/lib/contracts/libraries/TransferHelper.sol"";\n\nimport {IFactory} from ""../factory/IFactory.sol"";\nimport {IInstanceRegistry} from ""../factory/InstanceRegistry.sol"";\nimport {IUniversalVault} from ""../visor/Visor.sol"";\nimport {IRewardPool} from ""./RewardPool.sol"";\nimport {Powered} from ""./Powered.sol"";\n\ninterface IRageQuit {\n    function rageQuit() external;\n}\n\ninterface IHypervisor is IRageQuit {\n    / admin events /\n\n    event HypervisorCreated(address rewardPool, address powerSwitch);\n    event HypervisorFunded(uint256 amount, uint256 duration);\n    event BonusTokenRegistered(address token);\n    event VaultFactoryRegistered(address factory);\n    event VaultFactoryRemoved(address factory);\n\n    / user events /\n\n    event Staked(address vault, uint256 amount);\n    event Unstaked(address vault, uint256 amount);\n    event RewardClaimed(address vault, address recipient, address token, uint256 amount);\n\n    / data types /\n\n    struct HypervisorData {\n        address stakingToken;\n        address rewardToken;\n        address rewardPool;\n        RewardScaling rewardScaling;\n        uint256 rewardSharesOutstanding;\n        uint256 totalStake;\n        uint256 totalStakeUnits;\n        uint256 lastUpdate;\n        RewardSchedule[] rewardSchedules;\n    }\n\n    struct RewardSchedule {\n        uint256 duration;\n        uint256 start;\n        uint256 shares;\n    }\n\n    struct VaultData {\n        uint256 totalStake;\n        StakeData[] stakes;\n    }\n\n    struct StakeData {\n        uint256 amount;\n        uint256 timestamp;\n    }\n\n    struct RewardScaling {\n        uint256 floor;\n        uint256 ceiling;\n        uint256 time;\n    }\n\n    struct RewardOutput {\n        uint256 lastStakeAmount;\n        uint256 newStakesCount;\n        uint256 reward;\n        uint256 newTotalStakeUnits;\n    }\n\n    / user functions /\n\n    function stake(\n        address vault,\n        uint256 amount,\n        bytes calldata permission\n    ) external;\n\n    function unstakeAndClaim(\n        address vault,\n        uint256 amount,\n        bytes calldata permission\n    ) external;\n\n    / getter functions /\n\n    function getHypervisorData() external view returns (HypervisorData memory hypervisor);\n\n    function getBonusTokenSetLength() external view returns (uint256 length);\n\n    function getBonusTokenAtIndex(uint256 index) external view returns (address bonusToken);\n\n    function getVaultFactorySetLength() external view returns (uint256 length);\n\n    function getVaultFactoryAtIndex(uint256 index) external view returns (address factory);\n\n    function getVaultData(address vault) external view returns (VaultData memory vaultData);\n\n    function isValidAddress(address target) external view returns (bool validity);\n\n    function isValidVault(address target) external view returns (bool validity);\n\n    function getCurrentUnlockedRewards() external view returns (uint256 unlockedRewards);\n\n    function getFutureUnlockedRewards(uint256 timestamp)\n        external\n        view\n        returns (uint256 unlockedRewards);\n\n    function getCurrentVaultReward(address vault) external view returns (uint256 reward);\n\n    function getCurrentStakeReward(address vault, uint256 stakeAmount)\n        external\n        view\n        returns (uint256 reward);\n\n    function getFutureVaultReward(address vault, uint256 timestamp)\n        external\n        view\n        returns (uint256 reward);\n\n    function getFutureStakeReward(\n        address vault,\n        uint256 stakeAmount,\n        uint256 timestamp\n    ) external view returns (uint256 reward);\n\n    function getCurrentVaultStakeUnits(address vault) external view returns (uint256 stakeUnits);\n\n    function getFutureVaultStakeUnits(address vault, uint256 timestamp)\n        external\n        view\n        returns (uint256 stakeUnits);\n\n    function getCurrentTotalStakeUnits() external view returns (uint256 totalStakeUnits);\n\n    function getFutureTotalStakeUnits(uint256 timestamp)\n        external\n        view\n        returns (uint256 totalStakeUnits);\n\n    / pure functions /\n\n    function calculateTotalStakeUnits(StakeData[] memory stakes, uint256 timestamp)\n        external\n        pure\n        returns (uint256 totalStakeUnits);\n\n    function calculateStakeUnits(\n        uint256 amount,\n        uint256 start,\n        uint256 end\n    ) external pure returns (uint256 stakeUnits);\n\n    function calculateUnlockedRewards(\n        RewardSchedule[] memory rewardSchedules,\n        uint256 rewardBalance,\n        uint256 sharesOutstanding,\n        uint256 timestamp\n    ) external pure returns (uint256 unlockedRewards);\n\n    function calculateRewardFromStakes(\n        StakeData[] memory stakes,\n        uint256 unstakeAmount,\n        uint256 unlockedRewards,\n        uint256 totalStakeUnits,\n        uint256 timestamp,\n        RewardScaling memory rewardScaling\n    ) external pure returns (RewardOutput memory out);\n\n    function calculateReward(\n        uint256 unlockedRewards,\n        uint256 stakeAmount,\n        uint256 stakeDuration,\n        uint256 totalStakeUnits,\n        RewardScaling memory rewardScaling\n    ) external pure returns (uint256 reward);\n}\n\n/// @title Hypervisor\n/// @notice Reward distribution contract with time multiplier\n/// Access Control\n/// - Power controller:\n///     Can power off / shutdown the Hypervisor\n///     Can withdraw rewards from reward pool once shutdown\n/// - Proxy owner:\n///     Can change arbitrary logic / state by upgrading the Hypervisor\n///     Is unable to operate on user funds due to UniversalVault\n///     Is unable to operate on reward pool funds when reward pool is offline / shutdown\n/// - Hypervisor admin:\n///     Can add funds to the Hypervisor, register bonus tokens, and whitelist new vault factories\n///     Is a subset of proxy owner permissions\n/// - User:\n///     Can deposit / withdraw / ragequit\n/// Hypervisor State Machine\n/// - Online:\n///     Hypervisor is operating normally, all functions are enabled\n/// - Offline:\n///     Hypervisor is temporarely disabled for maintenance\n///     User deposits and withdrawls are disabled, ragequit remains enabled\n///     Users can withdraw their stake through rageQuit() but forego their pending reward\n///     Should only be used when downtime required for an upgrade\n/// - Shutdown:\n///     Hypervisor is permanently disabled\n///     All functions are disabled with the exception of ragequit\n///     Users can withdraw their stake through rageQuit()\n///     Power controller can withdraw from the reward pool\n///     Should only be used if Proxy Owner role is compromized\ncontract Hypervisor is IHypervisor, Powered, Ownable {\n    using SafeMath for uint256;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    / constants /\n\n    // An upper bound on the number of active stakes per vault is required to prevent\n    // calls to rageQuit() from reverting.\n    // With 30 stakes in a vault, ragequit costs 432811 gas which is conservatively lower\n    // than the hardcoded limit of 500k gas on the vault.\n    // This limit is configurable and could be increased in a future deployment.\n    // Ultimately, to avoid a need for fixed upper bounds, the EVM would need to provide\n    // an error code that allows for reliably catching out-of-gas errors on remote calls.\n    uint256 public constant MAX_STAKES_PER_VAULT = 30;\n    uint256 public constant MAX_REWARD_TOKENS = 50;\n    uint256 public constant BASE_SHARES_PER_WEI = 1000000;\n    uint256 public stakeLimit = 2500 ether;\n\n    / storage /\n\n    HypervisorData private _hypervisor;\n    mapping(address =&gt; VaultData) private _vaults;\n    EnumerableSet.AddressSet private _bonusTokenSet;\n    EnumerableSet.AddressSet private _vaultFactorySet;\n\n    / initializer /\n\n    /// @notice Initizalize Hypervisor\n    /// access control: only proxy constructor\n    /// state machine: can only be called once\n    /// state scope: set initialization variables\n    /// token transfer: none\n    /// @param ownerAddress address The admin address\n    /// @param rewardPoolFactory address The factory to use for deploying the RewardPool\n    /// @param powerSwitchFactory address The factory to use for deploying the PowerSwitch\n    /// @param stakingToken address The address of the staking token for this Hypervisor\n    /// @param rewardToken address The address of the reward token for this Hypervisor\n    /// @param rewardScaling RewardScaling The config for reward scaling floor, ceiling, and time\n    constructor(\n        address ownerAddress,\n        address rewardPoolFactory,\n        address powerSwitchFactory,\n        address stakingToken,\n        address rewardToken,\n        RewardScaling memory rewardScaling,\n        uint256 _stakeLimit\n    ) {\n        // the scaling floor must be smaller than ceiling\n        require(rewardScaling.floor &lt;= rewardScaling.ceiling, ""Hypervisor: floor above ceiling"");\n\n        // setting rewardScalingTime to 0 would cause divide by zero error\n        // to disable reward scaling, use rewardScalingFloor == rewardScalingCeiling\n        require(rewardScaling.time != 0, ""Hypervisor: scaling time cannot be zero"");\n\n        // deploy power switch\n        address powerSwitch = IFactory(powerSwitchFactory).create(abi.encode(ownerAddress));\n\n        // deploy reward pool\n        address rewardPool = IFactory(rewardPoolFactory).create(abi.encode(powerSwitch));\n\n        // set internal configs\n        Ownable.transferOwnership(ownerAddress);\n        Powered._setPowerSwitch(powerSwitch);\n\n        // commit to storage\n        _hypervisor.stakingToken = stakingToken;\n        _hypervisor.rewardToken = rewardToken;\n        _hypervisor.rewardPool = rewardPool;\n        _hypervisor.rewardScaling = rewardScaling;\n\n        stakeLimit = _stakeLimit;\n\n        // emit event\n        emit HypervisorCreated(rewardPool, powerSwitch);\n    }\n\n    / getter functions /\n\n    function getBonusTokenSetLength() external view override returns (uint256 length) {\n        return _bonusTokenSet.length();\n    }\n\n    function getBonusTokenAtIndex(uint256 index)\n        external\n        view\n        override\n        returns (address bonusToken)\n    {\n        return _bonusTokenSet.at(index);\n    }\n\n    function getVaultFactorySetLength() external view override returns (uint256 length) {\n        return _vaultFactorySet.length();\n    }\n\n    function getVaultFactoryAtIndex(uint256 index)\n        external\n        view\n        override\n        returns (address factory)\n    {\n        return _vaultFactorySet.at(index);\n    }\n\n    function isValidVault(address target) public view override returns (bool validity) {\n        // validate target is created from whitelisted vault factory\n        for (uint256 index = 0; index &lt; _vaultFactorySet.length(); index++) {\n            if (IInstanceRegistry(_vaultFactorySet.at(index)).isInstance(target)) {\n                return true;\n            }\n        }\n        // explicit return\n        return false;\n    }\n\n    function isValidAddress(address target) public view override returns (bool validity) {\n        // sanity check target for potential input errors\n        return\n            target != address(this) &amp;&amp;\n            target != address(0) &amp;&amp;\n            target != _hypervisor.stakingToken &amp;&amp;\n            target != _hypervisor.rewardToken &amp;&amp;\n            target != _hypervisor.rewardPool &amp;&amp;\n            !_bonusTokenSet.contains(target);\n    }\n\n    / Hypervisor getters /\n\n    function getHypervisorData() external view override returns (HypervisorData memory hypervisor) {\n        return _hypervisor;\n    }\n\n    function getCurrentUnlockedRewards() public view override returns (uint256 unlockedRewards) {\n        // calculate reward available based on state\n        return getFutureUnlockedRewards(block.timestamp);\n    }\n\n    function getFutureUnlockedRewards(uint256 timestamp)\n        public\n        view\n        override\n        returns (uint256 unlockedRewards)\n    {\n        // get reward amount remaining\n        uint256 remainingRewards = IERC20(_hypervisor.rewardToken).balanceOf(_hypervisor.rewardPool);\n        // calculate reward available based on state\n        unlockedRewards = calculateUnlockedRewards(\n            _hypervisor.rewardSchedules,\n            remainingRewards,\n            _hypervisor.rewardSharesOutstanding,\n            timestamp\n        );\n        // explicit return\n        return unlockedRewards;\n    }\n\n    function getCurrentTotalStakeUnits() public view override returns (uint256 totalStakeUnits) {\n        // calculate new stake units\n        return getFutureTotalStakeUnits(block.timestamp);\n    }\n\n    function getFutureTotalStakeUnits(uint256 timestamp)\n        public\n        view\n        override\n        returns (uint256 totalStakeUnits)\n    {\n        // return early if no change\n        if (timestamp == _hypervisor.lastUpdate) return _hypervisor.totalStakeUnits;\n        // calculate new stake units\n        uint256 newStakeUnits =\n            calculateStakeUnits(_hypervisor.totalStake, _hypervisor.lastUpdate, timestamp);\n        // add to cached total\n        totalStakeUnits = _hypervisor.totalStakeUnits.add(newStakeUnits);\n        // explicit return\n        return totalStakeUnits;\n    }\n\n    / vault getters /\n\n    function getVaultData(address vault)\n        external\n        view\n        override\n        returns (VaultData memory vaultData)\n    {\n        return _vaults[vault];\n    }\n\n    function getCurrentVaultReward(address vault) external view override returns (uint256 reward) {\n        // calculate rewards\n        return\n            calculateRewardFromStakes(\n                _vaults[vault]\n                    .stakes,\n                _vaults[vault]\n                    .totalStake,\n                getCurrentUnlockedRewards(),\n                getCurrentTotalStakeUnits(),\n                block\n                    .timestamp,\n                _hypervisor\n                    .rewardScaling\n            )\n                .reward;\n    }\n\n    function getFutureVaultReward(address vault, uint256 timestamp)\n        external\n        view\n        override\n        returns (uint256 reward)\n    {\n        // calculate rewards\n        return\n            calculateRewardFromStakes(\n                _vaults[vault]\n                    .stakes,\n                _vaults[vault]\n                    .totalStake,\n                getFutureUnlockedRewards(timestamp),\n                getFutureTotalStakeUnits(timestamp),\n                timestamp,\n                _hypervisor\n                    .rewardScaling\n            )\n                .reward;\n    }\n\n    function getCurrentStakeReward(address vault, uint256 stakeAmount)\n        external\n        view\n        override\n        returns (uint256 reward)\n    {\n        // calculate rewards\n        return\n            calculateRewardFromStakes(\n                _vaults[vault]\n                    .stakes,\n                stakeAmount,\n                getCurrentUnlockedRewards(),\n                getCurrentTotalStakeUnits(),\n                block\n                    .timestamp,\n                _hypervisor\n                    .rewardScaling\n            )\n                .reward;\n    }\n\n    function getFutureStakeReward(\n        address vault,\n        uint256 stakeAmount,\n        uint256 timestamp\n    ) external view override returns (uint256 reward) {\n        // calculate rewards\n        return\n            calculateRewardFromStakes(\n                _vaults[vault]\n                    .stakes,\n                stakeAmount,\n                getFutureUnlockedRewards(timestamp),\n                getFutureTotalStakeUnits(timestamp),\n                timestamp,\n                _hypervisor\n                    .rewardScaling\n            )\n                .reward;\n    }\n\n    function getCurrentVaultStakeUnits(address vault)\n        public\n        view\n        override\n        returns (uint256 stakeUnits)\n    {\n        // calculate stake units\n        return getFutureVaultStakeUnits(vault, block.timestamp);\n    }\n\n    function getFutureVaultStakeUnits(address vault, uint256 timestamp)\n        public\n        view\n        override\n        returns (uint256 stakeUnits)\n    {\n        // calculate stake units\n        return calculateTotalStakeUnits(_vaults[vault].stakes, timestamp);\n    }\n\n    / pure functions /\n\n    function calculateTotalStakeUnits(StakeData[] memory stakes, uint256 timestamp)\n        public\n        pure\n        override\n        returns (uint256 totalStakeUnits)\n    {\n        for (uint256 index; index &lt; stakes.length; index++) {\n            // reference stake\n            StakeData memory stakeData = stakes[index];\n            // calculate stake units\n            uint256 stakeUnits =\n                calculateStakeUnits(stakeData.amount, stakeData.timestamp, timestamp);\n            // add to running total\n            totalStakeUnits = totalStakeUnits.add(stakeUnits);\n        }\n    }\n\n    function calculateStakeUnits(\n        uint256 amount,\n        uint256 start,\n        uint256 end\n    ) public pure override returns (uint256 stakeUnits) {\n        // calculate duration\n        uint256 duration = end.sub(start);\n        // calculate stake units\n        stakeUnits = duration.mul(amount);\n        // explicit return\n        return stakeUnits;\n    }\n\n    function calculateUnlockedRewards(\n        RewardSchedule[] memory rewardSchedules,\n        uint256 rewardBalance,\n        uint256 sharesOutstanding,\n        uint256 timestamp\n    ) public pure override returns (uint256 unlockedRewards) {\n        // return 0 if no registered schedules\n        if (rewardSchedules.length == 0) {\n            return 0;\n        }\n\n        // calculate reward shares locked across all reward schedules\n        uint256 sharesLocked;\n        for (uint256 index = 0; index &lt; rewardSchedules.length; index++) {\n            // fetch reward schedule storage reference\n            RewardSchedule memory schedule = rewardSchedules[index];\n\n            // caculate amount of shares available on this schedule\n            // if (now - start) &lt; duration\n            //   sharesLocked = shares - (shares * (now - start) / duration)\n            // else\n            //   sharesLocked = 0\n            uint256 currentSharesLocked = 0;\n            if (timestamp.sub(schedule.start) &lt; schedule.duration) {\n                currentSharesLocked = schedule.shares.sub(\n                    schedule.shares.mul(timestamp.sub(schedule.start)).div(schedule.duration)\n                );\n            }\n\n            // add to running total\n            sharesLocked = sharesLocked.add(currentSharesLocked);\n        }\n\n        // convert shares to reward\n        // rewardLocked = sharesLocked * rewardBalance / sharesOutstanding\n        uint256 rewardLocked = sharesLocked.mul(rewardBalance).div(sharesOutstanding);\n\n        // calculate amount available\n        // unlockedRewards = rewardBalance - rewardLocked\n        unlockedRewards = rewardBalance.sub(rewardLocked);\n\n        // explicit return\n        return unlockedRewards;\n    }\n\n    function calculateRewardFromStakes(\n        StakeData[] memory stakes,\n        uint256 unstakeAmount,\n        uint256 unlockedRewards,\n        uint256 totalStakeUnits,\n        uint256 timestamp,\n        RewardScaling memory rewardScaling\n    ) public pure override returns (RewardOutput memory out) {\n        uint256 stakesToDrop = 0;\n        while (unstakeAmount &gt; 0) {\n            // fetch vault stake storage reference\n            StakeData memory lastStake = stakes[stakes.length.sub(stakesToDrop).sub(1)];\n\n            // calculate stake duration\n            uint256 stakeDuration = timestamp.sub(lastStake.timestamp);\n\n            uint256 currentAmount;\n            if (lastStake.amount &gt; unstakeAmount) {\n                // set current amount to remaining unstake amount\n                currentAmount = unstakeAmount;\n                // amount of last stake is reduced\n                out.lastStakeAmount = lastStake.amount.sub(unstakeAmount);\n            } else {\n                // set current amount to amount of last stake\n                currentAmount = lastStake.amount;\n                // add to stakes to drop\n                stakesToDrop += 1;\n            }\n\n            // update remaining unstakeAmount\n            unstakeAmount = unstakeAmount.sub(currentAmount);\n\n            // calculate reward amount\n            uint256 currentReward =\n                calculateReward(\n                    unlockedRewards,\n                    currentAmount,\n                    stakeDuration,\n                    totalStakeUnits,\n                    rewardScaling\n                );\n\n            // update cumulative reward\n            out.reward = out.reward.add(currentReward);\n\n            // update cached unlockedRewards\n            unlockedRewards = unlockedRewards.sub(currentReward);\n\n            // calculate time weighted stake\n            uint256 stakeUnits = currentAmount.mul(stakeDuration);\n\n            // update cached totalStakeUnits\n            totalStakeUnits = totalStakeUnits.sub(stakeUnits);\n        }\n\n        // explicit return\n        return\n            RewardOutput(\n                out.lastStakeAmount,\n                stakes.length.sub(stakesToDrop),\n                out.reward,\n                totalStakeUnits\n            );\n    }\n\n    function calculateReward(\n        uint256 unlockedRewards,\n        uint256 stakeAmount,\n        uint256 stakeDuration,\n        uint256 totalStakeUnits,\n        RewardScaling memory rewardScaling\n    ) public pure override returns (uint256 reward) {\n        // calculate time weighted stake\n        uint256 stakeUnits = stakeAmount.mul(stakeDuration);\n\n        // calculate base reward\n        // baseReward = unlockedRewards * stakeUnits / totalStakeUnits\n        uint256 baseReward = 0;\n        if (totalStakeUnits != 0) {\n            // scale reward according to proportional weight\n            baseReward = unlockedRewards.mul(stakeUnits).div(totalStakeUnits);\n        }\n\n        // calculate scaled reward\n        // if no scaling or scaling period completed\n        //   reward = baseReward\n        // else\n        //   minReward = baseReward * scalingFloor / scalingCeiling\n        //   bonusReward = baseReward\n        //                 * (scalingCeiling - scalingFloor) / scalingCeiling\n        //                 * duration / scalingTime\n        //   reward = minReward + bonusReward\n        if (stakeDuration &gt;= rewardScaling.time || rewardScaling.floor == rewardScaling.ceiling) {\n            // no reward scaling applied\n            reward = baseReward;\n        } else {\n            // calculate minimum reward using scaling floor\n            uint256 minReward = baseReward.mul(rewardScaling.floor).div(rewardScaling.ceiling);\n\n            // calculate bonus reward with vested portion of scaling factor\n            uint256 bonusReward =\n                baseReward\n                    .mul(stakeDuration)\n                    .mul(rewardScaling.ceiling.sub(rewardScaling.floor))\n                    .div(rewardScaling.ceiling)\n                    .div(rewardScaling.time);\n\n            // add minimum reward and bonus reward\n            reward = minReward.add(bonusReward);\n        }\n\n        // explicit return\n        return reward;\n    }\n\n    / admin functions /\n\n    /// @notice Add funds to the Hypervisor\n    /// access control: only admin\n    /// state machine:\n    ///   - can be called multiple times\n    ///   - only online\n    /// state scope:\n    ///   - increase _hypervisor.rewardSharesOutstanding\n    ///   - append to _hypervisor.rewardSchedules\n    /// token transfer: transfer staking tokens from msg.sender to reward pool\n    /// @param amount uint256 Amount of reward tokens to deposit\n    /// @param duration uint256 Duration over which to linearly unlock rewards\n    function fund(uint256 amount, uint256 duration) external onlyOwner onlyOnline {\n        // validate duration\n        require(duration != 0, ""Hypervisor: invalid duration"");\n\n        // create new reward shares\n        // if existing rewards on this Hypervisor\n        //   mint new shares proportional to % change in rewards remaining\n        //   newShares = remainingShares * newReward / remainingRewards\n        // else\n        //   mint new shares with BASE_SHARES_PER_WEI initial conversion rate\n        //   store as fixed point number with same  of decimals as reward token\n        uint256 newRewardShares;\n        if (_hypervisor.rewardSharesOutstanding &gt; 0) {\n            uint256 remainingRewards = IERC20(_hypervisor.rewardToken).balanceOf(_hypervisor.rewardPool);\n            newRewardShares = _hypervisor.rewardSharesOutstanding.mul(amount).div(remainingRewards);\n        } else {\n            newRewardShares = amount.mul(BASE_SHARES_PER_WEI);\n        }\n\n        // add reward shares to total\n        _hypervisor.rewardSharesOutstanding = _hypervisor.rewardSharesOutstanding.add(newRewardShares);\n\n        // store new reward schedule\n        _hypervisor.rewardSchedules.push(RewardSchedule(duration, block.timestamp, newRewardShares));\n\n        // transfer reward tokens to reward pool\n        TransferHelper.safeTransferFrom(\n            _hypervisor.rewardToken,\n            msg.sender,\n            _hypervisor.rewardPool,\n            amount\n        );\n\n        // emit event\n        emit HypervisorFunded(amount, duration);\n    }\n\n    /// @notice Add vault factory to whitelist\n    /// @dev use this function to enable stakes to vaults coming from the specified\n    ///      factory contract\n    /// access control: only admin\n    /// state machine:\n    ///   - can be called multiple times\n    ///   - not shutdown\n    /// state scope:\n    ///   - append to _vaultFactorySet\n    /// token transfer: none\n    /// @param factory address The address of the vault factory\n    function registerVaultFactory(address factory) external onlyOwner notShutdown {\n        // add factory to set\n        require(_vaultFactorySet.add(factory), ""Hypervisor: vault factory already registered"");\n\n        // emit event\n        emit VaultFactoryRegistered(factory);\n    }\n\n    /// @notice Remove vault factory from whitelist\n    /// @dev use this function to disable new stakes to vaults coming from the specified\n    ///      factory contract.\n    ///      note: vaults with existing stakes from this factory are sill able to unstake\n    /// access control: only admin\n    /// state machine:\n    ///   - can be called multiple times\n    ///   - not shutdown\n    /// state scope:\n    ///   - remove from _vaultFactorySet\n    /// token transfer: none\n    /// @param factory address The address of the vault factory\n    function removeVaultFactory(address factory) external onlyOwner notShutdown {\n        // remove factory from set\n        require(_vaultFactorySet.remove(factory), ""Hypervisor: vault factory not registered"");\n\n        // emit event\n        emit VaultFactoryRemoved(factory);\n    }\n\n    /// @notice Register bonus token for distribution\n    /// @dev use this function to enable distribution of any ERC20 held by the RewardPool contract\n    /// access control: only admin\n    /// state machine:\n    ///   - can be called multiple times\n    ///   - only online\n    /// state scope:\n    ///   - append to _bonusTokenSet\n    /// token transfer: none\n    /// @param bonusToken address The address of the bonus token\n    function registerBonusToken(address bonusToken) external onlyOwner onlyOnline {\n        // verify valid bonus token\n        _validateAddress(bonusToken);\n\n        // verify bonus token count\n        require(_bonusTokenSet.length() &lt; MAX_REWARD_TOKENS, ""Hypervisor: max bonus tokens reached "");\n\n        // add token to set\n        assert(_bonusTokenSet.add(bonusToken));\n\n        // emit event\n        emit BonusTokenRegistered(bonusToken);\n    }\n\n    /// @notice Rescue tokens from RewardPool\n    /// @dev use this function to rescue tokens from RewardPool contract\n    ///      without distributing to stakers or triggering emergency shutdown\n    /// access control: only admin\n    /// state machine:\n    ///   - can be called multiple times\n    ///   - only online\n    /// state scope: none\n    /// token transfer: transfer requested token from RewardPool to recipient\n    /// @param token address The address of the token to rescue\n    /// @param recipient address The address of the recipient\n    /// @param amount uint256 The amount of tokens to rescue\n    function rescueTokensFromRewardPool(\n        address token,\n        address recipient,\n        uint256 amount\n    ) external onlyOwner onlyOnline {\n        // verify recipient\n        _validateAddress(recipient);\n\n        // check not attempting to unstake reward token\n        require(token != _hypervisor.rewardToken, ""Hypervisor: invalid address"");\n\n        // check not attempting to wthdraw bonus token\n        require(!_bonusTokenSet.contains(token), ""Hypervisor: invalid address"");\n\n        // transfer tokens to recipient\n        IRewardPool(_hypervisor.rewardPool).sendERC20(token, recipient, amount);\n    }\n\n    / user functions /\n\n    /// @notice Stake tokens\n    /// @dev anyone can stake to any vault if they have valid permission\n    /// access control: anyone\n    /// state machine:\n    ///   - can be called multiple times\n    ///   - only online\n    ///   - when vault exists on this Hypervisor\n    /// state scope:\n    ///   - append to _vaults[vault].stakes\n    ///   - increase _vaults[vault].totalStake\n    ///   - increase _hypervisor.totalStake\n    ///   - increase _hypervisor.totalStakeUnits\n    ///   - increase _hypervisor.lastUpdate\n    /// token transfer: transfer staking tokens from msg.sender to vault\n    /// @param vault address The address of the vault to stake from\n    /// @param amount uint256 The amount of staking tokens to stake\n    function stake(\n        address vault,\n        uint256 amount,\n        bytes calldata permission\n    ) external override onlyOnline {\n        // verify vault is valid\n        require(isValidVault(vault), ""Hypervisor: vault is not registered"");\n\n        // verify non-zero amount\n        require(amount != 0, ""Hypervisor: no amount staked"");\n\n        // fetch vault storage reference\n        VaultData storage vaultData = _vaults[vault];\n\n        // verify stakes boundary not reached\n        require(\n            vaultData.stakes.length &lt; MAX_STAKES_PER_VAULT,\n            ""Hypervisor: MAX_STAKES_PER_VAULT reached""\n        );\n\n        // update cached sum of stake units across all vaults\n        _updateTotalStakeUnits();\n\n        // store amount and timestamp\n        vaultData.stakes.push(StakeData(amount, block.timestamp));\n\n        // update cached total vault and Hypervisor amounts\n        vaultData.totalStake = vaultData.totalStake.add(amount);\n        // verify stake quantity without bounds\n        require(\n            stakeLimit == 0 || vaultData.totalStake &lt;= stakeLimit,\n            ""Hypervisor: Stake limit exceeded""\n        );\n        _hypervisor.totalStake = _hypervisor.totalStake.add(amount);\n\n        // call lock on vault\n        IUniversalVault(vault).lock(_hypervisor.stakingToken, amount, permission);\n\n        // emit event\n        emit Staked(vault, amount);\n    }\n\n    /// @notice Unstake staking tokens and claim reward\n    /// @dev rewards can only be claimed when unstaking\n    /// access control: only owner of vault\n    /// state machine:\n    ///   - when vault exists on this Hypervisor\n    ///   - after stake from vault\n    ///   - can be called multiple times while sufficient stake remains\n    ///   - only online\n    /// state scope:\n    ///   - decrease _hypervisor.rewardSharesOutstanding\n    ///   - decrease _hypervisor.totalStake\n    ///   - increase _hypervisor.lastUpdate\n    ///   - modify _hypervisor.totalStakeUnits\n    ///   - modify _vaults[vault].stakes\n    ///   - decrease _vaults[vault].totalStake\n    /// token transfer:\n    ///   - transfer reward tokens from reward pool to recipient\n    ///   - transfer bonus tokens from reward pool to recipient\n    /// @param vault address The vault to unstake from\n    /// @param amount uint256 The amount of staking tokens to unstake\n    function unstakeAndClaim(\n        address vault,\n        uint256 amount,\n        bytes calldata permission\n    ) external override onlyOnline {\n        // fetch vault storage reference\n        VaultData storage vaultData = _vaults[vault];\n\n        // verify non-zero amount\n        require(amount != 0, ""Hypervisor: no amount unstaked"");\n\n        address recipient = IUniversalVault(vault).owner();\n\n        // validate recipient\n        _validateAddress(recipient);\n\n        // check for sufficient vault stake amount\n        require(vaultData.totalStake &gt;= amount, ""Hypervisor: insufficient vault stake"");\n\n        // check for sufficient Hypervisor stake amount\n        // if this check fails, there is a bug in stake accounting\n        assert(_hypervisor.totalStake &gt;= amount);\n\n        // update cached sum of stake units across all vaults\n        _updateTotalStakeUnits();\n\n        // get reward amount remaining\n        uint256 remainingRewards = IERC20(_hypervisor.rewardToken).balanceOf(_hypervisor.rewardPool);\n\n        // calculate vested portion of reward pool\n        uint256 unlockedRewards =\n            calculateUnlockedRewards(\n                _hypervisor.rewardSchedules,\n                remainingRewards,\n                _hypervisor.rewardSharesOutstanding,\n                block.timestamp\n            );\n\n        // calculate vault time weighted reward with scaling\n        RewardOutput memory out =\n            calculateRewardFromStakes(\n                vaultData.stakes,\n                amount,\n                unlockedRewards,\n                _hypervisor.totalStakeUnits,\n                block.timestamp,\n                _hypervisor.rewardScaling\n            );\n\n        // update stake data in storage\n        if (out.newStakesCount == 0) {\n            // all stakes have been unstaked\n            delete vaultData.stakes;\n        } else {\n            // some stakes have been completely or partially unstaked\n            // delete fully unstaked stakes\n            while (vaultData.stakes.length &gt; out.newStakesCount) vaultData.stakes.pop();\n            // update partially unstaked stake\n            vaultData.stakes[out.newStakesCount.sub(1)].amount = out.lastStakeAmount;\n        }\n\n        // update cached stake totals\n        vaultData.totalStake = vaultData.totalStake.sub(amount);\n        _hypervisor.totalStake = _hypervisor.totalStake.sub(amount);\n        _hypervisor.totalStakeUnits = out.newTotalStakeUnits;\n\n        // unlock staking tokens from vault\n        IUniversalVault(vault).unlock(_hypervisor.stakingToken, amount, permission);\n\n        // emit event\n        emit Unstaked(vault, amount);\n\n        // only perform on non-zero reward\n        if (out.reward &gt; 0) {\n            // calculate shares to burn\n            // sharesToBurn = sharesOutstanding * reward / remainingRewards\n            uint256 sharesToBurn =\n                _hypervisor.rewardSharesOutstanding.mul(out.reward).div(remainingRewards);\n\n            // burn claimed shares\n            _hypervisor.rewardSharesOutstanding = _hypervisor.rewardSharesOutstanding.sub(sharesToBurn);\n\n            // transfer bonus tokens from reward pool to recipient\n            if (_bonusTokenSet.length() &gt; 0) {\n                for (uint256 index = 0; index &lt; _bonusTokenSet.length(); index++) {\n                    // fetch bonus token address reference\n                    address bonusToken = _bonusTokenSet.at(index);\n\n                    // calculate bonus token amount\n                    // bonusAmount = bonusRemaining * reward / remainingRewards\n                    uint256 bonusAmount =\n                        IERC20(bonusToken).balanceOf(_hypervisor.rewardPool).mul(out.reward).div(\n                            remainingRewards\n                        );\n\n                    // transfer bonus token\n                    IRewardPool(_hypervisor.rewardPool).sendERC20(bonusToken, recipient, bonusAmount);\n\n                    // emit event\n                    emit RewardClaimed(vault, recipient, bonusToken, bonusAmount);\n                }\n            }\n\n            // transfer reward tokens from reward pool to recipient\n            IRewardPool(_hypervisor.rewardPool).sendERC20(_hypervisor.rewardToken, recipient, out.reward);\n\n            // emit event\n            emit RewardClaimed(vault, recipient, _hypervisor.rewardToken, out.reward);\n        }\n    }\n\n    /// @notice Exit Hypervisor without claiming reward\n    /// @dev This function should never revert when correctly called by the vault.\n    ///      A max number of stakes per vault is set with MAX_STAKES_PER_VAULT to\n    ///      place an upper bound on the for loop in calculateTotalStakeUnits().\n    /// access control: only callable by the vault directly\n    /// state machine:\n    ///   - when vault exists on this Hypervisor\n    ///   - when active stake from this vault\n    ///   - any power state\n    /// state scope:\n    ///   - decrease _hypervisor.totalStake\n    ///   - increase _hypervisor.lastUpdate\n    ///   - modify _hypervisor.totalStakeUnits\n    ///   - delete _vaults[vault]\n    /// token transfer: none\n    function rageQuit() external override {\n        // fetch vault storage reference\n        VaultData storage _vaultData = _vaults[msg.sender];\n\n        // revert if no active stakes\n        require(_vaultData.stakes.length != 0, ""Hypervisor: no stake"");\n\n        // update cached sum of stake units across all vaults\n        _updateTotalStakeUnits();\n\n        // emit event\n        emit Unstaked(msg.sender, _vaultData.totalStake);\n\n        // update cached totals\n        _hypervisor.totalStake = _hypervisor.totalStake.sub(_vaultData.totalStake);\n        _hypervisor.totalStakeUnits = _hypervisor.totalStakeUnits.sub(\n            calculateTotalStakeUnits(_vaultData.stakes, block.timestamp)\n        );\n\n        // delete stake data\n        delete _vaults[msg.sender];\n    }\n\n    / convenience functions /\n\n    function _updateTotalStakeUnits() private {\n        // update cached totalStakeUnits\n        _hypervisor.totalStakeUnits = getCurrentTotalStakeUnits();\n        // update cached lastUpdate\n        _hypervisor.lastUpdate = block.timestamp;\n    }\n\n    function _validateAddress(address target) private view {\n        // sanity check target for potential input errors\n        require(isValidAddress(target), ""Hypervisor: invalid address"");\n    }\n\n    function _truncateStakesArray(StakeData[] memory array, uint256 newLength)\n        private\n        pure\n        returns (StakeData[] memory newArray)\n    {\n        newArray = new StakeData;\n        for (uint256 index = 0; index &lt; newLength; index++) {\n            newArray[index] = array[index];\n        }\n        return newArray;\n    }\n}\n', 'ideas': "" Gas Limit Identified.\n\nLack of Gas Limit Considerations\n'''\nThe calculateTotalStakeUnits function iterates over the stakes array, which can potentially grow large if many stakes are made. If a user attempts to call this function with a vault that has a large number of stakes, it could lead to an out-of-gas error. This is particularly concerning in the rageQuit function, which calls _updateTotalStakeUnits, which in turn calls calculateTotalStakeUnits. If the stakes array is large, it could cause the transaction to fail due to exceeding the gas limit.\n\nTo mitigate this issue, consider implementing a maximum limit on the number of stakes that can be processed in a single transaction. Additionally, you could implement a mechanism to paginate through the stakes or allow users to withdraw stakes in smaller batches to avoid hitting gas limits.\n'''\n\n**Potential Denial-of-Service (DoS""} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-02-08 00:43:45 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **task_prompt** | // SPDX-License-Identifier: GPL-3.0-only pragma solidity 0.7.6; pragma abicoder v2; import {SafeMath} from ""@openzeppelin/contracts/math/SafeMath.sol""; import {EnumerableSet} from ""@openzeppelin/contracts/utils/EnumerableSet.sol""; import {IERC20} from ""@openzeppelin/contracts/token/ERC20/IERC20.sol""; import {Ownable} from ""@openzeppelin/contracts/access/Ownable.sol""; import {TransferHelper} from ""@uniswap/lib/contracts/libraries/TransferHelper.sol""; import {IFactory} from ""../factory/IFactory.sol""; import {IInstanceRegistry} from ""../factory/InstanceRegistry.sol""; import {IUniversalVault} from ""../visor/Visor.sol""; import {IRewardPool} from ""./RewardPool.sol""; import {Powered} from ""./Powered.sol""; interface IRageQuit {     function rageQuit() external; } interface IHypervisor is IRageQuit {     / admin events / event HypervisorCreated(address rewardPool, address powerSwitch); event HypervisorFunded(uint256 amount, uint256 duration); event BonusTokenRegistered(address token); event VaultFactoryRegistered(address factory); event VaultFactoryRemoved(address factory);  /* user events */  event Staked(address vault, uint256 amount); event Unstaked(address vault, uint256 amount); event RewardClaimed(address vault, address recipient, address token, uint256 amount);  /* data types */  struct HypervisorData {     address stakingToken;     address rewardToken;     address rewardPool;     RewardScaling rewardScaling;     uint256 rewardSharesOutstanding;     uint256 totalStake;     uint256 totalStakeUnits;     uint256 lastUpdate;     RewardSchedule[] rewardSchedules; }  struct RewardSchedule {     uint256 duration;     uint256 start;     uint256 shares; }  struct VaultData {     uint256 totalStake;     StakeData[] stakes; }  struct StakeData {     uint256 amount;     uint256 timestamp; }  struct RewardScaling {     uint256 floor;     uint256 ceiling;     uint256 time; }  struct RewardOutput {     uint256 lastStakeAmount;     uint256 newStakesCount;     uint256 reward;     uint256 newTotalStakeUnits; }  /* user functions */  function stake(     address vault,     uint256 amount,     bytes calldata permission ) external;  function unstakeAndClaim(     address vault,     uint256 amount,     bytes calldata permission ) external;  /* getter functions */  function getHypervisorData() external view returns (HypervisorData memory hypervisor);  function getBonusTokenSetLength() external view returns (uint256 length);  function getBonusTokenAtIndex(uint256 index) external view returns (address bonusToken);  function getVaultFactorySetLength() external view returns (uint256 length);  function getVaultFactoryAtIndex(uint256 index) external view returns (address factory);  function getVaultData(address vault) external view returns (VaultData memory vaultData);  function isValidAddress(address target) external view returns (bool validity);  function isValidVault(address target) external view returns (bool validity);  function getCurrentUnlockedRewards() external view returns (uint256 unlockedRewards);  function getFutureUnlockedRewards(uint256 timestamp)     external     view     returns (uint256 unlockedRewards);  function getCurrentVaultReward(address vault) external view returns (uint256 reward);  function getCurrentStakeReward(address vault, uint256 stakeAmount)     external     view     returns (uint256 reward);  function getFutureVaultReward(address vault, uint256 timestamp)     external     view     returns (uint256 reward);  function getFutureStakeReward(     address vault,     uint256 stakeAmount,     uint256 timestamp ) external view returns (uint256 reward);  function getCurrentVaultStakeUnits(address vault) external view returns (uint256 stakeUnits);  function getFutureVaultStakeUnits(address vault, uint256 timestamp)     external     view     returns (uint256 stakeUnits);  function getCurrentTotalStakeUnits() external view returns (uint256 totalStakeUnits);  function getFutureTotalStakeUnits(uint256 timestamp)     external     view     returns (uint256 totalStakeUnits);  /* pure functions */  function calculateTotalStakeUnits(StakeData[] memory stakes, uint256 timestamp)     external     pure     returns (uint256 totalStakeUnits);  function calculateStakeUnits(     uint256 amount,     uint256 start,     uint256 end ) external pure returns (uint256 stakeUnits);  function calculateUnlockedRewards(     RewardSchedule[] memory rewardSchedules,     uint256 rewardBalance,     uint256 sharesOutstanding,     uint256 timestamp ) external pure returns (uint256 unlockedRewards);  function calculateRewardFromStakes(     StakeData[] memory stakes,     uint256 unstakeAmount,     uint256 unlockedRewards,     uint256 totalStakeUnits,     uint256 timestamp,     RewardScaling memory rewardScaling ) external pure returns (RewardOutput memory out);  function calculateReward(     uint256 unlockedRewards,     uint256 stakeAmount,     uint256 stakeDuration,     uint256 totalStakeUnits,     RewardScaling memory rewardScaling ) external pure returns (uint256 reward);  } /// @title Hypervisor /// @notice Reward distribution contract with time multiplier /// Access Control /// - Power controller: ///     Can power off / shutdown the Hypervisor ///     Can withdraw rewards from reward pool once shutdown /// - Proxy owner: ///     Can change arbitrary logic / state by upgrading the Hypervisor ///     Is unable to operate on user funds due to UniversalVault ///     Is unable to operate on reward pool funds when reward pool is offline / shutdown /// - Hypervisor admin: ///     Can add funds to the Hypervisor, register bonus tokens, and whitelist new vault factories ///     Is a subset of proxy owner permissions /// - User: ///     Can deposit / withdraw / ragequit /// Hypervisor State Machine /// - Online: ///     Hypervisor is operating normally, all functions are enabled /// - Offline: ///     Hypervisor is temporarely disabled for maintenance ///     User deposits and withdrawls are disabled, ragequit remains enabled ///     Users can withdraw their stake through rageQuit() but forego their pending reward ///     Should only be used when downtime required for an upgrade /// - Shutdown: ///     Hypervisor is permanently disabled ///     All functions are disabled with the exception of ragequit ///     Users can withdraw their stake through rageQuit() ///     Power controller can withdraw from the reward pool ///     Should only be used if Proxy Owner role is compromized contract Hypervisor is IHypervisor, Powered, Ownable {     using SafeMath for uint256;     using EnumerableSet for EnumerableSet.AddressSet; /* constants */  // An upper bound on the number of active stakes per vault is required to prevent // calls to rageQuit() from reverting. // With 30 stakes in a vault, ragequit costs 432811 gas which is conservatively lower // than the hardcoded limit of 500k gas on the vault. // This limit is configurable and could be increased in a future deployment. // Ultimately, to avoid a need for fixed upper bounds, the EVM would need to provide // an error code that allows for reliably catching out-of-gas errors on remote calls. uint256 public constant MAX_STAKES_PER_VAULT = 30; uint256 public constant MAX_REWARD_TOKENS = 50; uint256 public constant BASE_SHARES_PER_WEI = 1000000; uint256 public stakeLimit = 2500 ether;  /* storage */  HypervisorData private _hypervisor; mapping(address =&gt; VaultData) private _vaults; EnumerableSet.AddressSet private _bonusTokenSet; EnumerableSet.AddressSet private _vaultFactorySet;  /* initializer */  /// @notice Initizalize Hypervisor /// access control: only proxy constructor /// state machine: can only be called once /// state scope: set initialization variables /// token transfer: none /// @param ownerAddress address The admin address /// @param rewardPoolFactory address The factory to use for deploying the RewardPool /// @param powerSwitchFactory address The factory to use for deploying the PowerSwitch /// @param stakingToken address The address of the staking token for this Hypervisor /// @param rewardToken address The address of the reward token for this Hypervisor /// @param rewardScaling RewardScaling The config for reward scaling floor, ceiling, and time constructor(     address ownerAddress,     address rewardPoolFactory,     address powerSwitchFactory,     address stakingToken,     address rewardToken,     RewardScaling memory rewardScaling,     uint256 _stakeLimit ) {     // the scaling floor must be smaller than ceiling     require(rewardScaling.floor &lt;= rewardScaling.ceiling, ""Hypervisor: floor above ceiling"");      // setting rewardScalingTime to 0 would cause divide by zero error     // to disable reward scaling, use rewardScalingFloor == rewardScalingCeiling     require(rewardScaling.time != 0, ""Hypervisor: scaling time cannot be zero"");      // deploy power switch     address powerSwitch = IFactory(powerSwitchFactory).create(abi.encode(ownerAddress));      // deploy reward pool     address rewardPool = IFactory(rewardPoolFactory).create(abi.encode(powerSwitch));      // set internal configs     Ownable.transferOwnership(ownerAddress);     Powered._setPowerSwitch(powerSwitch);      // commit to storage     _hypervisor.stakingToken = stakingToken;     _hypervisor.rewardToken = rewardToken;     _hypervisor.rewardPool = rewardPool;     _hypervisor.rewardScaling = rewardScaling;      stakeLimit = _stakeLimit;      // emit event     emit HypervisorCreated(rewardPool, powerSwitch); }  /* getter functions */  function getBonusTokenSetLength() external view override returns (uint256 length) {     return _bonusTokenSet.length(); }  function getBonusTokenAtIndex(uint256 index)     external     view     override     returns (address bonusToken) {     return _bonusTokenSet.at(index); }  function getVaultFactorySetLength() external view override returns (uint256 length) {     return _vaultFactorySet.length(); }  function getVaultFactoryAtIndex(uint256 index)     external     view     override     returns (address factory) {     return _vaultFactorySet.at(index); }  function isValidVault(address target) public view override returns (bool validity) {     // validate target is created from whitelisted vault factory     for (uint256 index = 0; index &lt; _vaultFactorySet.length(); index++) {         if (IInstanceRegistry(_vaultFactorySet.at(index)).isInstance(target)) {             return true;         }     }     // explicit return     return false; }  function isValidAddress(address target) public view override returns (bool validity) {     // sanity check target for potential input errors     return         target != address(this) &amp;&amp;         target != address(0) &amp;&amp;         target != _hypervisor.stakingToken &amp;&amp;         target != _hypervisor.rewardToken &amp;&amp;         target != _hypervisor.rewardPool &amp;&amp;         !_bonusTokenSet.contains(target); }  /* Hypervisor getters */  function getHypervisorData() external view override returns (HypervisorData memory hypervisor) {     return _hypervisor; }  function getCurrentUnlockedRewards() public view override returns (uint256 unlockedRewards) {     // calculate reward available based on state     return getFutureUnlockedRewards(block.timestamp); }  function getFutureUnlockedRewards(uint256 timestamp)     public     view     override     returns (uint256 unlockedRewards) {     // get reward amount remaining     uint256 remainingRewards = IERC20(_hypervisor.rewardToken).balanceOf(_hypervisor.rewardPool);     // calculate reward available based on state     unlockedRewards = calculateUnlockedRewards(         _hypervisor.rewardSchedules,         remainingRewards,         _hypervisor.rewardSharesOutstanding,         timestamp     );     // explicit return     return unlockedRewards; }  function getCurrentTotalStakeUnits() public view override returns (uint256 totalStakeUnits) {     // calculate new stake units     return getFutureTotalStakeUnits(block.timestamp); }  function getFutureTotalStakeUnits(uint256 timestamp)     public     view     override     returns (uint256 totalStakeUnits) {     // return early if no change     if (timestamp == _hypervisor.lastUpdate) return _hypervisor.totalStakeUnits;     // calculate new stake units     uint256 newStakeUnits =         calculateStakeUnits(_hypervisor.totalStake, _hypervisor.lastUpdate, timestamp);     // add to cached total     totalStakeUnits = _hypervisor.totalStakeUnits.add(newStakeUnits);     // explicit return     return totalStakeUnits; }  /* vault getters */  function getVaultData(address vault)     external     view     override     returns (VaultData memory vaultData) {     return _vaults[vault]; }  function getCurrentVaultReward(address vault) external view override returns (uint256 reward) {     // calculate rewards     return         calculateRewardFromStakes(             _vaults[vault]                 .stakes,             _vaults[vault]                 .totalStake,             getCurrentUnlockedRewards(),             getCurrentTotalStakeUnits(),             block                 .timestamp,             _hypervisor                 .rewardScaling         )             .reward; }  function getFutureVaultReward(address vault, uint256 timestamp)     external     view     override     returns (uint256 reward) {     // calculate rewards     return         calculateRewardFromStakes(             _vaults[vault]                 .stakes,             _vaults[vault]                 .totalStake,             getFutureUnlockedRewards(timestamp),             getFutureTotalStakeUnits(timestamp),             timestamp,             _hypervisor                 .rewardScaling         )             .reward; }  function getCurrentStakeReward(address vault, uint256 stakeAmount)     external     view     override     returns (uint256 reward) {     // calculate rewards     return         calculateRewardFromStakes(             _vaults[vault]                 .stakes,             stakeAmount,             getCurrentUnlockedRewards(),             getCurrentTotalStakeUnits(),             block                 .timestamp,             _hypervisor                 .rewardScaling         )             .reward; }  function getFutureStakeReward(     address vault,     uint256 stakeAmount,     uint256 timestamp ) external view override returns (uint256 reward) {     // calculate rewards     return         calculateRewardFromStakes(             _vaults[vault]                 .stakes,             stakeAmount,             getFutureUnlockedRewards(timestamp),             getFutureTotalStakeUnits(timestamp),             timestamp,             _hypervisor                 .rewardScaling         )             .reward; }  function getCurrentVaultStakeUnits(address vault)     public     view     override     returns (uint256 stakeUnits) {     // calculate stake units     return getFutureVaultStakeUnits(vault, block.timestamp); }  function getFutureVaultStakeUnits(address vault, uint256 timestamp)     public     view     override     returns (uint256 stakeUnits) {     // calculate stake units     return calculateTotalStakeUnits(_vaults[vault].stakes, timestamp); }  /* pure functions */  function calculateTotalStakeUnits(StakeData[] memory stakes, uint256 timestamp)     public     pure     override     returns (uint256 totalStakeUnits) {     for (uint256 index; index &lt; stakes.length; index++) {         // reference stake         StakeData memory stakeData = stakes[index];         // calculate stake units         uint256 stakeUnits =             calculateStakeUnits(stakeData.amount, stakeData.timestamp, timestamp);         // add to running total         totalStakeUnits = totalStakeUnits.add(stakeUnits);     } }  function calculateStakeUnits(     uint256 amount,     uint256 start,     uint256 end ) public pure override returns (uint256 stakeUnits) {     // calculate duration     uint256 duration = end.sub(start);     // calculate stake units     stakeUnits = duration.mul(amount);     // explicit return     return stakeUnits; }  function calculateUnlockedRewards(     RewardSchedule[] memory rewardSchedules,     uint256 rewardBalance,     uint256 sharesOutstanding,     uint256 timestamp ) public pure override returns (uint256 unlockedRewards) {     // return 0 if no registered schedules     if (rewardSchedules.length == 0) {         return 0;     }      // calculate reward shares locked across all reward schedules     uint256 sharesLocked;     for (uint256 index = 0; index &lt; rewardSchedules.length; index++) {         // fetch reward schedule storage reference         RewardSchedule memory schedule = rewardSchedules[index];          // caculate amount of shares available on this schedule         // if (now - start) &lt; duration         //   sharesLocked = shares - (shares * (now - start) / duration)         // else         //   sharesLocked = 0         uint256 currentSharesLocked = 0;         if (timestamp.sub(schedule.start) &lt; schedule.duration) {             currentSharesLocked = schedule.shares.sub(                 schedule.shares.mul(timestamp.sub(schedule.start)).div(schedule.duration)             );         }          // add to running total         sharesLocked = sharesLocked.add(currentSharesLocked);     }      // convert shares to reward     // rewardLocked = sharesLocked * rewardBalance / sharesOutstanding     uint256 rewardLocked = sharesLocked.mul(rewardBalance).div(sharesOutstanding);      // calculate amount available     // unlockedRewards = rewardBalance - rewardLocked     unlockedRewards = rewardBalance.sub(rewardLocked);      // explicit return     return unlockedRewards; }  function calculateRewardFromStakes(     StakeData[] memory stakes,     uint256 unstakeAmount,     uint256 unlockedRewards,     uint256 totalStakeUnits,     uint256 timestamp,     RewardScaling memory rewardScaling ) public pure override returns (RewardOutput memory out) {     uint256 stakesToDrop = 0;     while (unstakeAmount &gt; 0) {         // fetch vault stake storage reference         StakeData memory lastStake = stakes[stakes.length.sub(stakesToDrop).sub(1)];          // calculate stake duration         uint256 stakeDuration = timestamp.sub(lastStake.timestamp);          uint256 currentAmount;         if (lastStake.amount &gt; unstakeAmount) {             // set current amount to remaining unstake amount             currentAmount = unstakeAmount;             // amount of last stake is reduced             out.lastStakeAmount = lastStake.amount.sub(unstakeAmount);         } else {             // set current amount to amount of last stake             currentAmount = lastStake.amount;             // add to stakes to drop             stakesToDrop += 1;         }          // update remaining unstakeAmount         unstakeAmount = unstakeAmount.sub(currentAmount);          // calculate reward amount         uint256 currentReward =             calculateReward(                 unlockedRewards,                 currentAmount,                 stakeDuration,                 totalStakeUnits,                 rewardScaling             );          // update cumulative reward         out.reward = out.reward.add(currentReward);          // update cached unlockedRewards         unlockedRewards = unlockedRewards.sub(currentReward);          // calculate time weighted stake         uint256 stakeUnits = currentAmount.mul(stakeDuration);          // update cached totalStakeUnits         totalStakeUnits = totalStakeUnits.sub(stakeUnits);     }      // explicit return     return         RewardOutput(             out.lastStakeAmount,             stakes.length.sub(stakesToDrop),             out.reward,             totalStakeUnits         ); }  function calculateReward(     uint256 unlockedRewards,     uint256 stakeAmount,     uint256 stakeDuration,     uint256 totalStakeUnits,     RewardScaling memory rewardScaling ) public pure override returns (uint256 reward) {     // calculate time weighted stake     uint256 stakeUnits = stakeAmount.mul(stakeDuration);      // calculate base reward     // baseReward = unlockedRewards * stakeUnits / totalStakeUnits     uint256 baseReward = 0;     if (totalStakeUnits != 0) {         // scale reward according to proportional weight         baseReward = unlockedRewards.mul(stakeUnits).div(totalStakeUnits);     }      // calculate scaled reward     // if no scaling or scaling period completed     //   reward = baseReward     // else     //   minReward = baseReward * scalingFloor / scalingCeiling     //   bonusReward = baseReward     //                 * (scalingCeiling - scalingFloor) / scalingCeiling     //                 * duration / scalingTime     //   reward = minReward + bonusReward     if (stakeDuration &gt;= rewardScaling.time || rewardScaling.floor == rewardScaling.ceiling) {         // no reward scaling applied         reward = baseReward;     } else {         // calculate minimum reward using scaling floor         uint256 minReward = baseReward.mul(rewardScaling.floor).div(rewardScaling.ceiling);          // calculate bonus reward with vested portion of scaling factor         uint256 bonusReward =             baseReward                 .mul(stakeDuration)                 .mul(rewardScaling.ceiling.sub(rewardScaling.floor))                 .div(rewardScaling.ceiling)                 .div(rewardScaling.time);          // add minimum reward and bonus reward         reward = minReward.add(bonusReward);     }      // explicit return     return reward; }  /* admin functions */  /// @notice Add funds to the Hypervisor /// access control: only admin /// state machine: ///   - can be called multiple times ///   - only online /// state scope: ///   - increase _hypervisor.rewardSharesOutstanding ///   - append to _hypervisor.rewardSchedules /// token transfer: transfer staking tokens from msg.sender to reward pool /// @param amount uint256 Amount of reward tokens to deposit /// @param duration uint256 Duration over which to linearly unlock rewards function fund(uint256 amount, uint256 duration) external onlyOwner onlyOnline {     // validate duration     require(duration != 0, ""Hypervisor: invalid duration"");      // create new reward shares     // if existing rewards on this Hypervisor     //   mint new shares proportional to % change in rewards remaining     //   newShares = remainingShares * newReward / remainingRewards     // else     //   mint new shares with BASE_SHARES_PER_WEI initial conversion rate     //   store as fixed point number with same  of decimals as reward token     uint256 newRewardShares;     if (_hypervisor.rewardSharesOutstanding &gt; 0) {         uint256 remainingRewards = IERC20(_hypervisor.rewardToken).balanceOf(_hypervisor.rewardPool);         newRewardShares = _hypervisor.rewardSharesOutstanding.mul(amount).div(remainingRewards);     } else {         newRewardShares = amount.mul(BASE_SHARES_PER_WEI);     }      // add reward shares to total     _hypervisor.rewardSharesOutstanding = _hypervisor.rewardSharesOutstanding.add(newRewardShares);      // store new reward schedule     _hypervisor.rewardSchedules.push(RewardSchedule(duration, block.timestamp, newRewardShares));      // transfer reward tokens to reward pool     TransferHelper.safeTransferFrom(         _hypervisor.rewardToken,         msg.sender,         _hypervisor.rewardPool,         amount     );      // emit event     emit HypervisorFunded(amount, duration); }  /// @notice Add vault factory to whitelist /// @dev use this function to enable stakes to vaults coming from the specified ///      factory contract /// access control: only admin /// state machine: ///   - can be called multiple times ///   - not shutdown /// state scope: ///   - append to _vaultFactorySet /// token transfer: none /// @param factory address The address of the vault factory function registerVaultFactory(address factory) external onlyOwner notShutdown {     // add factory to set     require(_vaultFactorySet.add(factory), ""Hypervisor: vault factory already registered"");      // emit event     emit VaultFactoryRegistered(factory); }  /// @notice Remove vault factory from whitelist /// @dev use this function to disable new stakes to vaults coming from the specified ///      factory contract. ///      note: vaults with existing stakes from this factory are sill able to unstake /// access control: only admin /// state machine: ///   - can be called multiple times ///   - not shutdown /// state scope: ///   - remove from _vaultFactorySet /// token transfer: none /// @param factory address The address of the vault factory function removeVaultFactory(address factory) external onlyOwner notShutdown {     // remove factory from set     require(_vaultFactorySet.remove(factory), ""Hypervisor: vault factory not registered"");      // emit event     emit VaultFactoryRemoved(factory); }  /// @notice Register bonus token for distribution /// @dev use this function to enable distribution of any ERC20 held by the RewardPool contract /// access control: only admin /// state machine: ///   - can be called multiple times ///   - only online /// state scope: ///   - append to _bonusTokenSet /// token transfer: none /// @param bonusToken address The address of the bonus token function registerBonusToken(address bonusToken) external onlyOwner onlyOnline {     // verify valid bonus token     _validateAddress(bonusToken);      // verify bonus token count     require(_bonusTokenSet.length() &lt; MAX_REWARD_TOKENS, ""Hypervisor: max bonus tokens reached "");      // add token to set     assert(_bonusTokenSet.add(bonusToken));      // emit event     emit BonusTokenRegistered(bonusToken); }  /// @notice Rescue tokens from RewardPool /// @dev use this function to rescue tokens from RewardPool contract ///      without distributing to stakers or triggering emergency shutdown /// access control: only admin /// state machine: ///   - can be called multiple times ///   - only online /// state scope: none /// token transfer: transfer requested token from RewardPool to recipient /// @param token address The address of the token to rescue /// @param recipient address The address of the recipient /// @param amount uint256 The amount of tokens to rescue function rescueTokensFromRewardPool(     address token,     address recipient,     uint256 amount ) external onlyOwner onlyOnline {     // verify recipient     _validateAddress(recipient);      // check not attempting to unstake reward token     require(token != _hypervisor.rewardToken, ""Hypervisor: invalid address"");      // check not attempting to wthdraw bonus token     require(!_bonusTokenSet.contains(token), ""Hypervisor: invalid address"");      // transfer tokens to recipient     IRewardPool(_hypervisor.rewardPool).sendERC20(token, recipient, amount); }  /* user functions */  /// @notice Stake tokens /// @dev anyone can stake to any vault if they have valid permission /// access control: anyone /// state machine: ///   - can be called multiple times ///   - only online ///   - when vault exists on this Hypervisor /// state scope: ///   - append to _vaults[vault].stakes ///   - increase _vaults[vault].totalStake ///   - increase _hypervisor.totalStake ///   - increase _hypervisor.totalStakeUnits ///   - increase _hypervisor.lastUpdate /// token transfer: transfer staking tokens from msg.sender to vault /// @param vault address The address of the vault to stake from /// @param amount uint256 The amount of staking tokens to stake function stake(     address vault,     uint256 amount,     bytes calldata permission ) external override onlyOnline {     // verify vault is valid     require(isValidVault(vault), ""Hypervisor: vault is not registered"");      // verify non-zero amount     require(amount != 0, ""Hypervisor: no amount staked"");      // fetch vault storage reference     VaultData storage vaultData = _vaults[vault];      // verify stakes boundary not reached     require(         vaultData.stakes.length &lt; MAX_STAKES_PER_VAULT,         ""Hypervisor: MAX_STAKES_PER_VAULT reached""     );      // update cached sum of stake units across all vaults     _updateTotalStakeUnits();      // store amount and timestamp     vaultData.stakes.push(StakeData(amount, block.timestamp));      // update cached total vault and Hypervisor amounts     vaultData.totalStake = vaultData.totalStake.add(amount);     // verify stake quantity without bounds     require(         stakeLimit == 0 || vaultData.totalStake &lt;= stakeLimit,         ""Hypervisor: Stake limit exceeded""     );     _hypervisor.totalStake = _hypervisor.totalStake.add(amount);      // call lock on vault     IUniversalVault(vault).lock(_hypervisor.stakingToken, amount, permission);      // emit event     emit Staked(vault, amount); }  /// @notice Unstake staking tokens and claim reward /// @dev rewards can only be claimed when unstaking /// access control: only owner of vault /// state machine: ///   - when vault exists on this Hypervisor ///   - after stake from vault ///   - can be called multiple times while sufficient stake remains ///   - only online /// state scope: ///   - decrease _hypervisor.rewardSharesOutstanding ///   - decrease _hypervisor.totalStake ///   - increase _hypervisor.lastUpdate ///   - modify _hypervisor.totalStakeUnits ///   - modify _vaults[vault].stakes ///   - decrease _vaults[vault].totalStake /// token transfer: ///   - transfer reward tokens from reward pool to recipient ///   - transfer bonus tokens from reward pool to recipient /// @param vault address The vault to unstake from /// @param amount uint256 The amount of staking tokens to unstake function unstakeAndClaim(     address vault,     uint256 amount,     bytes calldata permission ) external override onlyOnline {     // fetch vault storage reference     VaultData storage vaultData = _vaults[vault];      // verify non-zero amount     require(amount != 0, ""Hypervisor: no amount unstaked"");      address recipient = IUniversalVault(vault).owner();      // validate recipient     _validateAddress(recipient);      // check for sufficient vault stake amount     require(vaultData.totalStake &gt;= amount, ""Hypervisor: insufficient vault stake"");      // check for sufficient Hypervisor stake amount     // if this check fails, there is a bug in stake accounting     assert(_hypervisor.totalStake &gt;= amount);      // update cached sum of stake units across all vaults     _updateTotalStakeUnits();      // get reward amount remaining     uint256 remainingRewards = IERC20(_hypervisor.rewardToken).balanceOf(_hypervisor.rewardPool);      // calculate vested portion of reward pool     uint256 unlockedRewards =         calculateUnlockedRewards(             _hypervisor.rewardSchedules,             remainingRewards,             _hypervisor.rewardSharesOutstanding,             block.timestamp         );      // calculate vault time weighted reward with scaling     RewardOutput memory out =         calculateRewardFromStakes(             vaultData.stakes,             amount,             unlockedRewards,             _hypervisor.totalStakeUnits,             block.timestamp,             _hypervisor.rewardScaling         );      // update stake data in storage     if (out.newStakesCount == 0) {         // all stakes have been unstaked         delete vaultData.stakes;     } else {         // some stakes have been completely or partially unstaked         // delete fully unstaked stakes         while (vaultData.stakes.length &gt; out.newStakesCount) vaultData.stakes.pop();         // update partially unstaked stake         vaultData.stakes[out.newStakesCount.sub(1)].amount = out.lastStakeAmount;     }      // update cached stake totals     vaultData.totalStake = vaultData.totalStake.sub(amount);     _hypervisor.totalStake = _hypervisor.totalStake.sub(amount);     _hypervisor.totalStakeUnits = out.newTotalStakeUnits;      // unlock staking tokens from vault     IUniversalVault(vault).unlock(_hypervisor.stakingToken, amount, permission);      // emit event     emit Unstaked(vault, amount);      // only perform on non-zero reward     if (out.reward &gt; 0) {         // calculate shares to burn         // sharesToBurn = sharesOutstanding * reward / remainingRewards         uint256 sharesToBurn =             _hypervisor.rewardSharesOutstanding.mul(out.reward).div(remainingRewards);          // burn claimed shares         _hypervisor.rewardSharesOutstanding = _hypervisor.rewardSharesOutstanding.sub(sharesToBurn);          // transfer bonus tokens from reward pool to recipient         if (_bonusTokenSet.length() &gt; 0) {             for (uint256 index = 0; index &lt; _bonusTokenSet.length(); index++) {                 // fetch bonus token address reference                 address bonusToken = _bonusTokenSet.at(index);                  // calculate bonus token amount                 // bonusAmount = bonusRemaining * reward / remainingRewards                 uint256 bonusAmount =                     IERC20(bonusToken).balanceOf(_hypervisor.rewardPool).mul(out.reward).div(                         remainingRewards                     );                  // transfer bonus token                 IRewardPool(_hypervisor.rewardPool).sendERC20(bonusToken, recipient, bonusAmount);                  // emit event                 emit RewardClaimed(vault, recipient, bonusToken, bonusAmount);             }         }          // transfer reward tokens from reward pool to recipient         IRewardPool(_hypervisor.rewardPool).sendERC20(_hypervisor.rewardToken, recipient, out.reward);          // emit event         emit RewardClaimed(vault, recipient, _hypervisor.rewardToken, out.reward);     } }  /// @notice Exit Hypervisor without claiming reward /// @dev This function should never revert when correctly called by the vault. ///      A max number of stakes per vault is set with MAX_STAKES_PER_VAULT to ///      place an upper bound on the for loop in calculateTotalStakeUnits(). /// access control: only callable by the vault directly /// state machine: ///   - when vault exists on this Hypervisor ///   - when active stake from this vault ///   - any power state /// state scope: ///   - decrease _hypervisor.totalStake ///   - increase _hypervisor.lastUpdate ///   - modify _hypervisor.totalStakeUnits ///   - delete _vaults[vault] /// token transfer: none function rageQuit() external override {     // fetch vault storage reference     VaultData storage _vaultData = _vaults[msg.sender];      // revert if no active stakes     require(_vaultData.stakes.length != 0, ""Hypervisor: no stake"");      // update cached sum of stake units across all vaults     _updateTotalStakeUnits();      // emit event     emit Unstaked(msg.sender, _vaultData.totalStake);      // update cached totals     _hypervisor.totalStake = _hypervisor.totalStake.sub(_vaultData.totalStake);     _hypervisor.totalStakeUnits = _hypervisor.totalStakeUnits.sub(         calculateTotalStakeUnits(_vaultData.stakes, block.timestamp)     );      // delete stake data     delete _vaults[msg.sender]; }  /* convenience functions */  function _updateTotalStakeUnits() private {     // update cached totalStakeUnits     _hypervisor.totalStakeUnits = getCurrentTotalStakeUnits();     // update cached lastUpdate     _hypervisor.lastUpdate = block.timestamp; }  function _validateAddress(address target) private view {     // sanity check target for potential input errors     require(isValidAddress(target), ""Hypervisor: invalid address""); }  function _truncateStakesArray(StakeData[] memory array, uint256 newLength)     private     pure     returns (StakeData[] memory newArray) {     newArray = new StakeData[](newLength);     for (uint256 index = 0; index &lt; newLength; index++) {         newArray[index] = array[index];     }     return newArray; }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-02-08 00:43:45 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: GPL-3.0-only
pragma solidity 0.7.6;
pragma abicoder v2;

import {SafeMath} from ""@openzeppelin/contracts/math/SafeMath.sol"";
import {EnumerableSet} from ""@openzeppelin/contracts/utils/EnumerableSet.sol"";
import {IERC20} from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import {Ownable} from ""@openzeppelin/contracts/access/Ownable.sol"";
import {TransferHelper} from ""@uniswap/lib/contracts/libraries/TransferHelper.sol"";

import {IFactory} from ""../factory/IFactory.sol"";
import {IInstanceRegistry} from ""../factory/InstanceRegistry.sol"";
import {IUniversalVault} from ""../visor/Visor.sol"";
import {IRewardPool} from ""./RewardPool.sol"";
import {Powered} from ""./Powered.sol"";

interface IRageQuit {
    function rageQuit() external;
}

interface IHypervisor is IRageQuit {
    /* admin events */

    event HypervisorCreated(address rewardPool, address powerSwitch);
    event HypervisorFunded(uint256 amount, uint256 duration);
    event BonusTokenRegistered(address token);
    event VaultFactoryRegistered(address factory);
    event VaultFactoryRemoved(address factory);

    /* user events */

    event Staked(address vault, uint256 amount);
    event Unstaked(address vault, uint256 amount);
    event RewardClaimed(address vault, address recipient, address token, uint256 amount);

    /* data types */

    struct HypervisorData {
        address stakingToken;
        address rewardToken;
        address rewardPool;
        RewardScaling rewardScaling;
        uint256 rewardSharesOutstanding;
        uint256 totalStake;
        uint256 totalStakeUnits;
        uint256 lastUpdate;
        RewardSchedule[] rewardSchedules;
    }

    struct RewardSchedule {
        uint256 duration;
        uint256 start;
        uint256 shares;
    }

    struct VaultData {
        uint256 totalStake;
        StakeData[] stakes;
    }

    struct StakeData {
        uint256 amount;
        uint256 timestamp;
    }

    struct RewardScaling {
        uint256 floor;
        uint256 ceiling;
        uint256 time;
    }

    struct RewardOutput {
        uint256 lastStakeAmount;
        uint256 newStakesCount;
        uint256 reward;
        uint256 newTotalStakeUnits;
    }

    /* user functions */

    function stake(
        address vault,
        uint256 amount,
        bytes calldata permission
    ) external;

    function unstakeAndClaim(
        address vault,
        uint256 amount,
        bytes calldata permission
    ) external;

    /* getter functions */

    function getHypervisorData() external view returns (HypervisorData memory hypervisor);

    function getBonusTokenSetLength() external view returns (uint256 length);

    function getBonusTokenAtIndex(uint256 index) external view returns (address bonusToken);

    function getVaultFactorySetLength() external view returns (uint256 length);

    function getVaultFactoryAtIndex(uint256 index) external view returns (address factory);

    function getVaultData(address vault) external view returns (VaultData memory vaultData);

    function isValidAddress(address target) external view returns (bool validity);

    function isValidVault(address target) external view returns (bool validity);

    function getCurrentUnlockedRewards() external view returns (uint256 unlockedRewards);

    function getFutureUnlockedRewards(uint256 timestamp)
        external
        view
        returns (uint256 unlockedRewards);

    function getCurrentVaultReward(address vault) external view returns (uint256 reward);

    function getCurrentStakeReward(address vault, uint256 stakeAmount)
        external
        view
        returns (uint256 reward);

    function getFutureVaultReward(address vault, uint256 timestamp)
        external
        view
        returns (uint256 reward);

    function getFutureStakeReward(
        address vault,
        uint256 stakeAmount,
        uint256 timestamp
    ) external view returns (uint256 reward);

    function getCurrentVaultStakeUnits(address vault) external view returns (uint256 stakeUnits);

    function getFutureVaultStakeUnits(address vault, uint256 timestamp)
        external
        view
        returns (uint256 stakeUnits);

    function getCurrentTotalStakeUnits() external view returns (uint256 totalStakeUnits);

    function getFutureTotalStakeUnits(uint256 timestamp)
        external
        view
        returns (uint256 totalStakeUnits);

    /* pure functions */

    function calculateTotalStakeUnits(StakeData[] memory stakes, uint256 timestamp)
        external
        pure
        returns (uint256 totalStakeUnits);

    function calculateStakeUnits(
        uint256 amount,
        uint256 start,
        uint256 end
    ) external pure returns (uint256 stakeUnits);

    function calculateUnlockedRewards(
        RewardSchedule[] memory rewardSchedules,
        uint256 rewardBalance,
        uint256 sharesOutstanding,
        uint256 timestamp
    ) external pure returns (uint256 unlockedRewards);

    function calculateRewardFromStakes(
        StakeData[] memory stakes,
        uint256 unstakeAmount,
        uint256 unlockedRewards,
        uint256 totalStakeUnits,
        uint256 timestamp,
        RewardScaling memory rewardScaling
    ) external pure returns (RewardOutput memory out);

    function calculateReward(
        uint256 unlockedRewards,
        uint256 stakeAmount,
        uint256 stakeDuration,
        uint256 totalStakeUnits,
        RewardScaling memory rewardScaling
    ) external pure returns (uint256 reward);
}

/// @title Hypervisor
/// @notice Reward distribution contract with time multiplier
/// Access Control
/// - Power controller:
///     Can power off / shutdown the Hypervisor
///     Can withdraw rewards from reward pool once shutdown
/// - Proxy owner:
///     Can change arbitrary logic / state by upgrading the Hypervisor
///     Is unable to operate on user funds due to UniversalVault
///     Is unable to operate on reward pool funds when reward pool is offline / shutdown
/// - Hypervisor admin:
///     Can add funds to the Hypervisor, register bonus tokens, and whitelist new vault factories
///     Is a subset of proxy owner permissions
/// - User:
///     Can deposit / withdraw / ragequit
/// Hypervisor State Machine
/// - Online:
///     Hypervisor is operating normally, all functions are enabled
/// - Offline:
///     Hypervisor is temporarely disabled for maintenance
///     User deposits and withdrawls are disabled, ragequit remains enabled
///     Users can withdraw their stake through rageQuit() but forego their pending reward
///     Should only be used when downtime required for an upgrade
/// - Shutdown:
///     Hypervisor is permanently disabled
///     All functions are disabled with the exception of ragequit
///     Users can withdraw their stake through rageQuit()
///     Power controller can withdraw from the reward pool
///     Should only be used if Proxy Owner role is compromized
contract Hypervisor is IHypervisor, Powered, Ownable {
    using SafeMath for uint256;
    using EnumerableSet for EnumerableSet.AddressSet;

    /* constants */

    // An upper bound on the number of active stakes per vault is required to prevent
    // calls to rageQuit() from reverting.
    // With 30 stakes in a vault, ragequit costs 432811 gas which is conservatively lower
    // than the hardcoded limit of 500k gas on the vault.
    // This limit is configurable and could be increased in a future deployment.
    // Ultimately, to avoid a need for fixed upper bounds, the EVM would need to provide
    // an error code that allows for reliably catching out-of-gas errors on remote calls.
    uint256 public constant MAX_STAKES_PER_VAULT = 30;
    uint256 public constant MAX_REWARD_TOKENS = 50;
    uint256 public constant BASE_SHARES_PER_WEI = 1000000;
    uint256 public stakeLimit = 2500 ether;

    /* storage */

    HypervisorData private _hypervisor;
    mapping(address => VaultData) private _vaults;
    EnumerableSet.AddressSet private _bonusTokenSet;
    EnumerableSet.AddressSet private _vaultFactorySet;

    /* initializer */

    /// @notice Initizalize Hypervisor
    /// access control: only proxy constructor
    /// state machine: can only be called once
    /// state scope: set initialization variables
    /// token transfer: none
    /// @param ownerAddress address The admin address
    /// @param rewardPoolFactory address The factory to use for deploying the RewardPool
    /// @param powerSwitchFactory address The factory to use for deploying the PowerSwitch
    /// @param stakingToken address The address of the staking token for this Hypervisor
    /// @param rewardToken address The address of the reward token for this Hypervisor
    /// @param rewardScaling RewardScaling The config for reward scaling floor, ceiling, and time
    constructor(
        address ownerAddress,
        address rewardPoolFactory,
        address powerSwitchFactory,
        address stakingToken,
        address rewardToken,
        RewardScaling memory rewardScaling,
        uint256 _stakeLimit
    ) {
        // the scaling floor must be smaller than ceiling
        require(rewardScaling.floor <= rewardScaling.ceiling, ""Hypervisor: floor above ceiling"");

        // setting rewardScalingTime to 0 would cause divide by zero error
        // to disable reward scaling, use rewardScalingFloor == rewardScalingCeiling
        require(rewardScaling.time != 0, ""Hypervisor: scaling time cannot be zero"");

        // deploy power switch
        address powerSwitch = IFactory(powerSwitchFactory).create(abi.encode(ownerAddress));

        // deploy reward pool
        address rewardPool = IFactory(rewardPoolFactory).create(abi.encode(powerSwitch));

        // set internal configs
        Ownable.transferOwnership(ownerAddress);
        Powered._setPowerSwitch(powerSwitch);

        // commit to storage
        _hypervisor.stakingToken = stakingToken;
        _hypervisor.rewardToken = rewardToken;
        _hypervisor.rewardPool = rewardPool;
        _hypervisor.rewardScaling = rewardScaling;

        stakeLimit = _stakeLimit;

        // emit event
        emit HypervisorCreated(rewardPool, powerSwitch);
    }

    /* getter functions */

    function getBonusTokenSetLength() external view override returns (uint256 length) {
        return _bonusTokenSet.length();
    }

    function getBonusTokenAtIndex(uint256 index)
        external
        view
        override
        returns (address bonusToken)
    {
        return _bonusTokenSet.at(index);
    }

    function getVaultFactorySetLength() external view override returns (uint256 length) {
        return _vaultFactorySet.length();
    }

    function getVaultFactoryAtIndex(uint256 index)
        external
        view
        override
        returns (address factory)
    {
        return _vaultFactorySet.at(index);
    }

    function isValidVault(address target) public view override returns (bool validity) {
        // validate target is created from whitelisted vault factory
        for (uint256 index = 0; index < _vaultFactorySet.length(); index++) {
            if (IInstanceRegistry(_vaultFactorySet.at(index)).isInstance(target)) {
                return true;
            }
        }
        // explicit return
        return false;
    }

    function isValidAddress(address target) public view override returns (bool validity) {
        // sanity check target for potential input errors
        return
            target != address(this) &&
            target != address(0) &&
            target != _hypervisor.stakingToken &&
            target != _hypervisor.rewardToken &&
            target != _hypervisor.rewardPool &&
            !_bonusTokenSet.contains(target);
    }

    /* Hypervisor getters */

    function getHypervisorData() external view override returns (HypervisorData memory hypervisor) {
        return _hypervisor;
    }

    function getCurrentUnlockedRewards() public view override returns (uint256 unlockedRewards) {
        // calculate reward available based on state
        return getFutureUnlockedRewards(block.timestamp);
    }

    function getFutureUnlockedRewards(uint256 timestamp)
        public
        view
        override
        returns (uint256 unlockedRewards)
    {
        // get reward amount remaining
        uint256 remainingRewards = IERC20(_hypervisor.rewardToken).balanceOf(_hypervisor.rewardPool);
        // calculate reward available based on state
        unlockedRewards = calculateUnlockedRewards(
            _hypervisor.rewardSchedules,
            remainingRewards,
            _hypervisor.rewardSharesOutstanding,
            timestamp
        );
        // explicit return
        return unlockedRewards;
    }

    function getCurrentTotalStakeUnits() public view override returns (uint256 totalStakeUnits) {
        // calculate new stake units
        return getFutureTotalStakeUnits(block.timestamp);
    }

    function getFutureTotalStakeUnits(uint256 timestamp)
        public
        view
        override
        returns (uint256 totalStakeUnits)
    {
        // return early if no change
        if (timestamp == _hypervisor.lastUpdate) return _hypervisor.totalStakeUnits;
        // calculate new stake units
        uint256 newStakeUnits =
            calculateStakeUnits(_hypervisor.totalStake, _hypervisor.lastUpdate, timestamp);
        // add to cached total
        totalStakeUnits = _hypervisor.totalStakeUnits.add(newStakeUnits);
        // explicit return
        return totalStakeUnits;
    }

    /* vault getters */

    function getVaultData(address vault)
        external
        view
        override
        returns (VaultData memory vaultData)
    {
        return _vaults[vault];
    }

    function getCurrentVaultReward(address vault) external view override returns (uint256 reward) {
        // calculate rewards
        return
            calculateRewardFromStakes(
                _vaults[vault]
                    .stakes,
                _vaults[vault]
                    .totalStake,
                getCurrentUnlockedRewards(),
                getCurrentTotalStakeUnits(),
                block
                    .timestamp,
                _hypervisor
                    .rewardScaling
            )
                .reward;
    }

    function getFutureVaultReward(address vault, uint256 timestamp)
        external
        view
        override
        returns (uint256 reward)
    {
        // calculate rewards
        return
            calculateRewardFromStakes(
                _vaults[vault]
                    .stakes,
                _vaults[vault]
                    .totalStake,
                getFutureUnlockedRewards(timestamp),
                getFutureTotalStakeUnits(timestamp),
                timestamp,
                _hypervisor
                    .rewardScaling
            )
                .reward;
    }

    function getCurrentStakeReward(address vault, uint256 stakeAmount)
        external
        view
        override
        returns (uint256 reward)
    {
        // calculate rewards
        return
            calculateRewardFromStakes(
                _vaults[vault]
                    .stakes,
                stakeAmount,
                getCurrentUnlockedRewards(),
                getCurrentTotalStakeUnits(),
                block
                    .timestamp,
                _hypervisor
                    .rewardScaling
            )
                .reward;
    }

    function getFutureStakeReward(
        address vault,
        uint256 stakeAmount,
        uint256 timestamp
    ) external view override returns (uint256 reward) {
        // calculate rewards
        return
            calculateRewardFromStakes(
                _vaults[vault]
                    .stakes,
                stakeAmount,
                getFutureUnlockedRewards(timestamp),
                getFutureTotalStakeUnits(timestamp),
                timestamp,
                _hypervisor
                    .rewardScaling
            )
                .reward;
    }

    function getCurrentVaultStakeUnits(address vault)
        public
        view
        override
        returns (uint256 stakeUnits)
    {
        // calculate stake units
        return getFutureVaultStakeUnits(vault, block.timestamp);
    }

    function getFutureVaultStakeUnits(address vault, uint256 timestamp)
        public
        view
        override
        returns (uint256 stakeUnits)
    {
        // calculate stake units
        return calculateTotalStakeUnits(_vaults[vault].stakes, timestamp);
    }

    /* pure functions */

    function calculateTotalStakeUnits(StakeData[] memory stakes, uint256 timestamp)
        public
        pure
        override
        returns (uint256 totalStakeUnits)
    {
        for (uint256 index; index < stakes.length; index++) {
            // reference stake
            StakeData memory stakeData = stakes[index];
            // calculate stake units
            uint256 stakeUnits =
                calculateStakeUnits(stakeData.amount, stakeData.timestamp, timestamp);
            // add to running total
            totalStakeUnits = totalStakeUnits.add(stakeUnits);
        }
    }

    function calculateStakeUnits(
        uint256 amount,
        uint256 start,
        uint256 end
    ) public pure override returns (uint256 stakeUnits) {
        // calculate duration
        uint256 duration = end.sub(start);
        // calculate stake units
        stakeUnits = duration.mul(amount);
        // explicit return
        return stakeUnits;
    }

    function calculateUnlockedRewards(
        RewardSchedule[] memory rewardSchedules,
        uint256 rewardBalance,
        uint256 sharesOutstanding,
        uint256 timestamp
    ) public pure override returns (uint256 unlockedRewards) {
        // return 0 if no registered schedules
        if (rewardSchedules.length == 0) {
            return 0;
        }

        // calculate reward shares locked across all reward schedules
        uint256 sharesLocked;
        for (uint256 index = 0; index < rewardSchedules.length; index++) {
            // fetch reward schedule storage reference
            RewardSchedule memory schedule = rewardSchedules[index];

            // caculate amount of shares available on this schedule
            // if (now - start) < duration
            //   sharesLocked = shares - (shares * (now - start) / duration)
            // else
            //   sharesLocked = 0
            uint256 currentSharesLocked = 0;
            if (timestamp.sub(schedule.start) < schedule.duration) {
                currentSharesLocked = schedule.shares.sub(
                    schedule.shares.mul(timestamp.sub(schedule.start)).div(schedule.duration)
                );
            }

            // add to running total
            sharesLocked = sharesLocked.add(currentSharesLocked);
        }

        // convert shares to reward
        // rewardLocked = sharesLocked * rewardBalance / sharesOutstanding
        uint256 rewardLocked = sharesLocked.mul(rewardBalance).div(sharesOutstanding);

        // calculate amount available
        // unlockedRewards = rewardBalance - rewardLocked
        unlockedRewards = rewardBalance.sub(rewardLocked);

        // explicit return
        return unlockedRewards;
    }

    function calculateRewardFromStakes(
        StakeData[] memory stakes,
        uint256 unstakeAmount,
        uint256 unlockedRewards,
        uint256 totalStakeUnits,
        uint256 timestamp,
        RewardScaling memory rewardScaling
    ) public pure override returns (RewardOutput memory out) {
        uint256 stakesToDrop = 0;
        while (unstakeAmount > 0) {
            // fetch vault stake storage reference
            StakeData memory lastStake = stakes[stakes.length.sub(stakesToDrop).sub(1)];

            // calculate stake duration
            uint256 stakeDuration = timestamp.sub(lastStake.timestamp);

            uint256 currentAmount;
            if (lastStake.amount > unstakeAmount) {
                // set current amount to remaining unstake amount
                currentAmount = unstakeAmount;
                // amount of last stake is reduced
                out.lastStakeAmount = lastStake.amount.sub(unstakeAmount);
            } else {
                // set current amount to amount of last stake
                currentAmount = lastStake.amount;
                // add to stakes to drop
                stakesToDrop += 1;
            }

            // update remaining unstakeAmount
            unstakeAmount = unstakeAmount.sub(currentAmount);

            // calculate reward amount
            uint256 currentReward =
                calculateReward(
                    unlockedRewards,
                    currentAmount,
                    stakeDuration,
                    totalStakeUnits,
                    rewardScaling
                );

            // update cumulative reward
            out.reward = out.reward.add(currentReward);

            // update cached unlockedRewards
            unlockedRewards = unlockedRewards.sub(currentReward);

            // calculate time weighted stake
            uint256 stakeUnits = currentAmount.mul(stakeDuration);

            // update cached totalStakeUnits
            totalStakeUnits = totalStakeUnits.sub(stakeUnits);
        }

        // explicit return
        return
            RewardOutput(
                out.lastStakeAmount,
                stakes.length.sub(stakesToDrop),
                out.reward,
                totalStakeUnits
            );
    }

    function calculateReward(
        uint256 unlockedRewards,
        uint256 stakeAmount,
        uint256 stakeDuration,
        uint256 totalStakeUnits,
        RewardScaling memory rewardScaling
    ) public pure override returns (uint256 reward) {
        // calculate time weighted stake
        uint256 stakeUnits = stakeAmount.mul(stakeDuration);

        // calculate base reward
        // baseReward = unlockedRewards * stakeUnits / totalStakeUnits
        uint256 baseReward = 0;
        if (totalStakeUnits != 0) {
            // scale reward according to proportional weight
            baseReward = unlockedRewards.mul(stakeUnits).div(totalStakeUnits);
        }

        // calculate scaled reward
        // if no scaling or scaling period completed
        //   reward = baseReward
        // else
        //   minReward = baseReward * scalingFloor / scalingCeiling
        //   bonusReward = baseReward
        //                 * (scalingCeiling - scalingFloor) / scalingCeiling
        //                 * duration / scalingTime
        //   reward = minReward + bonusReward
        if (stakeDuration >= rewardScaling.time || rewardScaling.floor == rewardScaling.ceiling) {
            // no reward scaling applied
            reward = baseReward;
        } else {
            // calculate minimum reward using scaling floor
            uint256 minReward = baseReward.mul(rewardScaling.floor).div(rewardScaling.ceiling);

            // calculate bonus reward with vested portion of scaling factor
            uint256 bonusReward =
                baseReward
                    .mul(stakeDuration)
                    .mul(rewardScaling.ceiling.sub(rewardScaling.floor))
                    .div(rewardScaling.ceiling)
                    .div(rewardScaling.time);

            // add minimum reward and bonus reward
            reward = minReward.add(bonusReward);
        }

        // explicit return
        return reward;
    }

    /* admin functions */

    /// @notice Add funds to the Hypervisor
    /// access control: only admin
    /// state machine:
    ///   - can be called multiple times
    ///   - only online
    /// state scope:
    ///   - increase _hypervisor.rewardSharesOutstanding
    ///   - append to _hypervisor.rewardSchedules
    /// token transfer: transfer staking tokens from msg.sender to reward pool
    /// @param amount uint256 Amount of reward tokens to deposit
    /// @param duration uint256 Duration over which to linearly unlock rewards
    function fund(uint256 amount, uint256 duration) external onlyOwner onlyOnline {
        // validate duration
        require(duration != 0, ""Hypervisor: invalid duration"");

        // create new reward shares
        // if existing rewards on this Hypervisor
        //   mint new shares proportional to % change in rewards remaining
        //   newShares = remainingShares * newReward / remainingRewards
        // else
        //   mint new shares with BASE_SHARES_PER_WEI initial conversion rate
        //   store as fixed point number with same  of decimals as reward token
        uint256 newRewardShares;
        if (_hypervisor.rewardSharesOutstanding > 0) {
            uint256 remainingRewards = IERC20(_hypervisor.rewardToken).balanceOf(_hypervisor.rewardPool);
            newRewardShares = _hypervisor.rewardSharesOutstanding.mul(amount).div(remainingRewards);
        } else {
            newRewardShares = amount.mul(BASE_SHARES_PER_WEI);
        }

        // add reward shares to total
        _hypervisor.rewardSharesOutstanding = _hypervisor.rewardSharesOutstanding.add(newRewardShares);

        // store new reward schedule
        _hypervisor.rewardSchedules.push(RewardSchedule(duration, block.timestamp, newRewardShares));

        // transfer reward tokens to reward pool
        TransferHelper.safeTransferFrom(
            _hypervisor.rewardToken,
            msg.sender,
            _hypervisor.rewardPool,
            amount
        );

        // emit event
        emit HypervisorFunded(amount, duration);
    }

    /// @notice Add vault factory to whitelist
    /// @dev use this function to enable stakes to vaults coming from the specified
    ///      factory contract
    /// access control: only admin
    /// state machine:
    ///   - can be called multiple times
    ///   - not shutdown
    /// state scope:
    ///   - append to _vaultFactorySet
    /// token transfer: none
    /// @param factory address The address of the vault factory
    function registerVaultFactory(address factory) external onlyOwner notShutdown {
        // add factory to set
        require(_vaultFactorySet.add(factory), ""Hypervisor: vault factory already registered"");

        // emit event
        emit VaultFactoryRegistered(factory);
    }

    /// @notice Remove vault factory from whitelist
    /// @dev use this function to disable new stakes to vaults coming from the specified
    ///      factory contract.
    ///      note: vaults with existing stakes from this factory are sill able to unstake
    /// access control: only admin
    /// state machine:
    ///   - can be called multiple times
    ///   - not shutdown
    /// state scope:
    ///   - remove from _vaultFactorySet
    /// token transfer: none
    /// @param factory address The address of the vault factory
    function removeVaultFactory(address factory) external onlyOwner notShutdown {
        // remove factory from set
        require(_vaultFactorySet.remove(factory), ""Hypervisor: vault factory not registered"");

        // emit event
        emit VaultFactoryRemoved(factory);
    }

    /// @notice Register bonus token for distribution
    /// @dev use this function to enable distribution of any ERC20 held by the RewardPool contract
    /// access control: only admin
    /// state machine:
    ///   - can be called multiple times
    ///   - only online
    /// state scope:
    ///   - append to _bonusTokenSet
    /// token transfer: none
    /// @param bonusToken address The address of the bonus token
    function registerBonusToken(address bonusToken) external onlyOwner onlyOnline {
        // verify valid bonus token
        _validateAddress(bonusToken);

        // verify bonus token count
        require(_bonusTokenSet.length() < MAX_REWARD_TOKENS, ""Hypervisor: max bonus tokens reached "");

        // add token to set
        assert(_bonusTokenSet.add(bonusToken));

        // emit event
        emit BonusTokenRegistered(bonusToken);
    }

    /// @notice Rescue tokens from RewardPool
    /// @dev use this function to rescue tokens from RewardPool contract
    ///      without distributing to stakers or triggering emergency shutdown
    /// access control: only admin
    /// state machine:
    ///   - can be called multiple times
    ///   - only online
    /// state scope: none
    /// token transfer: transfer requested token from RewardPool to recipient
    /// @param token address The address of the token to rescue
    /// @param recipient address The address of the recipient
    /// @param amount uint256 The amount of tokens to rescue
    function rescueTokensFromRewardPool(
        address token,
        address recipient,
        uint256 amount
    ) external onlyOwner onlyOnline {
        // verify recipient
        _validateAddress(recipient);

        // check not attempting to unstake reward token
        require(token != _hypervisor.rewardToken, ""Hypervisor: invalid address"");

        // check not attempting to wthdraw bonus token
        require(!_bonusTokenSet.contains(token), ""Hypervisor: invalid address"");

        // transfer tokens to recipient
        IRewardPool(_hypervisor.rewardPool).sendERC20(token, recipient, amount);
    }

    /* user functions */

    /// @notice Stake tokens
    /// @dev anyone can stake to any vault if they have valid permission
    /// access control: anyone
    /// state machine:
    ///   - can be called multiple times
    ///   - only online
    ///   - when vault exists on this Hypervisor
    /// state scope:
    ///   - append to _vaults[vault].stakes
    ///   - increase _vaults[vault].totalStake
    ///   - increase _hypervisor.totalStake
    ///   - increase _hypervisor.totalStakeUnits
    ///   - increase _hypervisor.lastUpdate
    /// token transfer: transfer staking tokens from msg.sender to vault
    /// @param vault address The address of the vault to stake from
    /// @param amount uint256 The amount of staking tokens to stake
    function stake(
        address vault,
        uint256 amount,
        bytes calldata permission
    ) external override onlyOnline {
        // verify vault is valid
        require(isValidVault(vault), ""Hypervisor: vault is not registered"");

        // verify non-zero amount
        require(amount != 0, ""Hypervisor: no amount staked"");

        // fetch vault storage reference
        VaultData storage vaultData = _vaults[vault];

        // verify stakes boundary not reached
        require(
            vaultData.stakes.length < MAX_STAKES_PER_VAULT,
            ""Hypervisor: MAX_STAKES_PER_VAULT reached""
        );

        // update cached sum of stake units across all vaults
        _updateTotalStakeUnits();

        // store amount and timestamp
        vaultData.stakes.push(StakeData(amount, block.timestamp));

        // update cached total vault and Hypervisor amounts
        vaultData.totalStake = vaultData.totalStake.add(amount);
        // verify stake quantity without bounds
        require(
            stakeLimit == 0 || vaultData.totalStake <= stakeLimit,
            ""Hypervisor: Stake limit exceeded""
        );
        _hypervisor.totalStake = _hypervisor.totalStake.add(amount);

        // call lock on vault
        IUniversalVault(vault).lock(_hypervisor.stakingToken, amount, permission);

        // emit event
        emit Staked(vault, amount);
    }

    /// @notice Unstake staking tokens and claim reward
    /// @dev rewards can only be claimed when unstaking
    /// access control: only owner of vault
    /// state machine:
    ///   - when vault exists on this Hypervisor
    ///   - after stake from vault
    ///   - can be called multiple times while sufficient stake remains
    ///   - only online
    /// state scope:
    ///   - decrease _hypervisor.rewardSharesOutstanding
    ///   - decrease _hypervisor.totalStake
    ///   - increase _hypervisor.lastUpdate
    ///   - modify _hypervisor.totalStakeUnits
    ///   - modify _vaults[vault].stakes
    ///   - decrease _vaults[vault].totalStake
    /// token transfer:
    ///   - transfer reward tokens from reward pool to recipient
    ///   - transfer bonus tokens from reward pool to recipient
    /// @param vault address The vault to unstake from
    /// @param amount uint256 The amount of staking tokens to unstake
    function unstakeAndClaim(
        address vault,
        uint256 amount,
        bytes calldata permission
    ) external override onlyOnline {
        // fetch vault storage reference
        VaultData storage vaultData = _vaults[vault];

        // verify non-zero amount
        require(amount != 0, ""Hypervisor: no amount unstaked"");

        address recipient = IUniversalVault(vault).owner();

        // validate recipient
        _validateAddress(recipient);

        // check for sufficient vault stake amount
        require(vaultData.totalStake >= amount, ""Hypervisor: insufficient vault stake"");

        // check for sufficient Hypervisor stake amount
        // if this check fails, there is a bug in stake accounting
        assert(_hypervisor.totalStake >= amount);

        // update cached sum of stake units across all vaults
        _updateTotalStakeUnits();

        // get reward amount remaining
        uint256 remainingRewards = IERC20(_hypervisor.rewardToken).balanceOf(_hypervisor.rewardPool);

        // calculate vested portion of reward pool
        uint256 unlockedRewards =
            calculateUnlockedRewards(
                _hypervisor.rewardSchedules,
                remainingRewards,
                _hypervisor.rewardSharesOutstanding,
                block.timestamp
            );

        // calculate vault time weighted reward with scaling
        RewardOutput memory out =
            calculateRewardFromStakes(
                vaultData.stakes,
                amount,
                unlockedRewards,
                _hypervisor.totalStakeUnits,
                block.timestamp,
                _hypervisor.rewardScaling
            );

        // update stake data in storage
        if (out.newStakesCount == 0) {
            // all stakes have been unstaked
            delete vaultData.stakes;
        } else {
            // some stakes have been completely or partially unstaked
            // delete fully unstaked stakes
            while (vaultData.stakes.length > out.newStakesCount) vaultData.stakes.pop();
            // update partially unstaked stake
            vaultData.stakes[out.newStakesCount.sub(1)].amount = out.lastStakeAmount;
        }

        // update cached stake totals
        vaultData.totalStake = vaultData.totalStake.sub(amount);
        _hypervisor.totalStake = _hypervisor.totalStake.sub(amount);
        _hypervisor.totalStakeUnits = out.newTotalStakeUnits;

        // unlock staking tokens from vault
        IUniversalVault(vault).unlock(_hypervisor.stakingToken, amount, permission);

        // emit event
        emit Unstaked(vault, amount);

        // only perform on non-zero reward
        if (out.reward > 0) {
            // calculate shares to burn
            // sharesToBurn = sharesOutstanding * reward / remainingRewards
            uint256 sharesToBurn =
                _hypervisor.rewardSharesOutstanding.mul(out.reward).div(remainingRewards);

            // burn claimed shares
            _hypervisor.rewardSharesOutstanding = _hypervisor.rewardSharesOutstanding.sub(sharesToBurn);

            // transfer bonus tokens from reward pool to recipient
            if (_bonusTokenSet.length() > 0) {
                for (uint256 index = 0; index < _bonusTokenSet.length(); index++) {
                    // fetch bonus token address reference
                    address bonusToken = _bonusTokenSet.at(index);

                    // calculate bonus token amount
                    // bonusAmount = bonusRemaining * reward / remainingRewards
                    uint256 bonusAmount =
                        IERC20(bonusToken).balanceOf(_hypervisor.rewardPool).mul(out.reward).div(
                            remainingRewards
                        );

                    // transfer bonus token
                    IRewardPool(_hypervisor.rewardPool).sendERC20(bonusToken, recipient, bonusAmount);

                    // emit event
                    emit RewardClaimed(vault, recipient, bonusToken, bonusAmount);
                }
            }

            // transfer reward tokens from reward pool to recipient
            IRewardPool(_hypervisor.rewardPool).sendERC20(_hypervisor.rewardToken, recipient, out.reward);

            // emit event
            emit RewardClaimed(vault, recipient, _hypervisor.rewardToken, out.reward);
        }
    }

    /// @notice Exit Hypervisor without claiming reward
    /// @dev This function should never revert when correctly called by the vault.
    ///      A max number of stakes per vault is set with MAX_STAKES_PER_VAULT to
    ///      place an upper bound on the for loop in calculateTotalStakeUnits().
    /// access control: only callable by the vault directly
    /// state machine:
    ///   - when vault exists on this Hypervisor
    ///   - when active stake from this vault
    ///   - any power state
    /// state scope:
    ///   - decrease _hypervisor.totalStake
    ///   - increase _hypervisor.lastUpdate
    ///   - modify _hypervisor.totalStakeUnits
    ///   - delete _vaults[vault]
    /// token transfer: none
    function rageQuit() external override {
        // fetch vault storage reference
        VaultData storage _vaultData = _vaults[msg.sender];

        // revert if no active stakes
        require(_vaultData.stakes.length != 0, ""Hypervisor: no stake"");

        // update cached sum of stake units across all vaults
        _updateTotalStakeUnits();

        // emit event
        emit Unstaked(msg.sender, _vaultData.totalStake);

        // update cached totals
        _hypervisor.totalStake = _hypervisor.totalStake.sub(_vaultData.totalStake);
        _hypervisor.totalStakeUnits = _hypervisor.totalStakeUnits.sub(
            calculateTotalStakeUnits(_vaultData.stakes, block.timestamp)
        );

        // delete stake data
        delete _vaults[msg.sender];
    }

    /* convenience functions */

    function _updateTotalStakeUnits() private {
        // update cached totalStakeUnits
        _hypervisor.totalStakeUnits = getCurrentTotalStakeUnits();
        // update cached lastUpdate
        _hypervisor.lastUpdate = block.timestamp;
    }

    function _validateAddress(address target) private view {
        // sanity check target for potential input errors
        require(isValidAddress(target), ""Hypervisor: invalid address"");
    }

    function _truncateStakesArray(StakeData[] memory array, uint256 newLength)
        private
        pure
        returns (StakeData[] memory newArray)
    {
        newArray = new StakeData[](newLength);
        for (uint256 index = 0; index < newLength; index++) {
            newArray[index] = array[index];
        }
        return newArray;
    }
}
.
To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs.]

Given the user's task and the brainstorming ideas provided:
Task: ""// SPDX-License-Identifier: GPL-3.0-only
pragma solidity 0.7.6;
pragma abicoder v2;

import {SafeMath} from ""@openzeppelin/contracts/math/SafeMath.sol"";
import {EnumerableSet} from ""@openzeppelin/contracts/utils/EnumerableSet.sol"";
import {IERC20} from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import {Ownable} from ""@openzeppelin/contracts/access/Ownable.sol"";
import {TransferHelper} from ""@uniswap/lib/contracts/libraries/TransferHelper.sol"";

import {IFactory} from ""../factory/IFactory.sol"";
import {IInstanceRegistry} from ""../factory/InstanceRegistry.sol"";
import {IUniversalVault} from ""../visor/Visor.sol"";
import {IRewardPool} from ""./RewardPool.sol"";
import {Powered} from ""./Powered.sol"";

interface IRageQuit {
    function rageQuit() external;
}

interface IHypervisor is IRageQuit {
    /* admin events */

    event HypervisorCreated(address rewardPool, address powerSwitch);
    event HypervisorFunded(uint256 amount, uint256 duration);
    event BonusTokenRegistered(address token);
    event VaultFactoryRegistered(address factory);
    event VaultFactoryRemoved(address factory);

    /* user events */

    event Staked(address vault, uint256 amount);
    event Unstaked(address vault, uint256 amount);
    event RewardClaimed(address vault, address recipient, address token, uint256 amount);

    /* data types */

    struct HypervisorData {
        address stakingToken;
        address rewardToken;
        address rewardPool;
        RewardScaling rewardScaling;
        uint256 rewardSharesOutstanding;
        uint256 totalStake;
        uint256 totalStakeUnits;
        uint256 lastUpdate;
        RewardSchedule[] rewardSchedules;
    }

    struct RewardSchedule {
        uint256 duration;
        uint256 start;
        uint256 shares;
    }

    struct VaultData {
        uint256 totalStake;
        StakeData[] stakes;
    }

    struct StakeData {
        uint256 amount;
        uint256 timestamp;
    }

    struct RewardScaling {
        uint256 floor;
        uint256 ceiling;
        uint256 time;
    }

    struct RewardOutput {
        uint256 lastStakeAmount;
        uint256 newStakesCount;
        uint256 reward;
        uint256 newTotalStakeUnits;
    }

    /* user functions */

    function stake(
        address vault,
        uint256 amount,
        bytes calldata permission
    ) external;

    function unstakeAndClaim(
        address vault,
        uint256 amount,
        bytes calldata permission
    ) external;

    /* getter functions */

    function getHypervisorData() external view returns (HypervisorData memory hypervisor);

    function getBonusTokenSetLength() external view returns (uint256 length);

    function getBonusTokenAtIndex(uint256 index) external view returns (address bonusToken);

    function getVaultFactorySetLength() external view returns (uint256 length);

    function getVaultFactoryAtIndex(uint256 index) external view returns (address factory);

    function getVaultData(address vault) external view returns (VaultData memory vaultData);

    function isValidAddress(address target) external view returns (bool validity);

    function isValidVault(address target) external view returns (bool validity);

    function getCurrentUnlockedRewards() external view returns (uint256 unlockedRewards);

    function getFutureUnlockedRewards(uint256 timestamp)
        external
        view
        returns (uint256 unlockedRewards);

    function getCurrentVaultReward(address vault) external view returns (uint256 reward);

    function getCurrentStakeReward(address vault, uint256 stakeAmount)
        external
        view
        returns (uint256 reward);

    function getFutureVaultReward(address vault, uint256 timestamp)
        external
        view
        returns (uint256 reward);

    function getFutureStakeReward(
        address vault,
        uint256 stakeAmount,
        uint256 timestamp
    ) external view returns (uint256 reward);

    function getCurrentVaultStakeUnits(address vault) external view returns (uint256 stakeUnits);

    function getFutureVaultStakeUnits(address vault, uint256 timestamp)
        external
        view
        returns (uint256 stakeUnits);

    function getCurrentTotalStakeUnits() external view returns (uint256 totalStakeUnits);

    function getFutureTotalStakeUnits(uint256 timestamp)
        external
        view
        returns (uint256 totalStakeUnits);

    /* pure functions */

    function calculateTotalStakeUnits(StakeData[] memory stakes, uint256 timestamp)
        external
        pure
        returns (uint256 totalStakeUnits);

    function calculateStakeUnits(
        uint256 amount,
        uint256 start,
        uint256 end
    ) external pure returns (uint256 stakeUnits);

    function calculateUnlockedRewards(
        RewardSchedule[] memory rewardSchedules,
        uint256 rewardBalance,
        uint256 sharesOutstanding,
        uint256 timestamp
    ) external pure returns (uint256 unlockedRewards);

    function calculateRewardFromStakes(
        StakeData[] memory stakes,
        uint256 unstakeAmount,
        uint256 unlockedRewards,
        uint256 totalStakeUnits,
        uint256 timestamp,
        RewardScaling memory rewardScaling
    ) external pure returns (RewardOutput memory out);

    function calculateReward(
        uint256 unlockedRewards,
        uint256 stakeAmount,
        uint256 stakeDuration,
        uint256 totalStakeUnits,
        RewardScaling memory rewardScaling
    ) external pure returns (uint256 reward);
}

/// @title Hypervisor
/// @notice Reward distribution contract with time multiplier
/// Access Control
/// - Power controller:
///     Can power off / shutdown the Hypervisor
///     Can withdraw rewards from reward pool once shutdown
/// - Proxy owner:
///     Can change arbitrary logic / state by upgrading the Hypervisor
///     Is unable to operate on user funds due to UniversalVault
///     Is unable to operate on reward pool funds when reward pool is offline / shutdown
/// - Hypervisor admin:
///     Can add funds to the Hypervisor, register bonus tokens, and whitelist new vault factories
///     Is a subset of proxy owner permissions
/// - User:
///     Can deposit / withdraw / ragequit
/// Hypervisor State Machine
/// - Online:
///     Hypervisor is operating normally, all functions are enabled
/// - Offline:
///     Hypervisor is temporarely disabled for maintenance
///     User deposits and withdrawls are disabled, ragequit remains enabled
///     Users can withdraw their stake through rageQuit() but forego their pending reward
///     Should only be used when downtime required for an upgrade
/// - Shutdown:
///     Hypervisor is permanently disabled
///     All functions are disabled with the exception of ragequit
///     Users can withdraw their stake through rageQuit()
///     Power controller can withdraw from the reward pool
///     Should only be used if Proxy Owner role is compromized
contract Hypervisor is IHypervisor, Powered, Ownable {
    using SafeMath for uint256;
    using EnumerableSet for EnumerableSet.AddressSet;

    /* constants */

    // An upper bound on the number of active stakes per vault is required to prevent
    // calls to rageQuit() from reverting.
    // With 30 stakes in a vault, ragequit costs 432811 gas which is conservatively lower
    // than the hardcoded limit of 500k gas on the vault.
    // This limit is configurable and could be increased in a future deployment.
    // Ultimately, to avoid a need for fixed upper bounds, the EVM would need to provide
    // an error code that allows for reliably catching out-of-gas errors on remote calls.
    uint256 public constant MAX_STAKES_PER_VAULT = 30;
    uint256 public constant MAX_REWARD_TOKENS = 50;
    uint256 public constant BASE_SHARES_PER_WEI = 1000000;
    uint256 public stakeLimit = 2500 ether;

    /* storage */

    HypervisorData private _hypervisor;
    mapping(address => VaultData) private _vaults;
    EnumerableSet.AddressSet private _bonusTokenSet;
    EnumerableSet.AddressSet private _vaultFactorySet;

    /* initializer */

    /// @notice Initizalize Hypervisor
    /// access control: only proxy constructor
    /// state machine: can only be called once
    /// state scope: set initialization variables
    /// token transfer: none
    /// @param ownerAddress address The admin address
    /// @param rewardPoolFactory address The factory to use for deploying the RewardPool
    /// @param powerSwitchFactory address The factory to use for deploying the PowerSwitch
    /// @param stakingToken address The address of the staking token for this Hypervisor
    /// @param rewardToken address The address of the reward token for this Hypervisor
    /// @param rewardScaling RewardScaling The config for reward scaling floor, ceiling, and time
    constructor(
        address ownerAddress,
        address rewardPoolFactory,
        address powerSwitchFactory,
        address stakingToken,
        address rewardToken,
        RewardScaling memory rewardScaling,
        uint256 _stakeLimit
    ) {
        // the scaling floor must be smaller than ceiling
        require(rewardScaling.floor <= rewardScaling.ceiling, ""Hypervisor: floor above ceiling"");

        // setting rewardScalingTime to 0 would cause divide by zero error
        // to disable reward scaling, use rewardScalingFloor == rewardScalingCeiling
        require(rewardScaling.time != 0, ""Hypervisor: scaling time cannot be zero"");

        // deploy power switch
        address powerSwitch = IFactory(powerSwitchFactory).create(abi.encode(ownerAddress));

        // deploy reward pool
        address rewardPool = IFactory(rewardPoolFactory).create(abi.encode(powerSwitch));

        // set internal configs
        Ownable.transferOwnership(ownerAddress);
        Powered._setPowerSwitch(powerSwitch);

        // commit to storage
        _hypervisor.stakingToken = stakingToken;
        _hypervisor.rewardToken = rewardToken;
        _hypervisor.rewardPool = rewardPool;
        _hypervisor.rewardScaling = rewardScaling;

        stakeLimit = _stakeLimit;

        // emit event
        emit HypervisorCreated(rewardPool, powerSwitch);
    }

    /* getter functions */

    function getBonusTokenSetLength() external view override returns (uint256 length) {
        return _bonusTokenSet.length();
    }

    function getBonusTokenAtIndex(uint256 index)
        external
        view
        override
        returns (address bonusToken)
    {
        return _bonusTokenSet.at(index);
    }

    function getVaultFactorySetLength() external view override returns (uint256 length) {
        return _vaultFactorySet.length();
    }

    function getVaultFactoryAtIndex(uint256 index)
        external
        view
        override
        returns (address factory)
    {
        return _vaultFactorySet.at(index);
    }

    function isValidVault(address target) public view override returns (bool validity) {
        // validate target is created from whitelisted vault factory
        for (uint256 index = 0; index < _vaultFactorySet.length(); index++) {
            if (IInstanceRegistry(_vaultFactorySet.at(index)).isInstance(target)) {
                return true;
            }
        }
        // explicit return
        return false;
    }

    function isValidAddress(address target) public view override returns (bool validity) {
        // sanity check target for potential input errors
        return
            target != address(this) &&
            target != address(0) &&
            target != _hypervisor.stakingToken &&
            target != _hypervisor.rewardToken &&
            target != _hypervisor.rewardPool &&
            !_bonusTokenSet.contains(target);
    }

    /* Hypervisor getters */

    function getHypervisorData() external view override returns (HypervisorData memory hypervisor) {
        return _hypervisor;
    }

    function getCurrentUnlockedRewards() public view override returns (uint256 unlockedRewards) {
        // calculate reward available based on state
        return getFutureUnlockedRewards(block.timestamp);
    }

    function getFutureUnlockedRewards(uint256 timestamp)
        public
        view
        override
        returns (uint256 unlockedRewards)
    {
        // get reward amount remaining
        uint256 remainingRewards = IERC20(_hypervisor.rewardToken).balanceOf(_hypervisor.rewardPool);
        // calculate reward available based on state
        unlockedRewards = calculateUnlockedRewards(
            _hypervisor.rewardSchedules,
            remainingRewards,
            _hypervisor.rewardSharesOutstanding,
            timestamp
        );
        // explicit return
        return unlockedRewards;
    }

    function getCurrentTotalStakeUnits() public view override returns (uint256 totalStakeUnits) {
        // calculate new stake units
        return getFutureTotalStakeUnits(block.timestamp);
    }

    function getFutureTotalStakeUnits(uint256 timestamp)
        public
        view
        override
        returns (uint256 totalStakeUnits)
    {
        // return early if no change
        if (timestamp == _hypervisor.lastUpdate) return _hypervisor.totalStakeUnits;
        // calculate new stake units
        uint256 newStakeUnits =
            calculateStakeUnits(_hypervisor.totalStake, _hypervisor.lastUpdate, timestamp);
        // add to cached total
        totalStakeUnits = _hypervisor.totalStakeUnits.add(newStakeUnits);
        // explicit return
        return totalStakeUnits;
    }

    /* vault getters */

    function getVaultData(address vault)
        external
        view
        override
        returns (VaultData memory vaultData)
    {
        return _vaults[vault];
    }

    function getCurrentVaultReward(address vault) external view override returns (uint256 reward) {
        // calculate rewards
        return
            calculateRewardFromStakes(
                _vaults[vault]
                    .stakes,
                _vaults[vault]
                    .totalStake,
                getCurrentUnlockedRewards(),
                getCurrentTotalStakeUnits(),
                block
                    .timestamp,
                _hypervisor
                    .rewardScaling
            )
                .reward;
    }

    function getFutureVaultReward(address vault, uint256 timestamp)
        external
        view
        override
        returns (uint256 reward)
    {
        // calculate rewards
        return
            calculateRewardFromStakes(
                _vaults[vault]
                    .stakes,
                _vaults[vault]
                    .totalStake,
                getFutureUnlockedRewards(timestamp),
                getFutureTotalStakeUnits(timestamp),
                timestamp,
                _hypervisor
                    .rewardScaling
            )
                .reward;
    }

    function getCurrentStakeReward(address vault, uint256 stakeAmount)
        external
        view
        override
        returns (uint256 reward)
    {
        // calculate rewards
        return
            calculateRewardFromStakes(
                _vaults[vault]
                    .stakes,
                stakeAmount,
                getCurrentUnlockedRewards(),
                getCurrentTotalStakeUnits(),
                block
                    .timestamp,
                _hypervisor
                    .rewardScaling
            )
                .reward;
    }

    function getFutureStakeReward(
        address vault,
        uint256 stakeAmount,
        uint256 timestamp
    ) external view override returns (uint256 reward) {
        // calculate rewards
        return
            calculateRewardFromStakes(
                _vaults[vault]
                    .stakes,
                stakeAmount,
                getFutureUnlockedRewards(timestamp),
                getFutureTotalStakeUnits(timestamp),
                timestamp,
                _hypervisor
                    .rewardScaling
            )
                .reward;
    }

    function getCurrentVaultStakeUnits(address vault)
        public
        view
        override
        returns (uint256 stakeUnits)
    {
        // calculate stake units
        return getFutureVaultStakeUnits(vault, block.timestamp);
    }

    function getFutureVaultStakeUnits(address vault, uint256 timestamp)
        public
        view
        override
        returns (uint256 stakeUnits)
    {
        // calculate stake units
        return calculateTotalStakeUnits(_vaults[vault].stakes, timestamp);
    }

    /* pure functions */

    function calculateTotalStakeUnits(StakeData[] memory stakes, uint256 timestamp)
        public
        pure
        override
        returns (uint256 totalStakeUnits)
    {
        for (uint256 index; index < stakes.length; index++) {
            // reference stake
            StakeData memory stakeData = stakes[index];
            // calculate stake units
            uint256 stakeUnits =
                calculateStakeUnits(stakeData.amount, stakeData.timestamp, timestamp);
            // add to running total
            totalStakeUnits = totalStakeUnits.add(stakeUnits);
        }
    }

    function calculateStakeUnits(
        uint256 amount,
        uint256 start,
        uint256 end
    ) public pure override returns (uint256 stakeUnits) {
        // calculate duration
        uint256 duration = end.sub(start);
        // calculate stake units
        stakeUnits = duration.mul(amount);
        // explicit return
        return stakeUnits;
    }

    function calculateUnlockedRewards(
        RewardSchedule[] memory rewardSchedules,
        uint256 rewardBalance,
        uint256 sharesOutstanding,
        uint256 timestamp
    ) public pure override returns (uint256 unlockedRewards) {
        // return 0 if no registered schedules
        if (rewardSchedules.length == 0) {
            return 0;
        }

        // calculate reward shares locked across all reward schedules
        uint256 sharesLocked;
        for (uint256 index = 0; index < rewardSchedules.length; index++) {
            // fetch reward schedule storage reference
            RewardSchedule memory schedule = rewardSchedules[index];

            // caculate amount of shares available on this schedule
            // if (now - start) < duration
            //   sharesLocked = shares - (shares * (now - start) / duration)
            // else
            //   sharesLocked = 0
            uint256 currentSharesLocked = 0;
            if (timestamp.sub(schedule.start) < schedule.duration) {
                currentSharesLocked = schedule.shares.sub(
                    schedule.shares.mul(timestamp.sub(schedule.start)).div(schedule.duration)
                );
            }

            // add to running total
            sharesLocked = sharesLocked.add(currentSharesLocked);
        }

        // convert shares to reward
        // rewardLocked = sharesLocked * rewardBalance / sharesOutstanding
        uint256 rewardLocked = sharesLocked.mul(rewardBalance).div(sharesOutstanding);

        // calculate amount available
        // unlockedRewards = rewardBalance - rewardLocked
        unlockedRewards = rewardBalance.sub(rewardLocked);

        // explicit return
        return unlockedRewards;
    }

    function calculateRewardFromStakes(
        StakeData[] memory stakes,
        uint256 unstakeAmount,
        uint256 unlockedRewards,
        uint256 totalStakeUnits,
        uint256 timestamp,
        RewardScaling memory rewardScaling
    ) public pure override returns (RewardOutput memory out) {
        uint256 stakesToDrop = 0;
        while (unstakeAmount > 0) {
            // fetch vault stake storage reference
            StakeData memory lastStake = stakes[stakes.length.sub(stakesToDrop).sub(1)];

            // calculate stake duration
            uint256 stakeDuration = timestamp.sub(lastStake.timestamp);

            uint256 currentAmount;
            if (lastStake.amount > unstakeAmount) {
                // set current amount to remaining unstake amount
                currentAmount = unstakeAmount;
                // amount of last stake is reduced
                out.lastStakeAmount = lastStake.amount.sub(unstakeAmount);
            } else {
                // set current amount to amount of last stake
                currentAmount = lastStake.amount;
                // add to stakes to drop
                stakesToDrop += 1;
            }

            // update remaining unstakeAmount
            unstakeAmount = unstakeAmount.sub(currentAmount);

            // calculate reward amount
            uint256 currentReward =
                calculateReward(
                    unlockedRewards,
                    currentAmount,
                    stakeDuration,
                    totalStakeUnits,
                    rewardScaling
                );

            // update cumulative reward
            out.reward = out.reward.add(currentReward);

            // update cached unlockedRewards
            unlockedRewards = unlockedRewards.sub(currentReward);

            // calculate time weighted stake
            uint256 stakeUnits = currentAmount.mul(stakeDuration);

            // update cached totalStakeUnits
            totalStakeUnits = totalStakeUnits.sub(stakeUnits);
        }

        // explicit return
        return
            RewardOutput(
                out.lastStakeAmount,
                stakes.length.sub(stakesToDrop),
                out.reward,
                totalStakeUnits
            );
    }

    function calculateReward(
        uint256 unlockedRewards,
        uint256 stakeAmount,
        uint256 stakeDuration,
        uint256 totalStakeUnits,
        RewardScaling memory rewardScaling
    ) public pure override returns (uint256 reward) {
        // calculate time weighted stake
        uint256 stakeUnits = stakeAmount.mul(stakeDuration);

        // calculate base reward
        // baseReward = unlockedRewards * stakeUnits / totalStakeUnits
        uint256 baseReward = 0;
        if (totalStakeUnits != 0) {
            // scale reward according to proportional weight
            baseReward = unlockedRewards.mul(stakeUnits).div(totalStakeUnits);
        }

        // calculate scaled reward
        // if no scaling or scaling period completed
        //   reward = baseReward
        // else
        //   minReward = baseReward * scalingFloor / scalingCeiling
        //   bonusReward = baseReward
        //                 * (scalingCeiling - scalingFloor) / scalingCeiling
        //                 * duration / scalingTime
        //   reward = minReward + bonusReward
        if (stakeDuration >= rewardScaling.time || rewardScaling.floor == rewardScaling.ceiling) {
            // no reward scaling applied
            reward = baseReward;
        } else {
            // calculate minimum reward using scaling floor
            uint256 minReward = baseReward.mul(rewardScaling.floor).div(rewardScaling.ceiling);

            // calculate bonus reward with vested portion of scaling factor
            uint256 bonusReward =
                baseReward
                    .mul(stakeDuration)
                    .mul(rewardScaling.ceiling.sub(rewardScaling.floor))
                    .div(rewardScaling.ceiling)
                    .div(rewardScaling.time);

            // add minimum reward and bonus reward
            reward = minReward.add(bonusReward);
        }

        // explicit return
        return reward;
    }

    /* admin functions */

    /// @notice Add funds to the Hypervisor
    /// access control: only admin
    /// state machine:
    ///   - can be called multiple times
    ///   - only online
    /// state scope:
    ///   - increase _hypervisor.rewardSharesOutstanding
    ///   - append to _hypervisor.rewardSchedules
    /// token transfer: transfer staking tokens from msg.sender to reward pool
    /// @param amount uint256 Amount of reward tokens to deposit
    /// @param duration uint256 Duration over which to linearly unlock rewards
    function fund(uint256 amount, uint256 duration) external onlyOwner onlyOnline {
        // validate duration
        require(duration != 0, ""Hypervisor: invalid duration"");

        // create new reward shares
        // if existing rewards on this Hypervisor
        //   mint new shares proportional to % change in rewards remaining
        //   newShares = remainingShares * newReward / remainingRewards
        // else
        //   mint new shares with BASE_SHARES_PER_WEI initial conversion rate
        //   store as fixed point number with same  of decimals as reward token
        uint256 newRewardShares;
        if (_hypervisor.rewardSharesOutstanding > 0) {
            uint256 remainingRewards = IERC20(_hypervisor.rewardToken).balanceOf(_hypervisor.rewardPool);
            newRewardShares = _hypervisor.rewardSharesOutstanding.mul(amount).div(remainingRewards);
        } else {
            newRewardShares = amount.mul(BASE_SHARES_PER_WEI);
        }

        // add reward shares to total
        _hypervisor.rewardSharesOutstanding = _hypervisor.rewardSharesOutstanding.add(newRewardShares);

        // store new reward schedule
        _hypervisor.rewardSchedules.push(RewardSchedule(duration, block.timestamp, newRewardShares));

        // transfer reward tokens to reward pool
        TransferHelper.safeTransferFrom(
            _hypervisor.rewardToken,
            msg.sender,
            _hypervisor.rewardPool,
            amount
        );

        // emit event
        emit HypervisorFunded(amount, duration);
    }

    /// @notice Add vault factory to whitelist
    /// @dev use this function to enable stakes to vaults coming from the specified
    ///      factory contract
    /// access control: only admin
    /// state machine:
    ///   - can be called multiple times
    ///   - not shutdown
    /// state scope:
    ///   - append to _vaultFactorySet
    /// token transfer: none
    /// @param factory address The address of the vault factory
    function registerVaultFactory(address factory) external onlyOwner notShutdown {
        // add factory to set
        require(_vaultFactorySet.add(factory), ""Hypervisor: vault factory already registered"");

        // emit event
        emit VaultFactoryRegistered(factory);
    }

    /// @notice Remove vault factory from whitelist
    /// @dev use this function to disable new stakes to vaults coming from the specified
    ///      factory contract.
    ///      note: vaults with existing stakes from this factory are sill able to unstake
    /// access control: only admin
    /// state machine:
    ///   - can be called multiple times
    ///   - not shutdown
    /// state scope:
    ///   - remove from _vaultFactorySet
    /// token transfer: none
    /// @param factory address The address of the vault factory
    function removeVaultFactory(address factory) external onlyOwner notShutdown {
        // remove factory from set
        require(_vaultFactorySet.remove(factory), ""Hypervisor: vault factory not registered"");

        // emit event
        emit VaultFactoryRemoved(factory);
    }

    /// @notice Register bonus token for distribution
    /// @dev use this function to enable distribution of any ERC20 held by the RewardPool contract
    /// access control: only admin
    /// state machine:
    ///   - can be called multiple times
    ///   - only online
    /// state scope:
    ///   - append to _bonusTokenSet
    /// token transfer: none
    /// @param bonusToken address The address of the bonus token
    function registerBonusToken(address bonusToken) external onlyOwner onlyOnline {
        // verify valid bonus token
        _validateAddress(bonusToken);

        // verify bonus token count
        require(_bonusTokenSet.length() < MAX_REWARD_TOKENS, ""Hypervisor: max bonus tokens reached "");

        // add token to set
        assert(_bonusTokenSet.add(bonusToken));

        // emit event
        emit BonusTokenRegistered(bonusToken);
    }

    /// @notice Rescue tokens from RewardPool
    /// @dev use this function to rescue tokens from RewardPool contract
    ///      without distributing to stakers or triggering emergency shutdown
    /// access control: only admin
    /// state machine:
    ///   - can be called multiple times
    ///   - only online
    /// state scope: none
    /// token transfer: transfer requested token from RewardPool to recipient
    /// @param token address The address of the token to rescue
    /// @param recipient address The address of the recipient
    /// @param amount uint256 The amount of tokens to rescue
    function rescueTokensFromRewardPool(
        address token,
        address recipient,
        uint256 amount
    ) external onlyOwner onlyOnline {
        // verify recipient
        _validateAddress(recipient);

        // check not attempting to unstake reward token
        require(token != _hypervisor.rewardToken, ""Hypervisor: invalid address"");

        // check not attempting to wthdraw bonus token
        require(!_bonusTokenSet.contains(token), ""Hypervisor: invalid address"");

        // transfer tokens to recipient
        IRewardPool(_hypervisor.rewardPool).sendERC20(token, recipient, amount);
    }

    /* user functions */

    /// @notice Stake tokens
    /// @dev anyone can stake to any vault if they have valid permission
    /// access control: anyone
    /// state machine:
    ///   - can be called multiple times
    ///   - only online
    ///   - when vault exists on this Hypervisor
    /// state scope:
    ///   - append to _vaults[vault].stakes
    ///   - increase _vaults[vault].totalStake
    ///   - increase _hypervisor.totalStake
    ///   - increase _hypervisor.totalStakeUnits
    ///   - increase _hypervisor.lastUpdate
    /// token transfer: transfer staking tokens from msg.sender to vault
    /// @param vault address The address of the vault to stake from
    /// @param amount uint256 The amount of staking tokens to stake
    function stake(
        address vault,
        uint256 amount,
        bytes calldata permission
    ) external override onlyOnline {
        // verify vault is valid
        require(isValidVault(vault), ""Hypervisor: vault is not registered"");

        // verify non-zero amount
        require(amount != 0, ""Hypervisor: no amount staked"");

        // fetch vault storage reference
        VaultData storage vaultData = _vaults[vault];

        // verify stakes boundary not reached
        require(
            vaultData.stakes.length < MAX_STAKES_PER_VAULT,
            ""Hypervisor: MAX_STAKES_PER_VAULT reached""
        );

        // update cached sum of stake units across all vaults
        _updateTotalStakeUnits();

        // store amount and timestamp
        vaultData.stakes.push(StakeData(amount, block.timestamp));

        // update cached total vault and Hypervisor amounts
        vaultData.totalStake = vaultData.totalStake.add(amount);
        // verify stake quantity without bounds
        require(
            stakeLimit == 0 || vaultData.totalStake <= stakeLimit,
            ""Hypervisor: Stake limit exceeded""
        );
        _hypervisor.totalStake = _hypervisor.totalStake.add(amount);

        // call lock on vault
        IUniversalVault(vault).lock(_hypervisor.stakingToken, amount, permission);

        // emit event
        emit Staked(vault, amount);
    }

    /// @notice Unstake staking tokens and claim reward
    /// @dev rewards can only be claimed when unstaking
    /// access control: only owner of vault
    /// state machine:
    ///   - when vault exists on this Hypervisor
    ///   - after stake from vault
    ///   - can be called multiple times while sufficient stake remains
    ///   - only online
    /// state scope:
    ///   - decrease _hypervisor.rewardSharesOutstanding
    ///   - decrease _hypervisor.totalStake
    ///   - increase _hypervisor.lastUpdate
    ///   - modify _hypervisor.totalStakeUnits
    ///   - modify _vaults[vault].stakes
    ///   - decrease _vaults[vault].totalStake
    /// token transfer:
    ///   - transfer reward tokens from reward pool to recipient
    ///   - transfer bonus tokens from reward pool to recipient
    /// @param vault address The vault to unstake from
    /// @param amount uint256 The amount of staking tokens to unstake
    function unstakeAndClaim(
        address vault,
        uint256 amount,
        bytes calldata permission
    ) external override onlyOnline {
        // fetch vault storage reference
        VaultData storage vaultData = _vaults[vault];

        // verify non-zero amount
        require(amount != 0, ""Hypervisor: no amount unstaked"");

        address recipient = IUniversalVault(vault).owner();

        // validate recipient
        _validateAddress(recipient);

        // check for sufficient vault stake amount
        require(vaultData.totalStake >= amount, ""Hypervisor: insufficient vault stake"");

        // check for sufficient Hypervisor stake amount
        // if this check fails, there is a bug in stake accounting
        assert(_hypervisor.totalStake >= amount);

        // update cached sum of stake units across all vaults
        _updateTotalStakeUnits();

        // get reward amount remaining
        uint256 remainingRewards = IERC20(_hypervisor.rewardToken).balanceOf(_hypervisor.rewardPool);

        // calculate vested portion of reward pool
        uint256 unlockedRewards =
            calculateUnlockedRewards(
                _hypervisor.rewardSchedules,
                remainingRewards,
                _hypervisor.rewardSharesOutstanding,
                block.timestamp
            );

        // calculate vault time weighted reward with scaling
        RewardOutput memory out =
            calculateRewardFromStakes(
                vaultData.stakes,
                amount,
                unlockedRewards,
                _hypervisor.totalStakeUnits,
                block.timestamp,
                _hypervisor.rewardScaling
            );

        // update stake data in storage
        if (out.newStakesCount == 0) {
            // all stakes have been unstaked
            delete vaultData.stakes;
        } else {
            // some stakes have been completely or partially unstaked
            // delete fully unstaked stakes
            while (vaultData.stakes.length > out.newStakesCount) vaultData.stakes.pop();
            // update partially unstaked stake
            vaultData.stakes[out.newStakesCount.sub(1)].amount = out.lastStakeAmount;
        }

        // update cached stake totals
        vaultData.totalStake = vaultData.totalStake.sub(amount);
        _hypervisor.totalStake = _hypervisor.totalStake.sub(amount);
        _hypervisor.totalStakeUnits = out.newTotalStakeUnits;

        // unlock staking tokens from vault
        IUniversalVault(vault).unlock(_hypervisor.stakingToken, amount, permission);

        // emit event
        emit Unstaked(vault, amount);

        // only perform on non-zero reward
        if (out.reward > 0) {
            // calculate shares to burn
            // sharesToBurn = sharesOutstanding * reward / remainingRewards
            uint256 sharesToBurn =
                _hypervisor.rewardSharesOutstanding.mul(out.reward).div(remainingRewards);

            // burn claimed shares
            _hypervisor.rewardSharesOutstanding = _hypervisor.rewardSharesOutstanding.sub(sharesToBurn);

            // transfer bonus tokens from reward pool to recipient
            if (_bonusTokenSet.length() > 0) {
                for (uint256 index = 0; index < _bonusTokenSet.length(); index++) {
                    // fetch bonus token address reference
                    address bonusToken = _bonusTokenSet.at(index);

                    // calculate bonus token amount
                    // bonusAmount = bonusRemaining * reward / remainingRewards
                    uint256 bonusAmount =
                        IERC20(bonusToken).balanceOf(_hypervisor.rewardPool).mul(out.reward).div(
                            remainingRewards
                        );

                    // transfer bonus token
                    IRewardPool(_hypervisor.rewardPool).sendERC20(bonusToken, recipient, bonusAmount);

                    // emit event
                    emit RewardClaimed(vault, recipient, bonusToken, bonusAmount);
                }
            }

            // transfer reward tokens from reward pool to recipient
            IRewardPool(_hypervisor.rewardPool).sendERC20(_hypervisor.rewardToken, recipient, out.reward);

            // emit event
            emit RewardClaimed(vault, recipient, _hypervisor.rewardToken, out.reward);
        }
    }

    /// @notice Exit Hypervisor without claiming reward
    /// @dev This function should never revert when correctly called by the vault.
    ///      A max number of stakes per vault is set with MAX_STAKES_PER_VAULT to
    ///      place an upper bound on the for loop in calculateTotalStakeUnits().
    /// access control: only callable by the vault directly
    /// state machine:
    ///   - when vault exists on this Hypervisor
    ///   - when active stake from this vault
    ///   - any power state
    /// state scope:
    ///   - decrease _hypervisor.totalStake
    ///   - increase _hypervisor.lastUpdate
    ///   - modify _hypervisor.totalStakeUnits
    ///   - delete _vaults[vault]
    /// token transfer: none
    function rageQuit() external override {
        // fetch vault storage reference
        VaultData storage _vaultData = _vaults[msg.sender];

        // revert if no active stakes
        require(_vaultData.stakes.length != 0, ""Hypervisor: no stake"");

        // update cached sum of stake units across all vaults
        _updateTotalStakeUnits();

        // emit event
        emit Unstaked(msg.sender, _vaultData.totalStake);

        // update cached totals
        _hypervisor.totalStake = _hypervisor.totalStake.sub(_vaultData.totalStake);
        _hypervisor.totalStakeUnits = _hypervisor.totalStakeUnits.sub(
            calculateTotalStakeUnits(_vaultData.stakes, block.timestamp)
        );

        // delete stake data
        delete _vaults[msg.sender];
    }

    /* convenience functions */

    function _updateTotalStakeUnits() private {
        // update cached totalStakeUnits
        _hypervisor.totalStakeUnits = getCurrentTotalStakeUnits();
        // update cached lastUpdate
        _hypervisor.lastUpdate = block.timestamp;
    }

    function _validateAddress(address target) private view {
        // sanity check target for potential input errors
        require(isValidAddress(target), ""Hypervisor: invalid address"");
    }

    function _truncateStakesArray(StakeData[] memory array, uint256 newLength)
        private
        pure
        returns (StakeData[] memory newArray)
    {
        newArray = new StakeData[](newLength);
        for (uint256 index = 0; index < newLength; index++) {
            newArray[index] = array[index];
        }
        return newArray;
    }
}
"".
Ideas: "" Gas Limit Identified.

**Lack of Gas Limit Considerations**
'''
The `calculateTotalStakeUnits` function iterates over the `stakes` array, which can potentially grow large if many stakes are made. If a user attempts to call this function with a vault that has a large number of stakes, it could lead to an out-of-gas error. This is particularly concerning in the `rageQuit` function, which calls `_updateTotalStakeUnits`, which in turn calls `calculateTotalStakeUnits`. If the stakes array is large, it could cause the transaction to fail due to exceeding the gas limit.

To mitigate this issue, consider implementing a maximum limit on the number of stakes that can be processed in a single transaction. Additionally, you could implement a mechanism to paginate through the stakes or allow users to withdraw stakes in smaller batches to avoid hitting gas limits.
'''

**Potential Denial-of-Service (DoS"".
As the Security Analyst, your primary objective is to conduct a comprehensive inspection of the provided contract code, with a particular focus on identifying vulnerabilities related to Price Manipulation. There are two cases where the contract may have Price Manipulation vulnerabilities:
1. When the contract allows arbitrary adjustment of token prices by a centralized authority without any checks or balances, potentially leading to unfair trades.
2. When the contract does not utilize decentralized or transparent mechanisms for determining token prices, allowing for potential exploitation by the controlling entity.
If you identify all Price Manipulation vulnerabilities, respond with: """,,"<INFO> Assumption of Fixed-Length Array Identified.

```
VULNERABILITY NAME: Assumption of Fixed-Length Array in calculateTotalStakeUnits
'''
DETAILED DESCRIPTION: The function `calculateTotalStakeUnits` assumes that the length of the `stakes` array is fixed and iterates through it using a for loop. If the length of the `stakes` array is modified externally or if the array is empty, this could lead to out-of-bounds errors or incorrect calculations. The function does not check the length of the array before accessing its elements, which can lead to unintended behavior or data corruption.

RECOMMENDED MITIGATION/FIX: Implement a check at the beginning of the function to ensure that the `stakes` array is not empty before proceeding with the calculations. Additionally, consider using a `while` loop that checks the current length dynamically to avoid assumptions about the array's length.
'''

VULNERABILITY NAME: Assumption of Fixed-Length Array in unstakeAndClaim
'''
DETAILED DESCRIPTION: In the `unstake

[2024-02-08 00:43:57 INFO] **[Execute Detail]**

execute SimplePhase:[WithdrawalFunctionDetector] in ComposedPhase:[CodeReview], cycle 1

[2024-02-08 00:43:57 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: GPL-3.0-only pragma solidity 0.7.6; pragma abicoder v2; import {SafeMath} from ""@openzeppelin/contracts/math/SafeMath.sol""; import {EnumerableSet} from ""@openzeppelin/contracts/utils/EnumerableSet.sol""; import {IERC20} from ""@openzeppelin/contracts/token/ERC20/IERC20.sol""; import {Ownable} from ""@openzeppelin/contracts/access/Ownable.sol""; import {TransferHelper} from ""@uniswap/lib/contracts/libraries/TransferHelper.sol""; import {IFactory} from ""../factory/IFactory.sol""; import {IInstanceRegistry} from ""../factory/InstanceRegistry.sol""; import {IUniversalVault} from ""../visor/Visor.sol""; import {IRewardPool} from ""./RewardPool.sol""; import {Powered} from ""./Powered.sol""; interface IRageQuit {     function rageQuit() external; } interface IHypervisor is IRageQuit {     / admin events / event HypervisorCreated(address rewardPool, address powerSwitch); event HypervisorFunded(uint256 amount, uint256 duration); event BonusTokenRegistered(address token); event VaultFactoryRegistered(address factory); event VaultFactoryRemoved(address factory);  /* user events */  event Staked(address vault, uint256 amount); event Unstaked(address vault, uint256 amount); event RewardClaimed(address vault, address recipient, address token, uint256 amount);  /* data types */  struct HypervisorData {     address stakingToken;     address rewardToken;     address rewardPool;     RewardScaling rewardScaling;     uint256 rewardSharesOutstanding;     uint256 totalStake;     uint256 totalStakeUnits;     uint256 lastUpdate;     RewardSchedule[] rewardSchedules; }  struct RewardSchedule {     uint256 duration;     uint256 start;     uint256 shares; }  struct VaultData {     uint256 totalStake;     StakeData[] stakes; }  struct StakeData {     uint256 amount;     uint256 timestamp; }  struct RewardScaling {     uint256 floor;     uint256 ceiling;     uint256 time; }  struct RewardOutput {     uint256 lastStakeAmount;     uint256 newStakesCount;     uint256 reward;     uint256 newTotalStakeUnits; }  /* user functions */  function stake(     address vault,     uint256 amount,     bytes calldata permission ) external;  function unstakeAndClaim(     address vault,     uint256 amount,     bytes calldata permission ) external;  /* getter functions */  function getHypervisorData() external view returns (HypervisorData memory hypervisor);  function getBonusTokenSetLength() external view returns (uint256 length);  function getBonusTokenAtIndex(uint256 index) external view returns (address bonusToken);  function getVaultFactorySetLength() external view returns (uint256 length);  function getVaultFactoryAtIndex(uint256 index) external view returns (address factory);  function getVaultData(address vault) external view returns (VaultData memory vaultData);  function isValidAddress(address target) external view returns (bool validity);  function isValidVault(address target) external view returns (bool validity);  function getCurrentUnlockedRewards() external view returns (uint256 unlockedRewards);  function getFutureUnlockedRewards(uint256 timestamp)     external     view     returns (uint256 unlockedRewards);  function getCurrentVaultReward(address vault) external view returns (uint256 reward);  function getCurrentStakeReward(address vault, uint256 stakeAmount)     external     view     returns (uint256 reward);  function getFutureVaultReward(address vault, uint256 timestamp)     external     view     returns (uint256 reward);  function getFutureStakeReward(     address vault,     uint256 stakeAmount,     uint256 timestamp ) external view returns (uint256 reward);  function getCurrentVaultStakeUnits(address vault) external view returns (uint256 stakeUnits);  function getFutureVaultStakeUnits(address vault, uint256 timestamp)     external     view     returns (uint256 stakeUnits);  function getCurrentTotalStakeUnits() external view returns (uint256 totalStakeUnits);  function getFutureTotalStakeUnits(uint256 timestamp)     external     view     returns (uint256 totalStakeUnits);  /* pure functions */  function calculateTotalStakeUnits(StakeData[] memory stakes, uint256 timestamp)     external     pure     returns (uint256 totalStakeUnits);  function calculateStakeUnits(     uint256 amount,     uint256 start,     uint256 end ) external pure returns (uint256 stakeUnits);  function calculateUnlockedRewards(     RewardSchedule[] memory rewardSchedules,     uint256 rewardBalance,     uint256 sharesOutstanding,     uint256 timestamp ) external pure returns (uint256 unlockedRewards);  function calculateRewardFromStakes(     StakeData[] memory stakes,     uint256 unstakeAmount,     uint256 unlockedRewards,     uint256 totalStakeUnits,     uint256 timestamp,     RewardScaling memory rewardScaling ) external pure returns (RewardOutput memory out);  function calculateReward(     uint256 unlockedRewards,     uint256 stakeAmount,     uint256 stakeDuration,     uint256 totalStakeUnits,     RewardScaling memory rewardScaling ) external pure returns (uint256 reward);  } /// @title Hypervisor /// @notice Reward distribution contract with time multiplier /// Access Control /// - Power controller: ///     Can power off / shutdown the Hypervisor ///     Can withdraw rewards from reward pool once shutdown /// - Proxy owner: ///     Can change arbitrary logic / state by upgrading the Hypervisor ///     Is unable to operate on user funds due to UniversalVault ///     Is unable to operate on reward pool funds when reward pool is offline / shutdown /// - Hypervisor admin: ///     Can add funds to the Hypervisor, register bonus tokens, and whitelist new vault factories ///     Is a subset of proxy owner permissions /// - User: ///     Can deposit / withdraw / ragequit /// Hypervisor State Machine /// - Online: ///     Hypervisor is operating normally, all functions are enabled /// - Offline: ///     Hypervisor is temporarely disabled for maintenance ///     User deposits and withdrawls are disabled, ragequit remains enabled ///     Users can withdraw their stake through rageQuit() but forego their pending reward ///     Should only be used when downtime required for an upgrade /// - Shutdown: ///     Hypervisor is permanently disabled ///     All functions are disabled with the exception of ragequit ///     Users can withdraw their stake through rageQuit() ///     Power controller can withdraw from the reward pool ///     Should only be used if Proxy Owner role is compromized contract Hypervisor is IHypervisor, Powered, Ownable {     using SafeMath for uint256;     using EnumerableSet for EnumerableSet.AddressSet; /* constants */  // An upper bound on the number of active stakes per vault is required to prevent // calls to rageQuit() from reverting. // With 30 stakes in a vault, ragequit costs 432811 gas which is conservatively lower // than the hardcoded limit of 500k gas on the vault. // This limit is configurable and could be increased in a future deployment. // Ultimately, to avoid a need for fixed upper bounds, the EVM would need to provide // an error code that allows for reliably catching out-of-gas errors on remote calls. uint256 public constant MAX_STAKES_PER_VAULT = 30; uint256 public constant MAX_REWARD_TOKENS = 50; uint256 public constant BASE_SHARES_PER_WEI = 1000000; uint256 public stakeLimit = 2500 ether;  /* storage */  HypervisorData private _hypervisor; mapping(address =&gt; VaultData) private _vaults; EnumerableSet.AddressSet private _bonusTokenSet; EnumerableSet.AddressSet private _vaultFactorySet;  /* initializer */  /// @notice Initizalize Hypervisor /// access control: only proxy constructor /// state machine: can only be called once /// state scope: set initialization variables /// token transfer: none /// @param ownerAddress address The admin address /// @param rewardPoolFactory address The factory to use for deploying the RewardPool /// @param powerSwitchFactory address The factory to use for deploying the PowerSwitch /// @param stakingToken address The address of the staking token for this Hypervisor /// @param rewardToken address The address of the reward token for this Hypervisor /// @param rewardScaling RewardScaling The config for reward scaling floor, ceiling, and time constructor(     address ownerAddress,     address rewardPoolFactory,     address powerSwitchFactory,     address stakingToken,     address rewardToken,     RewardScaling memory rewardScaling,     uint256 _stakeLimit ) {     // the scaling floor must be smaller than ceiling     require(rewardScaling.floor &lt;= rewardScaling.ceiling, ""Hypervisor: floor above ceiling"");      // setting rewardScalingTime to 0 would cause divide by zero error     // to disable reward scaling, use rewardScalingFloor == rewardScalingCeiling     require(rewardScaling.time != 0, ""Hypervisor: scaling time cannot be zero"");      // deploy power switch     address powerSwitch = IFactory(powerSwitchFactory).create(abi.encode(ownerAddress));      // deploy reward pool     address rewardPool = IFactory(rewardPoolFactory).create(abi.encode(powerSwitch));      // set internal configs     Ownable.transferOwnership(ownerAddress);     Powered._setPowerSwitch(powerSwitch);      // commit to storage     _hypervisor.stakingToken = stakingToken;     _hypervisor.rewardToken = rewardToken;     _hypervisor.rewardPool = rewardPool;     _hypervisor.rewardScaling = rewardScaling;      stakeLimit = _stakeLimit;      // emit event     emit HypervisorCreated(rewardPool, powerSwitch); }  /* getter functions */  function getBonusTokenSetLength() external view override returns (uint256 length) {     return _bonusTokenSet.length(); }  function getBonusTokenAtIndex(uint256 index)     external     view     override     returns (address bonusToken) {     return _bonusTokenSet.at(index); }  function getVaultFactorySetLength() external view override returns (uint256 length) {     return _vaultFactorySet.length(); }  function getVaultFactoryAtIndex(uint256 index)     external     view     override     returns (address factory) {     return _vaultFactorySet.at(index); }  function isValidVault(address target) public view override returns (bool validity) {     // validate target is created from whitelisted vault factory     for (uint256 index = 0; index &lt; _vaultFactorySet.length(); index++) {         if (IInstanceRegistry(_vaultFactorySet.at(index)).isInstance(target)) {             return true;         }     }     // explicit return     return false; }  function isValidAddress(address target) public view override returns (bool validity) {     // sanity check target for potential input errors     return         target != address(this) &amp;&amp;         target != address(0) &amp;&amp;         target != _hypervisor.stakingToken &amp;&amp;         target != _hypervisor.rewardToken &amp;&amp;         target != _hypervisor.rewardPool &amp;&amp;         !_bonusTokenSet.contains(target); }  /* Hypervisor getters */  function getHypervisorData() external view override returns (HypervisorData memory hypervisor) {     return _hypervisor; }  function getCurrentUnlockedRewards() public view override returns (uint256 unlockedRewards) {     // calculate reward available based on state     return getFutureUnlockedRewards(block.timestamp); }  function getFutureUnlockedRewards(uint256 timestamp)     public     view     override     returns (uint256 unlockedRewards) {     // get reward amount remaining     uint256 remainingRewards = IERC20(_hypervisor.rewardToken).balanceOf(_hypervisor.rewardPool);     // calculate reward available based on state     unlockedRewards = calculateUnlockedRewards(         _hypervisor.rewardSchedules,         remainingRewards,         _hypervisor.rewardSharesOutstanding,         timestamp     );     // explicit return     return unlockedRewards; }  function getCurrentTotalStakeUnits() public view override returns (uint256 totalStakeUnits) {     // calculate new stake units     return getFutureTotalStakeUnits(block.timestamp); }  function getFutureTotalStakeUnits(uint256 timestamp)     public     view     override     returns (uint256 totalStakeUnits) {     // return early if no change     if (timestamp == _hypervisor.lastUpdate) return _hypervisor.totalStakeUnits;     // calculate new stake units     uint256 newStakeUnits =         calculateStakeUnits(_hypervisor.totalStake, _hypervisor.lastUpdate, timestamp);     // add to cached total     totalStakeUnits = _hypervisor.totalStakeUnits.add(newStakeUnits);     // explicit return     return totalStakeUnits; }  /* vault getters */  function getVaultData(address vault)     external     view     override     returns (VaultData memory vaultData) {     return _vaults[vault]; }  function getCurrentVaultReward(address vault) external view override returns (uint256 reward) {     // calculate rewards     return         calculateRewardFromStakes(             _vaults[vault]                 .stakes,             _vaults[vault]                 .totalStake,             getCurrentUnlockedRewards(),             getCurrentTotalStakeUnits(),             block                 .timestamp,             _hypervisor                 .rewardScaling         )             .reward; }  function getFutureVaultReward(address vault, uint256 timestamp)     external     view     override     returns (uint256 reward) {     // calculate rewards     return         calculateRewardFromStakes(             _vaults[vault]                 .stakes,             _vaults[vault]                 .totalStake,             getFutureUnlockedRewards(timestamp),             getFutureTotalStakeUnits(timestamp),             timestamp,             _hypervisor                 .rewardScaling         )             .reward; }  function getCurrentStakeReward(address vault, uint256 stakeAmount)     external     view     override     returns (uint256 reward) {     // calculate rewards     return         calculateRewardFromStakes(             _vaults[vault]                 .stakes,             stakeAmount,             getCurrentUnlockedRewards(),             getCurrentTotalStakeUnits(),             block                 .timestamp,             _hypervisor                 .rewardScaling         )             .reward; }  function getFutureStakeReward(     address vault,     uint256 stakeAmount,     uint256 timestamp ) external view override returns (uint256 reward) {     // calculate rewards     return         calculateRewardFromStakes(             _vaults[vault]                 .stakes,             stakeAmount,             getFutureUnlockedRewards(timestamp),             getFutureTotalStakeUnits(timestamp),             timestamp,             _hypervisor                 .rewardScaling         )             .reward; }  function getCurrentVaultStakeUnits(address vault)     public     view     override     returns (uint256 stakeUnits) {     // calculate stake units     return getFutureVaultStakeUnits(vault, block.timestamp); }  function getFutureVaultStakeUnits(address vault, uint256 timestamp)     public     view     override     returns (uint256 stakeUnits) {     // calculate stake units     return calculateTotalStakeUnits(_vaults[vault].stakes, timestamp); }  /* pure functions */  function calculateTotalStakeUnits(StakeData[] memory stakes, uint256 timestamp)     public     pure     override     returns (uint256 totalStakeUnits) {     for (uint256 index; index &lt; stakes.length; index++) {         // reference stake         StakeData memory stakeData = stakes[index];         // calculate stake units         uint256 stakeUnits =             calculateStakeUnits(stakeData.amount, stakeData.timestamp, timestamp);         // add to running total         totalStakeUnits = totalStakeUnits.add(stakeUnits);     } }  function calculateStakeUnits(     uint256 amount,     uint256 start,     uint256 end ) public pure override returns (uint256 stakeUnits) {     // calculate duration     uint256 duration = end.sub(start);     // calculate stake units     stakeUnits = duration.mul(amount);     // explicit return     return stakeUnits; }  function calculateUnlockedRewards(     RewardSchedule[] memory rewardSchedules,     uint256 rewardBalance,     uint256 sharesOutstanding,     uint256 timestamp ) public pure override returns (uint256 unlockedRewards) {     // return 0 if no registered schedules     if (rewardSchedules.length == 0) {         return 0;     }      // calculate reward shares locked across all reward schedules     uint256 sharesLocked;     for (uint256 index = 0; index &lt; rewardSchedules.length; index++) {         // fetch reward schedule storage reference         RewardSchedule memory schedule = rewardSchedules[index];          // caculate amount of shares available on this schedule         // if (now - start) &lt; duration         //   sharesLocked = shares - (shares * (now - start) / duration)         // else         //   sharesLocked = 0         uint256 currentSharesLocked = 0;         if (timestamp.sub(schedule.start) &lt; schedule.duration) {             currentSharesLocked = schedule.shares.sub(                 schedule.shares.mul(timestamp.sub(schedule.start)).div(schedule.duration)             );         }          // add to running total         sharesLocked = sharesLocked.add(currentSharesLocked);     }      // convert shares to reward     // rewardLocked = sharesLocked * rewardBalance / sharesOutstanding     uint256 rewardLocked = sharesLocked.mul(rewardBalance).div(sharesOutstanding);      // calculate amount available     // unlockedRewards = rewardBalance - rewardLocked     unlockedRewards = rewardBalance.sub(rewardLocked);      // explicit return     return unlockedRewards; }  function calculateRewardFromStakes(     StakeData[] memory stakes,     uint256 unstakeAmount,     uint256 unlockedRewards,     uint256 totalStakeUnits,     uint256 timestamp,     RewardScaling memory rewardScaling ) public pure override returns (RewardOutput memory out) {     uint256 stakesToDrop = 0;     while (unstakeAmount &gt; 0) {         // fetch vault stake storage reference         StakeData memory lastStake = stakes[stakes.length.sub(stakesToDrop).sub(1)];          // calculate stake duration         uint256 stakeDuration = timestamp.sub(lastStake.timestamp);          uint256 currentAmount;         if (lastStake.amount &gt; unstakeAmount) {             // set current amount to remaining unstake amount             currentAmount = unstakeAmount;             // amount of last stake is reduced             out.lastStakeAmount = lastStake.amount.sub(unstakeAmount);         } else {             // set current amount to amount of last stake             currentAmount = lastStake.amount;             // add to stakes to drop             stakesToDrop += 1;         }          // update remaining unstakeAmount         unstakeAmount = unstakeAmount.sub(currentAmount);          // calculate reward amount         uint256 currentReward =             calculateReward(                 unlockedRewards,                 currentAmount,                 stakeDuration,                 totalStakeUnits,                 rewardScaling             );          // update cumulative reward         out.reward = out.reward.add(currentReward);          // update cached unlockedRewards         unlockedRewards = unlockedRewards.sub(currentReward);          // calculate time weighted stake         uint256 stakeUnits = currentAmount.mul(stakeDuration);          // update cached totalStakeUnits         totalStakeUnits = totalStakeUnits.sub(stakeUnits);     }      // explicit return     return         RewardOutput(             out.lastStakeAmount,             stakes.length.sub(stakesToDrop),             out.reward,             totalStakeUnits         ); }  function calculateReward(     uint256 unlockedRewards,     uint256 stakeAmount,     uint256 stakeDuration,     uint256 totalStakeUnits,     RewardScaling memory rewardScaling ) public pure override returns (uint256 reward) {     // calculate time weighted stake     uint256 stakeUnits = stakeAmount.mul(stakeDuration);      // calculate base reward     // baseReward = unlockedRewards * stakeUnits / totalStakeUnits     uint256 baseReward = 0;     if (totalStakeUnits != 0) {         // scale reward according to proportional weight         baseReward = unlockedRewards.mul(stakeUnits).div(totalStakeUnits);     }      // calculate scaled reward     // if no scaling or scaling period completed     //   reward = baseReward     // else     //   minReward = baseReward * scalingFloor / scalingCeiling     //   bonusReward = baseReward     //                 * (scalingCeiling - scalingFloor) / scalingCeiling     //                 * duration / scalingTime     //   reward = minReward + bonusReward     if (stakeDuration &gt;= rewardScaling.time || rewardScaling.floor == rewardScaling.ceiling) {         // no reward scaling applied         reward = baseReward;     } else {         // calculate minimum reward using scaling floor         uint256 minReward = baseReward.mul(rewardScaling.floor).div(rewardScaling.ceiling);          // calculate bonus reward with vested portion of scaling factor         uint256 bonusReward =             baseReward                 .mul(stakeDuration)                 .mul(rewardScaling.ceiling.sub(rewardScaling.floor))                 .div(rewardScaling.ceiling)                 .div(rewardScaling.time);          // add minimum reward and bonus reward         reward = minReward.add(bonusReward);     }      // explicit return     return reward; }  /* admin functions */  /// @notice Add funds to the Hypervisor /// access control: only admin /// state machine: ///   - can be called multiple times ///   - only online /// state scope: ///   - increase _hypervisor.rewardSharesOutstanding ///   - append to _hypervisor.rewardSchedules /// token transfer: transfer staking tokens from msg.sender to reward pool /// @param amount uint256 Amount of reward tokens to deposit /// @param duration uint256 Duration over which to linearly unlock rewards function fund(uint256 amount, uint256 duration) external onlyOwner onlyOnline {     // validate duration     require(duration != 0, ""Hypervisor: invalid duration"");      // create new reward shares     // if existing rewards on this Hypervisor     //   mint new shares proportional to % change in rewards remaining     //   newShares = remainingShares * newReward / remainingRewards     // else     //   mint new shares with BASE_SHARES_PER_WEI initial conversion rate     //   store as fixed point number with same  of decimals as reward token     uint256 newRewardShares;     if (_hypervisor.rewardSharesOutstanding &gt; 0) {         uint256 remainingRewards = IERC20(_hypervisor.rewardToken).balanceOf(_hypervisor.rewardPool);         newRewardShares = _hypervisor.rewardSharesOutstanding.mul(amount).div(remainingRewards);     } else {         newRewardShares = amount.mul(BASE_SHARES_PER_WEI);     }      // add reward shares to total     _hypervisor.rewardSharesOutstanding = _hypervisor.rewardSharesOutstanding.add(newRewardShares);      // store new reward schedule     _hypervisor.rewardSchedules.push(RewardSchedule(duration, block.timestamp, newRewardShares));      // transfer reward tokens to reward pool     TransferHelper.safeTransferFrom(         _hypervisor.rewardToken,         msg.sender,         _hypervisor.rewardPool,         amount     );      // emit event     emit HypervisorFunded(amount, duration); }  /// @notice Add vault factory to whitelist /// @dev use this function to enable stakes to vaults coming from the specified ///      factory contract /// access control: only admin /// state machine: ///   - can be called multiple times ///   - not shutdown /// state scope: ///   - append to _vaultFactorySet /// token transfer: none /// @param factory address The address of the vault factory function registerVaultFactory(address factory) external onlyOwner notShutdown {     // add factory to set     require(_vaultFactorySet.add(factory), ""Hypervisor: vault factory already registered"");      // emit event     emit VaultFactoryRegistered(factory); }  /// @notice Remove vault factory from whitelist /// @dev use this function to disable new stakes to vaults coming from the specified ///      factory contract. ///      note: vaults with existing stakes from this factory are sill able to unstake /// access control: only admin /// state machine: ///   - can be called multiple times ///   - not shutdown /// state scope: ///   - remove from _vaultFactorySet /// token transfer: none /// @param factory address The address of the vault factory function removeVaultFactory(address factory) external onlyOwner notShutdown {     // remove factory from set     require(_vaultFactorySet.remove(factory), ""Hypervisor: vault factory not registered"");      // emit event     emit VaultFactoryRemoved(factory); }  /// @notice Register bonus token for distribution /// @dev use this function to enable distribution of any ERC20 held by the RewardPool contract /// access control: only admin /// state machine: ///   - can be called multiple times ///   - only online /// state scope: ///   - append to _bonusTokenSet /// token transfer: none /// @param bonusToken address The address of the bonus token function registerBonusToken(address bonusToken) external onlyOwner onlyOnline {     // verify valid bonus token     _validateAddress(bonusToken);      // verify bonus token count     require(_bonusTokenSet.length() &lt; MAX_REWARD_TOKENS, ""Hypervisor: max bonus tokens reached "");      // add token to set     assert(_bonusTokenSet.add(bonusToken));      // emit event     emit BonusTokenRegistered(bonusToken); }  /// @notice Rescue tokens from RewardPool /// @dev use this function to rescue tokens from RewardPool contract ///      without distributing to stakers or triggering emergency shutdown /// access control: only admin /// state machine: ///   - can be called multiple times ///   - only online /// state scope: none /// token transfer: transfer requested token from RewardPool to recipient /// @param token address The address of the token to rescue /// @param recipient address The address of the recipient /// @param amount uint256 The amount of tokens to rescue function rescueTokensFromRewardPool(     address token,     address recipient,     uint256 amount ) external onlyOwner onlyOnline {     // verify recipient     _validateAddress(recipient);      // check not attempting to unstake reward token     require(token != _hypervisor.rewardToken, ""Hypervisor: invalid address"");      // check not attempting to wthdraw bonus token     require(!_bonusTokenSet.contains(token), ""Hypervisor: invalid address"");      // transfer tokens to recipient     IRewardPool(_hypervisor.rewardPool).sendERC20(token, recipient, amount); }  /* user functions */  /// @notice Stake tokens /// @dev anyone can stake to any vault if they have valid permission /// access control: anyone /// state machine: ///   - can be called multiple times ///   - only online ///   - when vault exists on this Hypervisor /// state scope: ///   - append to _vaults[vault].stakes ///   - increase _vaults[vault].totalStake ///   - increase _hypervisor.totalStake ///   - increase _hypervisor.totalStakeUnits ///   - increase _hypervisor.lastUpdate /// token transfer: transfer staking tokens from msg.sender to vault /// @param vault address The address of the vault to stake from /// @param amount uint256 The amount of staking tokens to stake function stake(     address vault,     uint256 amount,     bytes calldata permission ) external override onlyOnline {     // verify vault is valid     require(isValidVault(vault), ""Hypervisor: vault is not registered"");      // verify non-zero amount     require(amount != 0, ""Hypervisor: no amount staked"");      // fetch vault storage reference     VaultData storage vaultData = _vaults[vault];      // verify stakes boundary not reached     require(         vaultData.stakes.length &lt; MAX_STAKES_PER_VAULT,         ""Hypervisor: MAX_STAKES_PER_VAULT reached""     );      // update cached sum of stake units across all vaults     _updateTotalStakeUnits();      // store amount and timestamp     vaultData.stakes.push(StakeData(amount, block.timestamp));      // update cached total vault and Hypervisor amounts     vaultData.totalStake = vaultData.totalStake.add(amount);     // verify stake quantity without bounds     require(         stakeLimit == 0 || vaultData.totalStake &lt;= stakeLimit,         ""Hypervisor: Stake limit exceeded""     );     _hypervisor.totalStake = _hypervisor.totalStake.add(amount);      // call lock on vault     IUniversalVault(vault).lock(_hypervisor.stakingToken, amount, permission);      // emit event     emit Staked(vault, amount); }  /// @notice Unstake staking tokens and claim reward /// @dev rewards can only be claimed when unstaking /// access control: only owner of vault /// state machine: ///   - when vault exists on this Hypervisor ///   - after stake from vault ///   - can be called multiple times while sufficient stake remains ///   - only online /// state scope: ///   - decrease _hypervisor.rewardSharesOutstanding ///   - decrease _hypervisor.totalStake ///   - increase _hypervisor.lastUpdate ///   - modify _hypervisor.totalStakeUnits ///   - modify _vaults[vault].stakes ///   - decrease _vaults[vault].totalStake /// token transfer: ///   - transfer reward tokens from reward pool to recipient ///   - transfer bonus tokens from reward pool to recipient /// @param vault address The vault to unstake from /// @param amount uint256 The amount of staking tokens to unstake function unstakeAndClaim(     address vault,     uint256 amount,     bytes calldata permission ) external override onlyOnline {     // fetch vault storage reference     VaultData storage vaultData = _vaults[vault];      // verify non-zero amount     require(amount != 0, ""Hypervisor: no amount unstaked"");      address recipient = IUniversalVault(vault).owner();      // validate recipient     _validateAddress(recipient);      // check for sufficient vault stake amount     require(vaultData.totalStake &gt;= amount, ""Hypervisor: insufficient vault stake"");      // check for sufficient Hypervisor stake amount     // if this check fails, there is a bug in stake accounting     assert(_hypervisor.totalStake &gt;= amount);      // update cached sum of stake units across all vaults     _updateTotalStakeUnits();      // get reward amount remaining     uint256 remainingRewards = IERC20(_hypervisor.rewardToken).balanceOf(_hypervisor.rewardPool);      // calculate vested portion of reward pool     uint256 unlockedRewards =         calculateUnlockedRewards(             _hypervisor.rewardSchedules,             remainingRewards,             _hypervisor.rewardSharesOutstanding,             block.timestamp         );      // calculate vault time weighted reward with scaling     RewardOutput memory out =         calculateRewardFromStakes(             vaultData.stakes,             amount,             unlockedRewards,             _hypervisor.totalStakeUnits,             block.timestamp,             _hypervisor.rewardScaling         );      // update stake data in storage     if (out.newStakesCount == 0) {         // all stakes have been unstaked         delete vaultData.stakes;     } else {         // some stakes have been completely or partially unstaked         // delete fully unstaked stakes         while (vaultData.stakes.length &gt; out.newStakesCount) vaultData.stakes.pop();         // update partially unstaked stake         vaultData.stakes[out.newStakesCount.sub(1)].amount = out.lastStakeAmount;     }      // update cached stake totals     vaultData.totalStake = vaultData.totalStake.sub(amount);     _hypervisor.totalStake = _hypervisor.totalStake.sub(amount);     _hypervisor.totalStakeUnits = out.newTotalStakeUnits;      // unlock staking tokens from vault     IUniversalVault(vault).unlock(_hypervisor.stakingToken, amount, permission);      // emit event     emit Unstaked(vault, amount);      // only perform on non-zero reward     if (out.reward &gt; 0) {         // calculate shares to burn         // sharesToBurn = sharesOutstanding * reward / remainingRewards         uint256 sharesToBurn =             _hypervisor.rewardSharesOutstanding.mul(out.reward).div(remainingRewards);          // burn claimed shares         _hypervisor.rewardSharesOutstanding = _hypervisor.rewardSharesOutstanding.sub(sharesToBurn);          // transfer bonus tokens from reward pool to recipient         if (_bonusTokenSet.length() &gt; 0) {             for (uint256 index = 0; index &lt; _bonusTokenSet.length(); index++) {                 // fetch bonus token address reference                 address bonusToken = _bonusTokenSet.at(index);                  // calculate bonus token amount                 // bonusAmount = bonusRemaining * reward / remainingRewards                 uint256 bonusAmount =                     IERC20(bonusToken).balanceOf(_hypervisor.rewardPool).mul(out.reward).div(                         remainingRewards                     );                  // transfer bonus token                 IRewardPool(_hypervisor.rewardPool).sendERC20(bonusToken, recipient, bonusAmount);                  // emit event                 emit RewardClaimed(vault, recipient, bonusToken, bonusAmount);             }         }          // transfer reward tokens from reward pool to recipient         IRewardPool(_hypervisor.rewardPool).sendERC20(_hypervisor.rewardToken, recipient, out.reward);          // emit event         emit RewardClaimed(vault, recipient, _hypervisor.rewardToken, out.reward);     } }  /// @notice Exit Hypervisor without claiming reward /// @dev This function should never revert when correctly called by the vault. ///      A max number of stakes per vault is set with MAX_STAKES_PER_VAULT to ///      place an upper bound on the for loop in calculateTotalStakeUnits(). /// access control: only callable by the vault directly /// state machine: ///   - when vault exists on this Hypervisor ///   - when active stake from this vault ///   - any power state /// state scope: ///   - decrease _hypervisor.totalStake ///   - increase _hypervisor.lastUpdate ///   - modify _hypervisor.totalStakeUnits ///   - delete _vaults[vault] /// token transfer: none function rageQuit() external override {     // fetch vault storage reference     VaultData storage _vaultData = _vaults[msg.sender];      // revert if no active stakes     require(_vaultData.stakes.length != 0, ""Hypervisor: no stake"");      // update cached sum of stake units across all vaults     _updateTotalStakeUnits();      // emit event     emit Unstaked(msg.sender, _vaultData.totalStake);      // update cached totals     _hypervisor.totalStake = _hypervisor.totalStake.sub(_vaultData.totalStake);     _hypervisor.totalStakeUnits = _hypervisor.totalStakeUnits.sub(         calculateTotalStakeUnits(_vaultData.stakes, block.timestamp)     );      // delete stake data     delete _vaults[msg.sender]; }  /* convenience functions */  function _updateTotalStakeUnits() private {     // update cached totalStakeUnits     _hypervisor.totalStakeUnits = getCurrentTotalStakeUnits();     // update cached lastUpdate     _hypervisor.lastUpdate = block.timestamp; }  function _validateAddress(address target) private view {     // sanity check target for potential input errors     require(isValidAddress(target), ""Hypervisor: invalid address""); }  function _truncateStakesArray(StakeData[] memory array, uint256 newLength)     private     pure     returns (StakeData[] memory newArray) {     newArray = new StakeData[](newLength);     for (uint256 index = 0; index &lt; newLength; index++) {         newArray[index] = array[index];     }     return newArray; }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: ""{task}"". Ideas: ""{ideas}"". As the {assistant_role}, your primary objective is to perform a thorough and detailed inspection of the provided contract code, with a particular focus on identifying vulnerabilities related to the Lack of Withdrawal Function. Your analysis should determine if the contract provides a secure method for users to withdraw their funds. Proceed with the following steps in your analysis: 1. Scrutinize the contract's code to determine if there is a function that allows users to withdraw their deposited funds. 2. Scan the contract for any functions related to withdrawing Ether or other assets. Document each instance and investigate the logic to ensure it is implemented securely. 3. Evaluate whether the withdrawal function, if present, follows best practices to prevent common vulnerabilities such as reentrancy attacks. Ensure it uses the Checks-Effects-Interactions pattern. 4. If no withdrawal function is found, assess the impact on users who have deposited funds into the contract. Highlight the importance of having a secure withdrawal mechanism. If you discover a lack of a withdrawal function, respond with: "" Lack of Withdrawal Function Identified."" For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE ''' DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code ''' If a secure withdrawal function is found and no issues are identified, respond only with: "" Withdrawal Function Present and Secure."" |
| **phase_name** | WithdrawalFunctionDetector |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 1, 'modification_conclusion': '', 'cycle_index': 1, 'task': '// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport {SafeMath} from ""@openzeppelin/contracts/math/SafeMath.sol"";\nimport {EnumerableSet} from ""@openzeppelin/contracts/utils/EnumerableSet.sol"";\nimport {IERC20} from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";\nimport {Ownable} from ""@openzeppelin/contracts/access/Ownable.sol"";\nimport {TransferHelper} from ""@uniswap/lib/contracts/libraries/TransferHelper.sol"";\n\nimport {IFactory} from ""../factory/IFactory.sol"";\nimport {IInstanceRegistry} from ""../factory/InstanceRegistry.sol"";\nimport {IUniversalVault} from ""../visor/Visor.sol"";\nimport {IRewardPool} from ""./RewardPool.sol"";\nimport {Powered} from ""./Powered.sol"";\n\ninterface IRageQuit {\n    function rageQuit() external;\n}\n\ninterface IHypervisor is IRageQuit {\n    / admin events /\n\n    event HypervisorCreated(address rewardPool, address powerSwitch);\n    event HypervisorFunded(uint256 amount, uint256 duration);\n    event BonusTokenRegistered(address token);\n    event VaultFactoryRegistered(address factory);\n    event VaultFactoryRemoved(address factory);\n\n    / user events /\n\n    event Staked(address vault, uint256 amount);\n    event Unstaked(address vault, uint256 amount);\n    event RewardClaimed(address vault, address recipient, address token, uint256 amount);\n\n    / data types /\n\n    struct HypervisorData {\n        address stakingToken;\n        address rewardToken;\n        address rewardPool;\n        RewardScaling rewardScaling;\n        uint256 rewardSharesOutstanding;\n        uint256 totalStake;\n        uint256 totalStakeUnits;\n        uint256 lastUpdate;\n        RewardSchedule[] rewardSchedules;\n    }\n\n    struct RewardSchedule {\n        uint256 duration;\n        uint256 start;\n        uint256 shares;\n    }\n\n    struct VaultData {\n        uint256 totalStake;\n        StakeData[] stakes;\n    }\n\n    struct StakeData {\n        uint256 amount;\n        uint256 timestamp;\n    }\n\n    struct RewardScaling {\n        uint256 floor;\n        uint256 ceiling;\n        uint256 time;\n    }\n\n    struct RewardOutput {\n        uint256 lastStakeAmount;\n        uint256 newStakesCount;\n        uint256 reward;\n        uint256 newTotalStakeUnits;\n    }\n\n    / user functions /\n\n    function stake(\n        address vault,\n        uint256 amount,\n        bytes calldata permission\n    ) external;\n\n    function unstakeAndClaim(\n        address vault,\n        uint256 amount,\n        bytes calldata permission\n    ) external;\n\n    / getter functions /\n\n    function getHypervisorData() external view returns (HypervisorData memory hypervisor);\n\n    function getBonusTokenSetLength() external view returns (uint256 length);\n\n    function getBonusTokenAtIndex(uint256 index) external view returns (address bonusToken);\n\n    function getVaultFactorySetLength() external view returns (uint256 length);\n\n    function getVaultFactoryAtIndex(uint256 index) external view returns (address factory);\n\n    function getVaultData(address vault) external view returns (VaultData memory vaultData);\n\n    function isValidAddress(address target) external view returns (bool validity);\n\n    function isValidVault(address target) external view returns (bool validity);\n\n    function getCurrentUnlockedRewards() external view returns (uint256 unlockedRewards);\n\n    function getFutureUnlockedRewards(uint256 timestamp)\n        external\n        view\n        returns (uint256 unlockedRewards);\n\n    function getCurrentVaultReward(address vault) external view returns (uint256 reward);\n\n    function getCurrentStakeReward(address vault, uint256 stakeAmount)\n        external\n        view\n        returns (uint256 reward);\n\n    function getFutureVaultReward(address vault, uint256 timestamp)\n        external\n        view\n        returns (uint256 reward);\n\n    function getFutureStakeReward(\n        address vault,\n        uint256 stakeAmount,\n        uint256 timestamp\n    ) external view returns (uint256 reward);\n\n    function getCurrentVaultStakeUnits(address vault) external view returns (uint256 stakeUnits);\n\n    function getFutureVaultStakeUnits(address vault, uint256 timestamp)\n        external\n        view\n        returns (uint256 stakeUnits);\n\n    function getCurrentTotalStakeUnits() external view returns (uint256 totalStakeUnits);\n\n    function getFutureTotalStakeUnits(uint256 timestamp)\n        external\n        view\n        returns (uint256 totalStakeUnits);\n\n    / pure functions /\n\n    function calculateTotalStakeUnits(StakeData[] memory stakes, uint256 timestamp)\n        external\n        pure\n        returns (uint256 totalStakeUnits);\n\n    function calculateStakeUnits(\n        uint256 amount,\n        uint256 start,\n        uint256 end\n    ) external pure returns (uint256 stakeUnits);\n\n    function calculateUnlockedRewards(\n        RewardSchedule[] memory rewardSchedules,\n        uint256 rewardBalance,\n        uint256 sharesOutstanding,\n        uint256 timestamp\n    ) external pure returns (uint256 unlockedRewards);\n\n    function calculateRewardFromStakes(\n        StakeData[] memory stakes,\n        uint256 unstakeAmount,\n        uint256 unlockedRewards,\n        uint256 totalStakeUnits,\n        uint256 timestamp,\n        RewardScaling memory rewardScaling\n    ) external pure returns (RewardOutput memory out);\n\n    function calculateReward(\n        uint256 unlockedRewards,\n        uint256 stakeAmount,\n        uint256 stakeDuration,\n        uint256 totalStakeUnits,\n        RewardScaling memory rewardScaling\n    ) external pure returns (uint256 reward);\n}\n\n/// @title Hypervisor\n/// @notice Reward distribution contract with time multiplier\n/// Access Control\n/// - Power controller:\n///     Can power off / shutdown the Hypervisor\n///     Can withdraw rewards from reward pool once shutdown\n/// - Proxy owner:\n///     Can change arbitrary logic / state by upgrading the Hypervisor\n///     Is unable to operate on user funds due to UniversalVault\n///     Is unable to operate on reward pool funds when reward pool is offline / shutdown\n/// - Hypervisor admin:\n///     Can add funds to the Hypervisor, register bonus tokens, and whitelist new vault factories\n///     Is a subset of proxy owner permissions\n/// - User:\n///     Can deposit / withdraw / ragequit\n/// Hypervisor State Machine\n/// - Online:\n///     Hypervisor is operating normally, all functions are enabled\n/// - Offline:\n///     Hypervisor is temporarely disabled for maintenance\n///     User deposits and withdrawls are disabled, ragequit remains enabled\n///     Users can withdraw their stake through rageQuit() but forego their pending reward\n///     Should only be used when downtime required for an upgrade\n/// - Shutdown:\n///     Hypervisor is permanently disabled\n///     All functions are disabled with the exception of ragequit\n///     Users can withdraw their stake through rageQuit()\n///     Power controller can withdraw from the reward pool\n///     Should only be used if Proxy Owner role is compromized\ncontract Hypervisor is IHypervisor, Powered, Ownable {\n    using SafeMath for uint256;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    / constants /\n\n    // An upper bound on the number of active stakes per vault is required to prevent\n    // calls to rageQuit() from reverting.\n    // With 30 stakes in a vault, ragequit costs 432811 gas which is conservatively lower\n    // than the hardcoded limit of 500k gas on the vault.\n    // This limit is configurable and could be increased in a future deployment.\n    // Ultimately, to avoid a need for fixed upper bounds, the EVM would need to provide\n    // an error code that allows for reliably catching out-of-gas errors on remote calls.\n    uint256 public constant MAX_STAKES_PER_VAULT = 30;\n    uint256 public constant MAX_REWARD_TOKENS = 50;\n    uint256 public constant BASE_SHARES_PER_WEI = 1000000;\n    uint256 public stakeLimit = 2500 ether;\n\n    / storage /\n\n    HypervisorData private _hypervisor;\n    mapping(address =&gt; VaultData) private _vaults;\n    EnumerableSet.AddressSet private _bonusTokenSet;\n    EnumerableSet.AddressSet private _vaultFactorySet;\n\n    / initializer /\n\n    /// @notice Initizalize Hypervisor\n    /// access control: only proxy constructor\n    /// state machine: can only be called once\n    /// state scope: set initialization variables\n    /// token transfer: none\n    /// @param ownerAddress address The admin address\n    /// @param rewardPoolFactory address The factory to use for deploying the RewardPool\n    /// @param powerSwitchFactory address The factory to use for deploying the PowerSwitch\n    /// @param stakingToken address The address of the staking token for this Hypervisor\n    /// @param rewardToken address The address of the reward token for this Hypervisor\n    /// @param rewardScaling RewardScaling The config for reward scaling floor, ceiling, and time\n    constructor(\n        address ownerAddress,\n        address rewardPoolFactory,\n        address powerSwitchFactory,\n        address stakingToken,\n        address rewardToken,\n        RewardScaling memory rewardScaling,\n        uint256 _stakeLimit\n    ) {\n        // the scaling floor must be smaller than ceiling\n        require(rewardScaling.floor &lt;= rewardScaling.ceiling, ""Hypervisor: floor above ceiling"");\n\n        // setting rewardScalingTime to 0 would cause divide by zero error\n        // to disable reward scaling, use rewardScalingFloor == rewardScalingCeiling\n        require(rewardScaling.time != 0, ""Hypervisor: scaling time cannot be zero"");\n\n        // deploy power switch\n        address powerSwitch = IFactory(powerSwitchFactory).create(abi.encode(ownerAddress));\n\n        // deploy reward pool\n        address rewardPool = IFactory(rewardPoolFactory).create(abi.encode(powerSwitch));\n\n        // set internal configs\n        Ownable.transferOwnership(ownerAddress);\n        Powered._setPowerSwitch(powerSwitch);\n\n        // commit to storage\n        _hypervisor.stakingToken = stakingToken;\n        _hypervisor.rewardToken = rewardToken;\n        _hypervisor.rewardPool = rewardPool;\n        _hypervisor.rewardScaling = rewardScaling;\n\n        stakeLimit = _stakeLimit;\n\n        // emit event\n        emit HypervisorCreated(rewardPool, powerSwitch);\n    }\n\n    / getter functions /\n\n    function getBonusTokenSetLength() external view override returns (uint256 length) {\n        return _bonusTokenSet.length();\n    }\n\n    function getBonusTokenAtIndex(uint256 index)\n        external\n        view\n        override\n        returns (address bonusToken)\n    {\n        return _bonusTokenSet.at(index);\n    }\n\n    function getVaultFactorySetLength() external view override returns (uint256 length) {\n        return _vaultFactorySet.length();\n    }\n\n    function getVaultFactoryAtIndex(uint256 index)\n        external\n        view\n        override\n        returns (address factory)\n    {\n        return _vaultFactorySet.at(index);\n    }\n\n    function isValidVault(address target) public view override returns (bool validity) {\n        // validate target is created from whitelisted vault factory\n        for (uint256 index = 0; index &lt; _vaultFactorySet.length(); index++) {\n            if (IInstanceRegistry(_vaultFactorySet.at(index)).isInstance(target)) {\n                return true;\n            }\n        }\n        // explicit return\n        return false;\n    }\n\n    function isValidAddress(address target) public view override returns (bool validity) {\n        // sanity check target for potential input errors\n        return\n            target != address(this) &amp;&amp;\n            target != address(0) &amp;&amp;\n            target != _hypervisor.stakingToken &amp;&amp;\n            target != _hypervisor.rewardToken &amp;&amp;\n            target != _hypervisor.rewardPool &amp;&amp;\n            !_bonusTokenSet.contains(target);\n    }\n\n    / Hypervisor getters /\n\n    function getHypervisorData() external view override returns (HypervisorData memory hypervisor) {\n        return _hypervisor;\n    }\n\n    function getCurrentUnlockedRewards() public view override returns (uint256 unlockedRewards) {\n        // calculate reward available based on state\n        return getFutureUnlockedRewards(block.timestamp);\n    }\n\n    function getFutureUnlockedRewards(uint256 timestamp)\n        public\n        view\n        override\n        returns (uint256 unlockedRewards)\n    {\n        // get reward amount remaining\n        uint256 remainingRewards = IERC20(_hypervisor.rewardToken).balanceOf(_hypervisor.rewardPool);\n        // calculate reward available based on state\n        unlockedRewards = calculateUnlockedRewards(\n            _hypervisor.rewardSchedules,\n            remainingRewards,\n            _hypervisor.rewardSharesOutstanding,\n            timestamp\n        );\n        // explicit return\n        return unlockedRewards;\n    }\n\n    function getCurrentTotalStakeUnits() public view override returns (uint256 totalStakeUnits) {\n        // calculate new stake units\n        return getFutureTotalStakeUnits(block.timestamp);\n    }\n\n    function getFutureTotalStakeUnits(uint256 timestamp)\n        public\n        view\n        override\n        returns (uint256 totalStakeUnits)\n    {\n        // return early if no change\n        if (timestamp == _hypervisor.lastUpdate) return _hypervisor.totalStakeUnits;\n        // calculate new stake units\n        uint256 newStakeUnits =\n            calculateStakeUnits(_hypervisor.totalStake, _hypervisor.lastUpdate, timestamp);\n        // add to cached total\n        totalStakeUnits = _hypervisor.totalStakeUnits.add(newStakeUnits);\n        // explicit return\n        return totalStakeUnits;\n    }\n\n    / vault getters /\n\n    function getVaultData(address vault)\n        external\n        view\n        override\n        returns (VaultData memory vaultData)\n    {\n        return _vaults[vault];\n    }\n\n    function getCurrentVaultReward(address vault) external view override returns (uint256 reward) {\n        // calculate rewards\n        return\n            calculateRewardFromStakes(\n                _vaults[vault]\n                    .stakes,\n                _vaults[vault]\n                    .totalStake,\n                getCurrentUnlockedRewards(),\n                getCurrentTotalStakeUnits(),\n                block\n                    .timestamp,\n                _hypervisor\n                    .rewardScaling\n            )\n                .reward;\n    }\n\n    function getFutureVaultReward(address vault, uint256 timestamp)\n        external\n        view\n        override\n        returns (uint256 reward)\n    {\n        // calculate rewards\n        return\n            calculateRewardFromStakes(\n                _vaults[vault]\n                    .stakes,\n                _vaults[vault]\n                    .totalStake,\n                getFutureUnlockedRewards(timestamp),\n                getFutureTotalStakeUnits(timestamp),\n                timestamp,\n                _hypervisor\n                    .rewardScaling\n            )\n                .reward;\n    }\n\n    function getCurrentStakeReward(address vault, uint256 stakeAmount)\n        external\n        view\n        override\n        returns (uint256 reward)\n    {\n        // calculate rewards\n        return\n            calculateRewardFromStakes(\n                _vaults[vault]\n                    .stakes,\n                stakeAmount,\n                getCurrentUnlockedRewards(),\n                getCurrentTotalStakeUnits(),\n                block\n                    .timestamp,\n                _hypervisor\n                    .rewardScaling\n            )\n                .reward;\n    }\n\n    function getFutureStakeReward(\n        address vault,\n        uint256 stakeAmount,\n        uint256 timestamp\n    ) external view override returns (uint256 reward) {\n        // calculate rewards\n        return\n            calculateRewardFromStakes(\n                _vaults[vault]\n                    .stakes,\n                stakeAmount,\n                getFutureUnlockedRewards(timestamp),\n                getFutureTotalStakeUnits(timestamp),\n                timestamp,\n                _hypervisor\n                    .rewardScaling\n            )\n                .reward;\n    }\n\n    function getCurrentVaultStakeUnits(address vault)\n        public\n        view\n        override\n        returns (uint256 stakeUnits)\n    {\n        // calculate stake units\n        return getFutureVaultStakeUnits(vault, block.timestamp);\n    }\n\n    function getFutureVaultStakeUnits(address vault, uint256 timestamp)\n        public\n        view\n        override\n        returns (uint256 stakeUnits)\n    {\n        // calculate stake units\n        return calculateTotalStakeUnits(_vaults[vault].stakes, timestamp);\n    }\n\n    / pure functions /\n\n    function calculateTotalStakeUnits(StakeData[] memory stakes, uint256 timestamp)\n        public\n        pure\n        override\n        returns (uint256 totalStakeUnits)\n    {\n        for (uint256 index; index &lt; stakes.length; index++) {\n            // reference stake\n            StakeData memory stakeData = stakes[index];\n            // calculate stake units\n            uint256 stakeUnits =\n                calculateStakeUnits(stakeData.amount, stakeData.timestamp, timestamp);\n            // add to running total\n            totalStakeUnits = totalStakeUnits.add(stakeUnits);\n        }\n    }\n\n    function calculateStakeUnits(\n        uint256 amount,\n        uint256 start,\n        uint256 end\n    ) public pure override returns (uint256 stakeUnits) {\n        // calculate duration\n        uint256 duration = end.sub(start);\n        // calculate stake units\n        stakeUnits = duration.mul(amount);\n        // explicit return\n        return stakeUnits;\n    }\n\n    function calculateUnlockedRewards(\n        RewardSchedule[] memory rewardSchedules,\n        uint256 rewardBalance,\n        uint256 sharesOutstanding,\n        uint256 timestamp\n    ) public pure override returns (uint256 unlockedRewards) {\n        // return 0 if no registered schedules\n        if (rewardSchedules.length == 0) {\n            return 0;\n        }\n\n        // calculate reward shares locked across all reward schedules\n        uint256 sharesLocked;\n        for (uint256 index = 0; index &lt; rewardSchedules.length; index++) {\n            // fetch reward schedule storage reference\n            RewardSchedule memory schedule = rewardSchedules[index];\n\n            // caculate amount of shares available on this schedule\n            // if (now - start) &lt; duration\n            //   sharesLocked = shares - (shares * (now - start) / duration)\n            // else\n            //   sharesLocked = 0\n            uint256 currentSharesLocked = 0;\n            if (timestamp.sub(schedule.start) &lt; schedule.duration) {\n                currentSharesLocked = schedule.shares.sub(\n                    schedule.shares.mul(timestamp.sub(schedule.start)).div(schedule.duration)\n                );\n            }\n\n            // add to running total\n            sharesLocked = sharesLocked.add(currentSharesLocked);\n        }\n\n        // convert shares to reward\n        // rewardLocked = sharesLocked * rewardBalance / sharesOutstanding\n        uint256 rewardLocked = sharesLocked.mul(rewardBalance).div(sharesOutstanding);\n\n        // calculate amount available\n        // unlockedRewards = rewardBalance - rewardLocked\n        unlockedRewards = rewardBalance.sub(rewardLocked);\n\n        // explicit return\n        return unlockedRewards;\n    }\n\n    function calculateRewardFromStakes(\n        StakeData[] memory stakes,\n        uint256 unstakeAmount,\n        uint256 unlockedRewards,\n        uint256 totalStakeUnits,\n        uint256 timestamp,\n        RewardScaling memory rewardScaling\n    ) public pure override returns (RewardOutput memory out) {\n        uint256 stakesToDrop = 0;\n        while (unstakeAmount &gt; 0) {\n            // fetch vault stake storage reference\n            StakeData memory lastStake = stakes[stakes.length.sub(stakesToDrop).sub(1)];\n\n            // calculate stake duration\n            uint256 stakeDuration = timestamp.sub(lastStake.timestamp);\n\n            uint256 currentAmount;\n            if (lastStake.amount &gt; unstakeAmount) {\n                // set current amount to remaining unstake amount\n                currentAmount = unstakeAmount;\n                // amount of last stake is reduced\n                out.lastStakeAmount = lastStake.amount.sub(unstakeAmount);\n            } else {\n                // set current amount to amount of last stake\n                currentAmount = lastStake.amount;\n                // add to stakes to drop\n                stakesToDrop += 1;\n            }\n\n            // update remaining unstakeAmount\n            unstakeAmount = unstakeAmount.sub(currentAmount);\n\n            // calculate reward amount\n            uint256 currentReward =\n                calculateReward(\n                    unlockedRewards,\n                    currentAmount,\n                    stakeDuration,\n                    totalStakeUnits,\n                    rewardScaling\n                );\n\n            // update cumulative reward\n            out.reward = out.reward.add(currentReward);\n\n            // update cached unlockedRewards\n            unlockedRewards = unlockedRewards.sub(currentReward);\n\n            // calculate time weighted stake\n            uint256 stakeUnits = currentAmount.mul(stakeDuration);\n\n            // update cached totalStakeUnits\n            totalStakeUnits = totalStakeUnits.sub(stakeUnits);\n        }\n\n        // explicit return\n        return\n            RewardOutput(\n                out.lastStakeAmount,\n                stakes.length.sub(stakesToDrop),\n                out.reward,\n                totalStakeUnits\n            );\n    }\n\n    function calculateReward(\n        uint256 unlockedRewards,\n        uint256 stakeAmount,\n        uint256 stakeDuration,\n        uint256 totalStakeUnits,\n        RewardScaling memory rewardScaling\n    ) public pure override returns (uint256 reward) {\n        // calculate time weighted stake\n        uint256 stakeUnits = stakeAmount.mul(stakeDuration);\n\n        // calculate base reward\n        // baseReward = unlockedRewards * stakeUnits / totalStakeUnits\n        uint256 baseReward = 0;\n        if (totalStakeUnits != 0) {\n            // scale reward according to proportional weight\n            baseReward = unlockedRewards.mul(stakeUnits).div(totalStakeUnits);\n        }\n\n        // calculate scaled reward\n        // if no scaling or scaling period completed\n        //   reward = baseReward\n        // else\n        //   minReward = baseReward * scalingFloor / scalingCeiling\n        //   bonusReward = baseReward\n        //                 * (scalingCeiling - scalingFloor) / scalingCeiling\n        //                 * duration / scalingTime\n        //   reward = minReward + bonusReward\n        if (stakeDuration &gt;= rewardScaling.time || rewardScaling.floor == rewardScaling.ceiling) {\n            // no reward scaling applied\n            reward = baseReward;\n        } else {\n            // calculate minimum reward using scaling floor\n            uint256 minReward = baseReward.mul(rewardScaling.floor).div(rewardScaling.ceiling);\n\n            // calculate bonus reward with vested portion of scaling factor\n            uint256 bonusReward =\n                baseReward\n                    .mul(stakeDuration)\n                    .mul(rewardScaling.ceiling.sub(rewardScaling.floor))\n                    .div(rewardScaling.ceiling)\n                    .div(rewardScaling.time);\n\n            // add minimum reward and bonus reward\n            reward = minReward.add(bonusReward);\n        }\n\n        // explicit return\n        return reward;\n    }\n\n    / admin functions /\n\n    /// @notice Add funds to the Hypervisor\n    /// access control: only admin\n    /// state machine:\n    ///   - can be called multiple times\n    ///   - only online\n    /// state scope:\n    ///   - increase _hypervisor.rewardSharesOutstanding\n    ///   - append to _hypervisor.rewardSchedules\n    /// token transfer: transfer staking tokens from msg.sender to reward pool\n    /// @param amount uint256 Amount of reward tokens to deposit\n    /// @param duration uint256 Duration over which to linearly unlock rewards\n    function fund(uint256 amount, uint256 duration) external onlyOwner onlyOnline {\n        // validate duration\n        require(duration != 0, ""Hypervisor: invalid duration"");\n\n        // create new reward shares\n        // if existing rewards on this Hypervisor\n        //   mint new shares proportional to % change in rewards remaining\n        //   newShares = remainingShares * newReward / remainingRewards\n        // else\n        //   mint new shares with BASE_SHARES_PER_WEI initial conversion rate\n        //   store as fixed point number with same  of decimals as reward token\n        uint256 newRewardShares;\n        if (_hypervisor.rewardSharesOutstanding &gt; 0) {\n            uint256 remainingRewards = IERC20(_hypervisor.rewardToken).balanceOf(_hypervisor.rewardPool);\n            newRewardShares = _hypervisor.rewardSharesOutstanding.mul(amount).div(remainingRewards);\n        } else {\n            newRewardShares = amount.mul(BASE_SHARES_PER_WEI);\n        }\n\n        // add reward shares to total\n        _hypervisor.rewardSharesOutstanding = _hypervisor.rewardSharesOutstanding.add(newRewardShares);\n\n        // store new reward schedule\n        _hypervisor.rewardSchedules.push(RewardSchedule(duration, block.timestamp, newRewardShares));\n\n        // transfer reward tokens to reward pool\n        TransferHelper.safeTransferFrom(\n            _hypervisor.rewardToken,\n            msg.sender,\n            _hypervisor.rewardPool,\n            amount\n        );\n\n        // emit event\n        emit HypervisorFunded(amount, duration);\n    }\n\n    /// @notice Add vault factory to whitelist\n    /// @dev use this function to enable stakes to vaults coming from the specified\n    ///      factory contract\n    /// access control: only admin\n    /// state machine:\n    ///   - can be called multiple times\n    ///   - not shutdown\n    /// state scope:\n    ///   - append to _vaultFactorySet\n    /// token transfer: none\n    /// @param factory address The address of the vault factory\n    function registerVaultFactory(address factory) external onlyOwner notShutdown {\n        // add factory to set\n        require(_vaultFactorySet.add(factory), ""Hypervisor: vault factory already registered"");\n\n        // emit event\n        emit VaultFactoryRegistered(factory);\n    }\n\n    /// @notice Remove vault factory from whitelist\n    /// @dev use this function to disable new stakes to vaults coming from the specified\n    ///      factory contract.\n    ///      note: vaults with existing stakes from this factory are sill able to unstake\n    /// access control: only admin\n    /// state machine:\n    ///   - can be called multiple times\n    ///   - not shutdown\n    /// state scope:\n    ///   - remove from _vaultFactorySet\n    /// token transfer: none\n    /// @param factory address The address of the vault factory\n    function removeVaultFactory(address factory) external onlyOwner notShutdown {\n        // remove factory from set\n        require(_vaultFactorySet.remove(factory), ""Hypervisor: vault factory not registered"");\n\n        // emit event\n        emit VaultFactoryRemoved(factory);\n    }\n\n    /// @notice Register bonus token for distribution\n    /// @dev use this function to enable distribution of any ERC20 held by the RewardPool contract\n    /// access control: only admin\n    /// state machine:\n    ///   - can be called multiple times\n    ///   - only online\n    /// state scope:\n    ///   - append to _bonusTokenSet\n    /// token transfer: none\n    /// @param bonusToken address The address of the bonus token\n    function registerBonusToken(address bonusToken) external onlyOwner onlyOnline {\n        // verify valid bonus token\n        _validateAddress(bonusToken);\n\n        // verify bonus token count\n        require(_bonusTokenSet.length() &lt; MAX_REWARD_TOKENS, ""Hypervisor: max bonus tokens reached "");\n\n        // add token to set\n        assert(_bonusTokenSet.add(bonusToken));\n\n        // emit event\n        emit BonusTokenRegistered(bonusToken);\n    }\n\n    /// @notice Rescue tokens from RewardPool\n    /// @dev use this function to rescue tokens from RewardPool contract\n    ///      without distributing to stakers or triggering emergency shutdown\n    /// access control: only admin\n    /// state machine:\n    ///   - can be called multiple times\n    ///   - only online\n    /// state scope: none\n    /// token transfer: transfer requested token from RewardPool to recipient\n    /// @param token address The address of the token to rescue\n    /// @param recipient address The address of the recipient\n    /// @param amount uint256 The amount of tokens to rescue\n    function rescueTokensFromRewardPool(\n        address token,\n        address recipient,\n        uint256 amount\n    ) external onlyOwner onlyOnline {\n        // verify recipient\n        _validateAddress(recipient);\n\n        // check not attempting to unstake reward token\n        require(token != _hypervisor.rewardToken, ""Hypervisor: invalid address"");\n\n        // check not attempting to wthdraw bonus token\n        require(!_bonusTokenSet.contains(token), ""Hypervisor: invalid address"");\n\n        // transfer tokens to recipient\n        IRewardPool(_hypervisor.rewardPool).sendERC20(token, recipient, amount);\n    }\n\n    / user functions /\n\n    /// @notice Stake tokens\n    /// @dev anyone can stake to any vault if they have valid permission\n    /// access control: anyone\n    /// state machine:\n    ///   - can be called multiple times\n    ///   - only online\n    ///   - when vault exists on this Hypervisor\n    /// state scope:\n    ///   - append to _vaults[vault].stakes\n    ///   - increase _vaults[vault].totalStake\n    ///   - increase _hypervisor.totalStake\n    ///   - increase _hypervisor.totalStakeUnits\n    ///   - increase _hypervisor.lastUpdate\n    /// token transfer: transfer staking tokens from msg.sender to vault\n    /// @param vault address The address of the vault to stake from\n    /// @param amount uint256 The amount of staking tokens to stake\n    function stake(\n        address vault,\n        uint256 amount,\n        bytes calldata permission\n    ) external override onlyOnline {\n        // verify vault is valid\n        require(isValidVault(vault), ""Hypervisor: vault is not registered"");\n\n        // verify non-zero amount\n        require(amount != 0, ""Hypervisor: no amount staked"");\n\n        // fetch vault storage reference\n        VaultData storage vaultData = _vaults[vault];\n\n        // verify stakes boundary not reached\n        require(\n            vaultData.stakes.length &lt; MAX_STAKES_PER_VAULT,\n            ""Hypervisor: MAX_STAKES_PER_VAULT reached""\n        );\n\n        // update cached sum of stake units across all vaults\n        _updateTotalStakeUnits();\n\n        // store amount and timestamp\n        vaultData.stakes.push(StakeData(amount, block.timestamp));\n\n        // update cached total vault and Hypervisor amounts\n        vaultData.totalStake = vaultData.totalStake.add(amount);\n        // verify stake quantity without bounds\n        require(\n            stakeLimit == 0 || vaultData.totalStake &lt;= stakeLimit,\n            ""Hypervisor: Stake limit exceeded""\n        );\n        _hypervisor.totalStake = _hypervisor.totalStake.add(amount);\n\n        // call lock on vault\n        IUniversalVault(vault).lock(_hypervisor.stakingToken, amount, permission);\n\n        // emit event\n        emit Staked(vault, amount);\n    }\n\n    /// @notice Unstake staking tokens and claim reward\n    /// @dev rewards can only be claimed when unstaking\n    /// access control: only owner of vault\n    /// state machine:\n    ///   - when vault exists on this Hypervisor\n    ///   - after stake from vault\n    ///   - can be called multiple times while sufficient stake remains\n    ///   - only online\n    /// state scope:\n    ///   - decrease _hypervisor.rewardSharesOutstanding\n    ///   - decrease _hypervisor.totalStake\n    ///   - increase _hypervisor.lastUpdate\n    ///   - modify _hypervisor.totalStakeUnits\n    ///   - modify _vaults[vault].stakes\n    ///   - decrease _vaults[vault].totalStake\n    /// token transfer:\n    ///   - transfer reward tokens from reward pool to recipient\n    ///   - transfer bonus tokens from reward pool to recipient\n    /// @param vault address The vault to unstake from\n    /// @param amount uint256 The amount of staking tokens to unstake\n    function unstakeAndClaim(\n        address vault,\n        uint256 amount,\n        bytes calldata permission\n    ) external override onlyOnline {\n        // fetch vault storage reference\n        VaultData storage vaultData = _vaults[vault];\n\n        // verify non-zero amount\n        require(amount != 0, ""Hypervisor: no amount unstaked"");\n\n        address recipient = IUniversalVault(vault).owner();\n\n        // validate recipient\n        _validateAddress(recipient);\n\n        // check for sufficient vault stake amount\n        require(vaultData.totalStake &gt;= amount, ""Hypervisor: insufficient vault stake"");\n\n        // check for sufficient Hypervisor stake amount\n        // if this check fails, there is a bug in stake accounting\n        assert(_hypervisor.totalStake &gt;= amount);\n\n        // update cached sum of stake units across all vaults\n        _updateTotalStakeUnits();\n\n        // get reward amount remaining\n        uint256 remainingRewards = IERC20(_hypervisor.rewardToken).balanceOf(_hypervisor.rewardPool);\n\n        // calculate vested portion of reward pool\n        uint256 unlockedRewards =\n            calculateUnlockedRewards(\n                _hypervisor.rewardSchedules,\n                remainingRewards,\n                _hypervisor.rewardSharesOutstanding,\n                block.timestamp\n            );\n\n        // calculate vault time weighted reward with scaling\n        RewardOutput memory out =\n            calculateRewardFromStakes(\n                vaultData.stakes,\n                amount,\n                unlockedRewards,\n                _hypervisor.totalStakeUnits,\n                block.timestamp,\n                _hypervisor.rewardScaling\n            );\n\n        // update stake data in storage\n        if (out.newStakesCount == 0) {\n            // all stakes have been unstaked\n            delete vaultData.stakes;\n        } else {\n            // some stakes have been completely or partially unstaked\n            // delete fully unstaked stakes\n            while (vaultData.stakes.length &gt; out.newStakesCount) vaultData.stakes.pop();\n            // update partially unstaked stake\n            vaultData.stakes[out.newStakesCount.sub(1)].amount = out.lastStakeAmount;\n        }\n\n        // update cached stake totals\n        vaultData.totalStake = vaultData.totalStake.sub(amount);\n        _hypervisor.totalStake = _hypervisor.totalStake.sub(amount);\n        _hypervisor.totalStakeUnits = out.newTotalStakeUnits;\n\n        // unlock staking tokens from vault\n        IUniversalVault(vault).unlock(_hypervisor.stakingToken, amount, permission);\n\n        // emit event\n        emit Unstaked(vault, amount);\n\n        // only perform on non-zero reward\n        if (out.reward &gt; 0) {\n            // calculate shares to burn\n            // sharesToBurn = sharesOutstanding * reward / remainingRewards\n            uint256 sharesToBurn =\n                _hypervisor.rewardSharesOutstanding.mul(out.reward).div(remainingRewards);\n\n            // burn claimed shares\n            _hypervisor.rewardSharesOutstanding = _hypervisor.rewardSharesOutstanding.sub(sharesToBurn);\n\n            // transfer bonus tokens from reward pool to recipient\n            if (_bonusTokenSet.length() &gt; 0) {\n                for (uint256 index = 0; index &lt; _bonusTokenSet.length(); index++) {\n                    // fetch bonus token address reference\n                    address bonusToken = _bonusTokenSet.at(index);\n\n                    // calculate bonus token amount\n                    // bonusAmount = bonusRemaining * reward / remainingRewards\n                    uint256 bonusAmount =\n                        IERC20(bonusToken).balanceOf(_hypervisor.rewardPool).mul(out.reward).div(\n                            remainingRewards\n                        );\n\n                    // transfer bonus token\n                    IRewardPool(_hypervisor.rewardPool).sendERC20(bonusToken, recipient, bonusAmount);\n\n                    // emit event\n                    emit RewardClaimed(vault, recipient, bonusToken, bonusAmount);\n                }\n            }\n\n            // transfer reward tokens from reward pool to recipient\n            IRewardPool(_hypervisor.rewardPool).sendERC20(_hypervisor.rewardToken, recipient, out.reward);\n\n            // emit event\n            emit RewardClaimed(vault, recipient, _hypervisor.rewardToken, out.reward);\n        }\n    }\n\n    /// @notice Exit Hypervisor without claiming reward\n    /// @dev This function should never revert when correctly called by the vault.\n    ///      A max number of stakes per vault is set with MAX_STAKES_PER_VAULT to\n    ///      place an upper bound on the for loop in calculateTotalStakeUnits().\n    /// access control: only callable by the vault directly\n    /// state machine:\n    ///   - when vault exists on this Hypervisor\n    ///   - when active stake from this vault\n    ///   - any power state\n    /// state scope:\n    ///   - decrease _hypervisor.totalStake\n    ///   - increase _hypervisor.lastUpdate\n    ///   - modify _hypervisor.totalStakeUnits\n    ///   - delete _vaults[vault]\n    /// token transfer: none\n    function rageQuit() external override {\n        // fetch vault storage reference\n        VaultData storage _vaultData = _vaults[msg.sender];\n\n        // revert if no active stakes\n        require(_vaultData.stakes.length != 0, ""Hypervisor: no stake"");\n\n        // update cached sum of stake units across all vaults\n        _updateTotalStakeUnits();\n\n        // emit event\n        emit Unstaked(msg.sender, _vaultData.totalStake);\n\n        // update cached totals\n        _hypervisor.totalStake = _hypervisor.totalStake.sub(_vaultData.totalStake);\n        _hypervisor.totalStakeUnits = _hypervisor.totalStakeUnits.sub(\n            calculateTotalStakeUnits(_vaultData.stakes, block.timestamp)\n        );\n\n        // delete stake data\n        delete _vaults[msg.sender];\n    }\n\n    / convenience functions /\n\n    function _updateTotalStakeUnits() private {\n        // update cached totalStakeUnits\n        _hypervisor.totalStakeUnits = getCurrentTotalStakeUnits();\n        // update cached lastUpdate\n        _hypervisor.lastUpdate = block.timestamp;\n    }\n\n    function _validateAddress(address target) private view {\n        // sanity check target for potential input errors\n        require(isValidAddress(target), ""Hypervisor: invalid address"");\n    }\n\n    function _truncateStakesArray(StakeData[] memory array, uint256 newLength)\n        private\n        pure\n        returns (StakeData[] memory newArray)\n    {\n        newArray = new StakeData;\n        for (uint256 index = 0; index &lt; newLength; index++) {\n            newArray[index] = array[index];\n        }\n        return newArray;\n    }\n}\n', 'ideas': "" Assumption of Fixed-Length Array Identified.\n\n``\nVULNERABILITY NAME: Assumption of Fixed-Length Array in calculateTotalStakeUnits\n'''\nDETAILED DESCRIPTION: The functioncalculateTotalStakeUnitsassumes that the length of thestakesarray is fixed and iterates through it using a for loop. If the length of thestakesarray is modified externally or if the array is empty, this could lead to out-of-bounds errors or incorrect calculations. The function does not check the length of the array before accessing its elements, which can lead to unintended behavior or data corruption.\n\nRECOMMENDED MITIGATION/FIX: Implement a check at the beginning of the function to ensure that thestakesarray is not empty before proceeding with the calculations. Additionally, consider using awhileloop that checks the current length dynamically to avoid assumptions about the array's length.\n'''\n\nVULNERABILITY NAME: Assumption of Fixed-Length Array in unstakeAndClaim\n'''\nDETAILED DESCRIPTION: In theunstake""} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-02-08 00:43:57 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **task_prompt** | // SPDX-License-Identifier: GPL-3.0-only pragma solidity 0.7.6; pragma abicoder v2; import {SafeMath} from ""@openzeppelin/contracts/math/SafeMath.sol""; import {EnumerableSet} from ""@openzeppelin/contracts/utils/EnumerableSet.sol""; import {IERC20} from ""@openzeppelin/contracts/token/ERC20/IERC20.sol""; import {Ownable} from ""@openzeppelin/contracts/access/Ownable.sol""; import {TransferHelper} from ""@uniswap/lib/contracts/libraries/TransferHelper.sol""; import {IFactory} from ""../factory/IFactory.sol""; import {IInstanceRegistry} from ""../factory/InstanceRegistry.sol""; import {IUniversalVault} from ""../visor/Visor.sol""; import {IRewardPool} from ""./RewardPool.sol""; import {Powered} from ""./Powered.sol""; interface IRageQuit {     function rageQuit() external; } interface IHypervisor is IRageQuit {     / admin events / event HypervisorCreated(address rewardPool, address powerSwitch); event HypervisorFunded(uint256 amount, uint256 duration); event BonusTokenRegistered(address token); event VaultFactoryRegistered(address factory); event VaultFactoryRemoved(address factory);  /* user events */  event Staked(address vault, uint256 amount); event Unstaked(address vault, uint256 amount); event RewardClaimed(address vault, address recipient, address token, uint256 amount);  /* data types */  struct HypervisorData {     address stakingToken;     address rewardToken;     address rewardPool;     RewardScaling rewardScaling;     uint256 rewardSharesOutstanding;     uint256 totalStake;     uint256 totalStakeUnits;     uint256 lastUpdate;     RewardSchedule[] rewardSchedules; }  struct RewardSchedule {     uint256 duration;     uint256 start;     uint256 shares; }  struct VaultData {     uint256 totalStake;     StakeData[] stakes; }  struct StakeData {     uint256 amount;     uint256 timestamp; }  struct RewardScaling {     uint256 floor;     uint256 ceiling;     uint256 time; }  struct RewardOutput {     uint256 lastStakeAmount;     uint256 newStakesCount;     uint256 reward;     uint256 newTotalStakeUnits; }  /* user functions */  function stake(     address vault,     uint256 amount,     bytes calldata permission ) external;  function unstakeAndClaim(     address vault,     uint256 amount,     bytes calldata permission ) external;  /* getter functions */  function getHypervisorData() external view returns (HypervisorData memory hypervisor);  function getBonusTokenSetLength() external view returns (uint256 length);  function getBonusTokenAtIndex(uint256 index) external view returns (address bonusToken);  function getVaultFactorySetLength() external view returns (uint256 length);  function getVaultFactoryAtIndex(uint256 index) external view returns (address factory);  function getVaultData(address vault) external view returns (VaultData memory vaultData);  function isValidAddress(address target) external view returns (bool validity);  function isValidVault(address target) external view returns (bool validity);  function getCurrentUnlockedRewards() external view returns (uint256 unlockedRewards);  function getFutureUnlockedRewards(uint256 timestamp)     external     view     returns (uint256 unlockedRewards);  function getCurrentVaultReward(address vault) external view returns (uint256 reward);  function getCurrentStakeReward(address vault, uint256 stakeAmount)     external     view     returns (uint256 reward);  function getFutureVaultReward(address vault, uint256 timestamp)     external     view     returns (uint256 reward);  function getFutureStakeReward(     address vault,     uint256 stakeAmount,     uint256 timestamp ) external view returns (uint256 reward);  function getCurrentVaultStakeUnits(address vault) external view returns (uint256 stakeUnits);  function getFutureVaultStakeUnits(address vault, uint256 timestamp)     external     view     returns (uint256 stakeUnits);  function getCurrentTotalStakeUnits() external view returns (uint256 totalStakeUnits);  function getFutureTotalStakeUnits(uint256 timestamp)     external     view     returns (uint256 totalStakeUnits);  /* pure functions */  function calculateTotalStakeUnits(StakeData[] memory stakes, uint256 timestamp)     external     pure     returns (uint256 totalStakeUnits);  function calculateStakeUnits(     uint256 amount,     uint256 start,     uint256 end ) external pure returns (uint256 stakeUnits);  function calculateUnlockedRewards(     RewardSchedule[] memory rewardSchedules,     uint256 rewardBalance,     uint256 sharesOutstanding,     uint256 timestamp ) external pure returns (uint256 unlockedRewards);  function calculateRewardFromStakes(     StakeData[] memory stakes,     uint256 unstakeAmount,     uint256 unlockedRewards,     uint256 totalStakeUnits,     uint256 timestamp,     RewardScaling memory rewardScaling ) external pure returns (RewardOutput memory out);  function calculateReward(     uint256 unlockedRewards,     uint256 stakeAmount,     uint256 stakeDuration,     uint256 totalStakeUnits,     RewardScaling memory rewardScaling ) external pure returns (uint256 reward);  } /// @title Hypervisor /// @notice Reward distribution contract with time multiplier /// Access Control /// - Power controller: ///     Can power off / shutdown the Hypervisor ///     Can withdraw rewards from reward pool once shutdown /// - Proxy owner: ///     Can change arbitrary logic / state by upgrading the Hypervisor ///     Is unable to operate on user funds due to UniversalVault ///     Is unable to operate on reward pool funds when reward pool is offline / shutdown /// - Hypervisor admin: ///     Can add funds to the Hypervisor, register bonus tokens, and whitelist new vault factories ///     Is a subset of proxy owner permissions /// - User: ///     Can deposit / withdraw / ragequit /// Hypervisor State Machine /// - Online: ///     Hypervisor is operating normally, all functions are enabled /// - Offline: ///     Hypervisor is temporarely disabled for maintenance ///     User deposits and withdrawls are disabled, ragequit remains enabled ///     Users can withdraw their stake through rageQuit() but forego their pending reward ///     Should only be used when downtime required for an upgrade /// - Shutdown: ///     Hypervisor is permanently disabled ///     All functions are disabled with the exception of ragequit ///     Users can withdraw their stake through rageQuit() ///     Power controller can withdraw from the reward pool ///     Should only be used if Proxy Owner role is compromized contract Hypervisor is IHypervisor, Powered, Ownable {     using SafeMath for uint256;     using EnumerableSet for EnumerableSet.AddressSet; /* constants */  // An upper bound on the number of active stakes per vault is required to prevent // calls to rageQuit() from reverting. // With 30 stakes in a vault, ragequit costs 432811 gas which is conservatively lower // than the hardcoded limit of 500k gas on the vault. // This limit is configurable and could be increased in a future deployment. // Ultimately, to avoid a need for fixed upper bounds, the EVM would need to provide // an error code that allows for reliably catching out-of-gas errors on remote calls. uint256 public constant MAX_STAKES_PER_VAULT = 30; uint256 public constant MAX_REWARD_TOKENS = 50; uint256 public constant BASE_SHARES_PER_WEI = 1000000; uint256 public stakeLimit = 2500 ether;  /* storage */  HypervisorData private _hypervisor; mapping(address =&gt; VaultData) private _vaults; EnumerableSet.AddressSet private _bonusTokenSet; EnumerableSet.AddressSet private _vaultFactorySet;  /* initializer */  /// @notice Initizalize Hypervisor /// access control: only proxy constructor /// state machine: can only be called once /// state scope: set initialization variables /// token transfer: none /// @param ownerAddress address The admin address /// @param rewardPoolFactory address The factory to use for deploying the RewardPool /// @param powerSwitchFactory address The factory to use for deploying the PowerSwitch /// @param stakingToken address The address of the staking token for this Hypervisor /// @param rewardToken address The address of the reward token for this Hypervisor /// @param rewardScaling RewardScaling The config for reward scaling floor, ceiling, and time constructor(     address ownerAddress,     address rewardPoolFactory,     address powerSwitchFactory,     address stakingToken,     address rewardToken,     RewardScaling memory rewardScaling,     uint256 _stakeLimit ) {     // the scaling floor must be smaller than ceiling     require(rewardScaling.floor &lt;= rewardScaling.ceiling, ""Hypervisor: floor above ceiling"");      // setting rewardScalingTime to 0 would cause divide by zero error     // to disable reward scaling, use rewardScalingFloor == rewardScalingCeiling     require(rewardScaling.time != 0, ""Hypervisor: scaling time cannot be zero"");      // deploy power switch     address powerSwitch = IFactory(powerSwitchFactory).create(abi.encode(ownerAddress));      // deploy reward pool     address rewardPool = IFactory(rewardPoolFactory).create(abi.encode(powerSwitch));      // set internal configs     Ownable.transferOwnership(ownerAddress);     Powered._setPowerSwitch(powerSwitch);      // commit to storage     _hypervisor.stakingToken = stakingToken;     _hypervisor.rewardToken = rewardToken;     _hypervisor.rewardPool = rewardPool;     _hypervisor.rewardScaling = rewardScaling;      stakeLimit = _stakeLimit;      // emit event     emit HypervisorCreated(rewardPool, powerSwitch); }  /* getter functions */  function getBonusTokenSetLength() external view override returns (uint256 length) {     return _bonusTokenSet.length(); }  function getBonusTokenAtIndex(uint256 index)     external     view     override     returns (address bonusToken) {     return _bonusTokenSet.at(index); }  function getVaultFactorySetLength() external view override returns (uint256 length) {     return _vaultFactorySet.length(); }  function getVaultFactoryAtIndex(uint256 index)     external     view     override     returns (address factory) {     return _vaultFactorySet.at(index); }  function isValidVault(address target) public view override returns (bool validity) {     // validate target is created from whitelisted vault factory     for (uint256 index = 0; index &lt; _vaultFactorySet.length(); index++) {         if (IInstanceRegistry(_vaultFactorySet.at(index)).isInstance(target)) {             return true;         }     }     // explicit return     return false; }  function isValidAddress(address target) public view override returns (bool validity) {     // sanity check target for potential input errors     return         target != address(this) &amp;&amp;         target != address(0) &amp;&amp;         target != _hypervisor.stakingToken &amp;&amp;         target != _hypervisor.rewardToken &amp;&amp;         target != _hypervisor.rewardPool &amp;&amp;         !_bonusTokenSet.contains(target); }  /* Hypervisor getters */  function getHypervisorData() external view override returns (HypervisorData memory hypervisor) {     return _hypervisor; }  function getCurrentUnlockedRewards() public view override returns (uint256 unlockedRewards) {     // calculate reward available based on state     return getFutureUnlockedRewards(block.timestamp); }  function getFutureUnlockedRewards(uint256 timestamp)     public     view     override     returns (uint256 unlockedRewards) {     // get reward amount remaining     uint256 remainingRewards = IERC20(_hypervisor.rewardToken).balanceOf(_hypervisor.rewardPool);     // calculate reward available based on state     unlockedRewards = calculateUnlockedRewards(         _hypervisor.rewardSchedules,         remainingRewards,         _hypervisor.rewardSharesOutstanding,         timestamp     );     // explicit return     return unlockedRewards; }  function getCurrentTotalStakeUnits() public view override returns (uint256 totalStakeUnits) {     // calculate new stake units     return getFutureTotalStakeUnits(block.timestamp); }  function getFutureTotalStakeUnits(uint256 timestamp)     public     view     override     returns (uint256 totalStakeUnits) {     // return early if no change     if (timestamp == _hypervisor.lastUpdate) return _hypervisor.totalStakeUnits;     // calculate new stake units     uint256 newStakeUnits =         calculateStakeUnits(_hypervisor.totalStake, _hypervisor.lastUpdate, timestamp);     // add to cached total     totalStakeUnits = _hypervisor.totalStakeUnits.add(newStakeUnits);     // explicit return     return totalStakeUnits; }  /* vault getters */  function getVaultData(address vault)     external     view     override     returns (VaultData memory vaultData) {     return _vaults[vault]; }  function getCurrentVaultReward(address vault) external view override returns (uint256 reward) {     // calculate rewards     return         calculateRewardFromStakes(             _vaults[vault]                 .stakes,             _vaults[vault]                 .totalStake,             getCurrentUnlockedRewards(),             getCurrentTotalStakeUnits(),             block                 .timestamp,             _hypervisor                 .rewardScaling         )             .reward; }  function getFutureVaultReward(address vault, uint256 timestamp)     external     view     override     returns (uint256 reward) {     // calculate rewards     return         calculateRewardFromStakes(             _vaults[vault]                 .stakes,             _vaults[vault]                 .totalStake,             getFutureUnlockedRewards(timestamp),             getFutureTotalStakeUnits(timestamp),             timestamp,             _hypervisor                 .rewardScaling         )             .reward; }  function getCurrentStakeReward(address vault, uint256 stakeAmount)     external     view     override     returns (uint256 reward) {     // calculate rewards     return         calculateRewardFromStakes(             _vaults[vault]                 .stakes,             stakeAmount,             getCurrentUnlockedRewards(),             getCurrentTotalStakeUnits(),             block                 .timestamp,             _hypervisor                 .rewardScaling         )             .reward; }  function getFutureStakeReward(     address vault,     uint256 stakeAmount,     uint256 timestamp ) external view override returns (uint256 reward) {     // calculate rewards     return         calculateRewardFromStakes(             _vaults[vault]                 .stakes,             stakeAmount,             getFutureUnlockedRewards(timestamp),             getFutureTotalStakeUnits(timestamp),             timestamp,             _hypervisor                 .rewardScaling         )             .reward; }  function getCurrentVaultStakeUnits(address vault)     public     view     override     returns (uint256 stakeUnits) {     // calculate stake units     return getFutureVaultStakeUnits(vault, block.timestamp); }  function getFutureVaultStakeUnits(address vault, uint256 timestamp)     public     view     override     returns (uint256 stakeUnits) {     // calculate stake units     return calculateTotalStakeUnits(_vaults[vault].stakes, timestamp); }  /* pure functions */  function calculateTotalStakeUnits(StakeData[] memory stakes, uint256 timestamp)     public     pure     override     returns (uint256 totalStakeUnits) {     for (uint256 index; index &lt; stakes.length; index++) {         // reference stake         StakeData memory stakeData = stakes[index];         // calculate stake units         uint256 stakeUnits =             calculateStakeUnits(stakeData.amount, stakeData.timestamp, timestamp);         // add to running total         totalStakeUnits = totalStakeUnits.add(stakeUnits);     } }  function calculateStakeUnits(     uint256 amount,     uint256 start,     uint256 end ) public pure override returns (uint256 stakeUnits) {     // calculate duration     uint256 duration = end.sub(start);     // calculate stake units     stakeUnits = duration.mul(amount);     // explicit return     return stakeUnits; }  function calculateUnlockedRewards(     RewardSchedule[] memory rewardSchedules,     uint256 rewardBalance,     uint256 sharesOutstanding,     uint256 timestamp ) public pure override returns (uint256 unlockedRewards) {     // return 0 if no registered schedules     if (rewardSchedules.length == 0) {         return 0;     }      // calculate reward shares locked across all reward schedules     uint256 sharesLocked;     for (uint256 index = 0; index &lt; rewardSchedules.length; index++) {         // fetch reward schedule storage reference         RewardSchedule memory schedule = rewardSchedules[index];          // caculate amount of shares available on this schedule         // if (now - start) &lt; duration         //   sharesLocked = shares - (shares * (now - start) / duration)         // else         //   sharesLocked = 0         uint256 currentSharesLocked = 0;         if (timestamp.sub(schedule.start) &lt; schedule.duration) {             currentSharesLocked = schedule.shares.sub(                 schedule.shares.mul(timestamp.sub(schedule.start)).div(schedule.duration)             );         }          // add to running total         sharesLocked = sharesLocked.add(currentSharesLocked);     }      // convert shares to reward     // rewardLocked = sharesLocked * rewardBalance / sharesOutstanding     uint256 rewardLocked = sharesLocked.mul(rewardBalance).div(sharesOutstanding);      // calculate amount available     // unlockedRewards = rewardBalance - rewardLocked     unlockedRewards = rewardBalance.sub(rewardLocked);      // explicit return     return unlockedRewards; }  function calculateRewardFromStakes(     StakeData[] memory stakes,     uint256 unstakeAmount,     uint256 unlockedRewards,     uint256 totalStakeUnits,     uint256 timestamp,     RewardScaling memory rewardScaling ) public pure override returns (RewardOutput memory out) {     uint256 stakesToDrop = 0;     while (unstakeAmount &gt; 0) {         // fetch vault stake storage reference         StakeData memory lastStake = stakes[stakes.length.sub(stakesToDrop).sub(1)];          // calculate stake duration         uint256 stakeDuration = timestamp.sub(lastStake.timestamp);          uint256 currentAmount;         if (lastStake.amount &gt; unstakeAmount) {             // set current amount to remaining unstake amount             currentAmount = unstakeAmount;             // amount of last stake is reduced             out.lastStakeAmount = lastStake.amount.sub(unstakeAmount);         } else {             // set current amount to amount of last stake             currentAmount = lastStake.amount;             // add to stakes to drop             stakesToDrop += 1;         }          // update remaining unstakeAmount         unstakeAmount = unstakeAmount.sub(currentAmount);          // calculate reward amount         uint256 currentReward =             calculateReward(                 unlockedRewards,                 currentAmount,                 stakeDuration,                 totalStakeUnits,                 rewardScaling             );          // update cumulative reward         out.reward = out.reward.add(currentReward);          // update cached unlockedRewards         unlockedRewards = unlockedRewards.sub(currentReward);          // calculate time weighted stake         uint256 stakeUnits = currentAmount.mul(stakeDuration);          // update cached totalStakeUnits         totalStakeUnits = totalStakeUnits.sub(stakeUnits);     }      // explicit return     return         RewardOutput(             out.lastStakeAmount,             stakes.length.sub(stakesToDrop),             out.reward,             totalStakeUnits         ); }  function calculateReward(     uint256 unlockedRewards,     uint256 stakeAmount,     uint256 stakeDuration,     uint256 totalStakeUnits,     RewardScaling memory rewardScaling ) public pure override returns (uint256 reward) {     // calculate time weighted stake     uint256 stakeUnits = stakeAmount.mul(stakeDuration);      // calculate base reward     // baseReward = unlockedRewards * stakeUnits / totalStakeUnits     uint256 baseReward = 0;     if (totalStakeUnits != 0) {         // scale reward according to proportional weight         baseReward = unlockedRewards.mul(stakeUnits).div(totalStakeUnits);     }      // calculate scaled reward     // if no scaling or scaling period completed     //   reward = baseReward     // else     //   minReward = baseReward * scalingFloor / scalingCeiling     //   bonusReward = baseReward     //                 * (scalingCeiling - scalingFloor) / scalingCeiling     //                 * duration / scalingTime     //   reward = minReward + bonusReward     if (stakeDuration &gt;= rewardScaling.time || rewardScaling.floor == rewardScaling.ceiling) {         // no reward scaling applied         reward = baseReward;     } else {         // calculate minimum reward using scaling floor         uint256 minReward = baseReward.mul(rewardScaling.floor).div(rewardScaling.ceiling);          // calculate bonus reward with vested portion of scaling factor         uint256 bonusReward =             baseReward                 .mul(stakeDuration)                 .mul(rewardScaling.ceiling.sub(rewardScaling.floor))                 .div(rewardScaling.ceiling)                 .div(rewardScaling.time);          // add minimum reward and bonus reward         reward = minReward.add(bonusReward);     }      // explicit return     return reward; }  /* admin functions */  /// @notice Add funds to the Hypervisor /// access control: only admin /// state machine: ///   - can be called multiple times ///   - only online /// state scope: ///   - increase _hypervisor.rewardSharesOutstanding ///   - append to _hypervisor.rewardSchedules /// token transfer: transfer staking tokens from msg.sender to reward pool /// @param amount uint256 Amount of reward tokens to deposit /// @param duration uint256 Duration over which to linearly unlock rewards function fund(uint256 amount, uint256 duration) external onlyOwner onlyOnline {     // validate duration     require(duration != 0, ""Hypervisor: invalid duration"");      // create new reward shares     // if existing rewards on this Hypervisor     //   mint new shares proportional to % change in rewards remaining     //   newShares = remainingShares * newReward / remainingRewards     // else     //   mint new shares with BASE_SHARES_PER_WEI initial conversion rate     //   store as fixed point number with same  of decimals as reward token     uint256 newRewardShares;     if (_hypervisor.rewardSharesOutstanding &gt; 0) {         uint256 remainingRewards = IERC20(_hypervisor.rewardToken).balanceOf(_hypervisor.rewardPool);         newRewardShares = _hypervisor.rewardSharesOutstanding.mul(amount).div(remainingRewards);     } else {         newRewardShares = amount.mul(BASE_SHARES_PER_WEI);     }      // add reward shares to total     _hypervisor.rewardSharesOutstanding = _hypervisor.rewardSharesOutstanding.add(newRewardShares);      // store new reward schedule     _hypervisor.rewardSchedules.push(RewardSchedule(duration, block.timestamp, newRewardShares));      // transfer reward tokens to reward pool     TransferHelper.safeTransferFrom(         _hypervisor.rewardToken,         msg.sender,         _hypervisor.rewardPool,         amount     );      // emit event     emit HypervisorFunded(amount, duration); }  /// @notice Add vault factory to whitelist /// @dev use this function to enable stakes to vaults coming from the specified ///      factory contract /// access control: only admin /// state machine: ///   - can be called multiple times ///   - not shutdown /// state scope: ///   - append to _vaultFactorySet /// token transfer: none /// @param factory address The address of the vault factory function registerVaultFactory(address factory) external onlyOwner notShutdown {     // add factory to set     require(_vaultFactorySet.add(factory), ""Hypervisor: vault factory already registered"");      // emit event     emit VaultFactoryRegistered(factory); }  /// @notice Remove vault factory from whitelist /// @dev use this function to disable new stakes to vaults coming from the specified ///      factory contract. ///      note: vaults with existing stakes from this factory are sill able to unstake /// access control: only admin /// state machine: ///   - can be called multiple times ///   - not shutdown /// state scope: ///   - remove from _vaultFactorySet /// token transfer: none /// @param factory address The address of the vault factory function removeVaultFactory(address factory) external onlyOwner notShutdown {     // remove factory from set     require(_vaultFactorySet.remove(factory), ""Hypervisor: vault factory not registered"");      // emit event     emit VaultFactoryRemoved(factory); }  /// @notice Register bonus token for distribution /// @dev use this function to enable distribution of any ERC20 held by the RewardPool contract /// access control: only admin /// state machine: ///   - can be called multiple times ///   - only online /// state scope: ///   - append to _bonusTokenSet /// token transfer: none /// @param bonusToken address The address of the bonus token function registerBonusToken(address bonusToken) external onlyOwner onlyOnline {     // verify valid bonus token     _validateAddress(bonusToken);      // verify bonus token count     require(_bonusTokenSet.length() &lt; MAX_REWARD_TOKENS, ""Hypervisor: max bonus tokens reached "");      // add token to set     assert(_bonusTokenSet.add(bonusToken));      // emit event     emit BonusTokenRegistered(bonusToken); }  /// @notice Rescue tokens from RewardPool /// @dev use this function to rescue tokens from RewardPool contract ///      without distributing to stakers or triggering emergency shutdown /// access control: only admin /// state machine: ///   - can be called multiple times ///   - only online /// state scope: none /// token transfer: transfer requested token from RewardPool to recipient /// @param token address The address of the token to rescue /// @param recipient address The address of the recipient /// @param amount uint256 The amount of tokens to rescue function rescueTokensFromRewardPool(     address token,     address recipient,     uint256 amount ) external onlyOwner onlyOnline {     // verify recipient     _validateAddress(recipient);      // check not attempting to unstake reward token     require(token != _hypervisor.rewardToken, ""Hypervisor: invalid address"");      // check not attempting to wthdraw bonus token     require(!_bonusTokenSet.contains(token), ""Hypervisor: invalid address"");      // transfer tokens to recipient     IRewardPool(_hypervisor.rewardPool).sendERC20(token, recipient, amount); }  /* user functions */  /// @notice Stake tokens /// @dev anyone can stake to any vault if they have valid permission /// access control: anyone /// state machine: ///   - can be called multiple times ///   - only online ///   - when vault exists on this Hypervisor /// state scope: ///   - append to _vaults[vault].stakes ///   - increase _vaults[vault].totalStake ///   - increase _hypervisor.totalStake ///   - increase _hypervisor.totalStakeUnits ///   - increase _hypervisor.lastUpdate /// token transfer: transfer staking tokens from msg.sender to vault /// @param vault address The address of the vault to stake from /// @param amount uint256 The amount of staking tokens to stake function stake(     address vault,     uint256 amount,     bytes calldata permission ) external override onlyOnline {     // verify vault is valid     require(isValidVault(vault), ""Hypervisor: vault is not registered"");      // verify non-zero amount     require(amount != 0, ""Hypervisor: no amount staked"");      // fetch vault storage reference     VaultData storage vaultData = _vaults[vault];      // verify stakes boundary not reached     require(         vaultData.stakes.length &lt; MAX_STAKES_PER_VAULT,         ""Hypervisor: MAX_STAKES_PER_VAULT reached""     );      // update cached sum of stake units across all vaults     _updateTotalStakeUnits();      // store amount and timestamp     vaultData.stakes.push(StakeData(amount, block.timestamp));      // update cached total vault and Hypervisor amounts     vaultData.totalStake = vaultData.totalStake.add(amount);     // verify stake quantity without bounds     require(         stakeLimit == 0 || vaultData.totalStake &lt;= stakeLimit,         ""Hypervisor: Stake limit exceeded""     );     _hypervisor.totalStake = _hypervisor.totalStake.add(amount);      // call lock on vault     IUniversalVault(vault).lock(_hypervisor.stakingToken, amount, permission);      // emit event     emit Staked(vault, amount); }  /// @notice Unstake staking tokens and claim reward /// @dev rewards can only be claimed when unstaking /// access control: only owner of vault /// state machine: ///   - when vault exists on this Hypervisor ///   - after stake from vault ///   - can be called multiple times while sufficient stake remains ///   - only online /// state scope: ///   - decrease _hypervisor.rewardSharesOutstanding ///   - decrease _hypervisor.totalStake ///   - increase _hypervisor.lastUpdate ///   - modify _hypervisor.totalStakeUnits ///   - modify _vaults[vault].stakes ///   - decrease _vaults[vault].totalStake /// token transfer: ///   - transfer reward tokens from reward pool to recipient ///   - transfer bonus tokens from reward pool to recipient /// @param vault address The vault to unstake from /// @param amount uint256 The amount of staking tokens to unstake function unstakeAndClaim(     address vault,     uint256 amount,     bytes calldata permission ) external override onlyOnline {     // fetch vault storage reference     VaultData storage vaultData = _vaults[vault];      // verify non-zero amount     require(amount != 0, ""Hypervisor: no amount unstaked"");      address recipient = IUniversalVault(vault).owner();      // validate recipient     _validateAddress(recipient);      // check for sufficient vault stake amount     require(vaultData.totalStake &gt;= amount, ""Hypervisor: insufficient vault stake"");      // check for sufficient Hypervisor stake amount     // if this check fails, there is a bug in stake accounting     assert(_hypervisor.totalStake &gt;= amount);      // update cached sum of stake units across all vaults     _updateTotalStakeUnits();      // get reward amount remaining     uint256 remainingRewards = IERC20(_hypervisor.rewardToken).balanceOf(_hypervisor.rewardPool);      // calculate vested portion of reward pool     uint256 unlockedRewards =         calculateUnlockedRewards(             _hypervisor.rewardSchedules,             remainingRewards,             _hypervisor.rewardSharesOutstanding,             block.timestamp         );      // calculate vault time weighted reward with scaling     RewardOutput memory out =         calculateRewardFromStakes(             vaultData.stakes,             amount,             unlockedRewards,             _hypervisor.totalStakeUnits,             block.timestamp,             _hypervisor.rewardScaling         );      // update stake data in storage     if (out.newStakesCount == 0) {         // all stakes have been unstaked         delete vaultData.stakes;     } else {         // some stakes have been completely or partially unstaked         // delete fully unstaked stakes         while (vaultData.stakes.length &gt; out.newStakesCount) vaultData.stakes.pop();         // update partially unstaked stake         vaultData.stakes[out.newStakesCount.sub(1)].amount = out.lastStakeAmount;     }      // update cached stake totals     vaultData.totalStake = vaultData.totalStake.sub(amount);     _hypervisor.totalStake = _hypervisor.totalStake.sub(amount);     _hypervisor.totalStakeUnits = out.newTotalStakeUnits;      // unlock staking tokens from vault     IUniversalVault(vault).unlock(_hypervisor.stakingToken, amount, permission);      // emit event     emit Unstaked(vault, amount);      // only perform on non-zero reward     if (out.reward &gt; 0) {         // calculate shares to burn         // sharesToBurn = sharesOutstanding * reward / remainingRewards         uint256 sharesToBurn =             _hypervisor.rewardSharesOutstanding.mul(out.reward).div(remainingRewards);          // burn claimed shares         _hypervisor.rewardSharesOutstanding = _hypervisor.rewardSharesOutstanding.sub(sharesToBurn);          // transfer bonus tokens from reward pool to recipient         if (_bonusTokenSet.length() &gt; 0) {             for (uint256 index = 0; index &lt; _bonusTokenSet.length(); index++) {                 // fetch bonus token address reference                 address bonusToken = _bonusTokenSet.at(index);                  // calculate bonus token amount                 // bonusAmount = bonusRemaining * reward / remainingRewards                 uint256 bonusAmount =                     IERC20(bonusToken).balanceOf(_hypervisor.rewardPool).mul(out.reward).div(                         remainingRewards                     );                  // transfer bonus token                 IRewardPool(_hypervisor.rewardPool).sendERC20(bonusToken, recipient, bonusAmount);                  // emit event                 emit RewardClaimed(vault, recipient, bonusToken, bonusAmount);             }         }          // transfer reward tokens from reward pool to recipient         IRewardPool(_hypervisor.rewardPool).sendERC20(_hypervisor.rewardToken, recipient, out.reward);          // emit event         emit RewardClaimed(vault, recipient, _hypervisor.rewardToken, out.reward);     } }  /// @notice Exit Hypervisor without claiming reward /// @dev This function should never revert when correctly called by the vault. ///      A max number of stakes per vault is set with MAX_STAKES_PER_VAULT to ///      place an upper bound on the for loop in calculateTotalStakeUnits(). /// access control: only callable by the vault directly /// state machine: ///   - when vault exists on this Hypervisor ///   - when active stake from this vault ///   - any power state /// state scope: ///   - decrease _hypervisor.totalStake ///   - increase _hypervisor.lastUpdate ///   - modify _hypervisor.totalStakeUnits ///   - delete _vaults[vault] /// token transfer: none function rageQuit() external override {     // fetch vault storage reference     VaultData storage _vaultData = _vaults[msg.sender];      // revert if no active stakes     require(_vaultData.stakes.length != 0, ""Hypervisor: no stake"");      // update cached sum of stake units across all vaults     _updateTotalStakeUnits();      // emit event     emit Unstaked(msg.sender, _vaultData.totalStake);      // update cached totals     _hypervisor.totalStake = _hypervisor.totalStake.sub(_vaultData.totalStake);     _hypervisor.totalStakeUnits = _hypervisor.totalStakeUnits.sub(         calculateTotalStakeUnits(_vaultData.stakes, block.timestamp)     );      // delete stake data     delete _vaults[msg.sender]; }  /* convenience functions */  function _updateTotalStakeUnits() private {     // update cached totalStakeUnits     _hypervisor.totalStakeUnits = getCurrentTotalStakeUnits();     // update cached lastUpdate     _hypervisor.lastUpdate = block.timestamp; }  function _validateAddress(address target) private view {     // sanity check target for potential input errors     require(isValidAddress(target), ""Hypervisor: invalid address""); }  function _truncateStakesArray(StakeData[] memory array, uint256 newLength)     private     pure     returns (StakeData[] memory newArray) {     newArray = new StakeData[](newLength);     for (uint256 index = 0; index &lt; newLength; index++) {         newArray[index] = array[index];     }     return newArray; }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-02-08 00:43:57 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: GPL-3.0-only
pragma solidity 0.7.6;
pragma abicoder v2;

import {SafeMath} from ""@openzeppelin/contracts/math/SafeMath.sol"";
import {EnumerableSet} from ""@openzeppelin/contracts/utils/EnumerableSet.sol"";
import {IERC20} from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import {Ownable} from ""@openzeppelin/contracts/access/Ownable.sol"";
import {TransferHelper} from ""@uniswap/lib/contracts/libraries/TransferHelper.sol"";

import {IFactory} from ""../factory/IFactory.sol"";
import {IInstanceRegistry} from ""../factory/InstanceRegistry.sol"";
import {IUniversalVault} from ""../visor/Visor.sol"";
import {IRewardPool} from ""./RewardPool.sol"";
import {Powered} from ""./Powered.sol"";

interface IRageQuit {
    function rageQuit() external;
}

interface IHypervisor is IRageQuit {
    /* admin events */

    event HypervisorCreated(address rewardPool, address powerSwitch);
    event HypervisorFunded(uint256 amount, uint256 duration);
    event BonusTokenRegistered(address token);
    event VaultFactoryRegistered(address factory);
    event VaultFactoryRemoved(address factory);

    /* user events */

    event Staked(address vault, uint256 amount);
    event Unstaked(address vault, uint256 amount);
    event RewardClaimed(address vault, address recipient, address token, uint256 amount);

    /* data types */

    struct HypervisorData {
        address stakingToken;
        address rewardToken;
        address rewardPool;
        RewardScaling rewardScaling;
        uint256 rewardSharesOutstanding;
        uint256 totalStake;
        uint256 totalStakeUnits;
        uint256 lastUpdate;
        RewardSchedule[] rewardSchedules;
    }

    struct RewardSchedule {
        uint256 duration;
        uint256 start;
        uint256 shares;
    }

    struct VaultData {
        uint256 totalStake;
        StakeData[] stakes;
    }

    struct StakeData {
        uint256 amount;
        uint256 timestamp;
    }

    struct RewardScaling {
        uint256 floor;
        uint256 ceiling;
        uint256 time;
    }

    struct RewardOutput {
        uint256 lastStakeAmount;
        uint256 newStakesCount;
        uint256 reward;
        uint256 newTotalStakeUnits;
    }

    /* user functions */

    function stake(
        address vault,
        uint256 amount,
        bytes calldata permission
    ) external;

    function unstakeAndClaim(
        address vault,
        uint256 amount,
        bytes calldata permission
    ) external;

    /* getter functions */

    function getHypervisorData() external view returns (HypervisorData memory hypervisor);

    function getBonusTokenSetLength() external view returns (uint256 length);

    function getBonusTokenAtIndex(uint256 index) external view returns (address bonusToken);

    function getVaultFactorySetLength() external view returns (uint256 length);

    function getVaultFactoryAtIndex(uint256 index) external view returns (address factory);

    function getVaultData(address vault) external view returns (VaultData memory vaultData);

    function isValidAddress(address target) external view returns (bool validity);

    function isValidVault(address target) external view returns (bool validity);

    function getCurrentUnlockedRewards() external view returns (uint256 unlockedRewards);

    function getFutureUnlockedRewards(uint256 timestamp)
        external
        view
        returns (uint256 unlockedRewards);

    function getCurrentVaultReward(address vault) external view returns (uint256 reward);

    function getCurrentStakeReward(address vault, uint256 stakeAmount)
        external
        view
        returns (uint256 reward);

    function getFutureVaultReward(address vault, uint256 timestamp)
        external
        view
        returns (uint256 reward);

    function getFutureStakeReward(
        address vault,
        uint256 stakeAmount,
        uint256 timestamp
    ) external view returns (uint256 reward);

    function getCurrentVaultStakeUnits(address vault) external view returns (uint256 stakeUnits);

    function getFutureVaultStakeUnits(address vault, uint256 timestamp)
        external
        view
        returns (uint256 stakeUnits);

    function getCurrentTotalStakeUnits() external view returns (uint256 totalStakeUnits);

    function getFutureTotalStakeUnits(uint256 timestamp)
        external
        view
        returns (uint256 totalStakeUnits);

    /* pure functions */

    function calculateTotalStakeUnits(StakeData[] memory stakes, uint256 timestamp)
        external
        pure
        returns (uint256 totalStakeUnits);

    function calculateStakeUnits(
        uint256 amount,
        uint256 start,
        uint256 end
    ) external pure returns (uint256 stakeUnits);

    function calculateUnlockedRewards(
        RewardSchedule[] memory rewardSchedules,
        uint256 rewardBalance,
        uint256 sharesOutstanding,
        uint256 timestamp
    ) external pure returns (uint256 unlockedRewards);

    function calculateRewardFromStakes(
        StakeData[] memory stakes,
        uint256 unstakeAmount,
        uint256 unlockedRewards,
        uint256 totalStakeUnits,
        uint256 timestamp,
        RewardScaling memory rewardScaling
    ) external pure returns (RewardOutput memory out);

    function calculateReward(
        uint256 unlockedRewards,
        uint256 stakeAmount,
        uint256 stakeDuration,
        uint256 totalStakeUnits,
        RewardScaling memory rewardScaling
    ) external pure returns (uint256 reward);
}

/// @title Hypervisor
/// @notice Reward distribution contract with time multiplier
/// Access Control
/// - Power controller:
///     Can power off / shutdown the Hypervisor
///     Can withdraw rewards from reward pool once shutdown
/// - Proxy owner:
///     Can change arbitrary logic / state by upgrading the Hypervisor
///     Is unable to operate on user funds due to UniversalVault
///     Is unable to operate on reward pool funds when reward pool is offline / shutdown
/// - Hypervisor admin:
///     Can add funds to the Hypervisor, register bonus tokens, and whitelist new vault factories
///     Is a subset of proxy owner permissions
/// - User:
///     Can deposit / withdraw / ragequit
/// Hypervisor State Machine
/// - Online:
///     Hypervisor is operating normally, all functions are enabled
/// - Offline:
///     Hypervisor is temporarely disabled for maintenance
///     User deposits and withdrawls are disabled, ragequit remains enabled
///     Users can withdraw their stake through rageQuit() but forego their pending reward
///     Should only be used when downtime required for an upgrade
/// - Shutdown:
///     Hypervisor is permanently disabled
///     All functions are disabled with the exception of ragequit
///     Users can withdraw their stake through rageQuit()
///     Power controller can withdraw from the reward pool
///     Should only be used if Proxy Owner role is compromized
contract Hypervisor is IHypervisor, Powered, Ownable {
    using SafeMath for uint256;
    using EnumerableSet for EnumerableSet.AddressSet;

    /* constants */

    // An upper bound on the number of active stakes per vault is required to prevent
    // calls to rageQuit() from reverting.
    // With 30 stakes in a vault, ragequit costs 432811 gas which is conservatively lower
    // than the hardcoded limit of 500k gas on the vault.
    // This limit is configurable and could be increased in a future deployment.
    // Ultimately, to avoid a need for fixed upper bounds, the EVM would need to provide
    // an error code that allows for reliably catching out-of-gas errors on remote calls.
    uint256 public constant MAX_STAKES_PER_VAULT = 30;
    uint256 public constant MAX_REWARD_TOKENS = 50;
    uint256 public constant BASE_SHARES_PER_WEI = 1000000;
    uint256 public stakeLimit = 2500 ether;

    /* storage */

    HypervisorData private _hypervisor;
    mapping(address => VaultData) private _vaults;
    EnumerableSet.AddressSet private _bonusTokenSet;
    EnumerableSet.AddressSet private _vaultFactorySet;

    /* initializer */

    /// @notice Initizalize Hypervisor
    /// access control: only proxy constructor
    /// state machine: can only be called once
    /// state scope: set initialization variables
    /// token transfer: none
    /// @param ownerAddress address The admin address
    /// @param rewardPoolFactory address The factory to use for deploying the RewardPool
    /// @param powerSwitchFactory address The factory to use for deploying the PowerSwitch
    /// @param stakingToken address The address of the staking token for this Hypervisor
    /// @param rewardToken address The address of the reward token for this Hypervisor
    /// @param rewardScaling RewardScaling The config for reward scaling floor, ceiling, and time
    constructor(
        address ownerAddress,
        address rewardPoolFactory,
        address powerSwitchFactory,
        address stakingToken,
        address rewardToken,
        RewardScaling memory rewardScaling,
        uint256 _stakeLimit
    ) {
        // the scaling floor must be smaller than ceiling
        require(rewardScaling.floor <= rewardScaling.ceiling, ""Hypervisor: floor above ceiling"");

        // setting rewardScalingTime to 0 would cause divide by zero error
        // to disable reward scaling, use rewardScalingFloor == rewardScalingCeiling
        require(rewardScaling.time != 0, ""Hypervisor: scaling time cannot be zero"");

        // deploy power switch
        address powerSwitch = IFactory(powerSwitchFactory).create(abi.encode(ownerAddress));

        // deploy reward pool
        address rewardPool = IFactory(rewardPoolFactory).create(abi.encode(powerSwitch));

        // set internal configs
        Ownable.transferOwnership(ownerAddress);
        Powered._setPowerSwitch(powerSwitch);

        // commit to storage
        _hypervisor.stakingToken = stakingToken;
        _hypervisor.rewardToken = rewardToken;
        _hypervisor.rewardPool = rewardPool;
        _hypervisor.rewardScaling = rewardScaling;

        stakeLimit = _stakeLimit;

        // emit event
        emit HypervisorCreated(rewardPool, powerSwitch);
    }

    /* getter functions */

    function getBonusTokenSetLength() external view override returns (uint256 length) {
        return _bonusTokenSet.length();
    }

    function getBonusTokenAtIndex(uint256 index)
        external
        view
        override
        returns (address bonusToken)
    {
        return _bonusTokenSet.at(index);
    }

    function getVaultFactorySetLength() external view override returns (uint256 length) {
        return _vaultFactorySet.length();
    }

    function getVaultFactoryAtIndex(uint256 index)
        external
        view
        override
        returns (address factory)
    {
        return _vaultFactorySet.at(index);
    }

    function isValidVault(address target) public view override returns (bool validity) {
        // validate target is created from whitelisted vault factory
        for (uint256 index = 0; index < _vaultFactorySet.length(); index++) {
            if (IInstanceRegistry(_vaultFactorySet.at(index)).isInstance(target)) {
                return true;
            }
        }
        // explicit return
        return false;
    }

    function isValidAddress(address target) public view override returns (bool validity) {
        // sanity check target for potential input errors
        return
            target != address(this) &&
            target != address(0) &&
            target != _hypervisor.stakingToken &&
            target != _hypervisor.rewardToken &&
            target != _hypervisor.rewardPool &&
            !_bonusTokenSet.contains(target);
    }

    /* Hypervisor getters */

    function getHypervisorData() external view override returns (HypervisorData memory hypervisor) {
        return _hypervisor;
    }

    function getCurrentUnlockedRewards() public view override returns (uint256 unlockedRewards) {
        // calculate reward available based on state
        return getFutureUnlockedRewards(block.timestamp);
    }

    function getFutureUnlockedRewards(uint256 timestamp)
        public
        view
        override
        returns (uint256 unlockedRewards)
    {
        // get reward amount remaining
        uint256 remainingRewards = IERC20(_hypervisor.rewardToken).balanceOf(_hypervisor.rewardPool);
        // calculate reward available based on state
        unlockedRewards = calculateUnlockedRewards(
            _hypervisor.rewardSchedules,
            remainingRewards,
            _hypervisor.rewardSharesOutstanding,
            timestamp
        );
        // explicit return
        return unlockedRewards;
    }

    function getCurrentTotalStakeUnits() public view override returns (uint256 totalStakeUnits) {
        // calculate new stake units
        return getFutureTotalStakeUnits(block.timestamp);
    }

    function getFutureTotalStakeUnits(uint256 timestamp)
        public
        view
        override
        returns (uint256 totalStakeUnits)
    {
        // return early if no change
        if (timestamp == _hypervisor.lastUpdate) return _hypervisor.totalStakeUnits;
        // calculate new stake units
        uint256 newStakeUnits =
            calculateStakeUnits(_hypervisor.totalStake, _hypervisor.lastUpdate, timestamp);
        // add to cached total
        totalStakeUnits = _hypervisor.totalStakeUnits.add(newStakeUnits);
        // explicit return
        return totalStakeUnits;
    }

    /* vault getters */

    function getVaultData(address vault)
        external
        view
        override
        returns (VaultData memory vaultData)
    {
        return _vaults[vault];
    }

    function getCurrentVaultReward(address vault) external view override returns (uint256 reward) {
        // calculate rewards
        return
            calculateRewardFromStakes(
                _vaults[vault]
                    .stakes,
                _vaults[vault]
                    .totalStake,
                getCurrentUnlockedRewards(),
                getCurrentTotalStakeUnits(),
                block
                    .timestamp,
                _hypervisor
                    .rewardScaling
            )
                .reward;
    }

    function getFutureVaultReward(address vault, uint256 timestamp)
        external
        view
        override
        returns (uint256 reward)
    {
        // calculate rewards
        return
            calculateRewardFromStakes(
                _vaults[vault]
                    .stakes,
                _vaults[vault]
                    .totalStake,
                getFutureUnlockedRewards(timestamp),
                getFutureTotalStakeUnits(timestamp),
                timestamp,
                _hypervisor
                    .rewardScaling
            )
                .reward;
    }

    function getCurrentStakeReward(address vault, uint256 stakeAmount)
        external
        view
        override
        returns (uint256 reward)
    {
        // calculate rewards
        return
            calculateRewardFromStakes(
                _vaults[vault]
                    .stakes,
                stakeAmount,
                getCurrentUnlockedRewards(),
                getCurrentTotalStakeUnits(),
                block
                    .timestamp,
                _hypervisor
                    .rewardScaling
            )
                .reward;
    }

    function getFutureStakeReward(
        address vault,
        uint256 stakeAmount,
        uint256 timestamp
    ) external view override returns (uint256 reward) {
        // calculate rewards
        return
            calculateRewardFromStakes(
                _vaults[vault]
                    .stakes,
                stakeAmount,
                getFutureUnlockedRewards(timestamp),
                getFutureTotalStakeUnits(timestamp),
                timestamp,
                _hypervisor
                    .rewardScaling
            )
                .reward;
    }

    function getCurrentVaultStakeUnits(address vault)
        public
        view
        override
        returns (uint256 stakeUnits)
    {
        // calculate stake units
        return getFutureVaultStakeUnits(vault, block.timestamp);
    }

    function getFutureVaultStakeUnits(address vault, uint256 timestamp)
        public
        view
        override
        returns (uint256 stakeUnits)
    {
        // calculate stake units
        return calculateTotalStakeUnits(_vaults[vault].stakes, timestamp);
    }

    /* pure functions */

    function calculateTotalStakeUnits(StakeData[] memory stakes, uint256 timestamp)
        public
        pure
        override
        returns (uint256 totalStakeUnits)
    {
        for (uint256 index; index < stakes.length; index++) {
            // reference stake
            StakeData memory stakeData = stakes[index];
            // calculate stake units
            uint256 stakeUnits =
                calculateStakeUnits(stakeData.amount, stakeData.timestamp, timestamp);
            // add to running total
            totalStakeUnits = totalStakeUnits.add(stakeUnits);
        }
    }

    function calculateStakeUnits(
        uint256 amount,
        uint256 start,
        uint256 end
    ) public pure override returns (uint256 stakeUnits) {
        // calculate duration
        uint256 duration = end.sub(start);
        // calculate stake units
        stakeUnits = duration.mul(amount);
        // explicit return
        return stakeUnits;
    }

    function calculateUnlockedRewards(
        RewardSchedule[] memory rewardSchedules,
        uint256 rewardBalance,
        uint256 sharesOutstanding,
        uint256 timestamp
    ) public pure override returns (uint256 unlockedRewards) {
        // return 0 if no registered schedules
        if (rewardSchedules.length == 0) {
            return 0;
        }

        // calculate reward shares locked across all reward schedules
        uint256 sharesLocked;
        for (uint256 index = 0; index < rewardSchedules.length; index++) {
            // fetch reward schedule storage reference
            RewardSchedule memory schedule = rewardSchedules[index];

            // caculate amount of shares available on this schedule
            // if (now - start) < duration
            //   sharesLocked = shares - (shares * (now - start) / duration)
            // else
            //   sharesLocked = 0
            uint256 currentSharesLocked = 0;
            if (timestamp.sub(schedule.start) < schedule.duration) {
                currentSharesLocked = schedule.shares.sub(
                    schedule.shares.mul(timestamp.sub(schedule.start)).div(schedule.duration)
                );
            }

            // add to running total
            sharesLocked = sharesLocked.add(currentSharesLocked);
        }

        // convert shares to reward
        // rewardLocked = sharesLocked * rewardBalance / sharesOutstanding
        uint256 rewardLocked = sharesLocked.mul(rewardBalance).div(sharesOutstanding);

        // calculate amount available
        // unlockedRewards = rewardBalance - rewardLocked
        unlockedRewards = rewardBalance.sub(rewardLocked);

        // explicit return
        return unlockedRewards;
    }

    function calculateRewardFromStakes(
        StakeData[] memory stakes,
        uint256 unstakeAmount,
        uint256 unlockedRewards,
        uint256 totalStakeUnits,
        uint256 timestamp,
        RewardScaling memory rewardScaling
    ) public pure override returns (RewardOutput memory out) {
        uint256 stakesToDrop = 0;
        while (unstakeAmount > 0) {
            // fetch vault stake storage reference
            StakeData memory lastStake = stakes[stakes.length.sub(stakesToDrop).sub(1)];

            // calculate stake duration
            uint256 stakeDuration = timestamp.sub(lastStake.timestamp);

            uint256 currentAmount;
            if (lastStake.amount > unstakeAmount) {
                // set current amount to remaining unstake amount
                currentAmount = unstakeAmount;
                // amount of last stake is reduced
                out.lastStakeAmount = lastStake.amount.sub(unstakeAmount);
            } else {
                // set current amount to amount of last stake
                currentAmount = lastStake.amount;
                // add to stakes to drop
                stakesToDrop += 1;
            }

            // update remaining unstakeAmount
            unstakeAmount = unstakeAmount.sub(currentAmount);

            // calculate reward amount
            uint256 currentReward =
                calculateReward(
                    unlockedRewards,
                    currentAmount,
                    stakeDuration,
                    totalStakeUnits,
                    rewardScaling
                );

            // update cumulative reward
            out.reward = out.reward.add(currentReward);

            // update cached unlockedRewards
            unlockedRewards = unlockedRewards.sub(currentReward);

            // calculate time weighted stake
            uint256 stakeUnits = currentAmount.mul(stakeDuration);

            // update cached totalStakeUnits
            totalStakeUnits = totalStakeUnits.sub(stakeUnits);
        }

        // explicit return
        return
            RewardOutput(
                out.lastStakeAmount,
                stakes.length.sub(stakesToDrop),
                out.reward,
                totalStakeUnits
            );
    }

    function calculateReward(
        uint256 unlockedRewards,
        uint256 stakeAmount,
        uint256 stakeDuration,
        uint256 totalStakeUnits,
        RewardScaling memory rewardScaling
    ) public pure override returns (uint256 reward) {
        // calculate time weighted stake
        uint256 stakeUnits = stakeAmount.mul(stakeDuration);

        // calculate base reward
        // baseReward = unlockedRewards * stakeUnits / totalStakeUnits
        uint256 baseReward = 0;
        if (totalStakeUnits != 0) {
            // scale reward according to proportional weight
            baseReward = unlockedRewards.mul(stakeUnits).div(totalStakeUnits);
        }

        // calculate scaled reward
        // if no scaling or scaling period completed
        //   reward = baseReward
        // else
        //   minReward = baseReward * scalingFloor / scalingCeiling
        //   bonusReward = baseReward
        //                 * (scalingCeiling - scalingFloor) / scalingCeiling
        //                 * duration / scalingTime
        //   reward = minReward + bonusReward
        if (stakeDuration >= rewardScaling.time || rewardScaling.floor == rewardScaling.ceiling) {
            // no reward scaling applied
            reward = baseReward;
        } else {
            // calculate minimum reward using scaling floor
            uint256 minReward = baseReward.mul(rewardScaling.floor).div(rewardScaling.ceiling);

            // calculate bonus reward with vested portion of scaling factor
            uint256 bonusReward =
                baseReward
                    .mul(stakeDuration)
                    .mul(rewardScaling.ceiling.sub(rewardScaling.floor))
                    .div(rewardScaling.ceiling)
                    .div(rewardScaling.time);

            // add minimum reward and bonus reward
            reward = minReward.add(bonusReward);
        }

        // explicit return
        return reward;
    }

    /* admin functions */

    /// @notice Add funds to the Hypervisor
    /// access control: only admin
    /// state machine:
    ///   - can be called multiple times
    ///   - only online
    /// state scope:
    ///   - increase _hypervisor.rewardSharesOutstanding
    ///   - append to _hypervisor.rewardSchedules
    /// token transfer: transfer staking tokens from msg.sender to reward pool
    /// @param amount uint256 Amount of reward tokens to deposit
    /// @param duration uint256 Duration over which to linearly unlock rewards
    function fund(uint256 amount, uint256 duration) external onlyOwner onlyOnline {
        // validate duration
        require(duration != 0, ""Hypervisor: invalid duration"");

        // create new reward shares
        // if existing rewards on this Hypervisor
        //   mint new shares proportional to % change in rewards remaining
        //   newShares = remainingShares * newReward / remainingRewards
        // else
        //   mint new shares with BASE_SHARES_PER_WEI initial conversion rate
        //   store as fixed point number with same  of decimals as reward token
        uint256 newRewardShares;
        if (_hypervisor.rewardSharesOutstanding > 0) {
            uint256 remainingRewards = IERC20(_hypervisor.rewardToken).balanceOf(_hypervisor.rewardPool);
            newRewardShares = _hypervisor.rewardSharesOutstanding.mul(amount).div(remainingRewards);
        } else {
            newRewardShares = amount.mul(BASE_SHARES_PER_WEI);
        }

        // add reward shares to total
        _hypervisor.rewardSharesOutstanding = _hypervisor.rewardSharesOutstanding.add(newRewardShares);

        // store new reward schedule
        _hypervisor.rewardSchedules.push(RewardSchedule(duration, block.timestamp, newRewardShares));

        // transfer reward tokens to reward pool
        TransferHelper.safeTransferFrom(
            _hypervisor.rewardToken,
            msg.sender,
            _hypervisor.rewardPool,
            amount
        );

        // emit event
        emit HypervisorFunded(amount, duration);
    }

    /// @notice Add vault factory to whitelist
    /// @dev use this function to enable stakes to vaults coming from the specified
    ///      factory contract
    /// access control: only admin
    /// state machine:
    ///   - can be called multiple times
    ///   - not shutdown
    /// state scope:
    ///   - append to _vaultFactorySet
    /// token transfer: none
    /// @param factory address The address of the vault factory
    function registerVaultFactory(address factory) external onlyOwner notShutdown {
        // add factory to set
        require(_vaultFactorySet.add(factory), ""Hypervisor: vault factory already registered"");

        // emit event
        emit VaultFactoryRegistered(factory);
    }

    /// @notice Remove vault factory from whitelist
    /// @dev use this function to disable new stakes to vaults coming from the specified
    ///      factory contract.
    ///      note: vaults with existing stakes from this factory are sill able to unstake
    /// access control: only admin
    /// state machine:
    ///   - can be called multiple times
    ///   - not shutdown
    /// state scope:
    ///   - remove from _vaultFactorySet
    /// token transfer: none
    /// @param factory address The address of the vault factory
    function removeVaultFactory(address factory) external onlyOwner notShutdown {
        // remove factory from set
        require(_vaultFactorySet.remove(factory), ""Hypervisor: vault factory not registered"");

        // emit event
        emit VaultFactoryRemoved(factory);
    }

    /// @notice Register bonus token for distribution
    /// @dev use this function to enable distribution of any ERC20 held by the RewardPool contract
    /// access control: only admin
    /// state machine:
    ///   - can be called multiple times
    ///   - only online
    /// state scope:
    ///   - append to _bonusTokenSet
    /// token transfer: none
    /// @param bonusToken address The address of the bonus token
    function registerBonusToken(address bonusToken) external onlyOwner onlyOnline {
        // verify valid bonus token
        _validateAddress(bonusToken);

        // verify bonus token count
        require(_bonusTokenSet.length() < MAX_REWARD_TOKENS, ""Hypervisor: max bonus tokens reached "");

        // add token to set
        assert(_bonusTokenSet.add(bonusToken));

        // emit event
        emit BonusTokenRegistered(bonusToken);
    }

    /// @notice Rescue tokens from RewardPool
    /// @dev use this function to rescue tokens from RewardPool contract
    ///      without distributing to stakers or triggering emergency shutdown
    /// access control: only admin
    /// state machine:
    ///   - can be called multiple times
    ///   - only online
    /// state scope: none
    /// token transfer: transfer requested token from RewardPool to recipient
    /// @param token address The address of the token to rescue
    /// @param recipient address The address of the recipient
    /// @param amount uint256 The amount of tokens to rescue
    function rescueTokensFromRewardPool(
        address token,
        address recipient,
        uint256 amount
    ) external onlyOwner onlyOnline {
        // verify recipient
        _validateAddress(recipient);

        // check not attempting to unstake reward token
        require(token != _hypervisor.rewardToken, ""Hypervisor: invalid address"");

        // check not attempting to wthdraw bonus token
        require(!_bonusTokenSet.contains(token), ""Hypervisor: invalid address"");

        // transfer tokens to recipient
        IRewardPool(_hypervisor.rewardPool).sendERC20(token, recipient, amount);
    }

    /* user functions */

    /// @notice Stake tokens
    /// @dev anyone can stake to any vault if they have valid permission
    /// access control: anyone
    /// state machine:
    ///   - can be called multiple times
    ///   - only online
    ///   - when vault exists on this Hypervisor
    /// state scope:
    ///   - append to _vaults[vault].stakes
    ///   - increase _vaults[vault].totalStake
    ///   - increase _hypervisor.totalStake
    ///   - increase _hypervisor.totalStakeUnits
    ///   - increase _hypervisor.lastUpdate
    /// token transfer: transfer staking tokens from msg.sender to vault
    /// @param vault address The address of the vault to stake from
    /// @param amount uint256 The amount of staking tokens to stake
    function stake(
        address vault,
        uint256 amount,
        bytes calldata permission
    ) external override onlyOnline {
        // verify vault is valid
        require(isValidVault(vault), ""Hypervisor: vault is not registered"");

        // verify non-zero amount
        require(amount != 0, ""Hypervisor: no amount staked"");

        // fetch vault storage reference
        VaultData storage vaultData = _vaults[vault];

        // verify stakes boundary not reached
        require(
            vaultData.stakes.length < MAX_STAKES_PER_VAULT,
            ""Hypervisor: MAX_STAKES_PER_VAULT reached""
        );

        // update cached sum of stake units across all vaults
        _updateTotalStakeUnits();

        // store amount and timestamp
        vaultData.stakes.push(StakeData(amount, block.timestamp));

        // update cached total vault and Hypervisor amounts
        vaultData.totalStake = vaultData.totalStake.add(amount);
        // verify stake quantity without bounds
        require(
            stakeLimit == 0 || vaultData.totalStake <= stakeLimit,
            ""Hypervisor: Stake limit exceeded""
        );
        _hypervisor.totalStake = _hypervisor.totalStake.add(amount);

        // call lock on vault
        IUniversalVault(vault).lock(_hypervisor.stakingToken, amount, permission);

        // emit event
        emit Staked(vault, amount);
    }

    /// @notice Unstake staking tokens and claim reward
    /// @dev rewards can only be claimed when unstaking
    /// access control: only owner of vault
    /// state machine:
    ///   - when vault exists on this Hypervisor
    ///   - after stake from vault
    ///   - can be called multiple times while sufficient stake remains
    ///   - only online
    /// state scope:
    ///   - decrease _hypervisor.rewardSharesOutstanding
    ///   - decrease _hypervisor.totalStake
    ///   - increase _hypervisor.lastUpdate
    ///   - modify _hypervisor.totalStakeUnits
    ///   - modify _vaults[vault].stakes
    ///   - decrease _vaults[vault].totalStake
    /// token transfer:
    ///   - transfer reward tokens from reward pool to recipient
    ///   - transfer bonus tokens from reward pool to recipient
    /// @param vault address The vault to unstake from
    /// @param amount uint256 The amount of staking tokens to unstake
    function unstakeAndClaim(
        address vault,
        uint256 amount,
        bytes calldata permission
    ) external override onlyOnline {
        // fetch vault storage reference
        VaultData storage vaultData = _vaults[vault];

        // verify non-zero amount
        require(amount != 0, ""Hypervisor: no amount unstaked"");

        address recipient = IUniversalVault(vault).owner();

        // validate recipient
        _validateAddress(recipient);

        // check for sufficient vault stake amount
        require(vaultData.totalStake >= amount, ""Hypervisor: insufficient vault stake"");

        // check for sufficient Hypervisor stake amount
        // if this check fails, there is a bug in stake accounting
        assert(_hypervisor.totalStake >= amount);

        // update cached sum of stake units across all vaults
        _updateTotalStakeUnits();

        // get reward amount remaining
        uint256 remainingRewards = IERC20(_hypervisor.rewardToken).balanceOf(_hypervisor.rewardPool);

        // calculate vested portion of reward pool
        uint256 unlockedRewards =
            calculateUnlockedRewards(
                _hypervisor.rewardSchedules,
                remainingRewards,
                _hypervisor.rewardSharesOutstanding,
                block.timestamp
            );

        // calculate vault time weighted reward with scaling
        RewardOutput memory out =
            calculateRewardFromStakes(
                vaultData.stakes,
                amount,
                unlockedRewards,
                _hypervisor.totalStakeUnits,
                block.timestamp,
                _hypervisor.rewardScaling
            );

        // update stake data in storage
        if (out.newStakesCount == 0) {
            // all stakes have been unstaked
            delete vaultData.stakes;
        } else {
            // some stakes have been completely or partially unstaked
            // delete fully unstaked stakes
            while (vaultData.stakes.length > out.newStakesCount) vaultData.stakes.pop();
            // update partially unstaked stake
            vaultData.stakes[out.newStakesCount.sub(1)].amount = out.lastStakeAmount;
        }

        // update cached stake totals
        vaultData.totalStake = vaultData.totalStake.sub(amount);
        _hypervisor.totalStake = _hypervisor.totalStake.sub(amount);
        _hypervisor.totalStakeUnits = out.newTotalStakeUnits;

        // unlock staking tokens from vault
        IUniversalVault(vault).unlock(_hypervisor.stakingToken, amount, permission);

        // emit event
        emit Unstaked(vault, amount);

        // only perform on non-zero reward
        if (out.reward > 0) {
            // calculate shares to burn
            // sharesToBurn = sharesOutstanding * reward / remainingRewards
            uint256 sharesToBurn =
                _hypervisor.rewardSharesOutstanding.mul(out.reward).div(remainingRewards);

            // burn claimed shares
            _hypervisor.rewardSharesOutstanding = _hypervisor.rewardSharesOutstanding.sub(sharesToBurn);

            // transfer bonus tokens from reward pool to recipient
            if (_bonusTokenSet.length() > 0) {
                for (uint256 index = 0; index < _bonusTokenSet.length(); index++) {
                    // fetch bonus token address reference
                    address bonusToken = _bonusTokenSet.at(index);

                    // calculate bonus token amount
                    // bonusAmount = bonusRemaining * reward / remainingRewards
                    uint256 bonusAmount =
                        IERC20(bonusToken).balanceOf(_hypervisor.rewardPool).mul(out.reward).div(
                            remainingRewards
                        );

                    // transfer bonus token
                    IRewardPool(_hypervisor.rewardPool).sendERC20(bonusToken, recipient, bonusAmount);

                    // emit event
                    emit RewardClaimed(vault, recipient, bonusToken, bonusAmount);
                }
            }

            // transfer reward tokens from reward pool to recipient
            IRewardPool(_hypervisor.rewardPool).sendERC20(_hypervisor.rewardToken, recipient, out.reward);

            // emit event
            emit RewardClaimed(vault, recipient, _hypervisor.rewardToken, out.reward);
        }
    }

    /// @notice Exit Hypervisor without claiming reward
    /// @dev This function should never revert when correctly called by the vault.
    ///      A max number of stakes per vault is set with MAX_STAKES_PER_VAULT to
    ///      place an upper bound on the for loop in calculateTotalStakeUnits().
    /// access control: only callable by the vault directly
    /// state machine:
    ///   - when vault exists on this Hypervisor
    ///   - when active stake from this vault
    ///   - any power state
    /// state scope:
    ///   - decrease _hypervisor.totalStake
    ///   - increase _hypervisor.lastUpdate
    ///   - modify _hypervisor.totalStakeUnits
    ///   - delete _vaults[vault]
    /// token transfer: none
    function rageQuit() external override {
        // fetch vault storage reference
        VaultData storage _vaultData = _vaults[msg.sender];

        // revert if no active stakes
        require(_vaultData.stakes.length != 0, ""Hypervisor: no stake"");

        // update cached sum of stake units across all vaults
        _updateTotalStakeUnits();

        // emit event
        emit Unstaked(msg.sender, _vaultData.totalStake);

        // update cached totals
        _hypervisor.totalStake = _hypervisor.totalStake.sub(_vaultData.totalStake);
        _hypervisor.totalStakeUnits = _hypervisor.totalStakeUnits.sub(
            calculateTotalStakeUnits(_vaultData.stakes, block.timestamp)
        );

        // delete stake data
        delete _vaults[msg.sender];
    }

    /* convenience functions */

    function _updateTotalStakeUnits() private {
        // update cached totalStakeUnits
        _hypervisor.totalStakeUnits = getCurrentTotalStakeUnits();
        // update cached lastUpdate
        _hypervisor.lastUpdate = block.timestamp;
    }

    function _validateAddress(address target) private view {
        // sanity check target for potential input errors
        require(isValidAddress(target), ""Hypervisor: invalid address"");
    }

    function _truncateStakesArray(StakeData[] memory array, uint256 newLength)
        private
        pure
        returns (StakeData[] memory newArray)
    {
        newArray = new StakeData[](newLength);
        for (uint256 index = 0; index < newLength; index++) {
            newArray[index] = array[index];
        }
        return newArray;
    }
}
.
To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs.]

Given the user's task and the brainstorming ideas provided:
Task: ""// SPDX-License-Identifier: GPL-3.0-only
pragma solidity 0.7.6;
pragma abicoder v2;

import {SafeMath} from ""@openzeppelin/contracts/math/SafeMath.sol"";
import {EnumerableSet} from ""@openzeppelin/contracts/utils/EnumerableSet.sol"";
import {IERC20} from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import {Ownable} from ""@openzeppelin/contracts/access/Ownable.sol"";
import {TransferHelper} from ""@uniswap/lib/contracts/libraries/TransferHelper.sol"";

import {IFactory} from ""../factory/IFactory.sol"";
import {IInstanceRegistry} from ""../factory/InstanceRegistry.sol"";
import {IUniversalVault} from ""../visor/Visor.sol"";
import {IRewardPool} from ""./RewardPool.sol"";
import {Powered} from ""./Powered.sol"";

interface IRageQuit {
    function rageQuit() external;
}

interface IHypervisor is IRageQuit {
    /* admin events */

    event HypervisorCreated(address rewardPool, address powerSwitch);
    event HypervisorFunded(uint256 amount, uint256 duration);
    event BonusTokenRegistered(address token);
    event VaultFactoryRegistered(address factory);
    event VaultFactoryRemoved(address factory);

    /* user events */

    event Staked(address vault, uint256 amount);
    event Unstaked(address vault, uint256 amount);
    event RewardClaimed(address vault, address recipient, address token, uint256 amount);

    /* data types */

    struct HypervisorData {
        address stakingToken;
        address rewardToken;
        address rewardPool;
        RewardScaling rewardScaling;
        uint256 rewardSharesOutstanding;
        uint256 totalStake;
        uint256 totalStakeUnits;
        uint256 lastUpdate;
        RewardSchedule[] rewardSchedules;
    }

    struct RewardSchedule {
        uint256 duration;
        uint256 start;
        uint256 shares;
    }

    struct VaultData {
        uint256 totalStake;
        StakeData[] stakes;
    }

    struct StakeData {
        uint256 amount;
        uint256 timestamp;
    }

    struct RewardScaling {
        uint256 floor;
        uint256 ceiling;
        uint256 time;
    }

    struct RewardOutput {
        uint256 lastStakeAmount;
        uint256 newStakesCount;
        uint256 reward;
        uint256 newTotalStakeUnits;
    }

    /* user functions */

    function stake(
        address vault,
        uint256 amount,
        bytes calldata permission
    ) external;

    function unstakeAndClaim(
        address vault,
        uint256 amount,
        bytes calldata permission
    ) external;

    /* getter functions */

    function getHypervisorData() external view returns (HypervisorData memory hypervisor);

    function getBonusTokenSetLength() external view returns (uint256 length);

    function getBonusTokenAtIndex(uint256 index) external view returns (address bonusToken);

    function getVaultFactorySetLength() external view returns (uint256 length);

    function getVaultFactoryAtIndex(uint256 index) external view returns (address factory);

    function getVaultData(address vault) external view returns (VaultData memory vaultData);

    function isValidAddress(address target) external view returns (bool validity);

    function isValidVault(address target) external view returns (bool validity);

    function getCurrentUnlockedRewards() external view returns (uint256 unlockedRewards);

    function getFutureUnlockedRewards(uint256 timestamp)
        external
        view
        returns (uint256 unlockedRewards);

    function getCurrentVaultReward(address vault) external view returns (uint256 reward);

    function getCurrentStakeReward(address vault, uint256 stakeAmount)
        external
        view
        returns (uint256 reward);

    function getFutureVaultReward(address vault, uint256 timestamp)
        external
        view
        returns (uint256 reward);

    function getFutureStakeReward(
        address vault,
        uint256 stakeAmount,
        uint256 timestamp
    ) external view returns (uint256 reward);

    function getCurrentVaultStakeUnits(address vault) external view returns (uint256 stakeUnits);

    function getFutureVaultStakeUnits(address vault, uint256 timestamp)
        external
        view
        returns (uint256 stakeUnits);

    function getCurrentTotalStakeUnits() external view returns (uint256 totalStakeUnits);

    function getFutureTotalStakeUnits(uint256 timestamp)
        external
        view
        returns (uint256 totalStakeUnits);

    /* pure functions */

    function calculateTotalStakeUnits(StakeData[] memory stakes, uint256 timestamp)
        external
        pure
        returns (uint256 totalStakeUnits);

    function calculateStakeUnits(
        uint256 amount,
        uint256 start,
        uint256 end
    ) external pure returns (uint256 stakeUnits);

    function calculateUnlockedRewards(
        RewardSchedule[] memory rewardSchedules,
        uint256 rewardBalance,
        uint256 sharesOutstanding,
        uint256 timestamp
    ) external pure returns (uint256 unlockedRewards);

    function calculateRewardFromStakes(
        StakeData[] memory stakes,
        uint256 unstakeAmount,
        uint256 unlockedRewards,
        uint256 totalStakeUnits,
        uint256 timestamp,
        RewardScaling memory rewardScaling
    ) external pure returns (RewardOutput memory out);

    function calculateReward(
        uint256 unlockedRewards,
        uint256 stakeAmount,
        uint256 stakeDuration,
        uint256 totalStakeUnits,
        RewardScaling memory rewardScaling
    ) external pure returns (uint256 reward);
}

/// @title Hypervisor
/// @notice Reward distribution contract with time multiplier
/// Access Control
/// - Power controller:
///     Can power off / shutdown the Hypervisor
///     Can withdraw rewards from reward pool once shutdown
/// - Proxy owner:
///     Can change arbitrary logic / state by upgrading the Hypervisor
///     Is unable to operate on user funds due to UniversalVault
///     Is unable to operate on reward pool funds when reward pool is offline / shutdown
/// - Hypervisor admin:
///     Can add funds to the Hypervisor, register bonus tokens, and whitelist new vault factories
///     Is a subset of proxy owner permissions
/// - User:
///     Can deposit / withdraw / ragequit
/// Hypervisor State Machine
/// - Online:
///     Hypervisor is operating normally, all functions are enabled
/// - Offline:
///     Hypervisor is temporarely disabled for maintenance
///     User deposits and withdrawls are disabled, ragequit remains enabled
///     Users can withdraw their stake through rageQuit() but forego their pending reward
///     Should only be used when downtime required for an upgrade
/// - Shutdown:
///     Hypervisor is permanently disabled
///     All functions are disabled with the exception of ragequit
///     Users can withdraw their stake through rageQuit()
///     Power controller can withdraw from the reward pool
///     Should only be used if Proxy Owner role is compromized
contract Hypervisor is IHypervisor, Powered, Ownable {
    using SafeMath for uint256;
    using EnumerableSet for EnumerableSet.AddressSet;

    /* constants */

    // An upper bound on the number of active stakes per vault is required to prevent
    // calls to rageQuit() from reverting.
    // With 30 stakes in a vault, ragequit costs 432811 gas which is conservatively lower
    // than the hardcoded limit of 500k gas on the vault.
    // This limit is configurable and could be increased in a future deployment.
    // Ultimately, to avoid a need for fixed upper bounds, the EVM would need to provide
    // an error code that allows for reliably catching out-of-gas errors on remote calls.
    uint256 public constant MAX_STAKES_PER_VAULT = 30;
    uint256 public constant MAX_REWARD_TOKENS = 50;
    uint256 public constant BASE_SHARES_PER_WEI = 1000000;
    uint256 public stakeLimit = 2500 ether;

    /* storage */

    HypervisorData private _hypervisor;
    mapping(address => VaultData) private _vaults;
    EnumerableSet.AddressSet private _bonusTokenSet;
    EnumerableSet.AddressSet private _vaultFactorySet;

    /* initializer */

    /// @notice Initizalize Hypervisor
    /// access control: only proxy constructor
    /// state machine: can only be called once
    /// state scope: set initialization variables
    /// token transfer: none
    /// @param ownerAddress address The admin address
    /// @param rewardPoolFactory address The factory to use for deploying the RewardPool
    /// @param powerSwitchFactory address The factory to use for deploying the PowerSwitch
    /// @param stakingToken address The address of the staking token for this Hypervisor
    /// @param rewardToken address The address of the reward token for this Hypervisor
    /// @param rewardScaling RewardScaling The config for reward scaling floor, ceiling, and time
    constructor(
        address ownerAddress,
        address rewardPoolFactory,
        address powerSwitchFactory,
        address stakingToken,
        address rewardToken,
        RewardScaling memory rewardScaling,
        uint256 _stakeLimit
    ) {
        // the scaling floor must be smaller than ceiling
        require(rewardScaling.floor <= rewardScaling.ceiling, ""Hypervisor: floor above ceiling"");

        // setting rewardScalingTime to 0 would cause divide by zero error
        // to disable reward scaling, use rewardScalingFloor == rewardScalingCeiling
        require(rewardScaling.time != 0, ""Hypervisor: scaling time cannot be zero"");

        // deploy power switch
        address powerSwitch = IFactory(powerSwitchFactory).create(abi.encode(ownerAddress));

        // deploy reward pool
        address rewardPool = IFactory(rewardPoolFactory).create(abi.encode(powerSwitch));

        // set internal configs
        Ownable.transferOwnership(ownerAddress);
        Powered._setPowerSwitch(powerSwitch);

        // commit to storage
        _hypervisor.stakingToken = stakingToken;
        _hypervisor.rewardToken = rewardToken;
        _hypervisor.rewardPool = rewardPool;
        _hypervisor.rewardScaling = rewardScaling;

        stakeLimit = _stakeLimit;

        // emit event
        emit HypervisorCreated(rewardPool, powerSwitch);
    }

    /* getter functions */

    function getBonusTokenSetLength() external view override returns (uint256 length) {
        return _bonusTokenSet.length();
    }

    function getBonusTokenAtIndex(uint256 index)
        external
        view
        override
        returns (address bonusToken)
    {
        return _bonusTokenSet.at(index);
    }

    function getVaultFactorySetLength() external view override returns (uint256 length) {
        return _vaultFactorySet.length();
    }

    function getVaultFactoryAtIndex(uint256 index)
        external
        view
        override
        returns (address factory)
    {
        return _vaultFactorySet.at(index);
    }

    function isValidVault(address target) public view override returns (bool validity) {
        // validate target is created from whitelisted vault factory
        for (uint256 index = 0; index < _vaultFactorySet.length(); index++) {
            if (IInstanceRegistry(_vaultFactorySet.at(index)).isInstance(target)) {
                return true;
            }
        }
        // explicit return
        return false;
    }

    function isValidAddress(address target) public view override returns (bool validity) {
        // sanity check target for potential input errors
        return
            target != address(this) &&
            target != address(0) &&
            target != _hypervisor.stakingToken &&
            target != _hypervisor.rewardToken &&
            target != _hypervisor.rewardPool &&
            !_bonusTokenSet.contains(target);
    }

    /* Hypervisor getters */

    function getHypervisorData() external view override returns (HypervisorData memory hypervisor) {
        return _hypervisor;
    }

    function getCurrentUnlockedRewards() public view override returns (uint256 unlockedRewards) {
        // calculate reward available based on state
        return getFutureUnlockedRewards(block.timestamp);
    }

    function getFutureUnlockedRewards(uint256 timestamp)
        public
        view
        override
        returns (uint256 unlockedRewards)
    {
        // get reward amount remaining
        uint256 remainingRewards = IERC20(_hypervisor.rewardToken).balanceOf(_hypervisor.rewardPool);
        // calculate reward available based on state
        unlockedRewards = calculateUnlockedRewards(
            _hypervisor.rewardSchedules,
            remainingRewards,
            _hypervisor.rewardSharesOutstanding,
            timestamp
        );
        // explicit return
        return unlockedRewards;
    }

    function getCurrentTotalStakeUnits() public view override returns (uint256 totalStakeUnits) {
        // calculate new stake units
        return getFutureTotalStakeUnits(block.timestamp);
    }

    function getFutureTotalStakeUnits(uint256 timestamp)
        public
        view
        override
        returns (uint256 totalStakeUnits)
    {
        // return early if no change
        if (timestamp == _hypervisor.lastUpdate) return _hypervisor.totalStakeUnits;
        // calculate new stake units
        uint256 newStakeUnits =
            calculateStakeUnits(_hypervisor.totalStake, _hypervisor.lastUpdate, timestamp);
        // add to cached total
        totalStakeUnits = _hypervisor.totalStakeUnits.add(newStakeUnits);
        // explicit return
        return totalStakeUnits;
    }

    /* vault getters */

    function getVaultData(address vault)
        external
        view
        override
        returns (VaultData memory vaultData)
    {
        return _vaults[vault];
    }

    function getCurrentVaultReward(address vault) external view override returns (uint256 reward) {
        // calculate rewards
        return
            calculateRewardFromStakes(
                _vaults[vault]
                    .stakes,
                _vaults[vault]
                    .totalStake,
                getCurrentUnlockedRewards(),
                getCurrentTotalStakeUnits(),
                block
                    .timestamp,
                _hypervisor
                    .rewardScaling
            )
                .reward;
    }

    function getFutureVaultReward(address vault, uint256 timestamp)
        external
        view
        override
        returns (uint256 reward)
    {
        // calculate rewards
        return
            calculateRewardFromStakes(
                _vaults[vault]
                    .stakes,
                _vaults[vault]
                    .totalStake,
                getFutureUnlockedRewards(timestamp),
                getFutureTotalStakeUnits(timestamp),
                timestamp,
                _hypervisor
                    .rewardScaling
            )
                .reward;
    }

    function getCurrentStakeReward(address vault, uint256 stakeAmount)
        external
        view
        override
        returns (uint256 reward)
    {
        // calculate rewards
        return
            calculateRewardFromStakes(
                _vaults[vault]
                    .stakes,
                stakeAmount,
                getCurrentUnlockedRewards(),
                getCurrentTotalStakeUnits(),
                block
                    .timestamp,
                _hypervisor
                    .rewardScaling
            )
                .reward;
    }

    function getFutureStakeReward(
        address vault,
        uint256 stakeAmount,
        uint256 timestamp
    ) external view override returns (uint256 reward) {
        // calculate rewards
        return
            calculateRewardFromStakes(
                _vaults[vault]
                    .stakes,
                stakeAmount,
                getFutureUnlockedRewards(timestamp),
                getFutureTotalStakeUnits(timestamp),
                timestamp,
                _hypervisor
                    .rewardScaling
            )
                .reward;
    }

    function getCurrentVaultStakeUnits(address vault)
        public
        view
        override
        returns (uint256 stakeUnits)
    {
        // calculate stake units
        return getFutureVaultStakeUnits(vault, block.timestamp);
    }

    function getFutureVaultStakeUnits(address vault, uint256 timestamp)
        public
        view
        override
        returns (uint256 stakeUnits)
    {
        // calculate stake units
        return calculateTotalStakeUnits(_vaults[vault].stakes, timestamp);
    }

    /* pure functions */

    function calculateTotalStakeUnits(StakeData[] memory stakes, uint256 timestamp)
        public
        pure
        override
        returns (uint256 totalStakeUnits)
    {
        for (uint256 index; index < stakes.length; index++) {
            // reference stake
            StakeData memory stakeData = stakes[index];
            // calculate stake units
            uint256 stakeUnits =
                calculateStakeUnits(stakeData.amount, stakeData.timestamp, timestamp);
            // add to running total
            totalStakeUnits = totalStakeUnits.add(stakeUnits);
        }
    }

    function calculateStakeUnits(
        uint256 amount,
        uint256 start,
        uint256 end
    ) public pure override returns (uint256 stakeUnits) {
        // calculate duration
        uint256 duration = end.sub(start);
        // calculate stake units
        stakeUnits = duration.mul(amount);
        // explicit return
        return stakeUnits;
    }

    function calculateUnlockedRewards(
        RewardSchedule[] memory rewardSchedules,
        uint256 rewardBalance,
        uint256 sharesOutstanding,
        uint256 timestamp
    ) public pure override returns (uint256 unlockedRewards) {
        // return 0 if no registered schedules
        if (rewardSchedules.length == 0) {
            return 0;
        }

        // calculate reward shares locked across all reward schedules
        uint256 sharesLocked;
        for (uint256 index = 0; index < rewardSchedules.length; index++) {
            // fetch reward schedule storage reference
            RewardSchedule memory schedule = rewardSchedules[index];

            // caculate amount of shares available on this schedule
            // if (now - start) < duration
            //   sharesLocked = shares - (shares * (now - start) / duration)
            // else
            //   sharesLocked = 0
            uint256 currentSharesLocked = 0;
            if (timestamp.sub(schedule.start) < schedule.duration) {
                currentSharesLocked = schedule.shares.sub(
                    schedule.shares.mul(timestamp.sub(schedule.start)).div(schedule.duration)
                );
            }

            // add to running total
            sharesLocked = sharesLocked.add(currentSharesLocked);
        }

        // convert shares to reward
        // rewardLocked = sharesLocked * rewardBalance / sharesOutstanding
        uint256 rewardLocked = sharesLocked.mul(rewardBalance).div(sharesOutstanding);

        // calculate amount available
        // unlockedRewards = rewardBalance - rewardLocked
        unlockedRewards = rewardBalance.sub(rewardLocked);

        // explicit return
        return unlockedRewards;
    }

    function calculateRewardFromStakes(
        StakeData[] memory stakes,
        uint256 unstakeAmount,
        uint256 unlockedRewards,
        uint256 totalStakeUnits,
        uint256 timestamp,
        RewardScaling memory rewardScaling
    ) public pure override returns (RewardOutput memory out) {
        uint256 stakesToDrop = 0;
        while (unstakeAmount > 0) {
            // fetch vault stake storage reference
            StakeData memory lastStake = stakes[stakes.length.sub(stakesToDrop).sub(1)];

            // calculate stake duration
            uint256 stakeDuration = timestamp.sub(lastStake.timestamp);

            uint256 currentAmount;
            if (lastStake.amount > unstakeAmount) {
                // set current amount to remaining unstake amount
                currentAmount = unstakeAmount;
                // amount of last stake is reduced
                out.lastStakeAmount = lastStake.amount.sub(unstakeAmount);
            } else {
                // set current amount to amount of last stake
                currentAmount = lastStake.amount;
                // add to stakes to drop
                stakesToDrop += 1;
            }

            // update remaining unstakeAmount
            unstakeAmount = unstakeAmount.sub(currentAmount);

            // calculate reward amount
            uint256 currentReward =
                calculateReward(
                    unlockedRewards,
                    currentAmount,
                    stakeDuration,
                    totalStakeUnits,
                    rewardScaling
                );

            // update cumulative reward
            out.reward = out.reward.add(currentReward);

            // update cached unlockedRewards
            unlockedRewards = unlockedRewards.sub(currentReward);

            // calculate time weighted stake
            uint256 stakeUnits = currentAmount.mul(stakeDuration);

            // update cached totalStakeUnits
            totalStakeUnits = totalStakeUnits.sub(stakeUnits);
        }

        // explicit return
        return
            RewardOutput(
                out.lastStakeAmount,
                stakes.length.sub(stakesToDrop),
                out.reward,
                totalStakeUnits
            );
    }

    function calculateReward(
        uint256 unlockedRewards,
        uint256 stakeAmount,
        uint256 stakeDuration,
        uint256 totalStakeUnits,
        RewardScaling memory rewardScaling
    ) public pure override returns (uint256 reward) {
        // calculate time weighted stake
        uint256 stakeUnits = stakeAmount.mul(stakeDuration);

        // calculate base reward
        // baseReward = unlockedRewards * stakeUnits / totalStakeUnits
        uint256 baseReward = 0;
        if (totalStakeUnits != 0) {
            // scale reward according to proportional weight
            baseReward = unlockedRewards.mul(stakeUnits).div(totalStakeUnits);
        }

        // calculate scaled reward
        // if no scaling or scaling period completed
        //   reward = baseReward
        // else
        //   minReward = baseReward * scalingFloor / scalingCeiling
        //   bonusReward = baseReward
        //                 * (scalingCeiling - scalingFloor) / scalingCeiling
        //                 * duration / scalingTime
        //   reward = minReward + bonusReward
        if (stakeDuration >= rewardScaling.time || rewardScaling.floor == rewardScaling.ceiling) {
            // no reward scaling applied
            reward = baseReward;
        } else {
            // calculate minimum reward using scaling floor
            uint256 minReward = baseReward.mul(rewardScaling.floor).div(rewardScaling.ceiling);

            // calculate bonus reward with vested portion of scaling factor
            uint256 bonusReward =
                baseReward
                    .mul(stakeDuration)
                    .mul(rewardScaling.ceiling.sub(rewardScaling.floor))
                    .div(rewardScaling.ceiling)
                    .div(rewardScaling.time);

            // add minimum reward and bonus reward
            reward = minReward.add(bonusReward);
        }

        // explicit return
        return reward;
    }

    /* admin functions */

    /// @notice Add funds to the Hypervisor
    /// access control: only admin
    /// state machine:
    ///   - can be called multiple times
    ///   - only online
    /// state scope:
    ///   - increase _hypervisor.rewardSharesOutstanding
    ///   - append to _hypervisor.rewardSchedules
    /// token transfer: transfer staking tokens from msg.sender to reward pool
    /// @param amount uint256 Amount of reward tokens to deposit
    /// @param duration uint256 Duration over which to linearly unlock rewards
    function fund(uint256 amount, uint256 duration) external onlyOwner onlyOnline {
        // validate duration
        require(duration != 0, ""Hypervisor: invalid duration"");

        // create new reward shares
        // if existing rewards on this Hypervisor
        //   mint new shares proportional to % change in rewards remaining
        //   newShares = remainingShares * newReward / remainingRewards
        // else
        //   mint new shares with BASE_SHARES_PER_WEI initial conversion rate
        //   store as fixed point number with same  of decimals as reward token
        uint256 newRewardShares;
        if (_hypervisor.rewardSharesOutstanding > 0) {
            uint256 remainingRewards = IERC20(_hypervisor.rewardToken).balanceOf(_hypervisor.rewardPool);
            newRewardShares = _hypervisor.rewardSharesOutstanding.mul(amount).div(remainingRewards);
        } else {
            newRewardShares = amount.mul(BASE_SHARES_PER_WEI);
        }

        // add reward shares to total
        _hypervisor.rewardSharesOutstanding = _hypervisor.rewardSharesOutstanding.add(newRewardShares);

        // store new reward schedule
        _hypervisor.rewardSchedules.push(RewardSchedule(duration, block.timestamp, newRewardShares));

        // transfer reward tokens to reward pool
        TransferHelper.safeTransferFrom(
            _hypervisor.rewardToken,
            msg.sender,
            _hypervisor.rewardPool,
            amount
        );

        // emit event
        emit HypervisorFunded(amount, duration);
    }

    /// @notice Add vault factory to whitelist
    /// @dev use this function to enable stakes to vaults coming from the specified
    ///      factory contract
    /// access control: only admin
    /// state machine:
    ///   - can be called multiple times
    ///   - not shutdown
    /// state scope:
    ///   - append to _vaultFactorySet
    /// token transfer: none
    /// @param factory address The address of the vault factory
    function registerVaultFactory(address factory) external onlyOwner notShutdown {
        // add factory to set
        require(_vaultFactorySet.add(factory), ""Hypervisor: vault factory already registered"");

        // emit event
        emit VaultFactoryRegistered(factory);
    }

    /// @notice Remove vault factory from whitelist
    /// @dev use this function to disable new stakes to vaults coming from the specified
    ///      factory contract.
    ///      note: vaults with existing stakes from this factory are sill able to unstake
    /// access control: only admin
    /// state machine:
    ///   - can be called multiple times
    ///   - not shutdown
    /// state scope:
    ///   - remove from _vaultFactorySet
    /// token transfer: none
    /// @param factory address The address of the vault factory
    function removeVaultFactory(address factory) external onlyOwner notShutdown {
        // remove factory from set
        require(_vaultFactorySet.remove(factory), ""Hypervisor: vault factory not registered"");

        // emit event
        emit VaultFactoryRemoved(factory);
    }

    /// @notice Register bonus token for distribution
    /// @dev use this function to enable distribution of any ERC20 held by the RewardPool contract
    /// access control: only admin
    /// state machine:
    ///   - can be called multiple times
    ///   - only online
    /// state scope:
    ///   - append to _bonusTokenSet
    /// token transfer: none
    /// @param bonusToken address The address of the bonus token
    function registerBonusToken(address bonusToken) external onlyOwner onlyOnline {
        // verify valid bonus token
        _validateAddress(bonusToken);

        // verify bonus token count
        require(_bonusTokenSet.length() < MAX_REWARD_TOKENS, ""Hypervisor: max bonus tokens reached "");

        // add token to set
        assert(_bonusTokenSet.add(bonusToken));

        // emit event
        emit BonusTokenRegistered(bonusToken);
    }

    /// @notice Rescue tokens from RewardPool
    /// @dev use this function to rescue tokens from RewardPool contract
    ///      without distributing to stakers or triggering emergency shutdown
    /// access control: only admin
    /// state machine:
    ///   - can be called multiple times
    ///   - only online
    /// state scope: none
    /// token transfer: transfer requested token from RewardPool to recipient
    /// @param token address The address of the token to rescue
    /// @param recipient address The address of the recipient
    /// @param amount uint256 The amount of tokens to rescue
    function rescueTokensFromRewardPool(
        address token,
        address recipient,
        uint256 amount
    ) external onlyOwner onlyOnline {
        // verify recipient
        _validateAddress(recipient);

        // check not attempting to unstake reward token
        require(token != _hypervisor.rewardToken, ""Hypervisor: invalid address"");

        // check not attempting to wthdraw bonus token
        require(!_bonusTokenSet.contains(token), ""Hypervisor: invalid address"");

        // transfer tokens to recipient
        IRewardPool(_hypervisor.rewardPool).sendERC20(token, recipient, amount);
    }

    /* user functions */

    /// @notice Stake tokens
    /// @dev anyone can stake to any vault if they have valid permission
    /// access control: anyone
    /// state machine:
    ///   - can be called multiple times
    ///   - only online
    ///   - when vault exists on this Hypervisor
    /// state scope:
    ///   - append to _vaults[vault].stakes
    ///   - increase _vaults[vault].totalStake
    ///   - increase _hypervisor.totalStake
    ///   - increase _hypervisor.totalStakeUnits
    ///   - increase _hypervisor.lastUpdate
    /// token transfer: transfer staking tokens from msg.sender to vault
    /// @param vault address The address of the vault to stake from
    /// @param amount uint256 The amount of staking tokens to stake
    function stake(
        address vault,
        uint256 amount,
        bytes calldata permission
    ) external override onlyOnline {
        // verify vault is valid
        require(isValidVault(vault), ""Hypervisor: vault is not registered"");

        // verify non-zero amount
        require(amount != 0, ""Hypervisor: no amount staked"");

        // fetch vault storage reference
        VaultData storage vaultData = _vaults[vault];

        // verify stakes boundary not reached
        require(
            vaultData.stakes.length < MAX_STAKES_PER_VAULT,
            ""Hypervisor: MAX_STAKES_PER_VAULT reached""
        );

        // update cached sum of stake units across all vaults
        _updateTotalStakeUnits();

        // store amount and timestamp
        vaultData.stakes.push(StakeData(amount, block.timestamp));

        // update cached total vault and Hypervisor amounts
        vaultData.totalStake = vaultData.totalStake.add(amount);
        // verify stake quantity without bounds
        require(
            stakeLimit == 0 || vaultData.totalStake <= stakeLimit,
            ""Hypervisor: Stake limit exceeded""
        );
        _hypervisor.totalStake = _hypervisor.totalStake.add(amount);

        // call lock on vault
        IUniversalVault(vault).lock(_hypervisor.stakingToken, amount, permission);

        // emit event
        emit Staked(vault, amount);
    }

    /// @notice Unstake staking tokens and claim reward
    /// @dev rewards can only be claimed when unstaking
    /// access control: only owner of vault
    /// state machine:
    ///   - when vault exists on this Hypervisor
    ///   - after stake from vault
    ///   - can be called multiple times while sufficient stake remains
    ///   - only online
    /// state scope:
    ///   - decrease _hypervisor.rewardSharesOutstanding
    ///   - decrease _hypervisor.totalStake
    ///   - increase _hypervisor.lastUpdate
    ///   - modify _hypervisor.totalStakeUnits
    ///   - modify _vaults[vault].stakes
    ///   - decrease _vaults[vault].totalStake
    /// token transfer:
    ///   - transfer reward tokens from reward pool to recipient
    ///   - transfer bonus tokens from reward pool to recipient
    /// @param vault address The vault to unstake from
    /// @param amount uint256 The amount of staking tokens to unstake
    function unstakeAndClaim(
        address vault,
        uint256 amount,
        bytes calldata permission
    ) external override onlyOnline {
        // fetch vault storage reference
        VaultData storage vaultData = _vaults[vault];

        // verify non-zero amount
        require(amount != 0, ""Hypervisor: no amount unstaked"");

        address recipient = IUniversalVault(vault).owner();

        // validate recipient
        _validateAddress(recipient);

        // check for sufficient vault stake amount
        require(vaultData.totalStake >= amount, ""Hypervisor: insufficient vault stake"");

        // check for sufficient Hypervisor stake amount
        // if this check fails, there is a bug in stake accounting
        assert(_hypervisor.totalStake >= amount);

        // update cached sum of stake units across all vaults
        _updateTotalStakeUnits();

        // get reward amount remaining
        uint256 remainingRewards = IERC20(_hypervisor.rewardToken).balanceOf(_hypervisor.rewardPool);

        // calculate vested portion of reward pool
        uint256 unlockedRewards =
            calculateUnlockedRewards(
                _hypervisor.rewardSchedules,
                remainingRewards,
                _hypervisor.rewardSharesOutstanding,
                block.timestamp
            );

        // calculate vault time weighted reward with scaling
        RewardOutput memory out =
            calculateRewardFromStakes(
                vaultData.stakes,
                amount,
                unlockedRewards,
                _hypervisor.totalStakeUnits,
                block.timestamp,
                _hypervisor.rewardScaling
            );

        // update stake data in storage
        if (out.newStakesCount == 0) {
            // all stakes have been unstaked
            delete vaultData.stakes;
        } else {
            // some stakes have been completely or partially unstaked
            // delete fully unstaked stakes
            while (vaultData.stakes.length > out.newStakesCount) vaultData.stakes.pop();
            // update partially unstaked stake
            vaultData.stakes[out.newStakesCount.sub(1)].amount = out.lastStakeAmount;
        }

        // update cached stake totals
        vaultData.totalStake = vaultData.totalStake.sub(amount);
        _hypervisor.totalStake = _hypervisor.totalStake.sub(amount);
        _hypervisor.totalStakeUnits = out.newTotalStakeUnits;

        // unlock staking tokens from vault
        IUniversalVault(vault).unlock(_hypervisor.stakingToken, amount, permission);

        // emit event
        emit Unstaked(vault, amount);

        // only perform on non-zero reward
        if (out.reward > 0) {
            // calculate shares to burn
            // sharesToBurn = sharesOutstanding * reward / remainingRewards
            uint256 sharesToBurn =
                _hypervisor.rewardSharesOutstanding.mul(out.reward).div(remainingRewards);

            // burn claimed shares
            _hypervisor.rewardSharesOutstanding = _hypervisor.rewardSharesOutstanding.sub(sharesToBurn);

            // transfer bonus tokens from reward pool to recipient
            if (_bonusTokenSet.length() > 0) {
                for (uint256 index = 0; index < _bonusTokenSet.length(); index++) {
                    // fetch bonus token address reference
                    address bonusToken = _bonusTokenSet.at(index);

                    // calculate bonus token amount
                    // bonusAmount = bonusRemaining * reward / remainingRewards
                    uint256 bonusAmount =
                        IERC20(bonusToken).balanceOf(_hypervisor.rewardPool).mul(out.reward).div(
                            remainingRewards
                        );

                    // transfer bonus token
                    IRewardPool(_hypervisor.rewardPool).sendERC20(bonusToken, recipient, bonusAmount);

                    // emit event
                    emit RewardClaimed(vault, recipient, bonusToken, bonusAmount);
                }
            }

            // transfer reward tokens from reward pool to recipient
            IRewardPool(_hypervisor.rewardPool).sendERC20(_hypervisor.rewardToken, recipient, out.reward);

            // emit event
            emit RewardClaimed(vault, recipient, _hypervisor.rewardToken, out.reward);
        }
    }

    /// @notice Exit Hypervisor without claiming reward
    /// @dev This function should never revert when correctly called by the vault.
    ///      A max number of stakes per vault is set with MAX_STAKES_PER_VAULT to
    ///      place an upper bound on the for loop in calculateTotalStakeUnits().
    /// access control: only callable by the vault directly
    /// state machine:
    ///   - when vault exists on this Hypervisor
    ///   - when active stake from this vault
    ///   - any power state
    /// state scope:
    ///   - decrease _hypervisor.totalStake
    ///   - increase _hypervisor.lastUpdate
    ///   - modify _hypervisor.totalStakeUnits
    ///   - delete _vaults[vault]
    /// token transfer: none
    function rageQuit() external override {
        // fetch vault storage reference
        VaultData storage _vaultData = _vaults[msg.sender];

        // revert if no active stakes
        require(_vaultData.stakes.length != 0, ""Hypervisor: no stake"");

        // update cached sum of stake units across all vaults
        _updateTotalStakeUnits();

        // emit event
        emit Unstaked(msg.sender, _vaultData.totalStake);

        // update cached totals
        _hypervisor.totalStake = _hypervisor.totalStake.sub(_vaultData.totalStake);
        _hypervisor.totalStakeUnits = _hypervisor.totalStakeUnits.sub(
            calculateTotalStakeUnits(_vaultData.stakes, block.timestamp)
        );

        // delete stake data
        delete _vaults[msg.sender];
    }

    /* convenience functions */

    function _updateTotalStakeUnits() private {
        // update cached totalStakeUnits
        _hypervisor.totalStakeUnits = getCurrentTotalStakeUnits();
        // update cached lastUpdate
        _hypervisor.lastUpdate = block.timestamp;
    }

    function _validateAddress(address target) private view {
        // sanity check target for potential input errors
        require(isValidAddress(target), ""Hypervisor: invalid address"");
    }

    function _truncateStakesArray(StakeData[] memory array, uint256 newLength)
        private
        pure
        returns (StakeData[] memory newArray)
    {
        newArray = new StakeData[](newLength);
        for (uint256 index = 0; index < newLength; index++) {
            newArray[index] = array[index];
        }
        return newArray;
    }
}
"".
Ideas: "" Assumption of Fixed-Length Array Identified.

```
VULNERABILITY NAME: Assumption of Fixed-Length Array in calculateTotalStakeUnits
'''
DETAILED DESCRIPTION: The function `calculateTotalStakeUnits` assumes that the length of the `stakes` array is fixed and iterates through it using a for loop. If the length of the `stakes` array is modified externally or if the array is empty, this could lead to out-of-bounds errors or incorrect calculations. The function does not check the length of the array before accessing its elements, which can lead to unintended behavior or data corruption.

RECOMMENDED MITIGATION/FIX: Implement a check at the beginning of the function to ensure that the `stakes` array is not empty before proceeding with the calculations. Additionally, consider using a `while` loop that checks the current length dynamically to avoid assumptions about the array's length.
'''

VULNERABILITY NAME: Assumption of Fixed-Length Array in unstakeAndClaim
'''
DETAILED DESCRIPTION: In the `unstake"".
As the Security Analyst, your primary objective is to perform a thorough and detailed inspection of the provided contract code, with a particular focus on identifying vulnerabilities related to the Lack of Withdrawal Function. Your analysis should determine if the contract provides a secure method for users to withdraw their funds.
Proceed with the following steps in your analysis:
1. Scrutinize the contract's code to determine if there is a function that allows users to withdraw their deposited funds.
2. Scan the contract for any functions related to withdrawing Ether or other assets. Document each instance and investigate the logic to ensure it is implemented securely.
3. Evaluate whether the withdrawal function, if present, follows best practices to prevent common vulnerabilities such as reentrancy attacks. Ensure it uses the Checks-Effects-Interactions pattern.
4. If no withdrawal function is found, assess the impact on users who have deposited funds into the contract. Highlight the importance of having a secure withdrawal mechanism.
If you discover a lack of a withdrawal function, respond with: """,,"<INFO> Lack of Authorization Identified.

```
LACK OF AUTHORIZATION
'''
The `rageQuit()` function allows any user to exit the Hypervisor without claiming rewards. This function is callable by any address that has a registered vault, as it does not have any access control modifiers restricting its invocation. This could potentially allow malicious actors to exploit this function to withdraw stakes without proper authorization, especially if they manage to create a vault.

Recommended Mitigation:
Implement an access control modifier to restrict the `rageQuit()` function to only allow calls from the owner of the vault. This can be done by checking if `msg.sender` is the owner of the vault before allowing the function to execute.
'''
```

```
LACK OF AUTHORIZATION
'''
The `unstakeAndClaim

[2024-02-08 00:44:09 INFO] **[Execute Detail]**

execute SimplePhase:[DataInconsistencyDetector] in ComposedPhase:[CodeReview], cycle 1

[2024-02-08 00:44:10 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: GPL-3.0-only pragma solidity 0.7.6; pragma abicoder v2; import {SafeMath} from ""@openzeppelin/contracts/math/SafeMath.sol""; import {EnumerableSet} from ""@openzeppelin/contracts/utils/EnumerableSet.sol""; import {IERC20} from ""@openzeppelin/contracts/token/ERC20/IERC20.sol""; import {Ownable} from ""@openzeppelin/contracts/access/Ownable.sol""; import {TransferHelper} from ""@uniswap/lib/contracts/libraries/TransferHelper.sol""; import {IFactory} from ""../factory/IFactory.sol""; import {IInstanceRegistry} from ""../factory/InstanceRegistry.sol""; import {IUniversalVault} from ""../visor/Visor.sol""; import {IRewardPool} from ""./RewardPool.sol""; import {Powered} from ""./Powered.sol""; interface IRageQuit {     function rageQuit() external; } interface IHypervisor is IRageQuit {     / admin events / event HypervisorCreated(address rewardPool, address powerSwitch); event HypervisorFunded(uint256 amount, uint256 duration); event BonusTokenRegistered(address token); event VaultFactoryRegistered(address factory); event VaultFactoryRemoved(address factory);  /* user events */  event Staked(address vault, uint256 amount); event Unstaked(address vault, uint256 amount); event RewardClaimed(address vault, address recipient, address token, uint256 amount);  /* data types */  struct HypervisorData {     address stakingToken;     address rewardToken;     address rewardPool;     RewardScaling rewardScaling;     uint256 rewardSharesOutstanding;     uint256 totalStake;     uint256 totalStakeUnits;     uint256 lastUpdate;     RewardSchedule[] rewardSchedules; }  struct RewardSchedule {     uint256 duration;     uint256 start;     uint256 shares; }  struct VaultData {     uint256 totalStake;     StakeData[] stakes; }  struct StakeData {     uint256 amount;     uint256 timestamp; }  struct RewardScaling {     uint256 floor;     uint256 ceiling;     uint256 time; }  struct RewardOutput {     uint256 lastStakeAmount;     uint256 newStakesCount;     uint256 reward;     uint256 newTotalStakeUnits; }  /* user functions */  function stake(     address vault,     uint256 amount,     bytes calldata permission ) external;  function unstakeAndClaim(     address vault,     uint256 amount,     bytes calldata permission ) external;  /* getter functions */  function getHypervisorData() external view returns (HypervisorData memory hypervisor);  function getBonusTokenSetLength() external view returns (uint256 length);  function getBonusTokenAtIndex(uint256 index) external view returns (address bonusToken);  function getVaultFactorySetLength() external view returns (uint256 length);  function getVaultFactoryAtIndex(uint256 index) external view returns (address factory);  function getVaultData(address vault) external view returns (VaultData memory vaultData);  function isValidAddress(address target) external view returns (bool validity);  function isValidVault(address target) external view returns (bool validity);  function getCurrentUnlockedRewards() external view returns (uint256 unlockedRewards);  function getFutureUnlockedRewards(uint256 timestamp)     external     view     returns (uint256 unlockedRewards);  function getCurrentVaultReward(address vault) external view returns (uint256 reward);  function getCurrentStakeReward(address vault, uint256 stakeAmount)     external     view     returns (uint256 reward);  function getFutureVaultReward(address vault, uint256 timestamp)     external     view     returns (uint256 reward);  function getFutureStakeReward(     address vault,     uint256 stakeAmount,     uint256 timestamp ) external view returns (uint256 reward);  function getCurrentVaultStakeUnits(address vault) external view returns (uint256 stakeUnits);  function getFutureVaultStakeUnits(address vault, uint256 timestamp)     external     view     returns (uint256 stakeUnits);  function getCurrentTotalStakeUnits() external view returns (uint256 totalStakeUnits);  function getFutureTotalStakeUnits(uint256 timestamp)     external     view     returns (uint256 totalStakeUnits);  /* pure functions */  function calculateTotalStakeUnits(StakeData[] memory stakes, uint256 timestamp)     external     pure     returns (uint256 totalStakeUnits);  function calculateStakeUnits(     uint256 amount,     uint256 start,     uint256 end ) external pure returns (uint256 stakeUnits);  function calculateUnlockedRewards(     RewardSchedule[] memory rewardSchedules,     uint256 rewardBalance,     uint256 sharesOutstanding,     uint256 timestamp ) external pure returns (uint256 unlockedRewards);  function calculateRewardFromStakes(     StakeData[] memory stakes,     uint256 unstakeAmount,     uint256 unlockedRewards,     uint256 totalStakeUnits,     uint256 timestamp,     RewardScaling memory rewardScaling ) external pure returns (RewardOutput memory out);  function calculateReward(     uint256 unlockedRewards,     uint256 stakeAmount,     uint256 stakeDuration,     uint256 totalStakeUnits,     RewardScaling memory rewardScaling ) external pure returns (uint256 reward);  } /// @title Hypervisor /// @notice Reward distribution contract with time multiplier /// Access Control /// - Power controller: ///     Can power off / shutdown the Hypervisor ///     Can withdraw rewards from reward pool once shutdown /// - Proxy owner: ///     Can change arbitrary logic / state by upgrading the Hypervisor ///     Is unable to operate on user funds due to UniversalVault ///     Is unable to operate on reward pool funds when reward pool is offline / shutdown /// - Hypervisor admin: ///     Can add funds to the Hypervisor, register bonus tokens, and whitelist new vault factories ///     Is a subset of proxy owner permissions /// - User: ///     Can deposit / withdraw / ragequit /// Hypervisor State Machine /// - Online: ///     Hypervisor is operating normally, all functions are enabled /// - Offline: ///     Hypervisor is temporarely disabled for maintenance ///     User deposits and withdrawls are disabled, ragequit remains enabled ///     Users can withdraw their stake through rageQuit() but forego their pending reward ///     Should only be used when downtime required for an upgrade /// - Shutdown: ///     Hypervisor is permanently disabled ///     All functions are disabled with the exception of ragequit ///     Users can withdraw their stake through rageQuit() ///     Power controller can withdraw from the reward pool ///     Should only be used if Proxy Owner role is compromized contract Hypervisor is IHypervisor, Powered, Ownable {     using SafeMath for uint256;     using EnumerableSet for EnumerableSet.AddressSet; /* constants */  // An upper bound on the number of active stakes per vault is required to prevent // calls to rageQuit() from reverting. // With 30 stakes in a vault, ragequit costs 432811 gas which is conservatively lower // than the hardcoded limit of 500k gas on the vault. // This limit is configurable and could be increased in a future deployment. // Ultimately, to avoid a need for fixed upper bounds, the EVM would need to provide // an error code that allows for reliably catching out-of-gas errors on remote calls. uint256 public constant MAX_STAKES_PER_VAULT = 30; uint256 public constant MAX_REWARD_TOKENS = 50; uint256 public constant BASE_SHARES_PER_WEI = 1000000; uint256 public stakeLimit = 2500 ether;  /* storage */  HypervisorData private _hypervisor; mapping(address =&gt; VaultData) private _vaults; EnumerableSet.AddressSet private _bonusTokenSet; EnumerableSet.AddressSet private _vaultFactorySet;  /* initializer */  /// @notice Initizalize Hypervisor /// access control: only proxy constructor /// state machine: can only be called once /// state scope: set initialization variables /// token transfer: none /// @param ownerAddress address The admin address /// @param rewardPoolFactory address The factory to use for deploying the RewardPool /// @param powerSwitchFactory address The factory to use for deploying the PowerSwitch /// @param stakingToken address The address of the staking token for this Hypervisor /// @param rewardToken address The address of the reward token for this Hypervisor /// @param rewardScaling RewardScaling The config for reward scaling floor, ceiling, and time constructor(     address ownerAddress,     address rewardPoolFactory,     address powerSwitchFactory,     address stakingToken,     address rewardToken,     RewardScaling memory rewardScaling,     uint256 _stakeLimit ) {     // the scaling floor must be smaller than ceiling     require(rewardScaling.floor &lt;= rewardScaling.ceiling, ""Hypervisor: floor above ceiling"");      // setting rewardScalingTime to 0 would cause divide by zero error     // to disable reward scaling, use rewardScalingFloor == rewardScalingCeiling     require(rewardScaling.time != 0, ""Hypervisor: scaling time cannot be zero"");      // deploy power switch     address powerSwitch = IFactory(powerSwitchFactory).create(abi.encode(ownerAddress));      // deploy reward pool     address rewardPool = IFactory(rewardPoolFactory).create(abi.encode(powerSwitch));      // set internal configs     Ownable.transferOwnership(ownerAddress);     Powered._setPowerSwitch(powerSwitch);      // commit to storage     _hypervisor.stakingToken = stakingToken;     _hypervisor.rewardToken = rewardToken;     _hypervisor.rewardPool = rewardPool;     _hypervisor.rewardScaling = rewardScaling;      stakeLimit = _stakeLimit;      // emit event     emit HypervisorCreated(rewardPool, powerSwitch); }  /* getter functions */  function getBonusTokenSetLength() external view override returns (uint256 length) {     return _bonusTokenSet.length(); }  function getBonusTokenAtIndex(uint256 index)     external     view     override     returns (address bonusToken) {     return _bonusTokenSet.at(index); }  function getVaultFactorySetLength() external view override returns (uint256 length) {     return _vaultFactorySet.length(); }  function getVaultFactoryAtIndex(uint256 index)     external     view     override     returns (address factory) {     return _vaultFactorySet.at(index); }  function isValidVault(address target) public view override returns (bool validity) {     // validate target is created from whitelisted vault factory     for (uint256 index = 0; index &lt; _vaultFactorySet.length(); index++) {         if (IInstanceRegistry(_vaultFactorySet.at(index)).isInstance(target)) {             return true;         }     }     // explicit return     return false; }  function isValidAddress(address target) public view override returns (bool validity) {     // sanity check target for potential input errors     return         target != address(this) &amp;&amp;         target != address(0) &amp;&amp;         target != _hypervisor.stakingToken &amp;&amp;         target != _hypervisor.rewardToken &amp;&amp;         target != _hypervisor.rewardPool &amp;&amp;         !_bonusTokenSet.contains(target); }  /* Hypervisor getters */  function getHypervisorData() external view override returns (HypervisorData memory hypervisor) {     return _hypervisor; }  function getCurrentUnlockedRewards() public view override returns (uint256 unlockedRewards) {     // calculate reward available based on state     return getFutureUnlockedRewards(block.timestamp); }  function getFutureUnlockedRewards(uint256 timestamp)     public     view     override     returns (uint256 unlockedRewards) {     // get reward amount remaining     uint256 remainingRewards = IERC20(_hypervisor.rewardToken).balanceOf(_hypervisor.rewardPool);     // calculate reward available based on state     unlockedRewards = calculateUnlockedRewards(         _hypervisor.rewardSchedules,         remainingRewards,         _hypervisor.rewardSharesOutstanding,         timestamp     );     // explicit return     return unlockedRewards; }  function getCurrentTotalStakeUnits() public view override returns (uint256 totalStakeUnits) {     // calculate new stake units     return getFutureTotalStakeUnits(block.timestamp); }  function getFutureTotalStakeUnits(uint256 timestamp)     public     view     override     returns (uint256 totalStakeUnits) {     // return early if no change     if (timestamp == _hypervisor.lastUpdate) return _hypervisor.totalStakeUnits;     // calculate new stake units     uint256 newStakeUnits =         calculateStakeUnits(_hypervisor.totalStake, _hypervisor.lastUpdate, timestamp);     // add to cached total     totalStakeUnits = _hypervisor.totalStakeUnits.add(newStakeUnits);     // explicit return     return totalStakeUnits; }  /* vault getters */  function getVaultData(address vault)     external     view     override     returns (VaultData memory vaultData) {     return _vaults[vault]; }  function getCurrentVaultReward(address vault) external view override returns (uint256 reward) {     // calculate rewards     return         calculateRewardFromStakes(             _vaults[vault]                 .stakes,             _vaults[vault]                 .totalStake,             getCurrentUnlockedRewards(),             getCurrentTotalStakeUnits(),             block                 .timestamp,             _hypervisor                 .rewardScaling         )             .reward; }  function getFutureVaultReward(address vault, uint256 timestamp)     external     view     override     returns (uint256 reward) {     // calculate rewards     return         calculateRewardFromStakes(             _vaults[vault]                 .stakes,             _vaults[vault]                 .totalStake,             getFutureUnlockedRewards(timestamp),             getFutureTotalStakeUnits(timestamp),             timestamp,             _hypervisor                 .rewardScaling         )             .reward; }  function getCurrentStakeReward(address vault, uint256 stakeAmount)     external     view     override     returns (uint256 reward) {     // calculate rewards     return         calculateRewardFromStakes(             _vaults[vault]                 .stakes,             stakeAmount,             getCurrentUnlockedRewards(),             getCurrentTotalStakeUnits(),             block                 .timestamp,             _hypervisor                 .rewardScaling         )             .reward; }  function getFutureStakeReward(     address vault,     uint256 stakeAmount,     uint256 timestamp ) external view override returns (uint256 reward) {     // calculate rewards     return         calculateRewardFromStakes(             _vaults[vault]                 .stakes,             stakeAmount,             getFutureUnlockedRewards(timestamp),             getFutureTotalStakeUnits(timestamp),             timestamp,             _hypervisor                 .rewardScaling         )             .reward; }  function getCurrentVaultStakeUnits(address vault)     public     view     override     returns (uint256 stakeUnits) {     // calculate stake units     return getFutureVaultStakeUnits(vault, block.timestamp); }  function getFutureVaultStakeUnits(address vault, uint256 timestamp)     public     view     override     returns (uint256 stakeUnits) {     // calculate stake units     return calculateTotalStakeUnits(_vaults[vault].stakes, timestamp); }  /* pure functions */  function calculateTotalStakeUnits(StakeData[] memory stakes, uint256 timestamp)     public     pure     override     returns (uint256 totalStakeUnits) {     for (uint256 index; index &lt; stakes.length; index++) {         // reference stake         StakeData memory stakeData = stakes[index];         // calculate stake units         uint256 stakeUnits =             calculateStakeUnits(stakeData.amount, stakeData.timestamp, timestamp);         // add to running total         totalStakeUnits = totalStakeUnits.add(stakeUnits);     } }  function calculateStakeUnits(     uint256 amount,     uint256 start,     uint256 end ) public pure override returns (uint256 stakeUnits) {     // calculate duration     uint256 duration = end.sub(start);     // calculate stake units     stakeUnits = duration.mul(amount);     // explicit return     return stakeUnits; }  function calculateUnlockedRewards(     RewardSchedule[] memory rewardSchedules,     uint256 rewardBalance,     uint256 sharesOutstanding,     uint256 timestamp ) public pure override returns (uint256 unlockedRewards) {     // return 0 if no registered schedules     if (rewardSchedules.length == 0) {         return 0;     }      // calculate reward shares locked across all reward schedules     uint256 sharesLocked;     for (uint256 index = 0; index &lt; rewardSchedules.length; index++) {         // fetch reward schedule storage reference         RewardSchedule memory schedule = rewardSchedules[index];          // caculate amount of shares available on this schedule         // if (now - start) &lt; duration         //   sharesLocked = shares - (shares * (now - start) / duration)         // else         //   sharesLocked = 0         uint256 currentSharesLocked = 0;         if (timestamp.sub(schedule.start) &lt; schedule.duration) {             currentSharesLocked = schedule.shares.sub(                 schedule.shares.mul(timestamp.sub(schedule.start)).div(schedule.duration)             );         }          // add to running total         sharesLocked = sharesLocked.add(currentSharesLocked);     }      // convert shares to reward     // rewardLocked = sharesLocked * rewardBalance / sharesOutstanding     uint256 rewardLocked = sharesLocked.mul(rewardBalance).div(sharesOutstanding);      // calculate amount available     // unlockedRewards = rewardBalance - rewardLocked     unlockedRewards = rewardBalance.sub(rewardLocked);      // explicit return     return unlockedRewards; }  function calculateRewardFromStakes(     StakeData[] memory stakes,     uint256 unstakeAmount,     uint256 unlockedRewards,     uint256 totalStakeUnits,     uint256 timestamp,     RewardScaling memory rewardScaling ) public pure override returns (RewardOutput memory out) {     uint256 stakesToDrop = 0;     while (unstakeAmount &gt; 0) {         // fetch vault stake storage reference         StakeData memory lastStake = stakes[stakes.length.sub(stakesToDrop).sub(1)];          // calculate stake duration         uint256 stakeDuration = timestamp.sub(lastStake.timestamp);          uint256 currentAmount;         if (lastStake.amount &gt; unstakeAmount) {             // set current amount to remaining unstake amount             currentAmount = unstakeAmount;             // amount of last stake is reduced             out.lastStakeAmount = lastStake.amount.sub(unstakeAmount);         } else {             // set current amount to amount of last stake             currentAmount = lastStake.amount;             // add to stakes to drop             stakesToDrop += 1;         }          // update remaining unstakeAmount         unstakeAmount = unstakeAmount.sub(currentAmount);          // calculate reward amount         uint256 currentReward =             calculateReward(                 unlockedRewards,                 currentAmount,                 stakeDuration,                 totalStakeUnits,                 rewardScaling             );          // update cumulative reward         out.reward = out.reward.add(currentReward);          // update cached unlockedRewards         unlockedRewards = unlockedRewards.sub(currentReward);          // calculate time weighted stake         uint256 stakeUnits = currentAmount.mul(stakeDuration);          // update cached totalStakeUnits         totalStakeUnits = totalStakeUnits.sub(stakeUnits);     }      // explicit return     return         RewardOutput(             out.lastStakeAmount,             stakes.length.sub(stakesToDrop),             out.reward,             totalStakeUnits         ); }  function calculateReward(     uint256 unlockedRewards,     uint256 stakeAmount,     uint256 stakeDuration,     uint256 totalStakeUnits,     RewardScaling memory rewardScaling ) public pure override returns (uint256 reward) {     // calculate time weighted stake     uint256 stakeUnits = stakeAmount.mul(stakeDuration);      // calculate base reward     // baseReward = unlockedRewards * stakeUnits / totalStakeUnits     uint256 baseReward = 0;     if (totalStakeUnits != 0) {         // scale reward according to proportional weight         baseReward = unlockedRewards.mul(stakeUnits).div(totalStakeUnits);     }      // calculate scaled reward     // if no scaling or scaling period completed     //   reward = baseReward     // else     //   minReward = baseReward * scalingFloor / scalingCeiling     //   bonusReward = baseReward     //                 * (scalingCeiling - scalingFloor) / scalingCeiling     //                 * duration / scalingTime     //   reward = minReward + bonusReward     if (stakeDuration &gt;= rewardScaling.time || rewardScaling.floor == rewardScaling.ceiling) {         // no reward scaling applied         reward = baseReward;     } else {         // calculate minimum reward using scaling floor         uint256 minReward = baseReward.mul(rewardScaling.floor).div(rewardScaling.ceiling);          // calculate bonus reward with vested portion of scaling factor         uint256 bonusReward =             baseReward                 .mul(stakeDuration)                 .mul(rewardScaling.ceiling.sub(rewardScaling.floor))                 .div(rewardScaling.ceiling)                 .div(rewardScaling.time);          // add minimum reward and bonus reward         reward = minReward.add(bonusReward);     }      // explicit return     return reward; }  /* admin functions */  /// @notice Add funds to the Hypervisor /// access control: only admin /// state machine: ///   - can be called multiple times ///   - only online /// state scope: ///   - increase _hypervisor.rewardSharesOutstanding ///   - append to _hypervisor.rewardSchedules /// token transfer: transfer staking tokens from msg.sender to reward pool /// @param amount uint256 Amount of reward tokens to deposit /// @param duration uint256 Duration over which to linearly unlock rewards function fund(uint256 amount, uint256 duration) external onlyOwner onlyOnline {     // validate duration     require(duration != 0, ""Hypervisor: invalid duration"");      // create new reward shares     // if existing rewards on this Hypervisor     //   mint new shares proportional to % change in rewards remaining     //   newShares = remainingShares * newReward / remainingRewards     // else     //   mint new shares with BASE_SHARES_PER_WEI initial conversion rate     //   store as fixed point number with same  of decimals as reward token     uint256 newRewardShares;     if (_hypervisor.rewardSharesOutstanding &gt; 0) {         uint256 remainingRewards = IERC20(_hypervisor.rewardToken).balanceOf(_hypervisor.rewardPool);         newRewardShares = _hypervisor.rewardSharesOutstanding.mul(amount).div(remainingRewards);     } else {         newRewardShares = amount.mul(BASE_SHARES_PER_WEI);     }      // add reward shares to total     _hypervisor.rewardSharesOutstanding = _hypervisor.rewardSharesOutstanding.add(newRewardShares);      // store new reward schedule     _hypervisor.rewardSchedules.push(RewardSchedule(duration, block.timestamp, newRewardShares));      // transfer reward tokens to reward pool     TransferHelper.safeTransferFrom(         _hypervisor.rewardToken,         msg.sender,         _hypervisor.rewardPool,         amount     );      // emit event     emit HypervisorFunded(amount, duration); }  /// @notice Add vault factory to whitelist /// @dev use this function to enable stakes to vaults coming from the specified ///      factory contract /// access control: only admin /// state machine: ///   - can be called multiple times ///   - not shutdown /// state scope: ///   - append to _vaultFactorySet /// token transfer: none /// @param factory address The address of the vault factory function registerVaultFactory(address factory) external onlyOwner notShutdown {     // add factory to set     require(_vaultFactorySet.add(factory), ""Hypervisor: vault factory already registered"");      // emit event     emit VaultFactoryRegistered(factory); }  /// @notice Remove vault factory from whitelist /// @dev use this function to disable new stakes to vaults coming from the specified ///      factory contract. ///      note: vaults with existing stakes from this factory are sill able to unstake /// access control: only admin /// state machine: ///   - can be called multiple times ///   - not shutdown /// state scope: ///   - remove from _vaultFactorySet /// token transfer: none /// @param factory address The address of the vault factory function removeVaultFactory(address factory) external onlyOwner notShutdown {     // remove factory from set     require(_vaultFactorySet.remove(factory), ""Hypervisor: vault factory not registered"");      // emit event     emit VaultFactoryRemoved(factory); }  /// @notice Register bonus token for distribution /// @dev use this function to enable distribution of any ERC20 held by the RewardPool contract /// access control: only admin /// state machine: ///   - can be called multiple times ///   - only online /// state scope: ///   - append to _bonusTokenSet /// token transfer: none /// @param bonusToken address The address of the bonus token function registerBonusToken(address bonusToken) external onlyOwner onlyOnline {     // verify valid bonus token     _validateAddress(bonusToken);      // verify bonus token count     require(_bonusTokenSet.length() &lt; MAX_REWARD_TOKENS, ""Hypervisor: max bonus tokens reached "");      // add token to set     assert(_bonusTokenSet.add(bonusToken));      // emit event     emit BonusTokenRegistered(bonusToken); }  /// @notice Rescue tokens from RewardPool /// @dev use this function to rescue tokens from RewardPool contract ///      without distributing to stakers or triggering emergency shutdown /// access control: only admin /// state machine: ///   - can be called multiple times ///   - only online /// state scope: none /// token transfer: transfer requested token from RewardPool to recipient /// @param token address The address of the token to rescue /// @param recipient address The address of the recipient /// @param amount uint256 The amount of tokens to rescue function rescueTokensFromRewardPool(     address token,     address recipient,     uint256 amount ) external onlyOwner onlyOnline {     // verify recipient     _validateAddress(recipient);      // check not attempting to unstake reward token     require(token != _hypervisor.rewardToken, ""Hypervisor: invalid address"");      // check not attempting to wthdraw bonus token     require(!_bonusTokenSet.contains(token), ""Hypervisor: invalid address"");      // transfer tokens to recipient     IRewardPool(_hypervisor.rewardPool).sendERC20(token, recipient, amount); }  /* user functions */  /// @notice Stake tokens /// @dev anyone can stake to any vault if they have valid permission /// access control: anyone /// state machine: ///   - can be called multiple times ///   - only online ///   - when vault exists on this Hypervisor /// state scope: ///   - append to _vaults[vault].stakes ///   - increase _vaults[vault].totalStake ///   - increase _hypervisor.totalStake ///   - increase _hypervisor.totalStakeUnits ///   - increase _hypervisor.lastUpdate /// token transfer: transfer staking tokens from msg.sender to vault /// @param vault address The address of the vault to stake from /// @param amount uint256 The amount of staking tokens to stake function stake(     address vault,     uint256 amount,     bytes calldata permission ) external override onlyOnline {     // verify vault is valid     require(isValidVault(vault), ""Hypervisor: vault is not registered"");      // verify non-zero amount     require(amount != 0, ""Hypervisor: no amount staked"");      // fetch vault storage reference     VaultData storage vaultData = _vaults[vault];      // verify stakes boundary not reached     require(         vaultData.stakes.length &lt; MAX_STAKES_PER_VAULT,         ""Hypervisor: MAX_STAKES_PER_VAULT reached""     );      // update cached sum of stake units across all vaults     _updateTotalStakeUnits();      // store amount and timestamp     vaultData.stakes.push(StakeData(amount, block.timestamp));      // update cached total vault and Hypervisor amounts     vaultData.totalStake = vaultData.totalStake.add(amount);     // verify stake quantity without bounds     require(         stakeLimit == 0 || vaultData.totalStake &lt;= stakeLimit,         ""Hypervisor: Stake limit exceeded""     );     _hypervisor.totalStake = _hypervisor.totalStake.add(amount);      // call lock on vault     IUniversalVault(vault).lock(_hypervisor.stakingToken, amount, permission);      // emit event     emit Staked(vault, amount); }  /// @notice Unstake staking tokens and claim reward /// @dev rewards can only be claimed when unstaking /// access control: only owner of vault /// state machine: ///   - when vault exists on this Hypervisor ///   - after stake from vault ///   - can be called multiple times while sufficient stake remains ///   - only online /// state scope: ///   - decrease _hypervisor.rewardSharesOutstanding ///   - decrease _hypervisor.totalStake ///   - increase _hypervisor.lastUpdate ///   - modify _hypervisor.totalStakeUnits ///   - modify _vaults[vault].stakes ///   - decrease _vaults[vault].totalStake /// token transfer: ///   - transfer reward tokens from reward pool to recipient ///   - transfer bonus tokens from reward pool to recipient /// @param vault address The vault to unstake from /// @param amount uint256 The amount of staking tokens to unstake function unstakeAndClaim(     address vault,     uint256 amount,     bytes calldata permission ) external override onlyOnline {     // fetch vault storage reference     VaultData storage vaultData = _vaults[vault];      // verify non-zero amount     require(amount != 0, ""Hypervisor: no amount unstaked"");      address recipient = IUniversalVault(vault).owner();      // validate recipient     _validateAddress(recipient);      // check for sufficient vault stake amount     require(vaultData.totalStake &gt;= amount, ""Hypervisor: insufficient vault stake"");      // check for sufficient Hypervisor stake amount     // if this check fails, there is a bug in stake accounting     assert(_hypervisor.totalStake &gt;= amount);      // update cached sum of stake units across all vaults     _updateTotalStakeUnits();      // get reward amount remaining     uint256 remainingRewards = IERC20(_hypervisor.rewardToken).balanceOf(_hypervisor.rewardPool);      // calculate vested portion of reward pool     uint256 unlockedRewards =         calculateUnlockedRewards(             _hypervisor.rewardSchedules,             remainingRewards,             _hypervisor.rewardSharesOutstanding,             block.timestamp         );      // calculate vault time weighted reward with scaling     RewardOutput memory out =         calculateRewardFromStakes(             vaultData.stakes,             amount,             unlockedRewards,             _hypervisor.totalStakeUnits,             block.timestamp,             _hypervisor.rewardScaling         );      // update stake data in storage     if (out.newStakesCount == 0) {         // all stakes have been unstaked         delete vaultData.stakes;     } else {         // some stakes have been completely or partially unstaked         // delete fully unstaked stakes         while (vaultData.stakes.length &gt; out.newStakesCount) vaultData.stakes.pop();         // update partially unstaked stake         vaultData.stakes[out.newStakesCount.sub(1)].amount = out.lastStakeAmount;     }      // update cached stake totals     vaultData.totalStake = vaultData.totalStake.sub(amount);     _hypervisor.totalStake = _hypervisor.totalStake.sub(amount);     _hypervisor.totalStakeUnits = out.newTotalStakeUnits;      // unlock staking tokens from vault     IUniversalVault(vault).unlock(_hypervisor.stakingToken, amount, permission);      // emit event     emit Unstaked(vault, amount);      // only perform on non-zero reward     if (out.reward &gt; 0) {         // calculate shares to burn         // sharesToBurn = sharesOutstanding * reward / remainingRewards         uint256 sharesToBurn =             _hypervisor.rewardSharesOutstanding.mul(out.reward).div(remainingRewards);          // burn claimed shares         _hypervisor.rewardSharesOutstanding = _hypervisor.rewardSharesOutstanding.sub(sharesToBurn);          // transfer bonus tokens from reward pool to recipient         if (_bonusTokenSet.length() &gt; 0) {             for (uint256 index = 0; index &lt; _bonusTokenSet.length(); index++) {                 // fetch bonus token address reference                 address bonusToken = _bonusTokenSet.at(index);                  // calculate bonus token amount                 // bonusAmount = bonusRemaining * reward / remainingRewards                 uint256 bonusAmount =                     IERC20(bonusToken).balanceOf(_hypervisor.rewardPool).mul(out.reward).div(                         remainingRewards                     );                  // transfer bonus token                 IRewardPool(_hypervisor.rewardPool).sendERC20(bonusToken, recipient, bonusAmount);                  // emit event                 emit RewardClaimed(vault, recipient, bonusToken, bonusAmount);             }         }          // transfer reward tokens from reward pool to recipient         IRewardPool(_hypervisor.rewardPool).sendERC20(_hypervisor.rewardToken, recipient, out.reward);          // emit event         emit RewardClaimed(vault, recipient, _hypervisor.rewardToken, out.reward);     } }  /// @notice Exit Hypervisor without claiming reward /// @dev This function should never revert when correctly called by the vault. ///      A max number of stakes per vault is set with MAX_STAKES_PER_VAULT to ///      place an upper bound on the for loop in calculateTotalStakeUnits(). /// access control: only callable by the vault directly /// state machine: ///   - when vault exists on this Hypervisor ///   - when active stake from this vault ///   - any power state /// state scope: ///   - decrease _hypervisor.totalStake ///   - increase _hypervisor.lastUpdate ///   - modify _hypervisor.totalStakeUnits ///   - delete _vaults[vault] /// token transfer: none function rageQuit() external override {     // fetch vault storage reference     VaultData storage _vaultData = _vaults[msg.sender];      // revert if no active stakes     require(_vaultData.stakes.length != 0, ""Hypervisor: no stake"");      // update cached sum of stake units across all vaults     _updateTotalStakeUnits();      // emit event     emit Unstaked(msg.sender, _vaultData.totalStake);      // update cached totals     _hypervisor.totalStake = _hypervisor.totalStake.sub(_vaultData.totalStake);     _hypervisor.totalStakeUnits = _hypervisor.totalStakeUnits.sub(         calculateTotalStakeUnits(_vaultData.stakes, block.timestamp)     );      // delete stake data     delete _vaults[msg.sender]; }  /* convenience functions */  function _updateTotalStakeUnits() private {     // update cached totalStakeUnits     _hypervisor.totalStakeUnits = getCurrentTotalStakeUnits();     // update cached lastUpdate     _hypervisor.lastUpdate = block.timestamp; }  function _validateAddress(address target) private view {     // sanity check target for potential input errors     require(isValidAddress(target), ""Hypervisor: invalid address""); }  function _truncateStakesArray(StakeData[] memory array, uint256 newLength)     private     pure     returns (StakeData[] memory newArray) {     newArray = new StakeData[](newLength);     for (uint256 index = 0; index &lt; newLength; index++) {         newArray[index] = array[index];     }     return newArray; }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: ""{task}"". Ideas: ""{ideas}"". As the {assistant_role}, your primary objective is to perform a thorough and detailed inspection of the provided contract code, with a particular focus on identifying vulnerabilities related to Potential Data Inconsistency. This type of vulnerability occurs when data may become inconsistent due to incorrect assumptions about how data is stored, accessed, or modified. Proceed with the following steps in your analysis: 1. Scrutinize the contract's code to identify any assumptions made about the behavior of storage and memory when handling data. 2. Look for patterns where data is copied from storage to memory, or vice versa, and determine if these operations are performed correctly. 3. Identify any functions or segments of code where temporary copies of data are made, and assess whether these copies are used appropriately without causing unintended modifications to the original data. 4. Evaluate the overall logic of data manipulation within the contract to ensure that all operations maintain consistency and integrity of the stored data. If you discover any Potential Data Inconsistency vulnerabilities, respond with: "" Potential Data Inconsistency Identified."" For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE ''' DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code ''' If NO Potential Data Inconsistency vulnerabilities are found, respond only with: "" NO Potential Data Inconsistency."" |
| **phase_name** | DataInconsistencyDetector |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 1, 'modification_conclusion': '', 'cycle_index': 1, 'task': '// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport {SafeMath} from ""@openzeppelin/contracts/math/SafeMath.sol"";\nimport {EnumerableSet} from ""@openzeppelin/contracts/utils/EnumerableSet.sol"";\nimport {IERC20} from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";\nimport {Ownable} from ""@openzeppelin/contracts/access/Ownable.sol"";\nimport {TransferHelper} from ""@uniswap/lib/contracts/libraries/TransferHelper.sol"";\n\nimport {IFactory} from ""../factory/IFactory.sol"";\nimport {IInstanceRegistry} from ""../factory/InstanceRegistry.sol"";\nimport {IUniversalVault} from ""../visor/Visor.sol"";\nimport {IRewardPool} from ""./RewardPool.sol"";\nimport {Powered} from ""./Powered.sol"";\n\ninterface IRageQuit {\n    function rageQuit() external;\n}\n\ninterface IHypervisor is IRageQuit {\n    / admin events /\n\n    event HypervisorCreated(address rewardPool, address powerSwitch);\n    event HypervisorFunded(uint256 amount, uint256 duration);\n    event BonusTokenRegistered(address token);\n    event VaultFactoryRegistered(address factory);\n    event VaultFactoryRemoved(address factory);\n\n    / user events /\n\n    event Staked(address vault, uint256 amount);\n    event Unstaked(address vault, uint256 amount);\n    event RewardClaimed(address vault, address recipient, address token, uint256 amount);\n\n    / data types /\n\n    struct HypervisorData {\n        address stakingToken;\n        address rewardToken;\n        address rewardPool;\n        RewardScaling rewardScaling;\n        uint256 rewardSharesOutstanding;\n        uint256 totalStake;\n        uint256 totalStakeUnits;\n        uint256 lastUpdate;\n        RewardSchedule[] rewardSchedules;\n    }\n\n    struct RewardSchedule {\n        uint256 duration;\n        uint256 start;\n        uint256 shares;\n    }\n\n    struct VaultData {\n        uint256 totalStake;\n        StakeData[] stakes;\n    }\n\n    struct StakeData {\n        uint256 amount;\n        uint256 timestamp;\n    }\n\n    struct RewardScaling {\n        uint256 floor;\n        uint256 ceiling;\n        uint256 time;\n    }\n\n    struct RewardOutput {\n        uint256 lastStakeAmount;\n        uint256 newStakesCount;\n        uint256 reward;\n        uint256 newTotalStakeUnits;\n    }\n\n    / user functions /\n\n    function stake(\n        address vault,\n        uint256 amount,\n        bytes calldata permission\n    ) external;\n\n    function unstakeAndClaim(\n        address vault,\n        uint256 amount,\n        bytes calldata permission\n    ) external;\n\n    / getter functions /\n\n    function getHypervisorData() external view returns (HypervisorData memory hypervisor);\n\n    function getBonusTokenSetLength() external view returns (uint256 length);\n\n    function getBonusTokenAtIndex(uint256 index) external view returns (address bonusToken);\n\n    function getVaultFactorySetLength() external view returns (uint256 length);\n\n    function getVaultFactoryAtIndex(uint256 index) external view returns (address factory);\n\n    function getVaultData(address vault) external view returns (VaultData memory vaultData);\n\n    function isValidAddress(address target) external view returns (bool validity);\n\n    function isValidVault(address target) external view returns (bool validity);\n\n    function getCurrentUnlockedRewards() external view returns (uint256 unlockedRewards);\n\n    function getFutureUnlockedRewards(uint256 timestamp)\n        external\n        view\n        returns (uint256 unlockedRewards);\n\n    function getCurrentVaultReward(address vault) external view returns (uint256 reward);\n\n    function getCurrentStakeReward(address vault, uint256 stakeAmount)\n        external\n        view\n        returns (uint256 reward);\n\n    function getFutureVaultReward(address vault, uint256 timestamp)\n        external\n        view\n        returns (uint256 reward);\n\n    function getFutureStakeReward(\n        address vault,\n        uint256 stakeAmount,\n        uint256 timestamp\n    ) external view returns (uint256 reward);\n\n    function getCurrentVaultStakeUnits(address vault) external view returns (uint256 stakeUnits);\n\n    function getFutureVaultStakeUnits(address vault, uint256 timestamp)\n        external\n        view\n        returns (uint256 stakeUnits);\n\n    function getCurrentTotalStakeUnits() external view returns (uint256 totalStakeUnits);\n\n    function getFutureTotalStakeUnits(uint256 timestamp)\n        external\n        view\n        returns (uint256 totalStakeUnits);\n\n    / pure functions /\n\n    function calculateTotalStakeUnits(StakeData[] memory stakes, uint256 timestamp)\n        external\n        pure\n        returns (uint256 totalStakeUnits);\n\n    function calculateStakeUnits(\n        uint256 amount,\n        uint256 start,\n        uint256 end\n    ) external pure returns (uint256 stakeUnits);\n\n    function calculateUnlockedRewards(\n        RewardSchedule[] memory rewardSchedules,\n        uint256 rewardBalance,\n        uint256 sharesOutstanding,\n        uint256 timestamp\n    ) external pure returns (uint256 unlockedRewards);\n\n    function calculateRewardFromStakes(\n        StakeData[] memory stakes,\n        uint256 unstakeAmount,\n        uint256 unlockedRewards,\n        uint256 totalStakeUnits,\n        uint256 timestamp,\n        RewardScaling memory rewardScaling\n    ) external pure returns (RewardOutput memory out);\n\n    function calculateReward(\n        uint256 unlockedRewards,\n        uint256 stakeAmount,\n        uint256 stakeDuration,\n        uint256 totalStakeUnits,\n        RewardScaling memory rewardScaling\n    ) external pure returns (uint256 reward);\n}\n\n/// @title Hypervisor\n/// @notice Reward distribution contract with time multiplier\n/// Access Control\n/// - Power controller:\n///     Can power off / shutdown the Hypervisor\n///     Can withdraw rewards from reward pool once shutdown\n/// - Proxy owner:\n///     Can change arbitrary logic / state by upgrading the Hypervisor\n///     Is unable to operate on user funds due to UniversalVault\n///     Is unable to operate on reward pool funds when reward pool is offline / shutdown\n/// - Hypervisor admin:\n///     Can add funds to the Hypervisor, register bonus tokens, and whitelist new vault factories\n///     Is a subset of proxy owner permissions\n/// - User:\n///     Can deposit / withdraw / ragequit\n/// Hypervisor State Machine\n/// - Online:\n///     Hypervisor is operating normally, all functions are enabled\n/// - Offline:\n///     Hypervisor is temporarely disabled for maintenance\n///     User deposits and withdrawls are disabled, ragequit remains enabled\n///     Users can withdraw their stake through rageQuit() but forego their pending reward\n///     Should only be used when downtime required for an upgrade\n/// - Shutdown:\n///     Hypervisor is permanently disabled\n///     All functions are disabled with the exception of ragequit\n///     Users can withdraw their stake through rageQuit()\n///     Power controller can withdraw from the reward pool\n///     Should only be used if Proxy Owner role is compromized\ncontract Hypervisor is IHypervisor, Powered, Ownable {\n    using SafeMath for uint256;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    / constants /\n\n    // An upper bound on the number of active stakes per vault is required to prevent\n    // calls to rageQuit() from reverting.\n    // With 30 stakes in a vault, ragequit costs 432811 gas which is conservatively lower\n    // than the hardcoded limit of 500k gas on the vault.\n    // This limit is configurable and could be increased in a future deployment.\n    // Ultimately, to avoid a need for fixed upper bounds, the EVM would need to provide\n    // an error code that allows for reliably catching out-of-gas errors on remote calls.\n    uint256 public constant MAX_STAKES_PER_VAULT = 30;\n    uint256 public constant MAX_REWARD_TOKENS = 50;\n    uint256 public constant BASE_SHARES_PER_WEI = 1000000;\n    uint256 public stakeLimit = 2500 ether;\n\n    / storage /\n\n    HypervisorData private _hypervisor;\n    mapping(address =&gt; VaultData) private _vaults;\n    EnumerableSet.AddressSet private _bonusTokenSet;\n    EnumerableSet.AddressSet private _vaultFactorySet;\n\n    / initializer /\n\n    /// @notice Initizalize Hypervisor\n    /// access control: only proxy constructor\n    /// state machine: can only be called once\n    /// state scope: set initialization variables\n    /// token transfer: none\n    /// @param ownerAddress address The admin address\n    /// @param rewardPoolFactory address The factory to use for deploying the RewardPool\n    /// @param powerSwitchFactory address The factory to use for deploying the PowerSwitch\n    /// @param stakingToken address The address of the staking token for this Hypervisor\n    /// @param rewardToken address The address of the reward token for this Hypervisor\n    /// @param rewardScaling RewardScaling The config for reward scaling floor, ceiling, and time\n    constructor(\n        address ownerAddress,\n        address rewardPoolFactory,\n        address powerSwitchFactory,\n        address stakingToken,\n        address rewardToken,\n        RewardScaling memory rewardScaling,\n        uint256 _stakeLimit\n    ) {\n        // the scaling floor must be smaller than ceiling\n        require(rewardScaling.floor &lt;= rewardScaling.ceiling, ""Hypervisor: floor above ceiling"");\n\n        // setting rewardScalingTime to 0 would cause divide by zero error\n        // to disable reward scaling, use rewardScalingFloor == rewardScalingCeiling\n        require(rewardScaling.time != 0, ""Hypervisor: scaling time cannot be zero"");\n\n        // deploy power switch\n        address powerSwitch = IFactory(powerSwitchFactory).create(abi.encode(ownerAddress));\n\n        // deploy reward pool\n        address rewardPool = IFactory(rewardPoolFactory).create(abi.encode(powerSwitch));\n\n        // set internal configs\n        Ownable.transferOwnership(ownerAddress);\n        Powered._setPowerSwitch(powerSwitch);\n\n        // commit to storage\n        _hypervisor.stakingToken = stakingToken;\n        _hypervisor.rewardToken = rewardToken;\n        _hypervisor.rewardPool = rewardPool;\n        _hypervisor.rewardScaling = rewardScaling;\n\n        stakeLimit = _stakeLimit;\n\n        // emit event\n        emit HypervisorCreated(rewardPool, powerSwitch);\n    }\n\n    / getter functions /\n\n    function getBonusTokenSetLength() external view override returns (uint256 length) {\n        return _bonusTokenSet.length();\n    }\n\n    function getBonusTokenAtIndex(uint256 index)\n        external\n        view\n        override\n        returns (address bonusToken)\n    {\n        return _bonusTokenSet.at(index);\n    }\n\n    function getVaultFactorySetLength() external view override returns (uint256 length) {\n        return _vaultFactorySet.length();\n    }\n\n    function getVaultFactoryAtIndex(uint256 index)\n        external\n        view\n        override\n        returns (address factory)\n    {\n        return _vaultFactorySet.at(index);\n    }\n\n    function isValidVault(address target) public view override returns (bool validity) {\n        // validate target is created from whitelisted vault factory\n        for (uint256 index = 0; index &lt; _vaultFactorySet.length(); index++) {\n            if (IInstanceRegistry(_vaultFactorySet.at(index)).isInstance(target)) {\n                return true;\n            }\n        }\n        // explicit return\n        return false;\n    }\n\n    function isValidAddress(address target) public view override returns (bool validity) {\n        // sanity check target for potential input errors\n        return\n            target != address(this) &amp;&amp;\n            target != address(0) &amp;&amp;\n            target != _hypervisor.stakingToken &amp;&amp;\n            target != _hypervisor.rewardToken &amp;&amp;\n            target != _hypervisor.rewardPool &amp;&amp;\n            !_bonusTokenSet.contains(target);\n    }\n\n    / Hypervisor getters /\n\n    function getHypervisorData() external view override returns (HypervisorData memory hypervisor) {\n        return _hypervisor;\n    }\n\n    function getCurrentUnlockedRewards() public view override returns (uint256 unlockedRewards) {\n        // calculate reward available based on state\n        return getFutureUnlockedRewards(block.timestamp);\n    }\n\n    function getFutureUnlockedRewards(uint256 timestamp)\n        public\n        view\n        override\n        returns (uint256 unlockedRewards)\n    {\n        // get reward amount remaining\n        uint256 remainingRewards = IERC20(_hypervisor.rewardToken).balanceOf(_hypervisor.rewardPool);\n        // calculate reward available based on state\n        unlockedRewards = calculateUnlockedRewards(\n            _hypervisor.rewardSchedules,\n            remainingRewards,\n            _hypervisor.rewardSharesOutstanding,\n            timestamp\n        );\n        // explicit return\n        return unlockedRewards;\n    }\n\n    function getCurrentTotalStakeUnits() public view override returns (uint256 totalStakeUnits) {\n        // calculate new stake units\n        return getFutureTotalStakeUnits(block.timestamp);\n    }\n\n    function getFutureTotalStakeUnits(uint256 timestamp)\n        public\n        view\n        override\n        returns (uint256 totalStakeUnits)\n    {\n        // return early if no change\n        if (timestamp == _hypervisor.lastUpdate) return _hypervisor.totalStakeUnits;\n        // calculate new stake units\n        uint256 newStakeUnits =\n            calculateStakeUnits(_hypervisor.totalStake, _hypervisor.lastUpdate, timestamp);\n        // add to cached total\n        totalStakeUnits = _hypervisor.totalStakeUnits.add(newStakeUnits);\n        // explicit return\n        return totalStakeUnits;\n    }\n\n    / vault getters /\n\n    function getVaultData(address vault)\n        external\n        view\n        override\n        returns (VaultData memory vaultData)\n    {\n        return _vaults[vault];\n    }\n\n    function getCurrentVaultReward(address vault) external view override returns (uint256 reward) {\n        // calculate rewards\n        return\n            calculateRewardFromStakes(\n                _vaults[vault]\n                    .stakes,\n                _vaults[vault]\n                    .totalStake,\n                getCurrentUnlockedRewards(),\n                getCurrentTotalStakeUnits(),\n                block\n                    .timestamp,\n                _hypervisor\n                    .rewardScaling\n            )\n                .reward;\n    }\n\n    function getFutureVaultReward(address vault, uint256 timestamp)\n        external\n        view\n        override\n        returns (uint256 reward)\n    {\n        // calculate rewards\n        return\n            calculateRewardFromStakes(\n                _vaults[vault]\n                    .stakes,\n                _vaults[vault]\n                    .totalStake,\n                getFutureUnlockedRewards(timestamp),\n                getFutureTotalStakeUnits(timestamp),\n                timestamp,\n                _hypervisor\n                    .rewardScaling\n            )\n                .reward;\n    }\n\n    function getCurrentStakeReward(address vault, uint256 stakeAmount)\n        external\n        view\n        override\n        returns (uint256 reward)\n    {\n        // calculate rewards\n        return\n            calculateRewardFromStakes(\n                _vaults[vault]\n                    .stakes,\n                stakeAmount,\n                getCurrentUnlockedRewards(),\n                getCurrentTotalStakeUnits(),\n                block\n                    .timestamp,\n                _hypervisor\n                    .rewardScaling\n            )\n                .reward;\n    }\n\n    function getFutureStakeReward(\n        address vault,\n        uint256 stakeAmount,\n        uint256 timestamp\n    ) external view override returns (uint256 reward) {\n        // calculate rewards\n        return\n            calculateRewardFromStakes(\n                _vaults[vault]\n                    .stakes,\n                stakeAmount,\n                getFutureUnlockedRewards(timestamp),\n                getFutureTotalStakeUnits(timestamp),\n                timestamp,\n                _hypervisor\n                    .rewardScaling\n            )\n                .reward;\n    }\n\n    function getCurrentVaultStakeUnits(address vault)\n        public\n        view\n        override\n        returns (uint256 stakeUnits)\n    {\n        // calculate stake units\n        return getFutureVaultStakeUnits(vault, block.timestamp);\n    }\n\n    function getFutureVaultStakeUnits(address vault, uint256 timestamp)\n        public\n        view\n        override\n        returns (uint256 stakeUnits)\n    {\n        // calculate stake units\n        return calculateTotalStakeUnits(_vaults[vault].stakes, timestamp);\n    }\n\n    / pure functions /\n\n    function calculateTotalStakeUnits(StakeData[] memory stakes, uint256 timestamp)\n        public\n        pure\n        override\n        returns (uint256 totalStakeUnits)\n    {\n        for (uint256 index; index &lt; stakes.length; index++) {\n            // reference stake\n            StakeData memory stakeData = stakes[index];\n            // calculate stake units\n            uint256 stakeUnits =\n                calculateStakeUnits(stakeData.amount, stakeData.timestamp, timestamp);\n            // add to running total\n            totalStakeUnits = totalStakeUnits.add(stakeUnits);\n        }\n    }\n\n    function calculateStakeUnits(\n        uint256 amount,\n        uint256 start,\n        uint256 end\n    ) public pure override returns (uint256 stakeUnits) {\n        // calculate duration\n        uint256 duration = end.sub(start);\n        // calculate stake units\n        stakeUnits = duration.mul(amount);\n        // explicit return\n        return stakeUnits;\n    }\n\n    function calculateUnlockedRewards(\n        RewardSchedule[] memory rewardSchedules,\n        uint256 rewardBalance,\n        uint256 sharesOutstanding,\n        uint256 timestamp\n    ) public pure override returns (uint256 unlockedRewards) {\n        // return 0 if no registered schedules\n        if (rewardSchedules.length == 0) {\n            return 0;\n        }\n\n        // calculate reward shares locked across all reward schedules\n        uint256 sharesLocked;\n        for (uint256 index = 0; index &lt; rewardSchedules.length; index++) {\n            // fetch reward schedule storage reference\n            RewardSchedule memory schedule = rewardSchedules[index];\n\n            // caculate amount of shares available on this schedule\n            // if (now - start) &lt; duration\n            //   sharesLocked = shares - (shares * (now - start) / duration)\n            // else\n            //   sharesLocked = 0\n            uint256 currentSharesLocked = 0;\n            if (timestamp.sub(schedule.start) &lt; schedule.duration) {\n                currentSharesLocked = schedule.shares.sub(\n                    schedule.shares.mul(timestamp.sub(schedule.start)).div(schedule.duration)\n                );\n            }\n\n            // add to running total\n            sharesLocked = sharesLocked.add(currentSharesLocked);\n        }\n\n        // convert shares to reward\n        // rewardLocked = sharesLocked * rewardBalance / sharesOutstanding\n        uint256 rewardLocked = sharesLocked.mul(rewardBalance).div(sharesOutstanding);\n\n        // calculate amount available\n        // unlockedRewards = rewardBalance - rewardLocked\n        unlockedRewards = rewardBalance.sub(rewardLocked);\n\n        // explicit return\n        return unlockedRewards;\n    }\n\n    function calculateRewardFromStakes(\n        StakeData[] memory stakes,\n        uint256 unstakeAmount,\n        uint256 unlockedRewards,\n        uint256 totalStakeUnits,\n        uint256 timestamp,\n        RewardScaling memory rewardScaling\n    ) public pure override returns (RewardOutput memory out) {\n        uint256 stakesToDrop = 0;\n        while (unstakeAmount &gt; 0) {\n            // fetch vault stake storage reference\n            StakeData memory lastStake = stakes[stakes.length.sub(stakesToDrop).sub(1)];\n\n            // calculate stake duration\n            uint256 stakeDuration = timestamp.sub(lastStake.timestamp);\n\n            uint256 currentAmount;\n            if (lastStake.amount &gt; unstakeAmount) {\n                // set current amount to remaining unstake amount\n                currentAmount = unstakeAmount;\n                // amount of last stake is reduced\n                out.lastStakeAmount = lastStake.amount.sub(unstakeAmount);\n            } else {\n                // set current amount to amount of last stake\n                currentAmount = lastStake.amount;\n                // add to stakes to drop\n                stakesToDrop += 1;\n            }\n\n            // update remaining unstakeAmount\n            unstakeAmount = unstakeAmount.sub(currentAmount);\n\n            // calculate reward amount\n            uint256 currentReward =\n                calculateReward(\n                    unlockedRewards,\n                    currentAmount,\n                    stakeDuration,\n                    totalStakeUnits,\n                    rewardScaling\n                );\n\n            // update cumulative reward\n            out.reward = out.reward.add(currentReward);\n\n            // update cached unlockedRewards\n            unlockedRewards = unlockedRewards.sub(currentReward);\n\n            // calculate time weighted stake\n            uint256 stakeUnits = currentAmount.mul(stakeDuration);\n\n            // update cached totalStakeUnits\n            totalStakeUnits = totalStakeUnits.sub(stakeUnits);\n        }\n\n        // explicit return\n        return\n            RewardOutput(\n                out.lastStakeAmount,\n                stakes.length.sub(stakesToDrop),\n                out.reward,\n                totalStakeUnits\n            );\n    }\n\n    function calculateReward(\n        uint256 unlockedRewards,\n        uint256 stakeAmount,\n        uint256 stakeDuration,\n        uint256 totalStakeUnits,\n        RewardScaling memory rewardScaling\n    ) public pure override returns (uint256 reward) {\n        // calculate time weighted stake\n        uint256 stakeUnits = stakeAmount.mul(stakeDuration);\n\n        // calculate base reward\n        // baseReward = unlockedRewards * stakeUnits / totalStakeUnits\n        uint256 baseReward = 0;\n        if (totalStakeUnits != 0) {\n            // scale reward according to proportional weight\n            baseReward = unlockedRewards.mul(stakeUnits).div(totalStakeUnits);\n        }\n\n        // calculate scaled reward\n        // if no scaling or scaling period completed\n        //   reward = baseReward\n        // else\n        //   minReward = baseReward * scalingFloor / scalingCeiling\n        //   bonusReward = baseReward\n        //                 * (scalingCeiling - scalingFloor) / scalingCeiling\n        //                 * duration / scalingTime\n        //   reward = minReward + bonusReward\n        if (stakeDuration &gt;= rewardScaling.time || rewardScaling.floor == rewardScaling.ceiling) {\n            // no reward scaling applied\n            reward = baseReward;\n        } else {\n            // calculate minimum reward using scaling floor\n            uint256 minReward = baseReward.mul(rewardScaling.floor).div(rewardScaling.ceiling);\n\n            // calculate bonus reward with vested portion of scaling factor\n            uint256 bonusReward =\n                baseReward\n                    .mul(stakeDuration)\n                    .mul(rewardScaling.ceiling.sub(rewardScaling.floor))\n                    .div(rewardScaling.ceiling)\n                    .div(rewardScaling.time);\n\n            // add minimum reward and bonus reward\n            reward = minReward.add(bonusReward);\n        }\n\n        // explicit return\n        return reward;\n    }\n\n    / admin functions /\n\n    /// @notice Add funds to the Hypervisor\n    /// access control: only admin\n    /// state machine:\n    ///   - can be called multiple times\n    ///   - only online\n    /// state scope:\n    ///   - increase _hypervisor.rewardSharesOutstanding\n    ///   - append to _hypervisor.rewardSchedules\n    /// token transfer: transfer staking tokens from msg.sender to reward pool\n    /// @param amount uint256 Amount of reward tokens to deposit\n    /// @param duration uint256 Duration over which to linearly unlock rewards\n    function fund(uint256 amount, uint256 duration) external onlyOwner onlyOnline {\n        // validate duration\n        require(duration != 0, ""Hypervisor: invalid duration"");\n\n        // create new reward shares\n        // if existing rewards on this Hypervisor\n        //   mint new shares proportional to % change in rewards remaining\n        //   newShares = remainingShares * newReward / remainingRewards\n        // else\n        //   mint new shares with BASE_SHARES_PER_WEI initial conversion rate\n        //   store as fixed point number with same  of decimals as reward token\n        uint256 newRewardShares;\n        if (_hypervisor.rewardSharesOutstanding &gt; 0) {\n            uint256 remainingRewards = IERC20(_hypervisor.rewardToken).balanceOf(_hypervisor.rewardPool);\n            newRewardShares = _hypervisor.rewardSharesOutstanding.mul(amount).div(remainingRewards);\n        } else {\n            newRewardShares = amount.mul(BASE_SHARES_PER_WEI);\n        }\n\n        // add reward shares to total\n        _hypervisor.rewardSharesOutstanding = _hypervisor.rewardSharesOutstanding.add(newRewardShares);\n\n        // store new reward schedule\n        _hypervisor.rewardSchedules.push(RewardSchedule(duration, block.timestamp, newRewardShares));\n\n        // transfer reward tokens to reward pool\n        TransferHelper.safeTransferFrom(\n            _hypervisor.rewardToken,\n            msg.sender,\n            _hypervisor.rewardPool,\n            amount\n        );\n\n        // emit event\n        emit HypervisorFunded(amount, duration);\n    }\n\n    /// @notice Add vault factory to whitelist\n    /// @dev use this function to enable stakes to vaults coming from the specified\n    ///      factory contract\n    /// access control: only admin\n    /// state machine:\n    ///   - can be called multiple times\n    ///   - not shutdown\n    /// state scope:\n    ///   - append to _vaultFactorySet\n    /// token transfer: none\n    /// @param factory address The address of the vault factory\n    function registerVaultFactory(address factory) external onlyOwner notShutdown {\n        // add factory to set\n        require(_vaultFactorySet.add(factory), ""Hypervisor: vault factory already registered"");\n\n        // emit event\n        emit VaultFactoryRegistered(factory);\n    }\n\n    /// @notice Remove vault factory from whitelist\n    /// @dev use this function to disable new stakes to vaults coming from the specified\n    ///      factory contract.\n    ///      note: vaults with existing stakes from this factory are sill able to unstake\n    /// access control: only admin\n    /// state machine:\n    ///   - can be called multiple times\n    ///   - not shutdown\n    /// state scope:\n    ///   - remove from _vaultFactorySet\n    /// token transfer: none\n    /// @param factory address The address of the vault factory\n    function removeVaultFactory(address factory) external onlyOwner notShutdown {\n        // remove factory from set\n        require(_vaultFactorySet.remove(factory), ""Hypervisor: vault factory not registered"");\n\n        // emit event\n        emit VaultFactoryRemoved(factory);\n    }\n\n    /// @notice Register bonus token for distribution\n    /// @dev use this function to enable distribution of any ERC20 held by the RewardPool contract\n    /// access control: only admin\n    /// state machine:\n    ///   - can be called multiple times\n    ///   - only online\n    /// state scope:\n    ///   - append to _bonusTokenSet\n    /// token transfer: none\n    /// @param bonusToken address The address of the bonus token\n    function registerBonusToken(address bonusToken) external onlyOwner onlyOnline {\n        // verify valid bonus token\n        _validateAddress(bonusToken);\n\n        // verify bonus token count\n        require(_bonusTokenSet.length() &lt; MAX_REWARD_TOKENS, ""Hypervisor: max bonus tokens reached "");\n\n        // add token to set\n        assert(_bonusTokenSet.add(bonusToken));\n\n        // emit event\n        emit BonusTokenRegistered(bonusToken);\n    }\n\n    /// @notice Rescue tokens from RewardPool\n    /// @dev use this function to rescue tokens from RewardPool contract\n    ///      without distributing to stakers or triggering emergency shutdown\n    /// access control: only admin\n    /// state machine:\n    ///   - can be called multiple times\n    ///   - only online\n    /// state scope: none\n    /// token transfer: transfer requested token from RewardPool to recipient\n    /// @param token address The address of the token to rescue\n    /// @param recipient address The address of the recipient\n    /// @param amount uint256 The amount of tokens to rescue\n    function rescueTokensFromRewardPool(\n        address token,\n        address recipient,\n        uint256 amount\n    ) external onlyOwner onlyOnline {\n        // verify recipient\n        _validateAddress(recipient);\n\n        // check not attempting to unstake reward token\n        require(token != _hypervisor.rewardToken, ""Hypervisor: invalid address"");\n\n        // check not attempting to wthdraw bonus token\n        require(!_bonusTokenSet.contains(token), ""Hypervisor: invalid address"");\n\n        // transfer tokens to recipient\n        IRewardPool(_hypervisor.rewardPool).sendERC20(token, recipient, amount);\n    }\n\n    / user functions /\n\n    /// @notice Stake tokens\n    /// @dev anyone can stake to any vault if they have valid permission\n    /// access control: anyone\n    /// state machine:\n    ///   - can be called multiple times\n    ///   - only online\n    ///   - when vault exists on this Hypervisor\n    /// state scope:\n    ///   - append to _vaults[vault].stakes\n    ///   - increase _vaults[vault].totalStake\n    ///   - increase _hypervisor.totalStake\n    ///   - increase _hypervisor.totalStakeUnits\n    ///   - increase _hypervisor.lastUpdate\n    /// token transfer: transfer staking tokens from msg.sender to vault\n    /// @param vault address The address of the vault to stake from\n    /// @param amount uint256 The amount of staking tokens to stake\n    function stake(\n        address vault,\n        uint256 amount,\n        bytes calldata permission\n    ) external override onlyOnline {\n        // verify vault is valid\n        require(isValidVault(vault), ""Hypervisor: vault is not registered"");\n\n        // verify non-zero amount\n        require(amount != 0, ""Hypervisor: no amount staked"");\n\n        // fetch vault storage reference\n        VaultData storage vaultData = _vaults[vault];\n\n        // verify stakes boundary not reached\n        require(\n            vaultData.stakes.length &lt; MAX_STAKES_PER_VAULT,\n            ""Hypervisor: MAX_STAKES_PER_VAULT reached""\n        );\n\n        // update cached sum of stake units across all vaults\n        _updateTotalStakeUnits();\n\n        // store amount and timestamp\n        vaultData.stakes.push(StakeData(amount, block.timestamp));\n\n        // update cached total vault and Hypervisor amounts\n        vaultData.totalStake = vaultData.totalStake.add(amount);\n        // verify stake quantity without bounds\n        require(\n            stakeLimit == 0 || vaultData.totalStake &lt;= stakeLimit,\n            ""Hypervisor: Stake limit exceeded""\n        );\n        _hypervisor.totalStake = _hypervisor.totalStake.add(amount);\n\n        // call lock on vault\n        IUniversalVault(vault).lock(_hypervisor.stakingToken, amount, permission);\n\n        // emit event\n        emit Staked(vault, amount);\n    }\n\n    /// @notice Unstake staking tokens and claim reward\n    /// @dev rewards can only be claimed when unstaking\n    /// access control: only owner of vault\n    /// state machine:\n    ///   - when vault exists on this Hypervisor\n    ///   - after stake from vault\n    ///   - can be called multiple times while sufficient stake remains\n    ///   - only online\n    /// state scope:\n    ///   - decrease _hypervisor.rewardSharesOutstanding\n    ///   - decrease _hypervisor.totalStake\n    ///   - increase _hypervisor.lastUpdate\n    ///   - modify _hypervisor.totalStakeUnits\n    ///   - modify _vaults[vault].stakes\n    ///   - decrease _vaults[vault].totalStake\n    /// token transfer:\n    ///   - transfer reward tokens from reward pool to recipient\n    ///   - transfer bonus tokens from reward pool to recipient\n    /// @param vault address The vault to unstake from\n    /// @param amount uint256 The amount of staking tokens to unstake\n    function unstakeAndClaim(\n        address vault,\n        uint256 amount,\n        bytes calldata permission\n    ) external override onlyOnline {\n        // fetch vault storage reference\n        VaultData storage vaultData = _vaults[vault];\n\n        // verify non-zero amount\n        require(amount != 0, ""Hypervisor: no amount unstaked"");\n\n        address recipient = IUniversalVault(vault).owner();\n\n        // validate recipient\n        _validateAddress(recipient);\n\n        // check for sufficient vault stake amount\n        require(vaultData.totalStake &gt;= amount, ""Hypervisor: insufficient vault stake"");\n\n        // check for sufficient Hypervisor stake amount\n        // if this check fails, there is a bug in stake accounting\n        assert(_hypervisor.totalStake &gt;= amount);\n\n        // update cached sum of stake units across all vaults\n        _updateTotalStakeUnits();\n\n        // get reward amount remaining\n        uint256 remainingRewards = IERC20(_hypervisor.rewardToken).balanceOf(_hypervisor.rewardPool);\n\n        // calculate vested portion of reward pool\n        uint256 unlockedRewards =\n            calculateUnlockedRewards(\n                _hypervisor.rewardSchedules,\n                remainingRewards,\n                _hypervisor.rewardSharesOutstanding,\n                block.timestamp\n            );\n\n        // calculate vault time weighted reward with scaling\n        RewardOutput memory out =\n            calculateRewardFromStakes(\n                vaultData.stakes,\n                amount,\n                unlockedRewards,\n                _hypervisor.totalStakeUnits,\n                block.timestamp,\n                _hypervisor.rewardScaling\n            );\n\n        // update stake data in storage\n        if (out.newStakesCount == 0) {\n            // all stakes have been unstaked\n            delete vaultData.stakes;\n        } else {\n            // some stakes have been completely or partially unstaked\n            // delete fully unstaked stakes\n            while (vaultData.stakes.length &gt; out.newStakesCount) vaultData.stakes.pop();\n            // update partially unstaked stake\n            vaultData.stakes[out.newStakesCount.sub(1)].amount = out.lastStakeAmount;\n        }\n\n        // update cached stake totals\n        vaultData.totalStake = vaultData.totalStake.sub(amount);\n        _hypervisor.totalStake = _hypervisor.totalStake.sub(amount);\n        _hypervisor.totalStakeUnits = out.newTotalStakeUnits;\n\n        // unlock staking tokens from vault\n        IUniversalVault(vault).unlock(_hypervisor.stakingToken, amount, permission);\n\n        // emit event\n        emit Unstaked(vault, amount);\n\n        // only perform on non-zero reward\n        if (out.reward &gt; 0) {\n            // calculate shares to burn\n            // sharesToBurn = sharesOutstanding * reward / remainingRewards\n            uint256 sharesToBurn =\n                _hypervisor.rewardSharesOutstanding.mul(out.reward).div(remainingRewards);\n\n            // burn claimed shares\n            _hypervisor.rewardSharesOutstanding = _hypervisor.rewardSharesOutstanding.sub(sharesToBurn);\n\n            // transfer bonus tokens from reward pool to recipient\n            if (_bonusTokenSet.length() &gt; 0) {\n                for (uint256 index = 0; index &lt; _bonusTokenSet.length(); index++) {\n                    // fetch bonus token address reference\n                    address bonusToken = _bonusTokenSet.at(index);\n\n                    // calculate bonus token amount\n                    // bonusAmount = bonusRemaining * reward / remainingRewards\n                    uint256 bonusAmount =\n                        IERC20(bonusToken).balanceOf(_hypervisor.rewardPool).mul(out.reward).div(\n                            remainingRewards\n                        );\n\n                    // transfer bonus token\n                    IRewardPool(_hypervisor.rewardPool).sendERC20(bonusToken, recipient, bonusAmount);\n\n                    // emit event\n                    emit RewardClaimed(vault, recipient, bonusToken, bonusAmount);\n                }\n            }\n\n            // transfer reward tokens from reward pool to recipient\n            IRewardPool(_hypervisor.rewardPool).sendERC20(_hypervisor.rewardToken, recipient, out.reward);\n\n            // emit event\n            emit RewardClaimed(vault, recipient, _hypervisor.rewardToken, out.reward);\n        }\n    }\n\n    /// @notice Exit Hypervisor without claiming reward\n    /// @dev This function should never revert when correctly called by the vault.\n    ///      A max number of stakes per vault is set with MAX_STAKES_PER_VAULT to\n    ///      place an upper bound on the for loop in calculateTotalStakeUnits().\n    /// access control: only callable by the vault directly\n    /// state machine:\n    ///   - when vault exists on this Hypervisor\n    ///   - when active stake from this vault\n    ///   - any power state\n    /// state scope:\n    ///   - decrease _hypervisor.totalStake\n    ///   - increase _hypervisor.lastUpdate\n    ///   - modify _hypervisor.totalStakeUnits\n    ///   - delete _vaults[vault]\n    /// token transfer: none\n    function rageQuit() external override {\n        // fetch vault storage reference\n        VaultData storage _vaultData = _vaults[msg.sender];\n\n        // revert if no active stakes\n        require(_vaultData.stakes.length != 0, ""Hypervisor: no stake"");\n\n        // update cached sum of stake units across all vaults\n        _updateTotalStakeUnits();\n\n        // emit event\n        emit Unstaked(msg.sender, _vaultData.totalStake);\n\n        // update cached totals\n        _hypervisor.totalStake = _hypervisor.totalStake.sub(_vaultData.totalStake);\n        _hypervisor.totalStakeUnits = _hypervisor.totalStakeUnits.sub(\n            calculateTotalStakeUnits(_vaultData.stakes, block.timestamp)\n        );\n\n        // delete stake data\n        delete _vaults[msg.sender];\n    }\n\n    / convenience functions /\n\n    function _updateTotalStakeUnits() private {\n        // update cached totalStakeUnits\n        _hypervisor.totalStakeUnits = getCurrentTotalStakeUnits();\n        // update cached lastUpdate\n        _hypervisor.lastUpdate = block.timestamp;\n    }\n\n    function _validateAddress(address target) private view {\n        // sanity check target for potential input errors\n        require(isValidAddress(target), ""Hypervisor: invalid address"");\n    }\n\n    function _truncateStakesArray(StakeData[] memory array, uint256 newLength)\n        private\n        pure\n        returns (StakeData[] memory newArray)\n    {\n        newArray = new StakeData;\n        for (uint256 index = 0; index &lt; newLength; index++) {\n            newArray[index] = array[index];\n        }\n        return newArray;\n    }\n}\n', 'ideas': "" Lack of Authorization Identified.\n\n\nLACK OF AUTHORIZATION\n'''\nThe `rageQuit()` function allows any user to exit the Hypervisor without claiming rewards. This function is callable by any address that has a registered vault, as it does not have any access control modifiers restricting its invocation. This could potentially allow malicious actors to exploit this function to withdraw stakes without proper authorization, especially if they manage to create a vault.\n\nRecommended Mitigation:\nImplement an access control modifier to restrict the `rageQuit()` function to only allow calls from the owner of the vault. This can be done by checking if `msg.sender` is the owner of the vault before allowing the function to execute.\n'''\n\n\n``\nLACK OF AUTHORIZATION\n'''\nTheunstakeAndClaim""} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-02-08 00:44:10 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **task_prompt** | // SPDX-License-Identifier: GPL-3.0-only pragma solidity 0.7.6; pragma abicoder v2; import {SafeMath} from ""@openzeppelin/contracts/math/SafeMath.sol""; import {EnumerableSet} from ""@openzeppelin/contracts/utils/EnumerableSet.sol""; import {IERC20} from ""@openzeppelin/contracts/token/ERC20/IERC20.sol""; import {Ownable} from ""@openzeppelin/contracts/access/Ownable.sol""; import {TransferHelper} from ""@uniswap/lib/contracts/libraries/TransferHelper.sol""; import {IFactory} from ""../factory/IFactory.sol""; import {IInstanceRegistry} from ""../factory/InstanceRegistry.sol""; import {IUniversalVault} from ""../visor/Visor.sol""; import {IRewardPool} from ""./RewardPool.sol""; import {Powered} from ""./Powered.sol""; interface IRageQuit {     function rageQuit() external; } interface IHypervisor is IRageQuit {     / admin events / event HypervisorCreated(address rewardPool, address powerSwitch); event HypervisorFunded(uint256 amount, uint256 duration); event BonusTokenRegistered(address token); event VaultFactoryRegistered(address factory); event VaultFactoryRemoved(address factory);  /* user events */  event Staked(address vault, uint256 amount); event Unstaked(address vault, uint256 amount); event RewardClaimed(address vault, address recipient, address token, uint256 amount);  /* data types */  struct HypervisorData {     address stakingToken;     address rewardToken;     address rewardPool;     RewardScaling rewardScaling;     uint256 rewardSharesOutstanding;     uint256 totalStake;     uint256 totalStakeUnits;     uint256 lastUpdate;     RewardSchedule[] rewardSchedules; }  struct RewardSchedule {     uint256 duration;     uint256 start;     uint256 shares; }  struct VaultData {     uint256 totalStake;     StakeData[] stakes; }  struct StakeData {     uint256 amount;     uint256 timestamp; }  struct RewardScaling {     uint256 floor;     uint256 ceiling;     uint256 time; }  struct RewardOutput {     uint256 lastStakeAmount;     uint256 newStakesCount;     uint256 reward;     uint256 newTotalStakeUnits; }  /* user functions */  function stake(     address vault,     uint256 amount,     bytes calldata permission ) external;  function unstakeAndClaim(     address vault,     uint256 amount,     bytes calldata permission ) external;  /* getter functions */  function getHypervisorData() external view returns (HypervisorData memory hypervisor);  function getBonusTokenSetLength() external view returns (uint256 length);  function getBonusTokenAtIndex(uint256 index) external view returns (address bonusToken);  function getVaultFactorySetLength() external view returns (uint256 length);  function getVaultFactoryAtIndex(uint256 index) external view returns (address factory);  function getVaultData(address vault) external view returns (VaultData memory vaultData);  function isValidAddress(address target) external view returns (bool validity);  function isValidVault(address target) external view returns (bool validity);  function getCurrentUnlockedRewards() external view returns (uint256 unlockedRewards);  function getFutureUnlockedRewards(uint256 timestamp)     external     view     returns (uint256 unlockedRewards);  function getCurrentVaultReward(address vault) external view returns (uint256 reward);  function getCurrentStakeReward(address vault, uint256 stakeAmount)     external     view     returns (uint256 reward);  function getFutureVaultReward(address vault, uint256 timestamp)     external     view     returns (uint256 reward);  function getFutureStakeReward(     address vault,     uint256 stakeAmount,     uint256 timestamp ) external view returns (uint256 reward);  function getCurrentVaultStakeUnits(address vault) external view returns (uint256 stakeUnits);  function getFutureVaultStakeUnits(address vault, uint256 timestamp)     external     view     returns (uint256 stakeUnits);  function getCurrentTotalStakeUnits() external view returns (uint256 totalStakeUnits);  function getFutureTotalStakeUnits(uint256 timestamp)     external     view     returns (uint256 totalStakeUnits);  /* pure functions */  function calculateTotalStakeUnits(StakeData[] memory stakes, uint256 timestamp)     external     pure     returns (uint256 totalStakeUnits);  function calculateStakeUnits(     uint256 amount,     uint256 start,     uint256 end ) external pure returns (uint256 stakeUnits);  function calculateUnlockedRewards(     RewardSchedule[] memory rewardSchedules,     uint256 rewardBalance,     uint256 sharesOutstanding,     uint256 timestamp ) external pure returns (uint256 unlockedRewards);  function calculateRewardFromStakes(     StakeData[] memory stakes,     uint256 unstakeAmount,     uint256 unlockedRewards,     uint256 totalStakeUnits,     uint256 timestamp,     RewardScaling memory rewardScaling ) external pure returns (RewardOutput memory out);  function calculateReward(     uint256 unlockedRewards,     uint256 stakeAmount,     uint256 stakeDuration,     uint256 totalStakeUnits,     RewardScaling memory rewardScaling ) external pure returns (uint256 reward);  } /// @title Hypervisor /// @notice Reward distribution contract with time multiplier /// Access Control /// - Power controller: ///     Can power off / shutdown the Hypervisor ///     Can withdraw rewards from reward pool once shutdown /// - Proxy owner: ///     Can change arbitrary logic / state by upgrading the Hypervisor ///     Is unable to operate on user funds due to UniversalVault ///     Is unable to operate on reward pool funds when reward pool is offline / shutdown /// - Hypervisor admin: ///     Can add funds to the Hypervisor, register bonus tokens, and whitelist new vault factories ///     Is a subset of proxy owner permissions /// - User: ///     Can deposit / withdraw / ragequit /// Hypervisor State Machine /// - Online: ///     Hypervisor is operating normally, all functions are enabled /// - Offline: ///     Hypervisor is temporarely disabled for maintenance ///     User deposits and withdrawls are disabled, ragequit remains enabled ///     Users can withdraw their stake through rageQuit() but forego their pending reward ///     Should only be used when downtime required for an upgrade /// - Shutdown: ///     Hypervisor is permanently disabled ///     All functions are disabled with the exception of ragequit ///     Users can withdraw their stake through rageQuit() ///     Power controller can withdraw from the reward pool ///     Should only be used if Proxy Owner role is compromized contract Hypervisor is IHypervisor, Powered, Ownable {     using SafeMath for uint256;     using EnumerableSet for EnumerableSet.AddressSet; /* constants */  // An upper bound on the number of active stakes per vault is required to prevent // calls to rageQuit() from reverting. // With 30 stakes in a vault, ragequit costs 432811 gas which is conservatively lower // than the hardcoded limit of 500k gas on the vault. // This limit is configurable and could be increased in a future deployment. // Ultimately, to avoid a need for fixed upper bounds, the EVM would need to provide // an error code that allows for reliably catching out-of-gas errors on remote calls. uint256 public constant MAX_STAKES_PER_VAULT = 30; uint256 public constant MAX_REWARD_TOKENS = 50; uint256 public constant BASE_SHARES_PER_WEI = 1000000; uint256 public stakeLimit = 2500 ether;  /* storage */  HypervisorData private _hypervisor; mapping(address =&gt; VaultData) private _vaults; EnumerableSet.AddressSet private _bonusTokenSet; EnumerableSet.AddressSet private _vaultFactorySet;  /* initializer */  /// @notice Initizalize Hypervisor /// access control: only proxy constructor /// state machine: can only be called once /// state scope: set initialization variables /// token transfer: none /// @param ownerAddress address The admin address /// @param rewardPoolFactory address The factory to use for deploying the RewardPool /// @param powerSwitchFactory address The factory to use for deploying the PowerSwitch /// @param stakingToken address The address of the staking token for this Hypervisor /// @param rewardToken address The address of the reward token for this Hypervisor /// @param rewardScaling RewardScaling The config for reward scaling floor, ceiling, and time constructor(     address ownerAddress,     address rewardPoolFactory,     address powerSwitchFactory,     address stakingToken,     address rewardToken,     RewardScaling memory rewardScaling,     uint256 _stakeLimit ) {     // the scaling floor must be smaller than ceiling     require(rewardScaling.floor &lt;= rewardScaling.ceiling, ""Hypervisor: floor above ceiling"");      // setting rewardScalingTime to 0 would cause divide by zero error     // to disable reward scaling, use rewardScalingFloor == rewardScalingCeiling     require(rewardScaling.time != 0, ""Hypervisor: scaling time cannot be zero"");      // deploy power switch     address powerSwitch = IFactory(powerSwitchFactory).create(abi.encode(ownerAddress));      // deploy reward pool     address rewardPool = IFactory(rewardPoolFactory).create(abi.encode(powerSwitch));      // set internal configs     Ownable.transferOwnership(ownerAddress);     Powered._setPowerSwitch(powerSwitch);      // commit to storage     _hypervisor.stakingToken = stakingToken;     _hypervisor.rewardToken = rewardToken;     _hypervisor.rewardPool = rewardPool;     _hypervisor.rewardScaling = rewardScaling;      stakeLimit = _stakeLimit;      // emit event     emit HypervisorCreated(rewardPool, powerSwitch); }  /* getter functions */  function getBonusTokenSetLength() external view override returns (uint256 length) {     return _bonusTokenSet.length(); }  function getBonusTokenAtIndex(uint256 index)     external     view     override     returns (address bonusToken) {     return _bonusTokenSet.at(index); }  function getVaultFactorySetLength() external view override returns (uint256 length) {     return _vaultFactorySet.length(); }  function getVaultFactoryAtIndex(uint256 index)     external     view     override     returns (address factory) {     return _vaultFactorySet.at(index); }  function isValidVault(address target) public view override returns (bool validity) {     // validate target is created from whitelisted vault factory     for (uint256 index = 0; index &lt; _vaultFactorySet.length(); index++) {         if (IInstanceRegistry(_vaultFactorySet.at(index)).isInstance(target)) {             return true;         }     }     // explicit return     return false; }  function isValidAddress(address target) public view override returns (bool validity) {     // sanity check target for potential input errors     return         target != address(this) &amp;&amp;         target != address(0) &amp;&amp;         target != _hypervisor.stakingToken &amp;&amp;         target != _hypervisor.rewardToken &amp;&amp;         target != _hypervisor.rewardPool &amp;&amp;         !_bonusTokenSet.contains(target); }  /* Hypervisor getters */  function getHypervisorData() external view override returns (HypervisorData memory hypervisor) {     return _hypervisor; }  function getCurrentUnlockedRewards() public view override returns (uint256 unlockedRewards) {     // calculate reward available based on state     return getFutureUnlockedRewards(block.timestamp); }  function getFutureUnlockedRewards(uint256 timestamp)     public     view     override     returns (uint256 unlockedRewards) {     // get reward amount remaining     uint256 remainingRewards = IERC20(_hypervisor.rewardToken).balanceOf(_hypervisor.rewardPool);     // calculate reward available based on state     unlockedRewards = calculateUnlockedRewards(         _hypervisor.rewardSchedules,         remainingRewards,         _hypervisor.rewardSharesOutstanding,         timestamp     );     // explicit return     return unlockedRewards; }  function getCurrentTotalStakeUnits() public view override returns (uint256 totalStakeUnits) {     // calculate new stake units     return getFutureTotalStakeUnits(block.timestamp); }  function getFutureTotalStakeUnits(uint256 timestamp)     public     view     override     returns (uint256 totalStakeUnits) {     // return early if no change     if (timestamp == _hypervisor.lastUpdate) return _hypervisor.totalStakeUnits;     // calculate new stake units     uint256 newStakeUnits =         calculateStakeUnits(_hypervisor.totalStake, _hypervisor.lastUpdate, timestamp);     // add to cached total     totalStakeUnits = _hypervisor.totalStakeUnits.add(newStakeUnits);     // explicit return     return totalStakeUnits; }  /* vault getters */  function getVaultData(address vault)     external     view     override     returns (VaultData memory vaultData) {     return _vaults[vault]; }  function getCurrentVaultReward(address vault) external view override returns (uint256 reward) {     // calculate rewards     return         calculateRewardFromStakes(             _vaults[vault]                 .stakes,             _vaults[vault]                 .totalStake,             getCurrentUnlockedRewards(),             getCurrentTotalStakeUnits(),             block                 .timestamp,             _hypervisor                 .rewardScaling         )             .reward; }  function getFutureVaultReward(address vault, uint256 timestamp)     external     view     override     returns (uint256 reward) {     // calculate rewards     return         calculateRewardFromStakes(             _vaults[vault]                 .stakes,             _vaults[vault]                 .totalStake,             getFutureUnlockedRewards(timestamp),             getFutureTotalStakeUnits(timestamp),             timestamp,             _hypervisor                 .rewardScaling         )             .reward; }  function getCurrentStakeReward(address vault, uint256 stakeAmount)     external     view     override     returns (uint256 reward) {     // calculate rewards     return         calculateRewardFromStakes(             _vaults[vault]                 .stakes,             stakeAmount,             getCurrentUnlockedRewards(),             getCurrentTotalStakeUnits(),             block                 .timestamp,             _hypervisor                 .rewardScaling         )             .reward; }  function getFutureStakeReward(     address vault,     uint256 stakeAmount,     uint256 timestamp ) external view override returns (uint256 reward) {     // calculate rewards     return         calculateRewardFromStakes(             _vaults[vault]                 .stakes,             stakeAmount,             getFutureUnlockedRewards(timestamp),             getFutureTotalStakeUnits(timestamp),             timestamp,             _hypervisor                 .rewardScaling         )             .reward; }  function getCurrentVaultStakeUnits(address vault)     public     view     override     returns (uint256 stakeUnits) {     // calculate stake units     return getFutureVaultStakeUnits(vault, block.timestamp); }  function getFutureVaultStakeUnits(address vault, uint256 timestamp)     public     view     override     returns (uint256 stakeUnits) {     // calculate stake units     return calculateTotalStakeUnits(_vaults[vault].stakes, timestamp); }  /* pure functions */  function calculateTotalStakeUnits(StakeData[] memory stakes, uint256 timestamp)     public     pure     override     returns (uint256 totalStakeUnits) {     for (uint256 index; index &lt; stakes.length; index++) {         // reference stake         StakeData memory stakeData = stakes[index];         // calculate stake units         uint256 stakeUnits =             calculateStakeUnits(stakeData.amount, stakeData.timestamp, timestamp);         // add to running total         totalStakeUnits = totalStakeUnits.add(stakeUnits);     } }  function calculateStakeUnits(     uint256 amount,     uint256 start,     uint256 end ) public pure override returns (uint256 stakeUnits) {     // calculate duration     uint256 duration = end.sub(start);     // calculate stake units     stakeUnits = duration.mul(amount);     // explicit return     return stakeUnits; }  function calculateUnlockedRewards(     RewardSchedule[] memory rewardSchedules,     uint256 rewardBalance,     uint256 sharesOutstanding,     uint256 timestamp ) public pure override returns (uint256 unlockedRewards) {     // return 0 if no registered schedules     if (rewardSchedules.length == 0) {         return 0;     }      // calculate reward shares locked across all reward schedules     uint256 sharesLocked;     for (uint256 index = 0; index &lt; rewardSchedules.length; index++) {         // fetch reward schedule storage reference         RewardSchedule memory schedule = rewardSchedules[index];          // caculate amount of shares available on this schedule         // if (now - start) &lt; duration         //   sharesLocked = shares - (shares * (now - start) / duration)         // else         //   sharesLocked = 0         uint256 currentSharesLocked = 0;         if (timestamp.sub(schedule.start) &lt; schedule.duration) {             currentSharesLocked = schedule.shares.sub(                 schedule.shares.mul(timestamp.sub(schedule.start)).div(schedule.duration)             );         }          // add to running total         sharesLocked = sharesLocked.add(currentSharesLocked);     }      // convert shares to reward     // rewardLocked = sharesLocked * rewardBalance / sharesOutstanding     uint256 rewardLocked = sharesLocked.mul(rewardBalance).div(sharesOutstanding);      // calculate amount available     // unlockedRewards = rewardBalance - rewardLocked     unlockedRewards = rewardBalance.sub(rewardLocked);      // explicit return     return unlockedRewards; }  function calculateRewardFromStakes(     StakeData[] memory stakes,     uint256 unstakeAmount,     uint256 unlockedRewards,     uint256 totalStakeUnits,     uint256 timestamp,     RewardScaling memory rewardScaling ) public pure override returns (RewardOutput memory out) {     uint256 stakesToDrop = 0;     while (unstakeAmount &gt; 0) {         // fetch vault stake storage reference         StakeData memory lastStake = stakes[stakes.length.sub(stakesToDrop).sub(1)];          // calculate stake duration         uint256 stakeDuration = timestamp.sub(lastStake.timestamp);          uint256 currentAmount;         if (lastStake.amount &gt; unstakeAmount) {             // set current amount to remaining unstake amount             currentAmount = unstakeAmount;             // amount of last stake is reduced             out.lastStakeAmount = lastStake.amount.sub(unstakeAmount);         } else {             // set current amount to amount of last stake             currentAmount = lastStake.amount;             // add to stakes to drop             stakesToDrop += 1;         }          // update remaining unstakeAmount         unstakeAmount = unstakeAmount.sub(currentAmount);          // calculate reward amount         uint256 currentReward =             calculateReward(                 unlockedRewards,                 currentAmount,                 stakeDuration,                 totalStakeUnits,                 rewardScaling             );          // update cumulative reward         out.reward = out.reward.add(currentReward);          // update cached unlockedRewards         unlockedRewards = unlockedRewards.sub(currentReward);          // calculate time weighted stake         uint256 stakeUnits = currentAmount.mul(stakeDuration);          // update cached totalStakeUnits         totalStakeUnits = totalStakeUnits.sub(stakeUnits);     }      // explicit return     return         RewardOutput(             out.lastStakeAmount,             stakes.length.sub(stakesToDrop),             out.reward,             totalStakeUnits         ); }  function calculateReward(     uint256 unlockedRewards,     uint256 stakeAmount,     uint256 stakeDuration,     uint256 totalStakeUnits,     RewardScaling memory rewardScaling ) public pure override returns (uint256 reward) {     // calculate time weighted stake     uint256 stakeUnits = stakeAmount.mul(stakeDuration);      // calculate base reward     // baseReward = unlockedRewards * stakeUnits / totalStakeUnits     uint256 baseReward = 0;     if (totalStakeUnits != 0) {         // scale reward according to proportional weight         baseReward = unlockedRewards.mul(stakeUnits).div(totalStakeUnits);     }      // calculate scaled reward     // if no scaling or scaling period completed     //   reward = baseReward     // else     //   minReward = baseReward * scalingFloor / scalingCeiling     //   bonusReward = baseReward     //                 * (scalingCeiling - scalingFloor) / scalingCeiling     //                 * duration / scalingTime     //   reward = minReward + bonusReward     if (stakeDuration &gt;= rewardScaling.time || rewardScaling.floor == rewardScaling.ceiling) {         // no reward scaling applied         reward = baseReward;     } else {         // calculate minimum reward using scaling floor         uint256 minReward = baseReward.mul(rewardScaling.floor).div(rewardScaling.ceiling);          // calculate bonus reward with vested portion of scaling factor         uint256 bonusReward =             baseReward                 .mul(stakeDuration)                 .mul(rewardScaling.ceiling.sub(rewardScaling.floor))                 .div(rewardScaling.ceiling)                 .div(rewardScaling.time);          // add minimum reward and bonus reward         reward = minReward.add(bonusReward);     }      // explicit return     return reward; }  /* admin functions */  /// @notice Add funds to the Hypervisor /// access control: only admin /// state machine: ///   - can be called multiple times ///   - only online /// state scope: ///   - increase _hypervisor.rewardSharesOutstanding ///   - append to _hypervisor.rewardSchedules /// token transfer: transfer staking tokens from msg.sender to reward pool /// @param amount uint256 Amount of reward tokens to deposit /// @param duration uint256 Duration over which to linearly unlock rewards function fund(uint256 amount, uint256 duration) external onlyOwner onlyOnline {     // validate duration     require(duration != 0, ""Hypervisor: invalid duration"");      // create new reward shares     // if existing rewards on this Hypervisor     //   mint new shares proportional to % change in rewards remaining     //   newShares = remainingShares * newReward / remainingRewards     // else     //   mint new shares with BASE_SHARES_PER_WEI initial conversion rate     //   store as fixed point number with same  of decimals as reward token     uint256 newRewardShares;     if (_hypervisor.rewardSharesOutstanding &gt; 0) {         uint256 remainingRewards = IERC20(_hypervisor.rewardToken).balanceOf(_hypervisor.rewardPool);         newRewardShares = _hypervisor.rewardSharesOutstanding.mul(amount).div(remainingRewards);     } else {         newRewardShares = amount.mul(BASE_SHARES_PER_WEI);     }      // add reward shares to total     _hypervisor.rewardSharesOutstanding = _hypervisor.rewardSharesOutstanding.add(newRewardShares);      // store new reward schedule     _hypervisor.rewardSchedules.push(RewardSchedule(duration, block.timestamp, newRewardShares));      // transfer reward tokens to reward pool     TransferHelper.safeTransferFrom(         _hypervisor.rewardToken,         msg.sender,         _hypervisor.rewardPool,         amount     );      // emit event     emit HypervisorFunded(amount, duration); }  /// @notice Add vault factory to whitelist /// @dev use this function to enable stakes to vaults coming from the specified ///      factory contract /// access control: only admin /// state machine: ///   - can be called multiple times ///   - not shutdown /// state scope: ///   - append to _vaultFactorySet /// token transfer: none /// @param factory address The address of the vault factory function registerVaultFactory(address factory) external onlyOwner notShutdown {     // add factory to set     require(_vaultFactorySet.add(factory), ""Hypervisor: vault factory already registered"");      // emit event     emit VaultFactoryRegistered(factory); }  /// @notice Remove vault factory from whitelist /// @dev use this function to disable new stakes to vaults coming from the specified ///      factory contract. ///      note: vaults with existing stakes from this factory are sill able to unstake /// access control: only admin /// state machine: ///   - can be called multiple times ///   - not shutdown /// state scope: ///   - remove from _vaultFactorySet /// token transfer: none /// @param factory address The address of the vault factory function removeVaultFactory(address factory) external onlyOwner notShutdown {     // remove factory from set     require(_vaultFactorySet.remove(factory), ""Hypervisor: vault factory not registered"");      // emit event     emit VaultFactoryRemoved(factory); }  /// @notice Register bonus token for distribution /// @dev use this function to enable distribution of any ERC20 held by the RewardPool contract /// access control: only admin /// state machine: ///   - can be called multiple times ///   - only online /// state scope: ///   - append to _bonusTokenSet /// token transfer: none /// @param bonusToken address The address of the bonus token function registerBonusToken(address bonusToken) external onlyOwner onlyOnline {     // verify valid bonus token     _validateAddress(bonusToken);      // verify bonus token count     require(_bonusTokenSet.length() &lt; MAX_REWARD_TOKENS, ""Hypervisor: max bonus tokens reached "");      // add token to set     assert(_bonusTokenSet.add(bonusToken));      // emit event     emit BonusTokenRegistered(bonusToken); }  /// @notice Rescue tokens from RewardPool /// @dev use this function to rescue tokens from RewardPool contract ///      without distributing to stakers or triggering emergency shutdown /// access control: only admin /// state machine: ///   - can be called multiple times ///   - only online /// state scope: none /// token transfer: transfer requested token from RewardPool to recipient /// @param token address The address of the token to rescue /// @param recipient address The address of the recipient /// @param amount uint256 The amount of tokens to rescue function rescueTokensFromRewardPool(     address token,     address recipient,     uint256 amount ) external onlyOwner onlyOnline {     // verify recipient     _validateAddress(recipient);      // check not attempting to unstake reward token     require(token != _hypervisor.rewardToken, ""Hypervisor: invalid address"");      // check not attempting to wthdraw bonus token     require(!_bonusTokenSet.contains(token), ""Hypervisor: invalid address"");      // transfer tokens to recipient     IRewardPool(_hypervisor.rewardPool).sendERC20(token, recipient, amount); }  /* user functions */  /// @notice Stake tokens /// @dev anyone can stake to any vault if they have valid permission /// access control: anyone /// state machine: ///   - can be called multiple times ///   - only online ///   - when vault exists on this Hypervisor /// state scope: ///   - append to _vaults[vault].stakes ///   - increase _vaults[vault].totalStake ///   - increase _hypervisor.totalStake ///   - increase _hypervisor.totalStakeUnits ///   - increase _hypervisor.lastUpdate /// token transfer: transfer staking tokens from msg.sender to vault /// @param vault address The address of the vault to stake from /// @param amount uint256 The amount of staking tokens to stake function stake(     address vault,     uint256 amount,     bytes calldata permission ) external override onlyOnline {     // verify vault is valid     require(isValidVault(vault), ""Hypervisor: vault is not registered"");      // verify non-zero amount     require(amount != 0, ""Hypervisor: no amount staked"");      // fetch vault storage reference     VaultData storage vaultData = _vaults[vault];      // verify stakes boundary not reached     require(         vaultData.stakes.length &lt; MAX_STAKES_PER_VAULT,         ""Hypervisor: MAX_STAKES_PER_VAULT reached""     );      // update cached sum of stake units across all vaults     _updateTotalStakeUnits();      // store amount and timestamp     vaultData.stakes.push(StakeData(amount, block.timestamp));      // update cached total vault and Hypervisor amounts     vaultData.totalStake = vaultData.totalStake.add(amount);     // verify stake quantity without bounds     require(         stakeLimit == 0 || vaultData.totalStake &lt;= stakeLimit,         ""Hypervisor: Stake limit exceeded""     );     _hypervisor.totalStake = _hypervisor.totalStake.add(amount);      // call lock on vault     IUniversalVault(vault).lock(_hypervisor.stakingToken, amount, permission);      // emit event     emit Staked(vault, amount); }  /// @notice Unstake staking tokens and claim reward /// @dev rewards can only be claimed when unstaking /// access control: only owner of vault /// state machine: ///   - when vault exists on this Hypervisor ///   - after stake from vault ///   - can be called multiple times while sufficient stake remains ///   - only online /// state scope: ///   - decrease _hypervisor.rewardSharesOutstanding ///   - decrease _hypervisor.totalStake ///   - increase _hypervisor.lastUpdate ///   - modify _hypervisor.totalStakeUnits ///   - modify _vaults[vault].stakes ///   - decrease _vaults[vault].totalStake /// token transfer: ///   - transfer reward tokens from reward pool to recipient ///   - transfer bonus tokens from reward pool to recipient /// @param vault address The vault to unstake from /// @param amount uint256 The amount of staking tokens to unstake function unstakeAndClaim(     address vault,     uint256 amount,     bytes calldata permission ) external override onlyOnline {     // fetch vault storage reference     VaultData storage vaultData = _vaults[vault];      // verify non-zero amount     require(amount != 0, ""Hypervisor: no amount unstaked"");      address recipient = IUniversalVault(vault).owner();      // validate recipient     _validateAddress(recipient);      // check for sufficient vault stake amount     require(vaultData.totalStake &gt;= amount, ""Hypervisor: insufficient vault stake"");      // check for sufficient Hypervisor stake amount     // if this check fails, there is a bug in stake accounting     assert(_hypervisor.totalStake &gt;= amount);      // update cached sum of stake units across all vaults     _updateTotalStakeUnits();      // get reward amount remaining     uint256 remainingRewards = IERC20(_hypervisor.rewardToken).balanceOf(_hypervisor.rewardPool);      // calculate vested portion of reward pool     uint256 unlockedRewards =         calculateUnlockedRewards(             _hypervisor.rewardSchedules,             remainingRewards,             _hypervisor.rewardSharesOutstanding,             block.timestamp         );      // calculate vault time weighted reward with scaling     RewardOutput memory out =         calculateRewardFromStakes(             vaultData.stakes,             amount,             unlockedRewards,             _hypervisor.totalStakeUnits,             block.timestamp,             _hypervisor.rewardScaling         );      // update stake data in storage     if (out.newStakesCount == 0) {         // all stakes have been unstaked         delete vaultData.stakes;     } else {         // some stakes have been completely or partially unstaked         // delete fully unstaked stakes         while (vaultData.stakes.length &gt; out.newStakesCount) vaultData.stakes.pop();         // update partially unstaked stake         vaultData.stakes[out.newStakesCount.sub(1)].amount = out.lastStakeAmount;     }      // update cached stake totals     vaultData.totalStake = vaultData.totalStake.sub(amount);     _hypervisor.totalStake = _hypervisor.totalStake.sub(amount);     _hypervisor.totalStakeUnits = out.newTotalStakeUnits;      // unlock staking tokens from vault     IUniversalVault(vault).unlock(_hypervisor.stakingToken, amount, permission);      // emit event     emit Unstaked(vault, amount);      // only perform on non-zero reward     if (out.reward &gt; 0) {         // calculate shares to burn         // sharesToBurn = sharesOutstanding * reward / remainingRewards         uint256 sharesToBurn =             _hypervisor.rewardSharesOutstanding.mul(out.reward).div(remainingRewards);          // burn claimed shares         _hypervisor.rewardSharesOutstanding = _hypervisor.rewardSharesOutstanding.sub(sharesToBurn);          // transfer bonus tokens from reward pool to recipient         if (_bonusTokenSet.length() &gt; 0) {             for (uint256 index = 0; index &lt; _bonusTokenSet.length(); index++) {                 // fetch bonus token address reference                 address bonusToken = _bonusTokenSet.at(index);                  // calculate bonus token amount                 // bonusAmount = bonusRemaining * reward / remainingRewards                 uint256 bonusAmount =                     IERC20(bonusToken).balanceOf(_hypervisor.rewardPool).mul(out.reward).div(                         remainingRewards                     );                  // transfer bonus token                 IRewardPool(_hypervisor.rewardPool).sendERC20(bonusToken, recipient, bonusAmount);                  // emit event                 emit RewardClaimed(vault, recipient, bonusToken, bonusAmount);             }         }          // transfer reward tokens from reward pool to recipient         IRewardPool(_hypervisor.rewardPool).sendERC20(_hypervisor.rewardToken, recipient, out.reward);          // emit event         emit RewardClaimed(vault, recipient, _hypervisor.rewardToken, out.reward);     } }  /// @notice Exit Hypervisor without claiming reward /// @dev This function should never revert when correctly called by the vault. ///      A max number of stakes per vault is set with MAX_STAKES_PER_VAULT to ///      place an upper bound on the for loop in calculateTotalStakeUnits(). /// access control: only callable by the vault directly /// state machine: ///   - when vault exists on this Hypervisor ///   - when active stake from this vault ///   - any power state /// state scope: ///   - decrease _hypervisor.totalStake ///   - increase _hypervisor.lastUpdate ///   - modify _hypervisor.totalStakeUnits ///   - delete _vaults[vault] /// token transfer: none function rageQuit() external override {     // fetch vault storage reference     VaultData storage _vaultData = _vaults[msg.sender];      // revert if no active stakes     require(_vaultData.stakes.length != 0, ""Hypervisor: no stake"");      // update cached sum of stake units across all vaults     _updateTotalStakeUnits();      // emit event     emit Unstaked(msg.sender, _vaultData.totalStake);      // update cached totals     _hypervisor.totalStake = _hypervisor.totalStake.sub(_vaultData.totalStake);     _hypervisor.totalStakeUnits = _hypervisor.totalStakeUnits.sub(         calculateTotalStakeUnits(_vaultData.stakes, block.timestamp)     );      // delete stake data     delete _vaults[msg.sender]; }  /* convenience functions */  function _updateTotalStakeUnits() private {     // update cached totalStakeUnits     _hypervisor.totalStakeUnits = getCurrentTotalStakeUnits();     // update cached lastUpdate     _hypervisor.lastUpdate = block.timestamp; }  function _validateAddress(address target) private view {     // sanity check target for potential input errors     require(isValidAddress(target), ""Hypervisor: invalid address""); }  function _truncateStakesArray(StakeData[] memory array, uint256 newLength)     private     pure     returns (StakeData[] memory newArray) {     newArray = new StakeData[](newLength);     for (uint256 index = 0; index &lt; newLength; index++) {         newArray[index] = array[index];     }     return newArray; }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-02-08 00:44:10 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: GPL-3.0-only
pragma solidity 0.7.6;
pragma abicoder v2;

import {SafeMath} from ""@openzeppelin/contracts/math/SafeMath.sol"";
import {EnumerableSet} from ""@openzeppelin/contracts/utils/EnumerableSet.sol"";
import {IERC20} from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import {Ownable} from ""@openzeppelin/contracts/access/Ownable.sol"";
import {TransferHelper} from ""@uniswap/lib/contracts/libraries/TransferHelper.sol"";

import {IFactory} from ""../factory/IFactory.sol"";
import {IInstanceRegistry} from ""../factory/InstanceRegistry.sol"";
import {IUniversalVault} from ""../visor/Visor.sol"";
import {IRewardPool} from ""./RewardPool.sol"";
import {Powered} from ""./Powered.sol"";

interface IRageQuit {
    function rageQuit() external;
}

interface IHypervisor is IRageQuit {
    /* admin events */

    event HypervisorCreated(address rewardPool, address powerSwitch);
    event HypervisorFunded(uint256 amount, uint256 duration);
    event BonusTokenRegistered(address token);
    event VaultFactoryRegistered(address factory);
    event VaultFactoryRemoved(address factory);

    /* user events */

    event Staked(address vault, uint256 amount);
    event Unstaked(address vault, uint256 amount);
    event RewardClaimed(address vault, address recipient, address token, uint256 amount);

    /* data types */

    struct HypervisorData {
        address stakingToken;
        address rewardToken;
        address rewardPool;
        RewardScaling rewardScaling;
        uint256 rewardSharesOutstanding;
        uint256 totalStake;
        uint256 totalStakeUnits;
        uint256 lastUpdate;
        RewardSchedule[] rewardSchedules;
    }

    struct RewardSchedule {
        uint256 duration;
        uint256 start;
        uint256 shares;
    }

    struct VaultData {
        uint256 totalStake;
        StakeData[] stakes;
    }

    struct StakeData {
        uint256 amount;
        uint256 timestamp;
    }

    struct RewardScaling {
        uint256 floor;
        uint256 ceiling;
        uint256 time;
    }

    struct RewardOutput {
        uint256 lastStakeAmount;
        uint256 newStakesCount;
        uint256 reward;
        uint256 newTotalStakeUnits;
    }

    /* user functions */

    function stake(
        address vault,
        uint256 amount,
        bytes calldata permission
    ) external;

    function unstakeAndClaim(
        address vault,
        uint256 amount,
        bytes calldata permission
    ) external;

    /* getter functions */

    function getHypervisorData() external view returns (HypervisorData memory hypervisor);

    function getBonusTokenSetLength() external view returns (uint256 length);

    function getBonusTokenAtIndex(uint256 index) external view returns (address bonusToken);

    function getVaultFactorySetLength() external view returns (uint256 length);

    function getVaultFactoryAtIndex(uint256 index) external view returns (address factory);

    function getVaultData(address vault) external view returns (VaultData memory vaultData);

    function isValidAddress(address target) external view returns (bool validity);

    function isValidVault(address target) external view returns (bool validity);

    function getCurrentUnlockedRewards() external view returns (uint256 unlockedRewards);

    function getFutureUnlockedRewards(uint256 timestamp)
        external
        view
        returns (uint256 unlockedRewards);

    function getCurrentVaultReward(address vault) external view returns (uint256 reward);

    function getCurrentStakeReward(address vault, uint256 stakeAmount)
        external
        view
        returns (uint256 reward);

    function getFutureVaultReward(address vault, uint256 timestamp)
        external
        view
        returns (uint256 reward);

    function getFutureStakeReward(
        address vault,
        uint256 stakeAmount,
        uint256 timestamp
    ) external view returns (uint256 reward);

    function getCurrentVaultStakeUnits(address vault) external view returns (uint256 stakeUnits);

    function getFutureVaultStakeUnits(address vault, uint256 timestamp)
        external
        view
        returns (uint256 stakeUnits);

    function getCurrentTotalStakeUnits() external view returns (uint256 totalStakeUnits);

    function getFutureTotalStakeUnits(uint256 timestamp)
        external
        view
        returns (uint256 totalStakeUnits);

    /* pure functions */

    function calculateTotalStakeUnits(StakeData[] memory stakes, uint256 timestamp)
        external
        pure
        returns (uint256 totalStakeUnits);

    function calculateStakeUnits(
        uint256 amount,
        uint256 start,
        uint256 end
    ) external pure returns (uint256 stakeUnits);

    function calculateUnlockedRewards(
        RewardSchedule[] memory rewardSchedules,
        uint256 rewardBalance,
        uint256 sharesOutstanding,
        uint256 timestamp
    ) external pure returns (uint256 unlockedRewards);

    function calculateRewardFromStakes(
        StakeData[] memory stakes,
        uint256 unstakeAmount,
        uint256 unlockedRewards,
        uint256 totalStakeUnits,
        uint256 timestamp,
        RewardScaling memory rewardScaling
    ) external pure returns (RewardOutput memory out);

    function calculateReward(
        uint256 unlockedRewards,
        uint256 stakeAmount,
        uint256 stakeDuration,
        uint256 totalStakeUnits,
        RewardScaling memory rewardScaling
    ) external pure returns (uint256 reward);
}

/// @title Hypervisor
/// @notice Reward distribution contract with time multiplier
/// Access Control
/// - Power controller:
///     Can power off / shutdown the Hypervisor
///     Can withdraw rewards from reward pool once shutdown
/// - Proxy owner:
///     Can change arbitrary logic / state by upgrading the Hypervisor
///     Is unable to operate on user funds due to UniversalVault
///     Is unable to operate on reward pool funds when reward pool is offline / shutdown
/// - Hypervisor admin:
///     Can add funds to the Hypervisor, register bonus tokens, and whitelist new vault factories
///     Is a subset of proxy owner permissions
/// - User:
///     Can deposit / withdraw / ragequit
/// Hypervisor State Machine
/// - Online:
///     Hypervisor is operating normally, all functions are enabled
/// - Offline:
///     Hypervisor is temporarely disabled for maintenance
///     User deposits and withdrawls are disabled, ragequit remains enabled
///     Users can withdraw their stake through rageQuit() but forego their pending reward
///     Should only be used when downtime required for an upgrade
/// - Shutdown:
///     Hypervisor is permanently disabled
///     All functions are disabled with the exception of ragequit
///     Users can withdraw their stake through rageQuit()
///     Power controller can withdraw from the reward pool
///     Should only be used if Proxy Owner role is compromized
contract Hypervisor is IHypervisor, Powered, Ownable {
    using SafeMath for uint256;
    using EnumerableSet for EnumerableSet.AddressSet;

    /* constants */

    // An upper bound on the number of active stakes per vault is required to prevent
    // calls to rageQuit() from reverting.
    // With 30 stakes in a vault, ragequit costs 432811 gas which is conservatively lower
    // than the hardcoded limit of 500k gas on the vault.
    // This limit is configurable and could be increased in a future deployment.
    // Ultimately, to avoid a need for fixed upper bounds, the EVM would need to provide
    // an error code that allows for reliably catching out-of-gas errors on remote calls.
    uint256 public constant MAX_STAKES_PER_VAULT = 30;
    uint256 public constant MAX_REWARD_TOKENS = 50;
    uint256 public constant BASE_SHARES_PER_WEI = 1000000;
    uint256 public stakeLimit = 2500 ether;

    /* storage */

    HypervisorData private _hypervisor;
    mapping(address => VaultData) private _vaults;
    EnumerableSet.AddressSet private _bonusTokenSet;
    EnumerableSet.AddressSet private _vaultFactorySet;

    /* initializer */

    /// @notice Initizalize Hypervisor
    /// access control: only proxy constructor
    /// state machine: can only be called once
    /// state scope: set initialization variables
    /// token transfer: none
    /// @param ownerAddress address The admin address
    /// @param rewardPoolFactory address The factory to use for deploying the RewardPool
    /// @param powerSwitchFactory address The factory to use for deploying the PowerSwitch
    /// @param stakingToken address The address of the staking token for this Hypervisor
    /// @param rewardToken address The address of the reward token for this Hypervisor
    /// @param rewardScaling RewardScaling The config for reward scaling floor, ceiling, and time
    constructor(
        address ownerAddress,
        address rewardPoolFactory,
        address powerSwitchFactory,
        address stakingToken,
        address rewardToken,
        RewardScaling memory rewardScaling,
        uint256 _stakeLimit
    ) {
        // the scaling floor must be smaller than ceiling
        require(rewardScaling.floor <= rewardScaling.ceiling, ""Hypervisor: floor above ceiling"");

        // setting rewardScalingTime to 0 would cause divide by zero error
        // to disable reward scaling, use rewardScalingFloor == rewardScalingCeiling
        require(rewardScaling.time != 0, ""Hypervisor: scaling time cannot be zero"");

        // deploy power switch
        address powerSwitch = IFactory(powerSwitchFactory).create(abi.encode(ownerAddress));

        // deploy reward pool
        address rewardPool = IFactory(rewardPoolFactory).create(abi.encode(powerSwitch));

        // set internal configs
        Ownable.transferOwnership(ownerAddress);
        Powered._setPowerSwitch(powerSwitch);

        // commit to storage
        _hypervisor.stakingToken = stakingToken;
        _hypervisor.rewardToken = rewardToken;
        _hypervisor.rewardPool = rewardPool;
        _hypervisor.rewardScaling = rewardScaling;

        stakeLimit = _stakeLimit;

        // emit event
        emit HypervisorCreated(rewardPool, powerSwitch);
    }

    /* getter functions */

    function getBonusTokenSetLength() external view override returns (uint256 length) {
        return _bonusTokenSet.length();
    }

    function getBonusTokenAtIndex(uint256 index)
        external
        view
        override
        returns (address bonusToken)
    {
        return _bonusTokenSet.at(index);
    }

    function getVaultFactorySetLength() external view override returns (uint256 length) {
        return _vaultFactorySet.length();
    }

    function getVaultFactoryAtIndex(uint256 index)
        external
        view
        override
        returns (address factory)
    {
        return _vaultFactorySet.at(index);
    }

    function isValidVault(address target) public view override returns (bool validity) {
        // validate target is created from whitelisted vault factory
        for (uint256 index = 0; index < _vaultFactorySet.length(); index++) {
            if (IInstanceRegistry(_vaultFactorySet.at(index)).isInstance(target)) {
                return true;
            }
        }
        // explicit return
        return false;
    }

    function isValidAddress(address target) public view override returns (bool validity) {
        // sanity check target for potential input errors
        return
            target != address(this) &&
            target != address(0) &&
            target != _hypervisor.stakingToken &&
            target != _hypervisor.rewardToken &&
            target != _hypervisor.rewardPool &&
            !_bonusTokenSet.contains(target);
    }

    /* Hypervisor getters */

    function getHypervisorData() external view override returns (HypervisorData memory hypervisor) {
        return _hypervisor;
    }

    function getCurrentUnlockedRewards() public view override returns (uint256 unlockedRewards) {
        // calculate reward available based on state
        return getFutureUnlockedRewards(block.timestamp);
    }

    function getFutureUnlockedRewards(uint256 timestamp)
        public
        view
        override
        returns (uint256 unlockedRewards)
    {
        // get reward amount remaining
        uint256 remainingRewards = IERC20(_hypervisor.rewardToken).balanceOf(_hypervisor.rewardPool);
        // calculate reward available based on state
        unlockedRewards = calculateUnlockedRewards(
            _hypervisor.rewardSchedules,
            remainingRewards,
            _hypervisor.rewardSharesOutstanding,
            timestamp
        );
        // explicit return
        return unlockedRewards;
    }

    function getCurrentTotalStakeUnits() public view override returns (uint256 totalStakeUnits) {
        // calculate new stake units
        return getFutureTotalStakeUnits(block.timestamp);
    }

    function getFutureTotalStakeUnits(uint256 timestamp)
        public
        view
        override
        returns (uint256 totalStakeUnits)
    {
        // return early if no change
        if (timestamp == _hypervisor.lastUpdate) return _hypervisor.totalStakeUnits;
        // calculate new stake units
        uint256 newStakeUnits =
            calculateStakeUnits(_hypervisor.totalStake, _hypervisor.lastUpdate, timestamp);
        // add to cached total
        totalStakeUnits = _hypervisor.totalStakeUnits.add(newStakeUnits);
        // explicit return
        return totalStakeUnits;
    }

    /* vault getters */

    function getVaultData(address vault)
        external
        view
        override
        returns (VaultData memory vaultData)
    {
        return _vaults[vault];
    }

    function getCurrentVaultReward(address vault) external view override returns (uint256 reward) {
        // calculate rewards
        return
            calculateRewardFromStakes(
                _vaults[vault]
                    .stakes,
                _vaults[vault]
                    .totalStake,
                getCurrentUnlockedRewards(),
                getCurrentTotalStakeUnits(),
                block
                    .timestamp,
                _hypervisor
                    .rewardScaling
            )
                .reward;
    }

    function getFutureVaultReward(address vault, uint256 timestamp)
        external
        view
        override
        returns (uint256 reward)
    {
        // calculate rewards
        return
            calculateRewardFromStakes(
                _vaults[vault]
                    .stakes,
                _vaults[vault]
                    .totalStake,
                getFutureUnlockedRewards(timestamp),
                getFutureTotalStakeUnits(timestamp),
                timestamp,
                _hypervisor
                    .rewardScaling
            )
                .reward;
    }

    function getCurrentStakeReward(address vault, uint256 stakeAmount)
        external
        view
        override
        returns (uint256 reward)
    {
        // calculate rewards
        return
            calculateRewardFromStakes(
                _vaults[vault]
                    .stakes,
                stakeAmount,
                getCurrentUnlockedRewards(),
                getCurrentTotalStakeUnits(),
                block
                    .timestamp,
                _hypervisor
                    .rewardScaling
            )
                .reward;
    }

    function getFutureStakeReward(
        address vault,
        uint256 stakeAmount,
        uint256 timestamp
    ) external view override returns (uint256 reward) {
        // calculate rewards
        return
            calculateRewardFromStakes(
                _vaults[vault]
                    .stakes,
                stakeAmount,
                getFutureUnlockedRewards(timestamp),
                getFutureTotalStakeUnits(timestamp),
                timestamp,
                _hypervisor
                    .rewardScaling
            )
                .reward;
    }

    function getCurrentVaultStakeUnits(address vault)
        public
        view
        override
        returns (uint256 stakeUnits)
    {
        // calculate stake units
        return getFutureVaultStakeUnits(vault, block.timestamp);
    }

    function getFutureVaultStakeUnits(address vault, uint256 timestamp)
        public
        view
        override
        returns (uint256 stakeUnits)
    {
        // calculate stake units
        return calculateTotalStakeUnits(_vaults[vault].stakes, timestamp);
    }

    /* pure functions */

    function calculateTotalStakeUnits(StakeData[] memory stakes, uint256 timestamp)
        public
        pure
        override
        returns (uint256 totalStakeUnits)
    {
        for (uint256 index; index < stakes.length; index++) {
            // reference stake
            StakeData memory stakeData = stakes[index];
            // calculate stake units
            uint256 stakeUnits =
                calculateStakeUnits(stakeData.amount, stakeData.timestamp, timestamp);
            // add to running total
            totalStakeUnits = totalStakeUnits.add(stakeUnits);
        }
    }

    function calculateStakeUnits(
        uint256 amount,
        uint256 start,
        uint256 end
    ) public pure override returns (uint256 stakeUnits) {
        // calculate duration
        uint256 duration = end.sub(start);
        // calculate stake units
        stakeUnits = duration.mul(amount);
        // explicit return
        return stakeUnits;
    }

    function calculateUnlockedRewards(
        RewardSchedule[] memory rewardSchedules,
        uint256 rewardBalance,
        uint256 sharesOutstanding,
        uint256 timestamp
    ) public pure override returns (uint256 unlockedRewards) {
        // return 0 if no registered schedules
        if (rewardSchedules.length == 0) {
            return 0;
        }

        // calculate reward shares locked across all reward schedules
        uint256 sharesLocked;
        for (uint256 index = 0; index < rewardSchedules.length; index++) {
            // fetch reward schedule storage reference
            RewardSchedule memory schedule = rewardSchedules[index];

            // caculate amount of shares available on this schedule
            // if (now - start) < duration
            //   sharesLocked = shares - (shares * (now - start) / duration)
            // else
            //   sharesLocked = 0
            uint256 currentSharesLocked = 0;
            if (timestamp.sub(schedule.start) < schedule.duration) {
                currentSharesLocked = schedule.shares.sub(
                    schedule.shares.mul(timestamp.sub(schedule.start)).div(schedule.duration)
                );
            }

            // add to running total
            sharesLocked = sharesLocked.add(currentSharesLocked);
        }

        // convert shares to reward
        // rewardLocked = sharesLocked * rewardBalance / sharesOutstanding
        uint256 rewardLocked = sharesLocked.mul(rewardBalance).div(sharesOutstanding);

        // calculate amount available
        // unlockedRewards = rewardBalance - rewardLocked
        unlockedRewards = rewardBalance.sub(rewardLocked);

        // explicit return
        return unlockedRewards;
    }

    function calculateRewardFromStakes(
        StakeData[] memory stakes,
        uint256 unstakeAmount,
        uint256 unlockedRewards,
        uint256 totalStakeUnits,
        uint256 timestamp,
        RewardScaling memory rewardScaling
    ) public pure override returns (RewardOutput memory out) {
        uint256 stakesToDrop = 0;
        while (unstakeAmount > 0) {
            // fetch vault stake storage reference
            StakeData memory lastStake = stakes[stakes.length.sub(stakesToDrop).sub(1)];

            // calculate stake duration
            uint256 stakeDuration = timestamp.sub(lastStake.timestamp);

            uint256 currentAmount;
            if (lastStake.amount > unstakeAmount) {
                // set current amount to remaining unstake amount
                currentAmount = unstakeAmount;
                // amount of last stake is reduced
                out.lastStakeAmount = lastStake.amount.sub(unstakeAmount);
            } else {
                // set current amount to amount of last stake
                currentAmount = lastStake.amount;
                // add to stakes to drop
                stakesToDrop += 1;
            }

            // update remaining unstakeAmount
            unstakeAmount = unstakeAmount.sub(currentAmount);

            // calculate reward amount
            uint256 currentReward =
                calculateReward(
                    unlockedRewards,
                    currentAmount,
                    stakeDuration,
                    totalStakeUnits,
                    rewardScaling
                );

            // update cumulative reward
            out.reward = out.reward.add(currentReward);

            // update cached unlockedRewards
            unlockedRewards = unlockedRewards.sub(currentReward);

            // calculate time weighted stake
            uint256 stakeUnits = currentAmount.mul(stakeDuration);

            // update cached totalStakeUnits
            totalStakeUnits = totalStakeUnits.sub(stakeUnits);
        }

        // explicit return
        return
            RewardOutput(
                out.lastStakeAmount,
                stakes.length.sub(stakesToDrop),
                out.reward,
                totalStakeUnits
            );
    }

    function calculateReward(
        uint256 unlockedRewards,
        uint256 stakeAmount,
        uint256 stakeDuration,
        uint256 totalStakeUnits,
        RewardScaling memory rewardScaling
    ) public pure override returns (uint256 reward) {
        // calculate time weighted stake
        uint256 stakeUnits = stakeAmount.mul(stakeDuration);

        // calculate base reward
        // baseReward = unlockedRewards * stakeUnits / totalStakeUnits
        uint256 baseReward = 0;
        if (totalStakeUnits != 0) {
            // scale reward according to proportional weight
            baseReward = unlockedRewards.mul(stakeUnits).div(totalStakeUnits);
        }

        // calculate scaled reward
        // if no scaling or scaling period completed
        //   reward = baseReward
        // else
        //   minReward = baseReward * scalingFloor / scalingCeiling
        //   bonusReward = baseReward
        //                 * (scalingCeiling - scalingFloor) / scalingCeiling
        //                 * duration / scalingTime
        //   reward = minReward + bonusReward
        if (stakeDuration >= rewardScaling.time || rewardScaling.floor == rewardScaling.ceiling) {
            // no reward scaling applied
            reward = baseReward;
        } else {
            // calculate minimum reward using scaling floor
            uint256 minReward = baseReward.mul(rewardScaling.floor).div(rewardScaling.ceiling);

            // calculate bonus reward with vested portion of scaling factor
            uint256 bonusReward =
                baseReward
                    .mul(stakeDuration)
                    .mul(rewardScaling.ceiling.sub(rewardScaling.floor))
                    .div(rewardScaling.ceiling)
                    .div(rewardScaling.time);

            // add minimum reward and bonus reward
            reward = minReward.add(bonusReward);
        }

        // explicit return
        return reward;
    }

    /* admin functions */

    /// @notice Add funds to the Hypervisor
    /// access control: only admin
    /// state machine:
    ///   - can be called multiple times
    ///   - only online
    /// state scope:
    ///   - increase _hypervisor.rewardSharesOutstanding
    ///   - append to _hypervisor.rewardSchedules
    /// token transfer: transfer staking tokens from msg.sender to reward pool
    /// @param amount uint256 Amount of reward tokens to deposit
    /// @param duration uint256 Duration over which to linearly unlock rewards
    function fund(uint256 amount, uint256 duration) external onlyOwner onlyOnline {
        // validate duration
        require(duration != 0, ""Hypervisor: invalid duration"");

        // create new reward shares
        // if existing rewards on this Hypervisor
        //   mint new shares proportional to % change in rewards remaining
        //   newShares = remainingShares * newReward / remainingRewards
        // else
        //   mint new shares with BASE_SHARES_PER_WEI initial conversion rate
        //   store as fixed point number with same  of decimals as reward token
        uint256 newRewardShares;
        if (_hypervisor.rewardSharesOutstanding > 0) {
            uint256 remainingRewards = IERC20(_hypervisor.rewardToken).balanceOf(_hypervisor.rewardPool);
            newRewardShares = _hypervisor.rewardSharesOutstanding.mul(amount).div(remainingRewards);
        } else {
            newRewardShares = amount.mul(BASE_SHARES_PER_WEI);
        }

        // add reward shares to total
        _hypervisor.rewardSharesOutstanding = _hypervisor.rewardSharesOutstanding.add(newRewardShares);

        // store new reward schedule
        _hypervisor.rewardSchedules.push(RewardSchedule(duration, block.timestamp, newRewardShares));

        // transfer reward tokens to reward pool
        TransferHelper.safeTransferFrom(
            _hypervisor.rewardToken,
            msg.sender,
            _hypervisor.rewardPool,
            amount
        );

        // emit event
        emit HypervisorFunded(amount, duration);
    }

    /// @notice Add vault factory to whitelist
    /// @dev use this function to enable stakes to vaults coming from the specified
    ///      factory contract
    /// access control: only admin
    /// state machine:
    ///   - can be called multiple times
    ///   - not shutdown
    /// state scope:
    ///   - append to _vaultFactorySet
    /// token transfer: none
    /// @param factory address The address of the vault factory
    function registerVaultFactory(address factory) external onlyOwner notShutdown {
        // add factory to set
        require(_vaultFactorySet.add(factory), ""Hypervisor: vault factory already registered"");

        // emit event
        emit VaultFactoryRegistered(factory);
    }

    /// @notice Remove vault factory from whitelist
    /// @dev use this function to disable new stakes to vaults coming from the specified
    ///      factory contract.
    ///      note: vaults with existing stakes from this factory are sill able to unstake
    /// access control: only admin
    /// state machine:
    ///   - can be called multiple times
    ///   - not shutdown
    /// state scope:
    ///   - remove from _vaultFactorySet
    /// token transfer: none
    /// @param factory address The address of the vault factory
    function removeVaultFactory(address factory) external onlyOwner notShutdown {
        // remove factory from set
        require(_vaultFactorySet.remove(factory), ""Hypervisor: vault factory not registered"");

        // emit event
        emit VaultFactoryRemoved(factory);
    }

    /// @notice Register bonus token for distribution
    /// @dev use this function to enable distribution of any ERC20 held by the RewardPool contract
    /// access control: only admin
    /// state machine:
    ///   - can be called multiple times
    ///   - only online
    /// state scope:
    ///   - append to _bonusTokenSet
    /// token transfer: none
    /// @param bonusToken address The address of the bonus token
    function registerBonusToken(address bonusToken) external onlyOwner onlyOnline {
        // verify valid bonus token
        _validateAddress(bonusToken);

        // verify bonus token count
        require(_bonusTokenSet.length() < MAX_REWARD_TOKENS, ""Hypervisor: max bonus tokens reached "");

        // add token to set
        assert(_bonusTokenSet.add(bonusToken));

        // emit event
        emit BonusTokenRegistered(bonusToken);
    }

    /// @notice Rescue tokens from RewardPool
    /// @dev use this function to rescue tokens from RewardPool contract
    ///      without distributing to stakers or triggering emergency shutdown
    /// access control: only admin
    /// state machine:
    ///   - can be called multiple times
    ///   - only online
    /// state scope: none
    /// token transfer: transfer requested token from RewardPool to recipient
    /// @param token address The address of the token to rescue
    /// @param recipient address The address of the recipient
    /// @param amount uint256 The amount of tokens to rescue
    function rescueTokensFromRewardPool(
        address token,
        address recipient,
        uint256 amount
    ) external onlyOwner onlyOnline {
        // verify recipient
        _validateAddress(recipient);

        // check not attempting to unstake reward token
        require(token != _hypervisor.rewardToken, ""Hypervisor: invalid address"");

        // check not attempting to wthdraw bonus token
        require(!_bonusTokenSet.contains(token), ""Hypervisor: invalid address"");

        // transfer tokens to recipient
        IRewardPool(_hypervisor.rewardPool).sendERC20(token, recipient, amount);
    }

    /* user functions */

    /// @notice Stake tokens
    /// @dev anyone can stake to any vault if they have valid permission
    /// access control: anyone
    /// state machine:
    ///   - can be called multiple times
    ///   - only online
    ///   - when vault exists on this Hypervisor
    /// state scope:
    ///   - append to _vaults[vault].stakes
    ///   - increase _vaults[vault].totalStake
    ///   - increase _hypervisor.totalStake
    ///   - increase _hypervisor.totalStakeUnits
    ///   - increase _hypervisor.lastUpdate
    /// token transfer: transfer staking tokens from msg.sender to vault
    /// @param vault address The address of the vault to stake from
    /// @param amount uint256 The amount of staking tokens to stake
    function stake(
        address vault,
        uint256 amount,
        bytes calldata permission
    ) external override onlyOnline {
        // verify vault is valid
        require(isValidVault(vault), ""Hypervisor: vault is not registered"");

        // verify non-zero amount
        require(amount != 0, ""Hypervisor: no amount staked"");

        // fetch vault storage reference
        VaultData storage vaultData = _vaults[vault];

        // verify stakes boundary not reached
        require(
            vaultData.stakes.length < MAX_STAKES_PER_VAULT,
            ""Hypervisor: MAX_STAKES_PER_VAULT reached""
        );

        // update cached sum of stake units across all vaults
        _updateTotalStakeUnits();

        // store amount and timestamp
        vaultData.stakes.push(StakeData(amount, block.timestamp));

        // update cached total vault and Hypervisor amounts
        vaultData.totalStake = vaultData.totalStake.add(amount);
        // verify stake quantity without bounds
        require(
            stakeLimit == 0 || vaultData.totalStake <= stakeLimit,
            ""Hypervisor: Stake limit exceeded""
        );
        _hypervisor.totalStake = _hypervisor.totalStake.add(amount);

        // call lock on vault
        IUniversalVault(vault).lock(_hypervisor.stakingToken, amount, permission);

        // emit event
        emit Staked(vault, amount);
    }

    /// @notice Unstake staking tokens and claim reward
    /// @dev rewards can only be claimed when unstaking
    /// access control: only owner of vault
    /// state machine:
    ///   - when vault exists on this Hypervisor
    ///   - after stake from vault
    ///   - can be called multiple times while sufficient stake remains
    ///   - only online
    /// state scope:
    ///   - decrease _hypervisor.rewardSharesOutstanding
    ///   - decrease _hypervisor.totalStake
    ///   - increase _hypervisor.lastUpdate
    ///   - modify _hypervisor.totalStakeUnits
    ///   - modify _vaults[vault].stakes
    ///   - decrease _vaults[vault].totalStake
    /// token transfer:
    ///   - transfer reward tokens from reward pool to recipient
    ///   - transfer bonus tokens from reward pool to recipient
    /// @param vault address The vault to unstake from
    /// @param amount uint256 The amount of staking tokens to unstake
    function unstakeAndClaim(
        address vault,
        uint256 amount,
        bytes calldata permission
    ) external override onlyOnline {
        // fetch vault storage reference
        VaultData storage vaultData = _vaults[vault];

        // verify non-zero amount
        require(amount != 0, ""Hypervisor: no amount unstaked"");

        address recipient = IUniversalVault(vault).owner();

        // validate recipient
        _validateAddress(recipient);

        // check for sufficient vault stake amount
        require(vaultData.totalStake >= amount, ""Hypervisor: insufficient vault stake"");

        // check for sufficient Hypervisor stake amount
        // if this check fails, there is a bug in stake accounting
        assert(_hypervisor.totalStake >= amount);

        // update cached sum of stake units across all vaults
        _updateTotalStakeUnits();

        // get reward amount remaining
        uint256 remainingRewards = IERC20(_hypervisor.rewardToken).balanceOf(_hypervisor.rewardPool);

        // calculate vested portion of reward pool
        uint256 unlockedRewards =
            calculateUnlockedRewards(
                _hypervisor.rewardSchedules,
                remainingRewards,
                _hypervisor.rewardSharesOutstanding,
                block.timestamp
            );

        // calculate vault time weighted reward with scaling
        RewardOutput memory out =
            calculateRewardFromStakes(
                vaultData.stakes,
                amount,
                unlockedRewards,
                _hypervisor.totalStakeUnits,
                block.timestamp,
                _hypervisor.rewardScaling
            );

        // update stake data in storage
        if (out.newStakesCount == 0) {
            // all stakes have been unstaked
            delete vaultData.stakes;
        } else {
            // some stakes have been completely or partially unstaked
            // delete fully unstaked stakes
            while (vaultData.stakes.length > out.newStakesCount) vaultData.stakes.pop();
            // update partially unstaked stake
            vaultData.stakes[out.newStakesCount.sub(1)].amount = out.lastStakeAmount;
        }

        // update cached stake totals
        vaultData.totalStake = vaultData.totalStake.sub(amount);
        _hypervisor.totalStake = _hypervisor.totalStake.sub(amount);
        _hypervisor.totalStakeUnits = out.newTotalStakeUnits;

        // unlock staking tokens from vault
        IUniversalVault(vault).unlock(_hypervisor.stakingToken, amount, permission);

        // emit event
        emit Unstaked(vault, amount);

        // only perform on non-zero reward
        if (out.reward > 0) {
            // calculate shares to burn
            // sharesToBurn = sharesOutstanding * reward / remainingRewards
            uint256 sharesToBurn =
                _hypervisor.rewardSharesOutstanding.mul(out.reward).div(remainingRewards);

            // burn claimed shares
            _hypervisor.rewardSharesOutstanding = _hypervisor.rewardSharesOutstanding.sub(sharesToBurn);

            // transfer bonus tokens from reward pool to recipient
            if (_bonusTokenSet.length() > 0) {
                for (uint256 index = 0; index < _bonusTokenSet.length(); index++) {
                    // fetch bonus token address reference
                    address bonusToken = _bonusTokenSet.at(index);

                    // calculate bonus token amount
                    // bonusAmount = bonusRemaining * reward / remainingRewards
                    uint256 bonusAmount =
                        IERC20(bonusToken).balanceOf(_hypervisor.rewardPool).mul(out.reward).div(
                            remainingRewards
                        );

                    // transfer bonus token
                    IRewardPool(_hypervisor.rewardPool).sendERC20(bonusToken, recipient, bonusAmount);

                    // emit event
                    emit RewardClaimed(vault, recipient, bonusToken, bonusAmount);
                }
            }

            // transfer reward tokens from reward pool to recipient
            IRewardPool(_hypervisor.rewardPool).sendERC20(_hypervisor.rewardToken, recipient, out.reward);

            // emit event
            emit RewardClaimed(vault, recipient, _hypervisor.rewardToken, out.reward);
        }
    }

    /// @notice Exit Hypervisor without claiming reward
    /// @dev This function should never revert when correctly called by the vault.
    ///      A max number of stakes per vault is set with MAX_STAKES_PER_VAULT to
    ///      place an upper bound on the for loop in calculateTotalStakeUnits().
    /// access control: only callable by the vault directly
    /// state machine:
    ///   - when vault exists on this Hypervisor
    ///   - when active stake from this vault
    ///   - any power state
    /// state scope:
    ///   - decrease _hypervisor.totalStake
    ///   - increase _hypervisor.lastUpdate
    ///   - modify _hypervisor.totalStakeUnits
    ///   - delete _vaults[vault]
    /// token transfer: none
    function rageQuit() external override {
        // fetch vault storage reference
        VaultData storage _vaultData = _vaults[msg.sender];

        // revert if no active stakes
        require(_vaultData.stakes.length != 0, ""Hypervisor: no stake"");

        // update cached sum of stake units across all vaults
        _updateTotalStakeUnits();

        // emit event
        emit Unstaked(msg.sender, _vaultData.totalStake);

        // update cached totals
        _hypervisor.totalStake = _hypervisor.totalStake.sub(_vaultData.totalStake);
        _hypervisor.totalStakeUnits = _hypervisor.totalStakeUnits.sub(
            calculateTotalStakeUnits(_vaultData.stakes, block.timestamp)
        );

        // delete stake data
        delete _vaults[msg.sender];
    }

    /* convenience functions */

    function _updateTotalStakeUnits() private {
        // update cached totalStakeUnits
        _hypervisor.totalStakeUnits = getCurrentTotalStakeUnits();
        // update cached lastUpdate
        _hypervisor.lastUpdate = block.timestamp;
    }

    function _validateAddress(address target) private view {
        // sanity check target for potential input errors
        require(isValidAddress(target), ""Hypervisor: invalid address"");
    }

    function _truncateStakesArray(StakeData[] memory array, uint256 newLength)
        private
        pure
        returns (StakeData[] memory newArray)
    {
        newArray = new StakeData[](newLength);
        for (uint256 index = 0; index < newLength; index++) {
            newArray[index] = array[index];
        }
        return newArray;
    }
}
.
To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs.]

Given the user's task and the brainstorming ideas provided:
Task: ""// SPDX-License-Identifier: GPL-3.0-only
pragma solidity 0.7.6;
pragma abicoder v2;

import {SafeMath} from ""@openzeppelin/contracts/math/SafeMath.sol"";
import {EnumerableSet} from ""@openzeppelin/contracts/utils/EnumerableSet.sol"";
import {IERC20} from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import {Ownable} from ""@openzeppelin/contracts/access/Ownable.sol"";
import {TransferHelper} from ""@uniswap/lib/contracts/libraries/TransferHelper.sol"";

import {IFactory} from ""../factory/IFactory.sol"";
import {IInstanceRegistry} from ""../factory/InstanceRegistry.sol"";
import {IUniversalVault} from ""../visor/Visor.sol"";
import {IRewardPool} from ""./RewardPool.sol"";
import {Powered} from ""./Powered.sol"";

interface IRageQuit {
    function rageQuit() external;
}

interface IHypervisor is IRageQuit {
    /* admin events */

    event HypervisorCreated(address rewardPool, address powerSwitch);
    event HypervisorFunded(uint256 amount, uint256 duration);
    event BonusTokenRegistered(address token);
    event VaultFactoryRegistered(address factory);
    event VaultFactoryRemoved(address factory);

    /* user events */

    event Staked(address vault, uint256 amount);
    event Unstaked(address vault, uint256 amount);
    event RewardClaimed(address vault, address recipient, address token, uint256 amount);

    /* data types */

    struct HypervisorData {
        address stakingToken;
        address rewardToken;
        address rewardPool;
        RewardScaling rewardScaling;
        uint256 rewardSharesOutstanding;
        uint256 totalStake;
        uint256 totalStakeUnits;
        uint256 lastUpdate;
        RewardSchedule[] rewardSchedules;
    }

    struct RewardSchedule {
        uint256 duration;
        uint256 start;
        uint256 shares;
    }

    struct VaultData {
        uint256 totalStake;
        StakeData[] stakes;
    }

    struct StakeData {
        uint256 amount;
        uint256 timestamp;
    }

    struct RewardScaling {
        uint256 floor;
        uint256 ceiling;
        uint256 time;
    }

    struct RewardOutput {
        uint256 lastStakeAmount;
        uint256 newStakesCount;
        uint256 reward;
        uint256 newTotalStakeUnits;
    }

    /* user functions */

    function stake(
        address vault,
        uint256 amount,
        bytes calldata permission
    ) external;

    function unstakeAndClaim(
        address vault,
        uint256 amount,
        bytes calldata permission
    ) external;

    /* getter functions */

    function getHypervisorData() external view returns (HypervisorData memory hypervisor);

    function getBonusTokenSetLength() external view returns (uint256 length);

    function getBonusTokenAtIndex(uint256 index) external view returns (address bonusToken);

    function getVaultFactorySetLength() external view returns (uint256 length);

    function getVaultFactoryAtIndex(uint256 index) external view returns (address factory);

    function getVaultData(address vault) external view returns (VaultData memory vaultData);

    function isValidAddress(address target) external view returns (bool validity);

    function isValidVault(address target) external view returns (bool validity);

    function getCurrentUnlockedRewards() external view returns (uint256 unlockedRewards);

    function getFutureUnlockedRewards(uint256 timestamp)
        external
        view
        returns (uint256 unlockedRewards);

    function getCurrentVaultReward(address vault) external view returns (uint256 reward);

    function getCurrentStakeReward(address vault, uint256 stakeAmount)
        external
        view
        returns (uint256 reward);

    function getFutureVaultReward(address vault, uint256 timestamp)
        external
        view
        returns (uint256 reward);

    function getFutureStakeReward(
        address vault,
        uint256 stakeAmount,
        uint256 timestamp
    ) external view returns (uint256 reward);

    function getCurrentVaultStakeUnits(address vault) external view returns (uint256 stakeUnits);

    function getFutureVaultStakeUnits(address vault, uint256 timestamp)
        external
        view
        returns (uint256 stakeUnits);

    function getCurrentTotalStakeUnits() external view returns (uint256 totalStakeUnits);

    function getFutureTotalStakeUnits(uint256 timestamp)
        external
        view
        returns (uint256 totalStakeUnits);

    /* pure functions */

    function calculateTotalStakeUnits(StakeData[] memory stakes, uint256 timestamp)
        external
        pure
        returns (uint256 totalStakeUnits);

    function calculateStakeUnits(
        uint256 amount,
        uint256 start,
        uint256 end
    ) external pure returns (uint256 stakeUnits);

    function calculateUnlockedRewards(
        RewardSchedule[] memory rewardSchedules,
        uint256 rewardBalance,
        uint256 sharesOutstanding,
        uint256 timestamp
    ) external pure returns (uint256 unlockedRewards);

    function calculateRewardFromStakes(
        StakeData[] memory stakes,
        uint256 unstakeAmount,
        uint256 unlockedRewards,
        uint256 totalStakeUnits,
        uint256 timestamp,
        RewardScaling memory rewardScaling
    ) external pure returns (RewardOutput memory out);

    function calculateReward(
        uint256 unlockedRewards,
        uint256 stakeAmount,
        uint256 stakeDuration,
        uint256 totalStakeUnits,
        RewardScaling memory rewardScaling
    ) external pure returns (uint256 reward);
}

/// @title Hypervisor
/// @notice Reward distribution contract with time multiplier
/// Access Control
/// - Power controller:
///     Can power off / shutdown the Hypervisor
///     Can withdraw rewards from reward pool once shutdown
/// - Proxy owner:
///     Can change arbitrary logic / state by upgrading the Hypervisor
///     Is unable to operate on user funds due to UniversalVault
///     Is unable to operate on reward pool funds when reward pool is offline / shutdown
/// - Hypervisor admin:
///     Can add funds to the Hypervisor, register bonus tokens, and whitelist new vault factories
///     Is a subset of proxy owner permissions
/// - User:
///     Can deposit / withdraw / ragequit
/// Hypervisor State Machine
/// - Online:
///     Hypervisor is operating normally, all functions are enabled
/// - Offline:
///     Hypervisor is temporarely disabled for maintenance
///     User deposits and withdrawls are disabled, ragequit remains enabled
///     Users can withdraw their stake through rageQuit() but forego their pending reward
///     Should only be used when downtime required for an upgrade
/// - Shutdown:
///     Hypervisor is permanently disabled
///     All functions are disabled with the exception of ragequit
///     Users can withdraw their stake through rageQuit()
///     Power controller can withdraw from the reward pool
///     Should only be used if Proxy Owner role is compromized
contract Hypervisor is IHypervisor, Powered, Ownable {
    using SafeMath for uint256;
    using EnumerableSet for EnumerableSet.AddressSet;

    /* constants */

    // An upper bound on the number of active stakes per vault is required to prevent
    // calls to rageQuit() from reverting.
    // With 30 stakes in a vault, ragequit costs 432811 gas which is conservatively lower
    // than the hardcoded limit of 500k gas on the vault.
    // This limit is configurable and could be increased in a future deployment.
    // Ultimately, to avoid a need for fixed upper bounds, the EVM would need to provide
    // an error code that allows for reliably catching out-of-gas errors on remote calls.
    uint256 public constant MAX_STAKES_PER_VAULT = 30;
    uint256 public constant MAX_REWARD_TOKENS = 50;
    uint256 public constant BASE_SHARES_PER_WEI = 1000000;
    uint256 public stakeLimit = 2500 ether;

    /* storage */

    HypervisorData private _hypervisor;
    mapping(address => VaultData) private _vaults;
    EnumerableSet.AddressSet private _bonusTokenSet;
    EnumerableSet.AddressSet private _vaultFactorySet;

    /* initializer */

    /// @notice Initizalize Hypervisor
    /// access control: only proxy constructor
    /// state machine: can only be called once
    /// state scope: set initialization variables
    /// token transfer: none
    /// @param ownerAddress address The admin address
    /// @param rewardPoolFactory address The factory to use for deploying the RewardPool
    /// @param powerSwitchFactory address The factory to use for deploying the PowerSwitch
    /// @param stakingToken address The address of the staking token for this Hypervisor
    /// @param rewardToken address The address of the reward token for this Hypervisor
    /// @param rewardScaling RewardScaling The config for reward scaling floor, ceiling, and time
    constructor(
        address ownerAddress,
        address rewardPoolFactory,
        address powerSwitchFactory,
        address stakingToken,
        address rewardToken,
        RewardScaling memory rewardScaling,
        uint256 _stakeLimit
    ) {
        // the scaling floor must be smaller than ceiling
        require(rewardScaling.floor <= rewardScaling.ceiling, ""Hypervisor: floor above ceiling"");

        // setting rewardScalingTime to 0 would cause divide by zero error
        // to disable reward scaling, use rewardScalingFloor == rewardScalingCeiling
        require(rewardScaling.time != 0, ""Hypervisor: scaling time cannot be zero"");

        // deploy power switch
        address powerSwitch = IFactory(powerSwitchFactory).create(abi.encode(ownerAddress));

        // deploy reward pool
        address rewardPool = IFactory(rewardPoolFactory).create(abi.encode(powerSwitch));

        // set internal configs
        Ownable.transferOwnership(ownerAddress);
        Powered._setPowerSwitch(powerSwitch);

        // commit to storage
        _hypervisor.stakingToken = stakingToken;
        _hypervisor.rewardToken = rewardToken;
        _hypervisor.rewardPool = rewardPool;
        _hypervisor.rewardScaling = rewardScaling;

        stakeLimit = _stakeLimit;

        // emit event
        emit HypervisorCreated(rewardPool, powerSwitch);
    }

    /* getter functions */

    function getBonusTokenSetLength() external view override returns (uint256 length) {
        return _bonusTokenSet.length();
    }

    function getBonusTokenAtIndex(uint256 index)
        external
        view
        override
        returns (address bonusToken)
    {
        return _bonusTokenSet.at(index);
    }

    function getVaultFactorySetLength() external view override returns (uint256 length) {
        return _vaultFactorySet.length();
    }

    function getVaultFactoryAtIndex(uint256 index)
        external
        view
        override
        returns (address factory)
    {
        return _vaultFactorySet.at(index);
    }

    function isValidVault(address target) public view override returns (bool validity) {
        // validate target is created from whitelisted vault factory
        for (uint256 index = 0; index < _vaultFactorySet.length(); index++) {
            if (IInstanceRegistry(_vaultFactorySet.at(index)).isInstance(target)) {
                return true;
            }
        }
        // explicit return
        return false;
    }

    function isValidAddress(address target) public view override returns (bool validity) {
        // sanity check target for potential input errors
        return
            target != address(this) &&
            target != address(0) &&
            target != _hypervisor.stakingToken &&
            target != _hypervisor.rewardToken &&
            target != _hypervisor.rewardPool &&
            !_bonusTokenSet.contains(target);
    }

    /* Hypervisor getters */

    function getHypervisorData() external view override returns (HypervisorData memory hypervisor) {
        return _hypervisor;
    }

    function getCurrentUnlockedRewards() public view override returns (uint256 unlockedRewards) {
        // calculate reward available based on state
        return getFutureUnlockedRewards(block.timestamp);
    }

    function getFutureUnlockedRewards(uint256 timestamp)
        public
        view
        override
        returns (uint256 unlockedRewards)
    {
        // get reward amount remaining
        uint256 remainingRewards = IERC20(_hypervisor.rewardToken).balanceOf(_hypervisor.rewardPool);
        // calculate reward available based on state
        unlockedRewards = calculateUnlockedRewards(
            _hypervisor.rewardSchedules,
            remainingRewards,
            _hypervisor.rewardSharesOutstanding,
            timestamp
        );
        // explicit return
        return unlockedRewards;
    }

    function getCurrentTotalStakeUnits() public view override returns (uint256 totalStakeUnits) {
        // calculate new stake units
        return getFutureTotalStakeUnits(block.timestamp);
    }

    function getFutureTotalStakeUnits(uint256 timestamp)
        public
        view
        override
        returns (uint256 totalStakeUnits)
    {
        // return early if no change
        if (timestamp == _hypervisor.lastUpdate) return _hypervisor.totalStakeUnits;
        // calculate new stake units
        uint256 newStakeUnits =
            calculateStakeUnits(_hypervisor.totalStake, _hypervisor.lastUpdate, timestamp);
        // add to cached total
        totalStakeUnits = _hypervisor.totalStakeUnits.add(newStakeUnits);
        // explicit return
        return totalStakeUnits;
    }

    /* vault getters */

    function getVaultData(address vault)
        external
        view
        override
        returns (VaultData memory vaultData)
    {
        return _vaults[vault];
    }

    function getCurrentVaultReward(address vault) external view override returns (uint256 reward) {
        // calculate rewards
        return
            calculateRewardFromStakes(
                _vaults[vault]
                    .stakes,
                _vaults[vault]
                    .totalStake,
                getCurrentUnlockedRewards(),
                getCurrentTotalStakeUnits(),
                block
                    .timestamp,
                _hypervisor
                    .rewardScaling
            )
                .reward;
    }

    function getFutureVaultReward(address vault, uint256 timestamp)
        external
        view
        override
        returns (uint256 reward)
    {
        // calculate rewards
        return
            calculateRewardFromStakes(
                _vaults[vault]
                    .stakes,
                _vaults[vault]
                    .totalStake,
                getFutureUnlockedRewards(timestamp),
                getFutureTotalStakeUnits(timestamp),
                timestamp,
                _hypervisor
                    .rewardScaling
            )
                .reward;
    }

    function getCurrentStakeReward(address vault, uint256 stakeAmount)
        external
        view
        override
        returns (uint256 reward)
    {
        // calculate rewards
        return
            calculateRewardFromStakes(
                _vaults[vault]
                    .stakes,
                stakeAmount,
                getCurrentUnlockedRewards(),
                getCurrentTotalStakeUnits(),
                block
                    .timestamp,
                _hypervisor
                    .rewardScaling
            )
                .reward;
    }

    function getFutureStakeReward(
        address vault,
        uint256 stakeAmount,
        uint256 timestamp
    ) external view override returns (uint256 reward) {
        // calculate rewards
        return
            calculateRewardFromStakes(
                _vaults[vault]
                    .stakes,
                stakeAmount,
                getFutureUnlockedRewards(timestamp),
                getFutureTotalStakeUnits(timestamp),
                timestamp,
                _hypervisor
                    .rewardScaling
            )
                .reward;
    }

    function getCurrentVaultStakeUnits(address vault)
        public
        view
        override
        returns (uint256 stakeUnits)
    {
        // calculate stake units
        return getFutureVaultStakeUnits(vault, block.timestamp);
    }

    function getFutureVaultStakeUnits(address vault, uint256 timestamp)
        public
        view
        override
        returns (uint256 stakeUnits)
    {
        // calculate stake units
        return calculateTotalStakeUnits(_vaults[vault].stakes, timestamp);
    }

    /* pure functions */

    function calculateTotalStakeUnits(StakeData[] memory stakes, uint256 timestamp)
        public
        pure
        override
        returns (uint256 totalStakeUnits)
    {
        for (uint256 index; index < stakes.length; index++) {
            // reference stake
            StakeData memory stakeData = stakes[index];
            // calculate stake units
            uint256 stakeUnits =
                calculateStakeUnits(stakeData.amount, stakeData.timestamp, timestamp);
            // add to running total
            totalStakeUnits = totalStakeUnits.add(stakeUnits);
        }
    }

    function calculateStakeUnits(
        uint256 amount,
        uint256 start,
        uint256 end
    ) public pure override returns (uint256 stakeUnits) {
        // calculate duration
        uint256 duration = end.sub(start);
        // calculate stake units
        stakeUnits = duration.mul(amount);
        // explicit return
        return stakeUnits;
    }

    function calculateUnlockedRewards(
        RewardSchedule[] memory rewardSchedules,
        uint256 rewardBalance,
        uint256 sharesOutstanding,
        uint256 timestamp
    ) public pure override returns (uint256 unlockedRewards) {
        // return 0 if no registered schedules
        if (rewardSchedules.length == 0) {
            return 0;
        }

        // calculate reward shares locked across all reward schedules
        uint256 sharesLocked;
        for (uint256 index = 0; index < rewardSchedules.length; index++) {
            // fetch reward schedule storage reference
            RewardSchedule memory schedule = rewardSchedules[index];

            // caculate amount of shares available on this schedule
            // if (now - start) < duration
            //   sharesLocked = shares - (shares * (now - start) / duration)
            // else
            //   sharesLocked = 0
            uint256 currentSharesLocked = 0;
            if (timestamp.sub(schedule.start) < schedule.duration) {
                currentSharesLocked = schedule.shares.sub(
                    schedule.shares.mul(timestamp.sub(schedule.start)).div(schedule.duration)
                );
            }

            // add to running total
            sharesLocked = sharesLocked.add(currentSharesLocked);
        }

        // convert shares to reward
        // rewardLocked = sharesLocked * rewardBalance / sharesOutstanding
        uint256 rewardLocked = sharesLocked.mul(rewardBalance).div(sharesOutstanding);

        // calculate amount available
        // unlockedRewards = rewardBalance - rewardLocked
        unlockedRewards = rewardBalance.sub(rewardLocked);

        // explicit return
        return unlockedRewards;
    }

    function calculateRewardFromStakes(
        StakeData[] memory stakes,
        uint256 unstakeAmount,
        uint256 unlockedRewards,
        uint256 totalStakeUnits,
        uint256 timestamp,
        RewardScaling memory rewardScaling
    ) public pure override returns (RewardOutput memory out) {
        uint256 stakesToDrop = 0;
        while (unstakeAmount > 0) {
            // fetch vault stake storage reference
            StakeData memory lastStake = stakes[stakes.length.sub(stakesToDrop).sub(1)];

            // calculate stake duration
            uint256 stakeDuration = timestamp.sub(lastStake.timestamp);

            uint256 currentAmount;
            if (lastStake.amount > unstakeAmount) {
                // set current amount to remaining unstake amount
                currentAmount = unstakeAmount;
                // amount of last stake is reduced
                out.lastStakeAmount = lastStake.amount.sub(unstakeAmount);
            } else {
                // set current amount to amount of last stake
                currentAmount = lastStake.amount;
                // add to stakes to drop
                stakesToDrop += 1;
            }

            // update remaining unstakeAmount
            unstakeAmount = unstakeAmount.sub(currentAmount);

            // calculate reward amount
            uint256 currentReward =
                calculateReward(
                    unlockedRewards,
                    currentAmount,
                    stakeDuration,
                    totalStakeUnits,
                    rewardScaling
                );

            // update cumulative reward
            out.reward = out.reward.add(currentReward);

            // update cached unlockedRewards
            unlockedRewards = unlockedRewards.sub(currentReward);

            // calculate time weighted stake
            uint256 stakeUnits = currentAmount.mul(stakeDuration);

            // update cached totalStakeUnits
            totalStakeUnits = totalStakeUnits.sub(stakeUnits);
        }

        // explicit return
        return
            RewardOutput(
                out.lastStakeAmount,
                stakes.length.sub(stakesToDrop),
                out.reward,
                totalStakeUnits
            );
    }

    function calculateReward(
        uint256 unlockedRewards,
        uint256 stakeAmount,
        uint256 stakeDuration,
        uint256 totalStakeUnits,
        RewardScaling memory rewardScaling
    ) public pure override returns (uint256 reward) {
        // calculate time weighted stake
        uint256 stakeUnits = stakeAmount.mul(stakeDuration);

        // calculate base reward
        // baseReward = unlockedRewards * stakeUnits / totalStakeUnits
        uint256 baseReward = 0;
        if (totalStakeUnits != 0) {
            // scale reward according to proportional weight
            baseReward = unlockedRewards.mul(stakeUnits).div(totalStakeUnits);
        }

        // calculate scaled reward
        // if no scaling or scaling period completed
        //   reward = baseReward
        // else
        //   minReward = baseReward * scalingFloor / scalingCeiling
        //   bonusReward = baseReward
        //                 * (scalingCeiling - scalingFloor) / scalingCeiling
        //                 * duration / scalingTime
        //   reward = minReward + bonusReward
        if (stakeDuration >= rewardScaling.time || rewardScaling.floor == rewardScaling.ceiling) {
            // no reward scaling applied
            reward = baseReward;
        } else {
            // calculate minimum reward using scaling floor
            uint256 minReward = baseReward.mul(rewardScaling.floor).div(rewardScaling.ceiling);

            // calculate bonus reward with vested portion of scaling factor
            uint256 bonusReward =
                baseReward
                    .mul(stakeDuration)
                    .mul(rewardScaling.ceiling.sub(rewardScaling.floor))
                    .div(rewardScaling.ceiling)
                    .div(rewardScaling.time);

            // add minimum reward and bonus reward
            reward = minReward.add(bonusReward);
        }

        // explicit return
        return reward;
    }

    /* admin functions */

    /// @notice Add funds to the Hypervisor
    /// access control: only admin
    /// state machine:
    ///   - can be called multiple times
    ///   - only online
    /// state scope:
    ///   - increase _hypervisor.rewardSharesOutstanding
    ///   - append to _hypervisor.rewardSchedules
    /// token transfer: transfer staking tokens from msg.sender to reward pool
    /// @param amount uint256 Amount of reward tokens to deposit
    /// @param duration uint256 Duration over which to linearly unlock rewards
    function fund(uint256 amount, uint256 duration) external onlyOwner onlyOnline {
        // validate duration
        require(duration != 0, ""Hypervisor: invalid duration"");

        // create new reward shares
        // if existing rewards on this Hypervisor
        //   mint new shares proportional to % change in rewards remaining
        //   newShares = remainingShares * newReward / remainingRewards
        // else
        //   mint new shares with BASE_SHARES_PER_WEI initial conversion rate
        //   store as fixed point number with same  of decimals as reward token
        uint256 newRewardShares;
        if (_hypervisor.rewardSharesOutstanding > 0) {
            uint256 remainingRewards = IERC20(_hypervisor.rewardToken).balanceOf(_hypervisor.rewardPool);
            newRewardShares = _hypervisor.rewardSharesOutstanding.mul(amount).div(remainingRewards);
        } else {
            newRewardShares = amount.mul(BASE_SHARES_PER_WEI);
        }

        // add reward shares to total
        _hypervisor.rewardSharesOutstanding = _hypervisor.rewardSharesOutstanding.add(newRewardShares);

        // store new reward schedule
        _hypervisor.rewardSchedules.push(RewardSchedule(duration, block.timestamp, newRewardShares));

        // transfer reward tokens to reward pool
        TransferHelper.safeTransferFrom(
            _hypervisor.rewardToken,
            msg.sender,
            _hypervisor.rewardPool,
            amount
        );

        // emit event
        emit HypervisorFunded(amount, duration);
    }

    /// @notice Add vault factory to whitelist
    /// @dev use this function to enable stakes to vaults coming from the specified
    ///      factory contract
    /// access control: only admin
    /// state machine:
    ///   - can be called multiple times
    ///   - not shutdown
    /// state scope:
    ///   - append to _vaultFactorySet
    /// token transfer: none
    /// @param factory address The address of the vault factory
    function registerVaultFactory(address factory) external onlyOwner notShutdown {
        // add factory to set
        require(_vaultFactorySet.add(factory), ""Hypervisor: vault factory already registered"");

        // emit event
        emit VaultFactoryRegistered(factory);
    }

    /// @notice Remove vault factory from whitelist
    /// @dev use this function to disable new stakes to vaults coming from the specified
    ///      factory contract.
    ///      note: vaults with existing stakes from this factory are sill able to unstake
    /// access control: only admin
    /// state machine:
    ///   - can be called multiple times
    ///   - not shutdown
    /// state scope:
    ///   - remove from _vaultFactorySet
    /// token transfer: none
    /// @param factory address The address of the vault factory
    function removeVaultFactory(address factory) external onlyOwner notShutdown {
        // remove factory from set
        require(_vaultFactorySet.remove(factory), ""Hypervisor: vault factory not registered"");

        // emit event
        emit VaultFactoryRemoved(factory);
    }

    /// @notice Register bonus token for distribution
    /// @dev use this function to enable distribution of any ERC20 held by the RewardPool contract
    /// access control: only admin
    /// state machine:
    ///   - can be called multiple times
    ///   - only online
    /// state scope:
    ///   - append to _bonusTokenSet
    /// token transfer: none
    /// @param bonusToken address The address of the bonus token
    function registerBonusToken(address bonusToken) external onlyOwner onlyOnline {
        // verify valid bonus token
        _validateAddress(bonusToken);

        // verify bonus token count
        require(_bonusTokenSet.length() < MAX_REWARD_TOKENS, ""Hypervisor: max bonus tokens reached "");

        // add token to set
        assert(_bonusTokenSet.add(bonusToken));

        // emit event
        emit BonusTokenRegistered(bonusToken);
    }

    /// @notice Rescue tokens from RewardPool
    /// @dev use this function to rescue tokens from RewardPool contract
    ///      without distributing to stakers or triggering emergency shutdown
    /// access control: only admin
    /// state machine:
    ///   - can be called multiple times
    ///   - only online
    /// state scope: none
    /// token transfer: transfer requested token from RewardPool to recipient
    /// @param token address The address of the token to rescue
    /// @param recipient address The address of the recipient
    /// @param amount uint256 The amount of tokens to rescue
    function rescueTokensFromRewardPool(
        address token,
        address recipient,
        uint256 amount
    ) external onlyOwner onlyOnline {
        // verify recipient
        _validateAddress(recipient);

        // check not attempting to unstake reward token
        require(token != _hypervisor.rewardToken, ""Hypervisor: invalid address"");

        // check not attempting to wthdraw bonus token
        require(!_bonusTokenSet.contains(token), ""Hypervisor: invalid address"");

        // transfer tokens to recipient
        IRewardPool(_hypervisor.rewardPool).sendERC20(token, recipient, amount);
    }

    /* user functions */

    /// @notice Stake tokens
    /// @dev anyone can stake to any vault if they have valid permission
    /// access control: anyone
    /// state machine:
    ///   - can be called multiple times
    ///   - only online
    ///   - when vault exists on this Hypervisor
    /// state scope:
    ///   - append to _vaults[vault].stakes
    ///   - increase _vaults[vault].totalStake
    ///   - increase _hypervisor.totalStake
    ///   - increase _hypervisor.totalStakeUnits
    ///   - increase _hypervisor.lastUpdate
    /// token transfer: transfer staking tokens from msg.sender to vault
    /// @param vault address The address of the vault to stake from
    /// @param amount uint256 The amount of staking tokens to stake
    function stake(
        address vault,
        uint256 amount,
        bytes calldata permission
    ) external override onlyOnline {
        // verify vault is valid
        require(isValidVault(vault), ""Hypervisor: vault is not registered"");

        // verify non-zero amount
        require(amount != 0, ""Hypervisor: no amount staked"");

        // fetch vault storage reference
        VaultData storage vaultData = _vaults[vault];

        // verify stakes boundary not reached
        require(
            vaultData.stakes.length < MAX_STAKES_PER_VAULT,
            ""Hypervisor: MAX_STAKES_PER_VAULT reached""
        );

        // update cached sum of stake units across all vaults
        _updateTotalStakeUnits();

        // store amount and timestamp
        vaultData.stakes.push(StakeData(amount, block.timestamp));

        // update cached total vault and Hypervisor amounts
        vaultData.totalStake = vaultData.totalStake.add(amount);
        // verify stake quantity without bounds
        require(
            stakeLimit == 0 || vaultData.totalStake <= stakeLimit,
            ""Hypervisor: Stake limit exceeded""
        );
        _hypervisor.totalStake = _hypervisor.totalStake.add(amount);

        // call lock on vault
        IUniversalVault(vault).lock(_hypervisor.stakingToken, amount, permission);

        // emit event
        emit Staked(vault, amount);
    }

    /// @notice Unstake staking tokens and claim reward
    /// @dev rewards can only be claimed when unstaking
    /// access control: only owner of vault
    /// state machine:
    ///   - when vault exists on this Hypervisor
    ///   - after stake from vault
    ///   - can be called multiple times while sufficient stake remains
    ///   - only online
    /// state scope:
    ///   - decrease _hypervisor.rewardSharesOutstanding
    ///   - decrease _hypervisor.totalStake
    ///   - increase _hypervisor.lastUpdate
    ///   - modify _hypervisor.totalStakeUnits
    ///   - modify _vaults[vault].stakes
    ///   - decrease _vaults[vault].totalStake
    /// token transfer:
    ///   - transfer reward tokens from reward pool to recipient
    ///   - transfer bonus tokens from reward pool to recipient
    /// @param vault address The vault to unstake from
    /// @param amount uint256 The amount of staking tokens to unstake
    function unstakeAndClaim(
        address vault,
        uint256 amount,
        bytes calldata permission
    ) external override onlyOnline {
        // fetch vault storage reference
        VaultData storage vaultData = _vaults[vault];

        // verify non-zero amount
        require(amount != 0, ""Hypervisor: no amount unstaked"");

        address recipient = IUniversalVault(vault).owner();

        // validate recipient
        _validateAddress(recipient);

        // check for sufficient vault stake amount
        require(vaultData.totalStake >= amount, ""Hypervisor: insufficient vault stake"");

        // check for sufficient Hypervisor stake amount
        // if this check fails, there is a bug in stake accounting
        assert(_hypervisor.totalStake >= amount);

        // update cached sum of stake units across all vaults
        _updateTotalStakeUnits();

        // get reward amount remaining
        uint256 remainingRewards = IERC20(_hypervisor.rewardToken).balanceOf(_hypervisor.rewardPool);

        // calculate vested portion of reward pool
        uint256 unlockedRewards =
            calculateUnlockedRewards(
                _hypervisor.rewardSchedules,
                remainingRewards,
                _hypervisor.rewardSharesOutstanding,
                block.timestamp
            );

        // calculate vault time weighted reward with scaling
        RewardOutput memory out =
            calculateRewardFromStakes(
                vaultData.stakes,
                amount,
                unlockedRewards,
                _hypervisor.totalStakeUnits,
                block.timestamp,
                _hypervisor.rewardScaling
            );

        // update stake data in storage
        if (out.newStakesCount == 0) {
            // all stakes have been unstaked
            delete vaultData.stakes;
        } else {
            // some stakes have been completely or partially unstaked
            // delete fully unstaked stakes
            while (vaultData.stakes.length > out.newStakesCount) vaultData.stakes.pop();
            // update partially unstaked stake
            vaultData.stakes[out.newStakesCount.sub(1)].amount = out.lastStakeAmount;
        }

        // update cached stake totals
        vaultData.totalStake = vaultData.totalStake.sub(amount);
        _hypervisor.totalStake = _hypervisor.totalStake.sub(amount);
        _hypervisor.totalStakeUnits = out.newTotalStakeUnits;

        // unlock staking tokens from vault
        IUniversalVault(vault).unlock(_hypervisor.stakingToken, amount, permission);

        // emit event
        emit Unstaked(vault, amount);

        // only perform on non-zero reward
        if (out.reward > 0) {
            // calculate shares to burn
            // sharesToBurn = sharesOutstanding * reward / remainingRewards
            uint256 sharesToBurn =
                _hypervisor.rewardSharesOutstanding.mul(out.reward).div(remainingRewards);

            // burn claimed shares
            _hypervisor.rewardSharesOutstanding = _hypervisor.rewardSharesOutstanding.sub(sharesToBurn);

            // transfer bonus tokens from reward pool to recipient
            if (_bonusTokenSet.length() > 0) {
                for (uint256 index = 0; index < _bonusTokenSet.length(); index++) {
                    // fetch bonus token address reference
                    address bonusToken = _bonusTokenSet.at(index);

                    // calculate bonus token amount
                    // bonusAmount = bonusRemaining * reward / remainingRewards
                    uint256 bonusAmount =
                        IERC20(bonusToken).balanceOf(_hypervisor.rewardPool).mul(out.reward).div(
                            remainingRewards
                        );

                    // transfer bonus token
                    IRewardPool(_hypervisor.rewardPool).sendERC20(bonusToken, recipient, bonusAmount);

                    // emit event
                    emit RewardClaimed(vault, recipient, bonusToken, bonusAmount);
                }
            }

            // transfer reward tokens from reward pool to recipient
            IRewardPool(_hypervisor.rewardPool).sendERC20(_hypervisor.rewardToken, recipient, out.reward);

            // emit event
            emit RewardClaimed(vault, recipient, _hypervisor.rewardToken, out.reward);
        }
    }

    /// @notice Exit Hypervisor without claiming reward
    /// @dev This function should never revert when correctly called by the vault.
    ///      A max number of stakes per vault is set with MAX_STAKES_PER_VAULT to
    ///      place an upper bound on the for loop in calculateTotalStakeUnits().
    /// access control: only callable by the vault directly
    /// state machine:
    ///   - when vault exists on this Hypervisor
    ///   - when active stake from this vault
    ///   - any power state
    /// state scope:
    ///   - decrease _hypervisor.totalStake
    ///   - increase _hypervisor.lastUpdate
    ///   - modify _hypervisor.totalStakeUnits
    ///   - delete _vaults[vault]
    /// token transfer: none
    function rageQuit() external override {
        // fetch vault storage reference
        VaultData storage _vaultData = _vaults[msg.sender];

        // revert if no active stakes
        require(_vaultData.stakes.length != 0, ""Hypervisor: no stake"");

        // update cached sum of stake units across all vaults
        _updateTotalStakeUnits();

        // emit event
        emit Unstaked(msg.sender, _vaultData.totalStake);

        // update cached totals
        _hypervisor.totalStake = _hypervisor.totalStake.sub(_vaultData.totalStake);
        _hypervisor.totalStakeUnits = _hypervisor.totalStakeUnits.sub(
            calculateTotalStakeUnits(_vaultData.stakes, block.timestamp)
        );

        // delete stake data
        delete _vaults[msg.sender];
    }

    /* convenience functions */

    function _updateTotalStakeUnits() private {
        // update cached totalStakeUnits
        _hypervisor.totalStakeUnits = getCurrentTotalStakeUnits();
        // update cached lastUpdate
        _hypervisor.lastUpdate = block.timestamp;
    }

    function _validateAddress(address target) private view {
        // sanity check target for potential input errors
        require(isValidAddress(target), ""Hypervisor: invalid address"");
    }

    function _truncateStakesArray(StakeData[] memory array, uint256 newLength)
        private
        pure
        returns (StakeData[] memory newArray)
    {
        newArray = new StakeData[](newLength);
        for (uint256 index = 0; index < newLength; index++) {
            newArray[index] = array[index];
        }
        return newArray;
    }
}
"".
Ideas: "" Lack of Authorization Identified.

```
LACK OF AUTHORIZATION
'''
The `rageQuit()` function allows any user to exit the Hypervisor without claiming rewards. This function is callable by any address that has a registered vault, as it does not have any access control modifiers restricting its invocation. This could potentially allow malicious actors to exploit this function to withdraw stakes without proper authorization, especially if they manage to create a vault.

Recommended Mitigation:
Implement an access control modifier to restrict the `rageQuit()` function to only allow calls from the owner of the vault. This can be done by checking if `msg.sender` is the owner of the vault before allowing the function to execute.
'''
```

```
LACK OF AUTHORIZATION
'''
The `unstakeAndClaim"".
As the Security Analyst, your primary objective is to perform a thorough and detailed inspection of the provided contract code, with a particular focus on identifying vulnerabilities related to Potential Data Inconsistency. This type of vulnerability occurs when data may become inconsistent due to incorrect assumptions about how data is stored, accessed, or modified.
Proceed with the following steps in your analysis:
1. Scrutinize the contract's code to identify any assumptions made about the behavior of storage and memory when handling data.
2. Look for patterns where data is copied from storage to memory, or vice versa, and determine if these operations are performed correctly.
3. Identify any functions or segments of code where temporary copies of data are made, and assess whether these copies are used appropriately without causing unintended modifications to the original data.
4. Evaluate the overall logic of data manipulation within the contract to ensure that all operations maintain consistency and integrity of the stored data.
If you discover any Potential Data Inconsistency vulnerabilities, respond with: """,,,,,,,,"<INFO> Redundant Conditional Check Identified.
```
REDUNDANT CONDITIONAL CHECK
'''
In the `isValidAddress` function, the check for `target != address(this)` is redundant because the function is already designed to validate addresses that are not the contract itself. Additionally, the check for `target != address(0)` is also redundant as it is

[2024-02-08 00:44:51 INFO] **[Execute Detail]**

execute SimplePhase:[OracleDependencyDetector] in ComposedPhase:[CodeReview], cycle 1

[2024-02-08 00:44:51 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: GPL-3.0-only pragma solidity 0.7.6; pragma abicoder v2; import {SafeMath} from ""@openzeppelin/contracts/math/SafeMath.sol""; import {EnumerableSet} from ""@openzeppelin/contracts/utils/EnumerableSet.sol""; import {IERC20} from ""@openzeppelin/contracts/token/ERC20/IERC20.sol""; import {Ownable} from ""@openzeppelin/contracts/access/Ownable.sol""; import {TransferHelper} from ""@uniswap/lib/contracts/libraries/TransferHelper.sol""; import {IFactory} from ""../factory/IFactory.sol""; import {IInstanceRegistry} from ""../factory/InstanceRegistry.sol""; import {IUniversalVault} from ""../visor/Visor.sol""; import {IRewardPool} from ""./RewardPool.sol""; import {Powered} from ""./Powered.sol""; interface IRageQuit {     function rageQuit() external; } interface IHypervisor is IRageQuit {     / admin events / event HypervisorCreated(address rewardPool, address powerSwitch); event HypervisorFunded(uint256 amount, uint256 duration); event BonusTokenRegistered(address token); event VaultFactoryRegistered(address factory); event VaultFactoryRemoved(address factory);  /* user events */  event Staked(address vault, uint256 amount); event Unstaked(address vault, uint256 amount); event RewardClaimed(address vault, address recipient, address token, uint256 amount);  /* data types */  struct HypervisorData {     address stakingToken;     address rewardToken;     address rewardPool;     RewardScaling rewardScaling;     uint256 rewardSharesOutstanding;     uint256 totalStake;     uint256 totalStakeUnits;     uint256 lastUpdate;     RewardSchedule[] rewardSchedules; }  struct RewardSchedule {     uint256 duration;     uint256 start;     uint256 shares; }  struct VaultData {     uint256 totalStake;     StakeData[] stakes; }  struct StakeData {     uint256 amount;     uint256 timestamp; }  struct RewardScaling {     uint256 floor;     uint256 ceiling;     uint256 time; }  struct RewardOutput {     uint256 lastStakeAmount;     uint256 newStakesCount;     uint256 reward;     uint256 newTotalStakeUnits; }  /* user functions */  function stake(     address vault,     uint256 amount,     bytes calldata permission ) external;  function unstakeAndClaim(     address vault,     uint256 amount,     bytes calldata permission ) external;  /* getter functions */  function getHypervisorData() external view returns (HypervisorData memory hypervisor);  function getBonusTokenSetLength() external view returns (uint256 length);  function getBonusTokenAtIndex(uint256 index) external view returns (address bonusToken);  function getVaultFactorySetLength() external view returns (uint256 length);  function getVaultFactoryAtIndex(uint256 index) external view returns (address factory);  function getVaultData(address vault) external view returns (VaultData memory vaultData);  function isValidAddress(address target) external view returns (bool validity);  function isValidVault(address target) external view returns (bool validity);  function getCurrentUnlockedRewards() external view returns (uint256 unlockedRewards);  function getFutureUnlockedRewards(uint256 timestamp)     external     view     returns (uint256 unlockedRewards);  function getCurrentVaultReward(address vault) external view returns (uint256 reward);  function getCurrentStakeReward(address vault, uint256 stakeAmount)     external     view     returns (uint256 reward);  function getFutureVaultReward(address vault, uint256 timestamp)     external     view     returns (uint256 reward);  function getFutureStakeReward(     address vault,     uint256 stakeAmount,     uint256 timestamp ) external view returns (uint256 reward);  function getCurrentVaultStakeUnits(address vault) external view returns (uint256 stakeUnits);  function getFutureVaultStakeUnits(address vault, uint256 timestamp)     external     view     returns (uint256 stakeUnits);  function getCurrentTotalStakeUnits() external view returns (uint256 totalStakeUnits);  function getFutureTotalStakeUnits(uint256 timestamp)     external     view     returns (uint256 totalStakeUnits);  /* pure functions */  function calculateTotalStakeUnits(StakeData[] memory stakes, uint256 timestamp)     external     pure     returns (uint256 totalStakeUnits);  function calculateStakeUnits(     uint256 amount,     uint256 start,     uint256 end ) external pure returns (uint256 stakeUnits);  function calculateUnlockedRewards(     RewardSchedule[] memory rewardSchedules,     uint256 rewardBalance,     uint256 sharesOutstanding,     uint256 timestamp ) external pure returns (uint256 unlockedRewards);  function calculateRewardFromStakes(     StakeData[] memory stakes,     uint256 unstakeAmount,     uint256 unlockedRewards,     uint256 totalStakeUnits,     uint256 timestamp,     RewardScaling memory rewardScaling ) external pure returns (RewardOutput memory out);  function calculateReward(     uint256 unlockedRewards,     uint256 stakeAmount,     uint256 stakeDuration,     uint256 totalStakeUnits,     RewardScaling memory rewardScaling ) external pure returns (uint256 reward);  } /// @title Hypervisor /// @notice Reward distribution contract with time multiplier /// Access Control /// - Power controller: ///     Can power off / shutdown the Hypervisor ///     Can withdraw rewards from reward pool once shutdown /// - Proxy owner: ///     Can change arbitrary logic / state by upgrading the Hypervisor ///     Is unable to operate on user funds due to UniversalVault ///     Is unable to operate on reward pool funds when reward pool is offline / shutdown /// - Hypervisor admin: ///     Can add funds to the Hypervisor, register bonus tokens, and whitelist new vault factories ///     Is a subset of proxy owner permissions /// - User: ///     Can deposit / withdraw / ragequit /// Hypervisor State Machine /// - Online: ///     Hypervisor is operating normally, all functions are enabled /// - Offline: ///     Hypervisor is temporarely disabled for maintenance ///     User deposits and withdrawls are disabled, ragequit remains enabled ///     Users can withdraw their stake through rageQuit() but forego their pending reward ///     Should only be used when downtime required for an upgrade /// - Shutdown: ///     Hypervisor is permanently disabled ///     All functions are disabled with the exception of ragequit ///     Users can withdraw their stake through rageQuit() ///     Power controller can withdraw from the reward pool ///     Should only be used if Proxy Owner role is compromized contract Hypervisor is IHypervisor, Powered, Ownable {     using SafeMath for uint256;     using EnumerableSet for EnumerableSet.AddressSet; /* constants */  // An upper bound on the number of active stakes per vault is required to prevent // calls to rageQuit() from reverting. // With 30 stakes in a vault, ragequit costs 432811 gas which is conservatively lower // than the hardcoded limit of 500k gas on the vault. // This limit is configurable and could be increased in a future deployment. // Ultimately, to avoid a need for fixed upper bounds, the EVM would need to provide // an error code that allows for reliably catching out-of-gas errors on remote calls. uint256 public constant MAX_STAKES_PER_VAULT = 30; uint256 public constant MAX_REWARD_TOKENS = 50; uint256 public constant BASE_SHARES_PER_WEI = 1000000; uint256 public stakeLimit = 2500 ether;  /* storage */  HypervisorData private _hypervisor; mapping(address =&gt; VaultData) private _vaults; EnumerableSet.AddressSet private _bonusTokenSet; EnumerableSet.AddressSet private _vaultFactorySet;  /* initializer */  /// @notice Initizalize Hypervisor /// access control: only proxy constructor /// state machine: can only be called once /// state scope: set initialization variables /// token transfer: none /// @param ownerAddress address The admin address /// @param rewardPoolFactory address The factory to use for deploying the RewardPool /// @param powerSwitchFactory address The factory to use for deploying the PowerSwitch /// @param stakingToken address The address of the staking token for this Hypervisor /// @param rewardToken address The address of the reward token for this Hypervisor /// @param rewardScaling RewardScaling The config for reward scaling floor, ceiling, and time constructor(     address ownerAddress,     address rewardPoolFactory,     address powerSwitchFactory,     address stakingToken,     address rewardToken,     RewardScaling memory rewardScaling,     uint256 _stakeLimit ) {     // the scaling floor must be smaller than ceiling     require(rewardScaling.floor &lt;= rewardScaling.ceiling, ""Hypervisor: floor above ceiling"");      // setting rewardScalingTime to 0 would cause divide by zero error     // to disable reward scaling, use rewardScalingFloor == rewardScalingCeiling     require(rewardScaling.time != 0, ""Hypervisor: scaling time cannot be zero"");      // deploy power switch     address powerSwitch = IFactory(powerSwitchFactory).create(abi.encode(ownerAddress));      // deploy reward pool     address rewardPool = IFactory(rewardPoolFactory).create(abi.encode(powerSwitch));      // set internal configs     Ownable.transferOwnership(ownerAddress);     Powered._setPowerSwitch(powerSwitch);      // commit to storage     _hypervisor.stakingToken = stakingToken;     _hypervisor.rewardToken = rewardToken;     _hypervisor.rewardPool = rewardPool;     _hypervisor.rewardScaling = rewardScaling;      stakeLimit = _stakeLimit;      // emit event     emit HypervisorCreated(rewardPool, powerSwitch); }  /* getter functions */  function getBonusTokenSetLength() external view override returns (uint256 length) {     return _bonusTokenSet.length(); }  function getBonusTokenAtIndex(uint256 index)     external     view     override     returns (address bonusToken) {     return _bonusTokenSet.at(index); }  function getVaultFactorySetLength() external view override returns (uint256 length) {     return _vaultFactorySet.length(); }  function getVaultFactoryAtIndex(uint256 index)     external     view     override     returns (address factory) {     return _vaultFactorySet.at(index); }  function isValidVault(address target) public view override returns (bool validity) {     // validate target is created from whitelisted vault factory     for (uint256 index = 0; index &lt; _vaultFactorySet.length(); index++) {         if (IInstanceRegistry(_vaultFactorySet.at(index)).isInstance(target)) {             return true;         }     }     // explicit return     return false; }  function isValidAddress(address target) public view override returns (bool validity) {     // sanity check target for potential input errors     return         target != address(this) &amp;&amp;         target != address(0) &amp;&amp;         target != _hypervisor.stakingToken &amp;&amp;         target != _hypervisor.rewardToken &amp;&amp;         target != _hypervisor.rewardPool &amp;&amp;         !_bonusTokenSet.contains(target); }  /* Hypervisor getters */  function getHypervisorData() external view override returns (HypervisorData memory hypervisor) {     return _hypervisor; }  function getCurrentUnlockedRewards() public view override returns (uint256 unlockedRewards) {     // calculate reward available based on state     return getFutureUnlockedRewards(block.timestamp); }  function getFutureUnlockedRewards(uint256 timestamp)     public     view     override     returns (uint256 unlockedRewards) {     // get reward amount remaining     uint256 remainingRewards = IERC20(_hypervisor.rewardToken).balanceOf(_hypervisor.rewardPool);     // calculate reward available based on state     unlockedRewards = calculateUnlockedRewards(         _hypervisor.rewardSchedules,         remainingRewards,         _hypervisor.rewardSharesOutstanding,         timestamp     );     // explicit return     return unlockedRewards; }  function getCurrentTotalStakeUnits() public view override returns (uint256 totalStakeUnits) {     // calculate new stake units     return getFutureTotalStakeUnits(block.timestamp); }  function getFutureTotalStakeUnits(uint256 timestamp)     public     view     override     returns (uint256 totalStakeUnits) {     // return early if no change     if (timestamp == _hypervisor.lastUpdate) return _hypervisor.totalStakeUnits;     // calculate new stake units     uint256 newStakeUnits =         calculateStakeUnits(_hypervisor.totalStake, _hypervisor.lastUpdate, timestamp);     // add to cached total     totalStakeUnits = _hypervisor.totalStakeUnits.add(newStakeUnits);     // explicit return     return totalStakeUnits; }  /* vault getters */  function getVaultData(address vault)     external     view     override     returns (VaultData memory vaultData) {     return _vaults[vault]; }  function getCurrentVaultReward(address vault) external view override returns (uint256 reward) {     // calculate rewards     return         calculateRewardFromStakes(             _vaults[vault]                 .stakes,             _vaults[vault]                 .totalStake,             getCurrentUnlockedRewards(),             getCurrentTotalStakeUnits(),             block                 .timestamp,             _hypervisor                 .rewardScaling         )             .reward; }  function getFutureVaultReward(address vault, uint256 timestamp)     external     view     override     returns (uint256 reward) {     // calculate rewards     return         calculateRewardFromStakes(             _vaults[vault]                 .stakes,             _vaults[vault]                 .totalStake,             getFutureUnlockedRewards(timestamp),             getFutureTotalStakeUnits(timestamp),             timestamp,             _hypervisor                 .rewardScaling         )             .reward; }  function getCurrentStakeReward(address vault, uint256 stakeAmount)     external     view     override     returns (uint256 reward) {     // calculate rewards     return         calculateRewardFromStakes(             _vaults[vault]                 .stakes,             stakeAmount,             getCurrentUnlockedRewards(),             getCurrentTotalStakeUnits(),             block                 .timestamp,             _hypervisor                 .rewardScaling         )             .reward; }  function getFutureStakeReward(     address vault,     uint256 stakeAmount,     uint256 timestamp ) external view override returns (uint256 reward) {     // calculate rewards     return         calculateRewardFromStakes(             _vaults[vault]                 .stakes,             stakeAmount,             getFutureUnlockedRewards(timestamp),             getFutureTotalStakeUnits(timestamp),             timestamp,             _hypervisor                 .rewardScaling         )             .reward; }  function getCurrentVaultStakeUnits(address vault)     public     view     override     returns (uint256 stakeUnits) {     // calculate stake units     return getFutureVaultStakeUnits(vault, block.timestamp); }  function getFutureVaultStakeUnits(address vault, uint256 timestamp)     public     view     override     returns (uint256 stakeUnits) {     // calculate stake units     return calculateTotalStakeUnits(_vaults[vault].stakes, timestamp); }  /* pure functions */  function calculateTotalStakeUnits(StakeData[] memory stakes, uint256 timestamp)     public     pure     override     returns (uint256 totalStakeUnits) {     for (uint256 index; index &lt; stakes.length; index++) {         // reference stake         StakeData memory stakeData = stakes[index];         // calculate stake units         uint256 stakeUnits =             calculateStakeUnits(stakeData.amount, stakeData.timestamp, timestamp);         // add to running total         totalStakeUnits = totalStakeUnits.add(stakeUnits);     } }  function calculateStakeUnits(     uint256 amount,     uint256 start,     uint256 end ) public pure override returns (uint256 stakeUnits) {     // calculate duration     uint256 duration = end.sub(start);     // calculate stake units     stakeUnits = duration.mul(amount);     // explicit return     return stakeUnits; }  function calculateUnlockedRewards(     RewardSchedule[] memory rewardSchedules,     uint256 rewardBalance,     uint256 sharesOutstanding,     uint256 timestamp ) public pure override returns (uint256 unlockedRewards) {     // return 0 if no registered schedules     if (rewardSchedules.length == 0) {         return 0;     }      // calculate reward shares locked across all reward schedules     uint256 sharesLocked;     for (uint256 index = 0; index &lt; rewardSchedules.length; index++) {         // fetch reward schedule storage reference         RewardSchedule memory schedule = rewardSchedules[index];          // caculate amount of shares available on this schedule         // if (now - start) &lt; duration         //   sharesLocked = shares - (shares * (now - start) / duration)         // else         //   sharesLocked = 0         uint256 currentSharesLocked = 0;         if (timestamp.sub(schedule.start) &lt; schedule.duration) {             currentSharesLocked = schedule.shares.sub(                 schedule.shares.mul(timestamp.sub(schedule.start)).div(schedule.duration)             );         }          // add to running total         sharesLocked = sharesLocked.add(currentSharesLocked);     }      // convert shares to reward     // rewardLocked = sharesLocked * rewardBalance / sharesOutstanding     uint256 rewardLocked = sharesLocked.mul(rewardBalance).div(sharesOutstanding);      // calculate amount available     // unlockedRewards = rewardBalance - rewardLocked     unlockedRewards = rewardBalance.sub(rewardLocked);      // explicit return     return unlockedRewards; }  function calculateRewardFromStakes(     StakeData[] memory stakes,     uint256 unstakeAmount,     uint256 unlockedRewards,     uint256 totalStakeUnits,     uint256 timestamp,     RewardScaling memory rewardScaling ) public pure override returns (RewardOutput memory out) {     uint256 stakesToDrop = 0;     while (unstakeAmount &gt; 0) {         // fetch vault stake storage reference         StakeData memory lastStake = stakes[stakes.length.sub(stakesToDrop).sub(1)];          // calculate stake duration         uint256 stakeDuration = timestamp.sub(lastStake.timestamp);          uint256 currentAmount;         if (lastStake.amount &gt; unstakeAmount) {             // set current amount to remaining unstake amount             currentAmount = unstakeAmount;             // amount of last stake is reduced             out.lastStakeAmount = lastStake.amount.sub(unstakeAmount);         } else {             // set current amount to amount of last stake             currentAmount = lastStake.amount;             // add to stakes to drop             stakesToDrop += 1;         }          // update remaining unstakeAmount         unstakeAmount = unstakeAmount.sub(currentAmount);          // calculate reward amount         uint256 currentReward =             calculateReward(                 unlockedRewards,                 currentAmount,                 stakeDuration,                 totalStakeUnits,                 rewardScaling             );          // update cumulative reward         out.reward = out.reward.add(currentReward);          // update cached unlockedRewards         unlockedRewards = unlockedRewards.sub(currentReward);          // calculate time weighted stake         uint256 stakeUnits = currentAmount.mul(stakeDuration);          // update cached totalStakeUnits         totalStakeUnits = totalStakeUnits.sub(stakeUnits);     }      // explicit return     return         RewardOutput(             out.lastStakeAmount,             stakes.length.sub(stakesToDrop),             out.reward,             totalStakeUnits         ); }  function calculateReward(     uint256 unlockedRewards,     uint256 stakeAmount,     uint256 stakeDuration,     uint256 totalStakeUnits,     RewardScaling memory rewardScaling ) public pure override returns (uint256 reward) {     // calculate time weighted stake     uint256 stakeUnits = stakeAmount.mul(stakeDuration);      // calculate base reward     // baseReward = unlockedRewards * stakeUnits / totalStakeUnits     uint256 baseReward = 0;     if (totalStakeUnits != 0) {         // scale reward according to proportional weight         baseReward = unlockedRewards.mul(stakeUnits).div(totalStakeUnits);     }      // calculate scaled reward     // if no scaling or scaling period completed     //   reward = baseReward     // else     //   minReward = baseReward * scalingFloor / scalingCeiling     //   bonusReward = baseReward     //                 * (scalingCeiling - scalingFloor) / scalingCeiling     //                 * duration / scalingTime     //   reward = minReward + bonusReward     if (stakeDuration &gt;= rewardScaling.time || rewardScaling.floor == rewardScaling.ceiling) {         // no reward scaling applied         reward = baseReward;     } else {         // calculate minimum reward using scaling floor         uint256 minReward = baseReward.mul(rewardScaling.floor).div(rewardScaling.ceiling);          // calculate bonus reward with vested portion of scaling factor         uint256 bonusReward =             baseReward                 .mul(stakeDuration)                 .mul(rewardScaling.ceiling.sub(rewardScaling.floor))                 .div(rewardScaling.ceiling)                 .div(rewardScaling.time);          // add minimum reward and bonus reward         reward = minReward.add(bonusReward);     }      // explicit return     return reward; }  /* admin functions */  /// @notice Add funds to the Hypervisor /// access control: only admin /// state machine: ///   - can be called multiple times ///   - only online /// state scope: ///   - increase _hypervisor.rewardSharesOutstanding ///   - append to _hypervisor.rewardSchedules /// token transfer: transfer staking tokens from msg.sender to reward pool /// @param amount uint256 Amount of reward tokens to deposit /// @param duration uint256 Duration over which to linearly unlock rewards function fund(uint256 amount, uint256 duration) external onlyOwner onlyOnline {     // validate duration     require(duration != 0, ""Hypervisor: invalid duration"");      // create new reward shares     // if existing rewards on this Hypervisor     //   mint new shares proportional to % change in rewards remaining     //   newShares = remainingShares * newReward / remainingRewards     // else     //   mint new shares with BASE_SHARES_PER_WEI initial conversion rate     //   store as fixed point number with same  of decimals as reward token     uint256 newRewardShares;     if (_hypervisor.rewardSharesOutstanding &gt; 0) {         uint256 remainingRewards = IERC20(_hypervisor.rewardToken).balanceOf(_hypervisor.rewardPool);         newRewardShares = _hypervisor.rewardSharesOutstanding.mul(amount).div(remainingRewards);     } else {         newRewardShares = amount.mul(BASE_SHARES_PER_WEI);     }      // add reward shares to total     _hypervisor.rewardSharesOutstanding = _hypervisor.rewardSharesOutstanding.add(newRewardShares);      // store new reward schedule     _hypervisor.rewardSchedules.push(RewardSchedule(duration, block.timestamp, newRewardShares));      // transfer reward tokens to reward pool     TransferHelper.safeTransferFrom(         _hypervisor.rewardToken,         msg.sender,         _hypervisor.rewardPool,         amount     );      // emit event     emit HypervisorFunded(amount, duration); }  /// @notice Add vault factory to whitelist /// @dev use this function to enable stakes to vaults coming from the specified ///      factory contract /// access control: only admin /// state machine: ///   - can be called multiple times ///   - not shutdown /// state scope: ///   - append to _vaultFactorySet /// token transfer: none /// @param factory address The address of the vault factory function registerVaultFactory(address factory) external onlyOwner notShutdown {     // add factory to set     require(_vaultFactorySet.add(factory), ""Hypervisor: vault factory already registered"");      // emit event     emit VaultFactoryRegistered(factory); }  /// @notice Remove vault factory from whitelist /// @dev use this function to disable new stakes to vaults coming from the specified ///      factory contract. ///      note: vaults with existing stakes from this factory are sill able to unstake /// access control: only admin /// state machine: ///   - can be called multiple times ///   - not shutdown /// state scope: ///   - remove from _vaultFactorySet /// token transfer: none /// @param factory address The address of the vault factory function removeVaultFactory(address factory) external onlyOwner notShutdown {     // remove factory from set     require(_vaultFactorySet.remove(factory), ""Hypervisor: vault factory not registered"");      // emit event     emit VaultFactoryRemoved(factory); }  /// @notice Register bonus token for distribution /// @dev use this function to enable distribution of any ERC20 held by the RewardPool contract /// access control: only admin /// state machine: ///   - can be called multiple times ///   - only online /// state scope: ///   - append to _bonusTokenSet /// token transfer: none /// @param bonusToken address The address of the bonus token function registerBonusToken(address bonusToken) external onlyOwner onlyOnline {     // verify valid bonus token     _validateAddress(bonusToken);      // verify bonus token count     require(_bonusTokenSet.length() &lt; MAX_REWARD_TOKENS, ""Hypervisor: max bonus tokens reached "");      // add token to set     assert(_bonusTokenSet.add(bonusToken));      // emit event     emit BonusTokenRegistered(bonusToken); }  /// @notice Rescue tokens from RewardPool /// @dev use this function to rescue tokens from RewardPool contract ///      without distributing to stakers or triggering emergency shutdown /// access control: only admin /// state machine: ///   - can be called multiple times ///   - only online /// state scope: none /// token transfer: transfer requested token from RewardPool to recipient /// @param token address The address of the token to rescue /// @param recipient address The address of the recipient /// @param amount uint256 The amount of tokens to rescue function rescueTokensFromRewardPool(     address token,     address recipient,     uint256 amount ) external onlyOwner onlyOnline {     // verify recipient     _validateAddress(recipient);      // check not attempting to unstake reward token     require(token != _hypervisor.rewardToken, ""Hypervisor: invalid address"");      // check not attempting to wthdraw bonus token     require(!_bonusTokenSet.contains(token), ""Hypervisor: invalid address"");      // transfer tokens to recipient     IRewardPool(_hypervisor.rewardPool).sendERC20(token, recipient, amount); }  /* user functions */  /// @notice Stake tokens /// @dev anyone can stake to any vault if they have valid permission /// access control: anyone /// state machine: ///   - can be called multiple times ///   - only online ///   - when vault exists on this Hypervisor /// state scope: ///   - append to _vaults[vault].stakes ///   - increase _vaults[vault].totalStake ///   - increase _hypervisor.totalStake ///   - increase _hypervisor.totalStakeUnits ///   - increase _hypervisor.lastUpdate /// token transfer: transfer staking tokens from msg.sender to vault /// @param vault address The address of the vault to stake from /// @param amount uint256 The amount of staking tokens to stake function stake(     address vault,     uint256 amount,     bytes calldata permission ) external override onlyOnline {     // verify vault is valid     require(isValidVault(vault), ""Hypervisor: vault is not registered"");      // verify non-zero amount     require(amount != 0, ""Hypervisor: no amount staked"");      // fetch vault storage reference     VaultData storage vaultData = _vaults[vault];      // verify stakes boundary not reached     require(         vaultData.stakes.length &lt; MAX_STAKES_PER_VAULT,         ""Hypervisor: MAX_STAKES_PER_VAULT reached""     );      // update cached sum of stake units across all vaults     _updateTotalStakeUnits();      // store amount and timestamp     vaultData.stakes.push(StakeData(amount, block.timestamp));      // update cached total vault and Hypervisor amounts     vaultData.totalStake = vaultData.totalStake.add(amount);     // verify stake quantity without bounds     require(         stakeLimit == 0 || vaultData.totalStake &lt;= stakeLimit,         ""Hypervisor: Stake limit exceeded""     );     _hypervisor.totalStake = _hypervisor.totalStake.add(amount);      // call lock on vault     IUniversalVault(vault).lock(_hypervisor.stakingToken, amount, permission);      // emit event     emit Staked(vault, amount); }  /// @notice Unstake staking tokens and claim reward /// @dev rewards can only be claimed when unstaking /// access control: only owner of vault /// state machine: ///   - when vault exists on this Hypervisor ///   - after stake from vault ///   - can be called multiple times while sufficient stake remains ///   - only online /// state scope: ///   - decrease _hypervisor.rewardSharesOutstanding ///   - decrease _hypervisor.totalStake ///   - increase _hypervisor.lastUpdate ///   - modify _hypervisor.totalStakeUnits ///   - modify _vaults[vault].stakes ///   - decrease _vaults[vault].totalStake /// token transfer: ///   - transfer reward tokens from reward pool to recipient ///   - transfer bonus tokens from reward pool to recipient /// @param vault address The vault to unstake from /// @param amount uint256 The amount of staking tokens to unstake function unstakeAndClaim(     address vault,     uint256 amount,     bytes calldata permission ) external override onlyOnline {     // fetch vault storage reference     VaultData storage vaultData = _vaults[vault];      // verify non-zero amount     require(amount != 0, ""Hypervisor: no amount unstaked"");      address recipient = IUniversalVault(vault).owner();      // validate recipient     _validateAddress(recipient);      // check for sufficient vault stake amount     require(vaultData.totalStake &gt;= amount, ""Hypervisor: insufficient vault stake"");      // check for sufficient Hypervisor stake amount     // if this check fails, there is a bug in stake accounting     assert(_hypervisor.totalStake &gt;= amount);      // update cached sum of stake units across all vaults     _updateTotalStakeUnits();      // get reward amount remaining     uint256 remainingRewards = IERC20(_hypervisor.rewardToken).balanceOf(_hypervisor.rewardPool);      // calculate vested portion of reward pool     uint256 unlockedRewards =         calculateUnlockedRewards(             _hypervisor.rewardSchedules,             remainingRewards,             _hypervisor.rewardSharesOutstanding,             block.timestamp         );      // calculate vault time weighted reward with scaling     RewardOutput memory out =         calculateRewardFromStakes(             vaultData.stakes,             amount,             unlockedRewards,             _hypervisor.totalStakeUnits,             block.timestamp,             _hypervisor.rewardScaling         );      // update stake data in storage     if (out.newStakesCount == 0) {         // all stakes have been unstaked         delete vaultData.stakes;     } else {         // some stakes have been completely or partially unstaked         // delete fully unstaked stakes         while (vaultData.stakes.length &gt; out.newStakesCount) vaultData.stakes.pop();         // update partially unstaked stake         vaultData.stakes[out.newStakesCount.sub(1)].amount = out.lastStakeAmount;     }      // update cached stake totals     vaultData.totalStake = vaultData.totalStake.sub(amount);     _hypervisor.totalStake = _hypervisor.totalStake.sub(amount);     _hypervisor.totalStakeUnits = out.newTotalStakeUnits;      // unlock staking tokens from vault     IUniversalVault(vault).unlock(_hypervisor.stakingToken, amount, permission);      // emit event     emit Unstaked(vault, amount);      // only perform on non-zero reward     if (out.reward &gt; 0) {         // calculate shares to burn         // sharesToBurn = sharesOutstanding * reward / remainingRewards         uint256 sharesToBurn =             _hypervisor.rewardSharesOutstanding.mul(out.reward).div(remainingRewards);          // burn claimed shares         _hypervisor.rewardSharesOutstanding = _hypervisor.rewardSharesOutstanding.sub(sharesToBurn);          // transfer bonus tokens from reward pool to recipient         if (_bonusTokenSet.length() &gt; 0) {             for (uint256 index = 0; index &lt; _bonusTokenSet.length(); index++) {                 // fetch bonus token address reference                 address bonusToken = _bonusTokenSet.at(index);                  // calculate bonus token amount                 // bonusAmount = bonusRemaining * reward / remainingRewards                 uint256 bonusAmount =                     IERC20(bonusToken).balanceOf(_hypervisor.rewardPool).mul(out.reward).div(                         remainingRewards                     );                  // transfer bonus token                 IRewardPool(_hypervisor.rewardPool).sendERC20(bonusToken, recipient, bonusAmount);                  // emit event                 emit RewardClaimed(vault, recipient, bonusToken, bonusAmount);             }         }          // transfer reward tokens from reward pool to recipient         IRewardPool(_hypervisor.rewardPool).sendERC20(_hypervisor.rewardToken, recipient, out.reward);          // emit event         emit RewardClaimed(vault, recipient, _hypervisor.rewardToken, out.reward);     } }  /// @notice Exit Hypervisor without claiming reward /// @dev This function should never revert when correctly called by the vault. ///      A max number of stakes per vault is set with MAX_STAKES_PER_VAULT to ///      place an upper bound on the for loop in calculateTotalStakeUnits(). /// access control: only callable by the vault directly /// state machine: ///   - when vault exists on this Hypervisor ///   - when active stake from this vault ///   - any power state /// state scope: ///   - decrease _hypervisor.totalStake ///   - increase _hypervisor.lastUpdate ///   - modify _hypervisor.totalStakeUnits ///   - delete _vaults[vault] /// token transfer: none function rageQuit() external override {     // fetch vault storage reference     VaultData storage _vaultData = _vaults[msg.sender];      // revert if no active stakes     require(_vaultData.stakes.length != 0, ""Hypervisor: no stake"");      // update cached sum of stake units across all vaults     _updateTotalStakeUnits();      // emit event     emit Unstaked(msg.sender, _vaultData.totalStake);      // update cached totals     _hypervisor.totalStake = _hypervisor.totalStake.sub(_vaultData.totalStake);     _hypervisor.totalStakeUnits = _hypervisor.totalStakeUnits.sub(         calculateTotalStakeUnits(_vaultData.stakes, block.timestamp)     );      // delete stake data     delete _vaults[msg.sender]; }  /* convenience functions */  function _updateTotalStakeUnits() private {     // update cached totalStakeUnits     _hypervisor.totalStakeUnits = getCurrentTotalStakeUnits();     // update cached lastUpdate     _hypervisor.lastUpdate = block.timestamp; }  function _validateAddress(address target) private view {     // sanity check target for potential input errors     require(isValidAddress(target), ""Hypervisor: invalid address""); }  function _truncateStakesArray(StakeData[] memory array, uint256 newLength)     private     pure     returns (StakeData[] memory newArray) {     newArray = new StakeData[](newLength);     for (uint256 index = 0; index &lt; newLength; index++) {         newArray[index] = array[index];     }     return newArray; }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: ""{task}"". Ideas: ""{ideas}"". As the {assistant_role}, your primary objective is to perform a thorough and detailed inspection of the provided contract code, with a particular focus on identifying vulnerabilities related to External Oracle Dependency. There are two main concerns related to External Oracle Dependency vulnerabilities: 1. Dependence on a single external oracle for critical data, which pertains to the reliability of the data source. If the oracle is compromised, provides incorrect data, or becomes unavailable, the contract's functionalities could be adversely affected. 2. Lack of fallback mechanisms, which can lead to the contract failing if the external oracle call fails or returns invalid data. This could be exploited by adversaries to disrupt the contract's operations. If you identify reliance on a single external oracle for critical data, respond with: "" External Oracle Dependency Identified."" For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE ''' DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code ''' If you don't find any vulnerabilities, respond only with: "" NO External Oracle Dependency."" |
| **phase_name** | OracleDependencyDetector |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 1, 'modification_conclusion': '', 'cycle_index': 1, 'task': '// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport {SafeMath} from ""@openzeppelin/contracts/math/SafeMath.sol"";\nimport {EnumerableSet} from ""@openzeppelin/contracts/utils/EnumerableSet.sol"";\nimport {IERC20} from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";\nimport {Ownable} from ""@openzeppelin/contracts/access/Ownable.sol"";\nimport {TransferHelper} from ""@uniswap/lib/contracts/libraries/TransferHelper.sol"";\n\nimport {IFactory} from ""../factory/IFactory.sol"";\nimport {IInstanceRegistry} from ""../factory/InstanceRegistry.sol"";\nimport {IUniversalVault} from ""../visor/Visor.sol"";\nimport {IRewardPool} from ""./RewardPool.sol"";\nimport {Powered} from ""./Powered.sol"";\n\ninterface IRageQuit {\n    function rageQuit() external;\n}\n\ninterface IHypervisor is IRageQuit {\n    / admin events /\n\n    event HypervisorCreated(address rewardPool, address powerSwitch);\n    event HypervisorFunded(uint256 amount, uint256 duration);\n    event BonusTokenRegistered(address token);\n    event VaultFactoryRegistered(address factory);\n    event VaultFactoryRemoved(address factory);\n\n    / user events /\n\n    event Staked(address vault, uint256 amount);\n    event Unstaked(address vault, uint256 amount);\n    event RewardClaimed(address vault, address recipient, address token, uint256 amount);\n\n    / data types /\n\n    struct HypervisorData {\n        address stakingToken;\n        address rewardToken;\n        address rewardPool;\n        RewardScaling rewardScaling;\n        uint256 rewardSharesOutstanding;\n        uint256 totalStake;\n        uint256 totalStakeUnits;\n        uint256 lastUpdate;\n        RewardSchedule[] rewardSchedules;\n    }\n\n    struct RewardSchedule {\n        uint256 duration;\n        uint256 start;\n        uint256 shares;\n    }\n\n    struct VaultData {\n        uint256 totalStake;\n        StakeData[] stakes;\n    }\n\n    struct StakeData {\n        uint256 amount;\n        uint256 timestamp;\n    }\n\n    struct RewardScaling {\n        uint256 floor;\n        uint256 ceiling;\n        uint256 time;\n    }\n\n    struct RewardOutput {\n        uint256 lastStakeAmount;\n        uint256 newStakesCount;\n        uint256 reward;\n        uint256 newTotalStakeUnits;\n    }\n\n    / user functions /\n\n    function stake(\n        address vault,\n        uint256 amount,\n        bytes calldata permission\n    ) external;\n\n    function unstakeAndClaim(\n        address vault,\n        uint256 amount,\n        bytes calldata permission\n    ) external;\n\n    / getter functions /\n\n    function getHypervisorData() external view returns (HypervisorData memory hypervisor);\n\n    function getBonusTokenSetLength() external view returns (uint256 length);\n\n    function getBonusTokenAtIndex(uint256 index) external view returns (address bonusToken);\n\n    function getVaultFactorySetLength() external view returns (uint256 length);\n\n    function getVaultFactoryAtIndex(uint256 index) external view returns (address factory);\n\n    function getVaultData(address vault) external view returns (VaultData memory vaultData);\n\n    function isValidAddress(address target) external view returns (bool validity);\n\n    function isValidVault(address target) external view returns (bool validity);\n\n    function getCurrentUnlockedRewards() external view returns (uint256 unlockedRewards);\n\n    function getFutureUnlockedRewards(uint256 timestamp)\n        external\n        view\n        returns (uint256 unlockedRewards);\n\n    function getCurrentVaultReward(address vault) external view returns (uint256 reward);\n\n    function getCurrentStakeReward(address vault, uint256 stakeAmount)\n        external\n        view\n        returns (uint256 reward);\n\n    function getFutureVaultReward(address vault, uint256 timestamp)\n        external\n        view\n        returns (uint256 reward);\n\n    function getFutureStakeReward(\n        address vault,\n        uint256 stakeAmount,\n        uint256 timestamp\n    ) external view returns (uint256 reward);\n\n    function getCurrentVaultStakeUnits(address vault) external view returns (uint256 stakeUnits);\n\n    function getFutureVaultStakeUnits(address vault, uint256 timestamp)\n        external\n        view\n        returns (uint256 stakeUnits);\n\n    function getCurrentTotalStakeUnits() external view returns (uint256 totalStakeUnits);\n\n    function getFutureTotalStakeUnits(uint256 timestamp)\n        external\n        view\n        returns (uint256 totalStakeUnits);\n\n    / pure functions /\n\n    function calculateTotalStakeUnits(StakeData[] memory stakes, uint256 timestamp)\n        external\n        pure\n        returns (uint256 totalStakeUnits);\n\n    function calculateStakeUnits(\n        uint256 amount,\n        uint256 start,\n        uint256 end\n    ) external pure returns (uint256 stakeUnits);\n\n    function calculateUnlockedRewards(\n        RewardSchedule[] memory rewardSchedules,\n        uint256 rewardBalance,\n        uint256 sharesOutstanding,\n        uint256 timestamp\n    ) external pure returns (uint256 unlockedRewards);\n\n    function calculateRewardFromStakes(\n        StakeData[] memory stakes,\n        uint256 unstakeAmount,\n        uint256 unlockedRewards,\n        uint256 totalStakeUnits,\n        uint256 timestamp,\n        RewardScaling memory rewardScaling\n    ) external pure returns (RewardOutput memory out);\n\n    function calculateReward(\n        uint256 unlockedRewards,\n        uint256 stakeAmount,\n        uint256 stakeDuration,\n        uint256 totalStakeUnits,\n        RewardScaling memory rewardScaling\n    ) external pure returns (uint256 reward);\n}\n\n/// @title Hypervisor\n/// @notice Reward distribution contract with time multiplier\n/// Access Control\n/// - Power controller:\n///     Can power off / shutdown the Hypervisor\n///     Can withdraw rewards from reward pool once shutdown\n/// - Proxy owner:\n///     Can change arbitrary logic / state by upgrading the Hypervisor\n///     Is unable to operate on user funds due to UniversalVault\n///     Is unable to operate on reward pool funds when reward pool is offline / shutdown\n/// - Hypervisor admin:\n///     Can add funds to the Hypervisor, register bonus tokens, and whitelist new vault factories\n///     Is a subset of proxy owner permissions\n/// - User:\n///     Can deposit / withdraw / ragequit\n/// Hypervisor State Machine\n/// - Online:\n///     Hypervisor is operating normally, all functions are enabled\n/// - Offline:\n///     Hypervisor is temporarely disabled for maintenance\n///     User deposits and withdrawls are disabled, ragequit remains enabled\n///     Users can withdraw their stake through rageQuit() but forego their pending reward\n///     Should only be used when downtime required for an upgrade\n/// - Shutdown:\n///     Hypervisor is permanently disabled\n///     All functions are disabled with the exception of ragequit\n///     Users can withdraw their stake through rageQuit()\n///     Power controller can withdraw from the reward pool\n///     Should only be used if Proxy Owner role is compromized\ncontract Hypervisor is IHypervisor, Powered, Ownable {\n    using SafeMath for uint256;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    / constants /\n\n    // An upper bound on the number of active stakes per vault is required to prevent\n    // calls to rageQuit() from reverting.\n    // With 30 stakes in a vault, ragequit costs 432811 gas which is conservatively lower\n    // than the hardcoded limit of 500k gas on the vault.\n    // This limit is configurable and could be increased in a future deployment.\n    // Ultimately, to avoid a need for fixed upper bounds, the EVM would need to provide\n    // an error code that allows for reliably catching out-of-gas errors on remote calls.\n    uint256 public constant MAX_STAKES_PER_VAULT = 30;\n    uint256 public constant MAX_REWARD_TOKENS = 50;\n    uint256 public constant BASE_SHARES_PER_WEI = 1000000;\n    uint256 public stakeLimit = 2500 ether;\n\n    / storage /\n\n    HypervisorData private _hypervisor;\n    mapping(address =&gt; VaultData) private _vaults;\n    EnumerableSet.AddressSet private _bonusTokenSet;\n    EnumerableSet.AddressSet private _vaultFactorySet;\n\n    / initializer /\n\n    /// @notice Initizalize Hypervisor\n    /// access control: only proxy constructor\n    /// state machine: can only be called once\n    /// state scope: set initialization variables\n    /// token transfer: none\n    /// @param ownerAddress address The admin address\n    /// @param rewardPoolFactory address The factory to use for deploying the RewardPool\n    /// @param powerSwitchFactory address The factory to use for deploying the PowerSwitch\n    /// @param stakingToken address The address of the staking token for this Hypervisor\n    /// @param rewardToken address The address of the reward token for this Hypervisor\n    /// @param rewardScaling RewardScaling The config for reward scaling floor, ceiling, and time\n    constructor(\n        address ownerAddress,\n        address rewardPoolFactory,\n        address powerSwitchFactory,\n        address stakingToken,\n        address rewardToken,\n        RewardScaling memory rewardScaling,\n        uint256 _stakeLimit\n    ) {\n        // the scaling floor must be smaller than ceiling\n        require(rewardScaling.floor &lt;= rewardScaling.ceiling, ""Hypervisor: floor above ceiling"");\n\n        // setting rewardScalingTime to 0 would cause divide by zero error\n        // to disable reward scaling, use rewardScalingFloor == rewardScalingCeiling\n        require(rewardScaling.time != 0, ""Hypervisor: scaling time cannot be zero"");\n\n        // deploy power switch\n        address powerSwitch = IFactory(powerSwitchFactory).create(abi.encode(ownerAddress));\n\n        // deploy reward pool\n        address rewardPool = IFactory(rewardPoolFactory).create(abi.encode(powerSwitch));\n\n        // set internal configs\n        Ownable.transferOwnership(ownerAddress);\n        Powered._setPowerSwitch(powerSwitch);\n\n        // commit to storage\n        _hypervisor.stakingToken = stakingToken;\n        _hypervisor.rewardToken = rewardToken;\n        _hypervisor.rewardPool = rewardPool;\n        _hypervisor.rewardScaling = rewardScaling;\n\n        stakeLimit = _stakeLimit;\n\n        // emit event\n        emit HypervisorCreated(rewardPool, powerSwitch);\n    }\n\n    / getter functions /\n\n    function getBonusTokenSetLength() external view override returns (uint256 length) {\n        return _bonusTokenSet.length();\n    }\n\n    function getBonusTokenAtIndex(uint256 index)\n        external\n        view\n        override\n        returns (address bonusToken)\n    {\n        return _bonusTokenSet.at(index);\n    }\n\n    function getVaultFactorySetLength() external view override returns (uint256 length) {\n        return _vaultFactorySet.length();\n    }\n\n    function getVaultFactoryAtIndex(uint256 index)\n        external\n        view\n        override\n        returns (address factory)\n    {\n        return _vaultFactorySet.at(index);\n    }\n\n    function isValidVault(address target) public view override returns (bool validity) {\n        // validate target is created from whitelisted vault factory\n        for (uint256 index = 0; index &lt; _vaultFactorySet.length(); index++) {\n            if (IInstanceRegistry(_vaultFactorySet.at(index)).isInstance(target)) {\n                return true;\n            }\n        }\n        // explicit return\n        return false;\n    }\n\n    function isValidAddress(address target) public view override returns (bool validity) {\n        // sanity check target for potential input errors\n        return\n            target != address(this) &amp;&amp;\n            target != address(0) &amp;&amp;\n            target != _hypervisor.stakingToken &amp;&amp;\n            target != _hypervisor.rewardToken &amp;&amp;\n            target != _hypervisor.rewardPool &amp;&amp;\n            !_bonusTokenSet.contains(target);\n    }\n\n    / Hypervisor getters /\n\n    function getHypervisorData() external view override returns (HypervisorData memory hypervisor) {\n        return _hypervisor;\n    }\n\n    function getCurrentUnlockedRewards() public view override returns (uint256 unlockedRewards) {\n        // calculate reward available based on state\n        return getFutureUnlockedRewards(block.timestamp);\n    }\n\n    function getFutureUnlockedRewards(uint256 timestamp)\n        public\n        view\n        override\n        returns (uint256 unlockedRewards)\n    {\n        // get reward amount remaining\n        uint256 remainingRewards = IERC20(_hypervisor.rewardToken).balanceOf(_hypervisor.rewardPool);\n        // calculate reward available based on state\n        unlockedRewards = calculateUnlockedRewards(\n            _hypervisor.rewardSchedules,\n            remainingRewards,\n            _hypervisor.rewardSharesOutstanding,\n            timestamp\n        );\n        // explicit return\n        return unlockedRewards;\n    }\n\n    function getCurrentTotalStakeUnits() public view override returns (uint256 totalStakeUnits) {\n        // calculate new stake units\n        return getFutureTotalStakeUnits(block.timestamp);\n    }\n\n    function getFutureTotalStakeUnits(uint256 timestamp)\n        public\n        view\n        override\n        returns (uint256 totalStakeUnits)\n    {\n        // return early if no change\n        if (timestamp == _hypervisor.lastUpdate) return _hypervisor.totalStakeUnits;\n        // calculate new stake units\n        uint256 newStakeUnits =\n            calculateStakeUnits(_hypervisor.totalStake, _hypervisor.lastUpdate, timestamp);\n        // add to cached total\n        totalStakeUnits = _hypervisor.totalStakeUnits.add(newStakeUnits);\n        // explicit return\n        return totalStakeUnits;\n    }\n\n    / vault getters /\n\n    function getVaultData(address vault)\n        external\n        view\n        override\n        returns (VaultData memory vaultData)\n    {\n        return _vaults[vault];\n    }\n\n    function getCurrentVaultReward(address vault) external view override returns (uint256 reward) {\n        // calculate rewards\n        return\n            calculateRewardFromStakes(\n                _vaults[vault]\n                    .stakes,\n                _vaults[vault]\n                    .totalStake,\n                getCurrentUnlockedRewards(),\n                getCurrentTotalStakeUnits(),\n                block\n                    .timestamp,\n                _hypervisor\n                    .rewardScaling\n            )\n                .reward;\n    }\n\n    function getFutureVaultReward(address vault, uint256 timestamp)\n        external\n        view\n        override\n        returns (uint256 reward)\n    {\n        // calculate rewards\n        return\n            calculateRewardFromStakes(\n                _vaults[vault]\n                    .stakes,\n                _vaults[vault]\n                    .totalStake,\n                getFutureUnlockedRewards(timestamp),\n                getFutureTotalStakeUnits(timestamp),\n                timestamp,\n                _hypervisor\n                    .rewardScaling\n            )\n                .reward;\n    }\n\n    function getCurrentStakeReward(address vault, uint256 stakeAmount)\n        external\n        view\n        override\n        returns (uint256 reward)\n    {\n        // calculate rewards\n        return\n            calculateRewardFromStakes(\n                _vaults[vault]\n                    .stakes,\n                stakeAmount,\n                getCurrentUnlockedRewards(),\n                getCurrentTotalStakeUnits(),\n                block\n                    .timestamp,\n                _hypervisor\n                    .rewardScaling\n            )\n                .reward;\n    }\n\n    function getFutureStakeReward(\n        address vault,\n        uint256 stakeAmount,\n        uint256 timestamp\n    ) external view override returns (uint256 reward) {\n        // calculate rewards\n        return\n            calculateRewardFromStakes(\n                _vaults[vault]\n                    .stakes,\n                stakeAmount,\n                getFutureUnlockedRewards(timestamp),\n                getFutureTotalStakeUnits(timestamp),\n                timestamp,\n                _hypervisor\n                    .rewardScaling\n            )\n                .reward;\n    }\n\n    function getCurrentVaultStakeUnits(address vault)\n        public\n        view\n        override\n        returns (uint256 stakeUnits)\n    {\n        // calculate stake units\n        return getFutureVaultStakeUnits(vault, block.timestamp);\n    }\n\n    function getFutureVaultStakeUnits(address vault, uint256 timestamp)\n        public\n        view\n        override\n        returns (uint256 stakeUnits)\n    {\n        // calculate stake units\n        return calculateTotalStakeUnits(_vaults[vault].stakes, timestamp);\n    }\n\n    / pure functions /\n\n    function calculateTotalStakeUnits(StakeData[] memory stakes, uint256 timestamp)\n        public\n        pure\n        override\n        returns (uint256 totalStakeUnits)\n    {\n        for (uint256 index; index &lt; stakes.length; index++) {\n            // reference stake\n            StakeData memory stakeData = stakes[index];\n            // calculate stake units\n            uint256 stakeUnits =\n                calculateStakeUnits(stakeData.amount, stakeData.timestamp, timestamp);\n            // add to running total\n            totalStakeUnits = totalStakeUnits.add(stakeUnits);\n        }\n    }\n\n    function calculateStakeUnits(\n        uint256 amount,\n        uint256 start,\n        uint256 end\n    ) public pure override returns (uint256 stakeUnits) {\n        // calculate duration\n        uint256 duration = end.sub(start);\n        // calculate stake units\n        stakeUnits = duration.mul(amount);\n        // explicit return\n        return stakeUnits;\n    }\n\n    function calculateUnlockedRewards(\n        RewardSchedule[] memory rewardSchedules,\n        uint256 rewardBalance,\n        uint256 sharesOutstanding,\n        uint256 timestamp\n    ) public pure override returns (uint256 unlockedRewards) {\n        // return 0 if no registered schedules\n        if (rewardSchedules.length == 0) {\n            return 0;\n        }\n\n        // calculate reward shares locked across all reward schedules\n        uint256 sharesLocked;\n        for (uint256 index = 0; index &lt; rewardSchedules.length; index++) {\n            // fetch reward schedule storage reference\n            RewardSchedule memory schedule = rewardSchedules[index];\n\n            // caculate amount of shares available on this schedule\n            // if (now - start) &lt; duration\n            //   sharesLocked = shares - (shares * (now - start) / duration)\n            // else\n            //   sharesLocked = 0\n            uint256 currentSharesLocked = 0;\n            if (timestamp.sub(schedule.start) &lt; schedule.duration) {\n                currentSharesLocked = schedule.shares.sub(\n                    schedule.shares.mul(timestamp.sub(schedule.start)).div(schedule.duration)\n                );\n            }\n\n            // add to running total\n            sharesLocked = sharesLocked.add(currentSharesLocked);\n        }\n\n        // convert shares to reward\n        // rewardLocked = sharesLocked * rewardBalance / sharesOutstanding\n        uint256 rewardLocked = sharesLocked.mul(rewardBalance).div(sharesOutstanding);\n\n        // calculate amount available\n        // unlockedRewards = rewardBalance - rewardLocked\n        unlockedRewards = rewardBalance.sub(rewardLocked);\n\n        // explicit return\n        return unlockedRewards;\n    }\n\n    function calculateRewardFromStakes(\n        StakeData[] memory stakes,\n        uint256 unstakeAmount,\n        uint256 unlockedRewards,\n        uint256 totalStakeUnits,\n        uint256 timestamp,\n        RewardScaling memory rewardScaling\n    ) public pure override returns (RewardOutput memory out) {\n        uint256 stakesToDrop = 0;\n        while (unstakeAmount &gt; 0) {\n            // fetch vault stake storage reference\n            StakeData memory lastStake = stakes[stakes.length.sub(stakesToDrop).sub(1)];\n\n            // calculate stake duration\n            uint256 stakeDuration = timestamp.sub(lastStake.timestamp);\n\n            uint256 currentAmount;\n            if (lastStake.amount &gt; unstakeAmount) {\n                // set current amount to remaining unstake amount\n                currentAmount = unstakeAmount;\n                // amount of last stake is reduced\n                out.lastStakeAmount = lastStake.amount.sub(unstakeAmount);\n            } else {\n                // set current amount to amount of last stake\n                currentAmount = lastStake.amount;\n                // add to stakes to drop\n                stakesToDrop += 1;\n            }\n\n            // update remaining unstakeAmount\n            unstakeAmount = unstakeAmount.sub(currentAmount);\n\n            // calculate reward amount\n            uint256 currentReward =\n                calculateReward(\n                    unlockedRewards,\n                    currentAmount,\n                    stakeDuration,\n                    totalStakeUnits,\n                    rewardScaling\n                );\n\n            // update cumulative reward\n            out.reward = out.reward.add(currentReward);\n\n            // update cached unlockedRewards\n            unlockedRewards = unlockedRewards.sub(currentReward);\n\n            // calculate time weighted stake\n            uint256 stakeUnits = currentAmount.mul(stakeDuration);\n\n            // update cached totalStakeUnits\n            totalStakeUnits = totalStakeUnits.sub(stakeUnits);\n        }\n\n        // explicit return\n        return\n            RewardOutput(\n                out.lastStakeAmount,\n                stakes.length.sub(stakesToDrop),\n                out.reward,\n                totalStakeUnits\n            );\n    }\n\n    function calculateReward(\n        uint256 unlockedRewards,\n        uint256 stakeAmount,\n        uint256 stakeDuration,\n        uint256 totalStakeUnits,\n        RewardScaling memory rewardScaling\n    ) public pure override returns (uint256 reward) {\n        // calculate time weighted stake\n        uint256 stakeUnits = stakeAmount.mul(stakeDuration);\n\n        // calculate base reward\n        // baseReward = unlockedRewards * stakeUnits / totalStakeUnits\n        uint256 baseReward = 0;\n        if (totalStakeUnits != 0) {\n            // scale reward according to proportional weight\n            baseReward = unlockedRewards.mul(stakeUnits).div(totalStakeUnits);\n        }\n\n        // calculate scaled reward\n        // if no scaling or scaling period completed\n        //   reward = baseReward\n        // else\n        //   minReward = baseReward * scalingFloor / scalingCeiling\n        //   bonusReward = baseReward\n        //                 * (scalingCeiling - scalingFloor) / scalingCeiling\n        //                 * duration / scalingTime\n        //   reward = minReward + bonusReward\n        if (stakeDuration &gt;= rewardScaling.time || rewardScaling.floor == rewardScaling.ceiling) {\n            // no reward scaling applied\n            reward = baseReward;\n        } else {\n            // calculate minimum reward using scaling floor\n            uint256 minReward = baseReward.mul(rewardScaling.floor).div(rewardScaling.ceiling);\n\n            // calculate bonus reward with vested portion of scaling factor\n            uint256 bonusReward =\n                baseReward\n                    .mul(stakeDuration)\n                    .mul(rewardScaling.ceiling.sub(rewardScaling.floor))\n                    .div(rewardScaling.ceiling)\n                    .div(rewardScaling.time);\n\n            // add minimum reward and bonus reward\n            reward = minReward.add(bonusReward);\n        }\n\n        // explicit return\n        return reward;\n    }\n\n    / admin functions /\n\n    /// @notice Add funds to the Hypervisor\n    /// access control: only admin\n    /// state machine:\n    ///   - can be called multiple times\n    ///   - only online\n    /// state scope:\n    ///   - increase _hypervisor.rewardSharesOutstanding\n    ///   - append to _hypervisor.rewardSchedules\n    /// token transfer: transfer staking tokens from msg.sender to reward pool\n    /// @param amount uint256 Amount of reward tokens to deposit\n    /// @param duration uint256 Duration over which to linearly unlock rewards\n    function fund(uint256 amount, uint256 duration) external onlyOwner onlyOnline {\n        // validate duration\n        require(duration != 0, ""Hypervisor: invalid duration"");\n\n        // create new reward shares\n        // if existing rewards on this Hypervisor\n        //   mint new shares proportional to % change in rewards remaining\n        //   newShares = remainingShares * newReward / remainingRewards\n        // else\n        //   mint new shares with BASE_SHARES_PER_WEI initial conversion rate\n        //   store as fixed point number with same  of decimals as reward token\n        uint256 newRewardShares;\n        if (_hypervisor.rewardSharesOutstanding &gt; 0) {\n            uint256 remainingRewards = IERC20(_hypervisor.rewardToken).balanceOf(_hypervisor.rewardPool);\n            newRewardShares = _hypervisor.rewardSharesOutstanding.mul(amount).div(remainingRewards);\n        } else {\n            newRewardShares = amount.mul(BASE_SHARES_PER_WEI);\n        }\n\n        // add reward shares to total\n        _hypervisor.rewardSharesOutstanding = _hypervisor.rewardSharesOutstanding.add(newRewardShares);\n\n        // store new reward schedule\n        _hypervisor.rewardSchedules.push(RewardSchedule(duration, block.timestamp, newRewardShares));\n\n        // transfer reward tokens to reward pool\n        TransferHelper.safeTransferFrom(\n            _hypervisor.rewardToken,\n            msg.sender,\n            _hypervisor.rewardPool,\n            amount\n        );\n\n        // emit event\n        emit HypervisorFunded(amount, duration);\n    }\n\n    /// @notice Add vault factory to whitelist\n    /// @dev use this function to enable stakes to vaults coming from the specified\n    ///      factory contract\n    /// access control: only admin\n    /// state machine:\n    ///   - can be called multiple times\n    ///   - not shutdown\n    /// state scope:\n    ///   - append to _vaultFactorySet\n    /// token transfer: none\n    /// @param factory address The address of the vault factory\n    function registerVaultFactory(address factory) external onlyOwner notShutdown {\n        // add factory to set\n        require(_vaultFactorySet.add(factory), ""Hypervisor: vault factory already registered"");\n\n        // emit event\n        emit VaultFactoryRegistered(factory);\n    }\n\n    /// @notice Remove vault factory from whitelist\n    /// @dev use this function to disable new stakes to vaults coming from the specified\n    ///      factory contract.\n    ///      note: vaults with existing stakes from this factory are sill able to unstake\n    /// access control: only admin\n    /// state machine:\n    ///   - can be called multiple times\n    ///   - not shutdown\n    /// state scope:\n    ///   - remove from _vaultFactorySet\n    /// token transfer: none\n    /// @param factory address The address of the vault factory\n    function removeVaultFactory(address factory) external onlyOwner notShutdown {\n        // remove factory from set\n        require(_vaultFactorySet.remove(factory), ""Hypervisor: vault factory not registered"");\n\n        // emit event\n        emit VaultFactoryRemoved(factory);\n    }\n\n    /// @notice Register bonus token for distribution\n    /// @dev use this function to enable distribution of any ERC20 held by the RewardPool contract\n    /// access control: only admin\n    /// state machine:\n    ///   - can be called multiple times\n    ///   - only online\n    /// state scope:\n    ///   - append to _bonusTokenSet\n    /// token transfer: none\n    /// @param bonusToken address The address of the bonus token\n    function registerBonusToken(address bonusToken) external onlyOwner onlyOnline {\n        // verify valid bonus token\n        _validateAddress(bonusToken);\n\n        // verify bonus token count\n        require(_bonusTokenSet.length() &lt; MAX_REWARD_TOKENS, ""Hypervisor: max bonus tokens reached "");\n\n        // add token to set\n        assert(_bonusTokenSet.add(bonusToken));\n\n        // emit event\n        emit BonusTokenRegistered(bonusToken);\n    }\n\n    /// @notice Rescue tokens from RewardPool\n    /// @dev use this function to rescue tokens from RewardPool contract\n    ///      without distributing to stakers or triggering emergency shutdown\n    /// access control: only admin\n    /// state machine:\n    ///   - can be called multiple times\n    ///   - only online\n    /// state scope: none\n    /// token transfer: transfer requested token from RewardPool to recipient\n    /// @param token address The address of the token to rescue\n    /// @param recipient address The address of the recipient\n    /// @param amount uint256 The amount of tokens to rescue\n    function rescueTokensFromRewardPool(\n        address token,\n        address recipient,\n        uint256 amount\n    ) external onlyOwner onlyOnline {\n        // verify recipient\n        _validateAddress(recipient);\n\n        // check not attempting to unstake reward token\n        require(token != _hypervisor.rewardToken, ""Hypervisor: invalid address"");\n\n        // check not attempting to wthdraw bonus token\n        require(!_bonusTokenSet.contains(token), ""Hypervisor: invalid address"");\n\n        // transfer tokens to recipient\n        IRewardPool(_hypervisor.rewardPool).sendERC20(token, recipient, amount);\n    }\n\n    / user functions /\n\n    /// @notice Stake tokens\n    /// @dev anyone can stake to any vault if they have valid permission\n    /// access control: anyone\n    /// state machine:\n    ///   - can be called multiple times\n    ///   - only online\n    ///   - when vault exists on this Hypervisor\n    /// state scope:\n    ///   - append to _vaults[vault].stakes\n    ///   - increase _vaults[vault].totalStake\n    ///   - increase _hypervisor.totalStake\n    ///   - increase _hypervisor.totalStakeUnits\n    ///   - increase _hypervisor.lastUpdate\n    /// token transfer: transfer staking tokens from msg.sender to vault\n    /// @param vault address The address of the vault to stake from\n    /// @param amount uint256 The amount of staking tokens to stake\n    function stake(\n        address vault,\n        uint256 amount,\n        bytes calldata permission\n    ) external override onlyOnline {\n        // verify vault is valid\n        require(isValidVault(vault), ""Hypervisor: vault is not registered"");\n\n        // verify non-zero amount\n        require(amount != 0, ""Hypervisor: no amount staked"");\n\n        // fetch vault storage reference\n        VaultData storage vaultData = _vaults[vault];\n\n        // verify stakes boundary not reached\n        require(\n            vaultData.stakes.length &lt; MAX_STAKES_PER_VAULT,\n            ""Hypervisor: MAX_STAKES_PER_VAULT reached""\n        );\n\n        // update cached sum of stake units across all vaults\n        _updateTotalStakeUnits();\n\n        // store amount and timestamp\n        vaultData.stakes.push(StakeData(amount, block.timestamp));\n\n        // update cached total vault and Hypervisor amounts\n        vaultData.totalStake = vaultData.totalStake.add(amount);\n        // verify stake quantity without bounds\n        require(\n            stakeLimit == 0 || vaultData.totalStake &lt;= stakeLimit,\n            ""Hypervisor: Stake limit exceeded""\n        );\n        _hypervisor.totalStake = _hypervisor.totalStake.add(amount);\n\n        // call lock on vault\n        IUniversalVault(vault).lock(_hypervisor.stakingToken, amount, permission);\n\n        // emit event\n        emit Staked(vault, amount);\n    }\n\n    /// @notice Unstake staking tokens and claim reward\n    /// @dev rewards can only be claimed when unstaking\n    /// access control: only owner of vault\n    /// state machine:\n    ///   - when vault exists on this Hypervisor\n    ///   - after stake from vault\n    ///   - can be called multiple times while sufficient stake remains\n    ///   - only online\n    /// state scope:\n    ///   - decrease _hypervisor.rewardSharesOutstanding\n    ///   - decrease _hypervisor.totalStake\n    ///   - increase _hypervisor.lastUpdate\n    ///   - modify _hypervisor.totalStakeUnits\n    ///   - modify _vaults[vault].stakes\n    ///   - decrease _vaults[vault].totalStake\n    /// token transfer:\n    ///   - transfer reward tokens from reward pool to recipient\n    ///   - transfer bonus tokens from reward pool to recipient\n    /// @param vault address The vault to unstake from\n    /// @param amount uint256 The amount of staking tokens to unstake\n    function unstakeAndClaim(\n        address vault,\n        uint256 amount,\n        bytes calldata permission\n    ) external override onlyOnline {\n        // fetch vault storage reference\n        VaultData storage vaultData = _vaults[vault];\n\n        // verify non-zero amount\n        require(amount != 0, ""Hypervisor: no amount unstaked"");\n\n        address recipient = IUniversalVault(vault).owner();\n\n        // validate recipient\n        _validateAddress(recipient);\n\n        // check for sufficient vault stake amount\n        require(vaultData.totalStake &gt;= amount, ""Hypervisor: insufficient vault stake"");\n\n        // check for sufficient Hypervisor stake amount\n        // if this check fails, there is a bug in stake accounting\n        assert(_hypervisor.totalStake &gt;= amount);\n\n        // update cached sum of stake units across all vaults\n        _updateTotalStakeUnits();\n\n        // get reward amount remaining\n        uint256 remainingRewards = IERC20(_hypervisor.rewardToken).balanceOf(_hypervisor.rewardPool);\n\n        // calculate vested portion of reward pool\n        uint256 unlockedRewards =\n            calculateUnlockedRewards(\n                _hypervisor.rewardSchedules,\n                remainingRewards,\n                _hypervisor.rewardSharesOutstanding,\n                block.timestamp\n            );\n\n        // calculate vault time weighted reward with scaling\n        RewardOutput memory out =\n            calculateRewardFromStakes(\n                vaultData.stakes,\n                amount,\n                unlockedRewards,\n                _hypervisor.totalStakeUnits,\n                block.timestamp,\n                _hypervisor.rewardScaling\n            );\n\n        // update stake data in storage\n        if (out.newStakesCount == 0) {\n            // all stakes have been unstaked\n            delete vaultData.stakes;\n        } else {\n            // some stakes have been completely or partially unstaked\n            // delete fully unstaked stakes\n            while (vaultData.stakes.length &gt; out.newStakesCount) vaultData.stakes.pop();\n            // update partially unstaked stake\n            vaultData.stakes[out.newStakesCount.sub(1)].amount = out.lastStakeAmount;\n        }\n\n        // update cached stake totals\n        vaultData.totalStake = vaultData.totalStake.sub(amount);\n        _hypervisor.totalStake = _hypervisor.totalStake.sub(amount);\n        _hypervisor.totalStakeUnits = out.newTotalStakeUnits;\n\n        // unlock staking tokens from vault\n        IUniversalVault(vault).unlock(_hypervisor.stakingToken, amount, permission);\n\n        // emit event\n        emit Unstaked(vault, amount);\n\n        // only perform on non-zero reward\n        if (out.reward &gt; 0) {\n            // calculate shares to burn\n            // sharesToBurn = sharesOutstanding * reward / remainingRewards\n            uint256 sharesToBurn =\n                _hypervisor.rewardSharesOutstanding.mul(out.reward).div(remainingRewards);\n\n            // burn claimed shares\n            _hypervisor.rewardSharesOutstanding = _hypervisor.rewardSharesOutstanding.sub(sharesToBurn);\n\n            // transfer bonus tokens from reward pool to recipient\n            if (_bonusTokenSet.length() &gt; 0) {\n                for (uint256 index = 0; index &lt; _bonusTokenSet.length(); index++) {\n                    // fetch bonus token address reference\n                    address bonusToken = _bonusTokenSet.at(index);\n\n                    // calculate bonus token amount\n                    // bonusAmount = bonusRemaining * reward / remainingRewards\n                    uint256 bonusAmount =\n                        IERC20(bonusToken).balanceOf(_hypervisor.rewardPool).mul(out.reward).div(\n                            remainingRewards\n                        );\n\n                    // transfer bonus token\n                    IRewardPool(_hypervisor.rewardPool).sendERC20(bonusToken, recipient, bonusAmount);\n\n                    // emit event\n                    emit RewardClaimed(vault, recipient, bonusToken, bonusAmount);\n                }\n            }\n\n            // transfer reward tokens from reward pool to recipient\n            IRewardPool(_hypervisor.rewardPool).sendERC20(_hypervisor.rewardToken, recipient, out.reward);\n\n            // emit event\n            emit RewardClaimed(vault, recipient, _hypervisor.rewardToken, out.reward);\n        }\n    }\n\n    /// @notice Exit Hypervisor without claiming reward\n    /// @dev This function should never revert when correctly called by the vault.\n    ///      A max number of stakes per vault is set with MAX_STAKES_PER_VAULT to\n    ///      place an upper bound on the for loop in calculateTotalStakeUnits().\n    /// access control: only callable by the vault directly\n    /// state machine:\n    ///   - when vault exists on this Hypervisor\n    ///   - when active stake from this vault\n    ///   - any power state\n    /// state scope:\n    ///   - decrease _hypervisor.totalStake\n    ///   - increase _hypervisor.lastUpdate\n    ///   - modify _hypervisor.totalStakeUnits\n    ///   - delete _vaults[vault]\n    /// token transfer: none\n    function rageQuit() external override {\n        // fetch vault storage reference\n        VaultData storage _vaultData = _vaults[msg.sender];\n\n        // revert if no active stakes\n        require(_vaultData.stakes.length != 0, ""Hypervisor: no stake"");\n\n        // update cached sum of stake units across all vaults\n        _updateTotalStakeUnits();\n\n        // emit event\n        emit Unstaked(msg.sender, _vaultData.totalStake);\n\n        // update cached totals\n        _hypervisor.totalStake = _hypervisor.totalStake.sub(_vaultData.totalStake);\n        _hypervisor.totalStakeUnits = _hypervisor.totalStakeUnits.sub(\n            calculateTotalStakeUnits(_vaultData.stakes, block.timestamp)\n        );\n\n        // delete stake data\n        delete _vaults[msg.sender];\n    }\n\n    / convenience functions /\n\n    function _updateTotalStakeUnits() private {\n        // update cached totalStakeUnits\n        _hypervisor.totalStakeUnits = getCurrentTotalStakeUnits();\n        // update cached lastUpdate\n        _hypervisor.lastUpdate = block.timestamp;\n    }\n\n    function _validateAddress(address target) private view {\n        // sanity check target for potential input errors\n        require(isValidAddress(target), ""Hypervisor: invalid address"");\n    }\n\n    function _truncateStakesArray(StakeData[] memory array, uint256 newLength)\n        private\n        pure\n        returns (StakeData[] memory newArray)\n    {\n        newArray = new StakeData;\n        for (uint256 index = 0; index &lt; newLength; index++) {\n            newArray[index] = array[index];\n        }\n        return newArray;\n    }\n}\n', 'ideas': "" Redundant Conditional Check Identified.\n``\nREDUNDANT CONDITIONAL CHECK\n'''\nIn theisValidAddressfunction, the check fortarget != address(this)is redundant because the function is already designed to validate addresses that are not the contract itself. Additionally, the check fortarget != address(0)` is also redundant as it is""} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-02-08 00:44:51 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **task_prompt** | // SPDX-License-Identifier: GPL-3.0-only pragma solidity 0.7.6; pragma abicoder v2; import {SafeMath} from ""@openzeppelin/contracts/math/SafeMath.sol""; import {EnumerableSet} from ""@openzeppelin/contracts/utils/EnumerableSet.sol""; import {IERC20} from ""@openzeppelin/contracts/token/ERC20/IERC20.sol""; import {Ownable} from ""@openzeppelin/contracts/access/Ownable.sol""; import {TransferHelper} from ""@uniswap/lib/contracts/libraries/TransferHelper.sol""; import {IFactory} from ""../factory/IFactory.sol""; import {IInstanceRegistry} from ""../factory/InstanceRegistry.sol""; import {IUniversalVault} from ""../visor/Visor.sol""; import {IRewardPool} from ""./RewardPool.sol""; import {Powered} from ""./Powered.sol""; interface IRageQuit {     function rageQuit() external; } interface IHypervisor is IRageQuit {     / admin events / event HypervisorCreated(address rewardPool, address powerSwitch); event HypervisorFunded(uint256 amount, uint256 duration); event BonusTokenRegistered(address token); event VaultFactoryRegistered(address factory); event VaultFactoryRemoved(address factory);  /* user events */  event Staked(address vault, uint256 amount); event Unstaked(address vault, uint256 amount); event RewardClaimed(address vault, address recipient, address token, uint256 amount);  /* data types */  struct HypervisorData {     address stakingToken;     address rewardToken;     address rewardPool;     RewardScaling rewardScaling;     uint256 rewardSharesOutstanding;     uint256 totalStake;     uint256 totalStakeUnits;     uint256 lastUpdate;     RewardSchedule[] rewardSchedules; }  struct RewardSchedule {     uint256 duration;     uint256 start;     uint256 shares; }  struct VaultData {     uint256 totalStake;     StakeData[] stakes; }  struct StakeData {     uint256 amount;     uint256 timestamp; }  struct RewardScaling {     uint256 floor;     uint256 ceiling;     uint256 time; }  struct RewardOutput {     uint256 lastStakeAmount;     uint256 newStakesCount;     uint256 reward;     uint256 newTotalStakeUnits; }  /* user functions */  function stake(     address vault,     uint256 amount,     bytes calldata permission ) external;  function unstakeAndClaim(     address vault,     uint256 amount,     bytes calldata permission ) external;  /* getter functions */  function getHypervisorData() external view returns (HypervisorData memory hypervisor);  function getBonusTokenSetLength() external view returns (uint256 length);  function getBonusTokenAtIndex(uint256 index) external view returns (address bonusToken);  function getVaultFactorySetLength() external view returns (uint256 length);  function getVaultFactoryAtIndex(uint256 index) external view returns (address factory);  function getVaultData(address vault) external view returns (VaultData memory vaultData);  function isValidAddress(address target) external view returns (bool validity);  function isValidVault(address target) external view returns (bool validity);  function getCurrentUnlockedRewards() external view returns (uint256 unlockedRewards);  function getFutureUnlockedRewards(uint256 timestamp)     external     view     returns (uint256 unlockedRewards);  function getCurrentVaultReward(address vault) external view returns (uint256 reward);  function getCurrentStakeReward(address vault, uint256 stakeAmount)     external     view     returns (uint256 reward);  function getFutureVaultReward(address vault, uint256 timestamp)     external     view     returns (uint256 reward);  function getFutureStakeReward(     address vault,     uint256 stakeAmount,     uint256 timestamp ) external view returns (uint256 reward);  function getCurrentVaultStakeUnits(address vault) external view returns (uint256 stakeUnits);  function getFutureVaultStakeUnits(address vault, uint256 timestamp)     external     view     returns (uint256 stakeUnits);  function getCurrentTotalStakeUnits() external view returns (uint256 totalStakeUnits);  function getFutureTotalStakeUnits(uint256 timestamp)     external     view     returns (uint256 totalStakeUnits);  /* pure functions */  function calculateTotalStakeUnits(StakeData[] memory stakes, uint256 timestamp)     external     pure     returns (uint256 totalStakeUnits);  function calculateStakeUnits(     uint256 amount,     uint256 start,     uint256 end ) external pure returns (uint256 stakeUnits);  function calculateUnlockedRewards(     RewardSchedule[] memory rewardSchedules,     uint256 rewardBalance,     uint256 sharesOutstanding,     uint256 timestamp ) external pure returns (uint256 unlockedRewards);  function calculateRewardFromStakes(     StakeData[] memory stakes,     uint256 unstakeAmount,     uint256 unlockedRewards,     uint256 totalStakeUnits,     uint256 timestamp,     RewardScaling memory rewardScaling ) external pure returns (RewardOutput memory out);  function calculateReward(     uint256 unlockedRewards,     uint256 stakeAmount,     uint256 stakeDuration,     uint256 totalStakeUnits,     RewardScaling memory rewardScaling ) external pure returns (uint256 reward);  } /// @title Hypervisor /// @notice Reward distribution contract with time multiplier /// Access Control /// - Power controller: ///     Can power off / shutdown the Hypervisor ///     Can withdraw rewards from reward pool once shutdown /// - Proxy owner: ///     Can change arbitrary logic / state by upgrading the Hypervisor ///     Is unable to operate on user funds due to UniversalVault ///     Is unable to operate on reward pool funds when reward pool is offline / shutdown /// - Hypervisor admin: ///     Can add funds to the Hypervisor, register bonus tokens, and whitelist new vault factories ///     Is a subset of proxy owner permissions /// - User: ///     Can deposit / withdraw / ragequit /// Hypervisor State Machine /// - Online: ///     Hypervisor is operating normally, all functions are enabled /// - Offline: ///     Hypervisor is temporarely disabled for maintenance ///     User deposits and withdrawls are disabled, ragequit remains enabled ///     Users can withdraw their stake through rageQuit() but forego their pending reward ///     Should only be used when downtime required for an upgrade /// - Shutdown: ///     Hypervisor is permanently disabled ///     All functions are disabled with the exception of ragequit ///     Users can withdraw their stake through rageQuit() ///     Power controller can withdraw from the reward pool ///     Should only be used if Proxy Owner role is compromized contract Hypervisor is IHypervisor, Powered, Ownable {     using SafeMath for uint256;     using EnumerableSet for EnumerableSet.AddressSet; /* constants */  // An upper bound on the number of active stakes per vault is required to prevent // calls to rageQuit() from reverting. // With 30 stakes in a vault, ragequit costs 432811 gas which is conservatively lower // than the hardcoded limit of 500k gas on the vault. // This limit is configurable and could be increased in a future deployment. // Ultimately, to avoid a need for fixed upper bounds, the EVM would need to provide // an error code that allows for reliably catching out-of-gas errors on remote calls. uint256 public constant MAX_STAKES_PER_VAULT = 30; uint256 public constant MAX_REWARD_TOKENS = 50; uint256 public constant BASE_SHARES_PER_WEI = 1000000; uint256 public stakeLimit = 2500 ether;  /* storage */  HypervisorData private _hypervisor; mapping(address =&gt; VaultData) private _vaults; EnumerableSet.AddressSet private _bonusTokenSet; EnumerableSet.AddressSet private _vaultFactorySet;  /* initializer */  /// @notice Initizalize Hypervisor /// access control: only proxy constructor /// state machine: can only be called once /// state scope: set initialization variables /// token transfer: none /// @param ownerAddress address The admin address /// @param rewardPoolFactory address The factory to use for deploying the RewardPool /// @param powerSwitchFactory address The factory to use for deploying the PowerSwitch /// @param stakingToken address The address of the staking token for this Hypervisor /// @param rewardToken address The address of the reward token for this Hypervisor /// @param rewardScaling RewardScaling The config for reward scaling floor, ceiling, and time constructor(     address ownerAddress,     address rewardPoolFactory,     address powerSwitchFactory,     address stakingToken,     address rewardToken,     RewardScaling memory rewardScaling,     uint256 _stakeLimit ) {     // the scaling floor must be smaller than ceiling     require(rewardScaling.floor &lt;= rewardScaling.ceiling, ""Hypervisor: floor above ceiling"");      // setting rewardScalingTime to 0 would cause divide by zero error     // to disable reward scaling, use rewardScalingFloor == rewardScalingCeiling     require(rewardScaling.time != 0, ""Hypervisor: scaling time cannot be zero"");      // deploy power switch     address powerSwitch = IFactory(powerSwitchFactory).create(abi.encode(ownerAddress));      // deploy reward pool     address rewardPool = IFactory(rewardPoolFactory).create(abi.encode(powerSwitch));      // set internal configs     Ownable.transferOwnership(ownerAddress);     Powered._setPowerSwitch(powerSwitch);      // commit to storage     _hypervisor.stakingToken = stakingToken;     _hypervisor.rewardToken = rewardToken;     _hypervisor.rewardPool = rewardPool;     _hypervisor.rewardScaling = rewardScaling;      stakeLimit = _stakeLimit;      // emit event     emit HypervisorCreated(rewardPool, powerSwitch); }  /* getter functions */  function getBonusTokenSetLength() external view override returns (uint256 length) {     return _bonusTokenSet.length(); }  function getBonusTokenAtIndex(uint256 index)     external     view     override     returns (address bonusToken) {     return _bonusTokenSet.at(index); }  function getVaultFactorySetLength() external view override returns (uint256 length) {     return _vaultFactorySet.length(); }  function getVaultFactoryAtIndex(uint256 index)     external     view     override     returns (address factory) {     return _vaultFactorySet.at(index); }  function isValidVault(address target) public view override returns (bool validity) {     // validate target is created from whitelisted vault factory     for (uint256 index = 0; index &lt; _vaultFactorySet.length(); index++) {         if (IInstanceRegistry(_vaultFactorySet.at(index)).isInstance(target)) {             return true;         }     }     // explicit return     return false; }  function isValidAddress(address target) public view override returns (bool validity) {     // sanity check target for potential input errors     return         target != address(this) &amp;&amp;         target != address(0) &amp;&amp;         target != _hypervisor.stakingToken &amp;&amp;         target != _hypervisor.rewardToken &amp;&amp;         target != _hypervisor.rewardPool &amp;&amp;         !_bonusTokenSet.contains(target); }  /* Hypervisor getters */  function getHypervisorData() external view override returns (HypervisorData memory hypervisor) {     return _hypervisor; }  function getCurrentUnlockedRewards() public view override returns (uint256 unlockedRewards) {     // calculate reward available based on state     return getFutureUnlockedRewards(block.timestamp); }  function getFutureUnlockedRewards(uint256 timestamp)     public     view     override     returns (uint256 unlockedRewards) {     // get reward amount remaining     uint256 remainingRewards = IERC20(_hypervisor.rewardToken).balanceOf(_hypervisor.rewardPool);     // calculate reward available based on state     unlockedRewards = calculateUnlockedRewards(         _hypervisor.rewardSchedules,         remainingRewards,         _hypervisor.rewardSharesOutstanding,         timestamp     );     // explicit return     return unlockedRewards; }  function getCurrentTotalStakeUnits() public view override returns (uint256 totalStakeUnits) {     // calculate new stake units     return getFutureTotalStakeUnits(block.timestamp); }  function getFutureTotalStakeUnits(uint256 timestamp)     public     view     override     returns (uint256 totalStakeUnits) {     // return early if no change     if (timestamp == _hypervisor.lastUpdate) return _hypervisor.totalStakeUnits;     // calculate new stake units     uint256 newStakeUnits =         calculateStakeUnits(_hypervisor.totalStake, _hypervisor.lastUpdate, timestamp);     // add to cached total     totalStakeUnits = _hypervisor.totalStakeUnits.add(newStakeUnits);     // explicit return     return totalStakeUnits; }  /* vault getters */  function getVaultData(address vault)     external     view     override     returns (VaultData memory vaultData) {     return _vaults[vault]; }  function getCurrentVaultReward(address vault) external view override returns (uint256 reward) {     // calculate rewards     return         calculateRewardFromStakes(             _vaults[vault]                 .stakes,             _vaults[vault]                 .totalStake,             getCurrentUnlockedRewards(),             getCurrentTotalStakeUnits(),             block                 .timestamp,             _hypervisor                 .rewardScaling         )             .reward; }  function getFutureVaultReward(address vault, uint256 timestamp)     external     view     override     returns (uint256 reward) {     // calculate rewards     return         calculateRewardFromStakes(             _vaults[vault]                 .stakes,             _vaults[vault]                 .totalStake,             getFutureUnlockedRewards(timestamp),             getFutureTotalStakeUnits(timestamp),             timestamp,             _hypervisor                 .rewardScaling         )             .reward; }  function getCurrentStakeReward(address vault, uint256 stakeAmount)     external     view     override     returns (uint256 reward) {     // calculate rewards     return         calculateRewardFromStakes(             _vaults[vault]                 .stakes,             stakeAmount,             getCurrentUnlockedRewards(),             getCurrentTotalStakeUnits(),             block                 .timestamp,             _hypervisor                 .rewardScaling         )             .reward; }  function getFutureStakeReward(     address vault,     uint256 stakeAmount,     uint256 timestamp ) external view override returns (uint256 reward) {     // calculate rewards     return         calculateRewardFromStakes(             _vaults[vault]                 .stakes,             stakeAmount,             getFutureUnlockedRewards(timestamp),             getFutureTotalStakeUnits(timestamp),             timestamp,             _hypervisor                 .rewardScaling         )             .reward; }  function getCurrentVaultStakeUnits(address vault)     public     view     override     returns (uint256 stakeUnits) {     // calculate stake units     return getFutureVaultStakeUnits(vault, block.timestamp); }  function getFutureVaultStakeUnits(address vault, uint256 timestamp)     public     view     override     returns (uint256 stakeUnits) {     // calculate stake units     return calculateTotalStakeUnits(_vaults[vault].stakes, timestamp); }  /* pure functions */  function calculateTotalStakeUnits(StakeData[] memory stakes, uint256 timestamp)     public     pure     override     returns (uint256 totalStakeUnits) {     for (uint256 index; index &lt; stakes.length; index++) {         // reference stake         StakeData memory stakeData = stakes[index];         // calculate stake units         uint256 stakeUnits =             calculateStakeUnits(stakeData.amount, stakeData.timestamp, timestamp);         // add to running total         totalStakeUnits = totalStakeUnits.add(stakeUnits);     } }  function calculateStakeUnits(     uint256 amount,     uint256 start,     uint256 end ) public pure override returns (uint256 stakeUnits) {     // calculate duration     uint256 duration = end.sub(start);     // calculate stake units     stakeUnits = duration.mul(amount);     // explicit return     return stakeUnits; }  function calculateUnlockedRewards(     RewardSchedule[] memory rewardSchedules,     uint256 rewardBalance,     uint256 sharesOutstanding,     uint256 timestamp ) public pure override returns (uint256 unlockedRewards) {     // return 0 if no registered schedules     if (rewardSchedules.length == 0) {         return 0;     }      // calculate reward shares locked across all reward schedules     uint256 sharesLocked;     for (uint256 index = 0; index &lt; rewardSchedules.length; index++) {         // fetch reward schedule storage reference         RewardSchedule memory schedule = rewardSchedules[index];          // caculate amount of shares available on this schedule         // if (now - start) &lt; duration         //   sharesLocked = shares - (shares * (now - start) / duration)         // else         //   sharesLocked = 0         uint256 currentSharesLocked = 0;         if (timestamp.sub(schedule.start) &lt; schedule.duration) {             currentSharesLocked = schedule.shares.sub(                 schedule.shares.mul(timestamp.sub(schedule.start)).div(schedule.duration)             );         }          // add to running total         sharesLocked = sharesLocked.add(currentSharesLocked);     }      // convert shares to reward     // rewardLocked = sharesLocked * rewardBalance / sharesOutstanding     uint256 rewardLocked = sharesLocked.mul(rewardBalance).div(sharesOutstanding);      // calculate amount available     // unlockedRewards = rewardBalance - rewardLocked     unlockedRewards = rewardBalance.sub(rewardLocked);      // explicit return     return unlockedRewards; }  function calculateRewardFromStakes(     StakeData[] memory stakes,     uint256 unstakeAmount,     uint256 unlockedRewards,     uint256 totalStakeUnits,     uint256 timestamp,     RewardScaling memory rewardScaling ) public pure override returns (RewardOutput memory out) {     uint256 stakesToDrop = 0;     while (unstakeAmount &gt; 0) {         // fetch vault stake storage reference         StakeData memory lastStake = stakes[stakes.length.sub(stakesToDrop).sub(1)];          // calculate stake duration         uint256 stakeDuration = timestamp.sub(lastStake.timestamp);          uint256 currentAmount;         if (lastStake.amount &gt; unstakeAmount) {             // set current amount to remaining unstake amount             currentAmount = unstakeAmount;             // amount of last stake is reduced             out.lastStakeAmount = lastStake.amount.sub(unstakeAmount);         } else {             // set current amount to amount of last stake             currentAmount = lastStake.amount;             // add to stakes to drop             stakesToDrop += 1;         }          // update remaining unstakeAmount         unstakeAmount = unstakeAmount.sub(currentAmount);          // calculate reward amount         uint256 currentReward =             calculateReward(                 unlockedRewards,                 currentAmount,                 stakeDuration,                 totalStakeUnits,                 rewardScaling             );          // update cumulative reward         out.reward = out.reward.add(currentReward);          // update cached unlockedRewards         unlockedRewards = unlockedRewards.sub(currentReward);          // calculate time weighted stake         uint256 stakeUnits = currentAmount.mul(stakeDuration);          // update cached totalStakeUnits         totalStakeUnits = totalStakeUnits.sub(stakeUnits);     }      // explicit return     return         RewardOutput(             out.lastStakeAmount,             stakes.length.sub(stakesToDrop),             out.reward,             totalStakeUnits         ); }  function calculateReward(     uint256 unlockedRewards,     uint256 stakeAmount,     uint256 stakeDuration,     uint256 totalStakeUnits,     RewardScaling memory rewardScaling ) public pure override returns (uint256 reward) {     // calculate time weighted stake     uint256 stakeUnits = stakeAmount.mul(stakeDuration);      // calculate base reward     // baseReward = unlockedRewards * stakeUnits / totalStakeUnits     uint256 baseReward = 0;     if (totalStakeUnits != 0) {         // scale reward according to proportional weight         baseReward = unlockedRewards.mul(stakeUnits).div(totalStakeUnits);     }      // calculate scaled reward     // if no scaling or scaling period completed     //   reward = baseReward     // else     //   minReward = baseReward * scalingFloor / scalingCeiling     //   bonusReward = baseReward     //                 * (scalingCeiling - scalingFloor) / scalingCeiling     //                 * duration / scalingTime     //   reward = minReward + bonusReward     if (stakeDuration &gt;= rewardScaling.time || rewardScaling.floor == rewardScaling.ceiling) {         // no reward scaling applied         reward = baseReward;     } else {         // calculate minimum reward using scaling floor         uint256 minReward = baseReward.mul(rewardScaling.floor).div(rewardScaling.ceiling);          // calculate bonus reward with vested portion of scaling factor         uint256 bonusReward =             baseReward                 .mul(stakeDuration)                 .mul(rewardScaling.ceiling.sub(rewardScaling.floor))                 .div(rewardScaling.ceiling)                 .div(rewardScaling.time);          // add minimum reward and bonus reward         reward = minReward.add(bonusReward);     }      // explicit return     return reward; }  /* admin functions */  /// @notice Add funds to the Hypervisor /// access control: only admin /// state machine: ///   - can be called multiple times ///   - only online /// state scope: ///   - increase _hypervisor.rewardSharesOutstanding ///   - append to _hypervisor.rewardSchedules /// token transfer: transfer staking tokens from msg.sender to reward pool /// @param amount uint256 Amount of reward tokens to deposit /// @param duration uint256 Duration over which to linearly unlock rewards function fund(uint256 amount, uint256 duration) external onlyOwner onlyOnline {     // validate duration     require(duration != 0, ""Hypervisor: invalid duration"");      // create new reward shares     // if existing rewards on this Hypervisor     //   mint new shares proportional to % change in rewards remaining     //   newShares = remainingShares * newReward / remainingRewards     // else     //   mint new shares with BASE_SHARES_PER_WEI initial conversion rate     //   store as fixed point number with same  of decimals as reward token     uint256 newRewardShares;     if (_hypervisor.rewardSharesOutstanding &gt; 0) {         uint256 remainingRewards = IERC20(_hypervisor.rewardToken).balanceOf(_hypervisor.rewardPool);         newRewardShares = _hypervisor.rewardSharesOutstanding.mul(amount).div(remainingRewards);     } else {         newRewardShares = amount.mul(BASE_SHARES_PER_WEI);     }      // add reward shares to total     _hypervisor.rewardSharesOutstanding = _hypervisor.rewardSharesOutstanding.add(newRewardShares);      // store new reward schedule     _hypervisor.rewardSchedules.push(RewardSchedule(duration, block.timestamp, newRewardShares));      // transfer reward tokens to reward pool     TransferHelper.safeTransferFrom(         _hypervisor.rewardToken,         msg.sender,         _hypervisor.rewardPool,         amount     );      // emit event     emit HypervisorFunded(amount, duration); }  /// @notice Add vault factory to whitelist /// @dev use this function to enable stakes to vaults coming from the specified ///      factory contract /// access control: only admin /// state machine: ///   - can be called multiple times ///   - not shutdown /// state scope: ///   - append to _vaultFactorySet /// token transfer: none /// @param factory address The address of the vault factory function registerVaultFactory(address factory) external onlyOwner notShutdown {     // add factory to set     require(_vaultFactorySet.add(factory), ""Hypervisor: vault factory already registered"");      // emit event     emit VaultFactoryRegistered(factory); }  /// @notice Remove vault factory from whitelist /// @dev use this function to disable new stakes to vaults coming from the specified ///      factory contract. ///      note: vaults with existing stakes from this factory are sill able to unstake /// access control: only admin /// state machine: ///   - can be called multiple times ///   - not shutdown /// state scope: ///   - remove from _vaultFactorySet /// token transfer: none /// @param factory address The address of the vault factory function removeVaultFactory(address factory) external onlyOwner notShutdown {     // remove factory from set     require(_vaultFactorySet.remove(factory), ""Hypervisor: vault factory not registered"");      // emit event     emit VaultFactoryRemoved(factory); }  /// @notice Register bonus token for distribution /// @dev use this function to enable distribution of any ERC20 held by the RewardPool contract /// access control: only admin /// state machine: ///   - can be called multiple times ///   - only online /// state scope: ///   - append to _bonusTokenSet /// token transfer: none /// @param bonusToken address The address of the bonus token function registerBonusToken(address bonusToken) external onlyOwner onlyOnline {     // verify valid bonus token     _validateAddress(bonusToken);      // verify bonus token count     require(_bonusTokenSet.length() &lt; MAX_REWARD_TOKENS, ""Hypervisor: max bonus tokens reached "");      // add token to set     assert(_bonusTokenSet.add(bonusToken));      // emit event     emit BonusTokenRegistered(bonusToken); }  /// @notice Rescue tokens from RewardPool /// @dev use this function to rescue tokens from RewardPool contract ///      without distributing to stakers or triggering emergency shutdown /// access control: only admin /// state machine: ///   - can be called multiple times ///   - only online /// state scope: none /// token transfer: transfer requested token from RewardPool to recipient /// @param token address The address of the token to rescue /// @param recipient address The address of the recipient /// @param amount uint256 The amount of tokens to rescue function rescueTokensFromRewardPool(     address token,     address recipient,     uint256 amount ) external onlyOwner onlyOnline {     // verify recipient     _validateAddress(recipient);      // check not attempting to unstake reward token     require(token != _hypervisor.rewardToken, ""Hypervisor: invalid address"");      // check not attempting to wthdraw bonus token     require(!_bonusTokenSet.contains(token), ""Hypervisor: invalid address"");      // transfer tokens to recipient     IRewardPool(_hypervisor.rewardPool).sendERC20(token, recipient, amount); }  /* user functions */  /// @notice Stake tokens /// @dev anyone can stake to any vault if they have valid permission /// access control: anyone /// state machine: ///   - can be called multiple times ///   - only online ///   - when vault exists on this Hypervisor /// state scope: ///   - append to _vaults[vault].stakes ///   - increase _vaults[vault].totalStake ///   - increase _hypervisor.totalStake ///   - increase _hypervisor.totalStakeUnits ///   - increase _hypervisor.lastUpdate /// token transfer: transfer staking tokens from msg.sender to vault /// @param vault address The address of the vault to stake from /// @param amount uint256 The amount of staking tokens to stake function stake(     address vault,     uint256 amount,     bytes calldata permission ) external override onlyOnline {     // verify vault is valid     require(isValidVault(vault), ""Hypervisor: vault is not registered"");      // verify non-zero amount     require(amount != 0, ""Hypervisor: no amount staked"");      // fetch vault storage reference     VaultData storage vaultData = _vaults[vault];      // verify stakes boundary not reached     require(         vaultData.stakes.length &lt; MAX_STAKES_PER_VAULT,         ""Hypervisor: MAX_STAKES_PER_VAULT reached""     );      // update cached sum of stake units across all vaults     _updateTotalStakeUnits();      // store amount and timestamp     vaultData.stakes.push(StakeData(amount, block.timestamp));      // update cached total vault and Hypervisor amounts     vaultData.totalStake = vaultData.totalStake.add(amount);     // verify stake quantity without bounds     require(         stakeLimit == 0 || vaultData.totalStake &lt;= stakeLimit,         ""Hypervisor: Stake limit exceeded""     );     _hypervisor.totalStake = _hypervisor.totalStake.add(amount);      // call lock on vault     IUniversalVault(vault).lock(_hypervisor.stakingToken, amount, permission);      // emit event     emit Staked(vault, amount); }  /// @notice Unstake staking tokens and claim reward /// @dev rewards can only be claimed when unstaking /// access control: only owner of vault /// state machine: ///   - when vault exists on this Hypervisor ///   - after stake from vault ///   - can be called multiple times while sufficient stake remains ///   - only online /// state scope: ///   - decrease _hypervisor.rewardSharesOutstanding ///   - decrease _hypervisor.totalStake ///   - increase _hypervisor.lastUpdate ///   - modify _hypervisor.totalStakeUnits ///   - modify _vaults[vault].stakes ///   - decrease _vaults[vault].totalStake /// token transfer: ///   - transfer reward tokens from reward pool to recipient ///   - transfer bonus tokens from reward pool to recipient /// @param vault address The vault to unstake from /// @param amount uint256 The amount of staking tokens to unstake function unstakeAndClaim(     address vault,     uint256 amount,     bytes calldata permission ) external override onlyOnline {     // fetch vault storage reference     VaultData storage vaultData = _vaults[vault];      // verify non-zero amount     require(amount != 0, ""Hypervisor: no amount unstaked"");      address recipient = IUniversalVault(vault).owner();      // validate recipient     _validateAddress(recipient);      // check for sufficient vault stake amount     require(vaultData.totalStake &gt;= amount, ""Hypervisor: insufficient vault stake"");      // check for sufficient Hypervisor stake amount     // if this check fails, there is a bug in stake accounting     assert(_hypervisor.totalStake &gt;= amount);      // update cached sum of stake units across all vaults     _updateTotalStakeUnits();      // get reward amount remaining     uint256 remainingRewards = IERC20(_hypervisor.rewardToken).balanceOf(_hypervisor.rewardPool);      // calculate vested portion of reward pool     uint256 unlockedRewards =         calculateUnlockedRewards(             _hypervisor.rewardSchedules,             remainingRewards,             _hypervisor.rewardSharesOutstanding,             block.timestamp         );      // calculate vault time weighted reward with scaling     RewardOutput memory out =         calculateRewardFromStakes(             vaultData.stakes,             amount,             unlockedRewards,             _hypervisor.totalStakeUnits,             block.timestamp,             _hypervisor.rewardScaling         );      // update stake data in storage     if (out.newStakesCount == 0) {         // all stakes have been unstaked         delete vaultData.stakes;     } else {         // some stakes have been completely or partially unstaked         // delete fully unstaked stakes         while (vaultData.stakes.length &gt; out.newStakesCount) vaultData.stakes.pop();         // update partially unstaked stake         vaultData.stakes[out.newStakesCount.sub(1)].amount = out.lastStakeAmount;     }      // update cached stake totals     vaultData.totalStake = vaultData.totalStake.sub(amount);     _hypervisor.totalStake = _hypervisor.totalStake.sub(amount);     _hypervisor.totalStakeUnits = out.newTotalStakeUnits;      // unlock staking tokens from vault     IUniversalVault(vault).unlock(_hypervisor.stakingToken, amount, permission);      // emit event     emit Unstaked(vault, amount);      // only perform on non-zero reward     if (out.reward &gt; 0) {         // calculate shares to burn         // sharesToBurn = sharesOutstanding * reward / remainingRewards         uint256 sharesToBurn =             _hypervisor.rewardSharesOutstanding.mul(out.reward).div(remainingRewards);          // burn claimed shares         _hypervisor.rewardSharesOutstanding = _hypervisor.rewardSharesOutstanding.sub(sharesToBurn);          // transfer bonus tokens from reward pool to recipient         if (_bonusTokenSet.length() &gt; 0) {             for (uint256 index = 0; index &lt; _bonusTokenSet.length(); index++) {                 // fetch bonus token address reference                 address bonusToken = _bonusTokenSet.at(index);                  // calculate bonus token amount                 // bonusAmount = bonusRemaining * reward / remainingRewards                 uint256 bonusAmount =                     IERC20(bonusToken).balanceOf(_hypervisor.rewardPool).mul(out.reward).div(                         remainingRewards                     );                  // transfer bonus token                 IRewardPool(_hypervisor.rewardPool).sendERC20(bonusToken, recipient, bonusAmount);                  // emit event                 emit RewardClaimed(vault, recipient, bonusToken, bonusAmount);             }         }          // transfer reward tokens from reward pool to recipient         IRewardPool(_hypervisor.rewardPool).sendERC20(_hypervisor.rewardToken, recipient, out.reward);          // emit event         emit RewardClaimed(vault, recipient, _hypervisor.rewardToken, out.reward);     } }  /// @notice Exit Hypervisor without claiming reward /// @dev This function should never revert when correctly called by the vault. ///      A max number of stakes per vault is set with MAX_STAKES_PER_VAULT to ///      place an upper bound on the for loop in calculateTotalStakeUnits(). /// access control: only callable by the vault directly /// state machine: ///   - when vault exists on this Hypervisor ///   - when active stake from this vault ///   - any power state /// state scope: ///   - decrease _hypervisor.totalStake ///   - increase _hypervisor.lastUpdate ///   - modify _hypervisor.totalStakeUnits ///   - delete _vaults[vault] /// token transfer: none function rageQuit() external override {     // fetch vault storage reference     VaultData storage _vaultData = _vaults[msg.sender];      // revert if no active stakes     require(_vaultData.stakes.length != 0, ""Hypervisor: no stake"");      // update cached sum of stake units across all vaults     _updateTotalStakeUnits();      // emit event     emit Unstaked(msg.sender, _vaultData.totalStake);      // update cached totals     _hypervisor.totalStake = _hypervisor.totalStake.sub(_vaultData.totalStake);     _hypervisor.totalStakeUnits = _hypervisor.totalStakeUnits.sub(         calculateTotalStakeUnits(_vaultData.stakes, block.timestamp)     );      // delete stake data     delete _vaults[msg.sender]; }  /* convenience functions */  function _updateTotalStakeUnits() private {     // update cached totalStakeUnits     _hypervisor.totalStakeUnits = getCurrentTotalStakeUnits();     // update cached lastUpdate     _hypervisor.lastUpdate = block.timestamp; }  function _validateAddress(address target) private view {     // sanity check target for potential input errors     require(isValidAddress(target), ""Hypervisor: invalid address""); }  function _truncateStakesArray(StakeData[] memory array, uint256 newLength)     private     pure     returns (StakeData[] memory newArray) {     newArray = new StakeData[](newLength);     for (uint256 index = 0; index &lt; newLength; index++) {         newArray[index] = array[index];     }     return newArray; }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-02-08 00:44:51 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: GPL-3.0-only
pragma solidity 0.7.6;
pragma abicoder v2;

import {SafeMath} from ""@openzeppelin/contracts/math/SafeMath.sol"";
import {EnumerableSet} from ""@openzeppelin/contracts/utils/EnumerableSet.sol"";
import {IERC20} from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import {Ownable} from ""@openzeppelin/contracts/access/Ownable.sol"";
import {TransferHelper} from ""@uniswap/lib/contracts/libraries/TransferHelper.sol"";

import {IFactory} from ""../factory/IFactory.sol"";
import {IInstanceRegistry} from ""../factory/InstanceRegistry.sol"";
import {IUniversalVault} from ""../visor/Visor.sol"";
import {IRewardPool} from ""./RewardPool.sol"";
import {Powered} from ""./Powered.sol"";

interface IRageQuit {
    function rageQuit() external;
}

interface IHypervisor is IRageQuit {
    /* admin events */

    event HypervisorCreated(address rewardPool, address powerSwitch);
    event HypervisorFunded(uint256 amount, uint256 duration);
    event BonusTokenRegistered(address token);
    event VaultFactoryRegistered(address factory);
    event VaultFactoryRemoved(address factory);

    /* user events */

    event Staked(address vault, uint256 amount);
    event Unstaked(address vault, uint256 amount);
    event RewardClaimed(address vault, address recipient, address token, uint256 amount);

    /* data types */

    struct HypervisorData {
        address stakingToken;
        address rewardToken;
        address rewardPool;
        RewardScaling rewardScaling;
        uint256 rewardSharesOutstanding;
        uint256 totalStake;
        uint256 totalStakeUnits;
        uint256 lastUpdate;
        RewardSchedule[] rewardSchedules;
    }

    struct RewardSchedule {
        uint256 duration;
        uint256 start;
        uint256 shares;
    }

    struct VaultData {
        uint256 totalStake;
        StakeData[] stakes;
    }

    struct StakeData {
        uint256 amount;
        uint256 timestamp;
    }

    struct RewardScaling {
        uint256 floor;
        uint256 ceiling;
        uint256 time;
    }

    struct RewardOutput {
        uint256 lastStakeAmount;
        uint256 newStakesCount;
        uint256 reward;
        uint256 newTotalStakeUnits;
    }

    /* user functions */

    function stake(
        address vault,
        uint256 amount,
        bytes calldata permission
    ) external;

    function unstakeAndClaim(
        address vault,
        uint256 amount,
        bytes calldata permission
    ) external;

    /* getter functions */

    function getHypervisorData() external view returns (HypervisorData memory hypervisor);

    function getBonusTokenSetLength() external view returns (uint256 length);

    function getBonusTokenAtIndex(uint256 index) external view returns (address bonusToken);

    function getVaultFactorySetLength() external view returns (uint256 length);

    function getVaultFactoryAtIndex(uint256 index) external view returns (address factory);

    function getVaultData(address vault) external view returns (VaultData memory vaultData);

    function isValidAddress(address target) external view returns (bool validity);

    function isValidVault(address target) external view returns (bool validity);

    function getCurrentUnlockedRewards() external view returns (uint256 unlockedRewards);

    function getFutureUnlockedRewards(uint256 timestamp)
        external
        view
        returns (uint256 unlockedRewards);

    function getCurrentVaultReward(address vault) external view returns (uint256 reward);

    function getCurrentStakeReward(address vault, uint256 stakeAmount)
        external
        view
        returns (uint256 reward);

    function getFutureVaultReward(address vault, uint256 timestamp)
        external
        view
        returns (uint256 reward);

    function getFutureStakeReward(
        address vault,
        uint256 stakeAmount,
        uint256 timestamp
    ) external view returns (uint256 reward);

    function getCurrentVaultStakeUnits(address vault) external view returns (uint256 stakeUnits);

    function getFutureVaultStakeUnits(address vault, uint256 timestamp)
        external
        view
        returns (uint256 stakeUnits);

    function getCurrentTotalStakeUnits() external view returns (uint256 totalStakeUnits);

    function getFutureTotalStakeUnits(uint256 timestamp)
        external
        view
        returns (uint256 totalStakeUnits);

    /* pure functions */

    function calculateTotalStakeUnits(StakeData[] memory stakes, uint256 timestamp)
        external
        pure
        returns (uint256 totalStakeUnits);

    function calculateStakeUnits(
        uint256 amount,
        uint256 start,
        uint256 end
    ) external pure returns (uint256 stakeUnits);

    function calculateUnlockedRewards(
        RewardSchedule[] memory rewardSchedules,
        uint256 rewardBalance,
        uint256 sharesOutstanding,
        uint256 timestamp
    ) external pure returns (uint256 unlockedRewards);

    function calculateRewardFromStakes(
        StakeData[] memory stakes,
        uint256 unstakeAmount,
        uint256 unlockedRewards,
        uint256 totalStakeUnits,
        uint256 timestamp,
        RewardScaling memory rewardScaling
    ) external pure returns (RewardOutput memory out);

    function calculateReward(
        uint256 unlockedRewards,
        uint256 stakeAmount,
        uint256 stakeDuration,
        uint256 totalStakeUnits,
        RewardScaling memory rewardScaling
    ) external pure returns (uint256 reward);
}

/// @title Hypervisor
/// @notice Reward distribution contract with time multiplier
/// Access Control
/// - Power controller:
///     Can power off / shutdown the Hypervisor
///     Can withdraw rewards from reward pool once shutdown
/// - Proxy owner:
///     Can change arbitrary logic / state by upgrading the Hypervisor
///     Is unable to operate on user funds due to UniversalVault
///     Is unable to operate on reward pool funds when reward pool is offline / shutdown
/// - Hypervisor admin:
///     Can add funds to the Hypervisor, register bonus tokens, and whitelist new vault factories
///     Is a subset of proxy owner permissions
/// - User:
///     Can deposit / withdraw / ragequit
/// Hypervisor State Machine
/// - Online:
///     Hypervisor is operating normally, all functions are enabled
/// - Offline:
///     Hypervisor is temporarely disabled for maintenance
///     User deposits and withdrawls are disabled, ragequit remains enabled
///     Users can withdraw their stake through rageQuit() but forego their pending reward
///     Should only be used when downtime required for an upgrade
/// - Shutdown:
///     Hypervisor is permanently disabled
///     All functions are disabled with the exception of ragequit
///     Users can withdraw their stake through rageQuit()
///     Power controller can withdraw from the reward pool
///     Should only be used if Proxy Owner role is compromized
contract Hypervisor is IHypervisor, Powered, Ownable {
    using SafeMath for uint256;
    using EnumerableSet for EnumerableSet.AddressSet;

    /* constants */

    // An upper bound on the number of active stakes per vault is required to prevent
    // calls to rageQuit() from reverting.
    // With 30 stakes in a vault, ragequit costs 432811 gas which is conservatively lower
    // than the hardcoded limit of 500k gas on the vault.
    // This limit is configurable and could be increased in a future deployment.
    // Ultimately, to avoid a need for fixed upper bounds, the EVM would need to provide
    // an error code that allows for reliably catching out-of-gas errors on remote calls.
    uint256 public constant MAX_STAKES_PER_VAULT = 30;
    uint256 public constant MAX_REWARD_TOKENS = 50;
    uint256 public constant BASE_SHARES_PER_WEI = 1000000;
    uint256 public stakeLimit = 2500 ether;

    /* storage */

    HypervisorData private _hypervisor;
    mapping(address => VaultData) private _vaults;
    EnumerableSet.AddressSet private _bonusTokenSet;
    EnumerableSet.AddressSet private _vaultFactorySet;

    /* initializer */

    /// @notice Initizalize Hypervisor
    /// access control: only proxy constructor
    /// state machine: can only be called once
    /// state scope: set initialization variables
    /// token transfer: none
    /// @param ownerAddress address The admin address
    /// @param rewardPoolFactory address The factory to use for deploying the RewardPool
    /// @param powerSwitchFactory address The factory to use for deploying the PowerSwitch
    /// @param stakingToken address The address of the staking token for this Hypervisor
    /// @param rewardToken address The address of the reward token for this Hypervisor
    /// @param rewardScaling RewardScaling The config for reward scaling floor, ceiling, and time
    constructor(
        address ownerAddress,
        address rewardPoolFactory,
        address powerSwitchFactory,
        address stakingToken,
        address rewardToken,
        RewardScaling memory rewardScaling,
        uint256 _stakeLimit
    ) {
        // the scaling floor must be smaller than ceiling
        require(rewardScaling.floor <= rewardScaling.ceiling, ""Hypervisor: floor above ceiling"");

        // setting rewardScalingTime to 0 would cause divide by zero error
        // to disable reward scaling, use rewardScalingFloor == rewardScalingCeiling
        require(rewardScaling.time != 0, ""Hypervisor: scaling time cannot be zero"");

        // deploy power switch
        address powerSwitch = IFactory(powerSwitchFactory).create(abi.encode(ownerAddress));

        // deploy reward pool
        address rewardPool = IFactory(rewardPoolFactory).create(abi.encode(powerSwitch));

        // set internal configs
        Ownable.transferOwnership(ownerAddress);
        Powered._setPowerSwitch(powerSwitch);

        // commit to storage
        _hypervisor.stakingToken = stakingToken;
        _hypervisor.rewardToken = rewardToken;
        _hypervisor.rewardPool = rewardPool;
        _hypervisor.rewardScaling = rewardScaling;

        stakeLimit = _stakeLimit;

        // emit event
        emit HypervisorCreated(rewardPool, powerSwitch);
    }

    /* getter functions */

    function getBonusTokenSetLength() external view override returns (uint256 length) {
        return _bonusTokenSet.length();
    }

    function getBonusTokenAtIndex(uint256 index)
        external
        view
        override
        returns (address bonusToken)
    {
        return _bonusTokenSet.at(index);
    }

    function getVaultFactorySetLength() external view override returns (uint256 length) {
        return _vaultFactorySet.length();
    }

    function getVaultFactoryAtIndex(uint256 index)
        external
        view
        override
        returns (address factory)
    {
        return _vaultFactorySet.at(index);
    }

    function isValidVault(address target) public view override returns (bool validity) {
        // validate target is created from whitelisted vault factory
        for (uint256 index = 0; index < _vaultFactorySet.length(); index++) {
            if (IInstanceRegistry(_vaultFactorySet.at(index)).isInstance(target)) {
                return true;
            }
        }
        // explicit return
        return false;
    }

    function isValidAddress(address target) public view override returns (bool validity) {
        // sanity check target for potential input errors
        return
            target != address(this) &&
            target != address(0) &&
            target != _hypervisor.stakingToken &&
            target != _hypervisor.rewardToken &&
            target != _hypervisor.rewardPool &&
            !_bonusTokenSet.contains(target);
    }

    /* Hypervisor getters */

    function getHypervisorData() external view override returns (HypervisorData memory hypervisor) {
        return _hypervisor;
    }

    function getCurrentUnlockedRewards() public view override returns (uint256 unlockedRewards) {
        // calculate reward available based on state
        return getFutureUnlockedRewards(block.timestamp);
    }

    function getFutureUnlockedRewards(uint256 timestamp)
        public
        view
        override
        returns (uint256 unlockedRewards)
    {
        // get reward amount remaining
        uint256 remainingRewards = IERC20(_hypervisor.rewardToken).balanceOf(_hypervisor.rewardPool);
        // calculate reward available based on state
        unlockedRewards = calculateUnlockedRewards(
            _hypervisor.rewardSchedules,
            remainingRewards,
            _hypervisor.rewardSharesOutstanding,
            timestamp
        );
        // explicit return
        return unlockedRewards;
    }

    function getCurrentTotalStakeUnits() public view override returns (uint256 totalStakeUnits) {
        // calculate new stake units
        return getFutureTotalStakeUnits(block.timestamp);
    }

    function getFutureTotalStakeUnits(uint256 timestamp)
        public
        view
        override
        returns (uint256 totalStakeUnits)
    {
        // return early if no change
        if (timestamp == _hypervisor.lastUpdate) return _hypervisor.totalStakeUnits;
        // calculate new stake units
        uint256 newStakeUnits =
            calculateStakeUnits(_hypervisor.totalStake, _hypervisor.lastUpdate, timestamp);
        // add to cached total
        totalStakeUnits = _hypervisor.totalStakeUnits.add(newStakeUnits);
        // explicit return
        return totalStakeUnits;
    }

    /* vault getters */

    function getVaultData(address vault)
        external
        view
        override
        returns (VaultData memory vaultData)
    {
        return _vaults[vault];
    }

    function getCurrentVaultReward(address vault) external view override returns (uint256 reward) {
        // calculate rewards
        return
            calculateRewardFromStakes(
                _vaults[vault]
                    .stakes,
                _vaults[vault]
                    .totalStake,
                getCurrentUnlockedRewards(),
                getCurrentTotalStakeUnits(),
                block
                    .timestamp,
                _hypervisor
                    .rewardScaling
            )
                .reward;
    }

    function getFutureVaultReward(address vault, uint256 timestamp)
        external
        view
        override
        returns (uint256 reward)
    {
        // calculate rewards
        return
            calculateRewardFromStakes(
                _vaults[vault]
                    .stakes,
                _vaults[vault]
                    .totalStake,
                getFutureUnlockedRewards(timestamp),
                getFutureTotalStakeUnits(timestamp),
                timestamp,
                _hypervisor
                    .rewardScaling
            )
                .reward;
    }

    function getCurrentStakeReward(address vault, uint256 stakeAmount)
        external
        view
        override
        returns (uint256 reward)
    {
        // calculate rewards
        return
            calculateRewardFromStakes(
                _vaults[vault]
                    .stakes,
                stakeAmount,
                getCurrentUnlockedRewards(),
                getCurrentTotalStakeUnits(),
                block
                    .timestamp,
                _hypervisor
                    .rewardScaling
            )
                .reward;
    }

    function getFutureStakeReward(
        address vault,
        uint256 stakeAmount,
        uint256 timestamp
    ) external view override returns (uint256 reward) {
        // calculate rewards
        return
            calculateRewardFromStakes(
                _vaults[vault]
                    .stakes,
                stakeAmount,
                getFutureUnlockedRewards(timestamp),
                getFutureTotalStakeUnits(timestamp),
                timestamp,
                _hypervisor
                    .rewardScaling
            )
                .reward;
    }

    function getCurrentVaultStakeUnits(address vault)
        public
        view
        override
        returns (uint256 stakeUnits)
    {
        // calculate stake units
        return getFutureVaultStakeUnits(vault, block.timestamp);
    }

    function getFutureVaultStakeUnits(address vault, uint256 timestamp)
        public
        view
        override
        returns (uint256 stakeUnits)
    {
        // calculate stake units
        return calculateTotalStakeUnits(_vaults[vault].stakes, timestamp);
    }

    /* pure functions */

    function calculateTotalStakeUnits(StakeData[] memory stakes, uint256 timestamp)
        public
        pure
        override
        returns (uint256 totalStakeUnits)
    {
        for (uint256 index; index < stakes.length; index++) {
            // reference stake
            StakeData memory stakeData = stakes[index];
            // calculate stake units
            uint256 stakeUnits =
                calculateStakeUnits(stakeData.amount, stakeData.timestamp, timestamp);
            // add to running total
            totalStakeUnits = totalStakeUnits.add(stakeUnits);
        }
    }

    function calculateStakeUnits(
        uint256 amount,
        uint256 start,
        uint256 end
    ) public pure override returns (uint256 stakeUnits) {
        // calculate duration
        uint256 duration = end.sub(start);
        // calculate stake units
        stakeUnits = duration.mul(amount);
        // explicit return
        return stakeUnits;
    }

    function calculateUnlockedRewards(
        RewardSchedule[] memory rewardSchedules,
        uint256 rewardBalance,
        uint256 sharesOutstanding,
        uint256 timestamp
    ) public pure override returns (uint256 unlockedRewards) {
        // return 0 if no registered schedules
        if (rewardSchedules.length == 0) {
            return 0;
        }

        // calculate reward shares locked across all reward schedules
        uint256 sharesLocked;
        for (uint256 index = 0; index < rewardSchedules.length; index++) {
            // fetch reward schedule storage reference
            RewardSchedule memory schedule = rewardSchedules[index];

            // caculate amount of shares available on this schedule
            // if (now - start) < duration
            //   sharesLocked = shares - (shares * (now - start) / duration)
            // else
            //   sharesLocked = 0
            uint256 currentSharesLocked = 0;
            if (timestamp.sub(schedule.start) < schedule.duration) {
                currentSharesLocked = schedule.shares.sub(
                    schedule.shares.mul(timestamp.sub(schedule.start)).div(schedule.duration)
                );
            }

            // add to running total
            sharesLocked = sharesLocked.add(currentSharesLocked);
        }

        // convert shares to reward
        // rewardLocked = sharesLocked * rewardBalance / sharesOutstanding
        uint256 rewardLocked = sharesLocked.mul(rewardBalance).div(sharesOutstanding);

        // calculate amount available
        // unlockedRewards = rewardBalance - rewardLocked
        unlockedRewards = rewardBalance.sub(rewardLocked);

        // explicit return
        return unlockedRewards;
    }

    function calculateRewardFromStakes(
        StakeData[] memory stakes,
        uint256 unstakeAmount,
        uint256 unlockedRewards,
        uint256 totalStakeUnits,
        uint256 timestamp,
        RewardScaling memory rewardScaling
    ) public pure override returns (RewardOutput memory out) {
        uint256 stakesToDrop = 0;
        while (unstakeAmount > 0) {
            // fetch vault stake storage reference
            StakeData memory lastStake = stakes[stakes.length.sub(stakesToDrop).sub(1)];

            // calculate stake duration
            uint256 stakeDuration = timestamp.sub(lastStake.timestamp);

            uint256 currentAmount;
            if (lastStake.amount > unstakeAmount) {
                // set current amount to remaining unstake amount
                currentAmount = unstakeAmount;
                // amount of last stake is reduced
                out.lastStakeAmount = lastStake.amount.sub(unstakeAmount);
            } else {
                // set current amount to amount of last stake
                currentAmount = lastStake.amount;
                // add to stakes to drop
                stakesToDrop += 1;
            }

            // update remaining unstakeAmount
            unstakeAmount = unstakeAmount.sub(currentAmount);

            // calculate reward amount
            uint256 currentReward =
                calculateReward(
                    unlockedRewards,
                    currentAmount,
                    stakeDuration,
                    totalStakeUnits,
                    rewardScaling
                );

            // update cumulative reward
            out.reward = out.reward.add(currentReward);

            // update cached unlockedRewards
            unlockedRewards = unlockedRewards.sub(currentReward);

            // calculate time weighted stake
            uint256 stakeUnits = currentAmount.mul(stakeDuration);

            // update cached totalStakeUnits
            totalStakeUnits = totalStakeUnits.sub(stakeUnits);
        }

        // explicit return
        return
            RewardOutput(
                out.lastStakeAmount,
                stakes.length.sub(stakesToDrop),
                out.reward,
                totalStakeUnits
            );
    }

    function calculateReward(
        uint256 unlockedRewards,
        uint256 stakeAmount,
        uint256 stakeDuration,
        uint256 totalStakeUnits,
        RewardScaling memory rewardScaling
    ) public pure override returns (uint256 reward) {
        // calculate time weighted stake
        uint256 stakeUnits = stakeAmount.mul(stakeDuration);

        // calculate base reward
        // baseReward = unlockedRewards * stakeUnits / totalStakeUnits
        uint256 baseReward = 0;
        if (totalStakeUnits != 0) {
            // scale reward according to proportional weight
            baseReward = unlockedRewards.mul(stakeUnits).div(totalStakeUnits);
        }

        // calculate scaled reward
        // if no scaling or scaling period completed
        //   reward = baseReward
        // else
        //   minReward = baseReward * scalingFloor / scalingCeiling
        //   bonusReward = baseReward
        //                 * (scalingCeiling - scalingFloor) / scalingCeiling
        //                 * duration / scalingTime
        //   reward = minReward + bonusReward
        if (stakeDuration >= rewardScaling.time || rewardScaling.floor == rewardScaling.ceiling) {
            // no reward scaling applied
            reward = baseReward;
        } else {
            // calculate minimum reward using scaling floor
            uint256 minReward = baseReward.mul(rewardScaling.floor).div(rewardScaling.ceiling);

            // calculate bonus reward with vested portion of scaling factor
            uint256 bonusReward =
                baseReward
                    .mul(stakeDuration)
                    .mul(rewardScaling.ceiling.sub(rewardScaling.floor))
                    .div(rewardScaling.ceiling)
                    .div(rewardScaling.time);

            // add minimum reward and bonus reward
            reward = minReward.add(bonusReward);
        }

        // explicit return
        return reward;
    }

    /* admin functions */

    /// @notice Add funds to the Hypervisor
    /// access control: only admin
    /// state machine:
    ///   - can be called multiple times
    ///   - only online
    /// state scope:
    ///   - increase _hypervisor.rewardSharesOutstanding
    ///   - append to _hypervisor.rewardSchedules
    /// token transfer: transfer staking tokens from msg.sender to reward pool
    /// @param amount uint256 Amount of reward tokens to deposit
    /// @param duration uint256 Duration over which to linearly unlock rewards
    function fund(uint256 amount, uint256 duration) external onlyOwner onlyOnline {
        // validate duration
        require(duration != 0, ""Hypervisor: invalid duration"");

        // create new reward shares
        // if existing rewards on this Hypervisor
        //   mint new shares proportional to % change in rewards remaining
        //   newShares = remainingShares * newReward / remainingRewards
        // else
        //   mint new shares with BASE_SHARES_PER_WEI initial conversion rate
        //   store as fixed point number with same  of decimals as reward token
        uint256 newRewardShares;
        if (_hypervisor.rewardSharesOutstanding > 0) {
            uint256 remainingRewards = IERC20(_hypervisor.rewardToken).balanceOf(_hypervisor.rewardPool);
            newRewardShares = _hypervisor.rewardSharesOutstanding.mul(amount).div(remainingRewards);
        } else {
            newRewardShares = amount.mul(BASE_SHARES_PER_WEI);
        }

        // add reward shares to total
        _hypervisor.rewardSharesOutstanding = _hypervisor.rewardSharesOutstanding.add(newRewardShares);

        // store new reward schedule
        _hypervisor.rewardSchedules.push(RewardSchedule(duration, block.timestamp, newRewardShares));

        // transfer reward tokens to reward pool
        TransferHelper.safeTransferFrom(
            _hypervisor.rewardToken,
            msg.sender,
            _hypervisor.rewardPool,
            amount
        );

        // emit event
        emit HypervisorFunded(amount, duration);
    }

    /// @notice Add vault factory to whitelist
    /// @dev use this function to enable stakes to vaults coming from the specified
    ///      factory contract
    /// access control: only admin
    /// state machine:
    ///   - can be called multiple times
    ///   - not shutdown
    /// state scope:
    ///   - append to _vaultFactorySet
    /// token transfer: none
    /// @param factory address The address of the vault factory
    function registerVaultFactory(address factory) external onlyOwner notShutdown {
        // add factory to set
        require(_vaultFactorySet.add(factory), ""Hypervisor: vault factory already registered"");

        // emit event
        emit VaultFactoryRegistered(factory);
    }

    /// @notice Remove vault factory from whitelist
    /// @dev use this function to disable new stakes to vaults coming from the specified
    ///      factory contract.
    ///      note: vaults with existing stakes from this factory are sill able to unstake
    /// access control: only admin
    /// state machine:
    ///   - can be called multiple times
    ///   - not shutdown
    /// state scope:
    ///   - remove from _vaultFactorySet
    /// token transfer: none
    /// @param factory address The address of the vault factory
    function removeVaultFactory(address factory) external onlyOwner notShutdown {
        // remove factory from set
        require(_vaultFactorySet.remove(factory), ""Hypervisor: vault factory not registered"");

        // emit event
        emit VaultFactoryRemoved(factory);
    }

    /// @notice Register bonus token for distribution
    /// @dev use this function to enable distribution of any ERC20 held by the RewardPool contract
    /// access control: only admin
    /// state machine:
    ///   - can be called multiple times
    ///   - only online
    /// state scope:
    ///   - append to _bonusTokenSet
    /// token transfer: none
    /// @param bonusToken address The address of the bonus token
    function registerBonusToken(address bonusToken) external onlyOwner onlyOnline {
        // verify valid bonus token
        _validateAddress(bonusToken);

        // verify bonus token count
        require(_bonusTokenSet.length() < MAX_REWARD_TOKENS, ""Hypervisor: max bonus tokens reached "");

        // add token to set
        assert(_bonusTokenSet.add(bonusToken));

        // emit event
        emit BonusTokenRegistered(bonusToken);
    }

    /// @notice Rescue tokens from RewardPool
    /// @dev use this function to rescue tokens from RewardPool contract
    ///      without distributing to stakers or triggering emergency shutdown
    /// access control: only admin
    /// state machine:
    ///   - can be called multiple times
    ///   - only online
    /// state scope: none
    /// token transfer: transfer requested token from RewardPool to recipient
    /// @param token address The address of the token to rescue
    /// @param recipient address The address of the recipient
    /// @param amount uint256 The amount of tokens to rescue
    function rescueTokensFromRewardPool(
        address token,
        address recipient,
        uint256 amount
    ) external onlyOwner onlyOnline {
        // verify recipient
        _validateAddress(recipient);

        // check not attempting to unstake reward token
        require(token != _hypervisor.rewardToken, ""Hypervisor: invalid address"");

        // check not attempting to wthdraw bonus token
        require(!_bonusTokenSet.contains(token), ""Hypervisor: invalid address"");

        // transfer tokens to recipient
        IRewardPool(_hypervisor.rewardPool).sendERC20(token, recipient, amount);
    }

    /* user functions */

    /// @notice Stake tokens
    /// @dev anyone can stake to any vault if they have valid permission
    /// access control: anyone
    /// state machine:
    ///   - can be called multiple times
    ///   - only online
    ///   - when vault exists on this Hypervisor
    /// state scope:
    ///   - append to _vaults[vault].stakes
    ///   - increase _vaults[vault].totalStake
    ///   - increase _hypervisor.totalStake
    ///   - increase _hypervisor.totalStakeUnits
    ///   - increase _hypervisor.lastUpdate
    /// token transfer: transfer staking tokens from msg.sender to vault
    /// @param vault address The address of the vault to stake from
    /// @param amount uint256 The amount of staking tokens to stake
    function stake(
        address vault,
        uint256 amount,
        bytes calldata permission
    ) external override onlyOnline {
        // verify vault is valid
        require(isValidVault(vault), ""Hypervisor: vault is not registered"");

        // verify non-zero amount
        require(amount != 0, ""Hypervisor: no amount staked"");

        // fetch vault storage reference
        VaultData storage vaultData = _vaults[vault];

        // verify stakes boundary not reached
        require(
            vaultData.stakes.length < MAX_STAKES_PER_VAULT,
            ""Hypervisor: MAX_STAKES_PER_VAULT reached""
        );

        // update cached sum of stake units across all vaults
        _updateTotalStakeUnits();

        // store amount and timestamp
        vaultData.stakes.push(StakeData(amount, block.timestamp));

        // update cached total vault and Hypervisor amounts
        vaultData.totalStake = vaultData.totalStake.add(amount);
        // verify stake quantity without bounds
        require(
            stakeLimit == 0 || vaultData.totalStake <= stakeLimit,
            ""Hypervisor: Stake limit exceeded""
        );
        _hypervisor.totalStake = _hypervisor.totalStake.add(amount);

        // call lock on vault
        IUniversalVault(vault).lock(_hypervisor.stakingToken, amount, permission);

        // emit event
        emit Staked(vault, amount);
    }

    /// @notice Unstake staking tokens and claim reward
    /// @dev rewards can only be claimed when unstaking
    /// access control: only owner of vault
    /// state machine:
    ///   - when vault exists on this Hypervisor
    ///   - after stake from vault
    ///   - can be called multiple times while sufficient stake remains
    ///   - only online
    /// state scope:
    ///   - decrease _hypervisor.rewardSharesOutstanding
    ///   - decrease _hypervisor.totalStake
    ///   - increase _hypervisor.lastUpdate
    ///   - modify _hypervisor.totalStakeUnits
    ///   - modify _vaults[vault].stakes
    ///   - decrease _vaults[vault].totalStake
    /// token transfer:
    ///   - transfer reward tokens from reward pool to recipient
    ///   - transfer bonus tokens from reward pool to recipient
    /// @param vault address The vault to unstake from
    /// @param amount uint256 The amount of staking tokens to unstake
    function unstakeAndClaim(
        address vault,
        uint256 amount,
        bytes calldata permission
    ) external override onlyOnline {
        // fetch vault storage reference
        VaultData storage vaultData = _vaults[vault];

        // verify non-zero amount
        require(amount != 0, ""Hypervisor: no amount unstaked"");

        address recipient = IUniversalVault(vault).owner();

        // validate recipient
        _validateAddress(recipient);

        // check for sufficient vault stake amount
        require(vaultData.totalStake >= amount, ""Hypervisor: insufficient vault stake"");

        // check for sufficient Hypervisor stake amount
        // if this check fails, there is a bug in stake accounting
        assert(_hypervisor.totalStake >= amount);

        // update cached sum of stake units across all vaults
        _updateTotalStakeUnits();

        // get reward amount remaining
        uint256 remainingRewards = IERC20(_hypervisor.rewardToken).balanceOf(_hypervisor.rewardPool);

        // calculate vested portion of reward pool
        uint256 unlockedRewards =
            calculateUnlockedRewards(
                _hypervisor.rewardSchedules,
                remainingRewards,
                _hypervisor.rewardSharesOutstanding,
                block.timestamp
            );

        // calculate vault time weighted reward with scaling
        RewardOutput memory out =
            calculateRewardFromStakes(
                vaultData.stakes,
                amount,
                unlockedRewards,
                _hypervisor.totalStakeUnits,
                block.timestamp,
                _hypervisor.rewardScaling
            );

        // update stake data in storage
        if (out.newStakesCount == 0) {
            // all stakes have been unstaked
            delete vaultData.stakes;
        } else {
            // some stakes have been completely or partially unstaked
            // delete fully unstaked stakes
            while (vaultData.stakes.length > out.newStakesCount) vaultData.stakes.pop();
            // update partially unstaked stake
            vaultData.stakes[out.newStakesCount.sub(1)].amount = out.lastStakeAmount;
        }

        // update cached stake totals
        vaultData.totalStake = vaultData.totalStake.sub(amount);
        _hypervisor.totalStake = _hypervisor.totalStake.sub(amount);
        _hypervisor.totalStakeUnits = out.newTotalStakeUnits;

        // unlock staking tokens from vault
        IUniversalVault(vault).unlock(_hypervisor.stakingToken, amount, permission);

        // emit event
        emit Unstaked(vault, amount);

        // only perform on non-zero reward
        if (out.reward > 0) {
            // calculate shares to burn
            // sharesToBurn = sharesOutstanding * reward / remainingRewards
            uint256 sharesToBurn =
                _hypervisor.rewardSharesOutstanding.mul(out.reward).div(remainingRewards);

            // burn claimed shares
            _hypervisor.rewardSharesOutstanding = _hypervisor.rewardSharesOutstanding.sub(sharesToBurn);

            // transfer bonus tokens from reward pool to recipient
            if (_bonusTokenSet.length() > 0) {
                for (uint256 index = 0; index < _bonusTokenSet.length(); index++) {
                    // fetch bonus token address reference
                    address bonusToken = _bonusTokenSet.at(index);

                    // calculate bonus token amount
                    // bonusAmount = bonusRemaining * reward / remainingRewards
                    uint256 bonusAmount =
                        IERC20(bonusToken).balanceOf(_hypervisor.rewardPool).mul(out.reward).div(
                            remainingRewards
                        );

                    // transfer bonus token
                    IRewardPool(_hypervisor.rewardPool).sendERC20(bonusToken, recipient, bonusAmount);

                    // emit event
                    emit RewardClaimed(vault, recipient, bonusToken, bonusAmount);
                }
            }

            // transfer reward tokens from reward pool to recipient
            IRewardPool(_hypervisor.rewardPool).sendERC20(_hypervisor.rewardToken, recipient, out.reward);

            // emit event
            emit RewardClaimed(vault, recipient, _hypervisor.rewardToken, out.reward);
        }
    }

    /// @notice Exit Hypervisor without claiming reward
    /// @dev This function should never revert when correctly called by the vault.
    ///      A max number of stakes per vault is set with MAX_STAKES_PER_VAULT to
    ///      place an upper bound on the for loop in calculateTotalStakeUnits().
    /// access control: only callable by the vault directly
    /// state machine:
    ///   - when vault exists on this Hypervisor
    ///   - when active stake from this vault
    ///   - any power state
    /// state scope:
    ///   - decrease _hypervisor.totalStake
    ///   - increase _hypervisor.lastUpdate
    ///   - modify _hypervisor.totalStakeUnits
    ///   - delete _vaults[vault]
    /// token transfer: none
    function rageQuit() external override {
        // fetch vault storage reference
        VaultData storage _vaultData = _vaults[msg.sender];

        // revert if no active stakes
        require(_vaultData.stakes.length != 0, ""Hypervisor: no stake"");

        // update cached sum of stake units across all vaults
        _updateTotalStakeUnits();

        // emit event
        emit Unstaked(msg.sender, _vaultData.totalStake);

        // update cached totals
        _hypervisor.totalStake = _hypervisor.totalStake.sub(_vaultData.totalStake);
        _hypervisor.totalStakeUnits = _hypervisor.totalStakeUnits.sub(
            calculateTotalStakeUnits(_vaultData.stakes, block.timestamp)
        );

        // delete stake data
        delete _vaults[msg.sender];
    }

    /* convenience functions */

    function _updateTotalStakeUnits() private {
        // update cached totalStakeUnits
        _hypervisor.totalStakeUnits = getCurrentTotalStakeUnits();
        // update cached lastUpdate
        _hypervisor.lastUpdate = block.timestamp;
    }

    function _validateAddress(address target) private view {
        // sanity check target for potential input errors
        require(isValidAddress(target), ""Hypervisor: invalid address"");
    }

    function _truncateStakesArray(StakeData[] memory array, uint256 newLength)
        private
        pure
        returns (StakeData[] memory newArray)
    {
        newArray = new StakeData[](newLength);
        for (uint256 index = 0; index < newLength; index++) {
            newArray[index] = array[index];
        }
        return newArray;
    }
}
.
To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs.]

Given the user's task and the brainstorming ideas provided:
Task: ""// SPDX-License-Identifier: GPL-3.0-only
pragma solidity 0.7.6;
pragma abicoder v2;

import {SafeMath} from ""@openzeppelin/contracts/math/SafeMath.sol"";
import {EnumerableSet} from ""@openzeppelin/contracts/utils/EnumerableSet.sol"";
import {IERC20} from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import {Ownable} from ""@openzeppelin/contracts/access/Ownable.sol"";
import {TransferHelper} from ""@uniswap/lib/contracts/libraries/TransferHelper.sol"";

import {IFactory} from ""../factory/IFactory.sol"";
import {IInstanceRegistry} from ""../factory/InstanceRegistry.sol"";
import {IUniversalVault} from ""../visor/Visor.sol"";
import {IRewardPool} from ""./RewardPool.sol"";
import {Powered} from ""./Powered.sol"";

interface IRageQuit {
    function rageQuit() external;
}

interface IHypervisor is IRageQuit {
    /* admin events */

    event HypervisorCreated(address rewardPool, address powerSwitch);
    event HypervisorFunded(uint256 amount, uint256 duration);
    event BonusTokenRegistered(address token);
    event VaultFactoryRegistered(address factory);
    event VaultFactoryRemoved(address factory);

    /* user events */

    event Staked(address vault, uint256 amount);
    event Unstaked(address vault, uint256 amount);
    event RewardClaimed(address vault, address recipient, address token, uint256 amount);

    /* data types */

    struct HypervisorData {
        address stakingToken;
        address rewardToken;
        address rewardPool;
        RewardScaling rewardScaling;
        uint256 rewardSharesOutstanding;
        uint256 totalStake;
        uint256 totalStakeUnits;
        uint256 lastUpdate;
        RewardSchedule[] rewardSchedules;
    }

    struct RewardSchedule {
        uint256 duration;
        uint256 start;
        uint256 shares;
    }

    struct VaultData {
        uint256 totalStake;
        StakeData[] stakes;
    }

    struct StakeData {
        uint256 amount;
        uint256 timestamp;
    }

    struct RewardScaling {
        uint256 floor;
        uint256 ceiling;
        uint256 time;
    }

    struct RewardOutput {
        uint256 lastStakeAmount;
        uint256 newStakesCount;
        uint256 reward;
        uint256 newTotalStakeUnits;
    }

    /* user functions */

    function stake(
        address vault,
        uint256 amount,
        bytes calldata permission
    ) external;

    function unstakeAndClaim(
        address vault,
        uint256 amount,
        bytes calldata permission
    ) external;

    /* getter functions */

    function getHypervisorData() external view returns (HypervisorData memory hypervisor);

    function getBonusTokenSetLength() external view returns (uint256 length);

    function getBonusTokenAtIndex(uint256 index) external view returns (address bonusToken);

    function getVaultFactorySetLength() external view returns (uint256 length);

    function getVaultFactoryAtIndex(uint256 index) external view returns (address factory);

    function getVaultData(address vault) external view returns (VaultData memory vaultData);

    function isValidAddress(address target) external view returns (bool validity);

    function isValidVault(address target) external view returns (bool validity);

    function getCurrentUnlockedRewards() external view returns (uint256 unlockedRewards);

    function getFutureUnlockedRewards(uint256 timestamp)
        external
        view
        returns (uint256 unlockedRewards);

    function getCurrentVaultReward(address vault) external view returns (uint256 reward);

    function getCurrentStakeReward(address vault, uint256 stakeAmount)
        external
        view
        returns (uint256 reward);

    function getFutureVaultReward(address vault, uint256 timestamp)
        external
        view
        returns (uint256 reward);

    function getFutureStakeReward(
        address vault,
        uint256 stakeAmount,
        uint256 timestamp
    ) external view returns (uint256 reward);

    function getCurrentVaultStakeUnits(address vault) external view returns (uint256 stakeUnits);

    function getFutureVaultStakeUnits(address vault, uint256 timestamp)
        external
        view
        returns (uint256 stakeUnits);

    function getCurrentTotalStakeUnits() external view returns (uint256 totalStakeUnits);

    function getFutureTotalStakeUnits(uint256 timestamp)
        external
        view
        returns (uint256 totalStakeUnits);

    /* pure functions */

    function calculateTotalStakeUnits(StakeData[] memory stakes, uint256 timestamp)
        external
        pure
        returns (uint256 totalStakeUnits);

    function calculateStakeUnits(
        uint256 amount,
        uint256 start,
        uint256 end
    ) external pure returns (uint256 stakeUnits);

    function calculateUnlockedRewards(
        RewardSchedule[] memory rewardSchedules,
        uint256 rewardBalance,
        uint256 sharesOutstanding,
        uint256 timestamp
    ) external pure returns (uint256 unlockedRewards);

    function calculateRewardFromStakes(
        StakeData[] memory stakes,
        uint256 unstakeAmount,
        uint256 unlockedRewards,
        uint256 totalStakeUnits,
        uint256 timestamp,
        RewardScaling memory rewardScaling
    ) external pure returns (RewardOutput memory out);

    function calculateReward(
        uint256 unlockedRewards,
        uint256 stakeAmount,
        uint256 stakeDuration,
        uint256 totalStakeUnits,
        RewardScaling memory rewardScaling
    ) external pure returns (uint256 reward);
}

/// @title Hypervisor
/// @notice Reward distribution contract with time multiplier
/// Access Control
/// - Power controller:
///     Can power off / shutdown the Hypervisor
///     Can withdraw rewards from reward pool once shutdown
/// - Proxy owner:
///     Can change arbitrary logic / state by upgrading the Hypervisor
///     Is unable to operate on user funds due to UniversalVault
///     Is unable to operate on reward pool funds when reward pool is offline / shutdown
/// - Hypervisor admin:
///     Can add funds to the Hypervisor, register bonus tokens, and whitelist new vault factories
///     Is a subset of proxy owner permissions
/// - User:
///     Can deposit / withdraw / ragequit
/// Hypervisor State Machine
/// - Online:
///     Hypervisor is operating normally, all functions are enabled
/// - Offline:
///     Hypervisor is temporarely disabled for maintenance
///     User deposits and withdrawls are disabled, ragequit remains enabled
///     Users can withdraw their stake through rageQuit() but forego their pending reward
///     Should only be used when downtime required for an upgrade
/// - Shutdown:
///     Hypervisor is permanently disabled
///     All functions are disabled with the exception of ragequit
///     Users can withdraw their stake through rageQuit()
///     Power controller can withdraw from the reward pool
///     Should only be used if Proxy Owner role is compromized
contract Hypervisor is IHypervisor, Powered, Ownable {
    using SafeMath for uint256;
    using EnumerableSet for EnumerableSet.AddressSet;

    /* constants */

    // An upper bound on the number of active stakes per vault is required to prevent
    // calls to rageQuit() from reverting.
    // With 30 stakes in a vault, ragequit costs 432811 gas which is conservatively lower
    // than the hardcoded limit of 500k gas on the vault.
    // This limit is configurable and could be increased in a future deployment.
    // Ultimately, to avoid a need for fixed upper bounds, the EVM would need to provide
    // an error code that allows for reliably catching out-of-gas errors on remote calls.
    uint256 public constant MAX_STAKES_PER_VAULT = 30;
    uint256 public constant MAX_REWARD_TOKENS = 50;
    uint256 public constant BASE_SHARES_PER_WEI = 1000000;
    uint256 public stakeLimit = 2500 ether;

    /* storage */

    HypervisorData private _hypervisor;
    mapping(address => VaultData) private _vaults;
    EnumerableSet.AddressSet private _bonusTokenSet;
    EnumerableSet.AddressSet private _vaultFactorySet;

    /* initializer */

    /// @notice Initizalize Hypervisor
    /// access control: only proxy constructor
    /// state machine: can only be called once
    /// state scope: set initialization variables
    /// token transfer: none
    /// @param ownerAddress address The admin address
    /// @param rewardPoolFactory address The factory to use for deploying the RewardPool
    /// @param powerSwitchFactory address The factory to use for deploying the PowerSwitch
    /// @param stakingToken address The address of the staking token for this Hypervisor
    /// @param rewardToken address The address of the reward token for this Hypervisor
    /// @param rewardScaling RewardScaling The config for reward scaling floor, ceiling, and time
    constructor(
        address ownerAddress,
        address rewardPoolFactory,
        address powerSwitchFactory,
        address stakingToken,
        address rewardToken,
        RewardScaling memory rewardScaling,
        uint256 _stakeLimit
    ) {
        // the scaling floor must be smaller than ceiling
        require(rewardScaling.floor <= rewardScaling.ceiling, ""Hypervisor: floor above ceiling"");

        // setting rewardScalingTime to 0 would cause divide by zero error
        // to disable reward scaling, use rewardScalingFloor == rewardScalingCeiling
        require(rewardScaling.time != 0, ""Hypervisor: scaling time cannot be zero"");

        // deploy power switch
        address powerSwitch = IFactory(powerSwitchFactory).create(abi.encode(ownerAddress));

        // deploy reward pool
        address rewardPool = IFactory(rewardPoolFactory).create(abi.encode(powerSwitch));

        // set internal configs
        Ownable.transferOwnership(ownerAddress);
        Powered._setPowerSwitch(powerSwitch);

        // commit to storage
        _hypervisor.stakingToken = stakingToken;
        _hypervisor.rewardToken = rewardToken;
        _hypervisor.rewardPool = rewardPool;
        _hypervisor.rewardScaling = rewardScaling;

        stakeLimit = _stakeLimit;

        // emit event
        emit HypervisorCreated(rewardPool, powerSwitch);
    }

    /* getter functions */

    function getBonusTokenSetLength() external view override returns (uint256 length) {
        return _bonusTokenSet.length();
    }

    function getBonusTokenAtIndex(uint256 index)
        external
        view
        override
        returns (address bonusToken)
    {
        return _bonusTokenSet.at(index);
    }

    function getVaultFactorySetLength() external view override returns (uint256 length) {
        return _vaultFactorySet.length();
    }

    function getVaultFactoryAtIndex(uint256 index)
        external
        view
        override
        returns (address factory)
    {
        return _vaultFactorySet.at(index);
    }

    function isValidVault(address target) public view override returns (bool validity) {
        // validate target is created from whitelisted vault factory
        for (uint256 index = 0; index < _vaultFactorySet.length(); index++) {
            if (IInstanceRegistry(_vaultFactorySet.at(index)).isInstance(target)) {
                return true;
            }
        }
        // explicit return
        return false;
    }

    function isValidAddress(address target) public view override returns (bool validity) {
        // sanity check target for potential input errors
        return
            target != address(this) &&
            target != address(0) &&
            target != _hypervisor.stakingToken &&
            target != _hypervisor.rewardToken &&
            target != _hypervisor.rewardPool &&
            !_bonusTokenSet.contains(target);
    }

    /* Hypervisor getters */

    function getHypervisorData() external view override returns (HypervisorData memory hypervisor) {
        return _hypervisor;
    }

    function getCurrentUnlockedRewards() public view override returns (uint256 unlockedRewards) {
        // calculate reward available based on state
        return getFutureUnlockedRewards(block.timestamp);
    }

    function getFutureUnlockedRewards(uint256 timestamp)
        public
        view
        override
        returns (uint256 unlockedRewards)
    {
        // get reward amount remaining
        uint256 remainingRewards = IERC20(_hypervisor.rewardToken).balanceOf(_hypervisor.rewardPool);
        // calculate reward available based on state
        unlockedRewards = calculateUnlockedRewards(
            _hypervisor.rewardSchedules,
            remainingRewards,
            _hypervisor.rewardSharesOutstanding,
            timestamp
        );
        // explicit return
        return unlockedRewards;
    }

    function getCurrentTotalStakeUnits() public view override returns (uint256 totalStakeUnits) {
        // calculate new stake units
        return getFutureTotalStakeUnits(block.timestamp);
    }

    function getFutureTotalStakeUnits(uint256 timestamp)
        public
        view
        override
        returns (uint256 totalStakeUnits)
    {
        // return early if no change
        if (timestamp == _hypervisor.lastUpdate) return _hypervisor.totalStakeUnits;
        // calculate new stake units
        uint256 newStakeUnits =
            calculateStakeUnits(_hypervisor.totalStake, _hypervisor.lastUpdate, timestamp);
        // add to cached total
        totalStakeUnits = _hypervisor.totalStakeUnits.add(newStakeUnits);
        // explicit return
        return totalStakeUnits;
    }

    /* vault getters */

    function getVaultData(address vault)
        external
        view
        override
        returns (VaultData memory vaultData)
    {
        return _vaults[vault];
    }

    function getCurrentVaultReward(address vault) external view override returns (uint256 reward) {
        // calculate rewards
        return
            calculateRewardFromStakes(
                _vaults[vault]
                    .stakes,
                _vaults[vault]
                    .totalStake,
                getCurrentUnlockedRewards(),
                getCurrentTotalStakeUnits(),
                block
                    .timestamp,
                _hypervisor
                    .rewardScaling
            )
                .reward;
    }

    function getFutureVaultReward(address vault, uint256 timestamp)
        external
        view
        override
        returns (uint256 reward)
    {
        // calculate rewards
        return
            calculateRewardFromStakes(
                _vaults[vault]
                    .stakes,
                _vaults[vault]
                    .totalStake,
                getFutureUnlockedRewards(timestamp),
                getFutureTotalStakeUnits(timestamp),
                timestamp,
                _hypervisor
                    .rewardScaling
            )
                .reward;
    }

    function getCurrentStakeReward(address vault, uint256 stakeAmount)
        external
        view
        override
        returns (uint256 reward)
    {
        // calculate rewards
        return
            calculateRewardFromStakes(
                _vaults[vault]
                    .stakes,
                stakeAmount,
                getCurrentUnlockedRewards(),
                getCurrentTotalStakeUnits(),
                block
                    .timestamp,
                _hypervisor
                    .rewardScaling
            )
                .reward;
    }

    function getFutureStakeReward(
        address vault,
        uint256 stakeAmount,
        uint256 timestamp
    ) external view override returns (uint256 reward) {
        // calculate rewards
        return
            calculateRewardFromStakes(
                _vaults[vault]
                    .stakes,
                stakeAmount,
                getFutureUnlockedRewards(timestamp),
                getFutureTotalStakeUnits(timestamp),
                timestamp,
                _hypervisor
                    .rewardScaling
            )
                .reward;
    }

    function getCurrentVaultStakeUnits(address vault)
        public
        view
        override
        returns (uint256 stakeUnits)
    {
        // calculate stake units
        return getFutureVaultStakeUnits(vault, block.timestamp);
    }

    function getFutureVaultStakeUnits(address vault, uint256 timestamp)
        public
        view
        override
        returns (uint256 stakeUnits)
    {
        // calculate stake units
        return calculateTotalStakeUnits(_vaults[vault].stakes, timestamp);
    }

    /* pure functions */

    function calculateTotalStakeUnits(StakeData[] memory stakes, uint256 timestamp)
        public
        pure
        override
        returns (uint256 totalStakeUnits)
    {
        for (uint256 index; index < stakes.length; index++) {
            // reference stake
            StakeData memory stakeData = stakes[index];
            // calculate stake units
            uint256 stakeUnits =
                calculateStakeUnits(stakeData.amount, stakeData.timestamp, timestamp);
            // add to running total
            totalStakeUnits = totalStakeUnits.add(stakeUnits);
        }
    }

    function calculateStakeUnits(
        uint256 amount,
        uint256 start,
        uint256 end
    ) public pure override returns (uint256 stakeUnits) {
        // calculate duration
        uint256 duration = end.sub(start);
        // calculate stake units
        stakeUnits = duration.mul(amount);
        // explicit return
        return stakeUnits;
    }

    function calculateUnlockedRewards(
        RewardSchedule[] memory rewardSchedules,
        uint256 rewardBalance,
        uint256 sharesOutstanding,
        uint256 timestamp
    ) public pure override returns (uint256 unlockedRewards) {
        // return 0 if no registered schedules
        if (rewardSchedules.length == 0) {
            return 0;
        }

        // calculate reward shares locked across all reward schedules
        uint256 sharesLocked;
        for (uint256 index = 0; index < rewardSchedules.length; index++) {
            // fetch reward schedule storage reference
            RewardSchedule memory schedule = rewardSchedules[index];

            // caculate amount of shares available on this schedule
            // if (now - start) < duration
            //   sharesLocked = shares - (shares * (now - start) / duration)
            // else
            //   sharesLocked = 0
            uint256 currentSharesLocked = 0;
            if (timestamp.sub(schedule.start) < schedule.duration) {
                currentSharesLocked = schedule.shares.sub(
                    schedule.shares.mul(timestamp.sub(schedule.start)).div(schedule.duration)
                );
            }

            // add to running total
            sharesLocked = sharesLocked.add(currentSharesLocked);
        }

        // convert shares to reward
        // rewardLocked = sharesLocked * rewardBalance / sharesOutstanding
        uint256 rewardLocked = sharesLocked.mul(rewardBalance).div(sharesOutstanding);

        // calculate amount available
        // unlockedRewards = rewardBalance - rewardLocked
        unlockedRewards = rewardBalance.sub(rewardLocked);

        // explicit return
        return unlockedRewards;
    }

    function calculateRewardFromStakes(
        StakeData[] memory stakes,
        uint256 unstakeAmount,
        uint256 unlockedRewards,
        uint256 totalStakeUnits,
        uint256 timestamp,
        RewardScaling memory rewardScaling
    ) public pure override returns (RewardOutput memory out) {
        uint256 stakesToDrop = 0;
        while (unstakeAmount > 0) {
            // fetch vault stake storage reference
            StakeData memory lastStake = stakes[stakes.length.sub(stakesToDrop).sub(1)];

            // calculate stake duration
            uint256 stakeDuration = timestamp.sub(lastStake.timestamp);

            uint256 currentAmount;
            if (lastStake.amount > unstakeAmount) {
                // set current amount to remaining unstake amount
                currentAmount = unstakeAmount;
                // amount of last stake is reduced
                out.lastStakeAmount = lastStake.amount.sub(unstakeAmount);
            } else {
                // set current amount to amount of last stake
                currentAmount = lastStake.amount;
                // add to stakes to drop
                stakesToDrop += 1;
            }

            // update remaining unstakeAmount
            unstakeAmount = unstakeAmount.sub(currentAmount);

            // calculate reward amount
            uint256 currentReward =
                calculateReward(
                    unlockedRewards,
                    currentAmount,
                    stakeDuration,
                    totalStakeUnits,
                    rewardScaling
                );

            // update cumulative reward
            out.reward = out.reward.add(currentReward);

            // update cached unlockedRewards
            unlockedRewards = unlockedRewards.sub(currentReward);

            // calculate time weighted stake
            uint256 stakeUnits = currentAmount.mul(stakeDuration);

            // update cached totalStakeUnits
            totalStakeUnits = totalStakeUnits.sub(stakeUnits);
        }

        // explicit return
        return
            RewardOutput(
                out.lastStakeAmount,
                stakes.length.sub(stakesToDrop),
                out.reward,
                totalStakeUnits
            );
    }

    function calculateReward(
        uint256 unlockedRewards,
        uint256 stakeAmount,
        uint256 stakeDuration,
        uint256 totalStakeUnits,
        RewardScaling memory rewardScaling
    ) public pure override returns (uint256 reward) {
        // calculate time weighted stake
        uint256 stakeUnits = stakeAmount.mul(stakeDuration);

        // calculate base reward
        // baseReward = unlockedRewards * stakeUnits / totalStakeUnits
        uint256 baseReward = 0;
        if (totalStakeUnits != 0) {
            // scale reward according to proportional weight
            baseReward = unlockedRewards.mul(stakeUnits).div(totalStakeUnits);
        }

        // calculate scaled reward
        // if no scaling or scaling period completed
        //   reward = baseReward
        // else
        //   minReward = baseReward * scalingFloor / scalingCeiling
        //   bonusReward = baseReward
        //                 * (scalingCeiling - scalingFloor) / scalingCeiling
        //                 * duration / scalingTime
        //   reward = minReward + bonusReward
        if (stakeDuration >= rewardScaling.time || rewardScaling.floor == rewardScaling.ceiling) {
            // no reward scaling applied
            reward = baseReward;
        } else {
            // calculate minimum reward using scaling floor
            uint256 minReward = baseReward.mul(rewardScaling.floor).div(rewardScaling.ceiling);

            // calculate bonus reward with vested portion of scaling factor
            uint256 bonusReward =
                baseReward
                    .mul(stakeDuration)
                    .mul(rewardScaling.ceiling.sub(rewardScaling.floor))
                    .div(rewardScaling.ceiling)
                    .div(rewardScaling.time);

            // add minimum reward and bonus reward
            reward = minReward.add(bonusReward);
        }

        // explicit return
        return reward;
    }

    /* admin functions */

    /// @notice Add funds to the Hypervisor
    /// access control: only admin
    /// state machine:
    ///   - can be called multiple times
    ///   - only online
    /// state scope:
    ///   - increase _hypervisor.rewardSharesOutstanding
    ///   - append to _hypervisor.rewardSchedules
    /// token transfer: transfer staking tokens from msg.sender to reward pool
    /// @param amount uint256 Amount of reward tokens to deposit
    /// @param duration uint256 Duration over which to linearly unlock rewards
    function fund(uint256 amount, uint256 duration) external onlyOwner onlyOnline {
        // validate duration
        require(duration != 0, ""Hypervisor: invalid duration"");

        // create new reward shares
        // if existing rewards on this Hypervisor
        //   mint new shares proportional to % change in rewards remaining
        //   newShares = remainingShares * newReward / remainingRewards
        // else
        //   mint new shares with BASE_SHARES_PER_WEI initial conversion rate
        //   store as fixed point number with same  of decimals as reward token
        uint256 newRewardShares;
        if (_hypervisor.rewardSharesOutstanding > 0) {
            uint256 remainingRewards = IERC20(_hypervisor.rewardToken).balanceOf(_hypervisor.rewardPool);
            newRewardShares = _hypervisor.rewardSharesOutstanding.mul(amount).div(remainingRewards);
        } else {
            newRewardShares = amount.mul(BASE_SHARES_PER_WEI);
        }

        // add reward shares to total
        _hypervisor.rewardSharesOutstanding = _hypervisor.rewardSharesOutstanding.add(newRewardShares);

        // store new reward schedule
        _hypervisor.rewardSchedules.push(RewardSchedule(duration, block.timestamp, newRewardShares));

        // transfer reward tokens to reward pool
        TransferHelper.safeTransferFrom(
            _hypervisor.rewardToken,
            msg.sender,
            _hypervisor.rewardPool,
            amount
        );

        // emit event
        emit HypervisorFunded(amount, duration);
    }

    /// @notice Add vault factory to whitelist
    /// @dev use this function to enable stakes to vaults coming from the specified
    ///      factory contract
    /// access control: only admin
    /// state machine:
    ///   - can be called multiple times
    ///   - not shutdown
    /// state scope:
    ///   - append to _vaultFactorySet
    /// token transfer: none
    /// @param factory address The address of the vault factory
    function registerVaultFactory(address factory) external onlyOwner notShutdown {
        // add factory to set
        require(_vaultFactorySet.add(factory), ""Hypervisor: vault factory already registered"");

        // emit event
        emit VaultFactoryRegistered(factory);
    }

    /// @notice Remove vault factory from whitelist
    /// @dev use this function to disable new stakes to vaults coming from the specified
    ///      factory contract.
    ///      note: vaults with existing stakes from this factory are sill able to unstake
    /// access control: only admin
    /// state machine:
    ///   - can be called multiple times
    ///   - not shutdown
    /// state scope:
    ///   - remove from _vaultFactorySet
    /// token transfer: none
    /// @param factory address The address of the vault factory
    function removeVaultFactory(address factory) external onlyOwner notShutdown {
        // remove factory from set
        require(_vaultFactorySet.remove(factory), ""Hypervisor: vault factory not registered"");

        // emit event
        emit VaultFactoryRemoved(factory);
    }

    /// @notice Register bonus token for distribution
    /// @dev use this function to enable distribution of any ERC20 held by the RewardPool contract
    /// access control: only admin
    /// state machine:
    ///   - can be called multiple times
    ///   - only online
    /// state scope:
    ///   - append to _bonusTokenSet
    /// token transfer: none
    /// @param bonusToken address The address of the bonus token
    function registerBonusToken(address bonusToken) external onlyOwner onlyOnline {
        // verify valid bonus token
        _validateAddress(bonusToken);

        // verify bonus token count
        require(_bonusTokenSet.length() < MAX_REWARD_TOKENS, ""Hypervisor: max bonus tokens reached "");

        // add token to set
        assert(_bonusTokenSet.add(bonusToken));

        // emit event
        emit BonusTokenRegistered(bonusToken);
    }

    /// @notice Rescue tokens from RewardPool
    /// @dev use this function to rescue tokens from RewardPool contract
    ///      without distributing to stakers or triggering emergency shutdown
    /// access control: only admin
    /// state machine:
    ///   - can be called multiple times
    ///   - only online
    /// state scope: none
    /// token transfer: transfer requested token from RewardPool to recipient
    /// @param token address The address of the token to rescue
    /// @param recipient address The address of the recipient
    /// @param amount uint256 The amount of tokens to rescue
    function rescueTokensFromRewardPool(
        address token,
        address recipient,
        uint256 amount
    ) external onlyOwner onlyOnline {
        // verify recipient
        _validateAddress(recipient);

        // check not attempting to unstake reward token
        require(token != _hypervisor.rewardToken, ""Hypervisor: invalid address"");

        // check not attempting to wthdraw bonus token
        require(!_bonusTokenSet.contains(token), ""Hypervisor: invalid address"");

        // transfer tokens to recipient
        IRewardPool(_hypervisor.rewardPool).sendERC20(token, recipient, amount);
    }

    /* user functions */

    /// @notice Stake tokens
    /// @dev anyone can stake to any vault if they have valid permission
    /// access control: anyone
    /// state machine:
    ///   - can be called multiple times
    ///   - only online
    ///   - when vault exists on this Hypervisor
    /// state scope:
    ///   - append to _vaults[vault].stakes
    ///   - increase _vaults[vault].totalStake
    ///   - increase _hypervisor.totalStake
    ///   - increase _hypervisor.totalStakeUnits
    ///   - increase _hypervisor.lastUpdate
    /// token transfer: transfer staking tokens from msg.sender to vault
    /// @param vault address The address of the vault to stake from
    /// @param amount uint256 The amount of staking tokens to stake
    function stake(
        address vault,
        uint256 amount,
        bytes calldata permission
    ) external override onlyOnline {
        // verify vault is valid
        require(isValidVault(vault), ""Hypervisor: vault is not registered"");

        // verify non-zero amount
        require(amount != 0, ""Hypervisor: no amount staked"");

        // fetch vault storage reference
        VaultData storage vaultData = _vaults[vault];

        // verify stakes boundary not reached
        require(
            vaultData.stakes.length < MAX_STAKES_PER_VAULT,
            ""Hypervisor: MAX_STAKES_PER_VAULT reached""
        );

        // update cached sum of stake units across all vaults
        _updateTotalStakeUnits();

        // store amount and timestamp
        vaultData.stakes.push(StakeData(amount, block.timestamp));

        // update cached total vault and Hypervisor amounts
        vaultData.totalStake = vaultData.totalStake.add(amount);
        // verify stake quantity without bounds
        require(
            stakeLimit == 0 || vaultData.totalStake <= stakeLimit,
            ""Hypervisor: Stake limit exceeded""
        );
        _hypervisor.totalStake = _hypervisor.totalStake.add(amount);

        // call lock on vault
        IUniversalVault(vault).lock(_hypervisor.stakingToken, amount, permission);

        // emit event
        emit Staked(vault, amount);
    }

    /// @notice Unstake staking tokens and claim reward
    /// @dev rewards can only be claimed when unstaking
    /// access control: only owner of vault
    /// state machine:
    ///   - when vault exists on this Hypervisor
    ///   - after stake from vault
    ///   - can be called multiple times while sufficient stake remains
    ///   - only online
    /// state scope:
    ///   - decrease _hypervisor.rewardSharesOutstanding
    ///   - decrease _hypervisor.totalStake
    ///   - increase _hypervisor.lastUpdate
    ///   - modify _hypervisor.totalStakeUnits
    ///   - modify _vaults[vault].stakes
    ///   - decrease _vaults[vault].totalStake
    /// token transfer:
    ///   - transfer reward tokens from reward pool to recipient
    ///   - transfer bonus tokens from reward pool to recipient
    /// @param vault address The vault to unstake from
    /// @param amount uint256 The amount of staking tokens to unstake
    function unstakeAndClaim(
        address vault,
        uint256 amount,
        bytes calldata permission
    ) external override onlyOnline {
        // fetch vault storage reference
        VaultData storage vaultData = _vaults[vault];

        // verify non-zero amount
        require(amount != 0, ""Hypervisor: no amount unstaked"");

        address recipient = IUniversalVault(vault).owner();

        // validate recipient
        _validateAddress(recipient);

        // check for sufficient vault stake amount
        require(vaultData.totalStake >= amount, ""Hypervisor: insufficient vault stake"");

        // check for sufficient Hypervisor stake amount
        // if this check fails, there is a bug in stake accounting
        assert(_hypervisor.totalStake >= amount);

        // update cached sum of stake units across all vaults
        _updateTotalStakeUnits();

        // get reward amount remaining
        uint256 remainingRewards = IERC20(_hypervisor.rewardToken).balanceOf(_hypervisor.rewardPool);

        // calculate vested portion of reward pool
        uint256 unlockedRewards =
            calculateUnlockedRewards(
                _hypervisor.rewardSchedules,
                remainingRewards,
                _hypervisor.rewardSharesOutstanding,
                block.timestamp
            );

        // calculate vault time weighted reward with scaling
        RewardOutput memory out =
            calculateRewardFromStakes(
                vaultData.stakes,
                amount,
                unlockedRewards,
                _hypervisor.totalStakeUnits,
                block.timestamp,
                _hypervisor.rewardScaling
            );

        // update stake data in storage
        if (out.newStakesCount == 0) {
            // all stakes have been unstaked
            delete vaultData.stakes;
        } else {
            // some stakes have been completely or partially unstaked
            // delete fully unstaked stakes
            while (vaultData.stakes.length > out.newStakesCount) vaultData.stakes.pop();
            // update partially unstaked stake
            vaultData.stakes[out.newStakesCount.sub(1)].amount = out.lastStakeAmount;
        }

        // update cached stake totals
        vaultData.totalStake = vaultData.totalStake.sub(amount);
        _hypervisor.totalStake = _hypervisor.totalStake.sub(amount);
        _hypervisor.totalStakeUnits = out.newTotalStakeUnits;

        // unlock staking tokens from vault
        IUniversalVault(vault).unlock(_hypervisor.stakingToken, amount, permission);

        // emit event
        emit Unstaked(vault, amount);

        // only perform on non-zero reward
        if (out.reward > 0) {
            // calculate shares to burn
            // sharesToBurn = sharesOutstanding * reward / remainingRewards
            uint256 sharesToBurn =
                _hypervisor.rewardSharesOutstanding.mul(out.reward).div(remainingRewards);

            // burn claimed shares
            _hypervisor.rewardSharesOutstanding = _hypervisor.rewardSharesOutstanding.sub(sharesToBurn);

            // transfer bonus tokens from reward pool to recipient
            if (_bonusTokenSet.length() > 0) {
                for (uint256 index = 0; index < _bonusTokenSet.length(); index++) {
                    // fetch bonus token address reference
                    address bonusToken = _bonusTokenSet.at(index);

                    // calculate bonus token amount
                    // bonusAmount = bonusRemaining * reward / remainingRewards
                    uint256 bonusAmount =
                        IERC20(bonusToken).balanceOf(_hypervisor.rewardPool).mul(out.reward).div(
                            remainingRewards
                        );

                    // transfer bonus token
                    IRewardPool(_hypervisor.rewardPool).sendERC20(bonusToken, recipient, bonusAmount);

                    // emit event
                    emit RewardClaimed(vault, recipient, bonusToken, bonusAmount);
                }
            }

            // transfer reward tokens from reward pool to recipient
            IRewardPool(_hypervisor.rewardPool).sendERC20(_hypervisor.rewardToken, recipient, out.reward);

            // emit event
            emit RewardClaimed(vault, recipient, _hypervisor.rewardToken, out.reward);
        }
    }

    /// @notice Exit Hypervisor without claiming reward
    /// @dev This function should never revert when correctly called by the vault.
    ///      A max number of stakes per vault is set with MAX_STAKES_PER_VAULT to
    ///      place an upper bound on the for loop in calculateTotalStakeUnits().
    /// access control: only callable by the vault directly
    /// state machine:
    ///   - when vault exists on this Hypervisor
    ///   - when active stake from this vault
    ///   - any power state
    /// state scope:
    ///   - decrease _hypervisor.totalStake
    ///   - increase _hypervisor.lastUpdate
    ///   - modify _hypervisor.totalStakeUnits
    ///   - delete _vaults[vault]
    /// token transfer: none
    function rageQuit() external override {
        // fetch vault storage reference
        VaultData storage _vaultData = _vaults[msg.sender];

        // revert if no active stakes
        require(_vaultData.stakes.length != 0, ""Hypervisor: no stake"");

        // update cached sum of stake units across all vaults
        _updateTotalStakeUnits();

        // emit event
        emit Unstaked(msg.sender, _vaultData.totalStake);

        // update cached totals
        _hypervisor.totalStake = _hypervisor.totalStake.sub(_vaultData.totalStake);
        _hypervisor.totalStakeUnits = _hypervisor.totalStakeUnits.sub(
            calculateTotalStakeUnits(_vaultData.stakes, block.timestamp)
        );

        // delete stake data
        delete _vaults[msg.sender];
    }

    /* convenience functions */

    function _updateTotalStakeUnits() private {
        // update cached totalStakeUnits
        _hypervisor.totalStakeUnits = getCurrentTotalStakeUnits();
        // update cached lastUpdate
        _hypervisor.lastUpdate = block.timestamp;
    }

    function _validateAddress(address target) private view {
        // sanity check target for potential input errors
        require(isValidAddress(target), ""Hypervisor: invalid address"");
    }

    function _truncateStakesArray(StakeData[] memory array, uint256 newLength)
        private
        pure
        returns (StakeData[] memory newArray)
    {
        newArray = new StakeData[](newLength);
        for (uint256 index = 0; index < newLength; index++) {
            newArray[index] = array[index];
        }
        return newArray;
    }
}
"".
Ideas: "" Redundant Conditional Check Identified.
```
REDUNDANT CONDITIONAL CHECK
'''
In the `isValidAddress` function, the check for `target != address(this)` is redundant because the function is already designed to validate addresses that are not the contract itself. Additionally, the check for `target != address(0)` is also redundant as it is"".
As the Security Analyst, your primary objective is to perform a thorough and detailed inspection of the provided contract code, with a particular focus on identifying vulnerabilities related to External Oracle Dependency. There are two main concerns related to External Oracle Dependency vulnerabilities:
1. Dependence on a single external oracle for critical data, which pertains to the reliability of the data source. If the oracle is compromised, provides incorrect data, or becomes unavailable, the contract's functionalities could be adversely affected.
2. Lack of fallback mechanisms, which can lead to the contract failing if the external oracle call fails or returns invalid data. This could be exploited by adversaries to disrupt the contract's operations.
If you identify reliance on a single external oracle for critical data, respond with: """,,,"<INFO> Centralization Risk Identified.

**Ownership Hijacking**
'''
The contract uses the Ownable pattern, which centralizes control in a single address (the owner). If the owner's private key is compromised, an attacker could gain full control over the contract, allowing them to execute any function that requires ownership, such as `fund`, `registerVaultFactory`, `removeVaultFactory`, and `rescueTokensFromRewardPool`. This poses a significant risk to the integrity of the contract and the funds within it.

**Recommended Mitigation/Fix:**
Implement a multi-signature wallet for critical functions that require ownership. This would distribute control among multiple trusted parties, reducing the risk of a single point of failure. Additionally, consider implementing a time-lock mechanism for sensitive operations to provide a buffer period during which stakeholders can react to potentially malicious actions.
'''

[2024-02-08 00:45:09 INFO] **[Execute Detail]**

execute SimplePhase:[FundingCalculationDetector] in ComposedPhase:[CodeReview], cycle 1

[2024-02-08 00:45:09 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: GPL-3.0-only pragma solidity 0.7.6; pragma abicoder v2; import {SafeMath} from ""@openzeppelin/contracts/math/SafeMath.sol""; import {EnumerableSet} from ""@openzeppelin/contracts/utils/EnumerableSet.sol""; import {IERC20} from ""@openzeppelin/contracts/token/ERC20/IERC20.sol""; import {Ownable} from ""@openzeppelin/contracts/access/Ownable.sol""; import {TransferHelper} from ""@uniswap/lib/contracts/libraries/TransferHelper.sol""; import {IFactory} from ""../factory/IFactory.sol""; import {IInstanceRegistry} from ""../factory/InstanceRegistry.sol""; import {IUniversalVault} from ""../visor/Visor.sol""; import {IRewardPool} from ""./RewardPool.sol""; import {Powered} from ""./Powered.sol""; interface IRageQuit {     function rageQuit() external; } interface IHypervisor is IRageQuit {     / admin events / event HypervisorCreated(address rewardPool, address powerSwitch); event HypervisorFunded(uint256 amount, uint256 duration); event BonusTokenRegistered(address token); event VaultFactoryRegistered(address factory); event VaultFactoryRemoved(address factory);  /* user events */  event Staked(address vault, uint256 amount); event Unstaked(address vault, uint256 amount); event RewardClaimed(address vault, address recipient, address token, uint256 amount);  /* data types */  struct HypervisorData {     address stakingToken;     address rewardToken;     address rewardPool;     RewardScaling rewardScaling;     uint256 rewardSharesOutstanding;     uint256 totalStake;     uint256 totalStakeUnits;     uint256 lastUpdate;     RewardSchedule[] rewardSchedules; }  struct RewardSchedule {     uint256 duration;     uint256 start;     uint256 shares; }  struct VaultData {     uint256 totalStake;     StakeData[] stakes; }  struct StakeData {     uint256 amount;     uint256 timestamp; }  struct RewardScaling {     uint256 floor;     uint256 ceiling;     uint256 time; }  struct RewardOutput {     uint256 lastStakeAmount;     uint256 newStakesCount;     uint256 reward;     uint256 newTotalStakeUnits; }  /* user functions */  function stake(     address vault,     uint256 amount,     bytes calldata permission ) external;  function unstakeAndClaim(     address vault,     uint256 amount,     bytes calldata permission ) external;  /* getter functions */  function getHypervisorData() external view returns (HypervisorData memory hypervisor);  function getBonusTokenSetLength() external view returns (uint256 length);  function getBonusTokenAtIndex(uint256 index) external view returns (address bonusToken);  function getVaultFactorySetLength() external view returns (uint256 length);  function getVaultFactoryAtIndex(uint256 index) external view returns (address factory);  function getVaultData(address vault) external view returns (VaultData memory vaultData);  function isValidAddress(address target) external view returns (bool validity);  function isValidVault(address target) external view returns (bool validity);  function getCurrentUnlockedRewards() external view returns (uint256 unlockedRewards);  function getFutureUnlockedRewards(uint256 timestamp)     external     view     returns (uint256 unlockedRewards);  function getCurrentVaultReward(address vault) external view returns (uint256 reward);  function getCurrentStakeReward(address vault, uint256 stakeAmount)     external     view     returns (uint256 reward);  function getFutureVaultReward(address vault, uint256 timestamp)     external     view     returns (uint256 reward);  function getFutureStakeReward(     address vault,     uint256 stakeAmount,     uint256 timestamp ) external view returns (uint256 reward);  function getCurrentVaultStakeUnits(address vault) external view returns (uint256 stakeUnits);  function getFutureVaultStakeUnits(address vault, uint256 timestamp)     external     view     returns (uint256 stakeUnits);  function getCurrentTotalStakeUnits() external view returns (uint256 totalStakeUnits);  function getFutureTotalStakeUnits(uint256 timestamp)     external     view     returns (uint256 totalStakeUnits);  /* pure functions */  function calculateTotalStakeUnits(StakeData[] memory stakes, uint256 timestamp)     external     pure     returns (uint256 totalStakeUnits);  function calculateStakeUnits(     uint256 amount,     uint256 start,     uint256 end ) external pure returns (uint256 stakeUnits);  function calculateUnlockedRewards(     RewardSchedule[] memory rewardSchedules,     uint256 rewardBalance,     uint256 sharesOutstanding,     uint256 timestamp ) external pure returns (uint256 unlockedRewards);  function calculateRewardFromStakes(     StakeData[] memory stakes,     uint256 unstakeAmount,     uint256 unlockedRewards,     uint256 totalStakeUnits,     uint256 timestamp,     RewardScaling memory rewardScaling ) external pure returns (RewardOutput memory out);  function calculateReward(     uint256 unlockedRewards,     uint256 stakeAmount,     uint256 stakeDuration,     uint256 totalStakeUnits,     RewardScaling memory rewardScaling ) external pure returns (uint256 reward);  } /// @title Hypervisor /// @notice Reward distribution contract with time multiplier /// Access Control /// - Power controller: ///     Can power off / shutdown the Hypervisor ///     Can withdraw rewards from reward pool once shutdown /// - Proxy owner: ///     Can change arbitrary logic / state by upgrading the Hypervisor ///     Is unable to operate on user funds due to UniversalVault ///     Is unable to operate on reward pool funds when reward pool is offline / shutdown /// - Hypervisor admin: ///     Can add funds to the Hypervisor, register bonus tokens, and whitelist new vault factories ///     Is a subset of proxy owner permissions /// - User: ///     Can deposit / withdraw / ragequit /// Hypervisor State Machine /// - Online: ///     Hypervisor is operating normally, all functions are enabled /// - Offline: ///     Hypervisor is temporarely disabled for maintenance ///     User deposits and withdrawls are disabled, ragequit remains enabled ///     Users can withdraw their stake through rageQuit() but forego their pending reward ///     Should only be used when downtime required for an upgrade /// - Shutdown: ///     Hypervisor is permanently disabled ///     All functions are disabled with the exception of ragequit ///     Users can withdraw their stake through rageQuit() ///     Power controller can withdraw from the reward pool ///     Should only be used if Proxy Owner role is compromized contract Hypervisor is IHypervisor, Powered, Ownable {     using SafeMath for uint256;     using EnumerableSet for EnumerableSet.AddressSet; /* constants */  // An upper bound on the number of active stakes per vault is required to prevent // calls to rageQuit() from reverting. // With 30 stakes in a vault, ragequit costs 432811 gas which is conservatively lower // than the hardcoded limit of 500k gas on the vault. // This limit is configurable and could be increased in a future deployment. // Ultimately, to avoid a need for fixed upper bounds, the EVM would need to provide // an error code that allows for reliably catching out-of-gas errors on remote calls. uint256 public constant MAX_STAKES_PER_VAULT = 30; uint256 public constant MAX_REWARD_TOKENS = 50; uint256 public constant BASE_SHARES_PER_WEI = 1000000; uint256 public stakeLimit = 2500 ether;  /* storage */  HypervisorData private _hypervisor; mapping(address =&gt; VaultData) private _vaults; EnumerableSet.AddressSet private _bonusTokenSet; EnumerableSet.AddressSet private _vaultFactorySet;  /* initializer */  /// @notice Initizalize Hypervisor /// access control: only proxy constructor /// state machine: can only be called once /// state scope: set initialization variables /// token transfer: none /// @param ownerAddress address The admin address /// @param rewardPoolFactory address The factory to use for deploying the RewardPool /// @param powerSwitchFactory address The factory to use for deploying the PowerSwitch /// @param stakingToken address The address of the staking token for this Hypervisor /// @param rewardToken address The address of the reward token for this Hypervisor /// @param rewardScaling RewardScaling The config for reward scaling floor, ceiling, and time constructor(     address ownerAddress,     address rewardPoolFactory,     address powerSwitchFactory,     address stakingToken,     address rewardToken,     RewardScaling memory rewardScaling,     uint256 _stakeLimit ) {     // the scaling floor must be smaller than ceiling     require(rewardScaling.floor &lt;= rewardScaling.ceiling, ""Hypervisor: floor above ceiling"");      // setting rewardScalingTime to 0 would cause divide by zero error     // to disable reward scaling, use rewardScalingFloor == rewardScalingCeiling     require(rewardScaling.time != 0, ""Hypervisor: scaling time cannot be zero"");      // deploy power switch     address powerSwitch = IFactory(powerSwitchFactory).create(abi.encode(ownerAddress));      // deploy reward pool     address rewardPool = IFactory(rewardPoolFactory).create(abi.encode(powerSwitch));      // set internal configs     Ownable.transferOwnership(ownerAddress);     Powered._setPowerSwitch(powerSwitch);      // commit to storage     _hypervisor.stakingToken = stakingToken;     _hypervisor.rewardToken = rewardToken;     _hypervisor.rewardPool = rewardPool;     _hypervisor.rewardScaling = rewardScaling;      stakeLimit = _stakeLimit;      // emit event     emit HypervisorCreated(rewardPool, powerSwitch); }  /* getter functions */  function getBonusTokenSetLength() external view override returns (uint256 length) {     return _bonusTokenSet.length(); }  function getBonusTokenAtIndex(uint256 index)     external     view     override     returns (address bonusToken) {     return _bonusTokenSet.at(index); }  function getVaultFactorySetLength() external view override returns (uint256 length) {     return _vaultFactorySet.length(); }  function getVaultFactoryAtIndex(uint256 index)     external     view     override     returns (address factory) {     return _vaultFactorySet.at(index); }  function isValidVault(address target) public view override returns (bool validity) {     // validate target is created from whitelisted vault factory     for (uint256 index = 0; index &lt; _vaultFactorySet.length(); index++) {         if (IInstanceRegistry(_vaultFactorySet.at(index)).isInstance(target)) {             return true;         }     }     // explicit return     return false; }  function isValidAddress(address target) public view override returns (bool validity) {     // sanity check target for potential input errors     return         target != address(this) &amp;&amp;         target != address(0) &amp;&amp;         target != _hypervisor.stakingToken &amp;&amp;         target != _hypervisor.rewardToken &amp;&amp;         target != _hypervisor.rewardPool &amp;&amp;         !_bonusTokenSet.contains(target); }  /* Hypervisor getters */  function getHypervisorData() external view override returns (HypervisorData memory hypervisor) {     return _hypervisor; }  function getCurrentUnlockedRewards() public view override returns (uint256 unlockedRewards) {     // calculate reward available based on state     return getFutureUnlockedRewards(block.timestamp); }  function getFutureUnlockedRewards(uint256 timestamp)     public     view     override     returns (uint256 unlockedRewards) {     // get reward amount remaining     uint256 remainingRewards = IERC20(_hypervisor.rewardToken).balanceOf(_hypervisor.rewardPool);     // calculate reward available based on state     unlockedRewards = calculateUnlockedRewards(         _hypervisor.rewardSchedules,         remainingRewards,         _hypervisor.rewardSharesOutstanding,         timestamp     );     // explicit return     return unlockedRewards; }  function getCurrentTotalStakeUnits() public view override returns (uint256 totalStakeUnits) {     // calculate new stake units     return getFutureTotalStakeUnits(block.timestamp); }  function getFutureTotalStakeUnits(uint256 timestamp)     public     view     override     returns (uint256 totalStakeUnits) {     // return early if no change     if (timestamp == _hypervisor.lastUpdate) return _hypervisor.totalStakeUnits;     // calculate new stake units     uint256 newStakeUnits =         calculateStakeUnits(_hypervisor.totalStake, _hypervisor.lastUpdate, timestamp);     // add to cached total     totalStakeUnits = _hypervisor.totalStakeUnits.add(newStakeUnits);     // explicit return     return totalStakeUnits; }  /* vault getters */  function getVaultData(address vault)     external     view     override     returns (VaultData memory vaultData) {     return _vaults[vault]; }  function getCurrentVaultReward(address vault) external view override returns (uint256 reward) {     // calculate rewards     return         calculateRewardFromStakes(             _vaults[vault]                 .stakes,             _vaults[vault]                 .totalStake,             getCurrentUnlockedRewards(),             getCurrentTotalStakeUnits(),             block                 .timestamp,             _hypervisor                 .rewardScaling         )             .reward; }  function getFutureVaultReward(address vault, uint256 timestamp)     external     view     override     returns (uint256 reward) {     // calculate rewards     return         calculateRewardFromStakes(             _vaults[vault]                 .stakes,             _vaults[vault]                 .totalStake,             getFutureUnlockedRewards(timestamp),             getFutureTotalStakeUnits(timestamp),             timestamp,             _hypervisor                 .rewardScaling         )             .reward; }  function getCurrentStakeReward(address vault, uint256 stakeAmount)     external     view     override     returns (uint256 reward) {     // calculate rewards     return         calculateRewardFromStakes(             _vaults[vault]                 .stakes,             stakeAmount,             getCurrentUnlockedRewards(),             getCurrentTotalStakeUnits(),             block                 .timestamp,             _hypervisor                 .rewardScaling         )             .reward; }  function getFutureStakeReward(     address vault,     uint256 stakeAmount,     uint256 timestamp ) external view override returns (uint256 reward) {     // calculate rewards     return         calculateRewardFromStakes(             _vaults[vault]                 .stakes,             stakeAmount,             getFutureUnlockedRewards(timestamp),             getFutureTotalStakeUnits(timestamp),             timestamp,             _hypervisor                 .rewardScaling         )             .reward; }  function getCurrentVaultStakeUnits(address vault)     public     view     override     returns (uint256 stakeUnits) {     // calculate stake units     return getFutureVaultStakeUnits(vault, block.timestamp); }  function getFutureVaultStakeUnits(address vault, uint256 timestamp)     public     view     override     returns (uint256 stakeUnits) {     // calculate stake units     return calculateTotalStakeUnits(_vaults[vault].stakes, timestamp); }  /* pure functions */  function calculateTotalStakeUnits(StakeData[] memory stakes, uint256 timestamp)     public     pure     override     returns (uint256 totalStakeUnits) {     for (uint256 index; index &lt; stakes.length; index++) {         // reference stake         StakeData memory stakeData = stakes[index];         // calculate stake units         uint256 stakeUnits =             calculateStakeUnits(stakeData.amount, stakeData.timestamp, timestamp);         // add to running total         totalStakeUnits = totalStakeUnits.add(stakeUnits);     } }  function calculateStakeUnits(     uint256 amount,     uint256 start,     uint256 end ) public pure override returns (uint256 stakeUnits) {     // calculate duration     uint256 duration = end.sub(start);     // calculate stake units     stakeUnits = duration.mul(amount);     // explicit return     return stakeUnits; }  function calculateUnlockedRewards(     RewardSchedule[] memory rewardSchedules,     uint256 rewardBalance,     uint256 sharesOutstanding,     uint256 timestamp ) public pure override returns (uint256 unlockedRewards) {     // return 0 if no registered schedules     if (rewardSchedules.length == 0) {         return 0;     }      // calculate reward shares locked across all reward schedules     uint256 sharesLocked;     for (uint256 index = 0; index &lt; rewardSchedules.length; index++) {         // fetch reward schedule storage reference         RewardSchedule memory schedule = rewardSchedules[index];          // caculate amount of shares available on this schedule         // if (now - start) &lt; duration         //   sharesLocked = shares - (shares * (now - start) / duration)         // else         //   sharesLocked = 0         uint256 currentSharesLocked = 0;         if (timestamp.sub(schedule.start) &lt; schedule.duration) {             currentSharesLocked = schedule.shares.sub(                 schedule.shares.mul(timestamp.sub(schedule.start)).div(schedule.duration)             );         }          // add to running total         sharesLocked = sharesLocked.add(currentSharesLocked);     }      // convert shares to reward     // rewardLocked = sharesLocked * rewardBalance / sharesOutstanding     uint256 rewardLocked = sharesLocked.mul(rewardBalance).div(sharesOutstanding);      // calculate amount available     // unlockedRewards = rewardBalance - rewardLocked     unlockedRewards = rewardBalance.sub(rewardLocked);      // explicit return     return unlockedRewards; }  function calculateRewardFromStakes(     StakeData[] memory stakes,     uint256 unstakeAmount,     uint256 unlockedRewards,     uint256 totalStakeUnits,     uint256 timestamp,     RewardScaling memory rewardScaling ) public pure override returns (RewardOutput memory out) {     uint256 stakesToDrop = 0;     while (unstakeAmount &gt; 0) {         // fetch vault stake storage reference         StakeData memory lastStake = stakes[stakes.length.sub(stakesToDrop).sub(1)];          // calculate stake duration         uint256 stakeDuration = timestamp.sub(lastStake.timestamp);          uint256 currentAmount;         if (lastStake.amount &gt; unstakeAmount) {             // set current amount to remaining unstake amount             currentAmount = unstakeAmount;             // amount of last stake is reduced             out.lastStakeAmount = lastStake.amount.sub(unstakeAmount);         } else {             // set current amount to amount of last stake             currentAmount = lastStake.amount;             // add to stakes to drop             stakesToDrop += 1;         }          // update remaining unstakeAmount         unstakeAmount = unstakeAmount.sub(currentAmount);          // calculate reward amount         uint256 currentReward =             calculateReward(                 unlockedRewards,                 currentAmount,                 stakeDuration,                 totalStakeUnits,                 rewardScaling             );          // update cumulative reward         out.reward = out.reward.add(currentReward);          // update cached unlockedRewards         unlockedRewards = unlockedRewards.sub(currentReward);          // calculate time weighted stake         uint256 stakeUnits = currentAmount.mul(stakeDuration);          // update cached totalStakeUnits         totalStakeUnits = totalStakeUnits.sub(stakeUnits);     }      // explicit return     return         RewardOutput(             out.lastStakeAmount,             stakes.length.sub(stakesToDrop),             out.reward,             totalStakeUnits         ); }  function calculateReward(     uint256 unlockedRewards,     uint256 stakeAmount,     uint256 stakeDuration,     uint256 totalStakeUnits,     RewardScaling memory rewardScaling ) public pure override returns (uint256 reward) {     // calculate time weighted stake     uint256 stakeUnits = stakeAmount.mul(stakeDuration);      // calculate base reward     // baseReward = unlockedRewards * stakeUnits / totalStakeUnits     uint256 baseReward = 0;     if (totalStakeUnits != 0) {         // scale reward according to proportional weight         baseReward = unlockedRewards.mul(stakeUnits).div(totalStakeUnits);     }      // calculate scaled reward     // if no scaling or scaling period completed     //   reward = baseReward     // else     //   minReward = baseReward * scalingFloor / scalingCeiling     //   bonusReward = baseReward     //                 * (scalingCeiling - scalingFloor) / scalingCeiling     //                 * duration / scalingTime     //   reward = minReward + bonusReward     if (stakeDuration &gt;= rewardScaling.time || rewardScaling.floor == rewardScaling.ceiling) {         // no reward scaling applied         reward = baseReward;     } else {         // calculate minimum reward using scaling floor         uint256 minReward = baseReward.mul(rewardScaling.floor).div(rewardScaling.ceiling);          // calculate bonus reward with vested portion of scaling factor         uint256 bonusReward =             baseReward                 .mul(stakeDuration)                 .mul(rewardScaling.ceiling.sub(rewardScaling.floor))                 .div(rewardScaling.ceiling)                 .div(rewardScaling.time);          // add minimum reward and bonus reward         reward = minReward.add(bonusReward);     }      // explicit return     return reward; }  /* admin functions */  /// @notice Add funds to the Hypervisor /// access control: only admin /// state machine: ///   - can be called multiple times ///   - only online /// state scope: ///   - increase _hypervisor.rewardSharesOutstanding ///   - append to _hypervisor.rewardSchedules /// token transfer: transfer staking tokens from msg.sender to reward pool /// @param amount uint256 Amount of reward tokens to deposit /// @param duration uint256 Duration over which to linearly unlock rewards function fund(uint256 amount, uint256 duration) external onlyOwner onlyOnline {     // validate duration     require(duration != 0, ""Hypervisor: invalid duration"");      // create new reward shares     // if existing rewards on this Hypervisor     //   mint new shares proportional to % change in rewards remaining     //   newShares = remainingShares * newReward / remainingRewards     // else     //   mint new shares with BASE_SHARES_PER_WEI initial conversion rate     //   store as fixed point number with same  of decimals as reward token     uint256 newRewardShares;     if (_hypervisor.rewardSharesOutstanding &gt; 0) {         uint256 remainingRewards = IERC20(_hypervisor.rewardToken).balanceOf(_hypervisor.rewardPool);         newRewardShares = _hypervisor.rewardSharesOutstanding.mul(amount).div(remainingRewards);     } else {         newRewardShares = amount.mul(BASE_SHARES_PER_WEI);     }      // add reward shares to total     _hypervisor.rewardSharesOutstanding = _hypervisor.rewardSharesOutstanding.add(newRewardShares);      // store new reward schedule     _hypervisor.rewardSchedules.push(RewardSchedule(duration, block.timestamp, newRewardShares));      // transfer reward tokens to reward pool     TransferHelper.safeTransferFrom(         _hypervisor.rewardToken,         msg.sender,         _hypervisor.rewardPool,         amount     );      // emit event     emit HypervisorFunded(amount, duration); }  /// @notice Add vault factory to whitelist /// @dev use this function to enable stakes to vaults coming from the specified ///      factory contract /// access control: only admin /// state machine: ///   - can be called multiple times ///   - not shutdown /// state scope: ///   - append to _vaultFactorySet /// token transfer: none /// @param factory address The address of the vault factory function registerVaultFactory(address factory) external onlyOwner notShutdown {     // add factory to set     require(_vaultFactorySet.add(factory), ""Hypervisor: vault factory already registered"");      // emit event     emit VaultFactoryRegistered(factory); }  /// @notice Remove vault factory from whitelist /// @dev use this function to disable new stakes to vaults coming from the specified ///      factory contract. ///      note: vaults with existing stakes from this factory are sill able to unstake /// access control: only admin /// state machine: ///   - can be called multiple times ///   - not shutdown /// state scope: ///   - remove from _vaultFactorySet /// token transfer: none /// @param factory address The address of the vault factory function removeVaultFactory(address factory) external onlyOwner notShutdown {     // remove factory from set     require(_vaultFactorySet.remove(factory), ""Hypervisor: vault factory not registered"");      // emit event     emit VaultFactoryRemoved(factory); }  /// @notice Register bonus token for distribution /// @dev use this function to enable distribution of any ERC20 held by the RewardPool contract /// access control: only admin /// state machine: ///   - can be called multiple times ///   - only online /// state scope: ///   - append to _bonusTokenSet /// token transfer: none /// @param bonusToken address The address of the bonus token function registerBonusToken(address bonusToken) external onlyOwner onlyOnline {     // verify valid bonus token     _validateAddress(bonusToken);      // verify bonus token count     require(_bonusTokenSet.length() &lt; MAX_REWARD_TOKENS, ""Hypervisor: max bonus tokens reached "");      // add token to set     assert(_bonusTokenSet.add(bonusToken));      // emit event     emit BonusTokenRegistered(bonusToken); }  /// @notice Rescue tokens from RewardPool /// @dev use this function to rescue tokens from RewardPool contract ///      without distributing to stakers or triggering emergency shutdown /// access control: only admin /// state machine: ///   - can be called multiple times ///   - only online /// state scope: none /// token transfer: transfer requested token from RewardPool to recipient /// @param token address The address of the token to rescue /// @param recipient address The address of the recipient /// @param amount uint256 The amount of tokens to rescue function rescueTokensFromRewardPool(     address token,     address recipient,     uint256 amount ) external onlyOwner onlyOnline {     // verify recipient     _validateAddress(recipient);      // check not attempting to unstake reward token     require(token != _hypervisor.rewardToken, ""Hypervisor: invalid address"");      // check not attempting to wthdraw bonus token     require(!_bonusTokenSet.contains(token), ""Hypervisor: invalid address"");      // transfer tokens to recipient     IRewardPool(_hypervisor.rewardPool).sendERC20(token, recipient, amount); }  /* user functions */  /// @notice Stake tokens /// @dev anyone can stake to any vault if they have valid permission /// access control: anyone /// state machine: ///   - can be called multiple times ///   - only online ///   - when vault exists on this Hypervisor /// state scope: ///   - append to _vaults[vault].stakes ///   - increase _vaults[vault].totalStake ///   - increase _hypervisor.totalStake ///   - increase _hypervisor.totalStakeUnits ///   - increase _hypervisor.lastUpdate /// token transfer: transfer staking tokens from msg.sender to vault /// @param vault address The address of the vault to stake from /// @param amount uint256 The amount of staking tokens to stake function stake(     address vault,     uint256 amount,     bytes calldata permission ) external override onlyOnline {     // verify vault is valid     require(isValidVault(vault), ""Hypervisor: vault is not registered"");      // verify non-zero amount     require(amount != 0, ""Hypervisor: no amount staked"");      // fetch vault storage reference     VaultData storage vaultData = _vaults[vault];      // verify stakes boundary not reached     require(         vaultData.stakes.length &lt; MAX_STAKES_PER_VAULT,         ""Hypervisor: MAX_STAKES_PER_VAULT reached""     );      // update cached sum of stake units across all vaults     _updateTotalStakeUnits();      // store amount and timestamp     vaultData.stakes.push(StakeData(amount, block.timestamp));      // update cached total vault and Hypervisor amounts     vaultData.totalStake = vaultData.totalStake.add(amount);     // verify stake quantity without bounds     require(         stakeLimit == 0 || vaultData.totalStake &lt;= stakeLimit,         ""Hypervisor: Stake limit exceeded""     );     _hypervisor.totalStake = _hypervisor.totalStake.add(amount);      // call lock on vault     IUniversalVault(vault).lock(_hypervisor.stakingToken, amount, permission);      // emit event     emit Staked(vault, amount); }  /// @notice Unstake staking tokens and claim reward /// @dev rewards can only be claimed when unstaking /// access control: only owner of vault /// state machine: ///   - when vault exists on this Hypervisor ///   - after stake from vault ///   - can be called multiple times while sufficient stake remains ///   - only online /// state scope: ///   - decrease _hypervisor.rewardSharesOutstanding ///   - decrease _hypervisor.totalStake ///   - increase _hypervisor.lastUpdate ///   - modify _hypervisor.totalStakeUnits ///   - modify _vaults[vault].stakes ///   - decrease _vaults[vault].totalStake /// token transfer: ///   - transfer reward tokens from reward pool to recipient ///   - transfer bonus tokens from reward pool to recipient /// @param vault address The vault to unstake from /// @param amount uint256 The amount of staking tokens to unstake function unstakeAndClaim(     address vault,     uint256 amount,     bytes calldata permission ) external override onlyOnline {     // fetch vault storage reference     VaultData storage vaultData = _vaults[vault];      // verify non-zero amount     require(amount != 0, ""Hypervisor: no amount unstaked"");      address recipient = IUniversalVault(vault).owner();      // validate recipient     _validateAddress(recipient);      // check for sufficient vault stake amount     require(vaultData.totalStake &gt;= amount, ""Hypervisor: insufficient vault stake"");      // check for sufficient Hypervisor stake amount     // if this check fails, there is a bug in stake accounting     assert(_hypervisor.totalStake &gt;= amount);      // update cached sum of stake units across all vaults     _updateTotalStakeUnits();      // get reward amount remaining     uint256 remainingRewards = IERC20(_hypervisor.rewardToken).balanceOf(_hypervisor.rewardPool);      // calculate vested portion of reward pool     uint256 unlockedRewards =         calculateUnlockedRewards(             _hypervisor.rewardSchedules,             remainingRewards,             _hypervisor.rewardSharesOutstanding,             block.timestamp         );      // calculate vault time weighted reward with scaling     RewardOutput memory out =         calculateRewardFromStakes(             vaultData.stakes,             amount,             unlockedRewards,             _hypervisor.totalStakeUnits,             block.timestamp,             _hypervisor.rewardScaling         );      // update stake data in storage     if (out.newStakesCount == 0) {         // all stakes have been unstaked         delete vaultData.stakes;     } else {         // some stakes have been completely or partially unstaked         // delete fully unstaked stakes         while (vaultData.stakes.length &gt; out.newStakesCount) vaultData.stakes.pop();         // update partially unstaked stake         vaultData.stakes[out.newStakesCount.sub(1)].amount = out.lastStakeAmount;     }      // update cached stake totals     vaultData.totalStake = vaultData.totalStake.sub(amount);     _hypervisor.totalStake = _hypervisor.totalStake.sub(amount);     _hypervisor.totalStakeUnits = out.newTotalStakeUnits;      // unlock staking tokens from vault     IUniversalVault(vault).unlock(_hypervisor.stakingToken, amount, permission);      // emit event     emit Unstaked(vault, amount);      // only perform on non-zero reward     if (out.reward &gt; 0) {         // calculate shares to burn         // sharesToBurn = sharesOutstanding * reward / remainingRewards         uint256 sharesToBurn =             _hypervisor.rewardSharesOutstanding.mul(out.reward).div(remainingRewards);          // burn claimed shares         _hypervisor.rewardSharesOutstanding = _hypervisor.rewardSharesOutstanding.sub(sharesToBurn);          // transfer bonus tokens from reward pool to recipient         if (_bonusTokenSet.length() &gt; 0) {             for (uint256 index = 0; index &lt; _bonusTokenSet.length(); index++) {                 // fetch bonus token address reference                 address bonusToken = _bonusTokenSet.at(index);                  // calculate bonus token amount                 // bonusAmount = bonusRemaining * reward / remainingRewards                 uint256 bonusAmount =                     IERC20(bonusToken).balanceOf(_hypervisor.rewardPool).mul(out.reward).div(                         remainingRewards                     );                  // transfer bonus token                 IRewardPool(_hypervisor.rewardPool).sendERC20(bonusToken, recipient, bonusAmount);                  // emit event                 emit RewardClaimed(vault, recipient, bonusToken, bonusAmount);             }         }          // transfer reward tokens from reward pool to recipient         IRewardPool(_hypervisor.rewardPool).sendERC20(_hypervisor.rewardToken, recipient, out.reward);          // emit event         emit RewardClaimed(vault, recipient, _hypervisor.rewardToken, out.reward);     } }  /// @notice Exit Hypervisor without claiming reward /// @dev This function should never revert when correctly called by the vault. ///      A max number of stakes per vault is set with MAX_STAKES_PER_VAULT to ///      place an upper bound on the for loop in calculateTotalStakeUnits(). /// access control: only callable by the vault directly /// state machine: ///   - when vault exists on this Hypervisor ///   - when active stake from this vault ///   - any power state /// state scope: ///   - decrease _hypervisor.totalStake ///   - increase _hypervisor.lastUpdate ///   - modify _hypervisor.totalStakeUnits ///   - delete _vaults[vault] /// token transfer: none function rageQuit() external override {     // fetch vault storage reference     VaultData storage _vaultData = _vaults[msg.sender];      // revert if no active stakes     require(_vaultData.stakes.length != 0, ""Hypervisor: no stake"");      // update cached sum of stake units across all vaults     _updateTotalStakeUnits();      // emit event     emit Unstaked(msg.sender, _vaultData.totalStake);      // update cached totals     _hypervisor.totalStake = _hypervisor.totalStake.sub(_vaultData.totalStake);     _hypervisor.totalStakeUnits = _hypervisor.totalStakeUnits.sub(         calculateTotalStakeUnits(_vaultData.stakes, block.timestamp)     );      // delete stake data     delete _vaults[msg.sender]; }  /* convenience functions */  function _updateTotalStakeUnits() private {     // update cached totalStakeUnits     _hypervisor.totalStakeUnits = getCurrentTotalStakeUnits();     // update cached lastUpdate     _hypervisor.lastUpdate = block.timestamp; }  function _validateAddress(address target) private view {     // sanity check target for potential input errors     require(isValidAddress(target), ""Hypervisor: invalid address""); }  function _truncateStakesArray(StakeData[] memory array, uint256 newLength)     private     pure     returns (StakeData[] memory newArray) {     newArray = new StakeData[](newLength);     for (uint256 index = 0; index &lt; newLength; index++) {         newArray[index] = array[index];     }     return newArray; }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: ""{task}"". Ideas: ""{ideas}"". As the {assistant_role}, your primary objective is to perform a thorough and detailed inspection of the provided contract code, with a particular focus on identifying vulnerabilities related to Funding Rate Calculation Precision. There are two cases where the code may have Funding Rate Calculation Precision vulnerabilities: 1. Simplistic funding rate calculation that does not consider all necessary factors. This can lead to incorrect funding rates, which can be manipulated by providing incorrect input values. A robust funding rate calculation should account for various factors and validations to prevent exploitation. 2. Lack of input validation for critical parameters (e.g., spotPrice, markPrice) used in the funding rate calculation. Malicious actors could potentially manipulate these parameters to influence the funding rate calculation. If you identify a Simplistic funding rate calculation or Lack of input validation, respond with: "" Incorrect Funding Rate Calculation Identified."" For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE ''' DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code ''' If you don't find any vulnerabilities, respond only with: "" NO Incorrect Funding Rate Calculation."" |
| **phase_name** | FundingCalculationDetector |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 1, 'modification_conclusion': '', 'cycle_index': 1, 'task': '// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport {SafeMath} from ""@openzeppelin/contracts/math/SafeMath.sol"";\nimport {EnumerableSet} from ""@openzeppelin/contracts/utils/EnumerableSet.sol"";\nimport {IERC20} from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";\nimport {Ownable} from ""@openzeppelin/contracts/access/Ownable.sol"";\nimport {TransferHelper} from ""@uniswap/lib/contracts/libraries/TransferHelper.sol"";\n\nimport {IFactory} from ""../factory/IFactory.sol"";\nimport {IInstanceRegistry} from ""../factory/InstanceRegistry.sol"";\nimport {IUniversalVault} from ""../visor/Visor.sol"";\nimport {IRewardPool} from ""./RewardPool.sol"";\nimport {Powered} from ""./Powered.sol"";\n\ninterface IRageQuit {\n    function rageQuit() external;\n}\n\ninterface IHypervisor is IRageQuit {\n    / admin events /\n\n    event HypervisorCreated(address rewardPool, address powerSwitch);\n    event HypervisorFunded(uint256 amount, uint256 duration);\n    event BonusTokenRegistered(address token);\n    event VaultFactoryRegistered(address factory);\n    event VaultFactoryRemoved(address factory);\n\n    / user events /\n\n    event Staked(address vault, uint256 amount);\n    event Unstaked(address vault, uint256 amount);\n    event RewardClaimed(address vault, address recipient, address token, uint256 amount);\n\n    / data types /\n\n    struct HypervisorData {\n        address stakingToken;\n        address rewardToken;\n        address rewardPool;\n        RewardScaling rewardScaling;\n        uint256 rewardSharesOutstanding;\n        uint256 totalStake;\n        uint256 totalStakeUnits;\n        uint256 lastUpdate;\n        RewardSchedule[] rewardSchedules;\n    }\n\n    struct RewardSchedule {\n        uint256 duration;\n        uint256 start;\n        uint256 shares;\n    }\n\n    struct VaultData {\n        uint256 totalStake;\n        StakeData[] stakes;\n    }\n\n    struct StakeData {\n        uint256 amount;\n        uint256 timestamp;\n    }\n\n    struct RewardScaling {\n        uint256 floor;\n        uint256 ceiling;\n        uint256 time;\n    }\n\n    struct RewardOutput {\n        uint256 lastStakeAmount;\n        uint256 newStakesCount;\n        uint256 reward;\n        uint256 newTotalStakeUnits;\n    }\n\n    / user functions /\n\n    function stake(\n        address vault,\n        uint256 amount,\n        bytes calldata permission\n    ) external;\n\n    function unstakeAndClaim(\n        address vault,\n        uint256 amount,\n        bytes calldata permission\n    ) external;\n\n    / getter functions /\n\n    function getHypervisorData() external view returns (HypervisorData memory hypervisor);\n\n    function getBonusTokenSetLength() external view returns (uint256 length);\n\n    function getBonusTokenAtIndex(uint256 index) external view returns (address bonusToken);\n\n    function getVaultFactorySetLength() external view returns (uint256 length);\n\n    function getVaultFactoryAtIndex(uint256 index) external view returns (address factory);\n\n    function getVaultData(address vault) external view returns (VaultData memory vaultData);\n\n    function isValidAddress(address target) external view returns (bool validity);\n\n    function isValidVault(address target) external view returns (bool validity);\n\n    function getCurrentUnlockedRewards() external view returns (uint256 unlockedRewards);\n\n    function getFutureUnlockedRewards(uint256 timestamp)\n        external\n        view\n        returns (uint256 unlockedRewards);\n\n    function getCurrentVaultReward(address vault) external view returns (uint256 reward);\n\n    function getCurrentStakeReward(address vault, uint256 stakeAmount)\n        external\n        view\n        returns (uint256 reward);\n\n    function getFutureVaultReward(address vault, uint256 timestamp)\n        external\n        view\n        returns (uint256 reward);\n\n    function getFutureStakeReward(\n        address vault,\n        uint256 stakeAmount,\n        uint256 timestamp\n    ) external view returns (uint256 reward);\n\n    function getCurrentVaultStakeUnits(address vault) external view returns (uint256 stakeUnits);\n\n    function getFutureVaultStakeUnits(address vault, uint256 timestamp)\n        external\n        view\n        returns (uint256 stakeUnits);\n\n    function getCurrentTotalStakeUnits() external view returns (uint256 totalStakeUnits);\n\n    function getFutureTotalStakeUnits(uint256 timestamp)\n        external\n        view\n        returns (uint256 totalStakeUnits);\n\n    / pure functions /\n\n    function calculateTotalStakeUnits(StakeData[] memory stakes, uint256 timestamp)\n        external\n        pure\n        returns (uint256 totalStakeUnits);\n\n    function calculateStakeUnits(\n        uint256 amount,\n        uint256 start,\n        uint256 end\n    ) external pure returns (uint256 stakeUnits);\n\n    function calculateUnlockedRewards(\n        RewardSchedule[] memory rewardSchedules,\n        uint256 rewardBalance,\n        uint256 sharesOutstanding,\n        uint256 timestamp\n    ) external pure returns (uint256 unlockedRewards);\n\n    function calculateRewardFromStakes(\n        StakeData[] memory stakes,\n        uint256 unstakeAmount,\n        uint256 unlockedRewards,\n        uint256 totalStakeUnits,\n        uint256 timestamp,\n        RewardScaling memory rewardScaling\n    ) external pure returns (RewardOutput memory out);\n\n    function calculateReward(\n        uint256 unlockedRewards,\n        uint256 stakeAmount,\n        uint256 stakeDuration,\n        uint256 totalStakeUnits,\n        RewardScaling memory rewardScaling\n    ) external pure returns (uint256 reward);\n}\n\n/// @title Hypervisor\n/// @notice Reward distribution contract with time multiplier\n/// Access Control\n/// - Power controller:\n///     Can power off / shutdown the Hypervisor\n///     Can withdraw rewards from reward pool once shutdown\n/// - Proxy owner:\n///     Can change arbitrary logic / state by upgrading the Hypervisor\n///     Is unable to operate on user funds due to UniversalVault\n///     Is unable to operate on reward pool funds when reward pool is offline / shutdown\n/// - Hypervisor admin:\n///     Can add funds to the Hypervisor, register bonus tokens, and whitelist new vault factories\n///     Is a subset of proxy owner permissions\n/// - User:\n///     Can deposit / withdraw / ragequit\n/// Hypervisor State Machine\n/// - Online:\n///     Hypervisor is operating normally, all functions are enabled\n/// - Offline:\n///     Hypervisor is temporarely disabled for maintenance\n///     User deposits and withdrawls are disabled, ragequit remains enabled\n///     Users can withdraw their stake through rageQuit() but forego their pending reward\n///     Should only be used when downtime required for an upgrade\n/// - Shutdown:\n///     Hypervisor is permanently disabled\n///     All functions are disabled with the exception of ragequit\n///     Users can withdraw their stake through rageQuit()\n///     Power controller can withdraw from the reward pool\n///     Should only be used if Proxy Owner role is compromized\ncontract Hypervisor is IHypervisor, Powered, Ownable {\n    using SafeMath for uint256;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    / constants /\n\n    // An upper bound on the number of active stakes per vault is required to prevent\n    // calls to rageQuit() from reverting.\n    // With 30 stakes in a vault, ragequit costs 432811 gas which is conservatively lower\n    // than the hardcoded limit of 500k gas on the vault.\n    // This limit is configurable and could be increased in a future deployment.\n    // Ultimately, to avoid a need for fixed upper bounds, the EVM would need to provide\n    // an error code that allows for reliably catching out-of-gas errors on remote calls.\n    uint256 public constant MAX_STAKES_PER_VAULT = 30;\n    uint256 public constant MAX_REWARD_TOKENS = 50;\n    uint256 public constant BASE_SHARES_PER_WEI = 1000000;\n    uint256 public stakeLimit = 2500 ether;\n\n    / storage /\n\n    HypervisorData private _hypervisor;\n    mapping(address =&gt; VaultData) private _vaults;\n    EnumerableSet.AddressSet private _bonusTokenSet;\n    EnumerableSet.AddressSet private _vaultFactorySet;\n\n    / initializer /\n\n    /// @notice Initizalize Hypervisor\n    /// access control: only proxy constructor\n    /// state machine: can only be called once\n    /// state scope: set initialization variables\n    /// token transfer: none\n    /// @param ownerAddress address The admin address\n    /// @param rewardPoolFactory address The factory to use for deploying the RewardPool\n    /// @param powerSwitchFactory address The factory to use for deploying the PowerSwitch\n    /// @param stakingToken address The address of the staking token for this Hypervisor\n    /// @param rewardToken address The address of the reward token for this Hypervisor\n    /// @param rewardScaling RewardScaling The config for reward scaling floor, ceiling, and time\n    constructor(\n        address ownerAddress,\n        address rewardPoolFactory,\n        address powerSwitchFactory,\n        address stakingToken,\n        address rewardToken,\n        RewardScaling memory rewardScaling,\n        uint256 _stakeLimit\n    ) {\n        // the scaling floor must be smaller than ceiling\n        require(rewardScaling.floor &lt;= rewardScaling.ceiling, ""Hypervisor: floor above ceiling"");\n\n        // setting rewardScalingTime to 0 would cause divide by zero error\n        // to disable reward scaling, use rewardScalingFloor == rewardScalingCeiling\n        require(rewardScaling.time != 0, ""Hypervisor: scaling time cannot be zero"");\n\n        // deploy power switch\n        address powerSwitch = IFactory(powerSwitchFactory).create(abi.encode(ownerAddress));\n\n        // deploy reward pool\n        address rewardPool = IFactory(rewardPoolFactory).create(abi.encode(powerSwitch));\n\n        // set internal configs\n        Ownable.transferOwnership(ownerAddress);\n        Powered._setPowerSwitch(powerSwitch);\n\n        // commit to storage\n        _hypervisor.stakingToken = stakingToken;\n        _hypervisor.rewardToken = rewardToken;\n        _hypervisor.rewardPool = rewardPool;\n        _hypervisor.rewardScaling = rewardScaling;\n\n        stakeLimit = _stakeLimit;\n\n        // emit event\n        emit HypervisorCreated(rewardPool, powerSwitch);\n    }\n\n    / getter functions /\n\n    function getBonusTokenSetLength() external view override returns (uint256 length) {\n        return _bonusTokenSet.length();\n    }\n\n    function getBonusTokenAtIndex(uint256 index)\n        external\n        view\n        override\n        returns (address bonusToken)\n    {\n        return _bonusTokenSet.at(index);\n    }\n\n    function getVaultFactorySetLength() external view override returns (uint256 length) {\n        return _vaultFactorySet.length();\n    }\n\n    function getVaultFactoryAtIndex(uint256 index)\n        external\n        view\n        override\n        returns (address factory)\n    {\n        return _vaultFactorySet.at(index);\n    }\n\n    function isValidVault(address target) public view override returns (bool validity) {\n        // validate target is created from whitelisted vault factory\n        for (uint256 index = 0; index &lt; _vaultFactorySet.length(); index++) {\n            if (IInstanceRegistry(_vaultFactorySet.at(index)).isInstance(target)) {\n                return true;\n            }\n        }\n        // explicit return\n        return false;\n    }\n\n    function isValidAddress(address target) public view override returns (bool validity) {\n        // sanity check target for potential input errors\n        return\n            target != address(this) &amp;&amp;\n            target != address(0) &amp;&amp;\n            target != _hypervisor.stakingToken &amp;&amp;\n            target != _hypervisor.rewardToken &amp;&amp;\n            target != _hypervisor.rewardPool &amp;&amp;\n            !_bonusTokenSet.contains(target);\n    }\n\n    / Hypervisor getters /\n\n    function getHypervisorData() external view override returns (HypervisorData memory hypervisor) {\n        return _hypervisor;\n    }\n\n    function getCurrentUnlockedRewards() public view override returns (uint256 unlockedRewards) {\n        // calculate reward available based on state\n        return getFutureUnlockedRewards(block.timestamp);\n    }\n\n    function getFutureUnlockedRewards(uint256 timestamp)\n        public\n        view\n        override\n        returns (uint256 unlockedRewards)\n    {\n        // get reward amount remaining\n        uint256 remainingRewards = IERC20(_hypervisor.rewardToken).balanceOf(_hypervisor.rewardPool);\n        // calculate reward available based on state\n        unlockedRewards = calculateUnlockedRewards(\n            _hypervisor.rewardSchedules,\n            remainingRewards,\n            _hypervisor.rewardSharesOutstanding,\n            timestamp\n        );\n        // explicit return\n        return unlockedRewards;\n    }\n\n    function getCurrentTotalStakeUnits() public view override returns (uint256 totalStakeUnits) {\n        // calculate new stake units\n        return getFutureTotalStakeUnits(block.timestamp);\n    }\n\n    function getFutureTotalStakeUnits(uint256 timestamp)\n        public\n        view\n        override\n        returns (uint256 totalStakeUnits)\n    {\n        // return early if no change\n        if (timestamp == _hypervisor.lastUpdate) return _hypervisor.totalStakeUnits;\n        // calculate new stake units\n        uint256 newStakeUnits =\n            calculateStakeUnits(_hypervisor.totalStake, _hypervisor.lastUpdate, timestamp);\n        // add to cached total\n        totalStakeUnits = _hypervisor.totalStakeUnits.add(newStakeUnits);\n        // explicit return\n        return totalStakeUnits;\n    }\n\n    / vault getters /\n\n    function getVaultData(address vault)\n        external\n        view\n        override\n        returns (VaultData memory vaultData)\n    {\n        return _vaults[vault];\n    }\n\n    function getCurrentVaultReward(address vault) external view override returns (uint256 reward) {\n        // calculate rewards\n        return\n            calculateRewardFromStakes(\n                _vaults[vault]\n                    .stakes,\n                _vaults[vault]\n                    .totalStake,\n                getCurrentUnlockedRewards(),\n                getCurrentTotalStakeUnits(),\n                block\n                    .timestamp,\n                _hypervisor\n                    .rewardScaling\n            )\n                .reward;\n    }\n\n    function getFutureVaultReward(address vault, uint256 timestamp)\n        external\n        view\n        override\n        returns (uint256 reward)\n    {\n        // calculate rewards\n        return\n            calculateRewardFromStakes(\n                _vaults[vault]\n                    .stakes,\n                _vaults[vault]\n                    .totalStake,\n                getFutureUnlockedRewards(timestamp),\n                getFutureTotalStakeUnits(timestamp),\n                timestamp,\n                _hypervisor\n                    .rewardScaling\n            )\n                .reward;\n    }\n\n    function getCurrentStakeReward(address vault, uint256 stakeAmount)\n        external\n        view\n        override\n        returns (uint256 reward)\n    {\n        // calculate rewards\n        return\n            calculateRewardFromStakes(\n                _vaults[vault]\n                    .stakes,\n                stakeAmount,\n                getCurrentUnlockedRewards(),\n                getCurrentTotalStakeUnits(),\n                block\n                    .timestamp,\n                _hypervisor\n                    .rewardScaling\n            )\n                .reward;\n    }\n\n    function getFutureStakeReward(\n        address vault,\n        uint256 stakeAmount,\n        uint256 timestamp\n    ) external view override returns (uint256 reward) {\n        // calculate rewards\n        return\n            calculateRewardFromStakes(\n                _vaults[vault]\n                    .stakes,\n                stakeAmount,\n                getFutureUnlockedRewards(timestamp),\n                getFutureTotalStakeUnits(timestamp),\n                timestamp,\n                _hypervisor\n                    .rewardScaling\n            )\n                .reward;\n    }\n\n    function getCurrentVaultStakeUnits(address vault)\n        public\n        view\n        override\n        returns (uint256 stakeUnits)\n    {\n        // calculate stake units\n        return getFutureVaultStakeUnits(vault, block.timestamp);\n    }\n\n    function getFutureVaultStakeUnits(address vault, uint256 timestamp)\n        public\n        view\n        override\n        returns (uint256 stakeUnits)\n    {\n        // calculate stake units\n        return calculateTotalStakeUnits(_vaults[vault].stakes, timestamp);\n    }\n\n    / pure functions /\n\n    function calculateTotalStakeUnits(StakeData[] memory stakes, uint256 timestamp)\n        public\n        pure\n        override\n        returns (uint256 totalStakeUnits)\n    {\n        for (uint256 index; index &lt; stakes.length; index++) {\n            // reference stake\n            StakeData memory stakeData = stakes[index];\n            // calculate stake units\n            uint256 stakeUnits =\n                calculateStakeUnits(stakeData.amount, stakeData.timestamp, timestamp);\n            // add to running total\n            totalStakeUnits = totalStakeUnits.add(stakeUnits);\n        }\n    }\n\n    function calculateStakeUnits(\n        uint256 amount,\n        uint256 start,\n        uint256 end\n    ) public pure override returns (uint256 stakeUnits) {\n        // calculate duration\n        uint256 duration = end.sub(start);\n        // calculate stake units\n        stakeUnits = duration.mul(amount);\n        // explicit return\n        return stakeUnits;\n    }\n\n    function calculateUnlockedRewards(\n        RewardSchedule[] memory rewardSchedules,\n        uint256 rewardBalance,\n        uint256 sharesOutstanding,\n        uint256 timestamp\n    ) public pure override returns (uint256 unlockedRewards) {\n        // return 0 if no registered schedules\n        if (rewardSchedules.length == 0) {\n            return 0;\n        }\n\n        // calculate reward shares locked across all reward schedules\n        uint256 sharesLocked;\n        for (uint256 index = 0; index &lt; rewardSchedules.length; index++) {\n            // fetch reward schedule storage reference\n            RewardSchedule memory schedule = rewardSchedules[index];\n\n            // caculate amount of shares available on this schedule\n            // if (now - start) &lt; duration\n            //   sharesLocked = shares - (shares * (now - start) / duration)\n            // else\n            //   sharesLocked = 0\n            uint256 currentSharesLocked = 0;\n            if (timestamp.sub(schedule.start) &lt; schedule.duration) {\n                currentSharesLocked = schedule.shares.sub(\n                    schedule.shares.mul(timestamp.sub(schedule.start)).div(schedule.duration)\n                );\n            }\n\n            // add to running total\n            sharesLocked = sharesLocked.add(currentSharesLocked);\n        }\n\n        // convert shares to reward\n        // rewardLocked = sharesLocked * rewardBalance / sharesOutstanding\n        uint256 rewardLocked = sharesLocked.mul(rewardBalance).div(sharesOutstanding);\n\n        // calculate amount available\n        // unlockedRewards = rewardBalance - rewardLocked\n        unlockedRewards = rewardBalance.sub(rewardLocked);\n\n        // explicit return\n        return unlockedRewards;\n    }\n\n    function calculateRewardFromStakes(\n        StakeData[] memory stakes,\n        uint256 unstakeAmount,\n        uint256 unlockedRewards,\n        uint256 totalStakeUnits,\n        uint256 timestamp,\n        RewardScaling memory rewardScaling\n    ) public pure override returns (RewardOutput memory out) {\n        uint256 stakesToDrop = 0;\n        while (unstakeAmount &gt; 0) {\n            // fetch vault stake storage reference\n            StakeData memory lastStake = stakes[stakes.length.sub(stakesToDrop).sub(1)];\n\n            // calculate stake duration\n            uint256 stakeDuration = timestamp.sub(lastStake.timestamp);\n\n            uint256 currentAmount;\n            if (lastStake.amount &gt; unstakeAmount) {\n                // set current amount to remaining unstake amount\n                currentAmount = unstakeAmount;\n                // amount of last stake is reduced\n                out.lastStakeAmount = lastStake.amount.sub(unstakeAmount);\n            } else {\n                // set current amount to amount of last stake\n                currentAmount = lastStake.amount;\n                // add to stakes to drop\n                stakesToDrop += 1;\n            }\n\n            // update remaining unstakeAmount\n            unstakeAmount = unstakeAmount.sub(currentAmount);\n\n            // calculate reward amount\n            uint256 currentReward =\n                calculateReward(\n                    unlockedRewards,\n                    currentAmount,\n                    stakeDuration,\n                    totalStakeUnits,\n                    rewardScaling\n                );\n\n            // update cumulative reward\n            out.reward = out.reward.add(currentReward);\n\n            // update cached unlockedRewards\n            unlockedRewards = unlockedRewards.sub(currentReward);\n\n            // calculate time weighted stake\n            uint256 stakeUnits = currentAmount.mul(stakeDuration);\n\n            // update cached totalStakeUnits\n            totalStakeUnits = totalStakeUnits.sub(stakeUnits);\n        }\n\n        // explicit return\n        return\n            RewardOutput(\n                out.lastStakeAmount,\n                stakes.length.sub(stakesToDrop),\n                out.reward,\n                totalStakeUnits\n            );\n    }\n\n    function calculateReward(\n        uint256 unlockedRewards,\n        uint256 stakeAmount,\n        uint256 stakeDuration,\n        uint256 totalStakeUnits,\n        RewardScaling memory rewardScaling\n    ) public pure override returns (uint256 reward) {\n        // calculate time weighted stake\n        uint256 stakeUnits = stakeAmount.mul(stakeDuration);\n\n        // calculate base reward\n        // baseReward = unlockedRewards * stakeUnits / totalStakeUnits\n        uint256 baseReward = 0;\n        if (totalStakeUnits != 0) {\n            // scale reward according to proportional weight\n            baseReward = unlockedRewards.mul(stakeUnits).div(totalStakeUnits);\n        }\n\n        // calculate scaled reward\n        // if no scaling or scaling period completed\n        //   reward = baseReward\n        // else\n        //   minReward = baseReward * scalingFloor / scalingCeiling\n        //   bonusReward = baseReward\n        //                 * (scalingCeiling - scalingFloor) / scalingCeiling\n        //                 * duration / scalingTime\n        //   reward = minReward + bonusReward\n        if (stakeDuration &gt;= rewardScaling.time || rewardScaling.floor == rewardScaling.ceiling) {\n            // no reward scaling applied\n            reward = baseReward;\n        } else {\n            // calculate minimum reward using scaling floor\n            uint256 minReward = baseReward.mul(rewardScaling.floor).div(rewardScaling.ceiling);\n\n            // calculate bonus reward with vested portion of scaling factor\n            uint256 bonusReward =\n                baseReward\n                    .mul(stakeDuration)\n                    .mul(rewardScaling.ceiling.sub(rewardScaling.floor))\n                    .div(rewardScaling.ceiling)\n                    .div(rewardScaling.time);\n\n            // add minimum reward and bonus reward\n            reward = minReward.add(bonusReward);\n        }\n\n        // explicit return\n        return reward;\n    }\n\n    / admin functions /\n\n    /// @notice Add funds to the Hypervisor\n    /// access control: only admin\n    /// state machine:\n    ///   - can be called multiple times\n    ///   - only online\n    /// state scope:\n    ///   - increase _hypervisor.rewardSharesOutstanding\n    ///   - append to _hypervisor.rewardSchedules\n    /// token transfer: transfer staking tokens from msg.sender to reward pool\n    /// @param amount uint256 Amount of reward tokens to deposit\n    /// @param duration uint256 Duration over which to linearly unlock rewards\n    function fund(uint256 amount, uint256 duration) external onlyOwner onlyOnline {\n        // validate duration\n        require(duration != 0, ""Hypervisor: invalid duration"");\n\n        // create new reward shares\n        // if existing rewards on this Hypervisor\n        //   mint new shares proportional to % change in rewards remaining\n        //   newShares = remainingShares * newReward / remainingRewards\n        // else\n        //   mint new shares with BASE_SHARES_PER_WEI initial conversion rate\n        //   store as fixed point number with same  of decimals as reward token\n        uint256 newRewardShares;\n        if (_hypervisor.rewardSharesOutstanding &gt; 0) {\n            uint256 remainingRewards = IERC20(_hypervisor.rewardToken).balanceOf(_hypervisor.rewardPool);\n            newRewardShares = _hypervisor.rewardSharesOutstanding.mul(amount).div(remainingRewards);\n        } else {\n            newRewardShares = amount.mul(BASE_SHARES_PER_WEI);\n        }\n\n        // add reward shares to total\n        _hypervisor.rewardSharesOutstanding = _hypervisor.rewardSharesOutstanding.add(newRewardShares);\n\n        // store new reward schedule\n        _hypervisor.rewardSchedules.push(RewardSchedule(duration, block.timestamp, newRewardShares));\n\n        // transfer reward tokens to reward pool\n        TransferHelper.safeTransferFrom(\n            _hypervisor.rewardToken,\n            msg.sender,\n            _hypervisor.rewardPool,\n            amount\n        );\n\n        // emit event\n        emit HypervisorFunded(amount, duration);\n    }\n\n    /// @notice Add vault factory to whitelist\n    /// @dev use this function to enable stakes to vaults coming from the specified\n    ///      factory contract\n    /// access control: only admin\n    /// state machine:\n    ///   - can be called multiple times\n    ///   - not shutdown\n    /// state scope:\n    ///   - append to _vaultFactorySet\n    /// token transfer: none\n    /// @param factory address The address of the vault factory\n    function registerVaultFactory(address factory) external onlyOwner notShutdown {\n        // add factory to set\n        require(_vaultFactorySet.add(factory), ""Hypervisor: vault factory already registered"");\n\n        // emit event\n        emit VaultFactoryRegistered(factory);\n    }\n\n    /// @notice Remove vault factory from whitelist\n    /// @dev use this function to disable new stakes to vaults coming from the specified\n    ///      factory contract.\n    ///      note: vaults with existing stakes from this factory are sill able to unstake\n    /// access control: only admin\n    /// state machine:\n    ///   - can be called multiple times\n    ///   - not shutdown\n    /// state scope:\n    ///   - remove from _vaultFactorySet\n    /// token transfer: none\n    /// @param factory address The address of the vault factory\n    function removeVaultFactory(address factory) external onlyOwner notShutdown {\n        // remove factory from set\n        require(_vaultFactorySet.remove(factory), ""Hypervisor: vault factory not registered"");\n\n        // emit event\n        emit VaultFactoryRemoved(factory);\n    }\n\n    /// @notice Register bonus token for distribution\n    /// @dev use this function to enable distribution of any ERC20 held by the RewardPool contract\n    /// access control: only admin\n    /// state machine:\n    ///   - can be called multiple times\n    ///   - only online\n    /// state scope:\n    ///   - append to _bonusTokenSet\n    /// token transfer: none\n    /// @param bonusToken address The address of the bonus token\n    function registerBonusToken(address bonusToken) external onlyOwner onlyOnline {\n        // verify valid bonus token\n        _validateAddress(bonusToken);\n\n        // verify bonus token count\n        require(_bonusTokenSet.length() &lt; MAX_REWARD_TOKENS, ""Hypervisor: max bonus tokens reached "");\n\n        // add token to set\n        assert(_bonusTokenSet.add(bonusToken));\n\n        // emit event\n        emit BonusTokenRegistered(bonusToken);\n    }\n\n    /// @notice Rescue tokens from RewardPool\n    /// @dev use this function to rescue tokens from RewardPool contract\n    ///      without distributing to stakers or triggering emergency shutdown\n    /// access control: only admin\n    /// state machine:\n    ///   - can be called multiple times\n    ///   - only online\n    /// state scope: none\n    /// token transfer: transfer requested token from RewardPool to recipient\n    /// @param token address The address of the token to rescue\n    /// @param recipient address The address of the recipient\n    /// @param amount uint256 The amount of tokens to rescue\n    function rescueTokensFromRewardPool(\n        address token,\n        address recipient,\n        uint256 amount\n    ) external onlyOwner onlyOnline {\n        // verify recipient\n        _validateAddress(recipient);\n\n        // check not attempting to unstake reward token\n        require(token != _hypervisor.rewardToken, ""Hypervisor: invalid address"");\n\n        // check not attempting to wthdraw bonus token\n        require(!_bonusTokenSet.contains(token), ""Hypervisor: invalid address"");\n\n        // transfer tokens to recipient\n        IRewardPool(_hypervisor.rewardPool).sendERC20(token, recipient, amount);\n    }\n\n    / user functions /\n\n    /// @notice Stake tokens\n    /// @dev anyone can stake to any vault if they have valid permission\n    /// access control: anyone\n    /// state machine:\n    ///   - can be called multiple times\n    ///   - only online\n    ///   - when vault exists on this Hypervisor\n    /// state scope:\n    ///   - append to _vaults[vault].stakes\n    ///   - increase _vaults[vault].totalStake\n    ///   - increase _hypervisor.totalStake\n    ///   - increase _hypervisor.totalStakeUnits\n    ///   - increase _hypervisor.lastUpdate\n    /// token transfer: transfer staking tokens from msg.sender to vault\n    /// @param vault address The address of the vault to stake from\n    /// @param amount uint256 The amount of staking tokens to stake\n    function stake(\n        address vault,\n        uint256 amount,\n        bytes calldata permission\n    ) external override onlyOnline {\n        // verify vault is valid\n        require(isValidVault(vault), ""Hypervisor: vault is not registered"");\n\n        // verify non-zero amount\n        require(amount != 0, ""Hypervisor: no amount staked"");\n\n        // fetch vault storage reference\n        VaultData storage vaultData = _vaults[vault];\n\n        // verify stakes boundary not reached\n        require(\n            vaultData.stakes.length &lt; MAX_STAKES_PER_VAULT,\n            ""Hypervisor: MAX_STAKES_PER_VAULT reached""\n        );\n\n        // update cached sum of stake units across all vaults\n        _updateTotalStakeUnits();\n\n        // store amount and timestamp\n        vaultData.stakes.push(StakeData(amount, block.timestamp));\n\n        // update cached total vault and Hypervisor amounts\n        vaultData.totalStake = vaultData.totalStake.add(amount);\n        // verify stake quantity without bounds\n        require(\n            stakeLimit == 0 || vaultData.totalStake &lt;= stakeLimit,\n            ""Hypervisor: Stake limit exceeded""\n        );\n        _hypervisor.totalStake = _hypervisor.totalStake.add(amount);\n\n        // call lock on vault\n        IUniversalVault(vault).lock(_hypervisor.stakingToken, amount, permission);\n\n        // emit event\n        emit Staked(vault, amount);\n    }\n\n    /// @notice Unstake staking tokens and claim reward\n    /// @dev rewards can only be claimed when unstaking\n    /// access control: only owner of vault\n    /// state machine:\n    ///   - when vault exists on this Hypervisor\n    ///   - after stake from vault\n    ///   - can be called multiple times while sufficient stake remains\n    ///   - only online\n    /// state scope:\n    ///   - decrease _hypervisor.rewardSharesOutstanding\n    ///   - decrease _hypervisor.totalStake\n    ///   - increase _hypervisor.lastUpdate\n    ///   - modify _hypervisor.totalStakeUnits\n    ///   - modify _vaults[vault].stakes\n    ///   - decrease _vaults[vault].totalStake\n    /// token transfer:\n    ///   - transfer reward tokens from reward pool to recipient\n    ///   - transfer bonus tokens from reward pool to recipient\n    /// @param vault address The vault to unstake from\n    /// @param amount uint256 The amount of staking tokens to unstake\n    function unstakeAndClaim(\n        address vault,\n        uint256 amount,\n        bytes calldata permission\n    ) external override onlyOnline {\n        // fetch vault storage reference\n        VaultData storage vaultData = _vaults[vault];\n\n        // verify non-zero amount\n        require(amount != 0, ""Hypervisor: no amount unstaked"");\n\n        address recipient = IUniversalVault(vault).owner();\n\n        // validate recipient\n        _validateAddress(recipient);\n\n        // check for sufficient vault stake amount\n        require(vaultData.totalStake &gt;= amount, ""Hypervisor: insufficient vault stake"");\n\n        // check for sufficient Hypervisor stake amount\n        // if this check fails, there is a bug in stake accounting\n        assert(_hypervisor.totalStake &gt;= amount);\n\n        // update cached sum of stake units across all vaults\n        _updateTotalStakeUnits();\n\n        // get reward amount remaining\n        uint256 remainingRewards = IERC20(_hypervisor.rewardToken).balanceOf(_hypervisor.rewardPool);\n\n        // calculate vested portion of reward pool\n        uint256 unlockedRewards =\n            calculateUnlockedRewards(\n                _hypervisor.rewardSchedules,\n                remainingRewards,\n                _hypervisor.rewardSharesOutstanding,\n                block.timestamp\n            );\n\n        // calculate vault time weighted reward with scaling\n        RewardOutput memory out =\n            calculateRewardFromStakes(\n                vaultData.stakes,\n                amount,\n                unlockedRewards,\n                _hypervisor.totalStakeUnits,\n                block.timestamp,\n                _hypervisor.rewardScaling\n            );\n\n        // update stake data in storage\n        if (out.newStakesCount == 0) {\n            // all stakes have been unstaked\n            delete vaultData.stakes;\n        } else {\n            // some stakes have been completely or partially unstaked\n            // delete fully unstaked stakes\n            while (vaultData.stakes.length &gt; out.newStakesCount) vaultData.stakes.pop();\n            // update partially unstaked stake\n            vaultData.stakes[out.newStakesCount.sub(1)].amount = out.lastStakeAmount;\n        }\n\n        // update cached stake totals\n        vaultData.totalStake = vaultData.totalStake.sub(amount);\n        _hypervisor.totalStake = _hypervisor.totalStake.sub(amount);\n        _hypervisor.totalStakeUnits = out.newTotalStakeUnits;\n\n        // unlock staking tokens from vault\n        IUniversalVault(vault).unlock(_hypervisor.stakingToken, amount, permission);\n\n        // emit event\n        emit Unstaked(vault, amount);\n\n        // only perform on non-zero reward\n        if (out.reward &gt; 0) {\n            // calculate shares to burn\n            // sharesToBurn = sharesOutstanding * reward / remainingRewards\n            uint256 sharesToBurn =\n                _hypervisor.rewardSharesOutstanding.mul(out.reward).div(remainingRewards);\n\n            // burn claimed shares\n            _hypervisor.rewardSharesOutstanding = _hypervisor.rewardSharesOutstanding.sub(sharesToBurn);\n\n            // transfer bonus tokens from reward pool to recipient\n            if (_bonusTokenSet.length() &gt; 0) {\n                for (uint256 index = 0; index &lt; _bonusTokenSet.length(); index++) {\n                    // fetch bonus token address reference\n                    address bonusToken = _bonusTokenSet.at(index);\n\n                    // calculate bonus token amount\n                    // bonusAmount = bonusRemaining * reward / remainingRewards\n                    uint256 bonusAmount =\n                        IERC20(bonusToken).balanceOf(_hypervisor.rewardPool).mul(out.reward).div(\n                            remainingRewards\n                        );\n\n                    // transfer bonus token\n                    IRewardPool(_hypervisor.rewardPool).sendERC20(bonusToken, recipient, bonusAmount);\n\n                    // emit event\n                    emit RewardClaimed(vault, recipient, bonusToken, bonusAmount);\n                }\n            }\n\n            // transfer reward tokens from reward pool to recipient\n            IRewardPool(_hypervisor.rewardPool).sendERC20(_hypervisor.rewardToken, recipient, out.reward);\n\n            // emit event\n            emit RewardClaimed(vault, recipient, _hypervisor.rewardToken, out.reward);\n        }\n    }\n\n    /// @notice Exit Hypervisor without claiming reward\n    /// @dev This function should never revert when correctly called by the vault.\n    ///      A max number of stakes per vault is set with MAX_STAKES_PER_VAULT to\n    ///      place an upper bound on the for loop in calculateTotalStakeUnits().\n    /// access control: only callable by the vault directly\n    /// state machine:\n    ///   - when vault exists on this Hypervisor\n    ///   - when active stake from this vault\n    ///   - any power state\n    /// state scope:\n    ///   - decrease _hypervisor.totalStake\n    ///   - increase _hypervisor.lastUpdate\n    ///   - modify _hypervisor.totalStakeUnits\n    ///   - delete _vaults[vault]\n    /// token transfer: none\n    function rageQuit() external override {\n        // fetch vault storage reference\n        VaultData storage _vaultData = _vaults[msg.sender];\n\n        // revert if no active stakes\n        require(_vaultData.stakes.length != 0, ""Hypervisor: no stake"");\n\n        // update cached sum of stake units across all vaults\n        _updateTotalStakeUnits();\n\n        // emit event\n        emit Unstaked(msg.sender, _vaultData.totalStake);\n\n        // update cached totals\n        _hypervisor.totalStake = _hypervisor.totalStake.sub(_vaultData.totalStake);\n        _hypervisor.totalStakeUnits = _hypervisor.totalStakeUnits.sub(\n            calculateTotalStakeUnits(_vaultData.stakes, block.timestamp)\n        );\n\n        // delete stake data\n        delete _vaults[msg.sender];\n    }\n\n    / convenience functions /\n\n    function _updateTotalStakeUnits() private {\n        // update cached totalStakeUnits\n        _hypervisor.totalStakeUnits = getCurrentTotalStakeUnits();\n        // update cached lastUpdate\n        _hypervisor.lastUpdate = block.timestamp;\n    }\n\n    function _validateAddress(address target) private view {\n        // sanity check target for potential input errors\n        require(isValidAddress(target), ""Hypervisor: invalid address"");\n    }\n\n    function _truncateStakesArray(StakeData[] memory array, uint256 newLength)\n        private\n        pure\n        returns (StakeData[] memory newArray)\n    {\n        newArray = new StakeData;\n        for (uint256 index = 0; index &lt; newLength; index++) {\n            newArray[index] = array[index];\n        }\n        return newArray;\n    }\n}\n', 'ideas': "" Centralization Risk Identified.\n\nOwnership Hijacking\n'''\nThe contract uses the Ownable pattern, which centralizes control in a single address (the owner). If the owner's private key is compromised, an attacker could gain full control over the contract, allowing them to execute any function that requires ownership, such as fund, registerVaultFactory, removeVaultFactory, and rescueTokensFromRewardPool. This poses a significant risk to the integrity of the contract and the funds within it.\n\nRecommended Mitigation/Fix:\nImplement a multi-signature wallet for critical functions that require ownership. This would distribute control among multiple trusted parties, reducing the risk of a single point of failure. Additionally, consider implementing a time-lock mechanism for sensitive operations to provide a buffer period during which stakeholders can react to potentially malicious actions.\n'''""} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-02-08 00:45:09 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **task_prompt** | // SPDX-License-Identifier: GPL-3.0-only pragma solidity 0.7.6; pragma abicoder v2; import {SafeMath} from ""@openzeppelin/contracts/math/SafeMath.sol""; import {EnumerableSet} from ""@openzeppelin/contracts/utils/EnumerableSet.sol""; import {IERC20} from ""@openzeppelin/contracts/token/ERC20/IERC20.sol""; import {Ownable} from ""@openzeppelin/contracts/access/Ownable.sol""; import {TransferHelper} from ""@uniswap/lib/contracts/libraries/TransferHelper.sol""; import {IFactory} from ""../factory/IFactory.sol""; import {IInstanceRegistry} from ""../factory/InstanceRegistry.sol""; import {IUniversalVault} from ""../visor/Visor.sol""; import {IRewardPool} from ""./RewardPool.sol""; import {Powered} from ""./Powered.sol""; interface IRageQuit {     function rageQuit() external; } interface IHypervisor is IRageQuit {     / admin events / event HypervisorCreated(address rewardPool, address powerSwitch); event HypervisorFunded(uint256 amount, uint256 duration); event BonusTokenRegistered(address token); event VaultFactoryRegistered(address factory); event VaultFactoryRemoved(address factory);  /* user events */  event Staked(address vault, uint256 amount); event Unstaked(address vault, uint256 amount); event RewardClaimed(address vault, address recipient, address token, uint256 amount);  /* data types */  struct HypervisorData {     address stakingToken;     address rewardToken;     address rewardPool;     RewardScaling rewardScaling;     uint256 rewardSharesOutstanding;     uint256 totalStake;     uint256 totalStakeUnits;     uint256 lastUpdate;     RewardSchedule[] rewardSchedules; }  struct RewardSchedule {     uint256 duration;     uint256 start;     uint256 shares; }  struct VaultData {     uint256 totalStake;     StakeData[] stakes; }  struct StakeData {     uint256 amount;     uint256 timestamp; }  struct RewardScaling {     uint256 floor;     uint256 ceiling;     uint256 time; }  struct RewardOutput {     uint256 lastStakeAmount;     uint256 newStakesCount;     uint256 reward;     uint256 newTotalStakeUnits; }  /* user functions */  function stake(     address vault,     uint256 amount,     bytes calldata permission ) external;  function unstakeAndClaim(     address vault,     uint256 amount,     bytes calldata permission ) external;  /* getter functions */  function getHypervisorData() external view returns (HypervisorData memory hypervisor);  function getBonusTokenSetLength() external view returns (uint256 length);  function getBonusTokenAtIndex(uint256 index) external view returns (address bonusToken);  function getVaultFactorySetLength() external view returns (uint256 length);  function getVaultFactoryAtIndex(uint256 index) external view returns (address factory);  function getVaultData(address vault) external view returns (VaultData memory vaultData);  function isValidAddress(address target) external view returns (bool validity);  function isValidVault(address target) external view returns (bool validity);  function getCurrentUnlockedRewards() external view returns (uint256 unlockedRewards);  function getFutureUnlockedRewards(uint256 timestamp)     external     view     returns (uint256 unlockedRewards);  function getCurrentVaultReward(address vault) external view returns (uint256 reward);  function getCurrentStakeReward(address vault, uint256 stakeAmount)     external     view     returns (uint256 reward);  function getFutureVaultReward(address vault, uint256 timestamp)     external     view     returns (uint256 reward);  function getFutureStakeReward(     address vault,     uint256 stakeAmount,     uint256 timestamp ) external view returns (uint256 reward);  function getCurrentVaultStakeUnits(address vault) external view returns (uint256 stakeUnits);  function getFutureVaultStakeUnits(address vault, uint256 timestamp)     external     view     returns (uint256 stakeUnits);  function getCurrentTotalStakeUnits() external view returns (uint256 totalStakeUnits);  function getFutureTotalStakeUnits(uint256 timestamp)     external     view     returns (uint256 totalStakeUnits);  /* pure functions */  function calculateTotalStakeUnits(StakeData[] memory stakes, uint256 timestamp)     external     pure     returns (uint256 totalStakeUnits);  function calculateStakeUnits(     uint256 amount,     uint256 start,     uint256 end ) external pure returns (uint256 stakeUnits);  function calculateUnlockedRewards(     RewardSchedule[] memory rewardSchedules,     uint256 rewardBalance,     uint256 sharesOutstanding,     uint256 timestamp ) external pure returns (uint256 unlockedRewards);  function calculateRewardFromStakes(     StakeData[] memory stakes,     uint256 unstakeAmount,     uint256 unlockedRewards,     uint256 totalStakeUnits,     uint256 timestamp,     RewardScaling memory rewardScaling ) external pure returns (RewardOutput memory out);  function calculateReward(     uint256 unlockedRewards,     uint256 stakeAmount,     uint256 stakeDuration,     uint256 totalStakeUnits,     RewardScaling memory rewardScaling ) external pure returns (uint256 reward);  } /// @title Hypervisor /// @notice Reward distribution contract with time multiplier /// Access Control /// - Power controller: ///     Can power off / shutdown the Hypervisor ///     Can withdraw rewards from reward pool once shutdown /// - Proxy owner: ///     Can change arbitrary logic / state by upgrading the Hypervisor ///     Is unable to operate on user funds due to UniversalVault ///     Is unable to operate on reward pool funds when reward pool is offline / shutdown /// - Hypervisor admin: ///     Can add funds to the Hypervisor, register bonus tokens, and whitelist new vault factories ///     Is a subset of proxy owner permissions /// - User: ///     Can deposit / withdraw / ragequit /// Hypervisor State Machine /// - Online: ///     Hypervisor is operating normally, all functions are enabled /// - Offline: ///     Hypervisor is temporarely disabled for maintenance ///     User deposits and withdrawls are disabled, ragequit remains enabled ///     Users can withdraw their stake through rageQuit() but forego their pending reward ///     Should only be used when downtime required for an upgrade /// - Shutdown: ///     Hypervisor is permanently disabled ///     All functions are disabled with the exception of ragequit ///     Users can withdraw their stake through rageQuit() ///     Power controller can withdraw from the reward pool ///     Should only be used if Proxy Owner role is compromized contract Hypervisor is IHypervisor, Powered, Ownable {     using SafeMath for uint256;     using EnumerableSet for EnumerableSet.AddressSet; /* constants */  // An upper bound on the number of active stakes per vault is required to prevent // calls to rageQuit() from reverting. // With 30 stakes in a vault, ragequit costs 432811 gas which is conservatively lower // than the hardcoded limit of 500k gas on the vault. // This limit is configurable and could be increased in a future deployment. // Ultimately, to avoid a need for fixed upper bounds, the EVM would need to provide // an error code that allows for reliably catching out-of-gas errors on remote calls. uint256 public constant MAX_STAKES_PER_VAULT = 30; uint256 public constant MAX_REWARD_TOKENS = 50; uint256 public constant BASE_SHARES_PER_WEI = 1000000; uint256 public stakeLimit = 2500 ether;  /* storage */  HypervisorData private _hypervisor; mapping(address =&gt; VaultData) private _vaults; EnumerableSet.AddressSet private _bonusTokenSet; EnumerableSet.AddressSet private _vaultFactorySet;  /* initializer */  /// @notice Initizalize Hypervisor /// access control: only proxy constructor /// state machine: can only be called once /// state scope: set initialization variables /// token transfer: none /// @param ownerAddress address The admin address /// @param rewardPoolFactory address The factory to use for deploying the RewardPool /// @param powerSwitchFactory address The factory to use for deploying the PowerSwitch /// @param stakingToken address The address of the staking token for this Hypervisor /// @param rewardToken address The address of the reward token for this Hypervisor /// @param rewardScaling RewardScaling The config for reward scaling floor, ceiling, and time constructor(     address ownerAddress,     address rewardPoolFactory,     address powerSwitchFactory,     address stakingToken,     address rewardToken,     RewardScaling memory rewardScaling,     uint256 _stakeLimit ) {     // the scaling floor must be smaller than ceiling     require(rewardScaling.floor &lt;= rewardScaling.ceiling, ""Hypervisor: floor above ceiling"");      // setting rewardScalingTime to 0 would cause divide by zero error     // to disable reward scaling, use rewardScalingFloor == rewardScalingCeiling     require(rewardScaling.time != 0, ""Hypervisor: scaling time cannot be zero"");      // deploy power switch     address powerSwitch = IFactory(powerSwitchFactory).create(abi.encode(ownerAddress));      // deploy reward pool     address rewardPool = IFactory(rewardPoolFactory).create(abi.encode(powerSwitch));      // set internal configs     Ownable.transferOwnership(ownerAddress);     Powered._setPowerSwitch(powerSwitch);      // commit to storage     _hypervisor.stakingToken = stakingToken;     _hypervisor.rewardToken = rewardToken;     _hypervisor.rewardPool = rewardPool;     _hypervisor.rewardScaling = rewardScaling;      stakeLimit = _stakeLimit;      // emit event     emit HypervisorCreated(rewardPool, powerSwitch); }  /* getter functions */  function getBonusTokenSetLength() external view override returns (uint256 length) {     return _bonusTokenSet.length(); }  function getBonusTokenAtIndex(uint256 index)     external     view     override     returns (address bonusToken) {     return _bonusTokenSet.at(index); }  function getVaultFactorySetLength() external view override returns (uint256 length) {     return _vaultFactorySet.length(); }  function getVaultFactoryAtIndex(uint256 index)     external     view     override     returns (address factory) {     return _vaultFactorySet.at(index); }  function isValidVault(address target) public view override returns (bool validity) {     // validate target is created from whitelisted vault factory     for (uint256 index = 0; index &lt; _vaultFactorySet.length(); index++) {         if (IInstanceRegistry(_vaultFactorySet.at(index)).isInstance(target)) {             return true;         }     }     // explicit return     return false; }  function isValidAddress(address target) public view override returns (bool validity) {     // sanity check target for potential input errors     return         target != address(this) &amp;&amp;         target != address(0) &amp;&amp;         target != _hypervisor.stakingToken &amp;&amp;         target != _hypervisor.rewardToken &amp;&amp;         target != _hypervisor.rewardPool &amp;&amp;         !_bonusTokenSet.contains(target); }  /* Hypervisor getters */  function getHypervisorData() external view override returns (HypervisorData memory hypervisor) {     return _hypervisor; }  function getCurrentUnlockedRewards() public view override returns (uint256 unlockedRewards) {     // calculate reward available based on state     return getFutureUnlockedRewards(block.timestamp); }  function getFutureUnlockedRewards(uint256 timestamp)     public     view     override     returns (uint256 unlockedRewards) {     // get reward amount remaining     uint256 remainingRewards = IERC20(_hypervisor.rewardToken).balanceOf(_hypervisor.rewardPool);     // calculate reward available based on state     unlockedRewards = calculateUnlockedRewards(         _hypervisor.rewardSchedules,         remainingRewards,         _hypervisor.rewardSharesOutstanding,         timestamp     );     // explicit return     return unlockedRewards; }  function getCurrentTotalStakeUnits() public view override returns (uint256 totalStakeUnits) {     // calculate new stake units     return getFutureTotalStakeUnits(block.timestamp); }  function getFutureTotalStakeUnits(uint256 timestamp)     public     view     override     returns (uint256 totalStakeUnits) {     // return early if no change     if (timestamp == _hypervisor.lastUpdate) return _hypervisor.totalStakeUnits;     // calculate new stake units     uint256 newStakeUnits =         calculateStakeUnits(_hypervisor.totalStake, _hypervisor.lastUpdate, timestamp);     // add to cached total     totalStakeUnits = _hypervisor.totalStakeUnits.add(newStakeUnits);     // explicit return     return totalStakeUnits; }  /* vault getters */  function getVaultData(address vault)     external     view     override     returns (VaultData memory vaultData) {     return _vaults[vault]; }  function getCurrentVaultReward(address vault) external view override returns (uint256 reward) {     // calculate rewards     return         calculateRewardFromStakes(             _vaults[vault]                 .stakes,             _vaults[vault]                 .totalStake,             getCurrentUnlockedRewards(),             getCurrentTotalStakeUnits(),             block                 .timestamp,             _hypervisor                 .rewardScaling         )             .reward; }  function getFutureVaultReward(address vault, uint256 timestamp)     external     view     override     returns (uint256 reward) {     // calculate rewards     return         calculateRewardFromStakes(             _vaults[vault]                 .stakes,             _vaults[vault]                 .totalStake,             getFutureUnlockedRewards(timestamp),             getFutureTotalStakeUnits(timestamp),             timestamp,             _hypervisor                 .rewardScaling         )             .reward; }  function getCurrentStakeReward(address vault, uint256 stakeAmount)     external     view     override     returns (uint256 reward) {     // calculate rewards     return         calculateRewardFromStakes(             _vaults[vault]                 .stakes,             stakeAmount,             getCurrentUnlockedRewards(),             getCurrentTotalStakeUnits(),             block                 .timestamp,             _hypervisor                 .rewardScaling         )             .reward; }  function getFutureStakeReward(     address vault,     uint256 stakeAmount,     uint256 timestamp ) external view override returns (uint256 reward) {     // calculate rewards     return         calculateRewardFromStakes(             _vaults[vault]                 .stakes,             stakeAmount,             getFutureUnlockedRewards(timestamp),             getFutureTotalStakeUnits(timestamp),             timestamp,             _hypervisor                 .rewardScaling         )             .reward; }  function getCurrentVaultStakeUnits(address vault)     public     view     override     returns (uint256 stakeUnits) {     // calculate stake units     return getFutureVaultStakeUnits(vault, block.timestamp); }  function getFutureVaultStakeUnits(address vault, uint256 timestamp)     public     view     override     returns (uint256 stakeUnits) {     // calculate stake units     return calculateTotalStakeUnits(_vaults[vault].stakes, timestamp); }  /* pure functions */  function calculateTotalStakeUnits(StakeData[] memory stakes, uint256 timestamp)     public     pure     override     returns (uint256 totalStakeUnits) {     for (uint256 index; index &lt; stakes.length; index++) {         // reference stake         StakeData memory stakeData = stakes[index];         // calculate stake units         uint256 stakeUnits =             calculateStakeUnits(stakeData.amount, stakeData.timestamp, timestamp);         // add to running total         totalStakeUnits = totalStakeUnits.add(stakeUnits);     } }  function calculateStakeUnits(     uint256 amount,     uint256 start,     uint256 end ) public pure override returns (uint256 stakeUnits) {     // calculate duration     uint256 duration = end.sub(start);     // calculate stake units     stakeUnits = duration.mul(amount);     // explicit return     return stakeUnits; }  function calculateUnlockedRewards(     RewardSchedule[] memory rewardSchedules,     uint256 rewardBalance,     uint256 sharesOutstanding,     uint256 timestamp ) public pure override returns (uint256 unlockedRewards) {     // return 0 if no registered schedules     if (rewardSchedules.length == 0) {         return 0;     }      // calculate reward shares locked across all reward schedules     uint256 sharesLocked;     for (uint256 index = 0; index &lt; rewardSchedules.length; index++) {         // fetch reward schedule storage reference         RewardSchedule memory schedule = rewardSchedules[index];          // caculate amount of shares available on this schedule         // if (now - start) &lt; duration         //   sharesLocked = shares - (shares * (now - start) / duration)         // else         //   sharesLocked = 0         uint256 currentSharesLocked = 0;         if (timestamp.sub(schedule.start) &lt; schedule.duration) {             currentSharesLocked = schedule.shares.sub(                 schedule.shares.mul(timestamp.sub(schedule.start)).div(schedule.duration)             );         }          // add to running total         sharesLocked = sharesLocked.add(currentSharesLocked);     }      // convert shares to reward     // rewardLocked = sharesLocked * rewardBalance / sharesOutstanding     uint256 rewardLocked = sharesLocked.mul(rewardBalance).div(sharesOutstanding);      // calculate amount available     // unlockedRewards = rewardBalance - rewardLocked     unlockedRewards = rewardBalance.sub(rewardLocked);      // explicit return     return unlockedRewards; }  function calculateRewardFromStakes(     StakeData[] memory stakes,     uint256 unstakeAmount,     uint256 unlockedRewards,     uint256 totalStakeUnits,     uint256 timestamp,     RewardScaling memory rewardScaling ) public pure override returns (RewardOutput memory out) {     uint256 stakesToDrop = 0;     while (unstakeAmount &gt; 0) {         // fetch vault stake storage reference         StakeData memory lastStake = stakes[stakes.length.sub(stakesToDrop).sub(1)];          // calculate stake duration         uint256 stakeDuration = timestamp.sub(lastStake.timestamp);          uint256 currentAmount;         if (lastStake.amount &gt; unstakeAmount) {             // set current amount to remaining unstake amount             currentAmount = unstakeAmount;             // amount of last stake is reduced             out.lastStakeAmount = lastStake.amount.sub(unstakeAmount);         } else {             // set current amount to amount of last stake             currentAmount = lastStake.amount;             // add to stakes to drop             stakesToDrop += 1;         }          // update remaining unstakeAmount         unstakeAmount = unstakeAmount.sub(currentAmount);          // calculate reward amount         uint256 currentReward =             calculateReward(                 unlockedRewards,                 currentAmount,                 stakeDuration,                 totalStakeUnits,                 rewardScaling             );          // update cumulative reward         out.reward = out.reward.add(currentReward);          // update cached unlockedRewards         unlockedRewards = unlockedRewards.sub(currentReward);          // calculate time weighted stake         uint256 stakeUnits = currentAmount.mul(stakeDuration);          // update cached totalStakeUnits         totalStakeUnits = totalStakeUnits.sub(stakeUnits);     }      // explicit return     return         RewardOutput(             out.lastStakeAmount,             stakes.length.sub(stakesToDrop),             out.reward,             totalStakeUnits         ); }  function calculateReward(     uint256 unlockedRewards,     uint256 stakeAmount,     uint256 stakeDuration,     uint256 totalStakeUnits,     RewardScaling memory rewardScaling ) public pure override returns (uint256 reward) {     // calculate time weighted stake     uint256 stakeUnits = stakeAmount.mul(stakeDuration);      // calculate base reward     // baseReward = unlockedRewards * stakeUnits / totalStakeUnits     uint256 baseReward = 0;     if (totalStakeUnits != 0) {         // scale reward according to proportional weight         baseReward = unlockedRewards.mul(stakeUnits).div(totalStakeUnits);     }      // calculate scaled reward     // if no scaling or scaling period completed     //   reward = baseReward     // else     //   minReward = baseReward * scalingFloor / scalingCeiling     //   bonusReward = baseReward     //                 * (scalingCeiling - scalingFloor) / scalingCeiling     //                 * duration / scalingTime     //   reward = minReward + bonusReward     if (stakeDuration &gt;= rewardScaling.time || rewardScaling.floor == rewardScaling.ceiling) {         // no reward scaling applied         reward = baseReward;     } else {         // calculate minimum reward using scaling floor         uint256 minReward = baseReward.mul(rewardScaling.floor).div(rewardScaling.ceiling);          // calculate bonus reward with vested portion of scaling factor         uint256 bonusReward =             baseReward                 .mul(stakeDuration)                 .mul(rewardScaling.ceiling.sub(rewardScaling.floor))                 .div(rewardScaling.ceiling)                 .div(rewardScaling.time);          // add minimum reward and bonus reward         reward = minReward.add(bonusReward);     }      // explicit return     return reward; }  /* admin functions */  /// @notice Add funds to the Hypervisor /// access control: only admin /// state machine: ///   - can be called multiple times ///   - only online /// state scope: ///   - increase _hypervisor.rewardSharesOutstanding ///   - append to _hypervisor.rewardSchedules /// token transfer: transfer staking tokens from msg.sender to reward pool /// @param amount uint256 Amount of reward tokens to deposit /// @param duration uint256 Duration over which to linearly unlock rewards function fund(uint256 amount, uint256 duration) external onlyOwner onlyOnline {     // validate duration     require(duration != 0, ""Hypervisor: invalid duration"");      // create new reward shares     // if existing rewards on this Hypervisor     //   mint new shares proportional to % change in rewards remaining     //   newShares = remainingShares * newReward / remainingRewards     // else     //   mint new shares with BASE_SHARES_PER_WEI initial conversion rate     //   store as fixed point number with same  of decimals as reward token     uint256 newRewardShares;     if (_hypervisor.rewardSharesOutstanding &gt; 0) {         uint256 remainingRewards = IERC20(_hypervisor.rewardToken).balanceOf(_hypervisor.rewardPool);         newRewardShares = _hypervisor.rewardSharesOutstanding.mul(amount).div(remainingRewards);     } else {         newRewardShares = amount.mul(BASE_SHARES_PER_WEI);     }      // add reward shares to total     _hypervisor.rewardSharesOutstanding = _hypervisor.rewardSharesOutstanding.add(newRewardShares);      // store new reward schedule     _hypervisor.rewardSchedules.push(RewardSchedule(duration, block.timestamp, newRewardShares));      // transfer reward tokens to reward pool     TransferHelper.safeTransferFrom(         _hypervisor.rewardToken,         msg.sender,         _hypervisor.rewardPool,         amount     );      // emit event     emit HypervisorFunded(amount, duration); }  /// @notice Add vault factory to whitelist /// @dev use this function to enable stakes to vaults coming from the specified ///      factory contract /// access control: only admin /// state machine: ///   - can be called multiple times ///   - not shutdown /// state scope: ///   - append to _vaultFactorySet /// token transfer: none /// @param factory address The address of the vault factory function registerVaultFactory(address factory) external onlyOwner notShutdown {     // add factory to set     require(_vaultFactorySet.add(factory), ""Hypervisor: vault factory already registered"");      // emit event     emit VaultFactoryRegistered(factory); }  /// @notice Remove vault factory from whitelist /// @dev use this function to disable new stakes to vaults coming from the specified ///      factory contract. ///      note: vaults with existing stakes from this factory are sill able to unstake /// access control: only admin /// state machine: ///   - can be called multiple times ///   - not shutdown /// state scope: ///   - remove from _vaultFactorySet /// token transfer: none /// @param factory address The address of the vault factory function removeVaultFactory(address factory) external onlyOwner notShutdown {     // remove factory from set     require(_vaultFactorySet.remove(factory), ""Hypervisor: vault factory not registered"");      // emit event     emit VaultFactoryRemoved(factory); }  /// @notice Register bonus token for distribution /// @dev use this function to enable distribution of any ERC20 held by the RewardPool contract /// access control: only admin /// state machine: ///   - can be called multiple times ///   - only online /// state scope: ///   - append to _bonusTokenSet /// token transfer: none /// @param bonusToken address The address of the bonus token function registerBonusToken(address bonusToken) external onlyOwner onlyOnline {     // verify valid bonus token     _validateAddress(bonusToken);      // verify bonus token count     require(_bonusTokenSet.length() &lt; MAX_REWARD_TOKENS, ""Hypervisor: max bonus tokens reached "");      // add token to set     assert(_bonusTokenSet.add(bonusToken));      // emit event     emit BonusTokenRegistered(bonusToken); }  /// @notice Rescue tokens from RewardPool /// @dev use this function to rescue tokens from RewardPool contract ///      without distributing to stakers or triggering emergency shutdown /// access control: only admin /// state machine: ///   - can be called multiple times ///   - only online /// state scope: none /// token transfer: transfer requested token from RewardPool to recipient /// @param token address The address of the token to rescue /// @param recipient address The address of the recipient /// @param amount uint256 The amount of tokens to rescue function rescueTokensFromRewardPool(     address token,     address recipient,     uint256 amount ) external onlyOwner onlyOnline {     // verify recipient     _validateAddress(recipient);      // check not attempting to unstake reward token     require(token != _hypervisor.rewardToken, ""Hypervisor: invalid address"");      // check not attempting to wthdraw bonus token     require(!_bonusTokenSet.contains(token), ""Hypervisor: invalid address"");      // transfer tokens to recipient     IRewardPool(_hypervisor.rewardPool).sendERC20(token, recipient, amount); }  /* user functions */  /// @notice Stake tokens /// @dev anyone can stake to any vault if they have valid permission /// access control: anyone /// state machine: ///   - can be called multiple times ///   - only online ///   - when vault exists on this Hypervisor /// state scope: ///   - append to _vaults[vault].stakes ///   - increase _vaults[vault].totalStake ///   - increase _hypervisor.totalStake ///   - increase _hypervisor.totalStakeUnits ///   - increase _hypervisor.lastUpdate /// token transfer: transfer staking tokens from msg.sender to vault /// @param vault address The address of the vault to stake from /// @param amount uint256 The amount of staking tokens to stake function stake(     address vault,     uint256 amount,     bytes calldata permission ) external override onlyOnline {     // verify vault is valid     require(isValidVault(vault), ""Hypervisor: vault is not registered"");      // verify non-zero amount     require(amount != 0, ""Hypervisor: no amount staked"");      // fetch vault storage reference     VaultData storage vaultData = _vaults[vault];      // verify stakes boundary not reached     require(         vaultData.stakes.length &lt; MAX_STAKES_PER_VAULT,         ""Hypervisor: MAX_STAKES_PER_VAULT reached""     );      // update cached sum of stake units across all vaults     _updateTotalStakeUnits();      // store amount and timestamp     vaultData.stakes.push(StakeData(amount, block.timestamp));      // update cached total vault and Hypervisor amounts     vaultData.totalStake = vaultData.totalStake.add(amount);     // verify stake quantity without bounds     require(         stakeLimit == 0 || vaultData.totalStake &lt;= stakeLimit,         ""Hypervisor: Stake limit exceeded""     );     _hypervisor.totalStake = _hypervisor.totalStake.add(amount);      // call lock on vault     IUniversalVault(vault).lock(_hypervisor.stakingToken, amount, permission);      // emit event     emit Staked(vault, amount); }  /// @notice Unstake staking tokens and claim reward /// @dev rewards can only be claimed when unstaking /// access control: only owner of vault /// state machine: ///   - when vault exists on this Hypervisor ///   - after stake from vault ///   - can be called multiple times while sufficient stake remains ///   - only online /// state scope: ///   - decrease _hypervisor.rewardSharesOutstanding ///   - decrease _hypervisor.totalStake ///   - increase _hypervisor.lastUpdate ///   - modify _hypervisor.totalStakeUnits ///   - modify _vaults[vault].stakes ///   - decrease _vaults[vault].totalStake /// token transfer: ///   - transfer reward tokens from reward pool to recipient ///   - transfer bonus tokens from reward pool to recipient /// @param vault address The vault to unstake from /// @param amount uint256 The amount of staking tokens to unstake function unstakeAndClaim(     address vault,     uint256 amount,     bytes calldata permission ) external override onlyOnline {     // fetch vault storage reference     VaultData storage vaultData = _vaults[vault];      // verify non-zero amount     require(amount != 0, ""Hypervisor: no amount unstaked"");      address recipient = IUniversalVault(vault).owner();      // validate recipient     _validateAddress(recipient);      // check for sufficient vault stake amount     require(vaultData.totalStake &gt;= amount, ""Hypervisor: insufficient vault stake"");      // check for sufficient Hypervisor stake amount     // if this check fails, there is a bug in stake accounting     assert(_hypervisor.totalStake &gt;= amount);      // update cached sum of stake units across all vaults     _updateTotalStakeUnits();      // get reward amount remaining     uint256 remainingRewards = IERC20(_hypervisor.rewardToken).balanceOf(_hypervisor.rewardPool);      // calculate vested portion of reward pool     uint256 unlockedRewards =         calculateUnlockedRewards(             _hypervisor.rewardSchedules,             remainingRewards,             _hypervisor.rewardSharesOutstanding,             block.timestamp         );      // calculate vault time weighted reward with scaling     RewardOutput memory out =         calculateRewardFromStakes(             vaultData.stakes,             amount,             unlockedRewards,             _hypervisor.totalStakeUnits,             block.timestamp,             _hypervisor.rewardScaling         );      // update stake data in storage     if (out.newStakesCount == 0) {         // all stakes have been unstaked         delete vaultData.stakes;     } else {         // some stakes have been completely or partially unstaked         // delete fully unstaked stakes         while (vaultData.stakes.length &gt; out.newStakesCount) vaultData.stakes.pop();         // update partially unstaked stake         vaultData.stakes[out.newStakesCount.sub(1)].amount = out.lastStakeAmount;     }      // update cached stake totals     vaultData.totalStake = vaultData.totalStake.sub(amount);     _hypervisor.totalStake = _hypervisor.totalStake.sub(amount);     _hypervisor.totalStakeUnits = out.newTotalStakeUnits;      // unlock staking tokens from vault     IUniversalVault(vault).unlock(_hypervisor.stakingToken, amount, permission);      // emit event     emit Unstaked(vault, amount);      // only perform on non-zero reward     if (out.reward &gt; 0) {         // calculate shares to burn         // sharesToBurn = sharesOutstanding * reward / remainingRewards         uint256 sharesToBurn =             _hypervisor.rewardSharesOutstanding.mul(out.reward).div(remainingRewards);          // burn claimed shares         _hypervisor.rewardSharesOutstanding = _hypervisor.rewardSharesOutstanding.sub(sharesToBurn);          // transfer bonus tokens from reward pool to recipient         if (_bonusTokenSet.length() &gt; 0) {             for (uint256 index = 0; index &lt; _bonusTokenSet.length(); index++) {                 // fetch bonus token address reference                 address bonusToken = _bonusTokenSet.at(index);                  // calculate bonus token amount                 // bonusAmount = bonusRemaining * reward / remainingRewards                 uint256 bonusAmount =                     IERC20(bonusToken).balanceOf(_hypervisor.rewardPool).mul(out.reward).div(                         remainingRewards                     );                  // transfer bonus token                 IRewardPool(_hypervisor.rewardPool).sendERC20(bonusToken, recipient, bonusAmount);                  // emit event                 emit RewardClaimed(vault, recipient, bonusToken, bonusAmount);             }         }          // transfer reward tokens from reward pool to recipient         IRewardPool(_hypervisor.rewardPool).sendERC20(_hypervisor.rewardToken, recipient, out.reward);          // emit event         emit RewardClaimed(vault, recipient, _hypervisor.rewardToken, out.reward);     } }  /// @notice Exit Hypervisor without claiming reward /// @dev This function should never revert when correctly called by the vault. ///      A max number of stakes per vault is set with MAX_STAKES_PER_VAULT to ///      place an upper bound on the for loop in calculateTotalStakeUnits(). /// access control: only callable by the vault directly /// state machine: ///   - when vault exists on this Hypervisor ///   - when active stake from this vault ///   - any power state /// state scope: ///   - decrease _hypervisor.totalStake ///   - increase _hypervisor.lastUpdate ///   - modify _hypervisor.totalStakeUnits ///   - delete _vaults[vault] /// token transfer: none function rageQuit() external override {     // fetch vault storage reference     VaultData storage _vaultData = _vaults[msg.sender];      // revert if no active stakes     require(_vaultData.stakes.length != 0, ""Hypervisor: no stake"");      // update cached sum of stake units across all vaults     _updateTotalStakeUnits();      // emit event     emit Unstaked(msg.sender, _vaultData.totalStake);      // update cached totals     _hypervisor.totalStake = _hypervisor.totalStake.sub(_vaultData.totalStake);     _hypervisor.totalStakeUnits = _hypervisor.totalStakeUnits.sub(         calculateTotalStakeUnits(_vaultData.stakes, block.timestamp)     );      // delete stake data     delete _vaults[msg.sender]; }  /* convenience functions */  function _updateTotalStakeUnits() private {     // update cached totalStakeUnits     _hypervisor.totalStakeUnits = getCurrentTotalStakeUnits();     // update cached lastUpdate     _hypervisor.lastUpdate = block.timestamp; }  function _validateAddress(address target) private view {     // sanity check target for potential input errors     require(isValidAddress(target), ""Hypervisor: invalid address""); }  function _truncateStakesArray(StakeData[] memory array, uint256 newLength)     private     pure     returns (StakeData[] memory newArray) {     newArray = new StakeData[](newLength);     for (uint256 index = 0; index &lt; newLength; index++) {         newArray[index] = array[index];     }     return newArray; }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-02-08 00:45:09 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: GPL-3.0-only
pragma solidity 0.7.6;
pragma abicoder v2;

import {SafeMath} from ""@openzeppelin/contracts/math/SafeMath.sol"";
import {EnumerableSet} from ""@openzeppelin/contracts/utils/EnumerableSet.sol"";
import {IERC20} from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import {Ownable} from ""@openzeppelin/contracts/access/Ownable.sol"";
import {TransferHelper} from ""@uniswap/lib/contracts/libraries/TransferHelper.sol"";

import {IFactory} from ""../factory/IFactory.sol"";
import {IInstanceRegistry} from ""../factory/InstanceRegistry.sol"";
import {IUniversalVault} from ""../visor/Visor.sol"";
import {IRewardPool} from ""./RewardPool.sol"";
import {Powered} from ""./Powered.sol"";

interface IRageQuit {
    function rageQuit() external;
}

interface IHypervisor is IRageQuit {
    /* admin events */

    event HypervisorCreated(address rewardPool, address powerSwitch);
    event HypervisorFunded(uint256 amount, uint256 duration);
    event BonusTokenRegistered(address token);
    event VaultFactoryRegistered(address factory);
    event VaultFactoryRemoved(address factory);

    /* user events */

    event Staked(address vault, uint256 amount);
    event Unstaked(address vault, uint256 amount);
    event RewardClaimed(address vault, address recipient, address token, uint256 amount);

    /* data types */

    struct HypervisorData {
        address stakingToken;
        address rewardToken;
        address rewardPool;
        RewardScaling rewardScaling;
        uint256 rewardSharesOutstanding;
        uint256 totalStake;
        uint256 totalStakeUnits;
        uint256 lastUpdate;
        RewardSchedule[] rewardSchedules;
    }

    struct RewardSchedule {
        uint256 duration;
        uint256 start;
        uint256 shares;
    }

    struct VaultData {
        uint256 totalStake;
        StakeData[] stakes;
    }

    struct StakeData {
        uint256 amount;
        uint256 timestamp;
    }

    struct RewardScaling {
        uint256 floor;
        uint256 ceiling;
        uint256 time;
    }

    struct RewardOutput {
        uint256 lastStakeAmount;
        uint256 newStakesCount;
        uint256 reward;
        uint256 newTotalStakeUnits;
    }

    /* user functions */

    function stake(
        address vault,
        uint256 amount,
        bytes calldata permission
    ) external;

    function unstakeAndClaim(
        address vault,
        uint256 amount,
        bytes calldata permission
    ) external;

    /* getter functions */

    function getHypervisorData() external view returns (HypervisorData memory hypervisor);

    function getBonusTokenSetLength() external view returns (uint256 length);

    function getBonusTokenAtIndex(uint256 index) external view returns (address bonusToken);

    function getVaultFactorySetLength() external view returns (uint256 length);

    function getVaultFactoryAtIndex(uint256 index) external view returns (address factory);

    function getVaultData(address vault) external view returns (VaultData memory vaultData);

    function isValidAddress(address target) external view returns (bool validity);

    function isValidVault(address target) external view returns (bool validity);

    function getCurrentUnlockedRewards() external view returns (uint256 unlockedRewards);

    function getFutureUnlockedRewards(uint256 timestamp)
        external
        view
        returns (uint256 unlockedRewards);

    function getCurrentVaultReward(address vault) external view returns (uint256 reward);

    function getCurrentStakeReward(address vault, uint256 stakeAmount)
        external
        view
        returns (uint256 reward);

    function getFutureVaultReward(address vault, uint256 timestamp)
        external
        view
        returns (uint256 reward);

    function getFutureStakeReward(
        address vault,
        uint256 stakeAmount,
        uint256 timestamp
    ) external view returns (uint256 reward);

    function getCurrentVaultStakeUnits(address vault) external view returns (uint256 stakeUnits);

    function getFutureVaultStakeUnits(address vault, uint256 timestamp)
        external
        view
        returns (uint256 stakeUnits);

    function getCurrentTotalStakeUnits() external view returns (uint256 totalStakeUnits);

    function getFutureTotalStakeUnits(uint256 timestamp)
        external
        view
        returns (uint256 totalStakeUnits);

    /* pure functions */

    function calculateTotalStakeUnits(StakeData[] memory stakes, uint256 timestamp)
        external
        pure
        returns (uint256 totalStakeUnits);

    function calculateStakeUnits(
        uint256 amount,
        uint256 start,
        uint256 end
    ) external pure returns (uint256 stakeUnits);

    function calculateUnlockedRewards(
        RewardSchedule[] memory rewardSchedules,
        uint256 rewardBalance,
        uint256 sharesOutstanding,
        uint256 timestamp
    ) external pure returns (uint256 unlockedRewards);

    function calculateRewardFromStakes(
        StakeData[] memory stakes,
        uint256 unstakeAmount,
        uint256 unlockedRewards,
        uint256 totalStakeUnits,
        uint256 timestamp,
        RewardScaling memory rewardScaling
    ) external pure returns (RewardOutput memory out);

    function calculateReward(
        uint256 unlockedRewards,
        uint256 stakeAmount,
        uint256 stakeDuration,
        uint256 totalStakeUnits,
        RewardScaling memory rewardScaling
    ) external pure returns (uint256 reward);
}

/// @title Hypervisor
/// @notice Reward distribution contract with time multiplier
/// Access Control
/// - Power controller:
///     Can power off / shutdown the Hypervisor
///     Can withdraw rewards from reward pool once shutdown
/// - Proxy owner:
///     Can change arbitrary logic / state by upgrading the Hypervisor
///     Is unable to operate on user funds due to UniversalVault
///     Is unable to operate on reward pool funds when reward pool is offline / shutdown
/// - Hypervisor admin:
///     Can add funds to the Hypervisor, register bonus tokens, and whitelist new vault factories
///     Is a subset of proxy owner permissions
/// - User:
///     Can deposit / withdraw / ragequit
/// Hypervisor State Machine
/// - Online:
///     Hypervisor is operating normally, all functions are enabled
/// - Offline:
///     Hypervisor is temporarely disabled for maintenance
///     User deposits and withdrawls are disabled, ragequit remains enabled
///     Users can withdraw their stake through rageQuit() but forego their pending reward
///     Should only be used when downtime required for an upgrade
/// - Shutdown:
///     Hypervisor is permanently disabled
///     All functions are disabled with the exception of ragequit
///     Users can withdraw their stake through rageQuit()
///     Power controller can withdraw from the reward pool
///     Should only be used if Proxy Owner role is compromized
contract Hypervisor is IHypervisor, Powered, Ownable {
    using SafeMath for uint256;
    using EnumerableSet for EnumerableSet.AddressSet;

    /* constants */

    // An upper bound on the number of active stakes per vault is required to prevent
    // calls to rageQuit() from reverting.
    // With 30 stakes in a vault, ragequit costs 432811 gas which is conservatively lower
    // than the hardcoded limit of 500k gas on the vault.
    // This limit is configurable and could be increased in a future deployment.
    // Ultimately, to avoid a need for fixed upper bounds, the EVM would need to provide
    // an error code that allows for reliably catching out-of-gas errors on remote calls.
    uint256 public constant MAX_STAKES_PER_VAULT = 30;
    uint256 public constant MAX_REWARD_TOKENS = 50;
    uint256 public constant BASE_SHARES_PER_WEI = 1000000;
    uint256 public stakeLimit = 2500 ether;

    /* storage */

    HypervisorData private _hypervisor;
    mapping(address => VaultData) private _vaults;
    EnumerableSet.AddressSet private _bonusTokenSet;
    EnumerableSet.AddressSet private _vaultFactorySet;

    /* initializer */

    /// @notice Initizalize Hypervisor
    /// access control: only proxy constructor
    /// state machine: can only be called once
    /// state scope: set initialization variables
    /// token transfer: none
    /// @param ownerAddress address The admin address
    /// @param rewardPoolFactory address The factory to use for deploying the RewardPool
    /// @param powerSwitchFactory address The factory to use for deploying the PowerSwitch
    /// @param stakingToken address The address of the staking token for this Hypervisor
    /// @param rewardToken address The address of the reward token for this Hypervisor
    /// @param rewardScaling RewardScaling The config for reward scaling floor, ceiling, and time
    constructor(
        address ownerAddress,
        address rewardPoolFactory,
        address powerSwitchFactory,
        address stakingToken,
        address rewardToken,
        RewardScaling memory rewardScaling,
        uint256 _stakeLimit
    ) {
        // the scaling floor must be smaller than ceiling
        require(rewardScaling.floor <= rewardScaling.ceiling, ""Hypervisor: floor above ceiling"");

        // setting rewardScalingTime to 0 would cause divide by zero error
        // to disable reward scaling, use rewardScalingFloor == rewardScalingCeiling
        require(rewardScaling.time != 0, ""Hypervisor: scaling time cannot be zero"");

        // deploy power switch
        address powerSwitch = IFactory(powerSwitchFactory).create(abi.encode(ownerAddress));

        // deploy reward pool
        address rewardPool = IFactory(rewardPoolFactory).create(abi.encode(powerSwitch));

        // set internal configs
        Ownable.transferOwnership(ownerAddress);
        Powered._setPowerSwitch(powerSwitch);

        // commit to storage
        _hypervisor.stakingToken = stakingToken;
        _hypervisor.rewardToken = rewardToken;
        _hypervisor.rewardPool = rewardPool;
        _hypervisor.rewardScaling = rewardScaling;

        stakeLimit = _stakeLimit;

        // emit event
        emit HypervisorCreated(rewardPool, powerSwitch);
    }

    /* getter functions */

    function getBonusTokenSetLength() external view override returns (uint256 length) {
        return _bonusTokenSet.length();
    }

    function getBonusTokenAtIndex(uint256 index)
        external
        view
        override
        returns (address bonusToken)
    {
        return _bonusTokenSet.at(index);
    }

    function getVaultFactorySetLength() external view override returns (uint256 length) {
        return _vaultFactorySet.length();
    }

    function getVaultFactoryAtIndex(uint256 index)
        external
        view
        override
        returns (address factory)
    {
        return _vaultFactorySet.at(index);
    }

    function isValidVault(address target) public view override returns (bool validity) {
        // validate target is created from whitelisted vault factory
        for (uint256 index = 0; index < _vaultFactorySet.length(); index++) {
            if (IInstanceRegistry(_vaultFactorySet.at(index)).isInstance(target)) {
                return true;
            }
        }
        // explicit return
        return false;
    }

    function isValidAddress(address target) public view override returns (bool validity) {
        // sanity check target for potential input errors
        return
            target != address(this) &&
            target != address(0) &&
            target != _hypervisor.stakingToken &&
            target != _hypervisor.rewardToken &&
            target != _hypervisor.rewardPool &&
            !_bonusTokenSet.contains(target);
    }

    /* Hypervisor getters */

    function getHypervisorData() external view override returns (HypervisorData memory hypervisor) {
        return _hypervisor;
    }

    function getCurrentUnlockedRewards() public view override returns (uint256 unlockedRewards) {
        // calculate reward available based on state
        return getFutureUnlockedRewards(block.timestamp);
    }

    function getFutureUnlockedRewards(uint256 timestamp)
        public
        view
        override
        returns (uint256 unlockedRewards)
    {
        // get reward amount remaining
        uint256 remainingRewards = IERC20(_hypervisor.rewardToken).balanceOf(_hypervisor.rewardPool);
        // calculate reward available based on state
        unlockedRewards = calculateUnlockedRewards(
            _hypervisor.rewardSchedules,
            remainingRewards,
            _hypervisor.rewardSharesOutstanding,
            timestamp
        );
        // explicit return
        return unlockedRewards;
    }

    function getCurrentTotalStakeUnits() public view override returns (uint256 totalStakeUnits) {
        // calculate new stake units
        return getFutureTotalStakeUnits(block.timestamp);
    }

    function getFutureTotalStakeUnits(uint256 timestamp)
        public
        view
        override
        returns (uint256 totalStakeUnits)
    {
        // return early if no change
        if (timestamp == _hypervisor.lastUpdate) return _hypervisor.totalStakeUnits;
        // calculate new stake units
        uint256 newStakeUnits =
            calculateStakeUnits(_hypervisor.totalStake, _hypervisor.lastUpdate, timestamp);
        // add to cached total
        totalStakeUnits = _hypervisor.totalStakeUnits.add(newStakeUnits);
        // explicit return
        return totalStakeUnits;
    }

    /* vault getters */

    function getVaultData(address vault)
        external
        view
        override
        returns (VaultData memory vaultData)
    {
        return _vaults[vault];
    }

    function getCurrentVaultReward(address vault) external view override returns (uint256 reward) {
        // calculate rewards
        return
            calculateRewardFromStakes(
                _vaults[vault]
                    .stakes,
                _vaults[vault]
                    .totalStake,
                getCurrentUnlockedRewards(),
                getCurrentTotalStakeUnits(),
                block
                    .timestamp,
                _hypervisor
                    .rewardScaling
            )
                .reward;
    }

    function getFutureVaultReward(address vault, uint256 timestamp)
        external
        view
        override
        returns (uint256 reward)
    {
        // calculate rewards
        return
            calculateRewardFromStakes(
                _vaults[vault]
                    .stakes,
                _vaults[vault]
                    .totalStake,
                getFutureUnlockedRewards(timestamp),
                getFutureTotalStakeUnits(timestamp),
                timestamp,
                _hypervisor
                    .rewardScaling
            )
                .reward;
    }

    function getCurrentStakeReward(address vault, uint256 stakeAmount)
        external
        view
        override
        returns (uint256 reward)
    {
        // calculate rewards
        return
            calculateRewardFromStakes(
                _vaults[vault]
                    .stakes,
                stakeAmount,
                getCurrentUnlockedRewards(),
                getCurrentTotalStakeUnits(),
                block
                    .timestamp,
                _hypervisor
                    .rewardScaling
            )
                .reward;
    }

    function getFutureStakeReward(
        address vault,
        uint256 stakeAmount,
        uint256 timestamp
    ) external view override returns (uint256 reward) {
        // calculate rewards
        return
            calculateRewardFromStakes(
                _vaults[vault]
                    .stakes,
                stakeAmount,
                getFutureUnlockedRewards(timestamp),
                getFutureTotalStakeUnits(timestamp),
                timestamp,
                _hypervisor
                    .rewardScaling
            )
                .reward;
    }

    function getCurrentVaultStakeUnits(address vault)
        public
        view
        override
        returns (uint256 stakeUnits)
    {
        // calculate stake units
        return getFutureVaultStakeUnits(vault, block.timestamp);
    }

    function getFutureVaultStakeUnits(address vault, uint256 timestamp)
        public
        view
        override
        returns (uint256 stakeUnits)
    {
        // calculate stake units
        return calculateTotalStakeUnits(_vaults[vault].stakes, timestamp);
    }

    /* pure functions */

    function calculateTotalStakeUnits(StakeData[] memory stakes, uint256 timestamp)
        public
        pure
        override
        returns (uint256 totalStakeUnits)
    {
        for (uint256 index; index < stakes.length; index++) {
            // reference stake
            StakeData memory stakeData = stakes[index];
            // calculate stake units
            uint256 stakeUnits =
                calculateStakeUnits(stakeData.amount, stakeData.timestamp, timestamp);
            // add to running total
            totalStakeUnits = totalStakeUnits.add(stakeUnits);
        }
    }

    function calculateStakeUnits(
        uint256 amount,
        uint256 start,
        uint256 end
    ) public pure override returns (uint256 stakeUnits) {
        // calculate duration
        uint256 duration = end.sub(start);
        // calculate stake units
        stakeUnits = duration.mul(amount);
        // explicit return
        return stakeUnits;
    }

    function calculateUnlockedRewards(
        RewardSchedule[] memory rewardSchedules,
        uint256 rewardBalance,
        uint256 sharesOutstanding,
        uint256 timestamp
    ) public pure override returns (uint256 unlockedRewards) {
        // return 0 if no registered schedules
        if (rewardSchedules.length == 0) {
            return 0;
        }

        // calculate reward shares locked across all reward schedules
        uint256 sharesLocked;
        for (uint256 index = 0; index < rewardSchedules.length; index++) {
            // fetch reward schedule storage reference
            RewardSchedule memory schedule = rewardSchedules[index];

            // caculate amount of shares available on this schedule
            // if (now - start) < duration
            //   sharesLocked = shares - (shares * (now - start) / duration)
            // else
            //   sharesLocked = 0
            uint256 currentSharesLocked = 0;
            if (timestamp.sub(schedule.start) < schedule.duration) {
                currentSharesLocked = schedule.shares.sub(
                    schedule.shares.mul(timestamp.sub(schedule.start)).div(schedule.duration)
                );
            }

            // add to running total
            sharesLocked = sharesLocked.add(currentSharesLocked);
        }

        // convert shares to reward
        // rewardLocked = sharesLocked * rewardBalance / sharesOutstanding
        uint256 rewardLocked = sharesLocked.mul(rewardBalance).div(sharesOutstanding);

        // calculate amount available
        // unlockedRewards = rewardBalance - rewardLocked
        unlockedRewards = rewardBalance.sub(rewardLocked);

        // explicit return
        return unlockedRewards;
    }

    function calculateRewardFromStakes(
        StakeData[] memory stakes,
        uint256 unstakeAmount,
        uint256 unlockedRewards,
        uint256 totalStakeUnits,
        uint256 timestamp,
        RewardScaling memory rewardScaling
    ) public pure override returns (RewardOutput memory out) {
        uint256 stakesToDrop = 0;
        while (unstakeAmount > 0) {
            // fetch vault stake storage reference
            StakeData memory lastStake = stakes[stakes.length.sub(stakesToDrop).sub(1)];

            // calculate stake duration
            uint256 stakeDuration = timestamp.sub(lastStake.timestamp);

            uint256 currentAmount;
            if (lastStake.amount > unstakeAmount) {
                // set current amount to remaining unstake amount
                currentAmount = unstakeAmount;
                // amount of last stake is reduced
                out.lastStakeAmount = lastStake.amount.sub(unstakeAmount);
            } else {
                // set current amount to amount of last stake
                currentAmount = lastStake.amount;
                // add to stakes to drop
                stakesToDrop += 1;
            }

            // update remaining unstakeAmount
            unstakeAmount = unstakeAmount.sub(currentAmount);

            // calculate reward amount
            uint256 currentReward =
                calculateReward(
                    unlockedRewards,
                    currentAmount,
                    stakeDuration,
                    totalStakeUnits,
                    rewardScaling
                );

            // update cumulative reward
            out.reward = out.reward.add(currentReward);

            // update cached unlockedRewards
            unlockedRewards = unlockedRewards.sub(currentReward);

            // calculate time weighted stake
            uint256 stakeUnits = currentAmount.mul(stakeDuration);

            // update cached totalStakeUnits
            totalStakeUnits = totalStakeUnits.sub(stakeUnits);
        }

        // explicit return
        return
            RewardOutput(
                out.lastStakeAmount,
                stakes.length.sub(stakesToDrop),
                out.reward,
                totalStakeUnits
            );
    }

    function calculateReward(
        uint256 unlockedRewards,
        uint256 stakeAmount,
        uint256 stakeDuration,
        uint256 totalStakeUnits,
        RewardScaling memory rewardScaling
    ) public pure override returns (uint256 reward) {
        // calculate time weighted stake
        uint256 stakeUnits = stakeAmount.mul(stakeDuration);

        // calculate base reward
        // baseReward = unlockedRewards * stakeUnits / totalStakeUnits
        uint256 baseReward = 0;
        if (totalStakeUnits != 0) {
            // scale reward according to proportional weight
            baseReward = unlockedRewards.mul(stakeUnits).div(totalStakeUnits);
        }

        // calculate scaled reward
        // if no scaling or scaling period completed
        //   reward = baseReward
        // else
        //   minReward = baseReward * scalingFloor / scalingCeiling
        //   bonusReward = baseReward
        //                 * (scalingCeiling - scalingFloor) / scalingCeiling
        //                 * duration / scalingTime
        //   reward = minReward + bonusReward
        if (stakeDuration >= rewardScaling.time || rewardScaling.floor == rewardScaling.ceiling) {
            // no reward scaling applied
            reward = baseReward;
        } else {
            // calculate minimum reward using scaling floor
            uint256 minReward = baseReward.mul(rewardScaling.floor).div(rewardScaling.ceiling);

            // calculate bonus reward with vested portion of scaling factor
            uint256 bonusReward =
                baseReward
                    .mul(stakeDuration)
                    .mul(rewardScaling.ceiling.sub(rewardScaling.floor))
                    .div(rewardScaling.ceiling)
                    .div(rewardScaling.time);

            // add minimum reward and bonus reward
            reward = minReward.add(bonusReward);
        }

        // explicit return
        return reward;
    }

    /* admin functions */

    /// @notice Add funds to the Hypervisor
    /// access control: only admin
    /// state machine:
    ///   - can be called multiple times
    ///   - only online
    /// state scope:
    ///   - increase _hypervisor.rewardSharesOutstanding
    ///   - append to _hypervisor.rewardSchedules
    /// token transfer: transfer staking tokens from msg.sender to reward pool
    /// @param amount uint256 Amount of reward tokens to deposit
    /// @param duration uint256 Duration over which to linearly unlock rewards
    function fund(uint256 amount, uint256 duration) external onlyOwner onlyOnline {
        // validate duration
        require(duration != 0, ""Hypervisor: invalid duration"");

        // create new reward shares
        // if existing rewards on this Hypervisor
        //   mint new shares proportional to % change in rewards remaining
        //   newShares = remainingShares * newReward / remainingRewards
        // else
        //   mint new shares with BASE_SHARES_PER_WEI initial conversion rate
        //   store as fixed point number with same  of decimals as reward token
        uint256 newRewardShares;
        if (_hypervisor.rewardSharesOutstanding > 0) {
            uint256 remainingRewards = IERC20(_hypervisor.rewardToken).balanceOf(_hypervisor.rewardPool);
            newRewardShares = _hypervisor.rewardSharesOutstanding.mul(amount).div(remainingRewards);
        } else {
            newRewardShares = amount.mul(BASE_SHARES_PER_WEI);
        }

        // add reward shares to total
        _hypervisor.rewardSharesOutstanding = _hypervisor.rewardSharesOutstanding.add(newRewardShares);

        // store new reward schedule
        _hypervisor.rewardSchedules.push(RewardSchedule(duration, block.timestamp, newRewardShares));

        // transfer reward tokens to reward pool
        TransferHelper.safeTransferFrom(
            _hypervisor.rewardToken,
            msg.sender,
            _hypervisor.rewardPool,
            amount
        );

        // emit event
        emit HypervisorFunded(amount, duration);
    }

    /// @notice Add vault factory to whitelist
    /// @dev use this function to enable stakes to vaults coming from the specified
    ///      factory contract
    /// access control: only admin
    /// state machine:
    ///   - can be called multiple times
    ///   - not shutdown
    /// state scope:
    ///   - append to _vaultFactorySet
    /// token transfer: none
    /// @param factory address The address of the vault factory
    function registerVaultFactory(address factory) external onlyOwner notShutdown {
        // add factory to set
        require(_vaultFactorySet.add(factory), ""Hypervisor: vault factory already registered"");

        // emit event
        emit VaultFactoryRegistered(factory);
    }

    /// @notice Remove vault factory from whitelist
    /// @dev use this function to disable new stakes to vaults coming from the specified
    ///      factory contract.
    ///      note: vaults with existing stakes from this factory are sill able to unstake
    /// access control: only admin
    /// state machine:
    ///   - can be called multiple times
    ///   - not shutdown
    /// state scope:
    ///   - remove from _vaultFactorySet
    /// token transfer: none
    /// @param factory address The address of the vault factory
    function removeVaultFactory(address factory) external onlyOwner notShutdown {
        // remove factory from set
        require(_vaultFactorySet.remove(factory), ""Hypervisor: vault factory not registered"");

        // emit event
        emit VaultFactoryRemoved(factory);
    }

    /// @notice Register bonus token for distribution
    /// @dev use this function to enable distribution of any ERC20 held by the RewardPool contract
    /// access control: only admin
    /// state machine:
    ///   - can be called multiple times
    ///   - only online
    /// state scope:
    ///   - append to _bonusTokenSet
    /// token transfer: none
    /// @param bonusToken address The address of the bonus token
    function registerBonusToken(address bonusToken) external onlyOwner onlyOnline {
        // verify valid bonus token
        _validateAddress(bonusToken);

        // verify bonus token count
        require(_bonusTokenSet.length() < MAX_REWARD_TOKENS, ""Hypervisor: max bonus tokens reached "");

        // add token to set
        assert(_bonusTokenSet.add(bonusToken));

        // emit event
        emit BonusTokenRegistered(bonusToken);
    }

    /// @notice Rescue tokens from RewardPool
    /// @dev use this function to rescue tokens from RewardPool contract
    ///      without distributing to stakers or triggering emergency shutdown
    /// access control: only admin
    /// state machine:
    ///   - can be called multiple times
    ///   - only online
    /// state scope: none
    /// token transfer: transfer requested token from RewardPool to recipient
    /// @param token address The address of the token to rescue
    /// @param recipient address The address of the recipient
    /// @param amount uint256 The amount of tokens to rescue
    function rescueTokensFromRewardPool(
        address token,
        address recipient,
        uint256 amount
    ) external onlyOwner onlyOnline {
        // verify recipient
        _validateAddress(recipient);

        // check not attempting to unstake reward token
        require(token != _hypervisor.rewardToken, ""Hypervisor: invalid address"");

        // check not attempting to wthdraw bonus token
        require(!_bonusTokenSet.contains(token), ""Hypervisor: invalid address"");

        // transfer tokens to recipient
        IRewardPool(_hypervisor.rewardPool).sendERC20(token, recipient, amount);
    }

    /* user functions */

    /// @notice Stake tokens
    /// @dev anyone can stake to any vault if they have valid permission
    /// access control: anyone
    /// state machine:
    ///   - can be called multiple times
    ///   - only online
    ///   - when vault exists on this Hypervisor
    /// state scope:
    ///   - append to _vaults[vault].stakes
    ///   - increase _vaults[vault].totalStake
    ///   - increase _hypervisor.totalStake
    ///   - increase _hypervisor.totalStakeUnits
    ///   - increase _hypervisor.lastUpdate
    /// token transfer: transfer staking tokens from msg.sender to vault
    /// @param vault address The address of the vault to stake from
    /// @param amount uint256 The amount of staking tokens to stake
    function stake(
        address vault,
        uint256 amount,
        bytes calldata permission
    ) external override onlyOnline {
        // verify vault is valid
        require(isValidVault(vault), ""Hypervisor: vault is not registered"");

        // verify non-zero amount
        require(amount != 0, ""Hypervisor: no amount staked"");

        // fetch vault storage reference
        VaultData storage vaultData = _vaults[vault];

        // verify stakes boundary not reached
        require(
            vaultData.stakes.length < MAX_STAKES_PER_VAULT,
            ""Hypervisor: MAX_STAKES_PER_VAULT reached""
        );

        // update cached sum of stake units across all vaults
        _updateTotalStakeUnits();

        // store amount and timestamp
        vaultData.stakes.push(StakeData(amount, block.timestamp));

        // update cached total vault and Hypervisor amounts
        vaultData.totalStake = vaultData.totalStake.add(amount);
        // verify stake quantity without bounds
        require(
            stakeLimit == 0 || vaultData.totalStake <= stakeLimit,
            ""Hypervisor: Stake limit exceeded""
        );
        _hypervisor.totalStake = _hypervisor.totalStake.add(amount);

        // call lock on vault
        IUniversalVault(vault).lock(_hypervisor.stakingToken, amount, permission);

        // emit event
        emit Staked(vault, amount);
    }

    /// @notice Unstake staking tokens and claim reward
    /// @dev rewards can only be claimed when unstaking
    /// access control: only owner of vault
    /// state machine:
    ///   - when vault exists on this Hypervisor
    ///   - after stake from vault
    ///   - can be called multiple times while sufficient stake remains
    ///   - only online
    /// state scope:
    ///   - decrease _hypervisor.rewardSharesOutstanding
    ///   - decrease _hypervisor.totalStake
    ///   - increase _hypervisor.lastUpdate
    ///   - modify _hypervisor.totalStakeUnits
    ///   - modify _vaults[vault].stakes
    ///   - decrease _vaults[vault].totalStake
    /// token transfer:
    ///   - transfer reward tokens from reward pool to recipient
    ///   - transfer bonus tokens from reward pool to recipient
    /// @param vault address The vault to unstake from
    /// @param amount uint256 The amount of staking tokens to unstake
    function unstakeAndClaim(
        address vault,
        uint256 amount,
        bytes calldata permission
    ) external override onlyOnline {
        // fetch vault storage reference
        VaultData storage vaultData = _vaults[vault];

        // verify non-zero amount
        require(amount != 0, ""Hypervisor: no amount unstaked"");

        address recipient = IUniversalVault(vault).owner();

        // validate recipient
        _validateAddress(recipient);

        // check for sufficient vault stake amount
        require(vaultData.totalStake >= amount, ""Hypervisor: insufficient vault stake"");

        // check for sufficient Hypervisor stake amount
        // if this check fails, there is a bug in stake accounting
        assert(_hypervisor.totalStake >= amount);

        // update cached sum of stake units across all vaults
        _updateTotalStakeUnits();

        // get reward amount remaining
        uint256 remainingRewards = IERC20(_hypervisor.rewardToken).balanceOf(_hypervisor.rewardPool);

        // calculate vested portion of reward pool
        uint256 unlockedRewards =
            calculateUnlockedRewards(
                _hypervisor.rewardSchedules,
                remainingRewards,
                _hypervisor.rewardSharesOutstanding,
                block.timestamp
            );

        // calculate vault time weighted reward with scaling
        RewardOutput memory out =
            calculateRewardFromStakes(
                vaultData.stakes,
                amount,
                unlockedRewards,
                _hypervisor.totalStakeUnits,
                block.timestamp,
                _hypervisor.rewardScaling
            );

        // update stake data in storage
        if (out.newStakesCount == 0) {
            // all stakes have been unstaked
            delete vaultData.stakes;
        } else {
            // some stakes have been completely or partially unstaked
            // delete fully unstaked stakes
            while (vaultData.stakes.length > out.newStakesCount) vaultData.stakes.pop();
            // update partially unstaked stake
            vaultData.stakes[out.newStakesCount.sub(1)].amount = out.lastStakeAmount;
        }

        // update cached stake totals
        vaultData.totalStake = vaultData.totalStake.sub(amount);
        _hypervisor.totalStake = _hypervisor.totalStake.sub(amount);
        _hypervisor.totalStakeUnits = out.newTotalStakeUnits;

        // unlock staking tokens from vault
        IUniversalVault(vault).unlock(_hypervisor.stakingToken, amount, permission);

        // emit event
        emit Unstaked(vault, amount);

        // only perform on non-zero reward
        if (out.reward > 0) {
            // calculate shares to burn
            // sharesToBurn = sharesOutstanding * reward / remainingRewards
            uint256 sharesToBurn =
                _hypervisor.rewardSharesOutstanding.mul(out.reward).div(remainingRewards);

            // burn claimed shares
            _hypervisor.rewardSharesOutstanding = _hypervisor.rewardSharesOutstanding.sub(sharesToBurn);

            // transfer bonus tokens from reward pool to recipient
            if (_bonusTokenSet.length() > 0) {
                for (uint256 index = 0; index < _bonusTokenSet.length(); index++) {
                    // fetch bonus token address reference
                    address bonusToken = _bonusTokenSet.at(index);

                    // calculate bonus token amount
                    // bonusAmount = bonusRemaining * reward / remainingRewards
                    uint256 bonusAmount =
                        IERC20(bonusToken).balanceOf(_hypervisor.rewardPool).mul(out.reward).div(
                            remainingRewards
                        );

                    // transfer bonus token
                    IRewardPool(_hypervisor.rewardPool).sendERC20(bonusToken, recipient, bonusAmount);

                    // emit event
                    emit RewardClaimed(vault, recipient, bonusToken, bonusAmount);
                }
            }

            // transfer reward tokens from reward pool to recipient
            IRewardPool(_hypervisor.rewardPool).sendERC20(_hypervisor.rewardToken, recipient, out.reward);

            // emit event
            emit RewardClaimed(vault, recipient, _hypervisor.rewardToken, out.reward);
        }
    }

    /// @notice Exit Hypervisor without claiming reward
    /// @dev This function should never revert when correctly called by the vault.
    ///      A max number of stakes per vault is set with MAX_STAKES_PER_VAULT to
    ///      place an upper bound on the for loop in calculateTotalStakeUnits().
    /// access control: only callable by the vault directly
    /// state machine:
    ///   - when vault exists on this Hypervisor
    ///   - when active stake from this vault
    ///   - any power state
    /// state scope:
    ///   - decrease _hypervisor.totalStake
    ///   - increase _hypervisor.lastUpdate
    ///   - modify _hypervisor.totalStakeUnits
    ///   - delete _vaults[vault]
    /// token transfer: none
    function rageQuit() external override {
        // fetch vault storage reference
        VaultData storage _vaultData = _vaults[msg.sender];

        // revert if no active stakes
        require(_vaultData.stakes.length != 0, ""Hypervisor: no stake"");

        // update cached sum of stake units across all vaults
        _updateTotalStakeUnits();

        // emit event
        emit Unstaked(msg.sender, _vaultData.totalStake);

        // update cached totals
        _hypervisor.totalStake = _hypervisor.totalStake.sub(_vaultData.totalStake);
        _hypervisor.totalStakeUnits = _hypervisor.totalStakeUnits.sub(
            calculateTotalStakeUnits(_vaultData.stakes, block.timestamp)
        );

        // delete stake data
        delete _vaults[msg.sender];
    }

    /* convenience functions */

    function _updateTotalStakeUnits() private {
        // update cached totalStakeUnits
        _hypervisor.totalStakeUnits = getCurrentTotalStakeUnits();
        // update cached lastUpdate
        _hypervisor.lastUpdate = block.timestamp;
    }

    function _validateAddress(address target) private view {
        // sanity check target for potential input errors
        require(isValidAddress(target), ""Hypervisor: invalid address"");
    }

    function _truncateStakesArray(StakeData[] memory array, uint256 newLength)
        private
        pure
        returns (StakeData[] memory newArray)
    {
        newArray = new StakeData[](newLength);
        for (uint256 index = 0; index < newLength; index++) {
            newArray[index] = array[index];
        }
        return newArray;
    }
}
.
To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs.]

Given the user's task and the brainstorming ideas provided:
Task: ""// SPDX-License-Identifier: GPL-3.0-only
pragma solidity 0.7.6;
pragma abicoder v2;

import {SafeMath} from ""@openzeppelin/contracts/math/SafeMath.sol"";
import {EnumerableSet} from ""@openzeppelin/contracts/utils/EnumerableSet.sol"";
import {IERC20} from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import {Ownable} from ""@openzeppelin/contracts/access/Ownable.sol"";
import {TransferHelper} from ""@uniswap/lib/contracts/libraries/TransferHelper.sol"";

import {IFactory} from ""../factory/IFactory.sol"";
import {IInstanceRegistry} from ""../factory/InstanceRegistry.sol"";
import {IUniversalVault} from ""../visor/Visor.sol"";
import {IRewardPool} from ""./RewardPool.sol"";
import {Powered} from ""./Powered.sol"";

interface IRageQuit {
    function rageQuit() external;
}

interface IHypervisor is IRageQuit {
    /* admin events */

    event HypervisorCreated(address rewardPool, address powerSwitch);
    event HypervisorFunded(uint256 amount, uint256 duration);
    event BonusTokenRegistered(address token);
    event VaultFactoryRegistered(address factory);
    event VaultFactoryRemoved(address factory);

    /* user events */

    event Staked(address vault, uint256 amount);
    event Unstaked(address vault, uint256 amount);
    event RewardClaimed(address vault, address recipient, address token, uint256 amount);

    /* data types */

    struct HypervisorData {
        address stakingToken;
        address rewardToken;
        address rewardPool;
        RewardScaling rewardScaling;
        uint256 rewardSharesOutstanding;
        uint256 totalStake;
        uint256 totalStakeUnits;
        uint256 lastUpdate;
        RewardSchedule[] rewardSchedules;
    }

    struct RewardSchedule {
        uint256 duration;
        uint256 start;
        uint256 shares;
    }

    struct VaultData {
        uint256 totalStake;
        StakeData[] stakes;
    }

    struct StakeData {
        uint256 amount;
        uint256 timestamp;
    }

    struct RewardScaling {
        uint256 floor;
        uint256 ceiling;
        uint256 time;
    }

    struct RewardOutput {
        uint256 lastStakeAmount;
        uint256 newStakesCount;
        uint256 reward;
        uint256 newTotalStakeUnits;
    }

    /* user functions */

    function stake(
        address vault,
        uint256 amount,
        bytes calldata permission
    ) external;

    function unstakeAndClaim(
        address vault,
        uint256 amount,
        bytes calldata permission
    ) external;

    /* getter functions */

    function getHypervisorData() external view returns (HypervisorData memory hypervisor);

    function getBonusTokenSetLength() external view returns (uint256 length);

    function getBonusTokenAtIndex(uint256 index) external view returns (address bonusToken);

    function getVaultFactorySetLength() external view returns (uint256 length);

    function getVaultFactoryAtIndex(uint256 index) external view returns (address factory);

    function getVaultData(address vault) external view returns (VaultData memory vaultData);

    function isValidAddress(address target) external view returns (bool validity);

    function isValidVault(address target) external view returns (bool validity);

    function getCurrentUnlockedRewards() external view returns (uint256 unlockedRewards);

    function getFutureUnlockedRewards(uint256 timestamp)
        external
        view
        returns (uint256 unlockedRewards);

    function getCurrentVaultReward(address vault) external view returns (uint256 reward);

    function getCurrentStakeReward(address vault, uint256 stakeAmount)
        external
        view
        returns (uint256 reward);

    function getFutureVaultReward(address vault, uint256 timestamp)
        external
        view
        returns (uint256 reward);

    function getFutureStakeReward(
        address vault,
        uint256 stakeAmount,
        uint256 timestamp
    ) external view returns (uint256 reward);

    function getCurrentVaultStakeUnits(address vault) external view returns (uint256 stakeUnits);

    function getFutureVaultStakeUnits(address vault, uint256 timestamp)
        external
        view
        returns (uint256 stakeUnits);

    function getCurrentTotalStakeUnits() external view returns (uint256 totalStakeUnits);

    function getFutureTotalStakeUnits(uint256 timestamp)
        external
        view
        returns (uint256 totalStakeUnits);

    /* pure functions */

    function calculateTotalStakeUnits(StakeData[] memory stakes, uint256 timestamp)
        external
        pure
        returns (uint256 totalStakeUnits);

    function calculateStakeUnits(
        uint256 amount,
        uint256 start,
        uint256 end
    ) external pure returns (uint256 stakeUnits);

    function calculateUnlockedRewards(
        RewardSchedule[] memory rewardSchedules,
        uint256 rewardBalance,
        uint256 sharesOutstanding,
        uint256 timestamp
    ) external pure returns (uint256 unlockedRewards);

    function calculateRewardFromStakes(
        StakeData[] memory stakes,
        uint256 unstakeAmount,
        uint256 unlockedRewards,
        uint256 totalStakeUnits,
        uint256 timestamp,
        RewardScaling memory rewardScaling
    ) external pure returns (RewardOutput memory out);

    function calculateReward(
        uint256 unlockedRewards,
        uint256 stakeAmount,
        uint256 stakeDuration,
        uint256 totalStakeUnits,
        RewardScaling memory rewardScaling
    ) external pure returns (uint256 reward);
}

/// @title Hypervisor
/// @notice Reward distribution contract with time multiplier
/// Access Control
/// - Power controller:
///     Can power off / shutdown the Hypervisor
///     Can withdraw rewards from reward pool once shutdown
/// - Proxy owner:
///     Can change arbitrary logic / state by upgrading the Hypervisor
///     Is unable to operate on user funds due to UniversalVault
///     Is unable to operate on reward pool funds when reward pool is offline / shutdown
/// - Hypervisor admin:
///     Can add funds to the Hypervisor, register bonus tokens, and whitelist new vault factories
///     Is a subset of proxy owner permissions
/// - User:
///     Can deposit / withdraw / ragequit
/// Hypervisor State Machine
/// - Online:
///     Hypervisor is operating normally, all functions are enabled
/// - Offline:
///     Hypervisor is temporarely disabled for maintenance
///     User deposits and withdrawls are disabled, ragequit remains enabled
///     Users can withdraw their stake through rageQuit() but forego their pending reward
///     Should only be used when downtime required for an upgrade
/// - Shutdown:
///     Hypervisor is permanently disabled
///     All functions are disabled with the exception of ragequit
///     Users can withdraw their stake through rageQuit()
///     Power controller can withdraw from the reward pool
///     Should only be used if Proxy Owner role is compromized
contract Hypervisor is IHypervisor, Powered, Ownable {
    using SafeMath for uint256;
    using EnumerableSet for EnumerableSet.AddressSet;

    /* constants */

    // An upper bound on the number of active stakes per vault is required to prevent
    // calls to rageQuit() from reverting.
    // With 30 stakes in a vault, ragequit costs 432811 gas which is conservatively lower
    // than the hardcoded limit of 500k gas on the vault.
    // This limit is configurable and could be increased in a future deployment.
    // Ultimately, to avoid a need for fixed upper bounds, the EVM would need to provide
    // an error code that allows for reliably catching out-of-gas errors on remote calls.
    uint256 public constant MAX_STAKES_PER_VAULT = 30;
    uint256 public constant MAX_REWARD_TOKENS = 50;
    uint256 public constant BASE_SHARES_PER_WEI = 1000000;
    uint256 public stakeLimit = 2500 ether;

    /* storage */

    HypervisorData private _hypervisor;
    mapping(address => VaultData) private _vaults;
    EnumerableSet.AddressSet private _bonusTokenSet;
    EnumerableSet.AddressSet private _vaultFactorySet;

    /* initializer */

    /// @notice Initizalize Hypervisor
    /// access control: only proxy constructor
    /// state machine: can only be called once
    /// state scope: set initialization variables
    /// token transfer: none
    /// @param ownerAddress address The admin address
    /// @param rewardPoolFactory address The factory to use for deploying the RewardPool
    /// @param powerSwitchFactory address The factory to use for deploying the PowerSwitch
    /// @param stakingToken address The address of the staking token for this Hypervisor
    /// @param rewardToken address The address of the reward token for this Hypervisor
    /// @param rewardScaling RewardScaling The config for reward scaling floor, ceiling, and time
    constructor(
        address ownerAddress,
        address rewardPoolFactory,
        address powerSwitchFactory,
        address stakingToken,
        address rewardToken,
        RewardScaling memory rewardScaling,
        uint256 _stakeLimit
    ) {
        // the scaling floor must be smaller than ceiling
        require(rewardScaling.floor <= rewardScaling.ceiling, ""Hypervisor: floor above ceiling"");

        // setting rewardScalingTime to 0 would cause divide by zero error
        // to disable reward scaling, use rewardScalingFloor == rewardScalingCeiling
        require(rewardScaling.time != 0, ""Hypervisor: scaling time cannot be zero"");

        // deploy power switch
        address powerSwitch = IFactory(powerSwitchFactory).create(abi.encode(ownerAddress));

        // deploy reward pool
        address rewardPool = IFactory(rewardPoolFactory).create(abi.encode(powerSwitch));

        // set internal configs
        Ownable.transferOwnership(ownerAddress);
        Powered._setPowerSwitch(powerSwitch);

        // commit to storage
        _hypervisor.stakingToken = stakingToken;
        _hypervisor.rewardToken = rewardToken;
        _hypervisor.rewardPool = rewardPool;
        _hypervisor.rewardScaling = rewardScaling;

        stakeLimit = _stakeLimit;

        // emit event
        emit HypervisorCreated(rewardPool, powerSwitch);
    }

    /* getter functions */

    function getBonusTokenSetLength() external view override returns (uint256 length) {
        return _bonusTokenSet.length();
    }

    function getBonusTokenAtIndex(uint256 index)
        external
        view
        override
        returns (address bonusToken)
    {
        return _bonusTokenSet.at(index);
    }

    function getVaultFactorySetLength() external view override returns (uint256 length) {
        return _vaultFactorySet.length();
    }

    function getVaultFactoryAtIndex(uint256 index)
        external
        view
        override
        returns (address factory)
    {
        return _vaultFactorySet.at(index);
    }

    function isValidVault(address target) public view override returns (bool validity) {
        // validate target is created from whitelisted vault factory
        for (uint256 index = 0; index < _vaultFactorySet.length(); index++) {
            if (IInstanceRegistry(_vaultFactorySet.at(index)).isInstance(target)) {
                return true;
            }
        }
        // explicit return
        return false;
    }

    function isValidAddress(address target) public view override returns (bool validity) {
        // sanity check target for potential input errors
        return
            target != address(this) &&
            target != address(0) &&
            target != _hypervisor.stakingToken &&
            target != _hypervisor.rewardToken &&
            target != _hypervisor.rewardPool &&
            !_bonusTokenSet.contains(target);
    }

    /* Hypervisor getters */

    function getHypervisorData() external view override returns (HypervisorData memory hypervisor) {
        return _hypervisor;
    }

    function getCurrentUnlockedRewards() public view override returns (uint256 unlockedRewards) {
        // calculate reward available based on state
        return getFutureUnlockedRewards(block.timestamp);
    }

    function getFutureUnlockedRewards(uint256 timestamp)
        public
        view
        override
        returns (uint256 unlockedRewards)
    {
        // get reward amount remaining
        uint256 remainingRewards = IERC20(_hypervisor.rewardToken).balanceOf(_hypervisor.rewardPool);
        // calculate reward available based on state
        unlockedRewards = calculateUnlockedRewards(
            _hypervisor.rewardSchedules,
            remainingRewards,
            _hypervisor.rewardSharesOutstanding,
            timestamp
        );
        // explicit return
        return unlockedRewards;
    }

    function getCurrentTotalStakeUnits() public view override returns (uint256 totalStakeUnits) {
        // calculate new stake units
        return getFutureTotalStakeUnits(block.timestamp);
    }

    function getFutureTotalStakeUnits(uint256 timestamp)
        public
        view
        override
        returns (uint256 totalStakeUnits)
    {
        // return early if no change
        if (timestamp == _hypervisor.lastUpdate) return _hypervisor.totalStakeUnits;
        // calculate new stake units
        uint256 newStakeUnits =
            calculateStakeUnits(_hypervisor.totalStake, _hypervisor.lastUpdate, timestamp);
        // add to cached total
        totalStakeUnits = _hypervisor.totalStakeUnits.add(newStakeUnits);
        // explicit return
        return totalStakeUnits;
    }

    /* vault getters */

    function getVaultData(address vault)
        external
        view
        override
        returns (VaultData memory vaultData)
    {
        return _vaults[vault];
    }

    function getCurrentVaultReward(address vault) external view override returns (uint256 reward) {
        // calculate rewards
        return
            calculateRewardFromStakes(
                _vaults[vault]
                    .stakes,
                _vaults[vault]
                    .totalStake,
                getCurrentUnlockedRewards(),
                getCurrentTotalStakeUnits(),
                block
                    .timestamp,
                _hypervisor
                    .rewardScaling
            )
                .reward;
    }

    function getFutureVaultReward(address vault, uint256 timestamp)
        external
        view
        override
        returns (uint256 reward)
    {
        // calculate rewards
        return
            calculateRewardFromStakes(
                _vaults[vault]
                    .stakes,
                _vaults[vault]
                    .totalStake,
                getFutureUnlockedRewards(timestamp),
                getFutureTotalStakeUnits(timestamp),
                timestamp,
                _hypervisor
                    .rewardScaling
            )
                .reward;
    }

    function getCurrentStakeReward(address vault, uint256 stakeAmount)
        external
        view
        override
        returns (uint256 reward)
    {
        // calculate rewards
        return
            calculateRewardFromStakes(
                _vaults[vault]
                    .stakes,
                stakeAmount,
                getCurrentUnlockedRewards(),
                getCurrentTotalStakeUnits(),
                block
                    .timestamp,
                _hypervisor
                    .rewardScaling
            )
                .reward;
    }

    function getFutureStakeReward(
        address vault,
        uint256 stakeAmount,
        uint256 timestamp
    ) external view override returns (uint256 reward) {
        // calculate rewards
        return
            calculateRewardFromStakes(
                _vaults[vault]
                    .stakes,
                stakeAmount,
                getFutureUnlockedRewards(timestamp),
                getFutureTotalStakeUnits(timestamp),
                timestamp,
                _hypervisor
                    .rewardScaling
            )
                .reward;
    }

    function getCurrentVaultStakeUnits(address vault)
        public
        view
        override
        returns (uint256 stakeUnits)
    {
        // calculate stake units
        return getFutureVaultStakeUnits(vault, block.timestamp);
    }

    function getFutureVaultStakeUnits(address vault, uint256 timestamp)
        public
        view
        override
        returns (uint256 stakeUnits)
    {
        // calculate stake units
        return calculateTotalStakeUnits(_vaults[vault].stakes, timestamp);
    }

    /* pure functions */

    function calculateTotalStakeUnits(StakeData[] memory stakes, uint256 timestamp)
        public
        pure
        override
        returns (uint256 totalStakeUnits)
    {
        for (uint256 index; index < stakes.length; index++) {
            // reference stake
            StakeData memory stakeData = stakes[index];
            // calculate stake units
            uint256 stakeUnits =
                calculateStakeUnits(stakeData.amount, stakeData.timestamp, timestamp);
            // add to running total
            totalStakeUnits = totalStakeUnits.add(stakeUnits);
        }
    }

    function calculateStakeUnits(
        uint256 amount,
        uint256 start,
        uint256 end
    ) public pure override returns (uint256 stakeUnits) {
        // calculate duration
        uint256 duration = end.sub(start);
        // calculate stake units
        stakeUnits = duration.mul(amount);
        // explicit return
        return stakeUnits;
    }

    function calculateUnlockedRewards(
        RewardSchedule[] memory rewardSchedules,
        uint256 rewardBalance,
        uint256 sharesOutstanding,
        uint256 timestamp
    ) public pure override returns (uint256 unlockedRewards) {
        // return 0 if no registered schedules
        if (rewardSchedules.length == 0) {
            return 0;
        }

        // calculate reward shares locked across all reward schedules
        uint256 sharesLocked;
        for (uint256 index = 0; index < rewardSchedules.length; index++) {
            // fetch reward schedule storage reference
            RewardSchedule memory schedule = rewardSchedules[index];

            // caculate amount of shares available on this schedule
            // if (now - start) < duration
            //   sharesLocked = shares - (shares * (now - start) / duration)
            // else
            //   sharesLocked = 0
            uint256 currentSharesLocked = 0;
            if (timestamp.sub(schedule.start) < schedule.duration) {
                currentSharesLocked = schedule.shares.sub(
                    schedule.shares.mul(timestamp.sub(schedule.start)).div(schedule.duration)
                );
            }

            // add to running total
            sharesLocked = sharesLocked.add(currentSharesLocked);
        }

        // convert shares to reward
        // rewardLocked = sharesLocked * rewardBalance / sharesOutstanding
        uint256 rewardLocked = sharesLocked.mul(rewardBalance).div(sharesOutstanding);

        // calculate amount available
        // unlockedRewards = rewardBalance - rewardLocked
        unlockedRewards = rewardBalance.sub(rewardLocked);

        // explicit return
        return unlockedRewards;
    }

    function calculateRewardFromStakes(
        StakeData[] memory stakes,
        uint256 unstakeAmount,
        uint256 unlockedRewards,
        uint256 totalStakeUnits,
        uint256 timestamp,
        RewardScaling memory rewardScaling
    ) public pure override returns (RewardOutput memory out) {
        uint256 stakesToDrop = 0;
        while (unstakeAmount > 0) {
            // fetch vault stake storage reference
            StakeData memory lastStake = stakes[stakes.length.sub(stakesToDrop).sub(1)];

            // calculate stake duration
            uint256 stakeDuration = timestamp.sub(lastStake.timestamp);

            uint256 currentAmount;
            if (lastStake.amount > unstakeAmount) {
                // set current amount to remaining unstake amount
                currentAmount = unstakeAmount;
                // amount of last stake is reduced
                out.lastStakeAmount = lastStake.amount.sub(unstakeAmount);
            } else {
                // set current amount to amount of last stake
                currentAmount = lastStake.amount;
                // add to stakes to drop
                stakesToDrop += 1;
            }

            // update remaining unstakeAmount
            unstakeAmount = unstakeAmount.sub(currentAmount);

            // calculate reward amount
            uint256 currentReward =
                calculateReward(
                    unlockedRewards,
                    currentAmount,
                    stakeDuration,
                    totalStakeUnits,
                    rewardScaling
                );

            // update cumulative reward
            out.reward = out.reward.add(currentReward);

            // update cached unlockedRewards
            unlockedRewards = unlockedRewards.sub(currentReward);

            // calculate time weighted stake
            uint256 stakeUnits = currentAmount.mul(stakeDuration);

            // update cached totalStakeUnits
            totalStakeUnits = totalStakeUnits.sub(stakeUnits);
        }

        // explicit return
        return
            RewardOutput(
                out.lastStakeAmount,
                stakes.length.sub(stakesToDrop),
                out.reward,
                totalStakeUnits
            );
    }

    function calculateReward(
        uint256 unlockedRewards,
        uint256 stakeAmount,
        uint256 stakeDuration,
        uint256 totalStakeUnits,
        RewardScaling memory rewardScaling
    ) public pure override returns (uint256 reward) {
        // calculate time weighted stake
        uint256 stakeUnits = stakeAmount.mul(stakeDuration);

        // calculate base reward
        // baseReward = unlockedRewards * stakeUnits / totalStakeUnits
        uint256 baseReward = 0;
        if (totalStakeUnits != 0) {
            // scale reward according to proportional weight
            baseReward = unlockedRewards.mul(stakeUnits).div(totalStakeUnits);
        }

        // calculate scaled reward
        // if no scaling or scaling period completed
        //   reward = baseReward
        // else
        //   minReward = baseReward * scalingFloor / scalingCeiling
        //   bonusReward = baseReward
        //                 * (scalingCeiling - scalingFloor) / scalingCeiling
        //                 * duration / scalingTime
        //   reward = minReward + bonusReward
        if (stakeDuration >= rewardScaling.time || rewardScaling.floor == rewardScaling.ceiling) {
            // no reward scaling applied
            reward = baseReward;
        } else {
            // calculate minimum reward using scaling floor
            uint256 minReward = baseReward.mul(rewardScaling.floor).div(rewardScaling.ceiling);

            // calculate bonus reward with vested portion of scaling factor
            uint256 bonusReward =
                baseReward
                    .mul(stakeDuration)
                    .mul(rewardScaling.ceiling.sub(rewardScaling.floor))
                    .div(rewardScaling.ceiling)
                    .div(rewardScaling.time);

            // add minimum reward and bonus reward
            reward = minReward.add(bonusReward);
        }

        // explicit return
        return reward;
    }

    /* admin functions */

    /// @notice Add funds to the Hypervisor
    /// access control: only admin
    /// state machine:
    ///   - can be called multiple times
    ///   - only online
    /// state scope:
    ///   - increase _hypervisor.rewardSharesOutstanding
    ///   - append to _hypervisor.rewardSchedules
    /// token transfer: transfer staking tokens from msg.sender to reward pool
    /// @param amount uint256 Amount of reward tokens to deposit
    /// @param duration uint256 Duration over which to linearly unlock rewards
    function fund(uint256 amount, uint256 duration) external onlyOwner onlyOnline {
        // validate duration
        require(duration != 0, ""Hypervisor: invalid duration"");

        // create new reward shares
        // if existing rewards on this Hypervisor
        //   mint new shares proportional to % change in rewards remaining
        //   newShares = remainingShares * newReward / remainingRewards
        // else
        //   mint new shares with BASE_SHARES_PER_WEI initial conversion rate
        //   store as fixed point number with same  of decimals as reward token
        uint256 newRewardShares;
        if (_hypervisor.rewardSharesOutstanding > 0) {
            uint256 remainingRewards = IERC20(_hypervisor.rewardToken).balanceOf(_hypervisor.rewardPool);
            newRewardShares = _hypervisor.rewardSharesOutstanding.mul(amount).div(remainingRewards);
        } else {
            newRewardShares = amount.mul(BASE_SHARES_PER_WEI);
        }

        // add reward shares to total
        _hypervisor.rewardSharesOutstanding = _hypervisor.rewardSharesOutstanding.add(newRewardShares);

        // store new reward schedule
        _hypervisor.rewardSchedules.push(RewardSchedule(duration, block.timestamp, newRewardShares));

        // transfer reward tokens to reward pool
        TransferHelper.safeTransferFrom(
            _hypervisor.rewardToken,
            msg.sender,
            _hypervisor.rewardPool,
            amount
        );

        // emit event
        emit HypervisorFunded(amount, duration);
    }

    /// @notice Add vault factory to whitelist
    /// @dev use this function to enable stakes to vaults coming from the specified
    ///      factory contract
    /// access control: only admin
    /// state machine:
    ///   - can be called multiple times
    ///   - not shutdown
    /// state scope:
    ///   - append to _vaultFactorySet
    /// token transfer: none
    /// @param factory address The address of the vault factory
    function registerVaultFactory(address factory) external onlyOwner notShutdown {
        // add factory to set
        require(_vaultFactorySet.add(factory), ""Hypervisor: vault factory already registered"");

        // emit event
        emit VaultFactoryRegistered(factory);
    }

    /// @notice Remove vault factory from whitelist
    /// @dev use this function to disable new stakes to vaults coming from the specified
    ///      factory contract.
    ///      note: vaults with existing stakes from this factory are sill able to unstake
    /// access control: only admin
    /// state machine:
    ///   - can be called multiple times
    ///   - not shutdown
    /// state scope:
    ///   - remove from _vaultFactorySet
    /// token transfer: none
    /// @param factory address The address of the vault factory
    function removeVaultFactory(address factory) external onlyOwner notShutdown {
        // remove factory from set
        require(_vaultFactorySet.remove(factory), ""Hypervisor: vault factory not registered"");

        // emit event
        emit VaultFactoryRemoved(factory);
    }

    /// @notice Register bonus token for distribution
    /// @dev use this function to enable distribution of any ERC20 held by the RewardPool contract
    /// access control: only admin
    /// state machine:
    ///   - can be called multiple times
    ///   - only online
    /// state scope:
    ///   - append to _bonusTokenSet
    /// token transfer: none
    /// @param bonusToken address The address of the bonus token
    function registerBonusToken(address bonusToken) external onlyOwner onlyOnline {
        // verify valid bonus token
        _validateAddress(bonusToken);

        // verify bonus token count
        require(_bonusTokenSet.length() < MAX_REWARD_TOKENS, ""Hypervisor: max bonus tokens reached "");

        // add token to set
        assert(_bonusTokenSet.add(bonusToken));

        // emit event
        emit BonusTokenRegistered(bonusToken);
    }

    /// @notice Rescue tokens from RewardPool
    /// @dev use this function to rescue tokens from RewardPool contract
    ///      without distributing to stakers or triggering emergency shutdown
    /// access control: only admin
    /// state machine:
    ///   - can be called multiple times
    ///   - only online
    /// state scope: none
    /// token transfer: transfer requested token from RewardPool to recipient
    /// @param token address The address of the token to rescue
    /// @param recipient address The address of the recipient
    /// @param amount uint256 The amount of tokens to rescue
    function rescueTokensFromRewardPool(
        address token,
        address recipient,
        uint256 amount
    ) external onlyOwner onlyOnline {
        // verify recipient
        _validateAddress(recipient);

        // check not attempting to unstake reward token
        require(token != _hypervisor.rewardToken, ""Hypervisor: invalid address"");

        // check not attempting to wthdraw bonus token
        require(!_bonusTokenSet.contains(token), ""Hypervisor: invalid address"");

        // transfer tokens to recipient
        IRewardPool(_hypervisor.rewardPool).sendERC20(token, recipient, amount);
    }

    /* user functions */

    /// @notice Stake tokens
    /// @dev anyone can stake to any vault if they have valid permission
    /// access control: anyone
    /// state machine:
    ///   - can be called multiple times
    ///   - only online
    ///   - when vault exists on this Hypervisor
    /// state scope:
    ///   - append to _vaults[vault].stakes
    ///   - increase _vaults[vault].totalStake
    ///   - increase _hypervisor.totalStake
    ///   - increase _hypervisor.totalStakeUnits
    ///   - increase _hypervisor.lastUpdate
    /// token transfer: transfer staking tokens from msg.sender to vault
    /// @param vault address The address of the vault to stake from
    /// @param amount uint256 The amount of staking tokens to stake
    function stake(
        address vault,
        uint256 amount,
        bytes calldata permission
    ) external override onlyOnline {
        // verify vault is valid
        require(isValidVault(vault), ""Hypervisor: vault is not registered"");

        // verify non-zero amount
        require(amount != 0, ""Hypervisor: no amount staked"");

        // fetch vault storage reference
        VaultData storage vaultData = _vaults[vault];

        // verify stakes boundary not reached
        require(
            vaultData.stakes.length < MAX_STAKES_PER_VAULT,
            ""Hypervisor: MAX_STAKES_PER_VAULT reached""
        );

        // update cached sum of stake units across all vaults
        _updateTotalStakeUnits();

        // store amount and timestamp
        vaultData.stakes.push(StakeData(amount, block.timestamp));

        // update cached total vault and Hypervisor amounts
        vaultData.totalStake = vaultData.totalStake.add(amount);
        // verify stake quantity without bounds
        require(
            stakeLimit == 0 || vaultData.totalStake <= stakeLimit,
            ""Hypervisor: Stake limit exceeded""
        );
        _hypervisor.totalStake = _hypervisor.totalStake.add(amount);

        // call lock on vault
        IUniversalVault(vault).lock(_hypervisor.stakingToken, amount, permission);

        // emit event
        emit Staked(vault, amount);
    }

    /// @notice Unstake staking tokens and claim reward
    /// @dev rewards can only be claimed when unstaking
    /// access control: only owner of vault
    /// state machine:
    ///   - when vault exists on this Hypervisor
    ///   - after stake from vault
    ///   - can be called multiple times while sufficient stake remains
    ///   - only online
    /// state scope:
    ///   - decrease _hypervisor.rewardSharesOutstanding
    ///   - decrease _hypervisor.totalStake
    ///   - increase _hypervisor.lastUpdate
    ///   - modify _hypervisor.totalStakeUnits
    ///   - modify _vaults[vault].stakes
    ///   - decrease _vaults[vault].totalStake
    /// token transfer:
    ///   - transfer reward tokens from reward pool to recipient
    ///   - transfer bonus tokens from reward pool to recipient
    /// @param vault address The vault to unstake from
    /// @param amount uint256 The amount of staking tokens to unstake
    function unstakeAndClaim(
        address vault,
        uint256 amount,
        bytes calldata permission
    ) external override onlyOnline {
        // fetch vault storage reference
        VaultData storage vaultData = _vaults[vault];

        // verify non-zero amount
        require(amount != 0, ""Hypervisor: no amount unstaked"");

        address recipient = IUniversalVault(vault).owner();

        // validate recipient
        _validateAddress(recipient);

        // check for sufficient vault stake amount
        require(vaultData.totalStake >= amount, ""Hypervisor: insufficient vault stake"");

        // check for sufficient Hypervisor stake amount
        // if this check fails, there is a bug in stake accounting
        assert(_hypervisor.totalStake >= amount);

        // update cached sum of stake units across all vaults
        _updateTotalStakeUnits();

        // get reward amount remaining
        uint256 remainingRewards = IERC20(_hypervisor.rewardToken).balanceOf(_hypervisor.rewardPool);

        // calculate vested portion of reward pool
        uint256 unlockedRewards =
            calculateUnlockedRewards(
                _hypervisor.rewardSchedules,
                remainingRewards,
                _hypervisor.rewardSharesOutstanding,
                block.timestamp
            );

        // calculate vault time weighted reward with scaling
        RewardOutput memory out =
            calculateRewardFromStakes(
                vaultData.stakes,
                amount,
                unlockedRewards,
                _hypervisor.totalStakeUnits,
                block.timestamp,
                _hypervisor.rewardScaling
            );

        // update stake data in storage
        if (out.newStakesCount == 0) {
            // all stakes have been unstaked
            delete vaultData.stakes;
        } else {
            // some stakes have been completely or partially unstaked
            // delete fully unstaked stakes
            while (vaultData.stakes.length > out.newStakesCount) vaultData.stakes.pop();
            // update partially unstaked stake
            vaultData.stakes[out.newStakesCount.sub(1)].amount = out.lastStakeAmount;
        }

        // update cached stake totals
        vaultData.totalStake = vaultData.totalStake.sub(amount);
        _hypervisor.totalStake = _hypervisor.totalStake.sub(amount);
        _hypervisor.totalStakeUnits = out.newTotalStakeUnits;

        // unlock staking tokens from vault
        IUniversalVault(vault).unlock(_hypervisor.stakingToken, amount, permission);

        // emit event
        emit Unstaked(vault, amount);

        // only perform on non-zero reward
        if (out.reward > 0) {
            // calculate shares to burn
            // sharesToBurn = sharesOutstanding * reward / remainingRewards
            uint256 sharesToBurn =
                _hypervisor.rewardSharesOutstanding.mul(out.reward).div(remainingRewards);

            // burn claimed shares
            _hypervisor.rewardSharesOutstanding = _hypervisor.rewardSharesOutstanding.sub(sharesToBurn);

            // transfer bonus tokens from reward pool to recipient
            if (_bonusTokenSet.length() > 0) {
                for (uint256 index = 0; index < _bonusTokenSet.length(); index++) {
                    // fetch bonus token address reference
                    address bonusToken = _bonusTokenSet.at(index);

                    // calculate bonus token amount
                    // bonusAmount = bonusRemaining * reward / remainingRewards
                    uint256 bonusAmount =
                        IERC20(bonusToken).balanceOf(_hypervisor.rewardPool).mul(out.reward).div(
                            remainingRewards
                        );

                    // transfer bonus token
                    IRewardPool(_hypervisor.rewardPool).sendERC20(bonusToken, recipient, bonusAmount);

                    // emit event
                    emit RewardClaimed(vault, recipient, bonusToken, bonusAmount);
                }
            }

            // transfer reward tokens from reward pool to recipient
            IRewardPool(_hypervisor.rewardPool).sendERC20(_hypervisor.rewardToken, recipient, out.reward);

            // emit event
            emit RewardClaimed(vault, recipient, _hypervisor.rewardToken, out.reward);
        }
    }

    /// @notice Exit Hypervisor without claiming reward
    /// @dev This function should never revert when correctly called by the vault.
    ///      A max number of stakes per vault is set with MAX_STAKES_PER_VAULT to
    ///      place an upper bound on the for loop in calculateTotalStakeUnits().
    /// access control: only callable by the vault directly
    /// state machine:
    ///   - when vault exists on this Hypervisor
    ///   - when active stake from this vault
    ///   - any power state
    /// state scope:
    ///   - decrease _hypervisor.totalStake
    ///   - increase _hypervisor.lastUpdate
    ///   - modify _hypervisor.totalStakeUnits
    ///   - delete _vaults[vault]
    /// token transfer: none
    function rageQuit() external override {
        // fetch vault storage reference
        VaultData storage _vaultData = _vaults[msg.sender];

        // revert if no active stakes
        require(_vaultData.stakes.length != 0, ""Hypervisor: no stake"");

        // update cached sum of stake units across all vaults
        _updateTotalStakeUnits();

        // emit event
        emit Unstaked(msg.sender, _vaultData.totalStake);

        // update cached totals
        _hypervisor.totalStake = _hypervisor.totalStake.sub(_vaultData.totalStake);
        _hypervisor.totalStakeUnits = _hypervisor.totalStakeUnits.sub(
            calculateTotalStakeUnits(_vaultData.stakes, block.timestamp)
        );

        // delete stake data
        delete _vaults[msg.sender];
    }

    /* convenience functions */

    function _updateTotalStakeUnits() private {
        // update cached totalStakeUnits
        _hypervisor.totalStakeUnits = getCurrentTotalStakeUnits();
        // update cached lastUpdate
        _hypervisor.lastUpdate = block.timestamp;
    }

    function _validateAddress(address target) private view {
        // sanity check target for potential input errors
        require(isValidAddress(target), ""Hypervisor: invalid address"");
    }

    function _truncateStakesArray(StakeData[] memory array, uint256 newLength)
        private
        pure
        returns (StakeData[] memory newArray)
    {
        newArray = new StakeData[](newLength);
        for (uint256 index = 0; index < newLength; index++) {
            newArray[index] = array[index];
        }
        return newArray;
    }
}
"".
Ideas: "" Centralization Risk Identified.

**Ownership Hijacking**
'''
The contract uses the Ownable pattern, which centralizes control in a single address (the owner). If the owner's private key is compromised, an attacker could gain full control over the contract, allowing them to execute any function that requires ownership, such as `fund`, `registerVaultFactory`, `removeVaultFactory`, and `rescueTokensFromRewardPool`. This poses a significant risk to the integrity of the contract and the funds within it.

**Recommended Mitigation/Fix:**
Implement a multi-signature wallet for critical functions that require ownership. This would distribute control among multiple trusted parties, reducing the risk of a single point of failure. Additionally, consider implementing a time-lock mechanism for sensitive operations to provide a buffer period during which stakeholders can react to potentially malicious actions.
'''"".
As the Security Analyst, your primary objective is to perform a thorough and detailed inspection of the provided contract code, with a particular focus on identifying vulnerabilities related to Funding Rate Calculation Precision. There are two cases where the code may have Funding Rate Calculation Precision vulnerabilities:
1. Simplistic funding rate calculation that does not consider all necessary factors. This can lead to incorrect funding rates, which can be manipulated by providing incorrect input values. A robust funding rate calculation should account for various factors and validations to prevent exploitation.
2. Lack of input validation for critical parameters (e.g., spotPrice, markPrice) used in the funding rate calculation. Malicious actors could potentially manipulate these parameters to influence the funding rate calculation.
If you identify a Simplistic funding rate calculation or Lack of input validation, respond with: """,,,,,,,,,"<INFO> Order of Inheritance Initialization Identified.
```
ORDER OF INHERITANCE INITIALIZATION
'''
The contract `Hypervisor` inherits from two contracts: `Powered` and `Ownable`. In Solidity, the order of constructor execution is determined by the linearized order of inheritance, which may not match the order specified in the derived contract's constructor. This can lead to unexpected behavior if the constructors of the inherited contracts rely on state variables that are initialized in the derived contract's constructor.

In this case, if `Powered` and `Ownable` have their own state variables that are expected to be initialized before the derived contract's constructor logic executes, it could lead to incorrect initialization of those variables. 

To mitigate this issue, ensure that any state variables in the base contracts are initialized properly before they are used in the derived contract. This can be achieved by explicitly calling the constructors of the base contracts in the derived contract's constructor in the

[2024-02-08 00:46:08 INFO] **[Execute Detail]**

execute SimplePhase:[ImpracticalityMatchDetector] in ComposedPhase:[CodeReview], cycle 1

[2024-02-08 00:46:08 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: GPL-3.0-only pragma solidity 0.7.6; pragma abicoder v2; import {SafeMath} from ""@openzeppelin/contracts/math/SafeMath.sol""; import {EnumerableSet} from ""@openzeppelin/contracts/utils/EnumerableSet.sol""; import {IERC20} from ""@openzeppelin/contracts/token/ERC20/IERC20.sol""; import {Ownable} from ""@openzeppelin/contracts/access/Ownable.sol""; import {TransferHelper} from ""@uniswap/lib/contracts/libraries/TransferHelper.sol""; import {IFactory} from ""../factory/IFactory.sol""; import {IInstanceRegistry} from ""../factory/InstanceRegistry.sol""; import {IUniversalVault} from ""../visor/Visor.sol""; import {IRewardPool} from ""./RewardPool.sol""; import {Powered} from ""./Powered.sol""; interface IRageQuit {     function rageQuit() external; } interface IHypervisor is IRageQuit {     / admin events / event HypervisorCreated(address rewardPool, address powerSwitch); event HypervisorFunded(uint256 amount, uint256 duration); event BonusTokenRegistered(address token); event VaultFactoryRegistered(address factory); event VaultFactoryRemoved(address factory);  /* user events */  event Staked(address vault, uint256 amount); event Unstaked(address vault, uint256 amount); event RewardClaimed(address vault, address recipient, address token, uint256 amount);  /* data types */  struct HypervisorData {     address stakingToken;     address rewardToken;     address rewardPool;     RewardScaling rewardScaling;     uint256 rewardSharesOutstanding;     uint256 totalStake;     uint256 totalStakeUnits;     uint256 lastUpdate;     RewardSchedule[] rewardSchedules; }  struct RewardSchedule {     uint256 duration;     uint256 start;     uint256 shares; }  struct VaultData {     uint256 totalStake;     StakeData[] stakes; }  struct StakeData {     uint256 amount;     uint256 timestamp; }  struct RewardScaling {     uint256 floor;     uint256 ceiling;     uint256 time; }  struct RewardOutput {     uint256 lastStakeAmount;     uint256 newStakesCount;     uint256 reward;     uint256 newTotalStakeUnits; }  /* user functions */  function stake(     address vault,     uint256 amount,     bytes calldata permission ) external;  function unstakeAndClaim(     address vault,     uint256 amount,     bytes calldata permission ) external;  /* getter functions */  function getHypervisorData() external view returns (HypervisorData memory hypervisor);  function getBonusTokenSetLength() external view returns (uint256 length);  function getBonusTokenAtIndex(uint256 index) external view returns (address bonusToken);  function getVaultFactorySetLength() external view returns (uint256 length);  function getVaultFactoryAtIndex(uint256 index) external view returns (address factory);  function getVaultData(address vault) external view returns (VaultData memory vaultData);  function isValidAddress(address target) external view returns (bool validity);  function isValidVault(address target) external view returns (bool validity);  function getCurrentUnlockedRewards() external view returns (uint256 unlockedRewards);  function getFutureUnlockedRewards(uint256 timestamp)     external     view     returns (uint256 unlockedRewards);  function getCurrentVaultReward(address vault) external view returns (uint256 reward);  function getCurrentStakeReward(address vault, uint256 stakeAmount)     external     view     returns (uint256 reward);  function getFutureVaultReward(address vault, uint256 timestamp)     external     view     returns (uint256 reward);  function getFutureStakeReward(     address vault,     uint256 stakeAmount,     uint256 timestamp ) external view returns (uint256 reward);  function getCurrentVaultStakeUnits(address vault) external view returns (uint256 stakeUnits);  function getFutureVaultStakeUnits(address vault, uint256 timestamp)     external     view     returns (uint256 stakeUnits);  function getCurrentTotalStakeUnits() external view returns (uint256 totalStakeUnits);  function getFutureTotalStakeUnits(uint256 timestamp)     external     view     returns (uint256 totalStakeUnits);  /* pure functions */  function calculateTotalStakeUnits(StakeData[] memory stakes, uint256 timestamp)     external     pure     returns (uint256 totalStakeUnits);  function calculateStakeUnits(     uint256 amount,     uint256 start,     uint256 end ) external pure returns (uint256 stakeUnits);  function calculateUnlockedRewards(     RewardSchedule[] memory rewardSchedules,     uint256 rewardBalance,     uint256 sharesOutstanding,     uint256 timestamp ) external pure returns (uint256 unlockedRewards);  function calculateRewardFromStakes(     StakeData[] memory stakes,     uint256 unstakeAmount,     uint256 unlockedRewards,     uint256 totalStakeUnits,     uint256 timestamp,     RewardScaling memory rewardScaling ) external pure returns (RewardOutput memory out);  function calculateReward(     uint256 unlockedRewards,     uint256 stakeAmount,     uint256 stakeDuration,     uint256 totalStakeUnits,     RewardScaling memory rewardScaling ) external pure returns (uint256 reward);  } /// @title Hypervisor /// @notice Reward distribution contract with time multiplier /// Access Control /// - Power controller: ///     Can power off / shutdown the Hypervisor ///     Can withdraw rewards from reward pool once shutdown /// - Proxy owner: ///     Can change arbitrary logic / state by upgrading the Hypervisor ///     Is unable to operate on user funds due to UniversalVault ///     Is unable to operate on reward pool funds when reward pool is offline / shutdown /// - Hypervisor admin: ///     Can add funds to the Hypervisor, register bonus tokens, and whitelist new vault factories ///     Is a subset of proxy owner permissions /// - User: ///     Can deposit / withdraw / ragequit /// Hypervisor State Machine /// - Online: ///     Hypervisor is operating normally, all functions are enabled /// - Offline: ///     Hypervisor is temporarely disabled for maintenance ///     User deposits and withdrawls are disabled, ragequit remains enabled ///     Users can withdraw their stake through rageQuit() but forego their pending reward ///     Should only be used when downtime required for an upgrade /// - Shutdown: ///     Hypervisor is permanently disabled ///     All functions are disabled with the exception of ragequit ///     Users can withdraw their stake through rageQuit() ///     Power controller can withdraw from the reward pool ///     Should only be used if Proxy Owner role is compromized contract Hypervisor is IHypervisor, Powered, Ownable {     using SafeMath for uint256;     using EnumerableSet for EnumerableSet.AddressSet; /* constants */  // An upper bound on the number of active stakes per vault is required to prevent // calls to rageQuit() from reverting. // With 30 stakes in a vault, ragequit costs 432811 gas which is conservatively lower // than the hardcoded limit of 500k gas on the vault. // This limit is configurable and could be increased in a future deployment. // Ultimately, to avoid a need for fixed upper bounds, the EVM would need to provide // an error code that allows for reliably catching out-of-gas errors on remote calls. uint256 public constant MAX_STAKES_PER_VAULT = 30; uint256 public constant MAX_REWARD_TOKENS = 50; uint256 public constant BASE_SHARES_PER_WEI = 1000000; uint256 public stakeLimit = 2500 ether;  /* storage */  HypervisorData private _hypervisor; mapping(address =&gt; VaultData) private _vaults; EnumerableSet.AddressSet private _bonusTokenSet; EnumerableSet.AddressSet private _vaultFactorySet;  /* initializer */  /// @notice Initizalize Hypervisor /// access control: only proxy constructor /// state machine: can only be called once /// state scope: set initialization variables /// token transfer: none /// @param ownerAddress address The admin address /// @param rewardPoolFactory address The factory to use for deploying the RewardPool /// @param powerSwitchFactory address The factory to use for deploying the PowerSwitch /// @param stakingToken address The address of the staking token for this Hypervisor /// @param rewardToken address The address of the reward token for this Hypervisor /// @param rewardScaling RewardScaling The config for reward scaling floor, ceiling, and time constructor(     address ownerAddress,     address rewardPoolFactory,     address powerSwitchFactory,     address stakingToken,     address rewardToken,     RewardScaling memory rewardScaling,     uint256 _stakeLimit ) {     // the scaling floor must be smaller than ceiling     require(rewardScaling.floor &lt;= rewardScaling.ceiling, ""Hypervisor: floor above ceiling"");      // setting rewardScalingTime to 0 would cause divide by zero error     // to disable reward scaling, use rewardScalingFloor == rewardScalingCeiling     require(rewardScaling.time != 0, ""Hypervisor: scaling time cannot be zero"");      // deploy power switch     address powerSwitch = IFactory(powerSwitchFactory).create(abi.encode(ownerAddress));      // deploy reward pool     address rewardPool = IFactory(rewardPoolFactory).create(abi.encode(powerSwitch));      // set internal configs     Ownable.transferOwnership(ownerAddress);     Powered._setPowerSwitch(powerSwitch);      // commit to storage     _hypervisor.stakingToken = stakingToken;     _hypervisor.rewardToken = rewardToken;     _hypervisor.rewardPool = rewardPool;     _hypervisor.rewardScaling = rewardScaling;      stakeLimit = _stakeLimit;      // emit event     emit HypervisorCreated(rewardPool, powerSwitch); }  /* getter functions */  function getBonusTokenSetLength() external view override returns (uint256 length) {     return _bonusTokenSet.length(); }  function getBonusTokenAtIndex(uint256 index)     external     view     override     returns (address bonusToken) {     return _bonusTokenSet.at(index); }  function getVaultFactorySetLength() external view override returns (uint256 length) {     return _vaultFactorySet.length(); }  function getVaultFactoryAtIndex(uint256 index)     external     view     override     returns (address factory) {     return _vaultFactorySet.at(index); }  function isValidVault(address target) public view override returns (bool validity) {     // validate target is created from whitelisted vault factory     for (uint256 index = 0; index &lt; _vaultFactorySet.length(); index++) {         if (IInstanceRegistry(_vaultFactorySet.at(index)).isInstance(target)) {             return true;         }     }     // explicit return     return false; }  function isValidAddress(address target) public view override returns (bool validity) {     // sanity check target for potential input errors     return         target != address(this) &amp;&amp;         target != address(0) &amp;&amp;         target != _hypervisor.stakingToken &amp;&amp;         target != _hypervisor.rewardToken &amp;&amp;         target != _hypervisor.rewardPool &amp;&amp;         !_bonusTokenSet.contains(target); }  /* Hypervisor getters */  function getHypervisorData() external view override returns (HypervisorData memory hypervisor) {     return _hypervisor; }  function getCurrentUnlockedRewards() public view override returns (uint256 unlockedRewards) {     // calculate reward available based on state     return getFutureUnlockedRewards(block.timestamp); }  function getFutureUnlockedRewards(uint256 timestamp)     public     view     override     returns (uint256 unlockedRewards) {     // get reward amount remaining     uint256 remainingRewards = IERC20(_hypervisor.rewardToken).balanceOf(_hypervisor.rewardPool);     // calculate reward available based on state     unlockedRewards = calculateUnlockedRewards(         _hypervisor.rewardSchedules,         remainingRewards,         _hypervisor.rewardSharesOutstanding,         timestamp     );     // explicit return     return unlockedRewards; }  function getCurrentTotalStakeUnits() public view override returns (uint256 totalStakeUnits) {     // calculate new stake units     return getFutureTotalStakeUnits(block.timestamp); }  function getFutureTotalStakeUnits(uint256 timestamp)     public     view     override     returns (uint256 totalStakeUnits) {     // return early if no change     if (timestamp == _hypervisor.lastUpdate) return _hypervisor.totalStakeUnits;     // calculate new stake units     uint256 newStakeUnits =         calculateStakeUnits(_hypervisor.totalStake, _hypervisor.lastUpdate, timestamp);     // add to cached total     totalStakeUnits = _hypervisor.totalStakeUnits.add(newStakeUnits);     // explicit return     return totalStakeUnits; }  /* vault getters */  function getVaultData(address vault)     external     view     override     returns (VaultData memory vaultData) {     return _vaults[vault]; }  function getCurrentVaultReward(address vault) external view override returns (uint256 reward) {     // calculate rewards     return         calculateRewardFromStakes(             _vaults[vault]                 .stakes,             _vaults[vault]                 .totalStake,             getCurrentUnlockedRewards(),             getCurrentTotalStakeUnits(),             block                 .timestamp,             _hypervisor                 .rewardScaling         )             .reward; }  function getFutureVaultReward(address vault, uint256 timestamp)     external     view     override     returns (uint256 reward) {     // calculate rewards     return         calculateRewardFromStakes(             _vaults[vault]                 .stakes,             _vaults[vault]                 .totalStake,             getFutureUnlockedRewards(timestamp),             getFutureTotalStakeUnits(timestamp),             timestamp,             _hypervisor                 .rewardScaling         )             .reward; }  function getCurrentStakeReward(address vault, uint256 stakeAmount)     external     view     override     returns (uint256 reward) {     // calculate rewards     return         calculateRewardFromStakes(             _vaults[vault]                 .stakes,             stakeAmount,             getCurrentUnlockedRewards(),             getCurrentTotalStakeUnits(),             block                 .timestamp,             _hypervisor                 .rewardScaling         )             .reward; }  function getFutureStakeReward(     address vault,     uint256 stakeAmount,     uint256 timestamp ) external view override returns (uint256 reward) {     // calculate rewards     return         calculateRewardFromStakes(             _vaults[vault]                 .stakes,             stakeAmount,             getFutureUnlockedRewards(timestamp),             getFutureTotalStakeUnits(timestamp),             timestamp,             _hypervisor                 .rewardScaling         )             .reward; }  function getCurrentVaultStakeUnits(address vault)     public     view     override     returns (uint256 stakeUnits) {     // calculate stake units     return getFutureVaultStakeUnits(vault, block.timestamp); }  function getFutureVaultStakeUnits(address vault, uint256 timestamp)     public     view     override     returns (uint256 stakeUnits) {     // calculate stake units     return calculateTotalStakeUnits(_vaults[vault].stakes, timestamp); }  /* pure functions */  function calculateTotalStakeUnits(StakeData[] memory stakes, uint256 timestamp)     public     pure     override     returns (uint256 totalStakeUnits) {     for (uint256 index; index &lt; stakes.length; index++) {         // reference stake         StakeData memory stakeData = stakes[index];         // calculate stake units         uint256 stakeUnits =             calculateStakeUnits(stakeData.amount, stakeData.timestamp, timestamp);         // add to running total         totalStakeUnits = totalStakeUnits.add(stakeUnits);     } }  function calculateStakeUnits(     uint256 amount,     uint256 start,     uint256 end ) public pure override returns (uint256 stakeUnits) {     // calculate duration     uint256 duration = end.sub(start);     // calculate stake units     stakeUnits = duration.mul(amount);     // explicit return     return stakeUnits; }  function calculateUnlockedRewards(     RewardSchedule[] memory rewardSchedules,     uint256 rewardBalance,     uint256 sharesOutstanding,     uint256 timestamp ) public pure override returns (uint256 unlockedRewards) {     // return 0 if no registered schedules     if (rewardSchedules.length == 0) {         return 0;     }      // calculate reward shares locked across all reward schedules     uint256 sharesLocked;     for (uint256 index = 0; index &lt; rewardSchedules.length; index++) {         // fetch reward schedule storage reference         RewardSchedule memory schedule = rewardSchedules[index];          // caculate amount of shares available on this schedule         // if (now - start) &lt; duration         //   sharesLocked = shares - (shares * (now - start) / duration)         // else         //   sharesLocked = 0         uint256 currentSharesLocked = 0;         if (timestamp.sub(schedule.start) &lt; schedule.duration) {             currentSharesLocked = schedule.shares.sub(                 schedule.shares.mul(timestamp.sub(schedule.start)).div(schedule.duration)             );         }          // add to running total         sharesLocked = sharesLocked.add(currentSharesLocked);     }      // convert shares to reward     // rewardLocked = sharesLocked * rewardBalance / sharesOutstanding     uint256 rewardLocked = sharesLocked.mul(rewardBalance).div(sharesOutstanding);      // calculate amount available     // unlockedRewards = rewardBalance - rewardLocked     unlockedRewards = rewardBalance.sub(rewardLocked);      // explicit return     return unlockedRewards; }  function calculateRewardFromStakes(     StakeData[] memory stakes,     uint256 unstakeAmount,     uint256 unlockedRewards,     uint256 totalStakeUnits,     uint256 timestamp,     RewardScaling memory rewardScaling ) public pure override returns (RewardOutput memory out) {     uint256 stakesToDrop = 0;     while (unstakeAmount &gt; 0) {         // fetch vault stake storage reference         StakeData memory lastStake = stakes[stakes.length.sub(stakesToDrop).sub(1)];          // calculate stake duration         uint256 stakeDuration = timestamp.sub(lastStake.timestamp);          uint256 currentAmount;         if (lastStake.amount &gt; unstakeAmount) {             // set current amount to remaining unstake amount             currentAmount = unstakeAmount;             // amount of last stake is reduced             out.lastStakeAmount = lastStake.amount.sub(unstakeAmount);         } else {             // set current amount to amount of last stake             currentAmount = lastStake.amount;             // add to stakes to drop             stakesToDrop += 1;         }          // update remaining unstakeAmount         unstakeAmount = unstakeAmount.sub(currentAmount);          // calculate reward amount         uint256 currentReward =             calculateReward(                 unlockedRewards,                 currentAmount,                 stakeDuration,                 totalStakeUnits,                 rewardScaling             );          // update cumulative reward         out.reward = out.reward.add(currentReward);          // update cached unlockedRewards         unlockedRewards = unlockedRewards.sub(currentReward);          // calculate time weighted stake         uint256 stakeUnits = currentAmount.mul(stakeDuration);          // update cached totalStakeUnits         totalStakeUnits = totalStakeUnits.sub(stakeUnits);     }      // explicit return     return         RewardOutput(             out.lastStakeAmount,             stakes.length.sub(stakesToDrop),             out.reward,             totalStakeUnits         ); }  function calculateReward(     uint256 unlockedRewards,     uint256 stakeAmount,     uint256 stakeDuration,     uint256 totalStakeUnits,     RewardScaling memory rewardScaling ) public pure override returns (uint256 reward) {     // calculate time weighted stake     uint256 stakeUnits = stakeAmount.mul(stakeDuration);      // calculate base reward     // baseReward = unlockedRewards * stakeUnits / totalStakeUnits     uint256 baseReward = 0;     if (totalStakeUnits != 0) {         // scale reward according to proportional weight         baseReward = unlockedRewards.mul(stakeUnits).div(totalStakeUnits);     }      // calculate scaled reward     // if no scaling or scaling period completed     //   reward = baseReward     // else     //   minReward = baseReward * scalingFloor / scalingCeiling     //   bonusReward = baseReward     //                 * (scalingCeiling - scalingFloor) / scalingCeiling     //                 * duration / scalingTime     //   reward = minReward + bonusReward     if (stakeDuration &gt;= rewardScaling.time || rewardScaling.floor == rewardScaling.ceiling) {         // no reward scaling applied         reward = baseReward;     } else {         // calculate minimum reward using scaling floor         uint256 minReward = baseReward.mul(rewardScaling.floor).div(rewardScaling.ceiling);          // calculate bonus reward with vested portion of scaling factor         uint256 bonusReward =             baseReward                 .mul(stakeDuration)                 .mul(rewardScaling.ceiling.sub(rewardScaling.floor))                 .div(rewardScaling.ceiling)                 .div(rewardScaling.time);          // add minimum reward and bonus reward         reward = minReward.add(bonusReward);     }      // explicit return     return reward; }  /* admin functions */  /// @notice Add funds to the Hypervisor /// access control: only admin /// state machine: ///   - can be called multiple times ///   - only online /// state scope: ///   - increase _hypervisor.rewardSharesOutstanding ///   - append to _hypervisor.rewardSchedules /// token transfer: transfer staking tokens from msg.sender to reward pool /// @param amount uint256 Amount of reward tokens to deposit /// @param duration uint256 Duration over which to linearly unlock rewards function fund(uint256 amount, uint256 duration) external onlyOwner onlyOnline {     // validate duration     require(duration != 0, ""Hypervisor: invalid duration"");      // create new reward shares     // if existing rewards on this Hypervisor     //   mint new shares proportional to % change in rewards remaining     //   newShares = remainingShares * newReward / remainingRewards     // else     //   mint new shares with BASE_SHARES_PER_WEI initial conversion rate     //   store as fixed point number with same  of decimals as reward token     uint256 newRewardShares;     if (_hypervisor.rewardSharesOutstanding &gt; 0) {         uint256 remainingRewards = IERC20(_hypervisor.rewardToken).balanceOf(_hypervisor.rewardPool);         newRewardShares = _hypervisor.rewardSharesOutstanding.mul(amount).div(remainingRewards);     } else {         newRewardShares = amount.mul(BASE_SHARES_PER_WEI);     }      // add reward shares to total     _hypervisor.rewardSharesOutstanding = _hypervisor.rewardSharesOutstanding.add(newRewardShares);      // store new reward schedule     _hypervisor.rewardSchedules.push(RewardSchedule(duration, block.timestamp, newRewardShares));      // transfer reward tokens to reward pool     TransferHelper.safeTransferFrom(         _hypervisor.rewardToken,         msg.sender,         _hypervisor.rewardPool,         amount     );      // emit event     emit HypervisorFunded(amount, duration); }  /// @notice Add vault factory to whitelist /// @dev use this function to enable stakes to vaults coming from the specified ///      factory contract /// access control: only admin /// state machine: ///   - can be called multiple times ///   - not shutdown /// state scope: ///   - append to _vaultFactorySet /// token transfer: none /// @param factory address The address of the vault factory function registerVaultFactory(address factory) external onlyOwner notShutdown {     // add factory to set     require(_vaultFactorySet.add(factory), ""Hypervisor: vault factory already registered"");      // emit event     emit VaultFactoryRegistered(factory); }  /// @notice Remove vault factory from whitelist /// @dev use this function to disable new stakes to vaults coming from the specified ///      factory contract. ///      note: vaults with existing stakes from this factory are sill able to unstake /// access control: only admin /// state machine: ///   - can be called multiple times ///   - not shutdown /// state scope: ///   - remove from _vaultFactorySet /// token transfer: none /// @param factory address The address of the vault factory function removeVaultFactory(address factory) external onlyOwner notShutdown {     // remove factory from set     require(_vaultFactorySet.remove(factory), ""Hypervisor: vault factory not registered"");      // emit event     emit VaultFactoryRemoved(factory); }  /// @notice Register bonus token for distribution /// @dev use this function to enable distribution of any ERC20 held by the RewardPool contract /// access control: only admin /// state machine: ///   - can be called multiple times ///   - only online /// state scope: ///   - append to _bonusTokenSet /// token transfer: none /// @param bonusToken address The address of the bonus token function registerBonusToken(address bonusToken) external onlyOwner onlyOnline {     // verify valid bonus token     _validateAddress(bonusToken);      // verify bonus token count     require(_bonusTokenSet.length() &lt; MAX_REWARD_TOKENS, ""Hypervisor: max bonus tokens reached "");      // add token to set     assert(_bonusTokenSet.add(bonusToken));      // emit event     emit BonusTokenRegistered(bonusToken); }  /// @notice Rescue tokens from RewardPool /// @dev use this function to rescue tokens from RewardPool contract ///      without distributing to stakers or triggering emergency shutdown /// access control: only admin /// state machine: ///   - can be called multiple times ///   - only online /// state scope: none /// token transfer: transfer requested token from RewardPool to recipient /// @param token address The address of the token to rescue /// @param recipient address The address of the recipient /// @param amount uint256 The amount of tokens to rescue function rescueTokensFromRewardPool(     address token,     address recipient,     uint256 amount ) external onlyOwner onlyOnline {     // verify recipient     _validateAddress(recipient);      // check not attempting to unstake reward token     require(token != _hypervisor.rewardToken, ""Hypervisor: invalid address"");      // check not attempting to wthdraw bonus token     require(!_bonusTokenSet.contains(token), ""Hypervisor: invalid address"");      // transfer tokens to recipient     IRewardPool(_hypervisor.rewardPool).sendERC20(token, recipient, amount); }  /* user functions */  /// @notice Stake tokens /// @dev anyone can stake to any vault if they have valid permission /// access control: anyone /// state machine: ///   - can be called multiple times ///   - only online ///   - when vault exists on this Hypervisor /// state scope: ///   - append to _vaults[vault].stakes ///   - increase _vaults[vault].totalStake ///   - increase _hypervisor.totalStake ///   - increase _hypervisor.totalStakeUnits ///   - increase _hypervisor.lastUpdate /// token transfer: transfer staking tokens from msg.sender to vault /// @param vault address The address of the vault to stake from /// @param amount uint256 The amount of staking tokens to stake function stake(     address vault,     uint256 amount,     bytes calldata permission ) external override onlyOnline {     // verify vault is valid     require(isValidVault(vault), ""Hypervisor: vault is not registered"");      // verify non-zero amount     require(amount != 0, ""Hypervisor: no amount staked"");      // fetch vault storage reference     VaultData storage vaultData = _vaults[vault];      // verify stakes boundary not reached     require(         vaultData.stakes.length &lt; MAX_STAKES_PER_VAULT,         ""Hypervisor: MAX_STAKES_PER_VAULT reached""     );      // update cached sum of stake units across all vaults     _updateTotalStakeUnits();      // store amount and timestamp     vaultData.stakes.push(StakeData(amount, block.timestamp));      // update cached total vault and Hypervisor amounts     vaultData.totalStake = vaultData.totalStake.add(amount);     // verify stake quantity without bounds     require(         stakeLimit == 0 || vaultData.totalStake &lt;= stakeLimit,         ""Hypervisor: Stake limit exceeded""     );     _hypervisor.totalStake = _hypervisor.totalStake.add(amount);      // call lock on vault     IUniversalVault(vault).lock(_hypervisor.stakingToken, amount, permission);      // emit event     emit Staked(vault, amount); }  /// @notice Unstake staking tokens and claim reward /// @dev rewards can only be claimed when unstaking /// access control: only owner of vault /// state machine: ///   - when vault exists on this Hypervisor ///   - after stake from vault ///   - can be called multiple times while sufficient stake remains ///   - only online /// state scope: ///   - decrease _hypervisor.rewardSharesOutstanding ///   - decrease _hypervisor.totalStake ///   - increase _hypervisor.lastUpdate ///   - modify _hypervisor.totalStakeUnits ///   - modify _vaults[vault].stakes ///   - decrease _vaults[vault].totalStake /// token transfer: ///   - transfer reward tokens from reward pool to recipient ///   - transfer bonus tokens from reward pool to recipient /// @param vault address The vault to unstake from /// @param amount uint256 The amount of staking tokens to unstake function unstakeAndClaim(     address vault,     uint256 amount,     bytes calldata permission ) external override onlyOnline {     // fetch vault storage reference     VaultData storage vaultData = _vaults[vault];      // verify non-zero amount     require(amount != 0, ""Hypervisor: no amount unstaked"");      address recipient = IUniversalVault(vault).owner();      // validate recipient     _validateAddress(recipient);      // check for sufficient vault stake amount     require(vaultData.totalStake &gt;= amount, ""Hypervisor: insufficient vault stake"");      // check for sufficient Hypervisor stake amount     // if this check fails, there is a bug in stake accounting     assert(_hypervisor.totalStake &gt;= amount);      // update cached sum of stake units across all vaults     _updateTotalStakeUnits();      // get reward amount remaining     uint256 remainingRewards = IERC20(_hypervisor.rewardToken).balanceOf(_hypervisor.rewardPool);      // calculate vested portion of reward pool     uint256 unlockedRewards =         calculateUnlockedRewards(             _hypervisor.rewardSchedules,             remainingRewards,             _hypervisor.rewardSharesOutstanding,             block.timestamp         );      // calculate vault time weighted reward with scaling     RewardOutput memory out =         calculateRewardFromStakes(             vaultData.stakes,             amount,             unlockedRewards,             _hypervisor.totalStakeUnits,             block.timestamp,             _hypervisor.rewardScaling         );      // update stake data in storage     if (out.newStakesCount == 0) {         // all stakes have been unstaked         delete vaultData.stakes;     } else {         // some stakes have been completely or partially unstaked         // delete fully unstaked stakes         while (vaultData.stakes.length &gt; out.newStakesCount) vaultData.stakes.pop();         // update partially unstaked stake         vaultData.stakes[out.newStakesCount.sub(1)].amount = out.lastStakeAmount;     }      // update cached stake totals     vaultData.totalStake = vaultData.totalStake.sub(amount);     _hypervisor.totalStake = _hypervisor.totalStake.sub(amount);     _hypervisor.totalStakeUnits = out.newTotalStakeUnits;      // unlock staking tokens from vault     IUniversalVault(vault).unlock(_hypervisor.stakingToken, amount, permission);      // emit event     emit Unstaked(vault, amount);      // only perform on non-zero reward     if (out.reward &gt; 0) {         // calculate shares to burn         // sharesToBurn = sharesOutstanding * reward / remainingRewards         uint256 sharesToBurn =             _hypervisor.rewardSharesOutstanding.mul(out.reward).div(remainingRewards);          // burn claimed shares         _hypervisor.rewardSharesOutstanding = _hypervisor.rewardSharesOutstanding.sub(sharesToBurn);          // transfer bonus tokens from reward pool to recipient         if (_bonusTokenSet.length() &gt; 0) {             for (uint256 index = 0; index &lt; _bonusTokenSet.length(); index++) {                 // fetch bonus token address reference                 address bonusToken = _bonusTokenSet.at(index);                  // calculate bonus token amount                 // bonusAmount = bonusRemaining * reward / remainingRewards                 uint256 bonusAmount =                     IERC20(bonusToken).balanceOf(_hypervisor.rewardPool).mul(out.reward).div(                         remainingRewards                     );                  // transfer bonus token                 IRewardPool(_hypervisor.rewardPool).sendERC20(bonusToken, recipient, bonusAmount);                  // emit event                 emit RewardClaimed(vault, recipient, bonusToken, bonusAmount);             }         }          // transfer reward tokens from reward pool to recipient         IRewardPool(_hypervisor.rewardPool).sendERC20(_hypervisor.rewardToken, recipient, out.reward);          // emit event         emit RewardClaimed(vault, recipient, _hypervisor.rewardToken, out.reward);     } }  /// @notice Exit Hypervisor without claiming reward /// @dev This function should never revert when correctly called by the vault. ///      A max number of stakes per vault is set with MAX_STAKES_PER_VAULT to ///      place an upper bound on the for loop in calculateTotalStakeUnits(). /// access control: only callable by the vault directly /// state machine: ///   - when vault exists on this Hypervisor ///   - when active stake from this vault ///   - any power state /// state scope: ///   - decrease _hypervisor.totalStake ///   - increase _hypervisor.lastUpdate ///   - modify _hypervisor.totalStakeUnits ///   - delete _vaults[vault] /// token transfer: none function rageQuit() external override {     // fetch vault storage reference     VaultData storage _vaultData = _vaults[msg.sender];      // revert if no active stakes     require(_vaultData.stakes.length != 0, ""Hypervisor: no stake"");      // update cached sum of stake units across all vaults     _updateTotalStakeUnits();      // emit event     emit Unstaked(msg.sender, _vaultData.totalStake);      // update cached totals     _hypervisor.totalStake = _hypervisor.totalStake.sub(_vaultData.totalStake);     _hypervisor.totalStakeUnits = _hypervisor.totalStakeUnits.sub(         calculateTotalStakeUnits(_vaultData.stakes, block.timestamp)     );      // delete stake data     delete _vaults[msg.sender]; }  /* convenience functions */  function _updateTotalStakeUnits() private {     // update cached totalStakeUnits     _hypervisor.totalStakeUnits = getCurrentTotalStakeUnits();     // update cached lastUpdate     _hypervisor.lastUpdate = block.timestamp; }  function _validateAddress(address target) private view {     // sanity check target for potential input errors     require(isValidAddress(target), ""Hypervisor: invalid address""); }  function _truncateStakesArray(StakeData[] memory array, uint256 newLength)     private     pure     returns (StakeData[] memory newArray) {     newArray = new StakeData[](newLength);     for (uint256 index = 0; index &lt; newLength; index++) {         newArray[index] = array[index];     }     return newArray; }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: ""{task}"". Ideas: ""{ideas}"". As the {assistant_role}, your primary objective is to perform a thorough and detailed inspection of the provided contract code, with a particular focus on identifying vulnerabilities related to Impracticality of Exact Match. There are specific cases where the code may have Impracticality of Exact Match vulnerabilities: 1. The use of this.balance for checking if the funding goal is reached is flawed. This exact comparison is risky because even a tiny amount above or below the target amount will result in a false value. Moreover, users could manipulate the contract by sending an exact amount to influence the outcome. 2. Relying on an exact balance match for contract logic can lead to unexpected failures or exploitations due to the granularity of ether (wei) and typical transaction handling in Ethereum. If you identify Impracticality of Exact Match issues, respond with: "" Impracticality of Exact Match Identified."" For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE ''' DETAILED DESCRIPTION of the vulnerability, AND recommended mitigation/fix with no upgrade code ''' If you don't find any vulnerabilities, respond only with: "" NO Impracticality of Exact Match Issues."" |
| **phase_name** | ImpracticalityMatchDetector |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 1, 'modification_conclusion': '', 'cycle_index': 1, 'task': '// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport {SafeMath} from ""@openzeppelin/contracts/math/SafeMath.sol"";\nimport {EnumerableSet} from ""@openzeppelin/contracts/utils/EnumerableSet.sol"";\nimport {IERC20} from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";\nimport {Ownable} from ""@openzeppelin/contracts/access/Ownable.sol"";\nimport {TransferHelper} from ""@uniswap/lib/contracts/libraries/TransferHelper.sol"";\n\nimport {IFactory} from ""../factory/IFactory.sol"";\nimport {IInstanceRegistry} from ""../factory/InstanceRegistry.sol"";\nimport {IUniversalVault} from ""../visor/Visor.sol"";\nimport {IRewardPool} from ""./RewardPool.sol"";\nimport {Powered} from ""./Powered.sol"";\n\ninterface IRageQuit {\n    function rageQuit() external;\n}\n\ninterface IHypervisor is IRageQuit {\n    / admin events /\n\n    event HypervisorCreated(address rewardPool, address powerSwitch);\n    event HypervisorFunded(uint256 amount, uint256 duration);\n    event BonusTokenRegistered(address token);\n    event VaultFactoryRegistered(address factory);\n    event VaultFactoryRemoved(address factory);\n\n    / user events /\n\n    event Staked(address vault, uint256 amount);\n    event Unstaked(address vault, uint256 amount);\n    event RewardClaimed(address vault, address recipient, address token, uint256 amount);\n\n    / data types /\n\n    struct HypervisorData {\n        address stakingToken;\n        address rewardToken;\n        address rewardPool;\n        RewardScaling rewardScaling;\n        uint256 rewardSharesOutstanding;\n        uint256 totalStake;\n        uint256 totalStakeUnits;\n        uint256 lastUpdate;\n        RewardSchedule[] rewardSchedules;\n    }\n\n    struct RewardSchedule {\n        uint256 duration;\n        uint256 start;\n        uint256 shares;\n    }\n\n    struct VaultData {\n        uint256 totalStake;\n        StakeData[] stakes;\n    }\n\n    struct StakeData {\n        uint256 amount;\n        uint256 timestamp;\n    }\n\n    struct RewardScaling {\n        uint256 floor;\n        uint256 ceiling;\n        uint256 time;\n    }\n\n    struct RewardOutput {\n        uint256 lastStakeAmount;\n        uint256 newStakesCount;\n        uint256 reward;\n        uint256 newTotalStakeUnits;\n    }\n\n    / user functions /\n\n    function stake(\n        address vault,\n        uint256 amount,\n        bytes calldata permission\n    ) external;\n\n    function unstakeAndClaim(\n        address vault,\n        uint256 amount,\n        bytes calldata permission\n    ) external;\n\n    / getter functions /\n\n    function getHypervisorData() external view returns (HypervisorData memory hypervisor);\n\n    function getBonusTokenSetLength() external view returns (uint256 length);\n\n    function getBonusTokenAtIndex(uint256 index) external view returns (address bonusToken);\n\n    function getVaultFactorySetLength() external view returns (uint256 length);\n\n    function getVaultFactoryAtIndex(uint256 index) external view returns (address factory);\n\n    function getVaultData(address vault) external view returns (VaultData memory vaultData);\n\n    function isValidAddress(address target) external view returns (bool validity);\n\n    function isValidVault(address target) external view returns (bool validity);\n\n    function getCurrentUnlockedRewards() external view returns (uint256 unlockedRewards);\n\n    function getFutureUnlockedRewards(uint256 timestamp)\n        external\n        view\n        returns (uint256 unlockedRewards);\n\n    function getCurrentVaultReward(address vault) external view returns (uint256 reward);\n\n    function getCurrentStakeReward(address vault, uint256 stakeAmount)\n        external\n        view\n        returns (uint256 reward);\n\n    function getFutureVaultReward(address vault, uint256 timestamp)\n        external\n        view\n        returns (uint256 reward);\n\n    function getFutureStakeReward(\n        address vault,\n        uint256 stakeAmount,\n        uint256 timestamp\n    ) external view returns (uint256 reward);\n\n    function getCurrentVaultStakeUnits(address vault) external view returns (uint256 stakeUnits);\n\n    function getFutureVaultStakeUnits(address vault, uint256 timestamp)\n        external\n        view\n        returns (uint256 stakeUnits);\n\n    function getCurrentTotalStakeUnits() external view returns (uint256 totalStakeUnits);\n\n    function getFutureTotalStakeUnits(uint256 timestamp)\n        external\n        view\n        returns (uint256 totalStakeUnits);\n\n    / pure functions /\n\n    function calculateTotalStakeUnits(StakeData[] memory stakes, uint256 timestamp)\n        external\n        pure\n        returns (uint256 totalStakeUnits);\n\n    function calculateStakeUnits(\n        uint256 amount,\n        uint256 start,\n        uint256 end\n    ) external pure returns (uint256 stakeUnits);\n\n    function calculateUnlockedRewards(\n        RewardSchedule[] memory rewardSchedules,\n        uint256 rewardBalance,\n        uint256 sharesOutstanding,\n        uint256 timestamp\n    ) external pure returns (uint256 unlockedRewards);\n\n    function calculateRewardFromStakes(\n        StakeData[] memory stakes,\n        uint256 unstakeAmount,\n        uint256 unlockedRewards,\n        uint256 totalStakeUnits,\n        uint256 timestamp,\n        RewardScaling memory rewardScaling\n    ) external pure returns (RewardOutput memory out);\n\n    function calculateReward(\n        uint256 unlockedRewards,\n        uint256 stakeAmount,\n        uint256 stakeDuration,\n        uint256 totalStakeUnits,\n        RewardScaling memory rewardScaling\n    ) external pure returns (uint256 reward);\n}\n\n/// @title Hypervisor\n/// @notice Reward distribution contract with time multiplier\n/// Access Control\n/// - Power controller:\n///     Can power off / shutdown the Hypervisor\n///     Can withdraw rewards from reward pool once shutdown\n/// - Proxy owner:\n///     Can change arbitrary logic / state by upgrading the Hypervisor\n///     Is unable to operate on user funds due to UniversalVault\n///     Is unable to operate on reward pool funds when reward pool is offline / shutdown\n/// - Hypervisor admin:\n///     Can add funds to the Hypervisor, register bonus tokens, and whitelist new vault factories\n///     Is a subset of proxy owner permissions\n/// - User:\n///     Can deposit / withdraw / ragequit\n/// Hypervisor State Machine\n/// - Online:\n///     Hypervisor is operating normally, all functions are enabled\n/// - Offline:\n///     Hypervisor is temporarely disabled for maintenance\n///     User deposits and withdrawls are disabled, ragequit remains enabled\n///     Users can withdraw their stake through rageQuit() but forego their pending reward\n///     Should only be used when downtime required for an upgrade\n/// - Shutdown:\n///     Hypervisor is permanently disabled\n///     All functions are disabled with the exception of ragequit\n///     Users can withdraw their stake through rageQuit()\n///     Power controller can withdraw from the reward pool\n///     Should only be used if Proxy Owner role is compromized\ncontract Hypervisor is IHypervisor, Powered, Ownable {\n    using SafeMath for uint256;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    / constants /\n\n    // An upper bound on the number of active stakes per vault is required to prevent\n    // calls to rageQuit() from reverting.\n    // With 30 stakes in a vault, ragequit costs 432811 gas which is conservatively lower\n    // than the hardcoded limit of 500k gas on the vault.\n    // This limit is configurable and could be increased in a future deployment.\n    // Ultimately, to avoid a need for fixed upper bounds, the EVM would need to provide\n    // an error code that allows for reliably catching out-of-gas errors on remote calls.\n    uint256 public constant MAX_STAKES_PER_VAULT = 30;\n    uint256 public constant MAX_REWARD_TOKENS = 50;\n    uint256 public constant BASE_SHARES_PER_WEI = 1000000;\n    uint256 public stakeLimit = 2500 ether;\n\n    / storage /\n\n    HypervisorData private _hypervisor;\n    mapping(address =&gt; VaultData) private _vaults;\n    EnumerableSet.AddressSet private _bonusTokenSet;\n    EnumerableSet.AddressSet private _vaultFactorySet;\n\n    / initializer /\n\n    /// @notice Initizalize Hypervisor\n    /// access control: only proxy constructor\n    /// state machine: can only be called once\n    /// state scope: set initialization variables\n    /// token transfer: none\n    /// @param ownerAddress address The admin address\n    /// @param rewardPoolFactory address The factory to use for deploying the RewardPool\n    /// @param powerSwitchFactory address The factory to use for deploying the PowerSwitch\n    /// @param stakingToken address The address of the staking token for this Hypervisor\n    /// @param rewardToken address The address of the reward token for this Hypervisor\n    /// @param rewardScaling RewardScaling The config for reward scaling floor, ceiling, and time\n    constructor(\n        address ownerAddress,\n        address rewardPoolFactory,\n        address powerSwitchFactory,\n        address stakingToken,\n        address rewardToken,\n        RewardScaling memory rewardScaling,\n        uint256 _stakeLimit\n    ) {\n        // the scaling floor must be smaller than ceiling\n        require(rewardScaling.floor &lt;= rewardScaling.ceiling, ""Hypervisor: floor above ceiling"");\n\n        // setting rewardScalingTime to 0 would cause divide by zero error\n        // to disable reward scaling, use rewardScalingFloor == rewardScalingCeiling\n        require(rewardScaling.time != 0, ""Hypervisor: scaling time cannot be zero"");\n\n        // deploy power switch\n        address powerSwitch = IFactory(powerSwitchFactory).create(abi.encode(ownerAddress));\n\n        // deploy reward pool\n        address rewardPool = IFactory(rewardPoolFactory).create(abi.encode(powerSwitch));\n\n        // set internal configs\n        Ownable.transferOwnership(ownerAddress);\n        Powered._setPowerSwitch(powerSwitch);\n\n        // commit to storage\n        _hypervisor.stakingToken = stakingToken;\n        _hypervisor.rewardToken = rewardToken;\n        _hypervisor.rewardPool = rewardPool;\n        _hypervisor.rewardScaling = rewardScaling;\n\n        stakeLimit = _stakeLimit;\n\n        // emit event\n        emit HypervisorCreated(rewardPool, powerSwitch);\n    }\n\n    / getter functions /\n\n    function getBonusTokenSetLength() external view override returns (uint256 length) {\n        return _bonusTokenSet.length();\n    }\n\n    function getBonusTokenAtIndex(uint256 index)\n        external\n        view\n        override\n        returns (address bonusToken)\n    {\n        return _bonusTokenSet.at(index);\n    }\n\n    function getVaultFactorySetLength() external view override returns (uint256 length) {\n        return _vaultFactorySet.length();\n    }\n\n    function getVaultFactoryAtIndex(uint256 index)\n        external\n        view\n        override\n        returns (address factory)\n    {\n        return _vaultFactorySet.at(index);\n    }\n\n    function isValidVault(address target) public view override returns (bool validity) {\n        // validate target is created from whitelisted vault factory\n        for (uint256 index = 0; index &lt; _vaultFactorySet.length(); index++) {\n            if (IInstanceRegistry(_vaultFactorySet.at(index)).isInstance(target)) {\n                return true;\n            }\n        }\n        // explicit return\n        return false;\n    }\n\n    function isValidAddress(address target) public view override returns (bool validity) {\n        // sanity check target for potential input errors\n        return\n            target != address(this) &amp;&amp;\n            target != address(0) &amp;&amp;\n            target != _hypervisor.stakingToken &amp;&amp;\n            target != _hypervisor.rewardToken &amp;&amp;\n            target != _hypervisor.rewardPool &amp;&amp;\n            !_bonusTokenSet.contains(target);\n    }\n\n    / Hypervisor getters /\n\n    function getHypervisorData() external view override returns (HypervisorData memory hypervisor) {\n        return _hypervisor;\n    }\n\n    function getCurrentUnlockedRewards() public view override returns (uint256 unlockedRewards) {\n        // calculate reward available based on state\n        return getFutureUnlockedRewards(block.timestamp);\n    }\n\n    function getFutureUnlockedRewards(uint256 timestamp)\n        public\n        view\n        override\n        returns (uint256 unlockedRewards)\n    {\n        // get reward amount remaining\n        uint256 remainingRewards = IERC20(_hypervisor.rewardToken).balanceOf(_hypervisor.rewardPool);\n        // calculate reward available based on state\n        unlockedRewards = calculateUnlockedRewards(\n            _hypervisor.rewardSchedules,\n            remainingRewards,\n            _hypervisor.rewardSharesOutstanding,\n            timestamp\n        );\n        // explicit return\n        return unlockedRewards;\n    }\n\n    function getCurrentTotalStakeUnits() public view override returns (uint256 totalStakeUnits) {\n        // calculate new stake units\n        return getFutureTotalStakeUnits(block.timestamp);\n    }\n\n    function getFutureTotalStakeUnits(uint256 timestamp)\n        public\n        view\n        override\n        returns (uint256 totalStakeUnits)\n    {\n        // return early if no change\n        if (timestamp == _hypervisor.lastUpdate) return _hypervisor.totalStakeUnits;\n        // calculate new stake units\n        uint256 newStakeUnits =\n            calculateStakeUnits(_hypervisor.totalStake, _hypervisor.lastUpdate, timestamp);\n        // add to cached total\n        totalStakeUnits = _hypervisor.totalStakeUnits.add(newStakeUnits);\n        // explicit return\n        return totalStakeUnits;\n    }\n\n    / vault getters /\n\n    function getVaultData(address vault)\n        external\n        view\n        override\n        returns (VaultData memory vaultData)\n    {\n        return _vaults[vault];\n    }\n\n    function getCurrentVaultReward(address vault) external view override returns (uint256 reward) {\n        // calculate rewards\n        return\n            calculateRewardFromStakes(\n                _vaults[vault]\n                    .stakes,\n                _vaults[vault]\n                    .totalStake,\n                getCurrentUnlockedRewards(),\n                getCurrentTotalStakeUnits(),\n                block\n                    .timestamp,\n                _hypervisor\n                    .rewardScaling\n            )\n                .reward;\n    }\n\n    function getFutureVaultReward(address vault, uint256 timestamp)\n        external\n        view\n        override\n        returns (uint256 reward)\n    {\n        // calculate rewards\n        return\n            calculateRewardFromStakes(\n                _vaults[vault]\n                    .stakes,\n                _vaults[vault]\n                    .totalStake,\n                getFutureUnlockedRewards(timestamp),\n                getFutureTotalStakeUnits(timestamp),\n                timestamp,\n                _hypervisor\n                    .rewardScaling\n            )\n                .reward;\n    }\n\n    function getCurrentStakeReward(address vault, uint256 stakeAmount)\n        external\n        view\n        override\n        returns (uint256 reward)\n    {\n        // calculate rewards\n        return\n            calculateRewardFromStakes(\n                _vaults[vault]\n                    .stakes,\n                stakeAmount,\n                getCurrentUnlockedRewards(),\n                getCurrentTotalStakeUnits(),\n                block\n                    .timestamp,\n                _hypervisor\n                    .rewardScaling\n            )\n                .reward;\n    }\n\n    function getFutureStakeReward(\n        address vault,\n        uint256 stakeAmount,\n        uint256 timestamp\n    ) external view override returns (uint256 reward) {\n        // calculate rewards\n        return\n            calculateRewardFromStakes(\n                _vaults[vault]\n                    .stakes,\n                stakeAmount,\n                getFutureUnlockedRewards(timestamp),\n                getFutureTotalStakeUnits(timestamp),\n                timestamp,\n                _hypervisor\n                    .rewardScaling\n            )\n                .reward;\n    }\n\n    function getCurrentVaultStakeUnits(address vault)\n        public\n        view\n        override\n        returns (uint256 stakeUnits)\n    {\n        // calculate stake units\n        return getFutureVaultStakeUnits(vault, block.timestamp);\n    }\n\n    function getFutureVaultStakeUnits(address vault, uint256 timestamp)\n        public\n        view\n        override\n        returns (uint256 stakeUnits)\n    {\n        // calculate stake units\n        return calculateTotalStakeUnits(_vaults[vault].stakes, timestamp);\n    }\n\n    / pure functions /\n\n    function calculateTotalStakeUnits(StakeData[] memory stakes, uint256 timestamp)\n        public\n        pure\n        override\n        returns (uint256 totalStakeUnits)\n    {\n        for (uint256 index; index &lt; stakes.length; index++) {\n            // reference stake\n            StakeData memory stakeData = stakes[index];\n            // calculate stake units\n            uint256 stakeUnits =\n                calculateStakeUnits(stakeData.amount, stakeData.timestamp, timestamp);\n            // add to running total\n            totalStakeUnits = totalStakeUnits.add(stakeUnits);\n        }\n    }\n\n    function calculateStakeUnits(\n        uint256 amount,\n        uint256 start,\n        uint256 end\n    ) public pure override returns (uint256 stakeUnits) {\n        // calculate duration\n        uint256 duration = end.sub(start);\n        // calculate stake units\n        stakeUnits = duration.mul(amount);\n        // explicit return\n        return stakeUnits;\n    }\n\n    function calculateUnlockedRewards(\n        RewardSchedule[] memory rewardSchedules,\n        uint256 rewardBalance,\n        uint256 sharesOutstanding,\n        uint256 timestamp\n    ) public pure override returns (uint256 unlockedRewards) {\n        // return 0 if no registered schedules\n        if (rewardSchedules.length == 0) {\n            return 0;\n        }\n\n        // calculate reward shares locked across all reward schedules\n        uint256 sharesLocked;\n        for (uint256 index = 0; index &lt; rewardSchedules.length; index++) {\n            // fetch reward schedule storage reference\n            RewardSchedule memory schedule = rewardSchedules[index];\n\n            // caculate amount of shares available on this schedule\n            // if (now - start) &lt; duration\n            //   sharesLocked = shares - (shares * (now - start) / duration)\n            // else\n            //   sharesLocked = 0\n            uint256 currentSharesLocked = 0;\n            if (timestamp.sub(schedule.start) &lt; schedule.duration) {\n                currentSharesLocked = schedule.shares.sub(\n                    schedule.shares.mul(timestamp.sub(schedule.start)).div(schedule.duration)\n                );\n            }\n\n            // add to running total\n            sharesLocked = sharesLocked.add(currentSharesLocked);\n        }\n\n        // convert shares to reward\n        // rewardLocked = sharesLocked * rewardBalance / sharesOutstanding\n        uint256 rewardLocked = sharesLocked.mul(rewardBalance).div(sharesOutstanding);\n\n        // calculate amount available\n        // unlockedRewards = rewardBalance - rewardLocked\n        unlockedRewards = rewardBalance.sub(rewardLocked);\n\n        // explicit return\n        return unlockedRewards;\n    }\n\n    function calculateRewardFromStakes(\n        StakeData[] memory stakes,\n        uint256 unstakeAmount,\n        uint256 unlockedRewards,\n        uint256 totalStakeUnits,\n        uint256 timestamp,\n        RewardScaling memory rewardScaling\n    ) public pure override returns (RewardOutput memory out) {\n        uint256 stakesToDrop = 0;\n        while (unstakeAmount &gt; 0) {\n            // fetch vault stake storage reference\n            StakeData memory lastStake = stakes[stakes.length.sub(stakesToDrop).sub(1)];\n\n            // calculate stake duration\n            uint256 stakeDuration = timestamp.sub(lastStake.timestamp);\n\n            uint256 currentAmount;\n            if (lastStake.amount &gt; unstakeAmount) {\n                // set current amount to remaining unstake amount\n                currentAmount = unstakeAmount;\n                // amount of last stake is reduced\n                out.lastStakeAmount = lastStake.amount.sub(unstakeAmount);\n            } else {\n                // set current amount to amount of last stake\n                currentAmount = lastStake.amount;\n                // add to stakes to drop\n                stakesToDrop += 1;\n            }\n\n            // update remaining unstakeAmount\n            unstakeAmount = unstakeAmount.sub(currentAmount);\n\n            // calculate reward amount\n            uint256 currentReward =\n                calculateReward(\n                    unlockedRewards,\n                    currentAmount,\n                    stakeDuration,\n                    totalStakeUnits,\n                    rewardScaling\n                );\n\n            // update cumulative reward\n            out.reward = out.reward.add(currentReward);\n\n            // update cached unlockedRewards\n            unlockedRewards = unlockedRewards.sub(currentReward);\n\n            // calculate time weighted stake\n            uint256 stakeUnits = currentAmount.mul(stakeDuration);\n\n            // update cached totalStakeUnits\n            totalStakeUnits = totalStakeUnits.sub(stakeUnits);\n        }\n\n        // explicit return\n        return\n            RewardOutput(\n                out.lastStakeAmount,\n                stakes.length.sub(stakesToDrop),\n                out.reward,\n                totalStakeUnits\n            );\n    }\n\n    function calculateReward(\n        uint256 unlockedRewards,\n        uint256 stakeAmount,\n        uint256 stakeDuration,\n        uint256 totalStakeUnits,\n        RewardScaling memory rewardScaling\n    ) public pure override returns (uint256 reward) {\n        // calculate time weighted stake\n        uint256 stakeUnits = stakeAmount.mul(stakeDuration);\n\n        // calculate base reward\n        // baseReward = unlockedRewards * stakeUnits / totalStakeUnits\n        uint256 baseReward = 0;\n        if (totalStakeUnits != 0) {\n            // scale reward according to proportional weight\n            baseReward = unlockedRewards.mul(stakeUnits).div(totalStakeUnits);\n        }\n\n        // calculate scaled reward\n        // if no scaling or scaling period completed\n        //   reward = baseReward\n        // else\n        //   minReward = baseReward * scalingFloor / scalingCeiling\n        //   bonusReward = baseReward\n        //                 * (scalingCeiling - scalingFloor) / scalingCeiling\n        //                 * duration / scalingTime\n        //   reward = minReward + bonusReward\n        if (stakeDuration &gt;= rewardScaling.time || rewardScaling.floor == rewardScaling.ceiling) {\n            // no reward scaling applied\n            reward = baseReward;\n        } else {\n            // calculate minimum reward using scaling floor\n            uint256 minReward = baseReward.mul(rewardScaling.floor).div(rewardScaling.ceiling);\n\n            // calculate bonus reward with vested portion of scaling factor\n            uint256 bonusReward =\n                baseReward\n                    .mul(stakeDuration)\n                    .mul(rewardScaling.ceiling.sub(rewardScaling.floor))\n                    .div(rewardScaling.ceiling)\n                    .div(rewardScaling.time);\n\n            // add minimum reward and bonus reward\n            reward = minReward.add(bonusReward);\n        }\n\n        // explicit return\n        return reward;\n    }\n\n    / admin functions /\n\n    /// @notice Add funds to the Hypervisor\n    /// access control: only admin\n    /// state machine:\n    ///   - can be called multiple times\n    ///   - only online\n    /// state scope:\n    ///   - increase _hypervisor.rewardSharesOutstanding\n    ///   - append to _hypervisor.rewardSchedules\n    /// token transfer: transfer staking tokens from msg.sender to reward pool\n    /// @param amount uint256 Amount of reward tokens to deposit\n    /// @param duration uint256 Duration over which to linearly unlock rewards\n    function fund(uint256 amount, uint256 duration) external onlyOwner onlyOnline {\n        // validate duration\n        require(duration != 0, ""Hypervisor: invalid duration"");\n\n        // create new reward shares\n        // if existing rewards on this Hypervisor\n        //   mint new shares proportional to % change in rewards remaining\n        //   newShares = remainingShares * newReward / remainingRewards\n        // else\n        //   mint new shares with BASE_SHARES_PER_WEI initial conversion rate\n        //   store as fixed point number with same  of decimals as reward token\n        uint256 newRewardShares;\n        if (_hypervisor.rewardSharesOutstanding &gt; 0) {\n            uint256 remainingRewards = IERC20(_hypervisor.rewardToken).balanceOf(_hypervisor.rewardPool);\n            newRewardShares = _hypervisor.rewardSharesOutstanding.mul(amount).div(remainingRewards);\n        } else {\n            newRewardShares = amount.mul(BASE_SHARES_PER_WEI);\n        }\n\n        // add reward shares to total\n        _hypervisor.rewardSharesOutstanding = _hypervisor.rewardSharesOutstanding.add(newRewardShares);\n\n        // store new reward schedule\n        _hypervisor.rewardSchedules.push(RewardSchedule(duration, block.timestamp, newRewardShares));\n\n        // transfer reward tokens to reward pool\n        TransferHelper.safeTransferFrom(\n            _hypervisor.rewardToken,\n            msg.sender,\n            _hypervisor.rewardPool,\n            amount\n        );\n\n        // emit event\n        emit HypervisorFunded(amount, duration);\n    }\n\n    /// @notice Add vault factory to whitelist\n    /// @dev use this function to enable stakes to vaults coming from the specified\n    ///      factory contract\n    /// access control: only admin\n    /// state machine:\n    ///   - can be called multiple times\n    ///   - not shutdown\n    /// state scope:\n    ///   - append to _vaultFactorySet\n    /// token transfer: none\n    /// @param factory address The address of the vault factory\n    function registerVaultFactory(address factory) external onlyOwner notShutdown {\n        // add factory to set\n        require(_vaultFactorySet.add(factory), ""Hypervisor: vault factory already registered"");\n\n        // emit event\n        emit VaultFactoryRegistered(factory);\n    }\n\n    /// @notice Remove vault factory from whitelist\n    /// @dev use this function to disable new stakes to vaults coming from the specified\n    ///      factory contract.\n    ///      note: vaults with existing stakes from this factory are sill able to unstake\n    /// access control: only admin\n    /// state machine:\n    ///   - can be called multiple times\n    ///   - not shutdown\n    /// state scope:\n    ///   - remove from _vaultFactorySet\n    /// token transfer: none\n    /// @param factory address The address of the vault factory\n    function removeVaultFactory(address factory) external onlyOwner notShutdown {\n        // remove factory from set\n        require(_vaultFactorySet.remove(factory), ""Hypervisor: vault factory not registered"");\n\n        // emit event\n        emit VaultFactoryRemoved(factory);\n    }\n\n    /// @notice Register bonus token for distribution\n    /// @dev use this function to enable distribution of any ERC20 held by the RewardPool contract\n    /// access control: only admin\n    /// state machine:\n    ///   - can be called multiple times\n    ///   - only online\n    /// state scope:\n    ///   - append to _bonusTokenSet\n    /// token transfer: none\n    /// @param bonusToken address The address of the bonus token\n    function registerBonusToken(address bonusToken) external onlyOwner onlyOnline {\n        // verify valid bonus token\n        _validateAddress(bonusToken);\n\n        // verify bonus token count\n        require(_bonusTokenSet.length() &lt; MAX_REWARD_TOKENS, ""Hypervisor: max bonus tokens reached "");\n\n        // add token to set\n        assert(_bonusTokenSet.add(bonusToken));\n\n        // emit event\n        emit BonusTokenRegistered(bonusToken);\n    }\n\n    /// @notice Rescue tokens from RewardPool\n    /// @dev use this function to rescue tokens from RewardPool contract\n    ///      without distributing to stakers or triggering emergency shutdown\n    /// access control: only admin\n    /// state machine:\n    ///   - can be called multiple times\n    ///   - only online\n    /// state scope: none\n    /// token transfer: transfer requested token from RewardPool to recipient\n    /// @param token address The address of the token to rescue\n    /// @param recipient address The address of the recipient\n    /// @param amount uint256 The amount of tokens to rescue\n    function rescueTokensFromRewardPool(\n        address token,\n        address recipient,\n        uint256 amount\n    ) external onlyOwner onlyOnline {\n        // verify recipient\n        _validateAddress(recipient);\n\n        // check not attempting to unstake reward token\n        require(token != _hypervisor.rewardToken, ""Hypervisor: invalid address"");\n\n        // check not attempting to wthdraw bonus token\n        require(!_bonusTokenSet.contains(token), ""Hypervisor: invalid address"");\n\n        // transfer tokens to recipient\n        IRewardPool(_hypervisor.rewardPool).sendERC20(token, recipient, amount);\n    }\n\n    / user functions /\n\n    /// @notice Stake tokens\n    /// @dev anyone can stake to any vault if they have valid permission\n    /// access control: anyone\n    /// state machine:\n    ///   - can be called multiple times\n    ///   - only online\n    ///   - when vault exists on this Hypervisor\n    /// state scope:\n    ///   - append to _vaults[vault].stakes\n    ///   - increase _vaults[vault].totalStake\n    ///   - increase _hypervisor.totalStake\n    ///   - increase _hypervisor.totalStakeUnits\n    ///   - increase _hypervisor.lastUpdate\n    /// token transfer: transfer staking tokens from msg.sender to vault\n    /// @param vault address The address of the vault to stake from\n    /// @param amount uint256 The amount of staking tokens to stake\n    function stake(\n        address vault,\n        uint256 amount,\n        bytes calldata permission\n    ) external override onlyOnline {\n        // verify vault is valid\n        require(isValidVault(vault), ""Hypervisor: vault is not registered"");\n\n        // verify non-zero amount\n        require(amount != 0, ""Hypervisor: no amount staked"");\n\n        // fetch vault storage reference\n        VaultData storage vaultData = _vaults[vault];\n\n        // verify stakes boundary not reached\n        require(\n            vaultData.stakes.length &lt; MAX_STAKES_PER_VAULT,\n            ""Hypervisor: MAX_STAKES_PER_VAULT reached""\n        );\n\n        // update cached sum of stake units across all vaults\n        _updateTotalStakeUnits();\n\n        // store amount and timestamp\n        vaultData.stakes.push(StakeData(amount, block.timestamp));\n\n        // update cached total vault and Hypervisor amounts\n        vaultData.totalStake = vaultData.totalStake.add(amount);\n        // verify stake quantity without bounds\n        require(\n            stakeLimit == 0 || vaultData.totalStake &lt;= stakeLimit,\n            ""Hypervisor: Stake limit exceeded""\n        );\n        _hypervisor.totalStake = _hypervisor.totalStake.add(amount);\n\n        // call lock on vault\n        IUniversalVault(vault).lock(_hypervisor.stakingToken, amount, permission);\n\n        // emit event\n        emit Staked(vault, amount);\n    }\n\n    /// @notice Unstake staking tokens and claim reward\n    /// @dev rewards can only be claimed when unstaking\n    /// access control: only owner of vault\n    /// state machine:\n    ///   - when vault exists on this Hypervisor\n    ///   - after stake from vault\n    ///   - can be called multiple times while sufficient stake remains\n    ///   - only online\n    /// state scope:\n    ///   - decrease _hypervisor.rewardSharesOutstanding\n    ///   - decrease _hypervisor.totalStake\n    ///   - increase _hypervisor.lastUpdate\n    ///   - modify _hypervisor.totalStakeUnits\n    ///   - modify _vaults[vault].stakes\n    ///   - decrease _vaults[vault].totalStake\n    /// token transfer:\n    ///   - transfer reward tokens from reward pool to recipient\n    ///   - transfer bonus tokens from reward pool to recipient\n    /// @param vault address The vault to unstake from\n    /// @param amount uint256 The amount of staking tokens to unstake\n    function unstakeAndClaim(\n        address vault,\n        uint256 amount,\n        bytes calldata permission\n    ) external override onlyOnline {\n        // fetch vault storage reference\n        VaultData storage vaultData = _vaults[vault];\n\n        // verify non-zero amount\n        require(amount != 0, ""Hypervisor: no amount unstaked"");\n\n        address recipient = IUniversalVault(vault).owner();\n\n        // validate recipient\n        _validateAddress(recipient);\n\n        // check for sufficient vault stake amount\n        require(vaultData.totalStake &gt;= amount, ""Hypervisor: insufficient vault stake"");\n\n        // check for sufficient Hypervisor stake amount\n        // if this check fails, there is a bug in stake accounting\n        assert(_hypervisor.totalStake &gt;= amount);\n\n        // update cached sum of stake units across all vaults\n        _updateTotalStakeUnits();\n\n        // get reward amount remaining\n        uint256 remainingRewards = IERC20(_hypervisor.rewardToken).balanceOf(_hypervisor.rewardPool);\n\n        // calculate vested portion of reward pool\n        uint256 unlockedRewards =\n            calculateUnlockedRewards(\n                _hypervisor.rewardSchedules,\n                remainingRewards,\n                _hypervisor.rewardSharesOutstanding,\n                block.timestamp\n            );\n\n        // calculate vault time weighted reward with scaling\n        RewardOutput memory out =\n            calculateRewardFromStakes(\n                vaultData.stakes,\n                amount,\n                unlockedRewards,\n                _hypervisor.totalStakeUnits,\n                block.timestamp,\n                _hypervisor.rewardScaling\n            );\n\n        // update stake data in storage\n        if (out.newStakesCount == 0) {\n            // all stakes have been unstaked\n            delete vaultData.stakes;\n        } else {\n            // some stakes have been completely or partially unstaked\n            // delete fully unstaked stakes\n            while (vaultData.stakes.length &gt; out.newStakesCount) vaultData.stakes.pop();\n            // update partially unstaked stake\n            vaultData.stakes[out.newStakesCount.sub(1)].amount = out.lastStakeAmount;\n        }\n\n        // update cached stake totals\n        vaultData.totalStake = vaultData.totalStake.sub(amount);\n        _hypervisor.totalStake = _hypervisor.totalStake.sub(amount);\n        _hypervisor.totalStakeUnits = out.newTotalStakeUnits;\n\n        // unlock staking tokens from vault\n        IUniversalVault(vault).unlock(_hypervisor.stakingToken, amount, permission);\n\n        // emit event\n        emit Unstaked(vault, amount);\n\n        // only perform on non-zero reward\n        if (out.reward &gt; 0) {\n            // calculate shares to burn\n            // sharesToBurn = sharesOutstanding * reward / remainingRewards\n            uint256 sharesToBurn =\n                _hypervisor.rewardSharesOutstanding.mul(out.reward).div(remainingRewards);\n\n            // burn claimed shares\n            _hypervisor.rewardSharesOutstanding = _hypervisor.rewardSharesOutstanding.sub(sharesToBurn);\n\n            // transfer bonus tokens from reward pool to recipient\n            if (_bonusTokenSet.length() &gt; 0) {\n                for (uint256 index = 0; index &lt; _bonusTokenSet.length(); index++) {\n                    // fetch bonus token address reference\n                    address bonusToken = _bonusTokenSet.at(index);\n\n                    // calculate bonus token amount\n                    // bonusAmount = bonusRemaining * reward / remainingRewards\n                    uint256 bonusAmount =\n                        IERC20(bonusToken).balanceOf(_hypervisor.rewardPool).mul(out.reward).div(\n                            remainingRewards\n                        );\n\n                    // transfer bonus token\n                    IRewardPool(_hypervisor.rewardPool).sendERC20(bonusToken, recipient, bonusAmount);\n\n                    // emit event\n                    emit RewardClaimed(vault, recipient, bonusToken, bonusAmount);\n                }\n            }\n\n            // transfer reward tokens from reward pool to recipient\n            IRewardPool(_hypervisor.rewardPool).sendERC20(_hypervisor.rewardToken, recipient, out.reward);\n\n            // emit event\n            emit RewardClaimed(vault, recipient, _hypervisor.rewardToken, out.reward);\n        }\n    }\n\n    /// @notice Exit Hypervisor without claiming reward\n    /// @dev This function should never revert when correctly called by the vault.\n    ///      A max number of stakes per vault is set with MAX_STAKES_PER_VAULT to\n    ///      place an upper bound on the for loop in calculateTotalStakeUnits().\n    /// access control: only callable by the vault directly\n    /// state machine:\n    ///   - when vault exists on this Hypervisor\n    ///   - when active stake from this vault\n    ///   - any power state\n    /// state scope:\n    ///   - decrease _hypervisor.totalStake\n    ///   - increase _hypervisor.lastUpdate\n    ///   - modify _hypervisor.totalStakeUnits\n    ///   - delete _vaults[vault]\n    /// token transfer: none\n    function rageQuit() external override {\n        // fetch vault storage reference\n        VaultData storage _vaultData = _vaults[msg.sender];\n\n        // revert if no active stakes\n        require(_vaultData.stakes.length != 0, ""Hypervisor: no stake"");\n\n        // update cached sum of stake units across all vaults\n        _updateTotalStakeUnits();\n\n        // emit event\n        emit Unstaked(msg.sender, _vaultData.totalStake);\n\n        // update cached totals\n        _hypervisor.totalStake = _hypervisor.totalStake.sub(_vaultData.totalStake);\n        _hypervisor.totalStakeUnits = _hypervisor.totalStakeUnits.sub(\n            calculateTotalStakeUnits(_vaultData.stakes, block.timestamp)\n        );\n\n        // delete stake data\n        delete _vaults[msg.sender];\n    }\n\n    / convenience functions /\n\n    function _updateTotalStakeUnits() private {\n        // update cached totalStakeUnits\n        _hypervisor.totalStakeUnits = getCurrentTotalStakeUnits();\n        // update cached lastUpdate\n        _hypervisor.lastUpdate = block.timestamp;\n    }\n\n    function _validateAddress(address target) private view {\n        // sanity check target for potential input errors\n        require(isValidAddress(target), ""Hypervisor: invalid address"");\n    }\n\n    function _truncateStakesArray(StakeData[] memory array, uint256 newLength)\n        private\n        pure\n        returns (StakeData[] memory newArray)\n    {\n        newArray = new StakeData;\n        for (uint256 index = 0; index &lt; newLength; index++) {\n            newArray[index] = array[index];\n        }\n        return newArray;\n    }\n}\n', 'ideas': "" Order of Inheritance Initialization Identified.\n``\nORDER OF INHERITANCE INITIALIZATION\n'''\nThe contractHypervisorinherits from two contracts:PoweredandOwnable. In Solidity, the order of constructor execution is determined by the linearized order of inheritance, which may not match the order specified in the derived contract's constructor. This can lead to unexpected behavior if the constructors of the inherited contracts rely on state variables that are initialized in the derived contract's constructor.\n\nIn this case, ifPoweredandOwnable` have their own state variables that are expected to be initialized before the derived contract's constructor logic executes, it could lead to incorrect initialization of those variables. \n\nTo mitigate this issue, ensure that any state variables in the base contracts are initialized properly before they are used in the derived contract. This can be achieved by explicitly calling the constructors of the base contracts in the derived contract's constructor in the""} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-02-08 00:46:08 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **task_prompt** | // SPDX-License-Identifier: GPL-3.0-only pragma solidity 0.7.6; pragma abicoder v2; import {SafeMath} from ""@openzeppelin/contracts/math/SafeMath.sol""; import {EnumerableSet} from ""@openzeppelin/contracts/utils/EnumerableSet.sol""; import {IERC20} from ""@openzeppelin/contracts/token/ERC20/IERC20.sol""; import {Ownable} from ""@openzeppelin/contracts/access/Ownable.sol""; import {TransferHelper} from ""@uniswap/lib/contracts/libraries/TransferHelper.sol""; import {IFactory} from ""../factory/IFactory.sol""; import {IInstanceRegistry} from ""../factory/InstanceRegistry.sol""; import {IUniversalVault} from ""../visor/Visor.sol""; import {IRewardPool} from ""./RewardPool.sol""; import {Powered} from ""./Powered.sol""; interface IRageQuit {     function rageQuit() external; } interface IHypervisor is IRageQuit {     / admin events / event HypervisorCreated(address rewardPool, address powerSwitch); event HypervisorFunded(uint256 amount, uint256 duration); event BonusTokenRegistered(address token); event VaultFactoryRegistered(address factory); event VaultFactoryRemoved(address factory);  /* user events */  event Staked(address vault, uint256 amount); event Unstaked(address vault, uint256 amount); event RewardClaimed(address vault, address recipient, address token, uint256 amount);  /* data types */  struct HypervisorData {     address stakingToken;     address rewardToken;     address rewardPool;     RewardScaling rewardScaling;     uint256 rewardSharesOutstanding;     uint256 totalStake;     uint256 totalStakeUnits;     uint256 lastUpdate;     RewardSchedule[] rewardSchedules; }  struct RewardSchedule {     uint256 duration;     uint256 start;     uint256 shares; }  struct VaultData {     uint256 totalStake;     StakeData[] stakes; }  struct StakeData {     uint256 amount;     uint256 timestamp; }  struct RewardScaling {     uint256 floor;     uint256 ceiling;     uint256 time; }  struct RewardOutput {     uint256 lastStakeAmount;     uint256 newStakesCount;     uint256 reward;     uint256 newTotalStakeUnits; }  /* user functions */  function stake(     address vault,     uint256 amount,     bytes calldata permission ) external;  function unstakeAndClaim(     address vault,     uint256 amount,     bytes calldata permission ) external;  /* getter functions */  function getHypervisorData() external view returns (HypervisorData memory hypervisor);  function getBonusTokenSetLength() external view returns (uint256 length);  function getBonusTokenAtIndex(uint256 index) external view returns (address bonusToken);  function getVaultFactorySetLength() external view returns (uint256 length);  function getVaultFactoryAtIndex(uint256 index) external view returns (address factory);  function getVaultData(address vault) external view returns (VaultData memory vaultData);  function isValidAddress(address target) external view returns (bool validity);  function isValidVault(address target) external view returns (bool validity);  function getCurrentUnlockedRewards() external view returns (uint256 unlockedRewards);  function getFutureUnlockedRewards(uint256 timestamp)     external     view     returns (uint256 unlockedRewards);  function getCurrentVaultReward(address vault) external view returns (uint256 reward);  function getCurrentStakeReward(address vault, uint256 stakeAmount)     external     view     returns (uint256 reward);  function getFutureVaultReward(address vault, uint256 timestamp)     external     view     returns (uint256 reward);  function getFutureStakeReward(     address vault,     uint256 stakeAmount,     uint256 timestamp ) external view returns (uint256 reward);  function getCurrentVaultStakeUnits(address vault) external view returns (uint256 stakeUnits);  function getFutureVaultStakeUnits(address vault, uint256 timestamp)     external     view     returns (uint256 stakeUnits);  function getCurrentTotalStakeUnits() external view returns (uint256 totalStakeUnits);  function getFutureTotalStakeUnits(uint256 timestamp)     external     view     returns (uint256 totalStakeUnits);  /* pure functions */  function calculateTotalStakeUnits(StakeData[] memory stakes, uint256 timestamp)     external     pure     returns (uint256 totalStakeUnits);  function calculateStakeUnits(     uint256 amount,     uint256 start,     uint256 end ) external pure returns (uint256 stakeUnits);  function calculateUnlockedRewards(     RewardSchedule[] memory rewardSchedules,     uint256 rewardBalance,     uint256 sharesOutstanding,     uint256 timestamp ) external pure returns (uint256 unlockedRewards);  function calculateRewardFromStakes(     StakeData[] memory stakes,     uint256 unstakeAmount,     uint256 unlockedRewards,     uint256 totalStakeUnits,     uint256 timestamp,     RewardScaling memory rewardScaling ) external pure returns (RewardOutput memory out);  function calculateReward(     uint256 unlockedRewards,     uint256 stakeAmount,     uint256 stakeDuration,     uint256 totalStakeUnits,     RewardScaling memory rewardScaling ) external pure returns (uint256 reward);  } /// @title Hypervisor /// @notice Reward distribution contract with time multiplier /// Access Control /// - Power controller: ///     Can power off / shutdown the Hypervisor ///     Can withdraw rewards from reward pool once shutdown /// - Proxy owner: ///     Can change arbitrary logic / state by upgrading the Hypervisor ///     Is unable to operate on user funds due to UniversalVault ///     Is unable to operate on reward pool funds when reward pool is offline / shutdown /// - Hypervisor admin: ///     Can add funds to the Hypervisor, register bonus tokens, and whitelist new vault factories ///     Is a subset of proxy owner permissions /// - User: ///     Can deposit / withdraw / ragequit /// Hypervisor State Machine /// - Online: ///     Hypervisor is operating normally, all functions are enabled /// - Offline: ///     Hypervisor is temporarely disabled for maintenance ///     User deposits and withdrawls are disabled, ragequit remains enabled ///     Users can withdraw their stake through rageQuit() but forego their pending reward ///     Should only be used when downtime required for an upgrade /// - Shutdown: ///     Hypervisor is permanently disabled ///     All functions are disabled with the exception of ragequit ///     Users can withdraw their stake through rageQuit() ///     Power controller can withdraw from the reward pool ///     Should only be used if Proxy Owner role is compromized contract Hypervisor is IHypervisor, Powered, Ownable {     using SafeMath for uint256;     using EnumerableSet for EnumerableSet.AddressSet; /* constants */  // An upper bound on the number of active stakes per vault is required to prevent // calls to rageQuit() from reverting. // With 30 stakes in a vault, ragequit costs 432811 gas which is conservatively lower // than the hardcoded limit of 500k gas on the vault. // This limit is configurable and could be increased in a future deployment. // Ultimately, to avoid a need for fixed upper bounds, the EVM would need to provide // an error code that allows for reliably catching out-of-gas errors on remote calls. uint256 public constant MAX_STAKES_PER_VAULT = 30; uint256 public constant MAX_REWARD_TOKENS = 50; uint256 public constant BASE_SHARES_PER_WEI = 1000000; uint256 public stakeLimit = 2500 ether;  /* storage */  HypervisorData private _hypervisor; mapping(address =&gt; VaultData) private _vaults; EnumerableSet.AddressSet private _bonusTokenSet; EnumerableSet.AddressSet private _vaultFactorySet;  /* initializer */  /// @notice Initizalize Hypervisor /// access control: only proxy constructor /// state machine: can only be called once /// state scope: set initialization variables /// token transfer: none /// @param ownerAddress address The admin address /// @param rewardPoolFactory address The factory to use for deploying the RewardPool /// @param powerSwitchFactory address The factory to use for deploying the PowerSwitch /// @param stakingToken address The address of the staking token for this Hypervisor /// @param rewardToken address The address of the reward token for this Hypervisor /// @param rewardScaling RewardScaling The config for reward scaling floor, ceiling, and time constructor(     address ownerAddress,     address rewardPoolFactory,     address powerSwitchFactory,     address stakingToken,     address rewardToken,     RewardScaling memory rewardScaling,     uint256 _stakeLimit ) {     // the scaling floor must be smaller than ceiling     require(rewardScaling.floor &lt;= rewardScaling.ceiling, ""Hypervisor: floor above ceiling"");      // setting rewardScalingTime to 0 would cause divide by zero error     // to disable reward scaling, use rewardScalingFloor == rewardScalingCeiling     require(rewardScaling.time != 0, ""Hypervisor: scaling time cannot be zero"");      // deploy power switch     address powerSwitch = IFactory(powerSwitchFactory).create(abi.encode(ownerAddress));      // deploy reward pool     address rewardPool = IFactory(rewardPoolFactory).create(abi.encode(powerSwitch));      // set internal configs     Ownable.transferOwnership(ownerAddress);     Powered._setPowerSwitch(powerSwitch);      // commit to storage     _hypervisor.stakingToken = stakingToken;     _hypervisor.rewardToken = rewardToken;     _hypervisor.rewardPool = rewardPool;     _hypervisor.rewardScaling = rewardScaling;      stakeLimit = _stakeLimit;      // emit event     emit HypervisorCreated(rewardPool, powerSwitch); }  /* getter functions */  function getBonusTokenSetLength() external view override returns (uint256 length) {     return _bonusTokenSet.length(); }  function getBonusTokenAtIndex(uint256 index)     external     view     override     returns (address bonusToken) {     return _bonusTokenSet.at(index); }  function getVaultFactorySetLength() external view override returns (uint256 length) {     return _vaultFactorySet.length(); }  function getVaultFactoryAtIndex(uint256 index)     external     view     override     returns (address factory) {     return _vaultFactorySet.at(index); }  function isValidVault(address target) public view override returns (bool validity) {     // validate target is created from whitelisted vault factory     for (uint256 index = 0; index &lt; _vaultFactorySet.length(); index++) {         if (IInstanceRegistry(_vaultFactorySet.at(index)).isInstance(target)) {             return true;         }     }     // explicit return     return false; }  function isValidAddress(address target) public view override returns (bool validity) {     // sanity check target for potential input errors     return         target != address(this) &amp;&amp;         target != address(0) &amp;&amp;         target != _hypervisor.stakingToken &amp;&amp;         target != _hypervisor.rewardToken &amp;&amp;         target != _hypervisor.rewardPool &amp;&amp;         !_bonusTokenSet.contains(target); }  /* Hypervisor getters */  function getHypervisorData() external view override returns (HypervisorData memory hypervisor) {     return _hypervisor; }  function getCurrentUnlockedRewards() public view override returns (uint256 unlockedRewards) {     // calculate reward available based on state     return getFutureUnlockedRewards(block.timestamp); }  function getFutureUnlockedRewards(uint256 timestamp)     public     view     override     returns (uint256 unlockedRewards) {     // get reward amount remaining     uint256 remainingRewards = IERC20(_hypervisor.rewardToken).balanceOf(_hypervisor.rewardPool);     // calculate reward available based on state     unlockedRewards = calculateUnlockedRewards(         _hypervisor.rewardSchedules,         remainingRewards,         _hypervisor.rewardSharesOutstanding,         timestamp     );     // explicit return     return unlockedRewards; }  function getCurrentTotalStakeUnits() public view override returns (uint256 totalStakeUnits) {     // calculate new stake units     return getFutureTotalStakeUnits(block.timestamp); }  function getFutureTotalStakeUnits(uint256 timestamp)     public     view     override     returns (uint256 totalStakeUnits) {     // return early if no change     if (timestamp == _hypervisor.lastUpdate) return _hypervisor.totalStakeUnits;     // calculate new stake units     uint256 newStakeUnits =         calculateStakeUnits(_hypervisor.totalStake, _hypervisor.lastUpdate, timestamp);     // add to cached total     totalStakeUnits = _hypervisor.totalStakeUnits.add(newStakeUnits);     // explicit return     return totalStakeUnits; }  /* vault getters */  function getVaultData(address vault)     external     view     override     returns (VaultData memory vaultData) {     return _vaults[vault]; }  function getCurrentVaultReward(address vault) external view override returns (uint256 reward) {     // calculate rewards     return         calculateRewardFromStakes(             _vaults[vault]                 .stakes,             _vaults[vault]                 .totalStake,             getCurrentUnlockedRewards(),             getCurrentTotalStakeUnits(),             block                 .timestamp,             _hypervisor                 .rewardScaling         )             .reward; }  function getFutureVaultReward(address vault, uint256 timestamp)     external     view     override     returns (uint256 reward) {     // calculate rewards     return         calculateRewardFromStakes(             _vaults[vault]                 .stakes,             _vaults[vault]                 .totalStake,             getFutureUnlockedRewards(timestamp),             getFutureTotalStakeUnits(timestamp),             timestamp,             _hypervisor                 .rewardScaling         )             .reward; }  function getCurrentStakeReward(address vault, uint256 stakeAmount)     external     view     override     returns (uint256 reward) {     // calculate rewards     return         calculateRewardFromStakes(             _vaults[vault]                 .stakes,             stakeAmount,             getCurrentUnlockedRewards(),             getCurrentTotalStakeUnits(),             block                 .timestamp,             _hypervisor                 .rewardScaling         )             .reward; }  function getFutureStakeReward(     address vault,     uint256 stakeAmount,     uint256 timestamp ) external view override returns (uint256 reward) {     // calculate rewards     return         calculateRewardFromStakes(             _vaults[vault]                 .stakes,             stakeAmount,             getFutureUnlockedRewards(timestamp),             getFutureTotalStakeUnits(timestamp),             timestamp,             _hypervisor                 .rewardScaling         )             .reward; }  function getCurrentVaultStakeUnits(address vault)     public     view     override     returns (uint256 stakeUnits) {     // calculate stake units     return getFutureVaultStakeUnits(vault, block.timestamp); }  function getFutureVaultStakeUnits(address vault, uint256 timestamp)     public     view     override     returns (uint256 stakeUnits) {     // calculate stake units     return calculateTotalStakeUnits(_vaults[vault].stakes, timestamp); }  /* pure functions */  function calculateTotalStakeUnits(StakeData[] memory stakes, uint256 timestamp)     public     pure     override     returns (uint256 totalStakeUnits) {     for (uint256 index; index &lt; stakes.length; index++) {         // reference stake         StakeData memory stakeData = stakes[index];         // calculate stake units         uint256 stakeUnits =             calculateStakeUnits(stakeData.amount, stakeData.timestamp, timestamp);         // add to running total         totalStakeUnits = totalStakeUnits.add(stakeUnits);     } }  function calculateStakeUnits(     uint256 amount,     uint256 start,     uint256 end ) public pure override returns (uint256 stakeUnits) {     // calculate duration     uint256 duration = end.sub(start);     // calculate stake units     stakeUnits = duration.mul(amount);     // explicit return     return stakeUnits; }  function calculateUnlockedRewards(     RewardSchedule[] memory rewardSchedules,     uint256 rewardBalance,     uint256 sharesOutstanding,     uint256 timestamp ) public pure override returns (uint256 unlockedRewards) {     // return 0 if no registered schedules     if (rewardSchedules.length == 0) {         return 0;     }      // calculate reward shares locked across all reward schedules     uint256 sharesLocked;     for (uint256 index = 0; index &lt; rewardSchedules.length; index++) {         // fetch reward schedule storage reference         RewardSchedule memory schedule = rewardSchedules[index];          // caculate amount of shares available on this schedule         // if (now - start) &lt; duration         //   sharesLocked = shares - (shares * (now - start) / duration)         // else         //   sharesLocked = 0         uint256 currentSharesLocked = 0;         if (timestamp.sub(schedule.start) &lt; schedule.duration) {             currentSharesLocked = schedule.shares.sub(                 schedule.shares.mul(timestamp.sub(schedule.start)).div(schedule.duration)             );         }          // add to running total         sharesLocked = sharesLocked.add(currentSharesLocked);     }      // convert shares to reward     // rewardLocked = sharesLocked * rewardBalance / sharesOutstanding     uint256 rewardLocked = sharesLocked.mul(rewardBalance).div(sharesOutstanding);      // calculate amount available     // unlockedRewards = rewardBalance - rewardLocked     unlockedRewards = rewardBalance.sub(rewardLocked);      // explicit return     return unlockedRewards; }  function calculateRewardFromStakes(     StakeData[] memory stakes,     uint256 unstakeAmount,     uint256 unlockedRewards,     uint256 totalStakeUnits,     uint256 timestamp,     RewardScaling memory rewardScaling ) public pure override returns (RewardOutput memory out) {     uint256 stakesToDrop = 0;     while (unstakeAmount &gt; 0) {         // fetch vault stake storage reference         StakeData memory lastStake = stakes[stakes.length.sub(stakesToDrop).sub(1)];          // calculate stake duration         uint256 stakeDuration = timestamp.sub(lastStake.timestamp);          uint256 currentAmount;         if (lastStake.amount &gt; unstakeAmount) {             // set current amount to remaining unstake amount             currentAmount = unstakeAmount;             // amount of last stake is reduced             out.lastStakeAmount = lastStake.amount.sub(unstakeAmount);         } else {             // set current amount to amount of last stake             currentAmount = lastStake.amount;             // add to stakes to drop             stakesToDrop += 1;         }          // update remaining unstakeAmount         unstakeAmount = unstakeAmount.sub(currentAmount);          // calculate reward amount         uint256 currentReward =             calculateReward(                 unlockedRewards,                 currentAmount,                 stakeDuration,                 totalStakeUnits,                 rewardScaling             );          // update cumulative reward         out.reward = out.reward.add(currentReward);          // update cached unlockedRewards         unlockedRewards = unlockedRewards.sub(currentReward);          // calculate time weighted stake         uint256 stakeUnits = currentAmount.mul(stakeDuration);          // update cached totalStakeUnits         totalStakeUnits = totalStakeUnits.sub(stakeUnits);     }      // explicit return     return         RewardOutput(             out.lastStakeAmount,             stakes.length.sub(stakesToDrop),             out.reward,             totalStakeUnits         ); }  function calculateReward(     uint256 unlockedRewards,     uint256 stakeAmount,     uint256 stakeDuration,     uint256 totalStakeUnits,     RewardScaling memory rewardScaling ) public pure override returns (uint256 reward) {     // calculate time weighted stake     uint256 stakeUnits = stakeAmount.mul(stakeDuration);      // calculate base reward     // baseReward = unlockedRewards * stakeUnits / totalStakeUnits     uint256 baseReward = 0;     if (totalStakeUnits != 0) {         // scale reward according to proportional weight         baseReward = unlockedRewards.mul(stakeUnits).div(totalStakeUnits);     }      // calculate scaled reward     // if no scaling or scaling period completed     //   reward = baseReward     // else     //   minReward = baseReward * scalingFloor / scalingCeiling     //   bonusReward = baseReward     //                 * (scalingCeiling - scalingFloor) / scalingCeiling     //                 * duration / scalingTime     //   reward = minReward + bonusReward     if (stakeDuration &gt;= rewardScaling.time || rewardScaling.floor == rewardScaling.ceiling) {         // no reward scaling applied         reward = baseReward;     } else {         // calculate minimum reward using scaling floor         uint256 minReward = baseReward.mul(rewardScaling.floor).div(rewardScaling.ceiling);          // calculate bonus reward with vested portion of scaling factor         uint256 bonusReward =             baseReward                 .mul(stakeDuration)                 .mul(rewardScaling.ceiling.sub(rewardScaling.floor))                 .div(rewardScaling.ceiling)                 .div(rewardScaling.time);          // add minimum reward and bonus reward         reward = minReward.add(bonusReward);     }      // explicit return     return reward; }  /* admin functions */  /// @notice Add funds to the Hypervisor /// access control: only admin /// state machine: ///   - can be called multiple times ///   - only online /// state scope: ///   - increase _hypervisor.rewardSharesOutstanding ///   - append to _hypervisor.rewardSchedules /// token transfer: transfer staking tokens from msg.sender to reward pool /// @param amount uint256 Amount of reward tokens to deposit /// @param duration uint256 Duration over which to linearly unlock rewards function fund(uint256 amount, uint256 duration) external onlyOwner onlyOnline {     // validate duration     require(duration != 0, ""Hypervisor: invalid duration"");      // create new reward shares     // if existing rewards on this Hypervisor     //   mint new shares proportional to % change in rewards remaining     //   newShares = remainingShares * newReward / remainingRewards     // else     //   mint new shares with BASE_SHARES_PER_WEI initial conversion rate     //   store as fixed point number with same  of decimals as reward token     uint256 newRewardShares;     if (_hypervisor.rewardSharesOutstanding &gt; 0) {         uint256 remainingRewards = IERC20(_hypervisor.rewardToken).balanceOf(_hypervisor.rewardPool);         newRewardShares = _hypervisor.rewardSharesOutstanding.mul(amount).div(remainingRewards);     } else {         newRewardShares = amount.mul(BASE_SHARES_PER_WEI);     }      // add reward shares to total     _hypervisor.rewardSharesOutstanding = _hypervisor.rewardSharesOutstanding.add(newRewardShares);      // store new reward schedule     _hypervisor.rewardSchedules.push(RewardSchedule(duration, block.timestamp, newRewardShares));      // transfer reward tokens to reward pool     TransferHelper.safeTransferFrom(         _hypervisor.rewardToken,         msg.sender,         _hypervisor.rewardPool,         amount     );      // emit event     emit HypervisorFunded(amount, duration); }  /// @notice Add vault factory to whitelist /// @dev use this function to enable stakes to vaults coming from the specified ///      factory contract /// access control: only admin /// state machine: ///   - can be called multiple times ///   - not shutdown /// state scope: ///   - append to _vaultFactorySet /// token transfer: none /// @param factory address The address of the vault factory function registerVaultFactory(address factory) external onlyOwner notShutdown {     // add factory to set     require(_vaultFactorySet.add(factory), ""Hypervisor: vault factory already registered"");      // emit event     emit VaultFactoryRegistered(factory); }  /// @notice Remove vault factory from whitelist /// @dev use this function to disable new stakes to vaults coming from the specified ///      factory contract. ///      note: vaults with existing stakes from this factory are sill able to unstake /// access control: only admin /// state machine: ///   - can be called multiple times ///   - not shutdown /// state scope: ///   - remove from _vaultFactorySet /// token transfer: none /// @param factory address The address of the vault factory function removeVaultFactory(address factory) external onlyOwner notShutdown {     // remove factory from set     require(_vaultFactorySet.remove(factory), ""Hypervisor: vault factory not registered"");      // emit event     emit VaultFactoryRemoved(factory); }  /// @notice Register bonus token for distribution /// @dev use this function to enable distribution of any ERC20 held by the RewardPool contract /// access control: only admin /// state machine: ///   - can be called multiple times ///   - only online /// state scope: ///   - append to _bonusTokenSet /// token transfer: none /// @param bonusToken address The address of the bonus token function registerBonusToken(address bonusToken) external onlyOwner onlyOnline {     // verify valid bonus token     _validateAddress(bonusToken);      // verify bonus token count     require(_bonusTokenSet.length() &lt; MAX_REWARD_TOKENS, ""Hypervisor: max bonus tokens reached "");      // add token to set     assert(_bonusTokenSet.add(bonusToken));      // emit event     emit BonusTokenRegistered(bonusToken); }  /// @notice Rescue tokens from RewardPool /// @dev use this function to rescue tokens from RewardPool contract ///      without distributing to stakers or triggering emergency shutdown /// access control: only admin /// state machine: ///   - can be called multiple times ///   - only online /// state scope: none /// token transfer: transfer requested token from RewardPool to recipient /// @param token address The address of the token to rescue /// @param recipient address The address of the recipient /// @param amount uint256 The amount of tokens to rescue function rescueTokensFromRewardPool(     address token,     address recipient,     uint256 amount ) external onlyOwner onlyOnline {     // verify recipient     _validateAddress(recipient);      // check not attempting to unstake reward token     require(token != _hypervisor.rewardToken, ""Hypervisor: invalid address"");      // check not attempting to wthdraw bonus token     require(!_bonusTokenSet.contains(token), ""Hypervisor: invalid address"");      // transfer tokens to recipient     IRewardPool(_hypervisor.rewardPool).sendERC20(token, recipient, amount); }  /* user functions */  /// @notice Stake tokens /// @dev anyone can stake to any vault if they have valid permission /// access control: anyone /// state machine: ///   - can be called multiple times ///   - only online ///   - when vault exists on this Hypervisor /// state scope: ///   - append to _vaults[vault].stakes ///   - increase _vaults[vault].totalStake ///   - increase _hypervisor.totalStake ///   - increase _hypervisor.totalStakeUnits ///   - increase _hypervisor.lastUpdate /// token transfer: transfer staking tokens from msg.sender to vault /// @param vault address The address of the vault to stake from /// @param amount uint256 The amount of staking tokens to stake function stake(     address vault,     uint256 amount,     bytes calldata permission ) external override onlyOnline {     // verify vault is valid     require(isValidVault(vault), ""Hypervisor: vault is not registered"");      // verify non-zero amount     require(amount != 0, ""Hypervisor: no amount staked"");      // fetch vault storage reference     VaultData storage vaultData = _vaults[vault];      // verify stakes boundary not reached     require(         vaultData.stakes.length &lt; MAX_STAKES_PER_VAULT,         ""Hypervisor: MAX_STAKES_PER_VAULT reached""     );      // update cached sum of stake units across all vaults     _updateTotalStakeUnits();      // store amount and timestamp     vaultData.stakes.push(StakeData(amount, block.timestamp));      // update cached total vault and Hypervisor amounts     vaultData.totalStake = vaultData.totalStake.add(amount);     // verify stake quantity without bounds     require(         stakeLimit == 0 || vaultData.totalStake &lt;= stakeLimit,         ""Hypervisor: Stake limit exceeded""     );     _hypervisor.totalStake = _hypervisor.totalStake.add(amount);      // call lock on vault     IUniversalVault(vault).lock(_hypervisor.stakingToken, amount, permission);      // emit event     emit Staked(vault, amount); }  /// @notice Unstake staking tokens and claim reward /// @dev rewards can only be claimed when unstaking /// access control: only owner of vault /// state machine: ///   - when vault exists on this Hypervisor ///   - after stake from vault ///   - can be called multiple times while sufficient stake remains ///   - only online /// state scope: ///   - decrease _hypervisor.rewardSharesOutstanding ///   - decrease _hypervisor.totalStake ///   - increase _hypervisor.lastUpdate ///   - modify _hypervisor.totalStakeUnits ///   - modify _vaults[vault].stakes ///   - decrease _vaults[vault].totalStake /// token transfer: ///   - transfer reward tokens from reward pool to recipient ///   - transfer bonus tokens from reward pool to recipient /// @param vault address The vault to unstake from /// @param amount uint256 The amount of staking tokens to unstake function unstakeAndClaim(     address vault,     uint256 amount,     bytes calldata permission ) external override onlyOnline {     // fetch vault storage reference     VaultData storage vaultData = _vaults[vault];      // verify non-zero amount     require(amount != 0, ""Hypervisor: no amount unstaked"");      address recipient = IUniversalVault(vault).owner();      // validate recipient     _validateAddress(recipient);      // check for sufficient vault stake amount     require(vaultData.totalStake &gt;= amount, ""Hypervisor: insufficient vault stake"");      // check for sufficient Hypervisor stake amount     // if this check fails, there is a bug in stake accounting     assert(_hypervisor.totalStake &gt;= amount);      // update cached sum of stake units across all vaults     _updateTotalStakeUnits();      // get reward amount remaining     uint256 remainingRewards = IERC20(_hypervisor.rewardToken).balanceOf(_hypervisor.rewardPool);      // calculate vested portion of reward pool     uint256 unlockedRewards =         calculateUnlockedRewards(             _hypervisor.rewardSchedules,             remainingRewards,             _hypervisor.rewardSharesOutstanding,             block.timestamp         );      // calculate vault time weighted reward with scaling     RewardOutput memory out =         calculateRewardFromStakes(             vaultData.stakes,             amount,             unlockedRewards,             _hypervisor.totalStakeUnits,             block.timestamp,             _hypervisor.rewardScaling         );      // update stake data in storage     if (out.newStakesCount == 0) {         // all stakes have been unstaked         delete vaultData.stakes;     } else {         // some stakes have been completely or partially unstaked         // delete fully unstaked stakes         while (vaultData.stakes.length &gt; out.newStakesCount) vaultData.stakes.pop();         // update partially unstaked stake         vaultData.stakes[out.newStakesCount.sub(1)].amount = out.lastStakeAmount;     }      // update cached stake totals     vaultData.totalStake = vaultData.totalStake.sub(amount);     _hypervisor.totalStake = _hypervisor.totalStake.sub(amount);     _hypervisor.totalStakeUnits = out.newTotalStakeUnits;      // unlock staking tokens from vault     IUniversalVault(vault).unlock(_hypervisor.stakingToken, amount, permission);      // emit event     emit Unstaked(vault, amount);      // only perform on non-zero reward     if (out.reward &gt; 0) {         // calculate shares to burn         // sharesToBurn = sharesOutstanding * reward / remainingRewards         uint256 sharesToBurn =             _hypervisor.rewardSharesOutstanding.mul(out.reward).div(remainingRewards);          // burn claimed shares         _hypervisor.rewardSharesOutstanding = _hypervisor.rewardSharesOutstanding.sub(sharesToBurn);          // transfer bonus tokens from reward pool to recipient         if (_bonusTokenSet.length() &gt; 0) {             for (uint256 index = 0; index &lt; _bonusTokenSet.length(); index++) {                 // fetch bonus token address reference                 address bonusToken = _bonusTokenSet.at(index);                  // calculate bonus token amount                 // bonusAmount = bonusRemaining * reward / remainingRewards                 uint256 bonusAmount =                     IERC20(bonusToken).balanceOf(_hypervisor.rewardPool).mul(out.reward).div(                         remainingRewards                     );                  // transfer bonus token                 IRewardPool(_hypervisor.rewardPool).sendERC20(bonusToken, recipient, bonusAmount);                  // emit event                 emit RewardClaimed(vault, recipient, bonusToken, bonusAmount);             }         }          // transfer reward tokens from reward pool to recipient         IRewardPool(_hypervisor.rewardPool).sendERC20(_hypervisor.rewardToken, recipient, out.reward);          // emit event         emit RewardClaimed(vault, recipient, _hypervisor.rewardToken, out.reward);     } }  /// @notice Exit Hypervisor without claiming reward /// @dev This function should never revert when correctly called by the vault. ///      A max number of stakes per vault is set with MAX_STAKES_PER_VAULT to ///      place an upper bound on the for loop in calculateTotalStakeUnits(). /// access control: only callable by the vault directly /// state machine: ///   - when vault exists on this Hypervisor ///   - when active stake from this vault ///   - any power state /// state scope: ///   - decrease _hypervisor.totalStake ///   - increase _hypervisor.lastUpdate ///   - modify _hypervisor.totalStakeUnits ///   - delete _vaults[vault] /// token transfer: none function rageQuit() external override {     // fetch vault storage reference     VaultData storage _vaultData = _vaults[msg.sender];      // revert if no active stakes     require(_vaultData.stakes.length != 0, ""Hypervisor: no stake"");      // update cached sum of stake units across all vaults     _updateTotalStakeUnits();      // emit event     emit Unstaked(msg.sender, _vaultData.totalStake);      // update cached totals     _hypervisor.totalStake = _hypervisor.totalStake.sub(_vaultData.totalStake);     _hypervisor.totalStakeUnits = _hypervisor.totalStakeUnits.sub(         calculateTotalStakeUnits(_vaultData.stakes, block.timestamp)     );      // delete stake data     delete _vaults[msg.sender]; }  /* convenience functions */  function _updateTotalStakeUnits() private {     // update cached totalStakeUnits     _hypervisor.totalStakeUnits = getCurrentTotalStakeUnits();     // update cached lastUpdate     _hypervisor.lastUpdate = block.timestamp; }  function _validateAddress(address target) private view {     // sanity check target for potential input errors     require(isValidAddress(target), ""Hypervisor: invalid address""); }  function _truncateStakesArray(StakeData[] memory array, uint256 newLength)     private     pure     returns (StakeData[] memory newArray) {     newArray = new StakeData[](newLength);     for (uint256 index = 0; index &lt; newLength; index++) {         newArray[index] = array[index];     }     return newArray; }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-02-08 00:46:08 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: GPL-3.0-only
pragma solidity 0.7.6;
pragma abicoder v2;

import {SafeMath} from ""@openzeppelin/contracts/math/SafeMath.sol"";
import {EnumerableSet} from ""@openzeppelin/contracts/utils/EnumerableSet.sol"";
import {IERC20} from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import {Ownable} from ""@openzeppelin/contracts/access/Ownable.sol"";
import {TransferHelper} from ""@uniswap/lib/contracts/libraries/TransferHelper.sol"";

import {IFactory} from ""../factory/IFactory.sol"";
import {IInstanceRegistry} from ""../factory/InstanceRegistry.sol"";
import {IUniversalVault} from ""../visor/Visor.sol"";
import {IRewardPool} from ""./RewardPool.sol"";
import {Powered} from ""./Powered.sol"";

interface IRageQuit {
    function rageQuit() external;
}

interface IHypervisor is IRageQuit {
    /* admin events */

    event HypervisorCreated(address rewardPool, address powerSwitch);
    event HypervisorFunded(uint256 amount, uint256 duration);
    event BonusTokenRegistered(address token);
    event VaultFactoryRegistered(address factory);
    event VaultFactoryRemoved(address factory);

    /* user events */

    event Staked(address vault, uint256 amount);
    event Unstaked(address vault, uint256 amount);
    event RewardClaimed(address vault, address recipient, address token, uint256 amount);

    /* data types */

    struct HypervisorData {
        address stakingToken;
        address rewardToken;
        address rewardPool;
        RewardScaling rewardScaling;
        uint256 rewardSharesOutstanding;
        uint256 totalStake;
        uint256 totalStakeUnits;
        uint256 lastUpdate;
        RewardSchedule[] rewardSchedules;
    }

    struct RewardSchedule {
        uint256 duration;
        uint256 start;
        uint256 shares;
    }

    struct VaultData {
        uint256 totalStake;
        StakeData[] stakes;
    }

    struct StakeData {
        uint256 amount;
        uint256 timestamp;
    }

    struct RewardScaling {
        uint256 floor;
        uint256 ceiling;
        uint256 time;
    }

    struct RewardOutput {
        uint256 lastStakeAmount;
        uint256 newStakesCount;
        uint256 reward;
        uint256 newTotalStakeUnits;
    }

    /* user functions */

    function stake(
        address vault,
        uint256 amount,
        bytes calldata permission
    ) external;

    function unstakeAndClaim(
        address vault,
        uint256 amount,
        bytes calldata permission
    ) external;

    /* getter functions */

    function getHypervisorData() external view returns (HypervisorData memory hypervisor);

    function getBonusTokenSetLength() external view returns (uint256 length);

    function getBonusTokenAtIndex(uint256 index) external view returns (address bonusToken);

    function getVaultFactorySetLength() external view returns (uint256 length);

    function getVaultFactoryAtIndex(uint256 index) external view returns (address factory);

    function getVaultData(address vault) external view returns (VaultData memory vaultData);

    function isValidAddress(address target) external view returns (bool validity);

    function isValidVault(address target) external view returns (bool validity);

    function getCurrentUnlockedRewards() external view returns (uint256 unlockedRewards);

    function getFutureUnlockedRewards(uint256 timestamp)
        external
        view
        returns (uint256 unlockedRewards);

    function getCurrentVaultReward(address vault) external view returns (uint256 reward);

    function getCurrentStakeReward(address vault, uint256 stakeAmount)
        external
        view
        returns (uint256 reward);

    function getFutureVaultReward(address vault, uint256 timestamp)
        external
        view
        returns (uint256 reward);

    function getFutureStakeReward(
        address vault,
        uint256 stakeAmount,
        uint256 timestamp
    ) external view returns (uint256 reward);

    function getCurrentVaultStakeUnits(address vault) external view returns (uint256 stakeUnits);

    function getFutureVaultStakeUnits(address vault, uint256 timestamp)
        external
        view
        returns (uint256 stakeUnits);

    function getCurrentTotalStakeUnits() external view returns (uint256 totalStakeUnits);

    function getFutureTotalStakeUnits(uint256 timestamp)
        external
        view
        returns (uint256 totalStakeUnits);

    /* pure functions */

    function calculateTotalStakeUnits(StakeData[] memory stakes, uint256 timestamp)
        external
        pure
        returns (uint256 totalStakeUnits);

    function calculateStakeUnits(
        uint256 amount,
        uint256 start,
        uint256 end
    ) external pure returns (uint256 stakeUnits);

    function calculateUnlockedRewards(
        RewardSchedule[] memory rewardSchedules,
        uint256 rewardBalance,
        uint256 sharesOutstanding,
        uint256 timestamp
    ) external pure returns (uint256 unlockedRewards);

    function calculateRewardFromStakes(
        StakeData[] memory stakes,
        uint256 unstakeAmount,
        uint256 unlockedRewards,
        uint256 totalStakeUnits,
        uint256 timestamp,
        RewardScaling memory rewardScaling
    ) external pure returns (RewardOutput memory out);

    function calculateReward(
        uint256 unlockedRewards,
        uint256 stakeAmount,
        uint256 stakeDuration,
        uint256 totalStakeUnits,
        RewardScaling memory rewardScaling
    ) external pure returns (uint256 reward);
}

/// @title Hypervisor
/// @notice Reward distribution contract with time multiplier
/// Access Control
/// - Power controller:
///     Can power off / shutdown the Hypervisor
///     Can withdraw rewards from reward pool once shutdown
/// - Proxy owner:
///     Can change arbitrary logic / state by upgrading the Hypervisor
///     Is unable to operate on user funds due to UniversalVault
///     Is unable to operate on reward pool funds when reward pool is offline / shutdown
/// - Hypervisor admin:
///     Can add funds to the Hypervisor, register bonus tokens, and whitelist new vault factories
///     Is a subset of proxy owner permissions
/// - User:
///     Can deposit / withdraw / ragequit
/// Hypervisor State Machine
/// - Online:
///     Hypervisor is operating normally, all functions are enabled
/// - Offline:
///     Hypervisor is temporarely disabled for maintenance
///     User deposits and withdrawls are disabled, ragequit remains enabled
///     Users can withdraw their stake through rageQuit() but forego their pending reward
///     Should only be used when downtime required for an upgrade
/// - Shutdown:
///     Hypervisor is permanently disabled
///     All functions are disabled with the exception of ragequit
///     Users can withdraw their stake through rageQuit()
///     Power controller can withdraw from the reward pool
///     Should only be used if Proxy Owner role is compromized
contract Hypervisor is IHypervisor, Powered, Ownable {
    using SafeMath for uint256;
    using EnumerableSet for EnumerableSet.AddressSet;

    /* constants */

    // An upper bound on the number of active stakes per vault is required to prevent
    // calls to rageQuit() from reverting.
    // With 30 stakes in a vault, ragequit costs 432811 gas which is conservatively lower
    // than the hardcoded limit of 500k gas on the vault.
    // This limit is configurable and could be increased in a future deployment.
    // Ultimately, to avoid a need for fixed upper bounds, the EVM would need to provide
    // an error code that allows for reliably catching out-of-gas errors on remote calls.
    uint256 public constant MAX_STAKES_PER_VAULT = 30;
    uint256 public constant MAX_REWARD_TOKENS = 50;
    uint256 public constant BASE_SHARES_PER_WEI = 1000000;
    uint256 public stakeLimit = 2500 ether;

    /* storage */

    HypervisorData private _hypervisor;
    mapping(address => VaultData) private _vaults;
    EnumerableSet.AddressSet private _bonusTokenSet;
    EnumerableSet.AddressSet private _vaultFactorySet;

    /* initializer */

    /// @notice Initizalize Hypervisor
    /// access control: only proxy constructor
    /// state machine: can only be called once
    /// state scope: set initialization variables
    /// token transfer: none
    /// @param ownerAddress address The admin address
    /// @param rewardPoolFactory address The factory to use for deploying the RewardPool
    /// @param powerSwitchFactory address The factory to use for deploying the PowerSwitch
    /// @param stakingToken address The address of the staking token for this Hypervisor
    /// @param rewardToken address The address of the reward token for this Hypervisor
    /// @param rewardScaling RewardScaling The config for reward scaling floor, ceiling, and time
    constructor(
        address ownerAddress,
        address rewardPoolFactory,
        address powerSwitchFactory,
        address stakingToken,
        address rewardToken,
        RewardScaling memory rewardScaling,
        uint256 _stakeLimit
    ) {
        // the scaling floor must be smaller than ceiling
        require(rewardScaling.floor <= rewardScaling.ceiling, ""Hypervisor: floor above ceiling"");

        // setting rewardScalingTime to 0 would cause divide by zero error
        // to disable reward scaling, use rewardScalingFloor == rewardScalingCeiling
        require(rewardScaling.time != 0, ""Hypervisor: scaling time cannot be zero"");

        // deploy power switch
        address powerSwitch = IFactory(powerSwitchFactory).create(abi.encode(ownerAddress));

        // deploy reward pool
        address rewardPool = IFactory(rewardPoolFactory).create(abi.encode(powerSwitch));

        // set internal configs
        Ownable.transferOwnership(ownerAddress);
        Powered._setPowerSwitch(powerSwitch);

        // commit to storage
        _hypervisor.stakingToken = stakingToken;
        _hypervisor.rewardToken = rewardToken;
        _hypervisor.rewardPool = rewardPool;
        _hypervisor.rewardScaling = rewardScaling;

        stakeLimit = _stakeLimit;

        // emit event
        emit HypervisorCreated(rewardPool, powerSwitch);
    }

    /* getter functions */

    function getBonusTokenSetLength() external view override returns (uint256 length) {
        return _bonusTokenSet.length();
    }

    function getBonusTokenAtIndex(uint256 index)
        external
        view
        override
        returns (address bonusToken)
    {
        return _bonusTokenSet.at(index);
    }

    function getVaultFactorySetLength() external view override returns (uint256 length) {
        return _vaultFactorySet.length();
    }

    function getVaultFactoryAtIndex(uint256 index)
        external
        view
        override
        returns (address factory)
    {
        return _vaultFactorySet.at(index);
    }

    function isValidVault(address target) public view override returns (bool validity) {
        // validate target is created from whitelisted vault factory
        for (uint256 index = 0; index < _vaultFactorySet.length(); index++) {
            if (IInstanceRegistry(_vaultFactorySet.at(index)).isInstance(target)) {
                return true;
            }
        }
        // explicit return
        return false;
    }

    function isValidAddress(address target) public view override returns (bool validity) {
        // sanity check target for potential input errors
        return
            target != address(this) &&
            target != address(0) &&
            target != _hypervisor.stakingToken &&
            target != _hypervisor.rewardToken &&
            target != _hypervisor.rewardPool &&
            !_bonusTokenSet.contains(target);
    }

    /* Hypervisor getters */

    function getHypervisorData() external view override returns (HypervisorData memory hypervisor) {
        return _hypervisor;
    }

    function getCurrentUnlockedRewards() public view override returns (uint256 unlockedRewards) {
        // calculate reward available based on state
        return getFutureUnlockedRewards(block.timestamp);
    }

    function getFutureUnlockedRewards(uint256 timestamp)
        public
        view
        override
        returns (uint256 unlockedRewards)
    {
        // get reward amount remaining
        uint256 remainingRewards = IERC20(_hypervisor.rewardToken).balanceOf(_hypervisor.rewardPool);
        // calculate reward available based on state
        unlockedRewards = calculateUnlockedRewards(
            _hypervisor.rewardSchedules,
            remainingRewards,
            _hypervisor.rewardSharesOutstanding,
            timestamp
        );
        // explicit return
        return unlockedRewards;
    }

    function getCurrentTotalStakeUnits() public view override returns (uint256 totalStakeUnits) {
        // calculate new stake units
        return getFutureTotalStakeUnits(block.timestamp);
    }

    function getFutureTotalStakeUnits(uint256 timestamp)
        public
        view
        override
        returns (uint256 totalStakeUnits)
    {
        // return early if no change
        if (timestamp == _hypervisor.lastUpdate) return _hypervisor.totalStakeUnits;
        // calculate new stake units
        uint256 newStakeUnits =
            calculateStakeUnits(_hypervisor.totalStake, _hypervisor.lastUpdate, timestamp);
        // add to cached total
        totalStakeUnits = _hypervisor.totalStakeUnits.add(newStakeUnits);
        // explicit return
        return totalStakeUnits;
    }

    /* vault getters */

    function getVaultData(address vault)
        external
        view
        override
        returns (VaultData memory vaultData)
    {
        return _vaults[vault];
    }

    function getCurrentVaultReward(address vault) external view override returns (uint256 reward) {
        // calculate rewards
        return
            calculateRewardFromStakes(
                _vaults[vault]
                    .stakes,
                _vaults[vault]
                    .totalStake,
                getCurrentUnlockedRewards(),
                getCurrentTotalStakeUnits(),
                block
                    .timestamp,
                _hypervisor
                    .rewardScaling
            )
                .reward;
    }

    function getFutureVaultReward(address vault, uint256 timestamp)
        external
        view
        override
        returns (uint256 reward)
    {
        // calculate rewards
        return
            calculateRewardFromStakes(
                _vaults[vault]
                    .stakes,
                _vaults[vault]
                    .totalStake,
                getFutureUnlockedRewards(timestamp),
                getFutureTotalStakeUnits(timestamp),
                timestamp,
                _hypervisor
                    .rewardScaling
            )
                .reward;
    }

    function getCurrentStakeReward(address vault, uint256 stakeAmount)
        external
        view
        override
        returns (uint256 reward)
    {
        // calculate rewards
        return
            calculateRewardFromStakes(
                _vaults[vault]
                    .stakes,
                stakeAmount,
                getCurrentUnlockedRewards(),
                getCurrentTotalStakeUnits(),
                block
                    .timestamp,
                _hypervisor
                    .rewardScaling
            )
                .reward;
    }

    function getFutureStakeReward(
        address vault,
        uint256 stakeAmount,
        uint256 timestamp
    ) external view override returns (uint256 reward) {
        // calculate rewards
        return
            calculateRewardFromStakes(
                _vaults[vault]
                    .stakes,
                stakeAmount,
                getFutureUnlockedRewards(timestamp),
                getFutureTotalStakeUnits(timestamp),
                timestamp,
                _hypervisor
                    .rewardScaling
            )
                .reward;
    }

    function getCurrentVaultStakeUnits(address vault)
        public
        view
        override
        returns (uint256 stakeUnits)
    {
        // calculate stake units
        return getFutureVaultStakeUnits(vault, block.timestamp);
    }

    function getFutureVaultStakeUnits(address vault, uint256 timestamp)
        public
        view
        override
        returns (uint256 stakeUnits)
    {
        // calculate stake units
        return calculateTotalStakeUnits(_vaults[vault].stakes, timestamp);
    }

    /* pure functions */

    function calculateTotalStakeUnits(StakeData[] memory stakes, uint256 timestamp)
        public
        pure
        override
        returns (uint256 totalStakeUnits)
    {
        for (uint256 index; index < stakes.length; index++) {
            // reference stake
            StakeData memory stakeData = stakes[index];
            // calculate stake units
            uint256 stakeUnits =
                calculateStakeUnits(stakeData.amount, stakeData.timestamp, timestamp);
            // add to running total
            totalStakeUnits = totalStakeUnits.add(stakeUnits);
        }
    }

    function calculateStakeUnits(
        uint256 amount,
        uint256 start,
        uint256 end
    ) public pure override returns (uint256 stakeUnits) {
        // calculate duration
        uint256 duration = end.sub(start);
        // calculate stake units
        stakeUnits = duration.mul(amount);
        // explicit return
        return stakeUnits;
    }

    function calculateUnlockedRewards(
        RewardSchedule[] memory rewardSchedules,
        uint256 rewardBalance,
        uint256 sharesOutstanding,
        uint256 timestamp
    ) public pure override returns (uint256 unlockedRewards) {
        // return 0 if no registered schedules
        if (rewardSchedules.length == 0) {
            return 0;
        }

        // calculate reward shares locked across all reward schedules
        uint256 sharesLocked;
        for (uint256 index = 0; index < rewardSchedules.length; index++) {
            // fetch reward schedule storage reference
            RewardSchedule memory schedule = rewardSchedules[index];

            // caculate amount of shares available on this schedule
            // if (now - start) < duration
            //   sharesLocked = shares - (shares * (now - start) / duration)
            // else
            //   sharesLocked = 0
            uint256 currentSharesLocked = 0;
            if (timestamp.sub(schedule.start) < schedule.duration) {
                currentSharesLocked = schedule.shares.sub(
                    schedule.shares.mul(timestamp.sub(schedule.start)).div(schedule.duration)
                );
            }

            // add to running total
            sharesLocked = sharesLocked.add(currentSharesLocked);
        }

        // convert shares to reward
        // rewardLocked = sharesLocked * rewardBalance / sharesOutstanding
        uint256 rewardLocked = sharesLocked.mul(rewardBalance).div(sharesOutstanding);

        // calculate amount available
        // unlockedRewards = rewardBalance - rewardLocked
        unlockedRewards = rewardBalance.sub(rewardLocked);

        // explicit return
        return unlockedRewards;
    }

    function calculateRewardFromStakes(
        StakeData[] memory stakes,
        uint256 unstakeAmount,
        uint256 unlockedRewards,
        uint256 totalStakeUnits,
        uint256 timestamp,
        RewardScaling memory rewardScaling
    ) public pure override returns (RewardOutput memory out) {
        uint256 stakesToDrop = 0;
        while (unstakeAmount > 0) {
            // fetch vault stake storage reference
            StakeData memory lastStake = stakes[stakes.length.sub(stakesToDrop).sub(1)];

            // calculate stake duration
            uint256 stakeDuration = timestamp.sub(lastStake.timestamp);

            uint256 currentAmount;
            if (lastStake.amount > unstakeAmount) {
                // set current amount to remaining unstake amount
                currentAmount = unstakeAmount;
                // amount of last stake is reduced
                out.lastStakeAmount = lastStake.amount.sub(unstakeAmount);
            } else {
                // set current amount to amount of last stake
                currentAmount = lastStake.amount;
                // add to stakes to drop
                stakesToDrop += 1;
            }

            // update remaining unstakeAmount
            unstakeAmount = unstakeAmount.sub(currentAmount);

            // calculate reward amount
            uint256 currentReward =
                calculateReward(
                    unlockedRewards,
                    currentAmount,
                    stakeDuration,
                    totalStakeUnits,
                    rewardScaling
                );

            // update cumulative reward
            out.reward = out.reward.add(currentReward);

            // update cached unlockedRewards
            unlockedRewards = unlockedRewards.sub(currentReward);

            // calculate time weighted stake
            uint256 stakeUnits = currentAmount.mul(stakeDuration);

            // update cached totalStakeUnits
            totalStakeUnits = totalStakeUnits.sub(stakeUnits);
        }

        // explicit return
        return
            RewardOutput(
                out.lastStakeAmount,
                stakes.length.sub(stakesToDrop),
                out.reward,
                totalStakeUnits
            );
    }

    function calculateReward(
        uint256 unlockedRewards,
        uint256 stakeAmount,
        uint256 stakeDuration,
        uint256 totalStakeUnits,
        RewardScaling memory rewardScaling
    ) public pure override returns (uint256 reward) {
        // calculate time weighted stake
        uint256 stakeUnits = stakeAmount.mul(stakeDuration);

        // calculate base reward
        // baseReward = unlockedRewards * stakeUnits / totalStakeUnits
        uint256 baseReward = 0;
        if (totalStakeUnits != 0) {
            // scale reward according to proportional weight
            baseReward = unlockedRewards.mul(stakeUnits).div(totalStakeUnits);
        }

        // calculate scaled reward
        // if no scaling or scaling period completed
        //   reward = baseReward
        // else
        //   minReward = baseReward * scalingFloor / scalingCeiling
        //   bonusReward = baseReward
        //                 * (scalingCeiling - scalingFloor) / scalingCeiling
        //                 * duration / scalingTime
        //   reward = minReward + bonusReward
        if (stakeDuration >= rewardScaling.time || rewardScaling.floor == rewardScaling.ceiling) {
            // no reward scaling applied
            reward = baseReward;
        } else {
            // calculate minimum reward using scaling floor
            uint256 minReward = baseReward.mul(rewardScaling.floor).div(rewardScaling.ceiling);

            // calculate bonus reward with vested portion of scaling factor
            uint256 bonusReward =
                baseReward
                    .mul(stakeDuration)
                    .mul(rewardScaling.ceiling.sub(rewardScaling.floor))
                    .div(rewardScaling.ceiling)
                    .div(rewardScaling.time);

            // add minimum reward and bonus reward
            reward = minReward.add(bonusReward);
        }

        // explicit return
        return reward;
    }

    /* admin functions */

    /// @notice Add funds to the Hypervisor
    /// access control: only admin
    /// state machine:
    ///   - can be called multiple times
    ///   - only online
    /// state scope:
    ///   - increase _hypervisor.rewardSharesOutstanding
    ///   - append to _hypervisor.rewardSchedules
    /// token transfer: transfer staking tokens from msg.sender to reward pool
    /// @param amount uint256 Amount of reward tokens to deposit
    /// @param duration uint256 Duration over which to linearly unlock rewards
    function fund(uint256 amount, uint256 duration) external onlyOwner onlyOnline {
        // validate duration
        require(duration != 0, ""Hypervisor: invalid duration"");

        // create new reward shares
        // if existing rewards on this Hypervisor
        //   mint new shares proportional to % change in rewards remaining
        //   newShares = remainingShares * newReward / remainingRewards
        // else
        //   mint new shares with BASE_SHARES_PER_WEI initial conversion rate
        //   store as fixed point number with same  of decimals as reward token
        uint256 newRewardShares;
        if (_hypervisor.rewardSharesOutstanding > 0) {
            uint256 remainingRewards = IERC20(_hypervisor.rewardToken).balanceOf(_hypervisor.rewardPool);
            newRewardShares = _hypervisor.rewardSharesOutstanding.mul(amount).div(remainingRewards);
        } else {
            newRewardShares = amount.mul(BASE_SHARES_PER_WEI);
        }

        // add reward shares to total
        _hypervisor.rewardSharesOutstanding = _hypervisor.rewardSharesOutstanding.add(newRewardShares);

        // store new reward schedule
        _hypervisor.rewardSchedules.push(RewardSchedule(duration, block.timestamp, newRewardShares));

        // transfer reward tokens to reward pool
        TransferHelper.safeTransferFrom(
            _hypervisor.rewardToken,
            msg.sender,
            _hypervisor.rewardPool,
            amount
        );

        // emit event
        emit HypervisorFunded(amount, duration);
    }

    /// @notice Add vault factory to whitelist
    /// @dev use this function to enable stakes to vaults coming from the specified
    ///      factory contract
    /// access control: only admin
    /// state machine:
    ///   - can be called multiple times
    ///   - not shutdown
    /// state scope:
    ///   - append to _vaultFactorySet
    /// token transfer: none
    /// @param factory address The address of the vault factory
    function registerVaultFactory(address factory) external onlyOwner notShutdown {
        // add factory to set
        require(_vaultFactorySet.add(factory), ""Hypervisor: vault factory already registered"");

        // emit event
        emit VaultFactoryRegistered(factory);
    }

    /// @notice Remove vault factory from whitelist
    /// @dev use this function to disable new stakes to vaults coming from the specified
    ///      factory contract.
    ///      note: vaults with existing stakes from this factory are sill able to unstake
    /// access control: only admin
    /// state machine:
    ///   - can be called multiple times
    ///   - not shutdown
    /// state scope:
    ///   - remove from _vaultFactorySet
    /// token transfer: none
    /// @param factory address The address of the vault factory
    function removeVaultFactory(address factory) external onlyOwner notShutdown {
        // remove factory from set
        require(_vaultFactorySet.remove(factory), ""Hypervisor: vault factory not registered"");

        // emit event
        emit VaultFactoryRemoved(factory);
    }

    /// @notice Register bonus token for distribution
    /// @dev use this function to enable distribution of any ERC20 held by the RewardPool contract
    /// access control: only admin
    /// state machine:
    ///   - can be called multiple times
    ///   - only online
    /// state scope:
    ///   - append to _bonusTokenSet
    /// token transfer: none
    /// @param bonusToken address The address of the bonus token
    function registerBonusToken(address bonusToken) external onlyOwner onlyOnline {
        // verify valid bonus token
        _validateAddress(bonusToken);

        // verify bonus token count
        require(_bonusTokenSet.length() < MAX_REWARD_TOKENS, ""Hypervisor: max bonus tokens reached "");

        // add token to set
        assert(_bonusTokenSet.add(bonusToken));

        // emit event
        emit BonusTokenRegistered(bonusToken);
    }

    /// @notice Rescue tokens from RewardPool
    /// @dev use this function to rescue tokens from RewardPool contract
    ///      without distributing to stakers or triggering emergency shutdown
    /// access control: only admin
    /// state machine:
    ///   - can be called multiple times
    ///   - only online
    /// state scope: none
    /// token transfer: transfer requested token from RewardPool to recipient
    /// @param token address The address of the token to rescue
    /// @param recipient address The address of the recipient
    /// @param amount uint256 The amount of tokens to rescue
    function rescueTokensFromRewardPool(
        address token,
        address recipient,
        uint256 amount
    ) external onlyOwner onlyOnline {
        // verify recipient
        _validateAddress(recipient);

        // check not attempting to unstake reward token
        require(token != _hypervisor.rewardToken, ""Hypervisor: invalid address"");

        // check not attempting to wthdraw bonus token
        require(!_bonusTokenSet.contains(token), ""Hypervisor: invalid address"");

        // transfer tokens to recipient
        IRewardPool(_hypervisor.rewardPool).sendERC20(token, recipient, amount);
    }

    /* user functions */

    /// @notice Stake tokens
    /// @dev anyone can stake to any vault if they have valid permission
    /// access control: anyone
    /// state machine:
    ///   - can be called multiple times
    ///   - only online
    ///   - when vault exists on this Hypervisor
    /// state scope:
    ///   - append to _vaults[vault].stakes
    ///   - increase _vaults[vault].totalStake
    ///   - increase _hypervisor.totalStake
    ///   - increase _hypervisor.totalStakeUnits
    ///   - increase _hypervisor.lastUpdate
    /// token transfer: transfer staking tokens from msg.sender to vault
    /// @param vault address The address of the vault to stake from
    /// @param amount uint256 The amount of staking tokens to stake
    function stake(
        address vault,
        uint256 amount,
        bytes calldata permission
    ) external override onlyOnline {
        // verify vault is valid
        require(isValidVault(vault), ""Hypervisor: vault is not registered"");

        // verify non-zero amount
        require(amount != 0, ""Hypervisor: no amount staked"");

        // fetch vault storage reference
        VaultData storage vaultData = _vaults[vault];

        // verify stakes boundary not reached
        require(
            vaultData.stakes.length < MAX_STAKES_PER_VAULT,
            ""Hypervisor: MAX_STAKES_PER_VAULT reached""
        );

        // update cached sum of stake units across all vaults
        _updateTotalStakeUnits();

        // store amount and timestamp
        vaultData.stakes.push(StakeData(amount, block.timestamp));

        // update cached total vault and Hypervisor amounts
        vaultData.totalStake = vaultData.totalStake.add(amount);
        // verify stake quantity without bounds
        require(
            stakeLimit == 0 || vaultData.totalStake <= stakeLimit,
            ""Hypervisor: Stake limit exceeded""
        );
        _hypervisor.totalStake = _hypervisor.totalStake.add(amount);

        // call lock on vault
        IUniversalVault(vault).lock(_hypervisor.stakingToken, amount, permission);

        // emit event
        emit Staked(vault, amount);
    }

    /// @notice Unstake staking tokens and claim reward
    /// @dev rewards can only be claimed when unstaking
    /// access control: only owner of vault
    /// state machine:
    ///   - when vault exists on this Hypervisor
    ///   - after stake from vault
    ///   - can be called multiple times while sufficient stake remains
    ///   - only online
    /// state scope:
    ///   - decrease _hypervisor.rewardSharesOutstanding
    ///   - decrease _hypervisor.totalStake
    ///   - increase _hypervisor.lastUpdate
    ///   - modify _hypervisor.totalStakeUnits
    ///   - modify _vaults[vault].stakes
    ///   - decrease _vaults[vault].totalStake
    /// token transfer:
    ///   - transfer reward tokens from reward pool to recipient
    ///   - transfer bonus tokens from reward pool to recipient
    /// @param vault address The vault to unstake from
    /// @param amount uint256 The amount of staking tokens to unstake
    function unstakeAndClaim(
        address vault,
        uint256 amount,
        bytes calldata permission
    ) external override onlyOnline {
        // fetch vault storage reference
        VaultData storage vaultData = _vaults[vault];

        // verify non-zero amount
        require(amount != 0, ""Hypervisor: no amount unstaked"");

        address recipient = IUniversalVault(vault).owner();

        // validate recipient
        _validateAddress(recipient);

        // check for sufficient vault stake amount
        require(vaultData.totalStake >= amount, ""Hypervisor: insufficient vault stake"");

        // check for sufficient Hypervisor stake amount
        // if this check fails, there is a bug in stake accounting
        assert(_hypervisor.totalStake >= amount);

        // update cached sum of stake units across all vaults
        _updateTotalStakeUnits();

        // get reward amount remaining
        uint256 remainingRewards = IERC20(_hypervisor.rewardToken).balanceOf(_hypervisor.rewardPool);

        // calculate vested portion of reward pool
        uint256 unlockedRewards =
            calculateUnlockedRewards(
                _hypervisor.rewardSchedules,
                remainingRewards,
                _hypervisor.rewardSharesOutstanding,
                block.timestamp
            );

        // calculate vault time weighted reward with scaling
        RewardOutput memory out =
            calculateRewardFromStakes(
                vaultData.stakes,
                amount,
                unlockedRewards,
                _hypervisor.totalStakeUnits,
                block.timestamp,
                _hypervisor.rewardScaling
            );

        // update stake data in storage
        if (out.newStakesCount == 0) {
            // all stakes have been unstaked
            delete vaultData.stakes;
        } else {
            // some stakes have been completely or partially unstaked
            // delete fully unstaked stakes
            while (vaultData.stakes.length > out.newStakesCount) vaultData.stakes.pop();
            // update partially unstaked stake
            vaultData.stakes[out.newStakesCount.sub(1)].amount = out.lastStakeAmount;
        }

        // update cached stake totals
        vaultData.totalStake = vaultData.totalStake.sub(amount);
        _hypervisor.totalStake = _hypervisor.totalStake.sub(amount);
        _hypervisor.totalStakeUnits = out.newTotalStakeUnits;

        // unlock staking tokens from vault
        IUniversalVault(vault).unlock(_hypervisor.stakingToken, amount, permission);

        // emit event
        emit Unstaked(vault, amount);

        // only perform on non-zero reward
        if (out.reward > 0) {
            // calculate shares to burn
            // sharesToBurn = sharesOutstanding * reward / remainingRewards
            uint256 sharesToBurn =
                _hypervisor.rewardSharesOutstanding.mul(out.reward).div(remainingRewards);

            // burn claimed shares
            _hypervisor.rewardSharesOutstanding = _hypervisor.rewardSharesOutstanding.sub(sharesToBurn);

            // transfer bonus tokens from reward pool to recipient
            if (_bonusTokenSet.length() > 0) {
                for (uint256 index = 0; index < _bonusTokenSet.length(); index++) {
                    // fetch bonus token address reference
                    address bonusToken = _bonusTokenSet.at(index);

                    // calculate bonus token amount
                    // bonusAmount = bonusRemaining * reward / remainingRewards
                    uint256 bonusAmount =
                        IERC20(bonusToken).balanceOf(_hypervisor.rewardPool).mul(out.reward).div(
                            remainingRewards
                        );

                    // transfer bonus token
                    IRewardPool(_hypervisor.rewardPool).sendERC20(bonusToken, recipient, bonusAmount);

                    // emit event
                    emit RewardClaimed(vault, recipient, bonusToken, bonusAmount);
                }
            }

            // transfer reward tokens from reward pool to recipient
            IRewardPool(_hypervisor.rewardPool).sendERC20(_hypervisor.rewardToken, recipient, out.reward);

            // emit event
            emit RewardClaimed(vault, recipient, _hypervisor.rewardToken, out.reward);
        }
    }

    /// @notice Exit Hypervisor without claiming reward
    /// @dev This function should never revert when correctly called by the vault.
    ///      A max number of stakes per vault is set with MAX_STAKES_PER_VAULT to
    ///      place an upper bound on the for loop in calculateTotalStakeUnits().
    /// access control: only callable by the vault directly
    /// state machine:
    ///   - when vault exists on this Hypervisor
    ///   - when active stake from this vault
    ///   - any power state
    /// state scope:
    ///   - decrease _hypervisor.totalStake
    ///   - increase _hypervisor.lastUpdate
    ///   - modify _hypervisor.totalStakeUnits
    ///   - delete _vaults[vault]
    /// token transfer: none
    function rageQuit() external override {
        // fetch vault storage reference
        VaultData storage _vaultData = _vaults[msg.sender];

        // revert if no active stakes
        require(_vaultData.stakes.length != 0, ""Hypervisor: no stake"");

        // update cached sum of stake units across all vaults
        _updateTotalStakeUnits();

        // emit event
        emit Unstaked(msg.sender, _vaultData.totalStake);

        // update cached totals
        _hypervisor.totalStake = _hypervisor.totalStake.sub(_vaultData.totalStake);
        _hypervisor.totalStakeUnits = _hypervisor.totalStakeUnits.sub(
            calculateTotalStakeUnits(_vaultData.stakes, block.timestamp)
        );

        // delete stake data
        delete _vaults[msg.sender];
    }

    /* convenience functions */

    function _updateTotalStakeUnits() private {
        // update cached totalStakeUnits
        _hypervisor.totalStakeUnits = getCurrentTotalStakeUnits();
        // update cached lastUpdate
        _hypervisor.lastUpdate = block.timestamp;
    }

    function _validateAddress(address target) private view {
        // sanity check target for potential input errors
        require(isValidAddress(target), ""Hypervisor: invalid address"");
    }

    function _truncateStakesArray(StakeData[] memory array, uint256 newLength)
        private
        pure
        returns (StakeData[] memory newArray)
    {
        newArray = new StakeData[](newLength);
        for (uint256 index = 0; index < newLength; index++) {
            newArray[index] = array[index];
        }
        return newArray;
    }
}
.
To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs.]

Given the user's task and the brainstorming ideas provided:
Task: ""// SPDX-License-Identifier: GPL-3.0-only
pragma solidity 0.7.6;
pragma abicoder v2;

import {SafeMath} from ""@openzeppelin/contracts/math/SafeMath.sol"";
import {EnumerableSet} from ""@openzeppelin/contracts/utils/EnumerableSet.sol"";
import {IERC20} from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import {Ownable} from ""@openzeppelin/contracts/access/Ownable.sol"";
import {TransferHelper} from ""@uniswap/lib/contracts/libraries/TransferHelper.sol"";

import {IFactory} from ""../factory/IFactory.sol"";
import {IInstanceRegistry} from ""../factory/InstanceRegistry.sol"";
import {IUniversalVault} from ""../visor/Visor.sol"";
import {IRewardPool} from ""./RewardPool.sol"";
import {Powered} from ""./Powered.sol"";

interface IRageQuit {
    function rageQuit() external;
}

interface IHypervisor is IRageQuit {
    /* admin events */

    event HypervisorCreated(address rewardPool, address powerSwitch);
    event HypervisorFunded(uint256 amount, uint256 duration);
    event BonusTokenRegistered(address token);
    event VaultFactoryRegistered(address factory);
    event VaultFactoryRemoved(address factory);

    /* user events */

    event Staked(address vault, uint256 amount);
    event Unstaked(address vault, uint256 amount);
    event RewardClaimed(address vault, address recipient, address token, uint256 amount);

    /* data types */

    struct HypervisorData {
        address stakingToken;
        address rewardToken;
        address rewardPool;
        RewardScaling rewardScaling;
        uint256 rewardSharesOutstanding;
        uint256 totalStake;
        uint256 totalStakeUnits;
        uint256 lastUpdate;
        RewardSchedule[] rewardSchedules;
    }

    struct RewardSchedule {
        uint256 duration;
        uint256 start;
        uint256 shares;
    }

    struct VaultData {
        uint256 totalStake;
        StakeData[] stakes;
    }

    struct StakeData {
        uint256 amount;
        uint256 timestamp;
    }

    struct RewardScaling {
        uint256 floor;
        uint256 ceiling;
        uint256 time;
    }

    struct RewardOutput {
        uint256 lastStakeAmount;
        uint256 newStakesCount;
        uint256 reward;
        uint256 newTotalStakeUnits;
    }

    /* user functions */

    function stake(
        address vault,
        uint256 amount,
        bytes calldata permission
    ) external;

    function unstakeAndClaim(
        address vault,
        uint256 amount,
        bytes calldata permission
    ) external;

    /* getter functions */

    function getHypervisorData() external view returns (HypervisorData memory hypervisor);

    function getBonusTokenSetLength() external view returns (uint256 length);

    function getBonusTokenAtIndex(uint256 index) external view returns (address bonusToken);

    function getVaultFactorySetLength() external view returns (uint256 length);

    function getVaultFactoryAtIndex(uint256 index) external view returns (address factory);

    function getVaultData(address vault) external view returns (VaultData memory vaultData);

    function isValidAddress(address target) external view returns (bool validity);

    function isValidVault(address target) external view returns (bool validity);

    function getCurrentUnlockedRewards() external view returns (uint256 unlockedRewards);

    function getFutureUnlockedRewards(uint256 timestamp)
        external
        view
        returns (uint256 unlockedRewards);

    function getCurrentVaultReward(address vault) external view returns (uint256 reward);

    function getCurrentStakeReward(address vault, uint256 stakeAmount)
        external
        view
        returns (uint256 reward);

    function getFutureVaultReward(address vault, uint256 timestamp)
        external
        view
        returns (uint256 reward);

    function getFutureStakeReward(
        address vault,
        uint256 stakeAmount,
        uint256 timestamp
    ) external view returns (uint256 reward);

    function getCurrentVaultStakeUnits(address vault) external view returns (uint256 stakeUnits);

    function getFutureVaultStakeUnits(address vault, uint256 timestamp)
        external
        view
        returns (uint256 stakeUnits);

    function getCurrentTotalStakeUnits() external view returns (uint256 totalStakeUnits);

    function getFutureTotalStakeUnits(uint256 timestamp)
        external
        view
        returns (uint256 totalStakeUnits);

    /* pure functions */

    function calculateTotalStakeUnits(StakeData[] memory stakes, uint256 timestamp)
        external
        pure
        returns (uint256 totalStakeUnits);

    function calculateStakeUnits(
        uint256 amount,
        uint256 start,
        uint256 end
    ) external pure returns (uint256 stakeUnits);

    function calculateUnlockedRewards(
        RewardSchedule[] memory rewardSchedules,
        uint256 rewardBalance,
        uint256 sharesOutstanding,
        uint256 timestamp
    ) external pure returns (uint256 unlockedRewards);

    function calculateRewardFromStakes(
        StakeData[] memory stakes,
        uint256 unstakeAmount,
        uint256 unlockedRewards,
        uint256 totalStakeUnits,
        uint256 timestamp,
        RewardScaling memory rewardScaling
    ) external pure returns (RewardOutput memory out);

    function calculateReward(
        uint256 unlockedRewards,
        uint256 stakeAmount,
        uint256 stakeDuration,
        uint256 totalStakeUnits,
        RewardScaling memory rewardScaling
    ) external pure returns (uint256 reward);
}

/// @title Hypervisor
/// @notice Reward distribution contract with time multiplier
/// Access Control
/// - Power controller:
///     Can power off / shutdown the Hypervisor
///     Can withdraw rewards from reward pool once shutdown
/// - Proxy owner:
///     Can change arbitrary logic / state by upgrading the Hypervisor
///     Is unable to operate on user funds due to UniversalVault
///     Is unable to operate on reward pool funds when reward pool is offline / shutdown
/// - Hypervisor admin:
///     Can add funds to the Hypervisor, register bonus tokens, and whitelist new vault factories
///     Is a subset of proxy owner permissions
/// - User:
///     Can deposit / withdraw / ragequit
/// Hypervisor State Machine
/// - Online:
///     Hypervisor is operating normally, all functions are enabled
/// - Offline:
///     Hypervisor is temporarely disabled for maintenance
///     User deposits and withdrawls are disabled, ragequit remains enabled
///     Users can withdraw their stake through rageQuit() but forego their pending reward
///     Should only be used when downtime required for an upgrade
/// - Shutdown:
///     Hypervisor is permanently disabled
///     All functions are disabled with the exception of ragequit
///     Users can withdraw their stake through rageQuit()
///     Power controller can withdraw from the reward pool
///     Should only be used if Proxy Owner role is compromized
contract Hypervisor is IHypervisor, Powered, Ownable {
    using SafeMath for uint256;
    using EnumerableSet for EnumerableSet.AddressSet;

    /* constants */

    // An upper bound on the number of active stakes per vault is required to prevent
    // calls to rageQuit() from reverting.
    // With 30 stakes in a vault, ragequit costs 432811 gas which is conservatively lower
    // than the hardcoded limit of 500k gas on the vault.
    // This limit is configurable and could be increased in a future deployment.
    // Ultimately, to avoid a need for fixed upper bounds, the EVM would need to provide
    // an error code that allows for reliably catching out-of-gas errors on remote calls.
    uint256 public constant MAX_STAKES_PER_VAULT = 30;
    uint256 public constant MAX_REWARD_TOKENS = 50;
    uint256 public constant BASE_SHARES_PER_WEI = 1000000;
    uint256 public stakeLimit = 2500 ether;

    /* storage */

    HypervisorData private _hypervisor;
    mapping(address => VaultData) private _vaults;
    EnumerableSet.AddressSet private _bonusTokenSet;
    EnumerableSet.AddressSet private _vaultFactorySet;

    /* initializer */

    /// @notice Initizalize Hypervisor
    /// access control: only proxy constructor
    /// state machine: can only be called once
    /// state scope: set initialization variables
    /// token transfer: none
    /// @param ownerAddress address The admin address
    /// @param rewardPoolFactory address The factory to use for deploying the RewardPool
    /// @param powerSwitchFactory address The factory to use for deploying the PowerSwitch
    /// @param stakingToken address The address of the staking token for this Hypervisor
    /// @param rewardToken address The address of the reward token for this Hypervisor
    /// @param rewardScaling RewardScaling The config for reward scaling floor, ceiling, and time
    constructor(
        address ownerAddress,
        address rewardPoolFactory,
        address powerSwitchFactory,
        address stakingToken,
        address rewardToken,
        RewardScaling memory rewardScaling,
        uint256 _stakeLimit
    ) {
        // the scaling floor must be smaller than ceiling
        require(rewardScaling.floor <= rewardScaling.ceiling, ""Hypervisor: floor above ceiling"");

        // setting rewardScalingTime to 0 would cause divide by zero error
        // to disable reward scaling, use rewardScalingFloor == rewardScalingCeiling
        require(rewardScaling.time != 0, ""Hypervisor: scaling time cannot be zero"");

        // deploy power switch
        address powerSwitch = IFactory(powerSwitchFactory).create(abi.encode(ownerAddress));

        // deploy reward pool
        address rewardPool = IFactory(rewardPoolFactory).create(abi.encode(powerSwitch));

        // set internal configs
        Ownable.transferOwnership(ownerAddress);
        Powered._setPowerSwitch(powerSwitch);

        // commit to storage
        _hypervisor.stakingToken = stakingToken;
        _hypervisor.rewardToken = rewardToken;
        _hypervisor.rewardPool = rewardPool;
        _hypervisor.rewardScaling = rewardScaling;

        stakeLimit = _stakeLimit;

        // emit event
        emit HypervisorCreated(rewardPool, powerSwitch);
    }

    /* getter functions */

    function getBonusTokenSetLength() external view override returns (uint256 length) {
        return _bonusTokenSet.length();
    }

    function getBonusTokenAtIndex(uint256 index)
        external
        view
        override
        returns (address bonusToken)
    {
        return _bonusTokenSet.at(index);
    }

    function getVaultFactorySetLength() external view override returns (uint256 length) {
        return _vaultFactorySet.length();
    }

    function getVaultFactoryAtIndex(uint256 index)
        external
        view
        override
        returns (address factory)
    {
        return _vaultFactorySet.at(index);
    }

    function isValidVault(address target) public view override returns (bool validity) {
        // validate target is created from whitelisted vault factory
        for (uint256 index = 0; index < _vaultFactorySet.length(); index++) {
            if (IInstanceRegistry(_vaultFactorySet.at(index)).isInstance(target)) {
                return true;
            }
        }
        // explicit return
        return false;
    }

    function isValidAddress(address target) public view override returns (bool validity) {
        // sanity check target for potential input errors
        return
            target != address(this) &&
            target != address(0) &&
            target != _hypervisor.stakingToken &&
            target != _hypervisor.rewardToken &&
            target != _hypervisor.rewardPool &&
            !_bonusTokenSet.contains(target);
    }

    /* Hypervisor getters */

    function getHypervisorData() external view override returns (HypervisorData memory hypervisor) {
        return _hypervisor;
    }

    function getCurrentUnlockedRewards() public view override returns (uint256 unlockedRewards) {
        // calculate reward available based on state
        return getFutureUnlockedRewards(block.timestamp);
    }

    function getFutureUnlockedRewards(uint256 timestamp)
        public
        view
        override
        returns (uint256 unlockedRewards)
    {
        // get reward amount remaining
        uint256 remainingRewards = IERC20(_hypervisor.rewardToken).balanceOf(_hypervisor.rewardPool);
        // calculate reward available based on state
        unlockedRewards = calculateUnlockedRewards(
            _hypervisor.rewardSchedules,
            remainingRewards,
            _hypervisor.rewardSharesOutstanding,
            timestamp
        );
        // explicit return
        return unlockedRewards;
    }

    function getCurrentTotalStakeUnits() public view override returns (uint256 totalStakeUnits) {
        // calculate new stake units
        return getFutureTotalStakeUnits(block.timestamp);
    }

    function getFutureTotalStakeUnits(uint256 timestamp)
        public
        view
        override
        returns (uint256 totalStakeUnits)
    {
        // return early if no change
        if (timestamp == _hypervisor.lastUpdate) return _hypervisor.totalStakeUnits;
        // calculate new stake units
        uint256 newStakeUnits =
            calculateStakeUnits(_hypervisor.totalStake, _hypervisor.lastUpdate, timestamp);
        // add to cached total
        totalStakeUnits = _hypervisor.totalStakeUnits.add(newStakeUnits);
        // explicit return
        return totalStakeUnits;
    }

    /* vault getters */

    function getVaultData(address vault)
        external
        view
        override
        returns (VaultData memory vaultData)
    {
        return _vaults[vault];
    }

    function getCurrentVaultReward(address vault) external view override returns (uint256 reward) {
        // calculate rewards
        return
            calculateRewardFromStakes(
                _vaults[vault]
                    .stakes,
                _vaults[vault]
                    .totalStake,
                getCurrentUnlockedRewards(),
                getCurrentTotalStakeUnits(),
                block
                    .timestamp,
                _hypervisor
                    .rewardScaling
            )
                .reward;
    }

    function getFutureVaultReward(address vault, uint256 timestamp)
        external
        view
        override
        returns (uint256 reward)
    {
        // calculate rewards
        return
            calculateRewardFromStakes(
                _vaults[vault]
                    .stakes,
                _vaults[vault]
                    .totalStake,
                getFutureUnlockedRewards(timestamp),
                getFutureTotalStakeUnits(timestamp),
                timestamp,
                _hypervisor
                    .rewardScaling
            )
                .reward;
    }

    function getCurrentStakeReward(address vault, uint256 stakeAmount)
        external
        view
        override
        returns (uint256 reward)
    {
        // calculate rewards
        return
            calculateRewardFromStakes(
                _vaults[vault]
                    .stakes,
                stakeAmount,
                getCurrentUnlockedRewards(),
                getCurrentTotalStakeUnits(),
                block
                    .timestamp,
                _hypervisor
                    .rewardScaling
            )
                .reward;
    }

    function getFutureStakeReward(
        address vault,
        uint256 stakeAmount,
        uint256 timestamp
    ) external view override returns (uint256 reward) {
        // calculate rewards
        return
            calculateRewardFromStakes(
                _vaults[vault]
                    .stakes,
                stakeAmount,
                getFutureUnlockedRewards(timestamp),
                getFutureTotalStakeUnits(timestamp),
                timestamp,
                _hypervisor
                    .rewardScaling
            )
                .reward;
    }

    function getCurrentVaultStakeUnits(address vault)
        public
        view
        override
        returns (uint256 stakeUnits)
    {
        // calculate stake units
        return getFutureVaultStakeUnits(vault, block.timestamp);
    }

    function getFutureVaultStakeUnits(address vault, uint256 timestamp)
        public
        view
        override
        returns (uint256 stakeUnits)
    {
        // calculate stake units
        return calculateTotalStakeUnits(_vaults[vault].stakes, timestamp);
    }

    /* pure functions */

    function calculateTotalStakeUnits(StakeData[] memory stakes, uint256 timestamp)
        public
        pure
        override
        returns (uint256 totalStakeUnits)
    {
        for (uint256 index; index < stakes.length; index++) {
            // reference stake
            StakeData memory stakeData = stakes[index];
            // calculate stake units
            uint256 stakeUnits =
                calculateStakeUnits(stakeData.amount, stakeData.timestamp, timestamp);
            // add to running total
            totalStakeUnits = totalStakeUnits.add(stakeUnits);
        }
    }

    function calculateStakeUnits(
        uint256 amount,
        uint256 start,
        uint256 end
    ) public pure override returns (uint256 stakeUnits) {
        // calculate duration
        uint256 duration = end.sub(start);
        // calculate stake units
        stakeUnits = duration.mul(amount);
        // explicit return
        return stakeUnits;
    }

    function calculateUnlockedRewards(
        RewardSchedule[] memory rewardSchedules,
        uint256 rewardBalance,
        uint256 sharesOutstanding,
        uint256 timestamp
    ) public pure override returns (uint256 unlockedRewards) {
        // return 0 if no registered schedules
        if (rewardSchedules.length == 0) {
            return 0;
        }

        // calculate reward shares locked across all reward schedules
        uint256 sharesLocked;
        for (uint256 index = 0; index < rewardSchedules.length; index++) {
            // fetch reward schedule storage reference
            RewardSchedule memory schedule = rewardSchedules[index];

            // caculate amount of shares available on this schedule
            // if (now - start) < duration
            //   sharesLocked = shares - (shares * (now - start) / duration)
            // else
            //   sharesLocked = 0
            uint256 currentSharesLocked = 0;
            if (timestamp.sub(schedule.start) < schedule.duration) {
                currentSharesLocked = schedule.shares.sub(
                    schedule.shares.mul(timestamp.sub(schedule.start)).div(schedule.duration)
                );
            }

            // add to running total
            sharesLocked = sharesLocked.add(currentSharesLocked);
        }

        // convert shares to reward
        // rewardLocked = sharesLocked * rewardBalance / sharesOutstanding
        uint256 rewardLocked = sharesLocked.mul(rewardBalance).div(sharesOutstanding);

        // calculate amount available
        // unlockedRewards = rewardBalance - rewardLocked
        unlockedRewards = rewardBalance.sub(rewardLocked);

        // explicit return
        return unlockedRewards;
    }

    function calculateRewardFromStakes(
        StakeData[] memory stakes,
        uint256 unstakeAmount,
        uint256 unlockedRewards,
        uint256 totalStakeUnits,
        uint256 timestamp,
        RewardScaling memory rewardScaling
    ) public pure override returns (RewardOutput memory out) {
        uint256 stakesToDrop = 0;
        while (unstakeAmount > 0) {
            // fetch vault stake storage reference
            StakeData memory lastStake = stakes[stakes.length.sub(stakesToDrop).sub(1)];

            // calculate stake duration
            uint256 stakeDuration = timestamp.sub(lastStake.timestamp);

            uint256 currentAmount;
            if (lastStake.amount > unstakeAmount) {
                // set current amount to remaining unstake amount
                currentAmount = unstakeAmount;
                // amount of last stake is reduced
                out.lastStakeAmount = lastStake.amount.sub(unstakeAmount);
            } else {
                // set current amount to amount of last stake
                currentAmount = lastStake.amount;
                // add to stakes to drop
                stakesToDrop += 1;
            }

            // update remaining unstakeAmount
            unstakeAmount = unstakeAmount.sub(currentAmount);

            // calculate reward amount
            uint256 currentReward =
                calculateReward(
                    unlockedRewards,
                    currentAmount,
                    stakeDuration,
                    totalStakeUnits,
                    rewardScaling
                );

            // update cumulative reward
            out.reward = out.reward.add(currentReward);

            // update cached unlockedRewards
            unlockedRewards = unlockedRewards.sub(currentReward);

            // calculate time weighted stake
            uint256 stakeUnits = currentAmount.mul(stakeDuration);

            // update cached totalStakeUnits
            totalStakeUnits = totalStakeUnits.sub(stakeUnits);
        }

        // explicit return
        return
            RewardOutput(
                out.lastStakeAmount,
                stakes.length.sub(stakesToDrop),
                out.reward,
                totalStakeUnits
            );
    }

    function calculateReward(
        uint256 unlockedRewards,
        uint256 stakeAmount,
        uint256 stakeDuration,
        uint256 totalStakeUnits,
        RewardScaling memory rewardScaling
    ) public pure override returns (uint256 reward) {
        // calculate time weighted stake
        uint256 stakeUnits = stakeAmount.mul(stakeDuration);

        // calculate base reward
        // baseReward = unlockedRewards * stakeUnits / totalStakeUnits
        uint256 baseReward = 0;
        if (totalStakeUnits != 0) {
            // scale reward according to proportional weight
            baseReward = unlockedRewards.mul(stakeUnits).div(totalStakeUnits);
        }

        // calculate scaled reward
        // if no scaling or scaling period completed
        //   reward = baseReward
        // else
        //   minReward = baseReward * scalingFloor / scalingCeiling
        //   bonusReward = baseReward
        //                 * (scalingCeiling - scalingFloor) / scalingCeiling
        //                 * duration / scalingTime
        //   reward = minReward + bonusReward
        if (stakeDuration >= rewardScaling.time || rewardScaling.floor == rewardScaling.ceiling) {
            // no reward scaling applied
            reward = baseReward;
        } else {
            // calculate minimum reward using scaling floor
            uint256 minReward = baseReward.mul(rewardScaling.floor).div(rewardScaling.ceiling);

            // calculate bonus reward with vested portion of scaling factor
            uint256 bonusReward =
                baseReward
                    .mul(stakeDuration)
                    .mul(rewardScaling.ceiling.sub(rewardScaling.floor))
                    .div(rewardScaling.ceiling)
                    .div(rewardScaling.time);

            // add minimum reward and bonus reward
            reward = minReward.add(bonusReward);
        }

        // explicit return
        return reward;
    }

    /* admin functions */

    /// @notice Add funds to the Hypervisor
    /// access control: only admin
    /// state machine:
    ///   - can be called multiple times
    ///   - only online
    /// state scope:
    ///   - increase _hypervisor.rewardSharesOutstanding
    ///   - append to _hypervisor.rewardSchedules
    /// token transfer: transfer staking tokens from msg.sender to reward pool
    /// @param amount uint256 Amount of reward tokens to deposit
    /// @param duration uint256 Duration over which to linearly unlock rewards
    function fund(uint256 amount, uint256 duration) external onlyOwner onlyOnline {
        // validate duration
        require(duration != 0, ""Hypervisor: invalid duration"");

        // create new reward shares
        // if existing rewards on this Hypervisor
        //   mint new shares proportional to % change in rewards remaining
        //   newShares = remainingShares * newReward / remainingRewards
        // else
        //   mint new shares with BASE_SHARES_PER_WEI initial conversion rate
        //   store as fixed point number with same  of decimals as reward token
        uint256 newRewardShares;
        if (_hypervisor.rewardSharesOutstanding > 0) {
            uint256 remainingRewards = IERC20(_hypervisor.rewardToken).balanceOf(_hypervisor.rewardPool);
            newRewardShares = _hypervisor.rewardSharesOutstanding.mul(amount).div(remainingRewards);
        } else {
            newRewardShares = amount.mul(BASE_SHARES_PER_WEI);
        }

        // add reward shares to total
        _hypervisor.rewardSharesOutstanding = _hypervisor.rewardSharesOutstanding.add(newRewardShares);

        // store new reward schedule
        _hypervisor.rewardSchedules.push(RewardSchedule(duration, block.timestamp, newRewardShares));

        // transfer reward tokens to reward pool
        TransferHelper.safeTransferFrom(
            _hypervisor.rewardToken,
            msg.sender,
            _hypervisor.rewardPool,
            amount
        );

        // emit event
        emit HypervisorFunded(amount, duration);
    }

    /// @notice Add vault factory to whitelist
    /// @dev use this function to enable stakes to vaults coming from the specified
    ///      factory contract
    /// access control: only admin
    /// state machine:
    ///   - can be called multiple times
    ///   - not shutdown
    /// state scope:
    ///   - append to _vaultFactorySet
    /// token transfer: none
    /// @param factory address The address of the vault factory
    function registerVaultFactory(address factory) external onlyOwner notShutdown {
        // add factory to set
        require(_vaultFactorySet.add(factory), ""Hypervisor: vault factory already registered"");

        // emit event
        emit VaultFactoryRegistered(factory);
    }

    /// @notice Remove vault factory from whitelist
    /// @dev use this function to disable new stakes to vaults coming from the specified
    ///      factory contract.
    ///      note: vaults with existing stakes from this factory are sill able to unstake
    /// access control: only admin
    /// state machine:
    ///   - can be called multiple times
    ///   - not shutdown
    /// state scope:
    ///   - remove from _vaultFactorySet
    /// token transfer: none
    /// @param factory address The address of the vault factory
    function removeVaultFactory(address factory) external onlyOwner notShutdown {
        // remove factory from set
        require(_vaultFactorySet.remove(factory), ""Hypervisor: vault factory not registered"");

        // emit event
        emit VaultFactoryRemoved(factory);
    }

    /// @notice Register bonus token for distribution
    /// @dev use this function to enable distribution of any ERC20 held by the RewardPool contract
    /// access control: only admin
    /// state machine:
    ///   - can be called multiple times
    ///   - only online
    /// state scope:
    ///   - append to _bonusTokenSet
    /// token transfer: none
    /// @param bonusToken address The address of the bonus token
    function registerBonusToken(address bonusToken) external onlyOwner onlyOnline {
        // verify valid bonus token
        _validateAddress(bonusToken);

        // verify bonus token count
        require(_bonusTokenSet.length() < MAX_REWARD_TOKENS, ""Hypervisor: max bonus tokens reached "");

        // add token to set
        assert(_bonusTokenSet.add(bonusToken));

        // emit event
        emit BonusTokenRegistered(bonusToken);
    }

    /// @notice Rescue tokens from RewardPool
    /// @dev use this function to rescue tokens from RewardPool contract
    ///      without distributing to stakers or triggering emergency shutdown
    /// access control: only admin
    /// state machine:
    ///   - can be called multiple times
    ///   - only online
    /// state scope: none
    /// token transfer: transfer requested token from RewardPool to recipient
    /// @param token address The address of the token to rescue
    /// @param recipient address The address of the recipient
    /// @param amount uint256 The amount of tokens to rescue
    function rescueTokensFromRewardPool(
        address token,
        address recipient,
        uint256 amount
    ) external onlyOwner onlyOnline {
        // verify recipient
        _validateAddress(recipient);

        // check not attempting to unstake reward token
        require(token != _hypervisor.rewardToken, ""Hypervisor: invalid address"");

        // check not attempting to wthdraw bonus token
        require(!_bonusTokenSet.contains(token), ""Hypervisor: invalid address"");

        // transfer tokens to recipient
        IRewardPool(_hypervisor.rewardPool).sendERC20(token, recipient, amount);
    }

    /* user functions */

    /// @notice Stake tokens
    /// @dev anyone can stake to any vault if they have valid permission
    /// access control: anyone
    /// state machine:
    ///   - can be called multiple times
    ///   - only online
    ///   - when vault exists on this Hypervisor
    /// state scope:
    ///   - append to _vaults[vault].stakes
    ///   - increase _vaults[vault].totalStake
    ///   - increase _hypervisor.totalStake
    ///   - increase _hypervisor.totalStakeUnits
    ///   - increase _hypervisor.lastUpdate
    /// token transfer: transfer staking tokens from msg.sender to vault
    /// @param vault address The address of the vault to stake from
    /// @param amount uint256 The amount of staking tokens to stake
    function stake(
        address vault,
        uint256 amount,
        bytes calldata permission
    ) external override onlyOnline {
        // verify vault is valid
        require(isValidVault(vault), ""Hypervisor: vault is not registered"");

        // verify non-zero amount
        require(amount != 0, ""Hypervisor: no amount staked"");

        // fetch vault storage reference
        VaultData storage vaultData = _vaults[vault];

        // verify stakes boundary not reached
        require(
            vaultData.stakes.length < MAX_STAKES_PER_VAULT,
            ""Hypervisor: MAX_STAKES_PER_VAULT reached""
        );

        // update cached sum of stake units across all vaults
        _updateTotalStakeUnits();

        // store amount and timestamp
        vaultData.stakes.push(StakeData(amount, block.timestamp));

        // update cached total vault and Hypervisor amounts
        vaultData.totalStake = vaultData.totalStake.add(amount);
        // verify stake quantity without bounds
        require(
            stakeLimit == 0 || vaultData.totalStake <= stakeLimit,
            ""Hypervisor: Stake limit exceeded""
        );
        _hypervisor.totalStake = _hypervisor.totalStake.add(amount);

        // call lock on vault
        IUniversalVault(vault).lock(_hypervisor.stakingToken, amount, permission);

        // emit event
        emit Staked(vault, amount);
    }

    /// @notice Unstake staking tokens and claim reward
    /// @dev rewards can only be claimed when unstaking
    /// access control: only owner of vault
    /// state machine:
    ///   - when vault exists on this Hypervisor
    ///   - after stake from vault
    ///   - can be called multiple times while sufficient stake remains
    ///   - only online
    /// state scope:
    ///   - decrease _hypervisor.rewardSharesOutstanding
    ///   - decrease _hypervisor.totalStake
    ///   - increase _hypervisor.lastUpdate
    ///   - modify _hypervisor.totalStakeUnits
    ///   - modify _vaults[vault].stakes
    ///   - decrease _vaults[vault].totalStake
    /// token transfer:
    ///   - transfer reward tokens from reward pool to recipient
    ///   - transfer bonus tokens from reward pool to recipient
    /// @param vault address The vault to unstake from
    /// @param amount uint256 The amount of staking tokens to unstake
    function unstakeAndClaim(
        address vault,
        uint256 amount,
        bytes calldata permission
    ) external override onlyOnline {
        // fetch vault storage reference
        VaultData storage vaultData = _vaults[vault];

        // verify non-zero amount
        require(amount != 0, ""Hypervisor: no amount unstaked"");

        address recipient = IUniversalVault(vault).owner();

        // validate recipient
        _validateAddress(recipient);

        // check for sufficient vault stake amount
        require(vaultData.totalStake >= amount, ""Hypervisor: insufficient vault stake"");

        // check for sufficient Hypervisor stake amount
        // if this check fails, there is a bug in stake accounting
        assert(_hypervisor.totalStake >= amount);

        // update cached sum of stake units across all vaults
        _updateTotalStakeUnits();

        // get reward amount remaining
        uint256 remainingRewards = IERC20(_hypervisor.rewardToken).balanceOf(_hypervisor.rewardPool);

        // calculate vested portion of reward pool
        uint256 unlockedRewards =
            calculateUnlockedRewards(
                _hypervisor.rewardSchedules,
                remainingRewards,
                _hypervisor.rewardSharesOutstanding,
                block.timestamp
            );

        // calculate vault time weighted reward with scaling
        RewardOutput memory out =
            calculateRewardFromStakes(
                vaultData.stakes,
                amount,
                unlockedRewards,
                _hypervisor.totalStakeUnits,
                block.timestamp,
                _hypervisor.rewardScaling
            );

        // update stake data in storage
        if (out.newStakesCount == 0) {
            // all stakes have been unstaked
            delete vaultData.stakes;
        } else {
            // some stakes have been completely or partially unstaked
            // delete fully unstaked stakes
            while (vaultData.stakes.length > out.newStakesCount) vaultData.stakes.pop();
            // update partially unstaked stake
            vaultData.stakes[out.newStakesCount.sub(1)].amount = out.lastStakeAmount;
        }

        // update cached stake totals
        vaultData.totalStake = vaultData.totalStake.sub(amount);
        _hypervisor.totalStake = _hypervisor.totalStake.sub(amount);
        _hypervisor.totalStakeUnits = out.newTotalStakeUnits;

        // unlock staking tokens from vault
        IUniversalVault(vault).unlock(_hypervisor.stakingToken, amount, permission);

        // emit event
        emit Unstaked(vault, amount);

        // only perform on non-zero reward
        if (out.reward > 0) {
            // calculate shares to burn
            // sharesToBurn = sharesOutstanding * reward / remainingRewards
            uint256 sharesToBurn =
                _hypervisor.rewardSharesOutstanding.mul(out.reward).div(remainingRewards);

            // burn claimed shares
            _hypervisor.rewardSharesOutstanding = _hypervisor.rewardSharesOutstanding.sub(sharesToBurn);

            // transfer bonus tokens from reward pool to recipient
            if (_bonusTokenSet.length() > 0) {
                for (uint256 index = 0; index < _bonusTokenSet.length(); index++) {
                    // fetch bonus token address reference
                    address bonusToken = _bonusTokenSet.at(index);

                    // calculate bonus token amount
                    // bonusAmount = bonusRemaining * reward / remainingRewards
                    uint256 bonusAmount =
                        IERC20(bonusToken).balanceOf(_hypervisor.rewardPool).mul(out.reward).div(
                            remainingRewards
                        );

                    // transfer bonus token
                    IRewardPool(_hypervisor.rewardPool).sendERC20(bonusToken, recipient, bonusAmount);

                    // emit event
                    emit RewardClaimed(vault, recipient, bonusToken, bonusAmount);
                }
            }

            // transfer reward tokens from reward pool to recipient
            IRewardPool(_hypervisor.rewardPool).sendERC20(_hypervisor.rewardToken, recipient, out.reward);

            // emit event
            emit RewardClaimed(vault, recipient, _hypervisor.rewardToken, out.reward);
        }
    }

    /// @notice Exit Hypervisor without claiming reward
    /// @dev This function should never revert when correctly called by the vault.
    ///      A max number of stakes per vault is set with MAX_STAKES_PER_VAULT to
    ///      place an upper bound on the for loop in calculateTotalStakeUnits().
    /// access control: only callable by the vault directly
    /// state machine:
    ///   - when vault exists on this Hypervisor
    ///   - when active stake from this vault
    ///   - any power state
    /// state scope:
    ///   - decrease _hypervisor.totalStake
    ///   - increase _hypervisor.lastUpdate
    ///   - modify _hypervisor.totalStakeUnits
    ///   - delete _vaults[vault]
    /// token transfer: none
    function rageQuit() external override {
        // fetch vault storage reference
        VaultData storage _vaultData = _vaults[msg.sender];

        // revert if no active stakes
        require(_vaultData.stakes.length != 0, ""Hypervisor: no stake"");

        // update cached sum of stake units across all vaults
        _updateTotalStakeUnits();

        // emit event
        emit Unstaked(msg.sender, _vaultData.totalStake);

        // update cached totals
        _hypervisor.totalStake = _hypervisor.totalStake.sub(_vaultData.totalStake);
        _hypervisor.totalStakeUnits = _hypervisor.totalStakeUnits.sub(
            calculateTotalStakeUnits(_vaultData.stakes, block.timestamp)
        );

        // delete stake data
        delete _vaults[msg.sender];
    }

    /* convenience functions */

    function _updateTotalStakeUnits() private {
        // update cached totalStakeUnits
        _hypervisor.totalStakeUnits = getCurrentTotalStakeUnits();
        // update cached lastUpdate
        _hypervisor.lastUpdate = block.timestamp;
    }

    function _validateAddress(address target) private view {
        // sanity check target for potential input errors
        require(isValidAddress(target), ""Hypervisor: invalid address"");
    }

    function _truncateStakesArray(StakeData[] memory array, uint256 newLength)
        private
        pure
        returns (StakeData[] memory newArray)
    {
        newArray = new StakeData[](newLength);
        for (uint256 index = 0; index < newLength; index++) {
            newArray[index] = array[index];
        }
        return newArray;
    }
}
"".
Ideas: "" Order of Inheritance Initialization Identified.
```
ORDER OF INHERITANCE INITIALIZATION
'''
The contract `Hypervisor` inherits from two contracts: `Powered` and `Ownable`. In Solidity, the order of constructor execution is determined by the linearized order of inheritance, which may not match the order specified in the derived contract's constructor. This can lead to unexpected behavior if the constructors of the inherited contracts rely on state variables that are initialized in the derived contract's constructor.

In this case, if `Powered` and `Ownable` have their own state variables that are expected to be initialized before the derived contract's constructor logic executes, it could lead to incorrect initialization of those variables. 

To mitigate this issue, ensure that any state variables in the base contracts are initialized properly before they are used in the derived contract. This can be achieved by explicitly calling the constructors of the base contracts in the derived contract's constructor in the"".
As the Security Analyst, your primary objective is to perform a thorough and detailed inspection of the provided contract code, with a particular focus on identifying vulnerabilities related to Impracticality of Exact Match. There are specific cases where the code may have Impracticality of Exact Match vulnerabilities:
1. The use of `this.balance` for checking if the funding goal is reached is flawed. This exact comparison is risky because even a tiny amount above or below the target amount will result in a false value. Moreover, users could manipulate the contract by sending an exact amount to influence the outcome.
2. Relying on an exact balance match for contract logic can lead to unexpected failures or exploitations due to the granularity of ether (wei) and typical transaction handling in Ethereum.
If you identify Impracticality of Exact Match issues, respond with: """,,,,,,"<INFO> Lack of Input Validation Identified.

```
LACK OF INPUT VALIDATION IN STAKE FUNCTION
'''
In the `stake` function, there is a check for a non-zero amount, but there is no validation to ensure that the `vault` address is not a zero address before proceeding with the staking process. This could lead to unexpected behavior if a user attempts to stake to a zero address vault, potentially causing loss of funds or other unintended consequences.

Recommended Mitigation:
Add a validation check at the beginning of the `stake` function to ensure that the `vault` address is not the zero address:
require(vault != address(0), ""Hypervisor: vault address cannot be zero"");
'''

LACK OF INPUT VALIDATION IN UNSTAKEANDCLAIM FUNCTION
'''
In the `unstakeAndClaim` function, while there are checks for non-zero amounts

[2024-02-08 00:46:37 INFO] **[Execute Detail]**

execute SimplePhase:[DoSDetector] in ComposedPhase:[CodeReview], cycle 1

[2024-02-08 00:46:37 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: GPL-3.0-only pragma solidity 0.7.6; pragma abicoder v2; import {SafeMath} from ""@openzeppelin/contracts/math/SafeMath.sol""; import {EnumerableSet} from ""@openzeppelin/contracts/utils/EnumerableSet.sol""; import {IERC20} from ""@openzeppelin/contracts/token/ERC20/IERC20.sol""; import {Ownable} from ""@openzeppelin/contracts/access/Ownable.sol""; import {TransferHelper} from ""@uniswap/lib/contracts/libraries/TransferHelper.sol""; import {IFactory} from ""../factory/IFactory.sol""; import {IInstanceRegistry} from ""../factory/InstanceRegistry.sol""; import {IUniversalVault} from ""../visor/Visor.sol""; import {IRewardPool} from ""./RewardPool.sol""; import {Powered} from ""./Powered.sol""; interface IRageQuit {     function rageQuit() external; } interface IHypervisor is IRageQuit {     / admin events / event HypervisorCreated(address rewardPool, address powerSwitch); event HypervisorFunded(uint256 amount, uint256 duration); event BonusTokenRegistered(address token); event VaultFactoryRegistered(address factory); event VaultFactoryRemoved(address factory);  /* user events */  event Staked(address vault, uint256 amount); event Unstaked(address vault, uint256 amount); event RewardClaimed(address vault, address recipient, address token, uint256 amount);  /* data types */  struct HypervisorData {     address stakingToken;     address rewardToken;     address rewardPool;     RewardScaling rewardScaling;     uint256 rewardSharesOutstanding;     uint256 totalStake;     uint256 totalStakeUnits;     uint256 lastUpdate;     RewardSchedule[] rewardSchedules; }  struct RewardSchedule {     uint256 duration;     uint256 start;     uint256 shares; }  struct VaultData {     uint256 totalStake;     StakeData[] stakes; }  struct StakeData {     uint256 amount;     uint256 timestamp; }  struct RewardScaling {     uint256 floor;     uint256 ceiling;     uint256 time; }  struct RewardOutput {     uint256 lastStakeAmount;     uint256 newStakesCount;     uint256 reward;     uint256 newTotalStakeUnits; }  /* user functions */  function stake(     address vault,     uint256 amount,     bytes calldata permission ) external;  function unstakeAndClaim(     address vault,     uint256 amount,     bytes calldata permission ) external;  /* getter functions */  function getHypervisorData() external view returns (HypervisorData memory hypervisor);  function getBonusTokenSetLength() external view returns (uint256 length);  function getBonusTokenAtIndex(uint256 index) external view returns (address bonusToken);  function getVaultFactorySetLength() external view returns (uint256 length);  function getVaultFactoryAtIndex(uint256 index) external view returns (address factory);  function getVaultData(address vault) external view returns (VaultData memory vaultData);  function isValidAddress(address target) external view returns (bool validity);  function isValidVault(address target) external view returns (bool validity);  function getCurrentUnlockedRewards() external view returns (uint256 unlockedRewards);  function getFutureUnlockedRewards(uint256 timestamp)     external     view     returns (uint256 unlockedRewards);  function getCurrentVaultReward(address vault) external view returns (uint256 reward);  function getCurrentStakeReward(address vault, uint256 stakeAmount)     external     view     returns (uint256 reward);  function getFutureVaultReward(address vault, uint256 timestamp)     external     view     returns (uint256 reward);  function getFutureStakeReward(     address vault,     uint256 stakeAmount,     uint256 timestamp ) external view returns (uint256 reward);  function getCurrentVaultStakeUnits(address vault) external view returns (uint256 stakeUnits);  function getFutureVaultStakeUnits(address vault, uint256 timestamp)     external     view     returns (uint256 stakeUnits);  function getCurrentTotalStakeUnits() external view returns (uint256 totalStakeUnits);  function getFutureTotalStakeUnits(uint256 timestamp)     external     view     returns (uint256 totalStakeUnits);  /* pure functions */  function calculateTotalStakeUnits(StakeData[] memory stakes, uint256 timestamp)     external     pure     returns (uint256 totalStakeUnits);  function calculateStakeUnits(     uint256 amount,     uint256 start,     uint256 end ) external pure returns (uint256 stakeUnits);  function calculateUnlockedRewards(     RewardSchedule[] memory rewardSchedules,     uint256 rewardBalance,     uint256 sharesOutstanding,     uint256 timestamp ) external pure returns (uint256 unlockedRewards);  function calculateRewardFromStakes(     StakeData[] memory stakes,     uint256 unstakeAmount,     uint256 unlockedRewards,     uint256 totalStakeUnits,     uint256 timestamp,     RewardScaling memory rewardScaling ) external pure returns (RewardOutput memory out);  function calculateReward(     uint256 unlockedRewards,     uint256 stakeAmount,     uint256 stakeDuration,     uint256 totalStakeUnits,     RewardScaling memory rewardScaling ) external pure returns (uint256 reward);  } /// @title Hypervisor /// @notice Reward distribution contract with time multiplier /// Access Control /// - Power controller: ///     Can power off / shutdown the Hypervisor ///     Can withdraw rewards from reward pool once shutdown /// - Proxy owner: ///     Can change arbitrary logic / state by upgrading the Hypervisor ///     Is unable to operate on user funds due to UniversalVault ///     Is unable to operate on reward pool funds when reward pool is offline / shutdown /// - Hypervisor admin: ///     Can add funds to the Hypervisor, register bonus tokens, and whitelist new vault factories ///     Is a subset of proxy owner permissions /// - User: ///     Can deposit / withdraw / ragequit /// Hypervisor State Machine /// - Online: ///     Hypervisor is operating normally, all functions are enabled /// - Offline: ///     Hypervisor is temporarely disabled for maintenance ///     User deposits and withdrawls are disabled, ragequit remains enabled ///     Users can withdraw their stake through rageQuit() but forego their pending reward ///     Should only be used when downtime required for an upgrade /// - Shutdown: ///     Hypervisor is permanently disabled ///     All functions are disabled with the exception of ragequit ///     Users can withdraw their stake through rageQuit() ///     Power controller can withdraw from the reward pool ///     Should only be used if Proxy Owner role is compromized contract Hypervisor is IHypervisor, Powered, Ownable {     using SafeMath for uint256;     using EnumerableSet for EnumerableSet.AddressSet; /* constants */  // An upper bound on the number of active stakes per vault is required to prevent // calls to rageQuit() from reverting. // With 30 stakes in a vault, ragequit costs 432811 gas which is conservatively lower // than the hardcoded limit of 500k gas on the vault. // This limit is configurable and could be increased in a future deployment. // Ultimately, to avoid a need for fixed upper bounds, the EVM would need to provide // an error code that allows for reliably catching out-of-gas errors on remote calls. uint256 public constant MAX_STAKES_PER_VAULT = 30; uint256 public constant MAX_REWARD_TOKENS = 50; uint256 public constant BASE_SHARES_PER_WEI = 1000000; uint256 public stakeLimit = 2500 ether;  /* storage */  HypervisorData private _hypervisor; mapping(address =&gt; VaultData) private _vaults; EnumerableSet.AddressSet private _bonusTokenSet; EnumerableSet.AddressSet private _vaultFactorySet;  /* initializer */  /// @notice Initizalize Hypervisor /// access control: only proxy constructor /// state machine: can only be called once /// state scope: set initialization variables /// token transfer: none /// @param ownerAddress address The admin address /// @param rewardPoolFactory address The factory to use for deploying the RewardPool /// @param powerSwitchFactory address The factory to use for deploying the PowerSwitch /// @param stakingToken address The address of the staking token for this Hypervisor /// @param rewardToken address The address of the reward token for this Hypervisor /// @param rewardScaling RewardScaling The config for reward scaling floor, ceiling, and time constructor(     address ownerAddress,     address rewardPoolFactory,     address powerSwitchFactory,     address stakingToken,     address rewardToken,     RewardScaling memory rewardScaling,     uint256 _stakeLimit ) {     // the scaling floor must be smaller than ceiling     require(rewardScaling.floor &lt;= rewardScaling.ceiling, ""Hypervisor: floor above ceiling"");      // setting rewardScalingTime to 0 would cause divide by zero error     // to disable reward scaling, use rewardScalingFloor == rewardScalingCeiling     require(rewardScaling.time != 0, ""Hypervisor: scaling time cannot be zero"");      // deploy power switch     address powerSwitch = IFactory(powerSwitchFactory).create(abi.encode(ownerAddress));      // deploy reward pool     address rewardPool = IFactory(rewardPoolFactory).create(abi.encode(powerSwitch));      // set internal configs     Ownable.transferOwnership(ownerAddress);     Powered._setPowerSwitch(powerSwitch);      // commit to storage     _hypervisor.stakingToken = stakingToken;     _hypervisor.rewardToken = rewardToken;     _hypervisor.rewardPool = rewardPool;     _hypervisor.rewardScaling = rewardScaling;      stakeLimit = _stakeLimit;      // emit event     emit HypervisorCreated(rewardPool, powerSwitch); }  /* getter functions */  function getBonusTokenSetLength() external view override returns (uint256 length) {     return _bonusTokenSet.length(); }  function getBonusTokenAtIndex(uint256 index)     external     view     override     returns (address bonusToken) {     return _bonusTokenSet.at(index); }  function getVaultFactorySetLength() external view override returns (uint256 length) {     return _vaultFactorySet.length(); }  function getVaultFactoryAtIndex(uint256 index)     external     view     override     returns (address factory) {     return _vaultFactorySet.at(index); }  function isValidVault(address target) public view override returns (bool validity) {     // validate target is created from whitelisted vault factory     for (uint256 index = 0; index &lt; _vaultFactorySet.length(); index++) {         if (IInstanceRegistry(_vaultFactorySet.at(index)).isInstance(target)) {             return true;         }     }     // explicit return     return false; }  function isValidAddress(address target) public view override returns (bool validity) {     // sanity check target for potential input errors     return         target != address(this) &amp;&amp;         target != address(0) &amp;&amp;         target != _hypervisor.stakingToken &amp;&amp;         target != _hypervisor.rewardToken &amp;&amp;         target != _hypervisor.rewardPool &amp;&amp;         !_bonusTokenSet.contains(target); }  /* Hypervisor getters */  function getHypervisorData() external view override returns (HypervisorData memory hypervisor) {     return _hypervisor; }  function getCurrentUnlockedRewards() public view override returns (uint256 unlockedRewards) {     // calculate reward available based on state     return getFutureUnlockedRewards(block.timestamp); }  function getFutureUnlockedRewards(uint256 timestamp)     public     view     override     returns (uint256 unlockedRewards) {     // get reward amount remaining     uint256 remainingRewards = IERC20(_hypervisor.rewardToken).balanceOf(_hypervisor.rewardPool);     // calculate reward available based on state     unlockedRewards = calculateUnlockedRewards(         _hypervisor.rewardSchedules,         remainingRewards,         _hypervisor.rewardSharesOutstanding,         timestamp     );     // explicit return     return unlockedRewards; }  function getCurrentTotalStakeUnits() public view override returns (uint256 totalStakeUnits) {     // calculate new stake units     return getFutureTotalStakeUnits(block.timestamp); }  function getFutureTotalStakeUnits(uint256 timestamp)     public     view     override     returns (uint256 totalStakeUnits) {     // return early if no change     if (timestamp == _hypervisor.lastUpdate) return _hypervisor.totalStakeUnits;     // calculate new stake units     uint256 newStakeUnits =         calculateStakeUnits(_hypervisor.totalStake, _hypervisor.lastUpdate, timestamp);     // add to cached total     totalStakeUnits = _hypervisor.totalStakeUnits.add(newStakeUnits);     // explicit return     return totalStakeUnits; }  /* vault getters */  function getVaultData(address vault)     external     view     override     returns (VaultData memory vaultData) {     return _vaults[vault]; }  function getCurrentVaultReward(address vault) external view override returns (uint256 reward) {     // calculate rewards     return         calculateRewardFromStakes(             _vaults[vault]                 .stakes,             _vaults[vault]                 .totalStake,             getCurrentUnlockedRewards(),             getCurrentTotalStakeUnits(),             block                 .timestamp,             _hypervisor                 .rewardScaling         )             .reward; }  function getFutureVaultReward(address vault, uint256 timestamp)     external     view     override     returns (uint256 reward) {     // calculate rewards     return         calculateRewardFromStakes(             _vaults[vault]                 .stakes,             _vaults[vault]                 .totalStake,             getFutureUnlockedRewards(timestamp),             getFutureTotalStakeUnits(timestamp),             timestamp,             _hypervisor                 .rewardScaling         )             .reward; }  function getCurrentStakeReward(address vault, uint256 stakeAmount)     external     view     override     returns (uint256 reward) {     // calculate rewards     return         calculateRewardFromStakes(             _vaults[vault]                 .stakes,             stakeAmount,             getCurrentUnlockedRewards(),             getCurrentTotalStakeUnits(),             block                 .timestamp,             _hypervisor                 .rewardScaling         )             .reward; }  function getFutureStakeReward(     address vault,     uint256 stakeAmount,     uint256 timestamp ) external view override returns (uint256 reward) {     // calculate rewards     return         calculateRewardFromStakes(             _vaults[vault]                 .stakes,             stakeAmount,             getFutureUnlockedRewards(timestamp),             getFutureTotalStakeUnits(timestamp),             timestamp,             _hypervisor                 .rewardScaling         )             .reward; }  function getCurrentVaultStakeUnits(address vault)     public     view     override     returns (uint256 stakeUnits) {     // calculate stake units     return getFutureVaultStakeUnits(vault, block.timestamp); }  function getFutureVaultStakeUnits(address vault, uint256 timestamp)     public     view     override     returns (uint256 stakeUnits) {     // calculate stake units     return calculateTotalStakeUnits(_vaults[vault].stakes, timestamp); }  /* pure functions */  function calculateTotalStakeUnits(StakeData[] memory stakes, uint256 timestamp)     public     pure     override     returns (uint256 totalStakeUnits) {     for (uint256 index; index &lt; stakes.length; index++) {         // reference stake         StakeData memory stakeData = stakes[index];         // calculate stake units         uint256 stakeUnits =             calculateStakeUnits(stakeData.amount, stakeData.timestamp, timestamp);         // add to running total         totalStakeUnits = totalStakeUnits.add(stakeUnits);     } }  function calculateStakeUnits(     uint256 amount,     uint256 start,     uint256 end ) public pure override returns (uint256 stakeUnits) {     // calculate duration     uint256 duration = end.sub(start);     // calculate stake units     stakeUnits = duration.mul(amount);     // explicit return     return stakeUnits; }  function calculateUnlockedRewards(     RewardSchedule[] memory rewardSchedules,     uint256 rewardBalance,     uint256 sharesOutstanding,     uint256 timestamp ) public pure override returns (uint256 unlockedRewards) {     // return 0 if no registered schedules     if (rewardSchedules.length == 0) {         return 0;     }      // calculate reward shares locked across all reward schedules     uint256 sharesLocked;     for (uint256 index = 0; index &lt; rewardSchedules.length; index++) {         // fetch reward schedule storage reference         RewardSchedule memory schedule = rewardSchedules[index];          // caculate amount of shares available on this schedule         // if (now - start) &lt; duration         //   sharesLocked = shares - (shares * (now - start) / duration)         // else         //   sharesLocked = 0         uint256 currentSharesLocked = 0;         if (timestamp.sub(schedule.start) &lt; schedule.duration) {             currentSharesLocked = schedule.shares.sub(                 schedule.shares.mul(timestamp.sub(schedule.start)).div(schedule.duration)             );         }          // add to running total         sharesLocked = sharesLocked.add(currentSharesLocked);     }      // convert shares to reward     // rewardLocked = sharesLocked * rewardBalance / sharesOutstanding     uint256 rewardLocked = sharesLocked.mul(rewardBalance).div(sharesOutstanding);      // calculate amount available     // unlockedRewards = rewardBalance - rewardLocked     unlockedRewards = rewardBalance.sub(rewardLocked);      // explicit return     return unlockedRewards; }  function calculateRewardFromStakes(     StakeData[] memory stakes,     uint256 unstakeAmount,     uint256 unlockedRewards,     uint256 totalStakeUnits,     uint256 timestamp,     RewardScaling memory rewardScaling ) public pure override returns (RewardOutput memory out) {     uint256 stakesToDrop = 0;     while (unstakeAmount &gt; 0) {         // fetch vault stake storage reference         StakeData memory lastStake = stakes[stakes.length.sub(stakesToDrop).sub(1)];          // calculate stake duration         uint256 stakeDuration = timestamp.sub(lastStake.timestamp);          uint256 currentAmount;         if (lastStake.amount &gt; unstakeAmount) {             // set current amount to remaining unstake amount             currentAmount = unstakeAmount;             // amount of last stake is reduced             out.lastStakeAmount = lastStake.amount.sub(unstakeAmount);         } else {             // set current amount to amount of last stake             currentAmount = lastStake.amount;             // add to stakes to drop             stakesToDrop += 1;         }          // update remaining unstakeAmount         unstakeAmount = unstakeAmount.sub(currentAmount);          // calculate reward amount         uint256 currentReward =             calculateReward(                 unlockedRewards,                 currentAmount,                 stakeDuration,                 totalStakeUnits,                 rewardScaling             );          // update cumulative reward         out.reward = out.reward.add(currentReward);          // update cached unlockedRewards         unlockedRewards = unlockedRewards.sub(currentReward);          // calculate time weighted stake         uint256 stakeUnits = currentAmount.mul(stakeDuration);          // update cached totalStakeUnits         totalStakeUnits = totalStakeUnits.sub(stakeUnits);     }      // explicit return     return         RewardOutput(             out.lastStakeAmount,             stakes.length.sub(stakesToDrop),             out.reward,             totalStakeUnits         ); }  function calculateReward(     uint256 unlockedRewards,     uint256 stakeAmount,     uint256 stakeDuration,     uint256 totalStakeUnits,     RewardScaling memory rewardScaling ) public pure override returns (uint256 reward) {     // calculate time weighted stake     uint256 stakeUnits = stakeAmount.mul(stakeDuration);      // calculate base reward     // baseReward = unlockedRewards * stakeUnits / totalStakeUnits     uint256 baseReward = 0;     if (totalStakeUnits != 0) {         // scale reward according to proportional weight         baseReward = unlockedRewards.mul(stakeUnits).div(totalStakeUnits);     }      // calculate scaled reward     // if no scaling or scaling period completed     //   reward = baseReward     // else     //   minReward = baseReward * scalingFloor / scalingCeiling     //   bonusReward = baseReward     //                 * (scalingCeiling - scalingFloor) / scalingCeiling     //                 * duration / scalingTime     //   reward = minReward + bonusReward     if (stakeDuration &gt;= rewardScaling.time || rewardScaling.floor == rewardScaling.ceiling) {         // no reward scaling applied         reward = baseReward;     } else {         // calculate minimum reward using scaling floor         uint256 minReward = baseReward.mul(rewardScaling.floor).div(rewardScaling.ceiling);          // calculate bonus reward with vested portion of scaling factor         uint256 bonusReward =             baseReward                 .mul(stakeDuration)                 .mul(rewardScaling.ceiling.sub(rewardScaling.floor))                 .div(rewardScaling.ceiling)                 .div(rewardScaling.time);          // add minimum reward and bonus reward         reward = minReward.add(bonusReward);     }      // explicit return     return reward; }  /* admin functions */  /// @notice Add funds to the Hypervisor /// access control: only admin /// state machine: ///   - can be called multiple times ///   - only online /// state scope: ///   - increase _hypervisor.rewardSharesOutstanding ///   - append to _hypervisor.rewardSchedules /// token transfer: transfer staking tokens from msg.sender to reward pool /// @param amount uint256 Amount of reward tokens to deposit /// @param duration uint256 Duration over which to linearly unlock rewards function fund(uint256 amount, uint256 duration) external onlyOwner onlyOnline {     // validate duration     require(duration != 0, ""Hypervisor: invalid duration"");      // create new reward shares     // if existing rewards on this Hypervisor     //   mint new shares proportional to % change in rewards remaining     //   newShares = remainingShares * newReward / remainingRewards     // else     //   mint new shares with BASE_SHARES_PER_WEI initial conversion rate     //   store as fixed point number with same  of decimals as reward token     uint256 newRewardShares;     if (_hypervisor.rewardSharesOutstanding &gt; 0) {         uint256 remainingRewards = IERC20(_hypervisor.rewardToken).balanceOf(_hypervisor.rewardPool);         newRewardShares = _hypervisor.rewardSharesOutstanding.mul(amount).div(remainingRewards);     } else {         newRewardShares = amount.mul(BASE_SHARES_PER_WEI);     }      // add reward shares to total     _hypervisor.rewardSharesOutstanding = _hypervisor.rewardSharesOutstanding.add(newRewardShares);      // store new reward schedule     _hypervisor.rewardSchedules.push(RewardSchedule(duration, block.timestamp, newRewardShares));      // transfer reward tokens to reward pool     TransferHelper.safeTransferFrom(         _hypervisor.rewardToken,         msg.sender,         _hypervisor.rewardPool,         amount     );      // emit event     emit HypervisorFunded(amount, duration); }  /// @notice Add vault factory to whitelist /// @dev use this function to enable stakes to vaults coming from the specified ///      factory contract /// access control: only admin /// state machine: ///   - can be called multiple times ///   - not shutdown /// state scope: ///   - append to _vaultFactorySet /// token transfer: none /// @param factory address The address of the vault factory function registerVaultFactory(address factory) external onlyOwner notShutdown {     // add factory to set     require(_vaultFactorySet.add(factory), ""Hypervisor: vault factory already registered"");      // emit event     emit VaultFactoryRegistered(factory); }  /// @notice Remove vault factory from whitelist /// @dev use this function to disable new stakes to vaults coming from the specified ///      factory contract. ///      note: vaults with existing stakes from this factory are sill able to unstake /// access control: only admin /// state machine: ///   - can be called multiple times ///   - not shutdown /// state scope: ///   - remove from _vaultFactorySet /// token transfer: none /// @param factory address The address of the vault factory function removeVaultFactory(address factory) external onlyOwner notShutdown {     // remove factory from set     require(_vaultFactorySet.remove(factory), ""Hypervisor: vault factory not registered"");      // emit event     emit VaultFactoryRemoved(factory); }  /// @notice Register bonus token for distribution /// @dev use this function to enable distribution of any ERC20 held by the RewardPool contract /// access control: only admin /// state machine: ///   - can be called multiple times ///   - only online /// state scope: ///   - append to _bonusTokenSet /// token transfer: none /// @param bonusToken address The address of the bonus token function registerBonusToken(address bonusToken) external onlyOwner onlyOnline {     // verify valid bonus token     _validateAddress(bonusToken);      // verify bonus token count     require(_bonusTokenSet.length() &lt; MAX_REWARD_TOKENS, ""Hypervisor: max bonus tokens reached "");      // add token to set     assert(_bonusTokenSet.add(bonusToken));      // emit event     emit BonusTokenRegistered(bonusToken); }  /// @notice Rescue tokens from RewardPool /// @dev use this function to rescue tokens from RewardPool contract ///      without distributing to stakers or triggering emergency shutdown /// access control: only admin /// state machine: ///   - can be called multiple times ///   - only online /// state scope: none /// token transfer: transfer requested token from RewardPool to recipient /// @param token address The address of the token to rescue /// @param recipient address The address of the recipient /// @param amount uint256 The amount of tokens to rescue function rescueTokensFromRewardPool(     address token,     address recipient,     uint256 amount ) external onlyOwner onlyOnline {     // verify recipient     _validateAddress(recipient);      // check not attempting to unstake reward token     require(token != _hypervisor.rewardToken, ""Hypervisor: invalid address"");      // check not attempting to wthdraw bonus token     require(!_bonusTokenSet.contains(token), ""Hypervisor: invalid address"");      // transfer tokens to recipient     IRewardPool(_hypervisor.rewardPool).sendERC20(token, recipient, amount); }  /* user functions */  /// @notice Stake tokens /// @dev anyone can stake to any vault if they have valid permission /// access control: anyone /// state machine: ///   - can be called multiple times ///   - only online ///   - when vault exists on this Hypervisor /// state scope: ///   - append to _vaults[vault].stakes ///   - increase _vaults[vault].totalStake ///   - increase _hypervisor.totalStake ///   - increase _hypervisor.totalStakeUnits ///   - increase _hypervisor.lastUpdate /// token transfer: transfer staking tokens from msg.sender to vault /// @param vault address The address of the vault to stake from /// @param amount uint256 The amount of staking tokens to stake function stake(     address vault,     uint256 amount,     bytes calldata permission ) external override onlyOnline {     // verify vault is valid     require(isValidVault(vault), ""Hypervisor: vault is not registered"");      // verify non-zero amount     require(amount != 0, ""Hypervisor: no amount staked"");      // fetch vault storage reference     VaultData storage vaultData = _vaults[vault];      // verify stakes boundary not reached     require(         vaultData.stakes.length &lt; MAX_STAKES_PER_VAULT,         ""Hypervisor: MAX_STAKES_PER_VAULT reached""     );      // update cached sum of stake units across all vaults     _updateTotalStakeUnits();      // store amount and timestamp     vaultData.stakes.push(StakeData(amount, block.timestamp));      // update cached total vault and Hypervisor amounts     vaultData.totalStake = vaultData.totalStake.add(amount);     // verify stake quantity without bounds     require(         stakeLimit == 0 || vaultData.totalStake &lt;= stakeLimit,         ""Hypervisor: Stake limit exceeded""     );     _hypervisor.totalStake = _hypervisor.totalStake.add(amount);      // call lock on vault     IUniversalVault(vault).lock(_hypervisor.stakingToken, amount, permission);      // emit event     emit Staked(vault, amount); }  /// @notice Unstake staking tokens and claim reward /// @dev rewards can only be claimed when unstaking /// access control: only owner of vault /// state machine: ///   - when vault exists on this Hypervisor ///   - after stake from vault ///   - can be called multiple times while sufficient stake remains ///   - only online /// state scope: ///   - decrease _hypervisor.rewardSharesOutstanding ///   - decrease _hypervisor.totalStake ///   - increase _hypervisor.lastUpdate ///   - modify _hypervisor.totalStakeUnits ///   - modify _vaults[vault].stakes ///   - decrease _vaults[vault].totalStake /// token transfer: ///   - transfer reward tokens from reward pool to recipient ///   - transfer bonus tokens from reward pool to recipient /// @param vault address The vault to unstake from /// @param amount uint256 The amount of staking tokens to unstake function unstakeAndClaim(     address vault,     uint256 amount,     bytes calldata permission ) external override onlyOnline {     // fetch vault storage reference     VaultData storage vaultData = _vaults[vault];      // verify non-zero amount     require(amount != 0, ""Hypervisor: no amount unstaked"");      address recipient = IUniversalVault(vault).owner();      // validate recipient     _validateAddress(recipient);      // check for sufficient vault stake amount     require(vaultData.totalStake &gt;= amount, ""Hypervisor: insufficient vault stake"");      // check for sufficient Hypervisor stake amount     // if this check fails, there is a bug in stake accounting     assert(_hypervisor.totalStake &gt;= amount);      // update cached sum of stake units across all vaults     _updateTotalStakeUnits();      // get reward amount remaining     uint256 remainingRewards = IERC20(_hypervisor.rewardToken).balanceOf(_hypervisor.rewardPool);      // calculate vested portion of reward pool     uint256 unlockedRewards =         calculateUnlockedRewards(             _hypervisor.rewardSchedules,             remainingRewards,             _hypervisor.rewardSharesOutstanding,             block.timestamp         );      // calculate vault time weighted reward with scaling     RewardOutput memory out =         calculateRewardFromStakes(             vaultData.stakes,             amount,             unlockedRewards,             _hypervisor.totalStakeUnits,             block.timestamp,             _hypervisor.rewardScaling         );      // update stake data in storage     if (out.newStakesCount == 0) {         // all stakes have been unstaked         delete vaultData.stakes;     } else {         // some stakes have been completely or partially unstaked         // delete fully unstaked stakes         while (vaultData.stakes.length &gt; out.newStakesCount) vaultData.stakes.pop();         // update partially unstaked stake         vaultData.stakes[out.newStakesCount.sub(1)].amount = out.lastStakeAmount;     }      // update cached stake totals     vaultData.totalStake = vaultData.totalStake.sub(amount);     _hypervisor.totalStake = _hypervisor.totalStake.sub(amount);     _hypervisor.totalStakeUnits = out.newTotalStakeUnits;      // unlock staking tokens from vault     IUniversalVault(vault).unlock(_hypervisor.stakingToken, amount, permission);      // emit event     emit Unstaked(vault, amount);      // only perform on non-zero reward     if (out.reward &gt; 0) {         // calculate shares to burn         // sharesToBurn = sharesOutstanding * reward / remainingRewards         uint256 sharesToBurn =             _hypervisor.rewardSharesOutstanding.mul(out.reward).div(remainingRewards);          // burn claimed shares         _hypervisor.rewardSharesOutstanding = _hypervisor.rewardSharesOutstanding.sub(sharesToBurn);          // transfer bonus tokens from reward pool to recipient         if (_bonusTokenSet.length() &gt; 0) {             for (uint256 index = 0; index &lt; _bonusTokenSet.length(); index++) {                 // fetch bonus token address reference                 address bonusToken = _bonusTokenSet.at(index);                  // calculate bonus token amount                 // bonusAmount = bonusRemaining * reward / remainingRewards                 uint256 bonusAmount =                     IERC20(bonusToken).balanceOf(_hypervisor.rewardPool).mul(out.reward).div(                         remainingRewards                     );                  // transfer bonus token                 IRewardPool(_hypervisor.rewardPool).sendERC20(bonusToken, recipient, bonusAmount);                  // emit event                 emit RewardClaimed(vault, recipient, bonusToken, bonusAmount);             }         }          // transfer reward tokens from reward pool to recipient         IRewardPool(_hypervisor.rewardPool).sendERC20(_hypervisor.rewardToken, recipient, out.reward);          // emit event         emit RewardClaimed(vault, recipient, _hypervisor.rewardToken, out.reward);     } }  /// @notice Exit Hypervisor without claiming reward /// @dev This function should never revert when correctly called by the vault. ///      A max number of stakes per vault is set with MAX_STAKES_PER_VAULT to ///      place an upper bound on the for loop in calculateTotalStakeUnits(). /// access control: only callable by the vault directly /// state machine: ///   - when vault exists on this Hypervisor ///   - when active stake from this vault ///   - any power state /// state scope: ///   - decrease _hypervisor.totalStake ///   - increase _hypervisor.lastUpdate ///   - modify _hypervisor.totalStakeUnits ///   - delete _vaults[vault] /// token transfer: none function rageQuit() external override {     // fetch vault storage reference     VaultData storage _vaultData = _vaults[msg.sender];      // revert if no active stakes     require(_vaultData.stakes.length != 0, ""Hypervisor: no stake"");      // update cached sum of stake units across all vaults     _updateTotalStakeUnits();      // emit event     emit Unstaked(msg.sender, _vaultData.totalStake);      // update cached totals     _hypervisor.totalStake = _hypervisor.totalStake.sub(_vaultData.totalStake);     _hypervisor.totalStakeUnits = _hypervisor.totalStakeUnits.sub(         calculateTotalStakeUnits(_vaultData.stakes, block.timestamp)     );      // delete stake data     delete _vaults[msg.sender]; }  /* convenience functions */  function _updateTotalStakeUnits() private {     // update cached totalStakeUnits     _hypervisor.totalStakeUnits = getCurrentTotalStakeUnits();     // update cached lastUpdate     _hypervisor.lastUpdate = block.timestamp; }  function _validateAddress(address target) private view {     // sanity check target for potential input errors     require(isValidAddress(target), ""Hypervisor: invalid address""); }  function _truncateStakesArray(StakeData[] memory array, uint256 newLength)     private     pure     returns (StakeData[] memory newArray) {     newArray = new StakeData[](newLength);     for (uint256 index = 0; index &lt; newLength; index++) {         newArray[index] = array[index];     }     return newArray; }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: ""Identify all potential DoS (Denial of Service) vulnerabilities in the provided Solidity smart contract."". Ideas: ""DoS vulnerabilities can manifest in various forms in Solidity contracts, such as Gas Limit DoS, External Call DoS, Block Gas Limit DoS, and State Dependency DoS."". As the {assistant_role}, your primary objective is to conduct a comprehensive inspection of the provided contract code, with a particular focus on identifying vulnerabilities related to Denial of Service (DoS). DoS vulnerabilities can occur in the following cases: 1. When loops have an unbounded iteration count, leading to potential gas exhaustion. 2. When the contract makes external calls that can fail or consume excessive gas. 3. When the contract depends on certain state conditions that can be manipulated by an attacker to cause failures. 4. When an attacker can send high-gas transactions to consume most of the block's gas limit, making it difficult for other transactions to be included in the block. Please conduct a thorough analysis, considering the following information: 1. Review the contract's code logic to identify any potential areas where unbounded loops might cause gas exhaustion. 2. Examine external calls in the contract and ensure they are handled properly to avoid excessive gas consumption or failures. 3. Analyze state-dependent logic to identify any potential manipulations that could cause DoS. 4. Consider the overall design of the contract to ensure it is resilient against high-gas transactions and other DoS tactics. If you identify any DoS vulnerabilities, respond with: "" DoS Vulnerability Identified."" For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE ''' DETAILED DESCRIPTION of the vulnerability, along with recommended mitigation measures or fixes that do not require code upgrades. ''' If you don't find any vulnerabilities, respond only with: "" No DoS Vulnerabilities."" |
| **phase_name** | DoSDetector |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 1, 'modification_conclusion': '', 'cycle_index': 1, 'task': '// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport {SafeMath} from ""@openzeppelin/contracts/math/SafeMath.sol"";\nimport {EnumerableSet} from ""@openzeppelin/contracts/utils/EnumerableSet.sol"";\nimport {IERC20} from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";\nimport {Ownable} from ""@openzeppelin/contracts/access/Ownable.sol"";\nimport {TransferHelper} from ""@uniswap/lib/contracts/libraries/TransferHelper.sol"";\n\nimport {IFactory} from ""../factory/IFactory.sol"";\nimport {IInstanceRegistry} from ""../factory/InstanceRegistry.sol"";\nimport {IUniversalVault} from ""../visor/Visor.sol"";\nimport {IRewardPool} from ""./RewardPool.sol"";\nimport {Powered} from ""./Powered.sol"";\n\ninterface IRageQuit {\n    function rageQuit() external;\n}\n\ninterface IHypervisor is IRageQuit {\n    / admin events /\n\n    event HypervisorCreated(address rewardPool, address powerSwitch);\n    event HypervisorFunded(uint256 amount, uint256 duration);\n    event BonusTokenRegistered(address token);\n    event VaultFactoryRegistered(address factory);\n    event VaultFactoryRemoved(address factory);\n\n    / user events /\n\n    event Staked(address vault, uint256 amount);\n    event Unstaked(address vault, uint256 amount);\n    event RewardClaimed(address vault, address recipient, address token, uint256 amount);\n\n    / data types /\n\n    struct HypervisorData {\n        address stakingToken;\n        address rewardToken;\n        address rewardPool;\n        RewardScaling rewardScaling;\n        uint256 rewardSharesOutstanding;\n        uint256 totalStake;\n        uint256 totalStakeUnits;\n        uint256 lastUpdate;\n        RewardSchedule[] rewardSchedules;\n    }\n\n    struct RewardSchedule {\n        uint256 duration;\n        uint256 start;\n        uint256 shares;\n    }\n\n    struct VaultData {\n        uint256 totalStake;\n        StakeData[] stakes;\n    }\n\n    struct StakeData {\n        uint256 amount;\n        uint256 timestamp;\n    }\n\n    struct RewardScaling {\n        uint256 floor;\n        uint256 ceiling;\n        uint256 time;\n    }\n\n    struct RewardOutput {\n        uint256 lastStakeAmount;\n        uint256 newStakesCount;\n        uint256 reward;\n        uint256 newTotalStakeUnits;\n    }\n\n    / user functions /\n\n    function stake(\n        address vault,\n        uint256 amount,\n        bytes calldata permission\n    ) external;\n\n    function unstakeAndClaim(\n        address vault,\n        uint256 amount,\n        bytes calldata permission\n    ) external;\n\n    / getter functions /\n\n    function getHypervisorData() external view returns (HypervisorData memory hypervisor);\n\n    function getBonusTokenSetLength() external view returns (uint256 length);\n\n    function getBonusTokenAtIndex(uint256 index) external view returns (address bonusToken);\n\n    function getVaultFactorySetLength() external view returns (uint256 length);\n\n    function getVaultFactoryAtIndex(uint256 index) external view returns (address factory);\n\n    function getVaultData(address vault) external view returns (VaultData memory vaultData);\n\n    function isValidAddress(address target) external view returns (bool validity);\n\n    function isValidVault(address target) external view returns (bool validity);\n\n    function getCurrentUnlockedRewards() external view returns (uint256 unlockedRewards);\n\n    function getFutureUnlockedRewards(uint256 timestamp)\n        external\n        view\n        returns (uint256 unlockedRewards);\n\n    function getCurrentVaultReward(address vault) external view returns (uint256 reward);\n\n    function getCurrentStakeReward(address vault, uint256 stakeAmount)\n        external\n        view\n        returns (uint256 reward);\n\n    function getFutureVaultReward(address vault, uint256 timestamp)\n        external\n        view\n        returns (uint256 reward);\n\n    function getFutureStakeReward(\n        address vault,\n        uint256 stakeAmount,\n        uint256 timestamp\n    ) external view returns (uint256 reward);\n\n    function getCurrentVaultStakeUnits(address vault) external view returns (uint256 stakeUnits);\n\n    function getFutureVaultStakeUnits(address vault, uint256 timestamp)\n        external\n        view\n        returns (uint256 stakeUnits);\n\n    function getCurrentTotalStakeUnits() external view returns (uint256 totalStakeUnits);\n\n    function getFutureTotalStakeUnits(uint256 timestamp)\n        external\n        view\n        returns (uint256 totalStakeUnits);\n\n    / pure functions /\n\n    function calculateTotalStakeUnits(StakeData[] memory stakes, uint256 timestamp)\n        external\n        pure\n        returns (uint256 totalStakeUnits);\n\n    function calculateStakeUnits(\n        uint256 amount,\n        uint256 start,\n        uint256 end\n    ) external pure returns (uint256 stakeUnits);\n\n    function calculateUnlockedRewards(\n        RewardSchedule[] memory rewardSchedules,\n        uint256 rewardBalance,\n        uint256 sharesOutstanding,\n        uint256 timestamp\n    ) external pure returns (uint256 unlockedRewards);\n\n    function calculateRewardFromStakes(\n        StakeData[] memory stakes,\n        uint256 unstakeAmount,\n        uint256 unlockedRewards,\n        uint256 totalStakeUnits,\n        uint256 timestamp,\n        RewardScaling memory rewardScaling\n    ) external pure returns (RewardOutput memory out);\n\n    function calculateReward(\n        uint256 unlockedRewards,\n        uint256 stakeAmount,\n        uint256 stakeDuration,\n        uint256 totalStakeUnits,\n        RewardScaling memory rewardScaling\n    ) external pure returns (uint256 reward);\n}\n\n/// @title Hypervisor\n/// @notice Reward distribution contract with time multiplier\n/// Access Control\n/// - Power controller:\n///     Can power off / shutdown the Hypervisor\n///     Can withdraw rewards from reward pool once shutdown\n/// - Proxy owner:\n///     Can change arbitrary logic / state by upgrading the Hypervisor\n///     Is unable to operate on user funds due to UniversalVault\n///     Is unable to operate on reward pool funds when reward pool is offline / shutdown\n/// - Hypervisor admin:\n///     Can add funds to the Hypervisor, register bonus tokens, and whitelist new vault factories\n///     Is a subset of proxy owner permissions\n/// - User:\n///     Can deposit / withdraw / ragequit\n/// Hypervisor State Machine\n/// - Online:\n///     Hypervisor is operating normally, all functions are enabled\n/// - Offline:\n///     Hypervisor is temporarely disabled for maintenance\n///     User deposits and withdrawls are disabled, ragequit remains enabled\n///     Users can withdraw their stake through rageQuit() but forego their pending reward\n///     Should only be used when downtime required for an upgrade\n/// - Shutdown:\n///     Hypervisor is permanently disabled\n///     All functions are disabled with the exception of ragequit\n///     Users can withdraw their stake through rageQuit()\n///     Power controller can withdraw from the reward pool\n///     Should only be used if Proxy Owner role is compromized\ncontract Hypervisor is IHypervisor, Powered, Ownable {\n    using SafeMath for uint256;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    / constants /\n\n    // An upper bound on the number of active stakes per vault is required to prevent\n    // calls to rageQuit() from reverting.\n    // With 30 stakes in a vault, ragequit costs 432811 gas which is conservatively lower\n    // than the hardcoded limit of 500k gas on the vault.\n    // This limit is configurable and could be increased in a future deployment.\n    // Ultimately, to avoid a need for fixed upper bounds, the EVM would need to provide\n    // an error code that allows for reliably catching out-of-gas errors on remote calls.\n    uint256 public constant MAX_STAKES_PER_VAULT = 30;\n    uint256 public constant MAX_REWARD_TOKENS = 50;\n    uint256 public constant BASE_SHARES_PER_WEI = 1000000;\n    uint256 public stakeLimit = 2500 ether;\n\n    / storage /\n\n    HypervisorData private _hypervisor;\n    mapping(address =&gt; VaultData) private _vaults;\n    EnumerableSet.AddressSet private _bonusTokenSet;\n    EnumerableSet.AddressSet private _vaultFactorySet;\n\n    / initializer /\n\n    /// @notice Initizalize Hypervisor\n    /// access control: only proxy constructor\n    /// state machine: can only be called once\n    /// state scope: set initialization variables\n    /// token transfer: none\n    /// @param ownerAddress address The admin address\n    /// @param rewardPoolFactory address The factory to use for deploying the RewardPool\n    /// @param powerSwitchFactory address The factory to use for deploying the PowerSwitch\n    /// @param stakingToken address The address of the staking token for this Hypervisor\n    /// @param rewardToken address The address of the reward token for this Hypervisor\n    /// @param rewardScaling RewardScaling The config for reward scaling floor, ceiling, and time\n    constructor(\n        address ownerAddress,\n        address rewardPoolFactory,\n        address powerSwitchFactory,\n        address stakingToken,\n        address rewardToken,\n        RewardScaling memory rewardScaling,\n        uint256 _stakeLimit\n    ) {\n        // the scaling floor must be smaller than ceiling\n        require(rewardScaling.floor &lt;= rewardScaling.ceiling, ""Hypervisor: floor above ceiling"");\n\n        // setting rewardScalingTime to 0 would cause divide by zero error\n        // to disable reward scaling, use rewardScalingFloor == rewardScalingCeiling\n        require(rewardScaling.time != 0, ""Hypervisor: scaling time cannot be zero"");\n\n        // deploy power switch\n        address powerSwitch = IFactory(powerSwitchFactory).create(abi.encode(ownerAddress));\n\n        // deploy reward pool\n        address rewardPool = IFactory(rewardPoolFactory).create(abi.encode(powerSwitch));\n\n        // set internal configs\n        Ownable.transferOwnership(ownerAddress);\n        Powered._setPowerSwitch(powerSwitch);\n\n        // commit to storage\n        _hypervisor.stakingToken = stakingToken;\n        _hypervisor.rewardToken = rewardToken;\n        _hypervisor.rewardPool = rewardPool;\n        _hypervisor.rewardScaling = rewardScaling;\n\n        stakeLimit = _stakeLimit;\n\n        // emit event\n        emit HypervisorCreated(rewardPool, powerSwitch);\n    }\n\n    / getter functions /\n\n    function getBonusTokenSetLength() external view override returns (uint256 length) {\n        return _bonusTokenSet.length();\n    }\n\n    function getBonusTokenAtIndex(uint256 index)\n        external\n        view\n        override\n        returns (address bonusToken)\n    {\n        return _bonusTokenSet.at(index);\n    }\n\n    function getVaultFactorySetLength() external view override returns (uint256 length) {\n        return _vaultFactorySet.length();\n    }\n\n    function getVaultFactoryAtIndex(uint256 index)\n        external\n        view\n        override\n        returns (address factory)\n    {\n        return _vaultFactorySet.at(index);\n    }\n\n    function isValidVault(address target) public view override returns (bool validity) {\n        // validate target is created from whitelisted vault factory\n        for (uint256 index = 0; index &lt; _vaultFactorySet.length(); index++) {\n            if (IInstanceRegistry(_vaultFactorySet.at(index)).isInstance(target)) {\n                return true;\n            }\n        }\n        // explicit return\n        return false;\n    }\n\n    function isValidAddress(address target) public view override returns (bool validity) {\n        // sanity check target for potential input errors\n        return\n            target != address(this) &amp;&amp;\n            target != address(0) &amp;&amp;\n            target != _hypervisor.stakingToken &amp;&amp;\n            target != _hypervisor.rewardToken &amp;&amp;\n            target != _hypervisor.rewardPool &amp;&amp;\n            !_bonusTokenSet.contains(target);\n    }\n\n    / Hypervisor getters /\n\n    function getHypervisorData() external view override returns (HypervisorData memory hypervisor) {\n        return _hypervisor;\n    }\n\n    function getCurrentUnlockedRewards() public view override returns (uint256 unlockedRewards) {\n        // calculate reward available based on state\n        return getFutureUnlockedRewards(block.timestamp);\n    }\n\n    function getFutureUnlockedRewards(uint256 timestamp)\n        public\n        view\n        override\n        returns (uint256 unlockedRewards)\n    {\n        // get reward amount remaining\n        uint256 remainingRewards = IERC20(_hypervisor.rewardToken).balanceOf(_hypervisor.rewardPool);\n        // calculate reward available based on state\n        unlockedRewards = calculateUnlockedRewards(\n            _hypervisor.rewardSchedules,\n            remainingRewards,\n            _hypervisor.rewardSharesOutstanding,\n            timestamp\n        );\n        // explicit return\n        return unlockedRewards;\n    }\n\n    function getCurrentTotalStakeUnits() public view override returns (uint256 totalStakeUnits) {\n        // calculate new stake units\n        return getFutureTotalStakeUnits(block.timestamp);\n    }\n\n    function getFutureTotalStakeUnits(uint256 timestamp)\n        public\n        view\n        override\n        returns (uint256 totalStakeUnits)\n    {\n        // return early if no change\n        if (timestamp == _hypervisor.lastUpdate) return _hypervisor.totalStakeUnits;\n        // calculate new stake units\n        uint256 newStakeUnits =\n            calculateStakeUnits(_hypervisor.totalStake, _hypervisor.lastUpdate, timestamp);\n        // add to cached total\n        totalStakeUnits = _hypervisor.totalStakeUnits.add(newStakeUnits);\n        // explicit return\n        return totalStakeUnits;\n    }\n\n    / vault getters /\n\n    function getVaultData(address vault)\n        external\n        view\n        override\n        returns (VaultData memory vaultData)\n    {\n        return _vaults[vault];\n    }\n\n    function getCurrentVaultReward(address vault) external view override returns (uint256 reward) {\n        // calculate rewards\n        return\n            calculateRewardFromStakes(\n                _vaults[vault]\n                    .stakes,\n                _vaults[vault]\n                    .totalStake,\n                getCurrentUnlockedRewards(),\n                getCurrentTotalStakeUnits(),\n                block\n                    .timestamp,\n                _hypervisor\n                    .rewardScaling\n            )\n                .reward;\n    }\n\n    function getFutureVaultReward(address vault, uint256 timestamp)\n        external\n        view\n        override\n        returns (uint256 reward)\n    {\n        // calculate rewards\n        return\n            calculateRewardFromStakes(\n                _vaults[vault]\n                    .stakes,\n                _vaults[vault]\n                    .totalStake,\n                getFutureUnlockedRewards(timestamp),\n                getFutureTotalStakeUnits(timestamp),\n                timestamp,\n                _hypervisor\n                    .rewardScaling\n            )\n                .reward;\n    }\n\n    function getCurrentStakeReward(address vault, uint256 stakeAmount)\n        external\n        view\n        override\n        returns (uint256 reward)\n    {\n        // calculate rewards\n        return\n            calculateRewardFromStakes(\n                _vaults[vault]\n                    .stakes,\n                stakeAmount,\n                getCurrentUnlockedRewards(),\n                getCurrentTotalStakeUnits(),\n                block\n                    .timestamp,\n                _hypervisor\n                    .rewardScaling\n            )\n                .reward;\n    }\n\n    function getFutureStakeReward(\n        address vault,\n        uint256 stakeAmount,\n        uint256 timestamp\n    ) external view override returns (uint256 reward) {\n        // calculate rewards\n        return\n            calculateRewardFromStakes(\n                _vaults[vault]\n                    .stakes,\n                stakeAmount,\n                getFutureUnlockedRewards(timestamp),\n                getFutureTotalStakeUnits(timestamp),\n                timestamp,\n                _hypervisor\n                    .rewardScaling\n            )\n                .reward;\n    }\n\n    function getCurrentVaultStakeUnits(address vault)\n        public\n        view\n        override\n        returns (uint256 stakeUnits)\n    {\n        // calculate stake units\n        return getFutureVaultStakeUnits(vault, block.timestamp);\n    }\n\n    function getFutureVaultStakeUnits(address vault, uint256 timestamp)\n        public\n        view\n        override\n        returns (uint256 stakeUnits)\n    {\n        // calculate stake units\n        return calculateTotalStakeUnits(_vaults[vault].stakes, timestamp);\n    }\n\n    / pure functions /\n\n    function calculateTotalStakeUnits(StakeData[] memory stakes, uint256 timestamp)\n        public\n        pure\n        override\n        returns (uint256 totalStakeUnits)\n    {\n        for (uint256 index; index &lt; stakes.length; index++) {\n            // reference stake\n            StakeData memory stakeData = stakes[index];\n            // calculate stake units\n            uint256 stakeUnits =\n                calculateStakeUnits(stakeData.amount, stakeData.timestamp, timestamp);\n            // add to running total\n            totalStakeUnits = totalStakeUnits.add(stakeUnits);\n        }\n    }\n\n    function calculateStakeUnits(\n        uint256 amount,\n        uint256 start,\n        uint256 end\n    ) public pure override returns (uint256 stakeUnits) {\n        // calculate duration\n        uint256 duration = end.sub(start);\n        // calculate stake units\n        stakeUnits = duration.mul(amount);\n        // explicit return\n        return stakeUnits;\n    }\n\n    function calculateUnlockedRewards(\n        RewardSchedule[] memory rewardSchedules,\n        uint256 rewardBalance,\n        uint256 sharesOutstanding,\n        uint256 timestamp\n    ) public pure override returns (uint256 unlockedRewards) {\n        // return 0 if no registered schedules\n        if (rewardSchedules.length == 0) {\n            return 0;\n        }\n\n        // calculate reward shares locked across all reward schedules\n        uint256 sharesLocked;\n        for (uint256 index = 0; index &lt; rewardSchedules.length; index++) {\n            // fetch reward schedule storage reference\n            RewardSchedule memory schedule = rewardSchedules[index];\n\n            // caculate amount of shares available on this schedule\n            // if (now - start) &lt; duration\n            //   sharesLocked = shares - (shares * (now - start) / duration)\n            // else\n            //   sharesLocked = 0\n            uint256 currentSharesLocked = 0;\n            if (timestamp.sub(schedule.start) &lt; schedule.duration) {\n                currentSharesLocked = schedule.shares.sub(\n                    schedule.shares.mul(timestamp.sub(schedule.start)).div(schedule.duration)\n                );\n            }\n\n            // add to running total\n            sharesLocked = sharesLocked.add(currentSharesLocked);\n        }\n\n        // convert shares to reward\n        // rewardLocked = sharesLocked * rewardBalance / sharesOutstanding\n        uint256 rewardLocked = sharesLocked.mul(rewardBalance).div(sharesOutstanding);\n\n        // calculate amount available\n        // unlockedRewards = rewardBalance - rewardLocked\n        unlockedRewards = rewardBalance.sub(rewardLocked);\n\n        // explicit return\n        return unlockedRewards;\n    }\n\n    function calculateRewardFromStakes(\n        StakeData[] memory stakes,\n        uint256 unstakeAmount,\n        uint256 unlockedRewards,\n        uint256 totalStakeUnits,\n        uint256 timestamp,\n        RewardScaling memory rewardScaling\n    ) public pure override returns (RewardOutput memory out) {\n        uint256 stakesToDrop = 0;\n        while (unstakeAmount &gt; 0) {\n            // fetch vault stake storage reference\n            StakeData memory lastStake = stakes[stakes.length.sub(stakesToDrop).sub(1)];\n\n            // calculate stake duration\n            uint256 stakeDuration = timestamp.sub(lastStake.timestamp);\n\n            uint256 currentAmount;\n            if (lastStake.amount &gt; unstakeAmount) {\n                // set current amount to remaining unstake amount\n                currentAmount = unstakeAmount;\n                // amount of last stake is reduced\n                out.lastStakeAmount = lastStake.amount.sub(unstakeAmount);\n            } else {\n                // set current amount to amount of last stake\n                currentAmount = lastStake.amount;\n                // add to stakes to drop\n                stakesToDrop += 1;\n            }\n\n            // update remaining unstakeAmount\n            unstakeAmount = unstakeAmount.sub(currentAmount);\n\n            // calculate reward amount\n            uint256 currentReward =\n                calculateReward(\n                    unlockedRewards,\n                    currentAmount,\n                    stakeDuration,\n                    totalStakeUnits,\n                    rewardScaling\n                );\n\n            // update cumulative reward\n            out.reward = out.reward.add(currentReward);\n\n            // update cached unlockedRewards\n            unlockedRewards = unlockedRewards.sub(currentReward);\n\n            // calculate time weighted stake\n            uint256 stakeUnits = currentAmount.mul(stakeDuration);\n\n            // update cached totalStakeUnits\n            totalStakeUnits = totalStakeUnits.sub(stakeUnits);\n        }\n\n        // explicit return\n        return\n            RewardOutput(\n                out.lastStakeAmount,\n                stakes.length.sub(stakesToDrop),\n                out.reward,\n                totalStakeUnits\n            );\n    }\n\n    function calculateReward(\n        uint256 unlockedRewards,\n        uint256 stakeAmount,\n        uint256 stakeDuration,\n        uint256 totalStakeUnits,\n        RewardScaling memory rewardScaling\n    ) public pure override returns (uint256 reward) {\n        // calculate time weighted stake\n        uint256 stakeUnits = stakeAmount.mul(stakeDuration);\n\n        // calculate base reward\n        // baseReward = unlockedRewards * stakeUnits / totalStakeUnits\n        uint256 baseReward = 0;\n        if (totalStakeUnits != 0) {\n            // scale reward according to proportional weight\n            baseReward = unlockedRewards.mul(stakeUnits).div(totalStakeUnits);\n        }\n\n        // calculate scaled reward\n        // if no scaling or scaling period completed\n        //   reward = baseReward\n        // else\n        //   minReward = baseReward * scalingFloor / scalingCeiling\n        //   bonusReward = baseReward\n        //                 * (scalingCeiling - scalingFloor) / scalingCeiling\n        //                 * duration / scalingTime\n        //   reward = minReward + bonusReward\n        if (stakeDuration &gt;= rewardScaling.time || rewardScaling.floor == rewardScaling.ceiling) {\n            // no reward scaling applied\n            reward = baseReward;\n        } else {\n            // calculate minimum reward using scaling floor\n            uint256 minReward = baseReward.mul(rewardScaling.floor).div(rewardScaling.ceiling);\n\n            // calculate bonus reward with vested portion of scaling factor\n            uint256 bonusReward =\n                baseReward\n                    .mul(stakeDuration)\n                    .mul(rewardScaling.ceiling.sub(rewardScaling.floor))\n                    .div(rewardScaling.ceiling)\n                    .div(rewardScaling.time);\n\n            // add minimum reward and bonus reward\n            reward = minReward.add(bonusReward);\n        }\n\n        // explicit return\n        return reward;\n    }\n\n    / admin functions /\n\n    /// @notice Add funds to the Hypervisor\n    /// access control: only admin\n    /// state machine:\n    ///   - can be called multiple times\n    ///   - only online\n    /// state scope:\n    ///   - increase _hypervisor.rewardSharesOutstanding\n    ///   - append to _hypervisor.rewardSchedules\n    /// token transfer: transfer staking tokens from msg.sender to reward pool\n    /// @param amount uint256 Amount of reward tokens to deposit\n    /// @param duration uint256 Duration over which to linearly unlock rewards\n    function fund(uint256 amount, uint256 duration) external onlyOwner onlyOnline {\n        // validate duration\n        require(duration != 0, ""Hypervisor: invalid duration"");\n\n        // create new reward shares\n        // if existing rewards on this Hypervisor\n        //   mint new shares proportional to % change in rewards remaining\n        //   newShares = remainingShares * newReward / remainingRewards\n        // else\n        //   mint new shares with BASE_SHARES_PER_WEI initial conversion rate\n        //   store as fixed point number with same  of decimals as reward token\n        uint256 newRewardShares;\n        if (_hypervisor.rewardSharesOutstanding &gt; 0) {\n            uint256 remainingRewards = IERC20(_hypervisor.rewardToken).balanceOf(_hypervisor.rewardPool);\n            newRewardShares = _hypervisor.rewardSharesOutstanding.mul(amount).div(remainingRewards);\n        } else {\n            newRewardShares = amount.mul(BASE_SHARES_PER_WEI);\n        }\n\n        // add reward shares to total\n        _hypervisor.rewardSharesOutstanding = _hypervisor.rewardSharesOutstanding.add(newRewardShares);\n\n        // store new reward schedule\n        _hypervisor.rewardSchedules.push(RewardSchedule(duration, block.timestamp, newRewardShares));\n\n        // transfer reward tokens to reward pool\n        TransferHelper.safeTransferFrom(\n            _hypervisor.rewardToken,\n            msg.sender,\n            _hypervisor.rewardPool,\n            amount\n        );\n\n        // emit event\n        emit HypervisorFunded(amount, duration);\n    }\n\n    /// @notice Add vault factory to whitelist\n    /// @dev use this function to enable stakes to vaults coming from the specified\n    ///      factory contract\n    /// access control: only admin\n    /// state machine:\n    ///   - can be called multiple times\n    ///   - not shutdown\n    /// state scope:\n    ///   - append to _vaultFactorySet\n    /// token transfer: none\n    /// @param factory address The address of the vault factory\n    function registerVaultFactory(address factory) external onlyOwner notShutdown {\n        // add factory to set\n        require(_vaultFactorySet.add(factory), ""Hypervisor: vault factory already registered"");\n\n        // emit event\n        emit VaultFactoryRegistered(factory);\n    }\n\n    /// @notice Remove vault factory from whitelist\n    /// @dev use this function to disable new stakes to vaults coming from the specified\n    ///      factory contract.\n    ///      note: vaults with existing stakes from this factory are sill able to unstake\n    /// access control: only admin\n    /// state machine:\n    ///   - can be called multiple times\n    ///   - not shutdown\n    /// state scope:\n    ///   - remove from _vaultFactorySet\n    /// token transfer: none\n    /// @param factory address The address of the vault factory\n    function removeVaultFactory(address factory) external onlyOwner notShutdown {\n        // remove factory from set\n        require(_vaultFactorySet.remove(factory), ""Hypervisor: vault factory not registered"");\n\n        // emit event\n        emit VaultFactoryRemoved(factory);\n    }\n\n    /// @notice Register bonus token for distribution\n    /// @dev use this function to enable distribution of any ERC20 held by the RewardPool contract\n    /// access control: only admin\n    /// state machine:\n    ///   - can be called multiple times\n    ///   - only online\n    /// state scope:\n    ///   - append to _bonusTokenSet\n    /// token transfer: none\n    /// @param bonusToken address The address of the bonus token\n    function registerBonusToken(address bonusToken) external onlyOwner onlyOnline {\n        // verify valid bonus token\n        _validateAddress(bonusToken);\n\n        // verify bonus token count\n        require(_bonusTokenSet.length() &lt; MAX_REWARD_TOKENS, ""Hypervisor: max bonus tokens reached "");\n\n        // add token to set\n        assert(_bonusTokenSet.add(bonusToken));\n\n        // emit event\n        emit BonusTokenRegistered(bonusToken);\n    }\n\n    /// @notice Rescue tokens from RewardPool\n    /// @dev use this function to rescue tokens from RewardPool contract\n    ///      without distributing to stakers or triggering emergency shutdown\n    /// access control: only admin\n    /// state machine:\n    ///   - can be called multiple times\n    ///   - only online\n    /// state scope: none\n    /// token transfer: transfer requested token from RewardPool to recipient\n    /// @param token address The address of the token to rescue\n    /// @param recipient address The address of the recipient\n    /// @param amount uint256 The amount of tokens to rescue\n    function rescueTokensFromRewardPool(\n        address token,\n        address recipient,\n        uint256 amount\n    ) external onlyOwner onlyOnline {\n        // verify recipient\n        _validateAddress(recipient);\n\n        // check not attempting to unstake reward token\n        require(token != _hypervisor.rewardToken, ""Hypervisor: invalid address"");\n\n        // check not attempting to wthdraw bonus token\n        require(!_bonusTokenSet.contains(token), ""Hypervisor: invalid address"");\n\n        // transfer tokens to recipient\n        IRewardPool(_hypervisor.rewardPool).sendERC20(token, recipient, amount);\n    }\n\n    / user functions /\n\n    /// @notice Stake tokens\n    /// @dev anyone can stake to any vault if they have valid permission\n    /// access control: anyone\n    /// state machine:\n    ///   - can be called multiple times\n    ///   - only online\n    ///   - when vault exists on this Hypervisor\n    /// state scope:\n    ///   - append to _vaults[vault].stakes\n    ///   - increase _vaults[vault].totalStake\n    ///   - increase _hypervisor.totalStake\n    ///   - increase _hypervisor.totalStakeUnits\n    ///   - increase _hypervisor.lastUpdate\n    /// token transfer: transfer staking tokens from msg.sender to vault\n    /// @param vault address The address of the vault to stake from\n    /// @param amount uint256 The amount of staking tokens to stake\n    function stake(\n        address vault,\n        uint256 amount,\n        bytes calldata permission\n    ) external override onlyOnline {\n        // verify vault is valid\n        require(isValidVault(vault), ""Hypervisor: vault is not registered"");\n\n        // verify non-zero amount\n        require(amount != 0, ""Hypervisor: no amount staked"");\n\n        // fetch vault storage reference\n        VaultData storage vaultData = _vaults[vault];\n\n        // verify stakes boundary not reached\n        require(\n            vaultData.stakes.length &lt; MAX_STAKES_PER_VAULT,\n            ""Hypervisor: MAX_STAKES_PER_VAULT reached""\n        );\n\n        // update cached sum of stake units across all vaults\n        _updateTotalStakeUnits();\n\n        // store amount and timestamp\n        vaultData.stakes.push(StakeData(amount, block.timestamp));\n\n        // update cached total vault and Hypervisor amounts\n        vaultData.totalStake = vaultData.totalStake.add(amount);\n        // verify stake quantity without bounds\n        require(\n            stakeLimit == 0 || vaultData.totalStake &lt;= stakeLimit,\n            ""Hypervisor: Stake limit exceeded""\n        );\n        _hypervisor.totalStake = _hypervisor.totalStake.add(amount);\n\n        // call lock on vault\n        IUniversalVault(vault).lock(_hypervisor.stakingToken, amount, permission);\n\n        // emit event\n        emit Staked(vault, amount);\n    }\n\n    /// @notice Unstake staking tokens and claim reward\n    /// @dev rewards can only be claimed when unstaking\n    /// access control: only owner of vault\n    /// state machine:\n    ///   - when vault exists on this Hypervisor\n    ///   - after stake from vault\n    ///   - can be called multiple times while sufficient stake remains\n    ///   - only online\n    /// state scope:\n    ///   - decrease _hypervisor.rewardSharesOutstanding\n    ///   - decrease _hypervisor.totalStake\n    ///   - increase _hypervisor.lastUpdate\n    ///   - modify _hypervisor.totalStakeUnits\n    ///   - modify _vaults[vault].stakes\n    ///   - decrease _vaults[vault].totalStake\n    /// token transfer:\n    ///   - transfer reward tokens from reward pool to recipient\n    ///   - transfer bonus tokens from reward pool to recipient\n    /// @param vault address The vault to unstake from\n    /// @param amount uint256 The amount of staking tokens to unstake\n    function unstakeAndClaim(\n        address vault,\n        uint256 amount,\n        bytes calldata permission\n    ) external override onlyOnline {\n        // fetch vault storage reference\n        VaultData storage vaultData = _vaults[vault];\n\n        // verify non-zero amount\n        require(amount != 0, ""Hypervisor: no amount unstaked"");\n\n        address recipient = IUniversalVault(vault).owner();\n\n        // validate recipient\n        _validateAddress(recipient);\n\n        // check for sufficient vault stake amount\n        require(vaultData.totalStake &gt;= amount, ""Hypervisor: insufficient vault stake"");\n\n        // check for sufficient Hypervisor stake amount\n        // if this check fails, there is a bug in stake accounting\n        assert(_hypervisor.totalStake &gt;= amount);\n\n        // update cached sum of stake units across all vaults\n        _updateTotalStakeUnits();\n\n        // get reward amount remaining\n        uint256 remainingRewards = IERC20(_hypervisor.rewardToken).balanceOf(_hypervisor.rewardPool);\n\n        // calculate vested portion of reward pool\n        uint256 unlockedRewards =\n            calculateUnlockedRewards(\n                _hypervisor.rewardSchedules,\n                remainingRewards,\n                _hypervisor.rewardSharesOutstanding,\n                block.timestamp\n            );\n\n        // calculate vault time weighted reward with scaling\n        RewardOutput memory out =\n            calculateRewardFromStakes(\n                vaultData.stakes,\n                amount,\n                unlockedRewards,\n                _hypervisor.totalStakeUnits,\n                block.timestamp,\n                _hypervisor.rewardScaling\n            );\n\n        // update stake data in storage\n        if (out.newStakesCount == 0) {\n            // all stakes have been unstaked\n            delete vaultData.stakes;\n        } else {\n            // some stakes have been completely or partially unstaked\n            // delete fully unstaked stakes\n            while (vaultData.stakes.length &gt; out.newStakesCount) vaultData.stakes.pop();\n            // update partially unstaked stake\n            vaultData.stakes[out.newStakesCount.sub(1)].amount = out.lastStakeAmount;\n        }\n\n        // update cached stake totals\n        vaultData.totalStake = vaultData.totalStake.sub(amount);\n        _hypervisor.totalStake = _hypervisor.totalStake.sub(amount);\n        _hypervisor.totalStakeUnits = out.newTotalStakeUnits;\n\n        // unlock staking tokens from vault\n        IUniversalVault(vault).unlock(_hypervisor.stakingToken, amount, permission);\n\n        // emit event\n        emit Unstaked(vault, amount);\n\n        // only perform on non-zero reward\n        if (out.reward &gt; 0) {\n            // calculate shares to burn\n            // sharesToBurn = sharesOutstanding * reward / remainingRewards\n            uint256 sharesToBurn =\n                _hypervisor.rewardSharesOutstanding.mul(out.reward).div(remainingRewards);\n\n            // burn claimed shares\n            _hypervisor.rewardSharesOutstanding = _hypervisor.rewardSharesOutstanding.sub(sharesToBurn);\n\n            // transfer bonus tokens from reward pool to recipient\n            if (_bonusTokenSet.length() &gt; 0) {\n                for (uint256 index = 0; index &lt; _bonusTokenSet.length(); index++) {\n                    // fetch bonus token address reference\n                    address bonusToken = _bonusTokenSet.at(index);\n\n                    // calculate bonus token amount\n                    // bonusAmount = bonusRemaining * reward / remainingRewards\n                    uint256 bonusAmount =\n                        IERC20(bonusToken).balanceOf(_hypervisor.rewardPool).mul(out.reward).div(\n                            remainingRewards\n                        );\n\n                    // transfer bonus token\n                    IRewardPool(_hypervisor.rewardPool).sendERC20(bonusToken, recipient, bonusAmount);\n\n                    // emit event\n                    emit RewardClaimed(vault, recipient, bonusToken, bonusAmount);\n                }\n            }\n\n            // transfer reward tokens from reward pool to recipient\n            IRewardPool(_hypervisor.rewardPool).sendERC20(_hypervisor.rewardToken, recipient, out.reward);\n\n            // emit event\n            emit RewardClaimed(vault, recipient, _hypervisor.rewardToken, out.reward);\n        }\n    }\n\n    /// @notice Exit Hypervisor without claiming reward\n    /// @dev This function should never revert when correctly called by the vault.\n    ///      A max number of stakes per vault is set with MAX_STAKES_PER_VAULT to\n    ///      place an upper bound on the for loop in calculateTotalStakeUnits().\n    /// access control: only callable by the vault directly\n    /// state machine:\n    ///   - when vault exists on this Hypervisor\n    ///   - when active stake from this vault\n    ///   - any power state\n    /// state scope:\n    ///   - decrease _hypervisor.totalStake\n    ///   - increase _hypervisor.lastUpdate\n    ///   - modify _hypervisor.totalStakeUnits\n    ///   - delete _vaults[vault]\n    /// token transfer: none\n    function rageQuit() external override {\n        // fetch vault storage reference\n        VaultData storage _vaultData = _vaults[msg.sender];\n\n        // revert if no active stakes\n        require(_vaultData.stakes.length != 0, ""Hypervisor: no stake"");\n\n        // update cached sum of stake units across all vaults\n        _updateTotalStakeUnits();\n\n        // emit event\n        emit Unstaked(msg.sender, _vaultData.totalStake);\n\n        // update cached totals\n        _hypervisor.totalStake = _hypervisor.totalStake.sub(_vaultData.totalStake);\n        _hypervisor.totalStakeUnits = _hypervisor.totalStakeUnits.sub(\n            calculateTotalStakeUnits(_vaultData.stakes, block.timestamp)\n        );\n\n        // delete stake data\n        delete _vaults[msg.sender];\n    }\n\n    / convenience functions /\n\n    function _updateTotalStakeUnits() private {\n        // update cached totalStakeUnits\n        _hypervisor.totalStakeUnits = getCurrentTotalStakeUnits();\n        // update cached lastUpdate\n        _hypervisor.lastUpdate = block.timestamp;\n    }\n\n    function _validateAddress(address target) private view {\n        // sanity check target for potential input errors\n        require(isValidAddress(target), ""Hypervisor: invalid address"");\n    }\n\n    function _truncateStakesArray(StakeData[] memory array, uint256 newLength)\n        private\n        pure\n        returns (StakeData[] memory newArray)\n    {\n        newArray = new StakeData;\n        for (uint256 index = 0; index &lt; newLength; index++) {\n            newArray[index] = array[index];\n        }\n        return newArray;\n    }\n}\n', 'ideas': ' Lack of Input Validation Identified.\n\n``\nLACK OF INPUT VALIDATION IN STAKE FUNCTION\n\'\'\'\nIn thestakefunction, there is a check for a non-zero amount, but there is no validation to ensure that thevaultaddress is not a zero address before proceeding with the staking process. This could lead to unexpected behavior if a user attempts to stake to a zero address vault, potentially causing loss of funds or other unintended consequences.\n\nRecommended Mitigation:\nAdd a validation check at the beginning of thestakefunction to ensure that thevaultaddress is not the zero address:\nrequire(vault != address(0), ""Hypervisor: vault address cannot be zero"");\n\'\'\'\n\nLACK OF INPUT VALIDATION IN UNSTAKEANDCLAIM FUNCTION\n\'\'\'\nIn theunstakeAndClaim` function, while there are checks for non-zero amounts'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-02-08 00:46:37 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs. |
| **task_prompt** | // SPDX-License-Identifier: GPL-3.0-only pragma solidity 0.7.6; pragma abicoder v2; import {SafeMath} from ""@openzeppelin/contracts/math/SafeMath.sol""; import {EnumerableSet} from ""@openzeppelin/contracts/utils/EnumerableSet.sol""; import {IERC20} from ""@openzeppelin/contracts/token/ERC20/IERC20.sol""; import {Ownable} from ""@openzeppelin/contracts/access/Ownable.sol""; import {TransferHelper} from ""@uniswap/lib/contracts/libraries/TransferHelper.sol""; import {IFactory} from ""../factory/IFactory.sol""; import {IInstanceRegistry} from ""../factory/InstanceRegistry.sol""; import {IUniversalVault} from ""../visor/Visor.sol""; import {IRewardPool} from ""./RewardPool.sol""; import {Powered} from ""./Powered.sol""; interface IRageQuit {     function rageQuit() external; } interface IHypervisor is IRageQuit {     / admin events / event HypervisorCreated(address rewardPool, address powerSwitch); event HypervisorFunded(uint256 amount, uint256 duration); event BonusTokenRegistered(address token); event VaultFactoryRegistered(address factory); event VaultFactoryRemoved(address factory);  /* user events */  event Staked(address vault, uint256 amount); event Unstaked(address vault, uint256 amount); event RewardClaimed(address vault, address recipient, address token, uint256 amount);  /* data types */  struct HypervisorData {     address stakingToken;     address rewardToken;     address rewardPool;     RewardScaling rewardScaling;     uint256 rewardSharesOutstanding;     uint256 totalStake;     uint256 totalStakeUnits;     uint256 lastUpdate;     RewardSchedule[] rewardSchedules; }  struct RewardSchedule {     uint256 duration;     uint256 start;     uint256 shares; }  struct VaultData {     uint256 totalStake;     StakeData[] stakes; }  struct StakeData {     uint256 amount;     uint256 timestamp; }  struct RewardScaling {     uint256 floor;     uint256 ceiling;     uint256 time; }  struct RewardOutput {     uint256 lastStakeAmount;     uint256 newStakesCount;     uint256 reward;     uint256 newTotalStakeUnits; }  /* user functions */  function stake(     address vault,     uint256 amount,     bytes calldata permission ) external;  function unstakeAndClaim(     address vault,     uint256 amount,     bytes calldata permission ) external;  /* getter functions */  function getHypervisorData() external view returns (HypervisorData memory hypervisor);  function getBonusTokenSetLength() external view returns (uint256 length);  function getBonusTokenAtIndex(uint256 index) external view returns (address bonusToken);  function getVaultFactorySetLength() external view returns (uint256 length);  function getVaultFactoryAtIndex(uint256 index) external view returns (address factory);  function getVaultData(address vault) external view returns (VaultData memory vaultData);  function isValidAddress(address target) external view returns (bool validity);  function isValidVault(address target) external view returns (bool validity);  function getCurrentUnlockedRewards() external view returns (uint256 unlockedRewards);  function getFutureUnlockedRewards(uint256 timestamp)     external     view     returns (uint256 unlockedRewards);  function getCurrentVaultReward(address vault) external view returns (uint256 reward);  function getCurrentStakeReward(address vault, uint256 stakeAmount)     external     view     returns (uint256 reward);  function getFutureVaultReward(address vault, uint256 timestamp)     external     view     returns (uint256 reward);  function getFutureStakeReward(     address vault,     uint256 stakeAmount,     uint256 timestamp ) external view returns (uint256 reward);  function getCurrentVaultStakeUnits(address vault) external view returns (uint256 stakeUnits);  function getFutureVaultStakeUnits(address vault, uint256 timestamp)     external     view     returns (uint256 stakeUnits);  function getCurrentTotalStakeUnits() external view returns (uint256 totalStakeUnits);  function getFutureTotalStakeUnits(uint256 timestamp)     external     view     returns (uint256 totalStakeUnits);  /* pure functions */  function calculateTotalStakeUnits(StakeData[] memory stakes, uint256 timestamp)     external     pure     returns (uint256 totalStakeUnits);  function calculateStakeUnits(     uint256 amount,     uint256 start,     uint256 end ) external pure returns (uint256 stakeUnits);  function calculateUnlockedRewards(     RewardSchedule[] memory rewardSchedules,     uint256 rewardBalance,     uint256 sharesOutstanding,     uint256 timestamp ) external pure returns (uint256 unlockedRewards);  function calculateRewardFromStakes(     StakeData[] memory stakes,     uint256 unstakeAmount,     uint256 unlockedRewards,     uint256 totalStakeUnits,     uint256 timestamp,     RewardScaling memory rewardScaling ) external pure returns (RewardOutput memory out);  function calculateReward(     uint256 unlockedRewards,     uint256 stakeAmount,     uint256 stakeDuration,     uint256 totalStakeUnits,     RewardScaling memory rewardScaling ) external pure returns (uint256 reward);  } /// @title Hypervisor /// @notice Reward distribution contract with time multiplier /// Access Control /// - Power controller: ///     Can power off / shutdown the Hypervisor ///     Can withdraw rewards from reward pool once shutdown /// - Proxy owner: ///     Can change arbitrary logic / state by upgrading the Hypervisor ///     Is unable to operate on user funds due to UniversalVault ///     Is unable to operate on reward pool funds when reward pool is offline / shutdown /// - Hypervisor admin: ///     Can add funds to the Hypervisor, register bonus tokens, and whitelist new vault factories ///     Is a subset of proxy owner permissions /// - User: ///     Can deposit / withdraw / ragequit /// Hypervisor State Machine /// - Online: ///     Hypervisor is operating normally, all functions are enabled /// - Offline: ///     Hypervisor is temporarely disabled for maintenance ///     User deposits and withdrawls are disabled, ragequit remains enabled ///     Users can withdraw their stake through rageQuit() but forego their pending reward ///     Should only be used when downtime required for an upgrade /// - Shutdown: ///     Hypervisor is permanently disabled ///     All functions are disabled with the exception of ragequit ///     Users can withdraw their stake through rageQuit() ///     Power controller can withdraw from the reward pool ///     Should only be used if Proxy Owner role is compromized contract Hypervisor is IHypervisor, Powered, Ownable {     using SafeMath for uint256;     using EnumerableSet for EnumerableSet.AddressSet; /* constants */  // An upper bound on the number of active stakes per vault is required to prevent // calls to rageQuit() from reverting. // With 30 stakes in a vault, ragequit costs 432811 gas which is conservatively lower // than the hardcoded limit of 500k gas on the vault. // This limit is configurable and could be increased in a future deployment. // Ultimately, to avoid a need for fixed upper bounds, the EVM would need to provide // an error code that allows for reliably catching out-of-gas errors on remote calls. uint256 public constant MAX_STAKES_PER_VAULT = 30; uint256 public constant MAX_REWARD_TOKENS = 50; uint256 public constant BASE_SHARES_PER_WEI = 1000000; uint256 public stakeLimit = 2500 ether;  /* storage */  HypervisorData private _hypervisor; mapping(address =&gt; VaultData) private _vaults; EnumerableSet.AddressSet private _bonusTokenSet; EnumerableSet.AddressSet private _vaultFactorySet;  /* initializer */  /// @notice Initizalize Hypervisor /// access control: only proxy constructor /// state machine: can only be called once /// state scope: set initialization variables /// token transfer: none /// @param ownerAddress address The admin address /// @param rewardPoolFactory address The factory to use for deploying the RewardPool /// @param powerSwitchFactory address The factory to use for deploying the PowerSwitch /// @param stakingToken address The address of the staking token for this Hypervisor /// @param rewardToken address The address of the reward token for this Hypervisor /// @param rewardScaling RewardScaling The config for reward scaling floor, ceiling, and time constructor(     address ownerAddress,     address rewardPoolFactory,     address powerSwitchFactory,     address stakingToken,     address rewardToken,     RewardScaling memory rewardScaling,     uint256 _stakeLimit ) {     // the scaling floor must be smaller than ceiling     require(rewardScaling.floor &lt;= rewardScaling.ceiling, ""Hypervisor: floor above ceiling"");      // setting rewardScalingTime to 0 would cause divide by zero error     // to disable reward scaling, use rewardScalingFloor == rewardScalingCeiling     require(rewardScaling.time != 0, ""Hypervisor: scaling time cannot be zero"");      // deploy power switch     address powerSwitch = IFactory(powerSwitchFactory).create(abi.encode(ownerAddress));      // deploy reward pool     address rewardPool = IFactory(rewardPoolFactory).create(abi.encode(powerSwitch));      // set internal configs     Ownable.transferOwnership(ownerAddress);     Powered._setPowerSwitch(powerSwitch);      // commit to storage     _hypervisor.stakingToken = stakingToken;     _hypervisor.rewardToken = rewardToken;     _hypervisor.rewardPool = rewardPool;     _hypervisor.rewardScaling = rewardScaling;      stakeLimit = _stakeLimit;      // emit event     emit HypervisorCreated(rewardPool, powerSwitch); }  /* getter functions */  function getBonusTokenSetLength() external view override returns (uint256 length) {     return _bonusTokenSet.length(); }  function getBonusTokenAtIndex(uint256 index)     external     view     override     returns (address bonusToken) {     return _bonusTokenSet.at(index); }  function getVaultFactorySetLength() external view override returns (uint256 length) {     return _vaultFactorySet.length(); }  function getVaultFactoryAtIndex(uint256 index)     external     view     override     returns (address factory) {     return _vaultFactorySet.at(index); }  function isValidVault(address target) public view override returns (bool validity) {     // validate target is created from whitelisted vault factory     for (uint256 index = 0; index &lt; _vaultFactorySet.length(); index++) {         if (IInstanceRegistry(_vaultFactorySet.at(index)).isInstance(target)) {             return true;         }     }     // explicit return     return false; }  function isValidAddress(address target) public view override returns (bool validity) {     // sanity check target for potential input errors     return         target != address(this) &amp;&amp;         target != address(0) &amp;&amp;         target != _hypervisor.stakingToken &amp;&amp;         target != _hypervisor.rewardToken &amp;&amp;         target != _hypervisor.rewardPool &amp;&amp;         !_bonusTokenSet.contains(target); }  /* Hypervisor getters */  function getHypervisorData() external view override returns (HypervisorData memory hypervisor) {     return _hypervisor; }  function getCurrentUnlockedRewards() public view override returns (uint256 unlockedRewards) {     // calculate reward available based on state     return getFutureUnlockedRewards(block.timestamp); }  function getFutureUnlockedRewards(uint256 timestamp)     public     view     override     returns (uint256 unlockedRewards) {     // get reward amount remaining     uint256 remainingRewards = IERC20(_hypervisor.rewardToken).balanceOf(_hypervisor.rewardPool);     // calculate reward available based on state     unlockedRewards = calculateUnlockedRewards(         _hypervisor.rewardSchedules,         remainingRewards,         _hypervisor.rewardSharesOutstanding,         timestamp     );     // explicit return     return unlockedRewards; }  function getCurrentTotalStakeUnits() public view override returns (uint256 totalStakeUnits) {     // calculate new stake units     return getFutureTotalStakeUnits(block.timestamp); }  function getFutureTotalStakeUnits(uint256 timestamp)     public     view     override     returns (uint256 totalStakeUnits) {     // return early if no change     if (timestamp == _hypervisor.lastUpdate) return _hypervisor.totalStakeUnits;     // calculate new stake units     uint256 newStakeUnits =         calculateStakeUnits(_hypervisor.totalStake, _hypervisor.lastUpdate, timestamp);     // add to cached total     totalStakeUnits = _hypervisor.totalStakeUnits.add(newStakeUnits);     // explicit return     return totalStakeUnits; }  /* vault getters */  function getVaultData(address vault)     external     view     override     returns (VaultData memory vaultData) {     return _vaults[vault]; }  function getCurrentVaultReward(address vault) external view override returns (uint256 reward) {     // calculate rewards     return         calculateRewardFromStakes(             _vaults[vault]                 .stakes,             _vaults[vault]                 .totalStake,             getCurrentUnlockedRewards(),             getCurrentTotalStakeUnits(),             block                 .timestamp,             _hypervisor                 .rewardScaling         )             .reward; }  function getFutureVaultReward(address vault, uint256 timestamp)     external     view     override     returns (uint256 reward) {     // calculate rewards     return         calculateRewardFromStakes(             _vaults[vault]                 .stakes,             _vaults[vault]                 .totalStake,             getFutureUnlockedRewards(timestamp),             getFutureTotalStakeUnits(timestamp),             timestamp,             _hypervisor                 .rewardScaling         )             .reward; }  function getCurrentStakeReward(address vault, uint256 stakeAmount)     external     view     override     returns (uint256 reward) {     // calculate rewards     return         calculateRewardFromStakes(             _vaults[vault]                 .stakes,             stakeAmount,             getCurrentUnlockedRewards(),             getCurrentTotalStakeUnits(),             block                 .timestamp,             _hypervisor                 .rewardScaling         )             .reward; }  function getFutureStakeReward(     address vault,     uint256 stakeAmount,     uint256 timestamp ) external view override returns (uint256 reward) {     // calculate rewards     return         calculateRewardFromStakes(             _vaults[vault]                 .stakes,             stakeAmount,             getFutureUnlockedRewards(timestamp),             getFutureTotalStakeUnits(timestamp),             timestamp,             _hypervisor                 .rewardScaling         )             .reward; }  function getCurrentVaultStakeUnits(address vault)     public     view     override     returns (uint256 stakeUnits) {     // calculate stake units     return getFutureVaultStakeUnits(vault, block.timestamp); }  function getFutureVaultStakeUnits(address vault, uint256 timestamp)     public     view     override     returns (uint256 stakeUnits) {     // calculate stake units     return calculateTotalStakeUnits(_vaults[vault].stakes, timestamp); }  /* pure functions */  function calculateTotalStakeUnits(StakeData[] memory stakes, uint256 timestamp)     public     pure     override     returns (uint256 totalStakeUnits) {     for (uint256 index; index &lt; stakes.length; index++) {         // reference stake         StakeData memory stakeData = stakes[index];         // calculate stake units         uint256 stakeUnits =             calculateStakeUnits(stakeData.amount, stakeData.timestamp, timestamp);         // add to running total         totalStakeUnits = totalStakeUnits.add(stakeUnits);     } }  function calculateStakeUnits(     uint256 amount,     uint256 start,     uint256 end ) public pure override returns (uint256 stakeUnits) {     // calculate duration     uint256 duration = end.sub(start);     // calculate stake units     stakeUnits = duration.mul(amount);     // explicit return     return stakeUnits; }  function calculateUnlockedRewards(     RewardSchedule[] memory rewardSchedules,     uint256 rewardBalance,     uint256 sharesOutstanding,     uint256 timestamp ) public pure override returns (uint256 unlockedRewards) {     // return 0 if no registered schedules     if (rewardSchedules.length == 0) {         return 0;     }      // calculate reward shares locked across all reward schedules     uint256 sharesLocked;     for (uint256 index = 0; index &lt; rewardSchedules.length; index++) {         // fetch reward schedule storage reference         RewardSchedule memory schedule = rewardSchedules[index];          // caculate amount of shares available on this schedule         // if (now - start) &lt; duration         //   sharesLocked = shares - (shares * (now - start) / duration)         // else         //   sharesLocked = 0         uint256 currentSharesLocked = 0;         if (timestamp.sub(schedule.start) &lt; schedule.duration) {             currentSharesLocked = schedule.shares.sub(                 schedule.shares.mul(timestamp.sub(schedule.start)).div(schedule.duration)             );         }          // add to running total         sharesLocked = sharesLocked.add(currentSharesLocked);     }      // convert shares to reward     // rewardLocked = sharesLocked * rewardBalance / sharesOutstanding     uint256 rewardLocked = sharesLocked.mul(rewardBalance).div(sharesOutstanding);      // calculate amount available     // unlockedRewards = rewardBalance - rewardLocked     unlockedRewards = rewardBalance.sub(rewardLocked);      // explicit return     return unlockedRewards; }  function calculateRewardFromStakes(     StakeData[] memory stakes,     uint256 unstakeAmount,     uint256 unlockedRewards,     uint256 totalStakeUnits,     uint256 timestamp,     RewardScaling memory rewardScaling ) public pure override returns (RewardOutput memory out) {     uint256 stakesToDrop = 0;     while (unstakeAmount &gt; 0) {         // fetch vault stake storage reference         StakeData memory lastStake = stakes[stakes.length.sub(stakesToDrop).sub(1)];          // calculate stake duration         uint256 stakeDuration = timestamp.sub(lastStake.timestamp);          uint256 currentAmount;         if (lastStake.amount &gt; unstakeAmount) {             // set current amount to remaining unstake amount             currentAmount = unstakeAmount;             // amount of last stake is reduced             out.lastStakeAmount = lastStake.amount.sub(unstakeAmount);         } else {             // set current amount to amount of last stake             currentAmount = lastStake.amount;             // add to stakes to drop             stakesToDrop += 1;         }          // update remaining unstakeAmount         unstakeAmount = unstakeAmount.sub(currentAmount);          // calculate reward amount         uint256 currentReward =             calculateReward(                 unlockedRewards,                 currentAmount,                 stakeDuration,                 totalStakeUnits,                 rewardScaling             );          // update cumulative reward         out.reward = out.reward.add(currentReward);          // update cached unlockedRewards         unlockedRewards = unlockedRewards.sub(currentReward);          // calculate time weighted stake         uint256 stakeUnits = currentAmount.mul(stakeDuration);          // update cached totalStakeUnits         totalStakeUnits = totalStakeUnits.sub(stakeUnits);     }      // explicit return     return         RewardOutput(             out.lastStakeAmount,             stakes.length.sub(stakesToDrop),             out.reward,             totalStakeUnits         ); }  function calculateReward(     uint256 unlockedRewards,     uint256 stakeAmount,     uint256 stakeDuration,     uint256 totalStakeUnits,     RewardScaling memory rewardScaling ) public pure override returns (uint256 reward) {     // calculate time weighted stake     uint256 stakeUnits = stakeAmount.mul(stakeDuration);      // calculate base reward     // baseReward = unlockedRewards * stakeUnits / totalStakeUnits     uint256 baseReward = 0;     if (totalStakeUnits != 0) {         // scale reward according to proportional weight         baseReward = unlockedRewards.mul(stakeUnits).div(totalStakeUnits);     }      // calculate scaled reward     // if no scaling or scaling period completed     //   reward = baseReward     // else     //   minReward = baseReward * scalingFloor / scalingCeiling     //   bonusReward = baseReward     //                 * (scalingCeiling - scalingFloor) / scalingCeiling     //                 * duration / scalingTime     //   reward = minReward + bonusReward     if (stakeDuration &gt;= rewardScaling.time || rewardScaling.floor == rewardScaling.ceiling) {         // no reward scaling applied         reward = baseReward;     } else {         // calculate minimum reward using scaling floor         uint256 minReward = baseReward.mul(rewardScaling.floor).div(rewardScaling.ceiling);          // calculate bonus reward with vested portion of scaling factor         uint256 bonusReward =             baseReward                 .mul(stakeDuration)                 .mul(rewardScaling.ceiling.sub(rewardScaling.floor))                 .div(rewardScaling.ceiling)                 .div(rewardScaling.time);          // add minimum reward and bonus reward         reward = minReward.add(bonusReward);     }      // explicit return     return reward; }  /* admin functions */  /// @notice Add funds to the Hypervisor /// access control: only admin /// state machine: ///   - can be called multiple times ///   - only online /// state scope: ///   - increase _hypervisor.rewardSharesOutstanding ///   - append to _hypervisor.rewardSchedules /// token transfer: transfer staking tokens from msg.sender to reward pool /// @param amount uint256 Amount of reward tokens to deposit /// @param duration uint256 Duration over which to linearly unlock rewards function fund(uint256 amount, uint256 duration) external onlyOwner onlyOnline {     // validate duration     require(duration != 0, ""Hypervisor: invalid duration"");      // create new reward shares     // if existing rewards on this Hypervisor     //   mint new shares proportional to % change in rewards remaining     //   newShares = remainingShares * newReward / remainingRewards     // else     //   mint new shares with BASE_SHARES_PER_WEI initial conversion rate     //   store as fixed point number with same  of decimals as reward token     uint256 newRewardShares;     if (_hypervisor.rewardSharesOutstanding &gt; 0) {         uint256 remainingRewards = IERC20(_hypervisor.rewardToken).balanceOf(_hypervisor.rewardPool);         newRewardShares = _hypervisor.rewardSharesOutstanding.mul(amount).div(remainingRewards);     } else {         newRewardShares = amount.mul(BASE_SHARES_PER_WEI);     }      // add reward shares to total     _hypervisor.rewardSharesOutstanding = _hypervisor.rewardSharesOutstanding.add(newRewardShares);      // store new reward schedule     _hypervisor.rewardSchedules.push(RewardSchedule(duration, block.timestamp, newRewardShares));      // transfer reward tokens to reward pool     TransferHelper.safeTransferFrom(         _hypervisor.rewardToken,         msg.sender,         _hypervisor.rewardPool,         amount     );      // emit event     emit HypervisorFunded(amount, duration); }  /// @notice Add vault factory to whitelist /// @dev use this function to enable stakes to vaults coming from the specified ///      factory contract /// access control: only admin /// state machine: ///   - can be called multiple times ///   - not shutdown /// state scope: ///   - append to _vaultFactorySet /// token transfer: none /// @param factory address The address of the vault factory function registerVaultFactory(address factory) external onlyOwner notShutdown {     // add factory to set     require(_vaultFactorySet.add(factory), ""Hypervisor: vault factory already registered"");      // emit event     emit VaultFactoryRegistered(factory); }  /// @notice Remove vault factory from whitelist /// @dev use this function to disable new stakes to vaults coming from the specified ///      factory contract. ///      note: vaults with existing stakes from this factory are sill able to unstake /// access control: only admin /// state machine: ///   - can be called multiple times ///   - not shutdown /// state scope: ///   - remove from _vaultFactorySet /// token transfer: none /// @param factory address The address of the vault factory function removeVaultFactory(address factory) external onlyOwner notShutdown {     // remove factory from set     require(_vaultFactorySet.remove(factory), ""Hypervisor: vault factory not registered"");      // emit event     emit VaultFactoryRemoved(factory); }  /// @notice Register bonus token for distribution /// @dev use this function to enable distribution of any ERC20 held by the RewardPool contract /// access control: only admin /// state machine: ///   - can be called multiple times ///   - only online /// state scope: ///   - append to _bonusTokenSet /// token transfer: none /// @param bonusToken address The address of the bonus token function registerBonusToken(address bonusToken) external onlyOwner onlyOnline {     // verify valid bonus token     _validateAddress(bonusToken);      // verify bonus token count     require(_bonusTokenSet.length() &lt; MAX_REWARD_TOKENS, ""Hypervisor: max bonus tokens reached "");      // add token to set     assert(_bonusTokenSet.add(bonusToken));      // emit event     emit BonusTokenRegistered(bonusToken); }  /// @notice Rescue tokens from RewardPool /// @dev use this function to rescue tokens from RewardPool contract ///      without distributing to stakers or triggering emergency shutdown /// access control: only admin /// state machine: ///   - can be called multiple times ///   - only online /// state scope: none /// token transfer: transfer requested token from RewardPool to recipient /// @param token address The address of the token to rescue /// @param recipient address The address of the recipient /// @param amount uint256 The amount of tokens to rescue function rescueTokensFromRewardPool(     address token,     address recipient,     uint256 amount ) external onlyOwner onlyOnline {     // verify recipient     _validateAddress(recipient);      // check not attempting to unstake reward token     require(token != _hypervisor.rewardToken, ""Hypervisor: invalid address"");      // check not attempting to wthdraw bonus token     require(!_bonusTokenSet.contains(token), ""Hypervisor: invalid address"");      // transfer tokens to recipient     IRewardPool(_hypervisor.rewardPool).sendERC20(token, recipient, amount); }  /* user functions */  /// @notice Stake tokens /// @dev anyone can stake to any vault if they have valid permission /// access control: anyone /// state machine: ///   - can be called multiple times ///   - only online ///   - when vault exists on this Hypervisor /// state scope: ///   - append to _vaults[vault].stakes ///   - increase _vaults[vault].totalStake ///   - increase _hypervisor.totalStake ///   - increase _hypervisor.totalStakeUnits ///   - increase _hypervisor.lastUpdate /// token transfer: transfer staking tokens from msg.sender to vault /// @param vault address The address of the vault to stake from /// @param amount uint256 The amount of staking tokens to stake function stake(     address vault,     uint256 amount,     bytes calldata permission ) external override onlyOnline {     // verify vault is valid     require(isValidVault(vault), ""Hypervisor: vault is not registered"");      // verify non-zero amount     require(amount != 0, ""Hypervisor: no amount staked"");      // fetch vault storage reference     VaultData storage vaultData = _vaults[vault];      // verify stakes boundary not reached     require(         vaultData.stakes.length &lt; MAX_STAKES_PER_VAULT,         ""Hypervisor: MAX_STAKES_PER_VAULT reached""     );      // update cached sum of stake units across all vaults     _updateTotalStakeUnits();      // store amount and timestamp     vaultData.stakes.push(StakeData(amount, block.timestamp));      // update cached total vault and Hypervisor amounts     vaultData.totalStake = vaultData.totalStake.add(amount);     // verify stake quantity without bounds     require(         stakeLimit == 0 || vaultData.totalStake &lt;= stakeLimit,         ""Hypervisor: Stake limit exceeded""     );     _hypervisor.totalStake = _hypervisor.totalStake.add(amount);      // call lock on vault     IUniversalVault(vault).lock(_hypervisor.stakingToken, amount, permission);      // emit event     emit Staked(vault, amount); }  /// @notice Unstake staking tokens and claim reward /// @dev rewards can only be claimed when unstaking /// access control: only owner of vault /// state machine: ///   - when vault exists on this Hypervisor ///   - after stake from vault ///   - can be called multiple times while sufficient stake remains ///   - only online /// state scope: ///   - decrease _hypervisor.rewardSharesOutstanding ///   - decrease _hypervisor.totalStake ///   - increase _hypervisor.lastUpdate ///   - modify _hypervisor.totalStakeUnits ///   - modify _vaults[vault].stakes ///   - decrease _vaults[vault].totalStake /// token transfer: ///   - transfer reward tokens from reward pool to recipient ///   - transfer bonus tokens from reward pool to recipient /// @param vault address The vault to unstake from /// @param amount uint256 The amount of staking tokens to unstake function unstakeAndClaim(     address vault,     uint256 amount,     bytes calldata permission ) external override onlyOnline {     // fetch vault storage reference     VaultData storage vaultData = _vaults[vault];      // verify non-zero amount     require(amount != 0, ""Hypervisor: no amount unstaked"");      address recipient = IUniversalVault(vault).owner();      // validate recipient     _validateAddress(recipient);      // check for sufficient vault stake amount     require(vaultData.totalStake &gt;= amount, ""Hypervisor: insufficient vault stake"");      // check for sufficient Hypervisor stake amount     // if this check fails, there is a bug in stake accounting     assert(_hypervisor.totalStake &gt;= amount);      // update cached sum of stake units across all vaults     _updateTotalStakeUnits();      // get reward amount remaining     uint256 remainingRewards = IERC20(_hypervisor.rewardToken).balanceOf(_hypervisor.rewardPool);      // calculate vested portion of reward pool     uint256 unlockedRewards =         calculateUnlockedRewards(             _hypervisor.rewardSchedules,             remainingRewards,             _hypervisor.rewardSharesOutstanding,             block.timestamp         );      // calculate vault time weighted reward with scaling     RewardOutput memory out =         calculateRewardFromStakes(             vaultData.stakes,             amount,             unlockedRewards,             _hypervisor.totalStakeUnits,             block.timestamp,             _hypervisor.rewardScaling         );      // update stake data in storage     if (out.newStakesCount == 0) {         // all stakes have been unstaked         delete vaultData.stakes;     } else {         // some stakes have been completely or partially unstaked         // delete fully unstaked stakes         while (vaultData.stakes.length &gt; out.newStakesCount) vaultData.stakes.pop();         // update partially unstaked stake         vaultData.stakes[out.newStakesCount.sub(1)].amount = out.lastStakeAmount;     }      // update cached stake totals     vaultData.totalStake = vaultData.totalStake.sub(amount);     _hypervisor.totalStake = _hypervisor.totalStake.sub(amount);     _hypervisor.totalStakeUnits = out.newTotalStakeUnits;      // unlock staking tokens from vault     IUniversalVault(vault).unlock(_hypervisor.stakingToken, amount, permission);      // emit event     emit Unstaked(vault, amount);      // only perform on non-zero reward     if (out.reward &gt; 0) {         // calculate shares to burn         // sharesToBurn = sharesOutstanding * reward / remainingRewards         uint256 sharesToBurn =             _hypervisor.rewardSharesOutstanding.mul(out.reward).div(remainingRewards);          // burn claimed shares         _hypervisor.rewardSharesOutstanding = _hypervisor.rewardSharesOutstanding.sub(sharesToBurn);          // transfer bonus tokens from reward pool to recipient         if (_bonusTokenSet.length() &gt; 0) {             for (uint256 index = 0; index &lt; _bonusTokenSet.length(); index++) {                 // fetch bonus token address reference                 address bonusToken = _bonusTokenSet.at(index);                  // calculate bonus token amount                 // bonusAmount = bonusRemaining * reward / remainingRewards                 uint256 bonusAmount =                     IERC20(bonusToken).balanceOf(_hypervisor.rewardPool).mul(out.reward).div(                         remainingRewards                     );                  // transfer bonus token                 IRewardPool(_hypervisor.rewardPool).sendERC20(bonusToken, recipient, bonusAmount);                  // emit event                 emit RewardClaimed(vault, recipient, bonusToken, bonusAmount);             }         }          // transfer reward tokens from reward pool to recipient         IRewardPool(_hypervisor.rewardPool).sendERC20(_hypervisor.rewardToken, recipient, out.reward);          // emit event         emit RewardClaimed(vault, recipient, _hypervisor.rewardToken, out.reward);     } }  /// @notice Exit Hypervisor without claiming reward /// @dev This function should never revert when correctly called by the vault. ///      A max number of stakes per vault is set with MAX_STAKES_PER_VAULT to ///      place an upper bound on the for loop in calculateTotalStakeUnits(). /// access control: only callable by the vault directly /// state machine: ///   - when vault exists on this Hypervisor ///   - when active stake from this vault ///   - any power state /// state scope: ///   - decrease _hypervisor.totalStake ///   - increase _hypervisor.lastUpdate ///   - modify _hypervisor.totalStakeUnits ///   - delete _vaults[vault] /// token transfer: none function rageQuit() external override {     // fetch vault storage reference     VaultData storage _vaultData = _vaults[msg.sender];      // revert if no active stakes     require(_vaultData.stakes.length != 0, ""Hypervisor: no stake"");      // update cached sum of stake units across all vaults     _updateTotalStakeUnits();      // emit event     emit Unstaked(msg.sender, _vaultData.totalStake);      // update cached totals     _hypervisor.totalStake = _hypervisor.totalStake.sub(_vaultData.totalStake);     _hypervisor.totalStakeUnits = _hypervisor.totalStakeUnits.sub(         calculateTotalStakeUnits(_vaultData.stakes, block.timestamp)     );      // delete stake data     delete _vaults[msg.sender]; }  /* convenience functions */  function _updateTotalStakeUnits() private {     // update cached totalStakeUnits     _hypervisor.totalStakeUnits = getCurrentTotalStakeUnits();     // update cached lastUpdate     _hypervisor.lastUpdate = block.timestamp; }  function _validateAddress(address target) private view {     // sanity check target for potential input errors     require(isValidAddress(target), ""Hypervisor: invalid address""); }  function _truncateStakesArray(StakeData[] memory array, uint256 newLength)     private     pure     returns (StakeData[] memory newArray) {     newArray = new StakeData[](newLength);     for (uint256 index = 0; index &lt; newLength; index++) {         newArray[index] = array[index];     }     return newArray; }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-02-08 00:46:37 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: GPL-3.0-only
pragma solidity 0.7.6;
pragma abicoder v2;

import {SafeMath} from ""@openzeppelin/contracts/math/SafeMath.sol"";
import {EnumerableSet} from ""@openzeppelin/contracts/utils/EnumerableSet.sol"";
import {IERC20} from ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import {Ownable} from ""@openzeppelin/contracts/access/Ownable.sol"";
import {TransferHelper} from ""@uniswap/lib/contracts/libraries/TransferHelper.sol"";

import {IFactory} from ""../factory/IFactory.sol"";
import {IInstanceRegistry} from ""../factory/InstanceRegistry.sol"";
import {IUniversalVault} from ""../visor/Visor.sol"";
import {IRewardPool} from ""./RewardPool.sol"";
import {Powered} from ""./Powered.sol"";

interface IRageQuit {
    function rageQuit() external;
}

interface IHypervisor is IRageQuit {
    /* admin events */

    event HypervisorCreated(address rewardPool, address powerSwitch);
    event HypervisorFunded(uint256 amount, uint256 duration);
    event BonusTokenRegistered(address token);
    event VaultFactoryRegistered(address factory);
    event VaultFactoryRemoved(address factory);

    /* user events */

    event Staked(address vault, uint256 amount);
    event Unstaked(address vault, uint256 amount);
    event RewardClaimed(address vault, address recipient, address token, uint256 amount);

    /* data types */

    struct HypervisorData {
        address stakingToken;
        address rewardToken;
        address rewardPool;
        RewardScaling rewardScaling;
        uint256 rewardSharesOutstanding;
        uint256 totalStake;
        uint256 totalStakeUnits;
        uint256 lastUpdate;
        RewardSchedule[] rewardSchedules;
    }

    struct RewardSchedule {
        uint256 duration;
        uint256 start;
        uint256 shares;
    }

    struct VaultData {
        uint256 totalStake;
        StakeData[] stakes;
    }

    struct StakeData {
        uint256 amount;
        uint256 timestamp;
    }

    struct RewardScaling {
        uint256 floor;
        uint256 ceiling;
        uint256 time;
    }

    struct RewardOutput {
        uint256 lastStakeAmount;
        uint256 newStakesCount;
        uint256 reward;
        uint256 newTotalStakeUnits;
    }

    /* user functions */

    function stake(
        address vault,
        uint256 amount,
        bytes calldata permission
    ) external;

    function unstakeAndClaim(
        address vault,
        uint256 amount,
        bytes calldata permission
    ) external;

    /* getter functions */

    function getHypervisorData() external view returns (HypervisorData memory hypervisor);

    function getBonusTokenSetLength() external view returns (uint256 length);

    function getBonusTokenAtIndex(uint256 index) external view returns (address bonusToken);

    function getVaultFactorySetLength() external view returns (uint256 length);

    function getVaultFactoryAtIndex(uint256 index) external view returns (address factory);

    function getVaultData(address vault) external view returns (VaultData memory vaultData);

    function isValidAddress(address target) external view returns (bool validity);

    function isValidVault(address target) external view returns (bool validity);

    function getCurrentUnlockedRewards() external view returns (uint256 unlockedRewards);

    function getFutureUnlockedRewards(uint256 timestamp)
        external
        view
        returns (uint256 unlockedRewards);

    function getCurrentVaultReward(address vault) external view returns (uint256 reward);

    function getCurrentStakeReward(address vault, uint256 stakeAmount)
        external
        view
        returns (uint256 reward);

    function getFutureVaultReward(address vault, uint256 timestamp)
        external
        view
        returns (uint256 reward);

    function getFutureStakeReward(
        address vault,
        uint256 stakeAmount,
        uint256 timestamp
    ) external view returns (uint256 reward);

    function getCurrentVaultStakeUnits(address vault) external view returns (uint256 stakeUnits);

    function getFutureVaultStakeUnits(address vault, uint256 timestamp)
        external
        view
        returns (uint256 stakeUnits);

    function getCurrentTotalStakeUnits() external view returns (uint256 totalStakeUnits);

    function getFutureTotalStakeUnits(uint256 timestamp)
        external
        view
        returns (uint256 totalStakeUnits);

    /* pure functions */

    function calculateTotalStakeUnits(StakeData[] memory stakes, uint256 timestamp)
        external
        pure
        returns (uint256 totalStakeUnits);

    function calculateStakeUnits(
        uint256 amount,
        uint256 start,
        uint256 end
    ) external pure returns (uint256 stakeUnits);

    function calculateUnlockedRewards(
        RewardSchedule[] memory rewardSchedules,
        uint256 rewardBalance,
        uint256 sharesOutstanding,
        uint256 timestamp
    ) external pure returns (uint256 unlockedRewards);

    function calculateRewardFromStakes(
        StakeData[] memory stakes,
        uint256 unstakeAmount,
        uint256 unlockedRewards,
        uint256 totalStakeUnits,
        uint256 timestamp,
        RewardScaling memory rewardScaling
    ) external pure returns (RewardOutput memory out);

    function calculateReward(
        uint256 unlockedRewards,
        uint256 stakeAmount,
        uint256 stakeDuration,
        uint256 totalStakeUnits,
        RewardScaling memory rewardScaling
    ) external pure returns (uint256 reward);
}

/// @title Hypervisor
/// @notice Reward distribution contract with time multiplier
/// Access Control
/// - Power controller:
///     Can power off / shutdown the Hypervisor
///     Can withdraw rewards from reward pool once shutdown
/// - Proxy owner:
///     Can change arbitrary logic / state by upgrading the Hypervisor
///     Is unable to operate on user funds due to UniversalVault
///     Is unable to operate on reward pool funds when reward pool is offline / shutdown
/// - Hypervisor admin:
///     Can add funds to the Hypervisor, register bonus tokens, and whitelist new vault factories
///     Is a subset of proxy owner permissions
/// - User:
///     Can deposit / withdraw / ragequit
/// Hypervisor State Machine
/// - Online:
///     Hypervisor is operating normally, all functions are enabled
/// - Offline:
///     Hypervisor is temporarely disabled for maintenance
///     User deposits and withdrawls are disabled, ragequit remains enabled
///     Users can withdraw their stake through rageQuit() but forego their pending reward
///     Should only be used when downtime required for an upgrade
/// - Shutdown:
///     Hypervisor is permanently disabled
///     All functions are disabled with the exception of ragequit
///     Users can withdraw their stake through rageQuit()
///     Power controller can withdraw from the reward pool
///     Should only be used if Proxy Owner role is compromized
contract Hypervisor is IHypervisor, Powered, Ownable {
    using SafeMath for uint256;
    using EnumerableSet for EnumerableSet.AddressSet;

    /* constants */

    // An upper bound on the number of active stakes per vault is required to prevent
    // calls to rageQuit() from reverting.
    // With 30 stakes in a vault, ragequit costs 432811 gas which is conservatively lower
    // than the hardcoded limit of 500k gas on the vault.
    // This limit is configurable and could be increased in a future deployment.
    // Ultimately, to avoid a need for fixed upper bounds, the EVM would need to provide
    // an error code that allows for reliably catching out-of-gas errors on remote calls.
    uint256 public constant MAX_STAKES_PER_VAULT = 30;
    uint256 public constant MAX_REWARD_TOKENS = 50;
    uint256 public constant BASE_SHARES_PER_WEI = 1000000;
    uint256 public stakeLimit = 2500 ether;

    /* storage */

    HypervisorData private _hypervisor;
    mapping(address => VaultData) private _vaults;
    EnumerableSet.AddressSet private _bonusTokenSet;
    EnumerableSet.AddressSet private _vaultFactorySet;

    /* initializer */

    /// @notice Initizalize Hypervisor
    /// access control: only proxy constructor
    /// state machine: can only be called once
    /// state scope: set initialization variables
    /// token transfer: none
    /// @param ownerAddress address The admin address
    /// @param rewardPoolFactory address The factory to use for deploying the RewardPool
    /// @param powerSwitchFactory address The factory to use for deploying the PowerSwitch
    /// @param stakingToken address The address of the staking token for this Hypervisor
    /// @param rewardToken address The address of the reward token for this Hypervisor
    /// @param rewardScaling RewardScaling The config for reward scaling floor, ceiling, and time
    constructor(
        address ownerAddress,
        address rewardPoolFactory,
        address powerSwitchFactory,
        address stakingToken,
        address rewardToken,
        RewardScaling memory rewardScaling,
        uint256 _stakeLimit
    ) {
        // the scaling floor must be smaller than ceiling
        require(rewardScaling.floor <= rewardScaling.ceiling, ""Hypervisor: floor above ceiling"");

        // setting rewardScalingTime to 0 would cause divide by zero error
        // to disable reward scaling, use rewardScalingFloor == rewardScalingCeiling
        require(rewardScaling.time != 0, ""Hypervisor: scaling time cannot be zero"");

        // deploy power switch
        address powerSwitch = IFactory(powerSwitchFactory).create(abi.encode(ownerAddress));

        // deploy reward pool
        address rewardPool = IFactory(rewardPoolFactory).create(abi.encode(powerSwitch));

        // set internal configs
        Ownable.transferOwnership(ownerAddress);
        Powered._setPowerSwitch(powerSwitch);

        // commit to storage
        _hypervisor.stakingToken = stakingToken;
        _hypervisor.rewardToken = rewardToken;
        _hypervisor.rewardPool = rewardPool;
        _hypervisor.rewardScaling = rewardScaling;

        stakeLimit = _stakeLimit;

        // emit event
        emit HypervisorCreated(rewardPool, powerSwitch);
    }

    /* getter functions */

    function getBonusTokenSetLength() external view override returns (uint256 length) {
        return _bonusTokenSet.length();
    }

    function getBonusTokenAtIndex(uint256 index)
        external
        view
        override
        returns (address bonusToken)
    {
        return _bonusTokenSet.at(index);
    }

    function getVaultFactorySetLength() external view override returns (uint256 length) {
        return _vaultFactorySet.length();
    }

    function getVaultFactoryAtIndex(uint256 index)
        external
        view
        override
        returns (address factory)
    {
        return _vaultFactorySet.at(index);
    }

    function isValidVault(address target) public view override returns (bool validity) {
        // validate target is created from whitelisted vault factory
        for (uint256 index = 0; index < _vaultFactorySet.length(); index++) {
            if (IInstanceRegistry(_vaultFactorySet.at(index)).isInstance(target)) {
                return true;
            }
        }
        // explicit return
        return false;
    }

    function isValidAddress(address target) public view override returns (bool validity) {
        // sanity check target for potential input errors
        return
            target != address(this) &&
            target != address(0) &&
            target != _hypervisor.stakingToken &&
            target != _hypervisor.rewardToken &&
            target != _hypervisor.rewardPool &&
            !_bonusTokenSet.contains(target);
    }

    /* Hypervisor getters */

    function getHypervisorData() external view override returns (HypervisorData memory hypervisor) {
        return _hypervisor;
    }

    function getCurrentUnlockedRewards() public view override returns (uint256 unlockedRewards) {
        // calculate reward available based on state
        return getFutureUnlockedRewards(block.timestamp);
    }

    function getFutureUnlockedRewards(uint256 timestamp)
        public
        view
        override
        returns (uint256 unlockedRewards)
    {
        // get reward amount remaining
        uint256 remainingRewards = IERC20(_hypervisor.rewardToken).balanceOf(_hypervisor.rewardPool);
        // calculate reward available based on state
        unlockedRewards = calculateUnlockedRewards(
            _hypervisor.rewardSchedules,
            remainingRewards,
            _hypervisor.rewardSharesOutstanding,
            timestamp
        );
        // explicit return
        return unlockedRewards;
    }

    function getCurrentTotalStakeUnits() public view override returns (uint256 totalStakeUnits) {
        // calculate new stake units
        return getFutureTotalStakeUnits(block.timestamp);
    }

    function getFutureTotalStakeUnits(uint256 timestamp)
        public
        view
        override
        returns (uint256 totalStakeUnits)
    {
        // return early if no change
        if (timestamp == _hypervisor.lastUpdate) return _hypervisor.totalStakeUnits;
        // calculate new stake units
        uint256 newStakeUnits =
            calculateStakeUnits(_hypervisor.totalStake, _hypervisor.lastUpdate, timestamp);
        // add to cached total
        totalStakeUnits = _hypervisor.totalStakeUnits.add(newStakeUnits);
        // explicit return
        return totalStakeUnits;
    }

    /* vault getters */

    function getVaultData(address vault)
        external
        view
        override
        returns (VaultData memory vaultData)
    {
        return _vaults[vault];
    }

    function getCurrentVaultReward(address vault) external view override returns (uint256 reward) {
        // calculate rewards
        return
            calculateRewardFromStakes(
                _vaults[vault]
                    .stakes,
                _vaults[vault]
                    .totalStake,
                getCurrentUnlockedRewards(),
                getCurrentTotalStakeUnits(),
                block
                    .timestamp,
                _hypervisor
                    .rewardScaling
            )
                .reward;
    }

    function getFutureVaultReward(address vault, uint256 timestamp)
        external
        view
        override
        returns (uint256 reward)
    {
        // calculate rewards
        return
            calculateRewardFromStakes(
                _vaults[vault]
                    .stakes,
                _vaults[vault]
                    .totalStake,
                getFutureUnlockedRewards(timestamp),
                getFutureTotalStakeUnits(timestamp),
                timestamp,
                _hypervisor
                    .rewardScaling
            )
                .reward;
    }

    function getCurrentStakeReward(address vault, uint256 stakeAmount)
        external
        view
        override
        returns (uint256 reward)
    {
        // calculate rewards
        return
            calculateRewardFromStakes(
                _vaults[vault]
                    .stakes,
                stakeAmount,
                getCurrentUnlockedRewards(),
                getCurrentTotalStakeUnits(),
                block
                    .timestamp,
                _hypervisor
                    .rewardScaling
            )
                .reward;
    }

    function getFutureStakeReward(
        address vault,
        uint256 stakeAmount,
        uint256 timestamp
    ) external view override returns (uint256 reward) {
        // calculate rewards
        return
            calculateRewardFromStakes(
                _vaults[vault]
                    .stakes,
                stakeAmount,
                getFutureUnlockedRewards(timestamp),
                getFutureTotalStakeUnits(timestamp),
                timestamp,
                _hypervisor
                    .rewardScaling
            )
                .reward;
    }

    function getCurrentVaultStakeUnits(address vault)
        public
        view
        override
        returns (uint256 stakeUnits)
    {
        // calculate stake units
        return getFutureVaultStakeUnits(vault, block.timestamp);
    }

    function getFutureVaultStakeUnits(address vault, uint256 timestamp)
        public
        view
        override
        returns (uint256 stakeUnits)
    {
        // calculate stake units
        return calculateTotalStakeUnits(_vaults[vault].stakes, timestamp);
    }

    /* pure functions */

    function calculateTotalStakeUnits(StakeData[] memory stakes, uint256 timestamp)
        public
        pure
        override
        returns (uint256 totalStakeUnits)
    {
        for (uint256 index; index < stakes.length; index++) {
            // reference stake
            StakeData memory stakeData = stakes[index];
            // calculate stake units
            uint256 stakeUnits =
                calculateStakeUnits(stakeData.amount, stakeData.timestamp, timestamp);
            // add to running total
            totalStakeUnits = totalStakeUnits.add(stakeUnits);
        }
    }

    function calculateStakeUnits(
        uint256 amount,
        uint256 start,
        uint256 end
    ) public pure override returns (uint256 stakeUnits) {
        // calculate duration
        uint256 duration = end.sub(start);
        // calculate stake units
        stakeUnits = duration.mul(amount);
        // explicit return
        return stakeUnits;
    }

    function calculateUnlockedRewards(
        RewardSchedule[] memory rewardSchedules,
        uint256 rewardBalance,
        uint256 sharesOutstanding,
        uint256 timestamp
    ) public pure override returns (uint256 unlockedRewards) {
        // return 0 if no registered schedules
        if (rewardSchedules.length == 0) {
            return 0;
        }

        // calculate reward shares locked across all reward schedules
        uint256 sharesLocked;
        for (uint256 index = 0; index < rewardSchedules.length; index++) {
            // fetch reward schedule storage reference
            RewardSchedule memory schedule = rewardSchedules[index];

            // caculate amount of shares available on this schedule
            // if (now - start) < duration
            //   sharesLocked = shares - (shares * (now - start) / duration)
            // else
            //   sharesLocked = 0
            uint256 currentSharesLocked = 0;
            if (timestamp.sub(schedule.start) < schedule.duration) {
                currentSharesLocked = schedule.shares.sub(
                    schedule.shares.mul(timestamp.sub(schedule.start)).div(schedule.duration)
                );
            }

            // add to running total
            sharesLocked = sharesLocked.add(currentSharesLocked);
        }

        // convert shares to reward
        // rewardLocked = sharesLocked * rewardBalance / sharesOutstanding
        uint256 rewardLocked = sharesLocked.mul(rewardBalance).div(sharesOutstanding);

        // calculate amount available
        // unlockedRewards = rewardBalance - rewardLocked
        unlockedRewards = rewardBalance.sub(rewardLocked);

        // explicit return
        return unlockedRewards;
    }

    function calculateRewardFromStakes(
        StakeData[] memory stakes,
        uint256 unstakeAmount,
        uint256 unlockedRewards,
        uint256 totalStakeUnits,
        uint256 timestamp,
        RewardScaling memory rewardScaling
    ) public pure override returns (RewardOutput memory out) {
        uint256 stakesToDrop = 0;
        while (unstakeAmount > 0) {
            // fetch vault stake storage reference
            StakeData memory lastStake = stakes[stakes.length.sub(stakesToDrop).sub(1)];

            // calculate stake duration
            uint256 stakeDuration = timestamp.sub(lastStake.timestamp);

            uint256 currentAmount;
            if (lastStake.amount > unstakeAmount) {
                // set current amount to remaining unstake amount
                currentAmount = unstakeAmount;
                // amount of last stake is reduced
                out.lastStakeAmount = lastStake.amount.sub(unstakeAmount);
            } else {
                // set current amount to amount of last stake
                currentAmount = lastStake.amount;
                // add to stakes to drop
                stakesToDrop += 1;
            }

            // update remaining unstakeAmount
            unstakeAmount = unstakeAmount.sub(currentAmount);

            // calculate reward amount
            uint256 currentReward =
                calculateReward(
                    unlockedRewards,
                    currentAmount,
                    stakeDuration,
                    totalStakeUnits,
                    rewardScaling
                );

            // update cumulative reward
            out.reward = out.reward.add(currentReward);

            // update cached unlockedRewards
            unlockedRewards = unlockedRewards.sub(currentReward);

            // calculate time weighted stake
            uint256 stakeUnits = currentAmount.mul(stakeDuration);

            // update cached totalStakeUnits
            totalStakeUnits = totalStakeUnits.sub(stakeUnits);
        }

        // explicit return
        return
            RewardOutput(
                out.lastStakeAmount,
                stakes.length.sub(stakesToDrop),
                out.reward,
                totalStakeUnits
            );
    }

    function calculateReward(
        uint256 unlockedRewards,
        uint256 stakeAmount,
        uint256 stakeDuration,
        uint256 totalStakeUnits,
        RewardScaling memory rewardScaling
    ) public pure override returns (uint256 reward) {
        // calculate time weighted stake
        uint256 stakeUnits = stakeAmount.mul(stakeDuration);

        // calculate base reward
        // baseReward = unlockedRewards * stakeUnits / totalStakeUnits
        uint256 baseReward = 0;
        if (totalStakeUnits != 0) {
            // scale reward according to proportional weight
            baseReward = unlockedRewards.mul(stakeUnits).div(totalStakeUnits);
        }

        // calculate scaled reward
        // if no scaling or scaling period completed
        //   reward = baseReward
        // else
        //   minReward = baseReward * scalingFloor / scalingCeiling
        //   bonusReward = baseReward
        //                 * (scalingCeiling - scalingFloor) / scalingCeiling
        //                 * duration / scalingTime
        //   reward = minReward + bonusReward
        if (stakeDuration >= rewardScaling.time || rewardScaling.floor == rewardScaling.ceiling) {
            // no reward scaling applied
            reward = baseReward;
        } else {
            // calculate minimum reward using scaling floor
            uint256 minReward = baseReward.mul(rewardScaling.floor).div(rewardScaling.ceiling);

            // calculate bonus reward with vested portion of scaling factor
            uint256 bonusReward =
                baseReward
                    .mul(stakeDuration)
                    .mul(rewardScaling.ceiling.sub(rewardScaling.floor))
                    .div(rewardScaling.ceiling)
                    .div(rewardScaling.time);

            // add minimum reward and bonus reward
            reward = minReward.add(bonusReward);
        }

        // explicit return
        return reward;
    }

    /* admin functions */

    /// @notice Add funds to the Hypervisor
    /// access control: only admin
    /// state machine:
    ///   - can be called multiple times
    ///   - only online
    /// state scope:
    ///   - increase _hypervisor.rewardSharesOutstanding
    ///   - append to _hypervisor.rewardSchedules
    /// token transfer: transfer staking tokens from msg.sender to reward pool
    /// @param amount uint256 Amount of reward tokens to deposit
    /// @param duration uint256 Duration over which to linearly unlock rewards
    function fund(uint256 amount, uint256 duration) external onlyOwner onlyOnline {
        // validate duration
        require(duration != 0, ""Hypervisor: invalid duration"");

        // create new reward shares
        // if existing rewards on this Hypervisor
        //   mint new shares proportional to % change in rewards remaining
        //   newShares = remainingShares * newReward / remainingRewards
        // else
        //   mint new shares with BASE_SHARES_PER_WEI initial conversion rate
        //   store as fixed point number with same  of decimals as reward token
        uint256 newRewardShares;
        if (_hypervisor.rewardSharesOutstanding > 0) {
            uint256 remainingRewards = IERC20(_hypervisor.rewardToken).balanceOf(_hypervisor.rewardPool);
            newRewardShares = _hypervisor.rewardSharesOutstanding.mul(amount).div(remainingRewards);
        } else {
            newRewardShares = amount.mul(BASE_SHARES_PER_WEI);
        }

        // add reward shares to total
        _hypervisor.rewardSharesOutstanding = _hypervisor.rewardSharesOutstanding.add(newRewardShares);

        // store new reward schedule
        _hypervisor.rewardSchedules.push(RewardSchedule(duration, block.timestamp, newRewardShares));

        // transfer reward tokens to reward pool
        TransferHelper.safeTransferFrom(
            _hypervisor.rewardToken,
            msg.sender,
            _hypervisor.rewardPool,
            amount
        );

        // emit event
        emit HypervisorFunded(amount, duration);
    }

    /// @notice Add vault factory to whitelist
    /// @dev use this function to enable stakes to vaults coming from the specified
    ///      factory contract
    /// access control: only admin
    /// state machine:
    ///   - can be called multiple times
    ///   - not shutdown
    /// state scope:
    ///   - append to _vaultFactorySet
    /// token transfer: none
    /// @param factory address The address of the vault factory
    function registerVaultFactory(address factory) external onlyOwner notShutdown {
        // add factory to set
        require(_vaultFactorySet.add(factory), ""Hypervisor: vault factory already registered"");

        // emit event
        emit VaultFactoryRegistered(factory);
    }

    /// @notice Remove vault factory from whitelist
    /// @dev use this function to disable new stakes to vaults coming from the specified
    ///      factory contract.
    ///      note: vaults with existing stakes from this factory are sill able to unstake
    /// access control: only admin
    /// state machine:
    ///   - can be called multiple times
    ///   - not shutdown
    /// state scope:
    ///   - remove from _vaultFactorySet
    /// token transfer: none
    /// @param factory address The address of the vault factory
    function removeVaultFactory(address factory) external onlyOwner notShutdown {
        // remove factory from set
        require(_vaultFactorySet.remove(factory), ""Hypervisor: vault factory not registered"");

        // emit event
        emit VaultFactoryRemoved(factory);
    }

    /// @notice Register bonus token for distribution
    /// @dev use this function to enable distribution of any ERC20 held by the RewardPool contract
    /// access control: only admin
    /// state machine:
    ///   - can be called multiple times
    ///   - only online
    /// state scope:
    ///   - append to _bonusTokenSet
    /// token transfer: none
    /// @param bonusToken address The address of the bonus token
    function registerBonusToken(address bonusToken) external onlyOwner onlyOnline {
        // verify valid bonus token
        _validateAddress(bonusToken);

        // verify bonus token count
        require(_bonusTokenSet.length() < MAX_REWARD_TOKENS, ""Hypervisor: max bonus tokens reached "");

        // add token to set
        assert(_bonusTokenSet.add(bonusToken));

        // emit event
        emit BonusTokenRegistered(bonusToken);
    }

    /// @notice Rescue tokens from RewardPool
    /// @dev use this function to rescue tokens from RewardPool contract
    ///      without distributing to stakers or triggering emergency shutdown
    /// access control: only admin
    /// state machine:
    ///   - can be called multiple times
    ///   - only online
    /// state scope: none
    /// token transfer: transfer requested token from RewardPool to recipient
    /// @param token address The address of the token to rescue
    /// @param recipient address The address of the recipient
    /// @param amount uint256 The amount of tokens to rescue
    function rescueTokensFromRewardPool(
        address token,
        address recipient,
        uint256 amount
    ) external onlyOwner onlyOnline {
        // verify recipient
        _validateAddress(recipient);

        // check not attempting to unstake reward token
        require(token != _hypervisor.rewardToken, ""Hypervisor: invalid address"");

        // check not attempting to wthdraw bonus token
        require(!_bonusTokenSet.contains(token), ""Hypervisor: invalid address"");

        // transfer tokens to recipient
        IRewardPool(_hypervisor.rewardPool).sendERC20(token, recipient, amount);
    }

    /* user functions */

    /// @notice Stake tokens
    /// @dev anyone can stake to any vault if they have valid permission
    /// access control: anyone
    /// state machine:
    ///   - can be called multiple times
    ///   - only online
    ///   - when vault exists on this Hypervisor
    /// state scope:
    ///   - append to _vaults[vault].stakes
    ///   - increase _vaults[vault].totalStake
    ///   - increase _hypervisor.totalStake
    ///   - increase _hypervisor.totalStakeUnits
    ///   - increase _hypervisor.lastUpdate
    /// token transfer: transfer staking tokens from msg.sender to vault
    /// @param vault address The address of the vault to stake from
    /// @param amount uint256 The amount of staking tokens to stake
    function stake(
        address vault,
        uint256 amount,
        bytes calldata permission
    ) external override onlyOnline {
        // verify vault is valid
        require(isValidVault(vault), ""Hypervisor: vault is not registered"");

        // verify non-zero amount
        require(amount != 0, ""Hypervisor: no amount staked"");

        // fetch vault storage reference
        VaultData storage vaultData = _vaults[vault];

        // verify stakes boundary not reached
        require(
            vaultData.stakes.length < MAX_STAKES_PER_VAULT,
            ""Hypervisor: MAX_STAKES_PER_VAULT reached""
        );

        // update cached sum of stake units across all vaults
        _updateTotalStakeUnits();

        // store amount and timestamp
        vaultData.stakes.push(StakeData(amount, block.timestamp));

        // update cached total vault and Hypervisor amounts
        vaultData.totalStake = vaultData.totalStake.add(amount);
        // verify stake quantity without bounds
        require(
            stakeLimit == 0 || vaultData.totalStake <= stakeLimit,
            ""Hypervisor: Stake limit exceeded""
        );
        _hypervisor.totalStake = _hypervisor.totalStake.add(amount);

        // call lock on vault
        IUniversalVault(vault).lock(_hypervisor.stakingToken, amount, permission);

        // emit event
        emit Staked(vault, amount);
    }

    /// @notice Unstake staking tokens and claim reward
    /// @dev rewards can only be claimed when unstaking
    /// access control: only owner of vault
    /// state machine:
    ///   - when vault exists on this Hypervisor
    ///   - after stake from vault
    ///   - can be called multiple times while sufficient stake remains
    ///   - only online
    /// state scope:
    ///   - decrease _hypervisor.rewardSharesOutstanding
    ///   - decrease _hypervisor.totalStake
    ///   - increase _hypervisor.lastUpdate
    ///   - modify _hypervisor.totalStakeUnits
    ///   - modify _vaults[vault].stakes
    ///   - decrease _vaults[vault].totalStake
    /// token transfer:
    ///   - transfer reward tokens from reward pool to recipient
    ///   - transfer bonus tokens from reward pool to recipient
    /// @param vault address The vault to unstake from
    /// @param amount uint256 The amount of staking tokens to unstake
    function unstakeAndClaim(
        address vault,
        uint256 amount,
        bytes calldata permission
    ) external override onlyOnline {
        // fetch vault storage reference
        VaultData storage vaultData = _vaults[vault];

        // verify non-zero amount
        require(amount != 0, ""Hypervisor: no amount unstaked"");

        address recipient = IUniversalVault(vault).owner();

        // validate recipient
        _validateAddress(recipient);

        // check for sufficient vault stake amount
        require(vaultData.totalStake >= amount, ""Hypervisor: insufficient vault stake"");

        // check for sufficient Hypervisor stake amount
        // if this check fails, there is a bug in stake accounting
        assert(_hypervisor.totalStake >= amount);

        // update cached sum of stake units across all vaults
        _updateTotalStakeUnits();

        // get reward amount remaining
        uint256 remainingRewards = IERC20(_hypervisor.rewardToken).balanceOf(_hypervisor.rewardPool);

        // calculate vested portion of reward pool
        uint256 unlockedRewards =
            calculateUnlockedRewards(
                _hypervisor.rewardSchedules,
                remainingRewards,
                _hypervisor.rewardSharesOutstanding,
                block.timestamp
            );

        // calculate vault time weighted reward with scaling
        RewardOutput memory out =
            calculateRewardFromStakes(
                vaultData.stakes,
                amount,
                unlockedRewards,
                _hypervisor.totalStakeUnits,
                block.timestamp,
                _hypervisor.rewardScaling
            );

        // update stake data in storage
        if (out.newStakesCount == 0) {
            // all stakes have been unstaked
            delete vaultData.stakes;
        } else {
            // some stakes have been completely or partially unstaked
            // delete fully unstaked stakes
            while (vaultData.stakes.length > out.newStakesCount) vaultData.stakes.pop();
            // update partially unstaked stake
            vaultData.stakes[out.newStakesCount.sub(1)].amount = out.lastStakeAmount;
        }

        // update cached stake totals
        vaultData.totalStake = vaultData.totalStake.sub(amount);
        _hypervisor.totalStake = _hypervisor.totalStake.sub(amount);
        _hypervisor.totalStakeUnits = out.newTotalStakeUnits;

        // unlock staking tokens from vault
        IUniversalVault(vault).unlock(_hypervisor.stakingToken, amount, permission);

        // emit event
        emit Unstaked(vault, amount);

        // only perform on non-zero reward
        if (out.reward > 0) {
            // calculate shares to burn
            // sharesToBurn = sharesOutstanding * reward / remainingRewards
            uint256 sharesToBurn =
                _hypervisor.rewardSharesOutstanding.mul(out.reward).div(remainingRewards);

            // burn claimed shares
            _hypervisor.rewardSharesOutstanding = _hypervisor.rewardSharesOutstanding.sub(sharesToBurn);

            // transfer bonus tokens from reward pool to recipient
            if (_bonusTokenSet.length() > 0) {
                for (uint256 index = 0; index < _bonusTokenSet.length(); index++) {
                    // fetch bonus token address reference
                    address bonusToken = _bonusTokenSet.at(index);

                    // calculate bonus token amount
                    // bonusAmount = bonusRemaining * reward / remainingRewards
                    uint256 bonusAmount =
                        IERC20(bonusToken).balanceOf(_hypervisor.rewardPool).mul(out.reward).div(
                            remainingRewards
                        );

                    // transfer bonus token
                    IRewardPool(_hypervisor.rewardPool).sendERC20(bonusToken, recipient, bonusAmount);

                    // emit event
                    emit RewardClaimed(vault, recipient, bonusToken, bonusAmount);
                }
            }

            // transfer reward tokens from reward pool to recipient
            IRewardPool(_hypervisor.rewardPool).sendERC20(_hypervisor.rewardToken, recipient, out.reward);

            // emit event
            emit RewardClaimed(vault, recipient, _hypervisor.rewardToken, out.reward);
        }
    }

    /// @notice Exit Hypervisor without claiming reward
    /// @dev This function should never revert when correctly called by the vault.
    ///      A max number of stakes per vault is set with MAX_STAKES_PER_VAULT to
    ///      place an upper bound on the for loop in calculateTotalStakeUnits().
    /// access control: only callable by the vault directly
    /// state machine:
    ///   - when vault exists on this Hypervisor
    ///   - when active stake from this vault
    ///   - any power state
    /// state scope:
    ///   - decrease _hypervisor.totalStake
    ///   - increase _hypervisor.lastUpdate
    ///   - modify _hypervisor.totalStakeUnits
    ///   - delete _vaults[vault]
    /// token transfer: none
    function rageQuit() external override {
        // fetch vault storage reference
        VaultData storage _vaultData = _vaults[msg.sender];

        // revert if no active stakes
        require(_vaultData.stakes.length != 0, ""Hypervisor: no stake"");

        // update cached sum of stake units across all vaults
        _updateTotalStakeUnits();

        // emit event
        emit Unstaked(msg.sender, _vaultData.totalStake);

        // update cached totals
        _hypervisor.totalStake = _hypervisor.totalStake.sub(_vaultData.totalStake);
        _hypervisor.totalStakeUnits = _hypervisor.totalStakeUnits.sub(
            calculateTotalStakeUnits(_vaultData.stakes, block.timestamp)
        );

        // delete stake data
        delete _vaults[msg.sender];
    }

    /* convenience functions */

    function _updateTotalStakeUnits() private {
        // update cached totalStakeUnits
        _hypervisor.totalStakeUnits = getCurrentTotalStakeUnits();
        // update cached lastUpdate
        _hypervisor.lastUpdate = block.timestamp;
    }

    function _validateAddress(address target) private view {
        // sanity check target for potential input errors
        require(isValidAddress(target), ""Hypervisor: invalid address"");
    }

    function _truncateStakesArray(StakeData[] memory array, uint256 newLength)
        private
        pure
        returns (StakeData[] memory newArray)
    {
        newArray = new StakeData[](newLength);
        for (uint256 index = 0; index < newLength; index++) {
            newArray[index] = array[index];
        }
        return newArray;
    }
}
.
To complete the task,  you must write a response that appropriately solves the requested instruction based on your expertise and customer's needs.]

Given the user's task and the brainstorming ideas provided:
Task: ""Identify all potential DoS (Denial of Service) vulnerabilities in the provided Solidity smart contract."".
Ideas: ""DoS vulnerabilities can manifest in various forms in Solidity contracts, such as Gas Limit DoS, External Call DoS, Block Gas Limit DoS, and State Dependency DoS."".
As the Security Analyst, your primary objective is to conduct a comprehensive inspection of the provided contract code, with a particular focus on identifying vulnerabilities related to Denial of Service (DoS). DoS vulnerabilities can occur in the following cases:
1. When loops have an unbounded iteration count, leading to potential gas exhaustion.
2. When the contract makes external calls that can fail or consume excessive gas.
3. When the contract depends on certain state conditions that can be manipulated by an attacker to cause failures.
4. When an attacker can send high-gas transactions to consume most of the block's gas limit, making it difficult for other transactions to be included in the block.
Please conduct a thorough analysis, considering the following information:
1. Review the contract's code logic to identify any potential areas where unbounded loops might cause gas exhaustion.
2. Examine external calls in the contract and ensure they are handled properly to avoid excessive gas consumption or failures.
3. Analyze state-dependent logic to identify any potential manipulations that could cause DoS.
4. Consider the overall design of the contract to ensure it is resilient against high-gas transactions and other DoS tactics.
If you identify any DoS vulnerabilities, respond with: """,
