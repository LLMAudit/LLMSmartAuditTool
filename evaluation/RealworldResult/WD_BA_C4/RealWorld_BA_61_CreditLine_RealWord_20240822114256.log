[2024-22-08 11:42:56 INFO] **[Preprocessing]**

**ChatDev Starts** (20240822114256)

**Timestamp**: 20240822114256

**config_path**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/CompanyConfig/SmartContractBA/ChatChainConfig.json

**config_phase_path**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/CompanyConfig/SmartContractBA/PhaseConfig.json

**config_role_path**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/CompanyConfig/SmartContractBA/RoleConfig.json

**task_prompt**: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/utils/ReentrancyGuard.sol';
import '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';
import '../interfaces/IPriceOracle.sol';
import '../interfaces/IYield.sol';
import '../interfaces/ISavingsAccount.sol';
import '../SavingsAccount/SavingsAccountUtil.sol';
import '../interfaces/IStrategyRegistry.sol';

/**
 * @title Credit Line contract with Methods related to credit Line
 * @notice Implements the functions related to Credit Line
 * @author Sublime
 **/

contract CreditLine is ReentrancyGuard, OwnableUpgradeable {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    enum CreditLineStatus {
        NOT_CREATED,
        REQUESTED,
        ACTIVE,
        CLOSED,
        CANCELLED,
        LIQUIDATED
    }

    /**
     * @notice counter that tracks the number of credit lines created
     * @dev used to create unique identifier for credit lines
     **/
    uint256 public creditLineCounter;

    uint256 constant YEAR_IN_SECONDS = 365 days;

    struct CreditLineVariables {
        CreditLineStatus status;
        uint256 principal;
        uint256 totalInterestRepaid;
        uint256 lastPrincipalUpdateTime;
        uint256 interestAccruedTillLastPrincipalUpdate;
    }

    struct CreditLineConstants {
        address lender;
        address borrower;
        uint256 borrowLimit;
        uint256 idealCollateralRatio;
        uint256 borrowRate;
        address borrowAsset;
        address collateralAsset;
        bool autoLiquidation;
        bool requestByLender;
    }
    /**
     * @notice stores the collateral shares in a credit line per strategy
     * @dev creditLineId => Strategy => collateralShares
     **/
    mapping(uint256 => mapping(address => uint256)) public collateralShareInStrategy;

    /**
     * @notice stores the variables to maintain a credit line
     **/
    mapping(uint256 => CreditLineVariables) public creditLineVariables;

    /**
     * @notice stores the constants related to a credit line
     **/
    mapping(uint256 => CreditLineConstants) public creditLineConstants;

    /**
     * @notice stores the address of savings account contract
     **/
    address public savingsAccount;

    /**
     * @notice stores the address of price oracle contract
     **/
    address public priceOracle;

    /**
     * @notice stores the address of strategy registry contract
     **/
    address public strategyRegistry;

    /**
     * @notice stores the address of default strategy
     **/
    address public defaultStrategy;

    /**
     * @notice stores the fraction of borrowed amount charged as fee by protocol
     * @dev it is multiplied by 10**30
     **/
    uint256 public protocolFeeFraction;

    /**
     * @notice address where protocol fee is collected
     **/
    address public protocolFeeCollector;

    /**
     * @notice stores the fraction of amount liquidated given as reward to liquidator
     * @dev it is multiplied by 10**30
     **/
    uint256 public liquidatorRewardFraction;
    /**
     * @dev checks if Credit Line exists
     * @param _id identifier for the credit line
     **/
    modifier ifCreditLineExists(uint256 _id) {
        require(creditLineVariables[_id].status != CreditLineStatus.NOT_CREATED, 'Credit line does not exist');
        _;
    }

    /**
     * @dev checks if called by credit Line Borrower
     * @param _id creditLine identifier
     **/
    modifier onlyCreditLineBorrower(uint256 _id) {
        require(creditLineConstants[_id].borrower == msg.sender, 'Only credit line Borrower can access');
        _;
    }

    /**
     * @dev checks if called by credit Line Lender
     * @param _id creditLine identifier
     **/
    modifier onlyCreditLineLender(uint256 _id) {
        require(creditLineConstants[_id].lender == msg.sender, 'Only credit line Lender can access');
        _;
    }

    /**
     * @notice emitted when a collateral is deposited into credit line
     * @param id id of the credit line
     * @param amount amount of collateral deposited
     * @param strategy address of the strategy into which collateral is deposited
     */
    event CollateralDeposited(uint256 indexed id, uint256 amount, address indexed strategy);

    /**
     * @notice emitted when collateral is withdrawn from credit line
     * @param id id of the credit line
     * @param amount amount of collateral withdrawn
     */
    event CollateralWithdrawn(uint256 indexed id, uint256 amount);

    /**
     * @notice emitted when a request for new credit line is placed
     * @param id id of the credit line for which request was made
     * @param lender address of the lender for credit line
     * @param borrower address of the borrower for credit line
     */
    event CreditLineRequested(uint256 indexed id, address indexed lender, address indexed borrower);

    /**
     * @notice emitted when a credit line is liquidated
     * @param id id of the credit line which is liquidated
     * @param liquidator address of the liquidator
     */
    event CreditLineLiquidated(uint256 indexed id, address indexed liquidator);

    /**
     * @notice emitted when tokens are borrowed from credit line
     * @param id id of the credit line from which tokens are borrowed
     * @param borrowAmount amount of tokens borrowed
     */
    event BorrowedFromCreditLine(uint256 indexed id, uint256 borrowAmount);

    /**
     * @notice emitted when credit line is accepted
     * @param id id of the credit line that was accepted
     */
    event CreditLineAccepted(uint256 indexed id);

    /**
     * @notice emitted when credit line is completely repaid and reset
     * @param id id of the credit line that is reset
     */
    event CreditLineReset(uint256 indexed id);

    /**
     * @notice emitted when the credit line is partially repaid
     * @param id id of the credit line
     * @param repayAmount amount repaid
     */
    event PartialCreditLineRepaid(uint256 indexed id, uint256 repayAmount);

    /**
     * @notice emitted when the credit line is completely repaid
     * @param id id of the credit line
     * @param repayAmount amount repaid
     */
    event CompleteCreditLineRepaid(uint256 indexed id, uint256 repayAmount);

    /**
     * @notice emitted when the credit line is closed by one of the parties of credit line
     * @param id id of the credit line
     */
    event CreditLineClosed(uint256 indexed id);

    /**
     * @notice emitted when default strategy for the credit line is updated
     * @param defaultStrategy address of the strategy contract that is used as default by credit lines
     */
    event DefaultStrategyUpdated(address indexed defaultStrategy);

    /**
     * @notice emitted when the price oracle is updated
     * @param priceOracle address of the updated price oracle
     */
    event PriceOracleUpdated(address indexed priceOracle);

    /**
     * @notice emitted when the savings account address is updated
     * @param savingsAccount address of the updated savingsAccount
     */
    event SavingsAccountUpdated(address indexed savingsAccount);

    /**
     * @notice emitted when strategy registry address is updated
     * @param strategyRegistry address of the updated strategy registry
     */
    event StrategyRegistryUpdated(address indexed strategyRegistry);

    /**
     * @notice emitted when fee that protocol charges for credit line is updated
     * @param updatedProtocolFee updated value of protocolFeeFraction
     */
    event ProtocolFeeFractionUpdated(uint256 updatedProtocolFee);

    /**
     * @notice emitted when address which receives fee that protocol changes for pools is updated
     * @param updatedProtocolFeeCollector updated value of protocolFeeCollector
     */
    event ProtocolFeeCollectorUpdated(address indexed updatedProtocolFeeCollector);

    /**
     * @notice emitted when liquidatorRewardFraction is updated
     * @param liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator
     */
    event LiquidationRewardFractionUpdated(uint256 liquidatorRewardFraction);

    /**
     * @notice used to initialize the contract
     * @dev can only be called once during the life cycle of the contract
     * @param _defaultStrategy default strategy used in credit lines
     * @param _priceOracle address of the priceOracle
     * @param _savingsAccount address of  the savings account contract
     * @param _strategyRegistry address of the strategy registry contract
     * @param _owner address of owner who can change global variables
     * @param _protocolFeeFraction fraction of the fee charged by protocol
     * @param _protocolFeeCollector address to which protocol fee is charged to
     * @param _liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator
     */
    function initialize(
        address _defaultStrategy,
        address _priceOracle,
        address _savingsAccount,
        address _strategyRegistry,
        address _owner,
        uint256 _protocolFeeFraction,
        address _protocolFeeCollector,
        uint256 _liquidatorRewardFraction
    ) external initializer {
        OwnableUpgradeable.__Ownable_init();
        OwnableUpgradeable.transferOwnership(_owner);

        _updateDefaultStrategy(_defaultStrategy);
        _updatePriceOracle(_priceOracle);
        _updateSavingsAccount(_savingsAccount);
        _updateStrategyRegistry(_strategyRegistry);
        _updateProtocolFeeFraction(_protocolFeeFraction);
        _updateProtocolFeeCollector(_protocolFeeCollector);
        _updateLiquidatorRewardFraction(_liquidatorRewardFraction);
    }

    /**
     * @notice used to update the default strategy
     * @dev can only be updated by owner
     * @param _defaultStrategy address of the updated default strategy
     */
    function updateDefaultStrategy(address _defaultStrategy) external onlyOwner {
        _updateDefaultStrategy(_defaultStrategy);
    }

    function _updateDefaultStrategy(address _defaultStrategy) internal {
        defaultStrategy = _defaultStrategy;
        emit DefaultStrategyUpdated(_defaultStrategy);
    }

    /**
     * @notice used to update the price oracle
     * @dev can only be updated by owner
     * @param _priceOracle address of the updated price oracle
     */
    function updatePriceOracle(address _priceOracle) external onlyOwner {
        _updatePriceOracle(_priceOracle);
    }

    function _updatePriceOracle(address _priceOracle) internal {
        priceOracle = _priceOracle;
        emit PriceOracleUpdated(_priceOracle);
    }

    /**
     * @notice used to update the savings account address
     * @dev can only be updated by owner
     * @param _savingsAccount address of the updated savings account
     */
    function updateSavingsAccount(address _savingsAccount) external onlyOwner {
        _updateSavingsAccount(_savingsAccount);
    }

    function _updateSavingsAccount(address _savingsAccount) internal {
        savingsAccount = _savingsAccount;
        emit SavingsAccountUpdated(_savingsAccount);
    }

    /**
     * @notice used to update the protocol fee fraction
     * @dev can only be updated by owner
     * @param _protocolFee fraction of the borrower amount collected as protocol fee
     */
    function updateProtocolFeeFraction(uint256 _protocolFee) external onlyOwner {
        _updateProtocolFeeFraction(_protocolFee);
    }

    function _updateProtocolFeeFraction(uint256 _protocolFee) internal {
        protocolFeeFraction = _protocolFee;
        emit ProtocolFeeFractionUpdated(_protocolFee);
    }

    /**
     * @notice used to update the protocol fee collector
     * @dev can only be updated by owner
     * @param _protocolFeeCollector address in which protocol fee is collected
     */
    function updateProtocolFeeCollector(address _protocolFeeCollector) external onlyOwner {
        _updateProtocolFeeCollector(_protocolFeeCollector);
    }

    function _updateProtocolFeeCollector(address _protocolFeeCollector) internal {
        require(_protocolFeeCollector != address(0), 'cant be 0 address');
        protocolFeeCollector = _protocolFeeCollector;
        emit ProtocolFeeCollectorUpdated(_protocolFeeCollector);
    }

    /**
     * @notice used to update the strategy registry address
     * @dev can only be updated by owner
     * @param _strategyRegistry address of the updated strategy registry
     */
    function updateStrategyRegistry(address _strategyRegistry) external onlyOwner {
        _updateStrategyRegistry(_strategyRegistry);
    }

    function _updateStrategyRegistry(address _strategyRegistry) internal {
        require(_strategyRegistry != address(0), 'CL::I zero address');
        strategyRegistry = _strategyRegistry;
        emit StrategyRegistryUpdated(_strategyRegistry);
    }

    /**
     * @notice used to update the liquidatorRewardFraction
     * @dev can only be updated by owner
     * @param _rewardFraction fraction of liquidated amount given to liquidator as reward
     */
    function updateLiquidatorRewardFraction(uint256 _rewardFraction) external onlyOwner {
        _updateLiquidatorRewardFraction(_rewardFraction);
    }

    function _updateLiquidatorRewardFraction(uint256 _rewardFraction) internal {
        require(_rewardFraction <= 10**30, 'Fraction has to be less than 1');
        liquidatorRewardFraction = _rewardFraction;
        emit LiquidationRewardFractionUpdated(_rewardFraction);
    }

    /**
     * @dev Used to Calculate Interest Per second on given principal and Interest rate
     * @param _principal principal Amount for which interest has to be calculated.
     * @param _borrowRate It is the Interest Rate at which Credit Line is approved
     * @return interest per second for the given parameters
     */
    function calculateInterest(
        uint256 _principal,
        uint256 _borrowRate,
        uint256 _timeElapsed
    ) public pure returns (uint256) {
        uint256 _interest = _principal.mul(_borrowRate).mul(_timeElapsed).div(10**30).div(YEAR_IN_SECONDS);

        return _interest;
    }

    /**
     * @dev Used to calculate interest accrued since last repayment
     * @param _id identifier for the credit line
     * @return interest accrued over current borrowed amount since last repayment
     */

    function calculateInterestAccrued(uint256 _id) public view returns (uint256) {
        uint256 _lastPrincipalUpdateTime = creditLineVariables[_id].lastPrincipalUpdateTime;
        if (_lastPrincipalUpdateTime == 0) return 0;
        uint256 _timeElapsed = (block.timestamp).sub(_lastPrincipalUpdateTime);
        uint256 _interestAccrued = calculateInterest(creditLineVariables[_id].principal, creditLineConstants[_id].borrowRate, _timeElapsed);
        return _interestAccrued;
    }

    /**
     * @dev Used to calculate current debt of borrower against a credit line.
     * @param _id identifier for the credit line
     * @return current debt of borrower
     */
    function calculateCurrentDebt(uint256 _id) public view returns (uint256) {
        uint256 _interestAccrued = calculateInterestAccrued(_id);
        uint256 _currentDebt = (creditLineVariables[_id].principal)
            .add(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate)
            .add(_interestAccrued)
            .sub(creditLineVariables[_id].totalInterestRepaid);
        return _currentDebt;
    }

    /**
     * @notice used to calculate amount that can be borrowed by the borrower
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view.
            borrowableAmount changes per block as interest changes per block.
     * @param _id identifier for the credit line
     * @return amount that can be borrowed from the credit line
     */
    function calculateBorrowableAmount(uint256 _id) public returns (uint256) {
        CreditLineStatus _status = creditLineVariables[_id].status;
        require(
            _status == CreditLineStatus.ACTIVE || _status == CreditLineStatus.REQUESTED,
            'CreditLine: Cannot only if credit line ACTIVE or REQUESTED'
        );
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(
            creditLineConstants[_id].collateralAsset,
            creditLineConstants[_id].borrowAsset
        );

        uint256 _totalCollateralToken = calculateTotalCollateralTokens(_id);

        uint256 _currentDebt = calculateCurrentDebt(_id);

        uint256 _maxPossible = _totalCollateralToken.mul(_ratioOfPrices).div(creditLineConstants[_id].idealCollateralRatio).mul(10**30).div(
            10**_decimals
        );

        uint256 _borrowLimit = creditLineConstants[_id].borrowLimit;

        if (_maxPossible > _borrowLimit) {
            _maxPossible = _borrowLimit;
        }
        if (_maxPossible > _currentDebt) {
            return _maxPossible.sub(_currentDebt);
        }
        return 0;
    }

    function updateinterestAccruedTillLastPrincipalUpdate(uint256 _id) internal {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');

        uint256 _interestAccrued = calculateInterestAccrued(_id);
        uint256 _newInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(_interestAccrued);
        creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _newInterestAccrued;
    }

    function _depositCollateralFromSavingsAccount(
        uint256 _id,
        uint256 _amount,
        address _sender
    ) internal {
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        uint256 _activeAmount;

        for (uint256 _index = 0; _index < _strategyList.length; _index++) {
            address _strategy = _strategyList[_index];
            uint256 _liquidityShares = _savingsAccount.balanceInShares(_sender, _collateralAsset, _strategy);
            if (_liquidityShares == 0 || _strategyList[_index] == address(0)) {
                continue;
            }
            uint256 _tokenInStrategy = _liquidityShares;
            _tokenInStrategy = IYield(_strategy).getTokensForShares(_liquidityShares, _collateralAsset);

            uint256 _tokensToTransfer = _tokenInStrategy;
            if (_activeAmount.add(_tokenInStrategy) >= _amount) {
                _tokensToTransfer = (_amount.sub(_activeAmount));
            }
            _activeAmount = _activeAmount.add(_tokensToTransfer);
            _savingsAccount.transferFrom(_tokensToTransfer, _collateralAsset, _strategy, _sender, address(this));

            collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(
                _liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy)
            );

            if (_amount == _activeAmount) {
                return;
            }
        }
        revert('CreditLine::_depositCollateralFromSavingsAccount - Insufficient balance');
    }

    /**
     * @notice used to request a credit line either by borrower or lender
     * @param _requestTo Address to which creditLine is requested, 
                        if borrower creates request then lender address and 
                        if lender creates then borrower address
     * @param _borrowLimit maximum borrow amount in a credit line
     * @param _borrowRate Interest Rate at which credit Line is requested
     * @param _autoLiquidation if true, anyone can liquidate loan, otherwise only lender
     * @param _collateralRatio ratio of the collateral to the debt below which credit line can be liquidated
     * @param _borrowAsset address of the token to be borrowed
     * @param _collateralAsset address of the token provided as collateral
     * @param _requestAsLender if true, lender is placing request, otherwise borrower
     * @return identifier for the credit line
     */

    function request(
        address _requestTo,
        uint256 _borrowLimit,
        uint256 _borrowRate,
        bool _autoLiquidation,
        uint256 _collateralRatio,
        address _borrowAsset,
        address _collateralAsset,
        bool _requestAsLender
    ) external returns (uint256) {
        require(_borrowAsset != _collateralAsset, 'R: cant borrow lent token');
        require(IPriceOracle(priceOracle).doesFeedExist(_borrowAsset, _collateralAsset), 'R: No price feed');

        address _lender = _requestTo;
        address _borrower = msg.sender;
        if (_requestAsLender) {
            _lender = msg.sender;
            _borrower = _requestTo;
        }

        uint256 _id = _createRequest(
            _lender,
            _borrower,
            _borrowLimit,
            _borrowRate,
            _autoLiquidation,
            _collateralRatio,
            _borrowAsset,
            _collateralAsset,
            _requestAsLender
        );

        emit CreditLineRequested(_id, _lender, _borrower);
        return _id;
    }

    function _createRequest(
        address _lender,
        address _borrower,
        uint256 _borrowLimit,
        uint256 _borrowRate,
        bool _autoLiquidation,
        uint256 _collateralRatio,
        address _borrowAsset,
        address _collateralAsset,
        bool _requestByLender
    ) internal returns (uint256) {
        require(_lender != _borrower, 'Lender and Borrower cannot be same addresses');
        uint256 _id = creditLineCounter + 1;
        creditLineCounter = _id;
        creditLineVariables[_id].status = CreditLineStatus.REQUESTED;
        creditLineConstants[_id].borrower = _borrower;
        creditLineConstants[_id].lender = _lender;
        creditLineConstants[_id].borrowLimit = _borrowLimit;
        creditLineConstants[_id].autoLiquidation = _autoLiquidation;
        creditLineConstants[_id].idealCollateralRatio = _collateralRatio;
        creditLineConstants[_id].borrowRate = _borrowRate;
        creditLineConstants[_id].borrowAsset = _borrowAsset;
        creditLineConstants[_id].collateralAsset = _collateralAsset;
        creditLineConstants[_id].requestByLender = _requestByLender;
        return _id;
    }

    /**
     * @notice used to accept a credit line
     * @dev if borrower places request, lender can accept and vice versa
     * @param _id identifier for the credit line
     */
    function accept(uint256 _id) external {
        require(
            creditLineVariables[_id].status == CreditLineStatus.REQUESTED,
            'CreditLine::acceptCreditLineLender - CreditLine is already accepted'
        );
        bool _requestByLender = creditLineConstants[_id].requestByLender;
        require(
            (msg.sender == creditLineConstants[_id].borrower && _requestByLender) ||
                (msg.sender == creditLineConstants[_id].lender && !_requestByLender),
            "Only Borrower or Lender who hasn't requested can accept"
        );
        creditLineVariables[_id].status = CreditLineStatus.ACTIVE;
        emit CreditLineAccepted(_id);
    }

    /**
     * @notice used to deposit collateral into the credit line
     * @dev collateral tokens have to be approved in savingsAccount or token contract(unless ether).
            If transferred from savings account, the tokens are transferred from strategies in the 
            order prespecified in strategy registry
     * @param _id identifier for the credit line
     * @param _amount amount of collateral being deposited
     * @param _strategy strategy to which collateral is to be deposited in case transfer is not from savings account
     * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount 
                                otherwise direct from collateral token contract
     */
    function depositCollateral(
        uint256 _id,
        uint256 _amount,
        address _strategy,
        bool _fromSavingsAccount
    ) external payable nonReentrant ifCreditLineExists(_id) {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine not active');
        _depositCollateral(_id, _amount, _strategy, _fromSavingsAccount);
        emit CollateralDeposited(_id, _amount, _strategy);
    }

    function _depositCollateral(
        uint256 _id,
        uint256 _amount,
        address _strategy,
        bool _fromSavingsAccount
    ) internal {
        require(creditLineConstants[_id].lender != msg.sender, 'lender cant deposit collateral');
        if (_fromSavingsAccount) {
            _depositCollateralFromSavingsAccount(_id, _amount, msg.sender);
        } else {
            address _collateralAsset = creditLineConstants[_id].collateralAsset;
            ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
            if (_collateralAsset == address(0)) {
                require(msg.value == _amount, "CreditLine::_depositCollateral - value to transfer doesn't match argument");
            } else {
                IERC20(_collateralAsset).safeTransferFrom(msg.sender, address(this), _amount);
                IERC20(_collateralAsset).approve(_strategy, _amount);
            }
            uint256 _sharesReceived = _savingsAccount.deposit{value: msg.value}(_amount, _collateralAsset, _strategy, address(this));
            collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(_sharesReceived);
        }
    }

    function _withdrawBorrowAmount(
        address _asset,
        uint256 _amountInTokens,
        address _lender
    ) internal {
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        uint256 _activeAmount;
        for (uint256 _index = 0; _index < _strategyList.length; _index++) {
            if (_strategyList[_index] == address(0)) {
                continue;
            }
            uint256 _liquidityShares = _savingsAccount.balanceInShares(_lender, _asset, _strategyList[_index]);
            if (_liquidityShares != 0) {
                uint256 tokenInStrategy = _liquidityShares;
                tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);
                uint256 _tokensToTransfer = tokenInStrategy;
                if (_activeAmount.add(tokenInStrategy) >= _amountInTokens) {
                    _tokensToTransfer = (_amountInTokens.sub(_activeAmount));
                }
                _activeAmount = _activeAmount.add(_tokensToTransfer);
                _savingsAccount.withdrawFrom(_tokensToTransfer, _asset, _strategyList[_index], _lender, address(this), false);
                if (_activeAmount == _amountInTokens) {
                    return;
                }
            }
        }
        require(_activeAmount == _amountInTokens, 'insufficient balance');
    }

    /**
     * @notice used to borrow tokens from credit line by borrower
     * @dev only borrower can call this function. Amount that can actually be borrowed is 
            min(amount based on borrowLimit, allowance to creditLine contract, balance of lender)
     * @param _id identifier for the credit line
     * @param _amount amount of tokens to borrow
     */
    function borrow(uint256 _id, uint256 _amount) external payable nonReentrant onlyCreditLineBorrower(_id) {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');
        uint256 _borrowableAmount = calculateBorrowableAmount(_id);
        require(_amount <= _borrowableAmount, "CreditLine::borrow - The current collateral ratio doesn't allow to withdraw the amount");
        address _borrowAsset = creditLineConstants[_id].borrowAsset;
        address _lender = creditLineConstants[_id].lender;

        updateinterestAccruedTillLastPrincipalUpdate(_id);
        creditLineVariables[_id].principal = creditLineVariables[_id].principal.add(_amount);
        creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;

        uint256 _tokenDiffBalance;
        if (_borrowAsset != address(0)) {
            uint256 _balanceBefore = IERC20(_borrowAsset).balanceOf(address(this));
            _withdrawBorrowAmount(_borrowAsset, _amount, _lender);
            uint256 _balanceAfter = IERC20(_borrowAsset).balanceOf(address(this));
            _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);
        } else {
            uint256 _balanceBefore = address(this).balance;
            _withdrawBorrowAmount(_borrowAsset, _amount, _lender);
            uint256 _balanceAfter = address(this).balance;
            _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);
        }
        uint256 _protocolFee = _tokenDiffBalance.mul(protocolFeeFraction).div(10**30);
        _tokenDiffBalance = _tokenDiffBalance.sub(_protocolFee);

        if (_borrowAsset == address(0)) {
            (bool feeSuccess, ) = protocolFeeCollector.call{value: _protocolFee}('');
            require(feeSuccess, 'Transfer fail');
            (bool success, ) = msg.sender.call{value: _tokenDiffBalance}('');
            require(success, 'Transfer fail');
        } else {
            IERC20(_borrowAsset).safeTransfer(protocolFeeCollector, _protocolFee);
            IERC20(_borrowAsset).safeTransfer(msg.sender, _tokenDiffBalance);
        }
        emit BorrowedFromCreditLine(_id, _tokenDiffBalance);
    }

    function _repayFromSavingsAccount(
        uint256 _amount,
        address _asset,
        address _lender
    ) internal {
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        uint256 _activeAmount;

        for (uint256 _index = 0; _index < _strategyList.length; _index++) {
            if (_strategyList[_index] == address(0)) {
                continue;
            }
            uint256 _liquidityShares = _savingsAccount.balanceInShares(msg.sender, _asset, _strategyList[_index]);
            if (_liquidityShares == 0) {
                continue;
            }
            uint256 _tokenInStrategy = _liquidityShares;
            _tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);

            uint256 _tokensToTransfer = _tokenInStrategy;
            if (_activeAmount.add(_tokenInStrategy) >= _amount) {
                _tokensToTransfer = (_amount.sub(_activeAmount));
            }
            _activeAmount = _activeAmount.add(_tokensToTransfer);
            _savingsAccount.transferFrom(_tokensToTransfer, _asset, _strategyList[_index], msg.sender, _lender);

            if (_amount == _activeAmount) {
                return;
            }
        }
        revert('CreditLine::_repayFromSavingsAccount - Insufficient balance');
    }

    function _repay(
        uint256 _id,
        uint256 _amount,
        bool _fromSavingsAccount,
        uint256 _principalPaid
    ) internal {
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        address _defaultStrategy = defaultStrategy;
        address _borrowAsset = creditLineConstants[_id].borrowAsset;
        address _lender = creditLineConstants[_id].lender;
        if (!_fromSavingsAccount) {
            if (_borrowAsset == address(0)) {
                require(msg.value == _amount, 'creditLine::repay - Ether sent not equal to repay amount');
                _savingsAccount.deposit{value: _amount}(_amount, _borrowAsset, _defaultStrategy, _lender);
            } else {
                IERC20(_borrowAsset).safeTransferFrom(msg.sender, address(this), _amount);
                IERC20(_borrowAsset).approve(_defaultStrategy, _amount);
                _savingsAccount.deposit(_amount, _borrowAsset, _defaultStrategy, _lender);
            }
        } else {
            _repayFromSavingsAccount(_amount, _borrowAsset, _lender);
        }
        if (_principalPaid != 0) {
            _savingsAccount.increaseAllowanceToCreditLine(_principalPaid, _borrowAsset, _lender);
        }
    }

    /**
     * @notice used to repay interest and principal to credit line. Interest has to be repaid before repaying principal
     * @dev partial repayments possible
     * @param _id identifier for the credit line
     * @param _amount amount being repaid
     * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount 
                                otherwise direct from collateral token contract
     */
    function repay(
        uint256 _id,
        uint256 _amount,
        bool _fromSavingsAccount
    ) external payable nonReentrant {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');
        require(creditLineConstants[_id].lender != msg.sender, 'Lender cant repay');

        uint256 _interestSincePrincipalUpdate = calculateInterestAccrued(_id);
        uint256 _totalInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(
            _interestSincePrincipalUpdate
        );
        uint256 _interestToPay = _totalInterestAccrued.sub(creditLineVariables[_id].totalInterestRepaid);
        uint256 _totalCurrentDebt = _interestToPay.add(creditLineVariables[_id].principal);
        uint256 _principalPaid = 0;

        if (_amount >= _totalCurrentDebt) {
            _amount = _totalCurrentDebt;
            emit CompleteCreditLineRepaid(_id, _amount);
        } else {
            emit PartialCreditLineRepaid(_id, _amount);
        }

        if (_amount > _interestToPay) {
            creditLineVariables[_id].principal = _totalCurrentDebt.sub(_amount);
            creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _totalInterestAccrued;
            creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;
            creditLineVariables[_id].totalInterestRepaid = _totalInterestAccrued;
            _principalPaid = _amount.sub(_interestToPay);
        } else {
            creditLineVariables[_id].totalInterestRepaid = creditLineVariables[_id].totalInterestRepaid.add(_amount);
        }

        _repay(_id, _amount, _fromSavingsAccount, _principalPaid);

        if (creditLineVariables[_id].principal == 0) {
            _resetCreditLine(_id);
        }
    }

    function _resetCreditLine(uint256 _id) internal {
        creditLineVariables[_id].lastPrincipalUpdateTime = 0;
        creditLineVariables[_id].totalInterestRepaid = 0;
        creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = 0;
        emit CreditLineReset(_id);
    }

    /**
     * @dev used to close credit line by borrower or lender
     * @param _id identifier for the credit line
     */
    function close(uint256 _id) external ifCreditLineExists(_id) {
        require(
            msg.sender == creditLineConstants[_id].borrower || msg.sender == creditLineConstants[_id].lender,
            'CreditLine: Permission denied while closing Line of credit'
        );
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: Credit line should be active.');
        require(creditLineVariables[_id].principal == 0, 'CreditLine: Cannot be closed since not repaid.');
        require(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate == 0, 'CreditLine: Cannot be closed since not repaid.');
        creditLineVariables[_id].status = CreditLineStatus.CLOSED;
        emit CreditLineClosed(_id);
    }

    /**
     * @notice used to calculate the current collateral ratio
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view.
            Interest is also considered while calculating debt
     * @param _id identifier for the credit line
     * @return collateral ratio multiplied by 10**30 to retain precision
     */
    function calculateCurrentCollateralRatio(uint256 _id) public ifCreditLineExists(_id) returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(
            creditLineConstants[_id].collateralAsset,
            creditLineConstants[_id].borrowAsset
        );

        uint256 currentDebt = calculateCurrentDebt(_id);
        uint256 currentCollateralRatio = calculateTotalCollateralTokens(_id).mul(_ratioOfPrices).div(currentDebt).mul(10**30).div(
            10**_decimals
        );

        return currentCollateralRatio;
    }

    /**
     * @notice used to calculate the total collateral tokens
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @param _id identifier for the credit line
     * @return _amount total collateral tokens deposited into the credit line
     */
    function calculateTotalCollateralTokens(uint256 _id) public returns (uint256 _amount) {
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        uint256 _liquidityShares;
        for (uint256 index = 0; index < _strategyList.length; index++) {
            if (_strategyList[index] == address(0)) {
                continue;
            }
            _liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];
            uint256 _tokenInStrategy = _liquidityShares;
            _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(_liquidityShares, _collateralAsset);

            _amount = _amount.add(_tokenInStrategy);
        }
    }

    /**
     * @notice used to withdraw any excess collateral
     * @dev collateral can't be withdraw if collateralRatio goes below the ideal value. Only borrower can withdraw
     * @param _id identifier for the credit line
     * @param _amount amount of collateral to withdraw
     * @param _toSavingsAccount if true, tokens are transferred from savingsAccount 
                                otherwise direct from collateral token contract
     */
    function withdrawCollateral(
        uint256 _id,
        uint256 _amount,
        bool _toSavingsAccount
    ) external nonReentrant onlyCreditLineBorrower(_id) {
        uint256 _withdrawableCollateral = withdrawableCollateral(_id);
        require(_amount <= _withdrawableCollateral, 'Collateral ratio cant go below ideal');
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        _transferCollateral(_id, _collateralAsset, _amount, _toSavingsAccount);
        emit CollateralWithdrawn(_id, _amount);
    }

    /**
     * @notice used to calculate the collateral that can be withdrawn
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @param _id identifier for the credit line
     * @return total collateral withdrawable by borrower
     */
    function withdrawableCollateral(uint256 _id) public returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(
            creditLineConstants[_id].collateralAsset,
            creditLineConstants[_id].borrowAsset
        );

        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);
        uint256 _currentDebt = calculateCurrentDebt(_id);

        uint256 _collateralNeeded = _currentDebt
            .mul(creditLineConstants[_id].idealCollateralRatio)
            .div(_ratioOfPrices)
            .mul(10**_decimals)
            .div(10**30);

        if (_collateralNeeded >= _totalCollateralTokens) {
            return 0;
        }
        return _totalCollateralTokens.sub(_collateralNeeded);
    }

    function _transferCollateral(
        uint256 _id,
        address _asset,
        uint256 _amountInTokens,
        bool _toSavingsAccount
    ) internal {
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        uint256 _activeAmount;
        for (uint256 index = 0; index < _strategyList.length; index++) {
            uint256 liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];
            if (liquidityShares == 0 || _strategyList[index] == address(0)) {
                continue;
            }
            uint256 _tokenInStrategy = liquidityShares;
            _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(liquidityShares, _asset);
            uint256 _tokensToTransfer = _tokenInStrategy;
            if (_activeAmount.add(_tokenInStrategy) > _amountInTokens) {
                _tokensToTransfer = _amountInTokens.sub(_activeAmount);
                liquidityShares = liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy);
            }
            _activeAmount = _activeAmount.add(_tokensToTransfer);
            collateralShareInStrategy[_id][_strategyList[index]] = collateralShareInStrategy[_id][_strategyList[index]].sub(
                liquidityShares
            );
            if (_toSavingsAccount) {
                ISavingsAccount(savingsAccount).transfer(_tokensToTransfer, _asset, _strategyList[index], msg.sender);
            } else {
                ISavingsAccount(savingsAccount).withdraw(_tokensToTransfer, _asset, _strategyList[index], msg.sender, false);
            }

            if (_activeAmount == _amountInTokens) {
                return;
            }
        }
        revert('insufficient collateral');
    }

    /**
     * @notice used to liquidate credit line in case collateral ratio goes below the threshold
     * @dev if lender liquidates, then collateral is directly transferred. 
            If autoLiquidation is true, anyone can liquidate by providing enough borrow tokens
     * @param _id identifier for the credit line
     * @param _toSavingsAccount if true, tokens are transferred from savingsAccount 
                                otherwise direct from collateral token contract
     */
    function liquidate(uint256 _id, bool _toSavingsAccount) external payable nonReentrant {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: Credit line should be active.');
        require(creditLineVariables[_id].principal != 0, 'CreditLine: cannot liquidate if principal is 0');

        uint256 currentCollateralRatio = calculateCurrentCollateralRatio(_id);
        require(
            currentCollateralRatio < creditLineConstants[_id].idealCollateralRatio,
            'CreditLine: Collateral ratio is higher than ideal value'
        );

        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        address _lender = creditLineConstants[_id].lender;
        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);
        address _borrowAsset = creditLineConstants[_id].borrowAsset;

        creditLineVariables[_id].status = CreditLineStatus.LIQUIDATED;

        if (creditLineConstants[_id].autoLiquidation && _lender != msg.sender) {
            uint256 _borrowTokens = _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens);
            if (_borrowAsset == address(0)) {
                uint256 _returnETH = msg.value.sub(_borrowTokens, 'Insufficient ETH to liquidate');
                if (_returnETH != 0) {
                    (bool success, ) = msg.sender.call{value: _returnETH}('');
                    require(success, 'Transfer fail');
                }
            } else {
                IERC20(_borrowAsset).safeTransferFrom(msg.sender, _lender, _borrowTokens);
            }
        }

        _transferCollateral(_id, _collateralAsset, _totalCollateralTokens, _toSavingsAccount);

        emit CreditLineLiquidated(_id, msg.sender);
    }

    /**
     * @notice used to calculate the borrow tokens necessary for liquidator to liquidate
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @param _id identifier for the credit line
     * @return borrow tokens necessary for liquidator to liquidate
     */
    function borrowTokensToLiquidate(uint256 _id) external returns (uint256) {
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);
        address _borrowAsset = creditLineConstants[_id].borrowAsset;

        return _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens);
    }

    function _borrowTokensToLiquidate(
        address _borrowAsset,
        address _collateralAsset,
        uint256 _totalCollateralTokens
    ) internal view returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(_borrowAsset, _collateralAsset);
        uint256 _borrowTokens = (
            _totalCollateralTokens.mul(uint256(10**30).sub(liquidatorRewardFraction)).div(10**30).mul(_ratioOfPrices).div(10**_decimals)
        );

        return _borrowTokens;
    }

    receive() external payable {
        require(msg.sender == savingsAccount, 'CreditLine::receive invalid transaction');
    }
}


**project_name**: RealWorld_BA_61_CreditLine

**Log File**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/WareHouse/RealWorld_BA_61_CreditLine_RealWord_20240822114256.log

**ChatDevConfig**:
ChatEnvConfig.with_memory: False
ChatEnvConfig.clear_structure: True
ChatEnvConfig.git_management: False
ChatEnvConfig.gui_design: True
ChatEnvConfig.incremental_develop: False
ChatEnvConfig.background_prompt: We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.


**ChatGPTConfig**:
ChatGPTConfig(temperature=0.2, top_p=1.0, n=1, stream=False, stop=None, max_tokens=None, presence_penalty=0.0, frequency_penalty=0.0, logit_bias={}, user='')



[2024-22-08 11:42:57 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol'; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/utils/ReentrancyGuard.sol'; import '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol'; import '../interfaces/IPriceOracle.sol'; import '../interfaces/IYield.sol'; import '../interfaces/ISavingsAccount.sol'; import '../SavingsAccount/SavingsAccountUtil.sol'; import '../interfaces/IStrategyRegistry.sol'; /  * @title Credit Line contract with Methods related to credit Line  * @notice Implements the functions related to Credit Line  * @author Sublime  / contract CreditLine is ReentrancyGuard, OwnableUpgradeable {     using SafeERC20 for IERC20;     using SafeMath for uint256; enum CreditLineStatus {     NOT_CREATED,     REQUESTED,     ACTIVE,     CLOSED,     CANCELLED,     LIQUIDATED }  /**  * @notice counter that tracks the number of credit lines created  * @dev used to create unique identifier for credit lines  **/ uint256 public creditLineCounter;  uint256 constant YEAR_IN_SECONDS = 365 days;  struct CreditLineVariables {     CreditLineStatus status;     uint256 principal;     uint256 totalInterestRepaid;     uint256 lastPrincipalUpdateTime;     uint256 interestAccruedTillLastPrincipalUpdate; }  struct CreditLineConstants {     address lender;     address borrower;     uint256 borrowLimit;     uint256 idealCollateralRatio;     uint256 borrowRate;     address borrowAsset;     address collateralAsset;     bool autoLiquidation;     bool requestByLender; } /**  * @notice stores the collateral shares in a credit line per strategy  * @dev creditLineId =&gt; Strategy =&gt; collateralShares  **/ mapping(uint256 =&gt; mapping(address =&gt; uint256)) public collateralShareInStrategy;  /**  * @notice stores the variables to maintain a credit line  **/ mapping(uint256 =&gt; CreditLineVariables) public creditLineVariables;  /**  * @notice stores the constants related to a credit line  **/ mapping(uint256 =&gt; CreditLineConstants) public creditLineConstants;  /**  * @notice stores the address of savings account contract  **/ address public savingsAccount;  /**  * @notice stores the address of price oracle contract  **/ address public priceOracle;  /**  * @notice stores the address of strategy registry contract  **/ address public strategyRegistry;  /**  * @notice stores the address of default strategy  **/ address public defaultStrategy;  /**  * @notice stores the fraction of borrowed amount charged as fee by protocol  * @dev it is multiplied by 10**30  **/ uint256 public protocolFeeFraction;  /**  * @notice address where protocol fee is collected  **/ address public protocolFeeCollector;  /**  * @notice stores the fraction of amount liquidated given as reward to liquidator  * @dev it is multiplied by 10**30  **/ uint256 public liquidatorRewardFraction; /**  * @dev checks if Credit Line exists  * @param _id identifier for the credit line  **/ modifier ifCreditLineExists(uint256 _id) {     require(creditLineVariables[_id].status != CreditLineStatus.NOT_CREATED, 'Credit line does not exist');     _; }  /**  * @dev checks if called by credit Line Borrower  * @param _id creditLine identifier  **/ modifier onlyCreditLineBorrower(uint256 _id) {     require(creditLineConstants[_id].borrower == msg.sender, 'Only credit line Borrower can access');     _; }  /**  * @dev checks if called by credit Line Lender  * @param _id creditLine identifier  **/ modifier onlyCreditLineLender(uint256 _id) {     require(creditLineConstants[_id].lender == msg.sender, 'Only credit line Lender can access');     _; }  /**  * @notice emitted when a collateral is deposited into credit line  * @param id id of the credit line  * @param amount amount of collateral deposited  * @param strategy address of the strategy into which collateral is deposited  */ event CollateralDeposited(uint256 indexed id, uint256 amount, address indexed strategy);  /**  * @notice emitted when collateral is withdrawn from credit line  * @param id id of the credit line  * @param amount amount of collateral withdrawn  */ event CollateralWithdrawn(uint256 indexed id, uint256 amount);  /**  * @notice emitted when a request for new credit line is placed  * @param id id of the credit line for which request was made  * @param lender address of the lender for credit line  * @param borrower address of the borrower for credit line  */ event CreditLineRequested(uint256 indexed id, address indexed lender, address indexed borrower);  /**  * @notice emitted when a credit line is liquidated  * @param id id of the credit line which is liquidated  * @param liquidator address of the liquidator  */ event CreditLineLiquidated(uint256 indexed id, address indexed liquidator);  /**  * @notice emitted when tokens are borrowed from credit line  * @param id id of the credit line from which tokens are borrowed  * @param borrowAmount amount of tokens borrowed  */ event BorrowedFromCreditLine(uint256 indexed id, uint256 borrowAmount);  /**  * @notice emitted when credit line is accepted  * @param id id of the credit line that was accepted  */ event CreditLineAccepted(uint256 indexed id);  /**  * @notice emitted when credit line is completely repaid and reset  * @param id id of the credit line that is reset  */ event CreditLineReset(uint256 indexed id);  /**  * @notice emitted when the credit line is partially repaid  * @param id id of the credit line  * @param repayAmount amount repaid  */ event PartialCreditLineRepaid(uint256 indexed id, uint256 repayAmount);  /**  * @notice emitted when the credit line is completely repaid  * @param id id of the credit line  * @param repayAmount amount repaid  */ event CompleteCreditLineRepaid(uint256 indexed id, uint256 repayAmount);  /**  * @notice emitted when the credit line is closed by one of the parties of credit line  * @param id id of the credit line  */ event CreditLineClosed(uint256 indexed id);  /**  * @notice emitted when default strategy for the credit line is updated  * @param defaultStrategy address of the strategy contract that is used as default by credit lines  */ event DefaultStrategyUpdated(address indexed defaultStrategy);  /**  * @notice emitted when the price oracle is updated  * @param priceOracle address of the updated price oracle  */ event PriceOracleUpdated(address indexed priceOracle);  /**  * @notice emitted when the savings account address is updated  * @param savingsAccount address of the updated savingsAccount  */ event SavingsAccountUpdated(address indexed savingsAccount);  /**  * @notice emitted when strategy registry address is updated  * @param strategyRegistry address of the updated strategy registry  */ event StrategyRegistryUpdated(address indexed strategyRegistry);  /**  * @notice emitted when fee that protocol charges for credit line is updated  * @param updatedProtocolFee updated value of protocolFeeFraction  */ event ProtocolFeeFractionUpdated(uint256 updatedProtocolFee);  /**  * @notice emitted when address which receives fee that protocol changes for pools is updated  * @param updatedProtocolFeeCollector updated value of protocolFeeCollector  */ event ProtocolFeeCollectorUpdated(address indexed updatedProtocolFeeCollector);  /**  * @notice emitted when liquidatorRewardFraction is updated  * @param liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator  */ event LiquidationRewardFractionUpdated(uint256 liquidatorRewardFraction);  /**  * @notice used to initialize the contract  * @dev can only be called once during the life cycle of the contract  * @param _defaultStrategy default strategy used in credit lines  * @param _priceOracle address of the priceOracle  * @param _savingsAccount address of  the savings account contract  * @param _strategyRegistry address of the strategy registry contract  * @param _owner address of owner who can change global variables  * @param _protocolFeeFraction fraction of the fee charged by protocol  * @param _protocolFeeCollector address to which protocol fee is charged to  * @param _liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator  */ function initialize(     address _defaultStrategy,     address _priceOracle,     address _savingsAccount,     address _strategyRegistry,     address _owner,     uint256 _protocolFeeFraction,     address _protocolFeeCollector,     uint256 _liquidatorRewardFraction ) external initializer {     OwnableUpgradeable.__Ownable_init();     OwnableUpgradeable.transferOwnership(_owner);      _updateDefaultStrategy(_defaultStrategy);     _updatePriceOracle(_priceOracle);     _updateSavingsAccount(_savingsAccount);     _updateStrategyRegistry(_strategyRegistry);     _updateProtocolFeeFraction(_protocolFeeFraction);     _updateProtocolFeeCollector(_protocolFeeCollector);     _updateLiquidatorRewardFraction(_liquidatorRewardFraction); }  /**  * @notice used to update the default strategy  * @dev can only be updated by owner  * @param _defaultStrategy address of the updated default strategy  */ function updateDefaultStrategy(address _defaultStrategy) external onlyOwner {     _updateDefaultStrategy(_defaultStrategy); }  function _updateDefaultStrategy(address _defaultStrategy) internal {     defaultStrategy = _defaultStrategy;     emit DefaultStrategyUpdated(_defaultStrategy); }  /**  * @notice used to update the price oracle  * @dev can only be updated by owner  * @param _priceOracle address of the updated price oracle  */ function updatePriceOracle(address _priceOracle) external onlyOwner {     _updatePriceOracle(_priceOracle); }  function _updatePriceOracle(address _priceOracle) internal {     priceOracle = _priceOracle;     emit PriceOracleUpdated(_priceOracle); }  /**  * @notice used to update the savings account address  * @dev can only be updated by owner  * @param _savingsAccount address of the updated savings account  */ function updateSavingsAccount(address _savingsAccount) external onlyOwner {     _updateSavingsAccount(_savingsAccount); }  function _updateSavingsAccount(address _savingsAccount) internal {     savingsAccount = _savingsAccount;     emit SavingsAccountUpdated(_savingsAccount); }  /**  * @notice used to update the protocol fee fraction  * @dev can only be updated by owner  * @param _protocolFee fraction of the borrower amount collected as protocol fee  */ function updateProtocolFeeFraction(uint256 _protocolFee) external onlyOwner {     _updateProtocolFeeFraction(_protocolFee); }  function _updateProtocolFeeFraction(uint256 _protocolFee) internal {     protocolFeeFraction = _protocolFee;     emit ProtocolFeeFractionUpdated(_protocolFee); }  /**  * @notice used to update the protocol fee collector  * @dev can only be updated by owner  * @param _protocolFeeCollector address in which protocol fee is collected  */ function updateProtocolFeeCollector(address _protocolFeeCollector) external onlyOwner {     _updateProtocolFeeCollector(_protocolFeeCollector); }  function _updateProtocolFeeCollector(address _protocolFeeCollector) internal {     require(_protocolFeeCollector != address(0), 'cant be 0 address');     protocolFeeCollector = _protocolFeeCollector;     emit ProtocolFeeCollectorUpdated(_protocolFeeCollector); }  /**  * @notice used to update the strategy registry address  * @dev can only be updated by owner  * @param _strategyRegistry address of the updated strategy registry  */ function updateStrategyRegistry(address _strategyRegistry) external onlyOwner {     _updateStrategyRegistry(_strategyRegistry); }  function _updateStrategyRegistry(address _strategyRegistry) internal {     require(_strategyRegistry != address(0), 'CL::I zero address');     strategyRegistry = _strategyRegistry;     emit StrategyRegistryUpdated(_strategyRegistry); }  /**  * @notice used to update the liquidatorRewardFraction  * @dev can only be updated by owner  * @param _rewardFraction fraction of liquidated amount given to liquidator as reward  */ function updateLiquidatorRewardFraction(uint256 _rewardFraction) external onlyOwner {     _updateLiquidatorRewardFraction(_rewardFraction); }  function _updateLiquidatorRewardFraction(uint256 _rewardFraction) internal {     require(_rewardFraction &lt;= 10**30, 'Fraction has to be less than 1');     liquidatorRewardFraction = _rewardFraction;     emit LiquidationRewardFractionUpdated(_rewardFraction); }  /**  * @dev Used to Calculate Interest Per second on given principal and Interest rate  * @param _principal principal Amount for which interest has to be calculated.  * @param _borrowRate It is the Interest Rate at which Credit Line is approved  * @return interest per second for the given parameters  */ function calculateInterest(     uint256 _principal,     uint256 _borrowRate,     uint256 _timeElapsed ) public pure returns (uint256) {     uint256 _interest = _principal.mul(_borrowRate).mul(_timeElapsed).div(10**30).div(YEAR_IN_SECONDS);      return _interest; }  /**  * @dev Used to calculate interest accrued since last repayment  * @param _id identifier for the credit line  * @return interest accrued over current borrowed amount since last repayment  */  function calculateInterestAccrued(uint256 _id) public view returns (uint256) {     uint256 _lastPrincipalUpdateTime = creditLineVariables[_id].lastPrincipalUpdateTime;     if (_lastPrincipalUpdateTime == 0) return 0;     uint256 _timeElapsed = (block.timestamp).sub(_lastPrincipalUpdateTime);     uint256 _interestAccrued = calculateInterest(creditLineVariables[_id].principal, creditLineConstants[_id].borrowRate, _timeElapsed);     return _interestAccrued; }  /**  * @dev Used to calculate current debt of borrower against a credit line.  * @param _id identifier for the credit line  * @return current debt of borrower  */ function calculateCurrentDebt(uint256 _id) public view returns (uint256) {     uint256 _interestAccrued = calculateInterestAccrued(_id);     uint256 _currentDebt = (creditLineVariables[_id].principal)         .add(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate)         .add(_interestAccrued)         .sub(creditLineVariables[_id].totalInterestRepaid);     return _currentDebt; }  /**  * @notice used to calculate amount that can be borrowed by the borrower  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view.         borrowableAmount changes per block as interest changes per block.  * @param _id identifier for the credit line  * @return amount that can be borrowed from the credit line  */ function calculateBorrowableAmount(uint256 _id) public returns (uint256) {     CreditLineStatus _status = creditLineVariables[_id].status;     require(         _status == CreditLineStatus.ACTIVE || _status == CreditLineStatus.REQUESTED,         'CreditLine: Cannot only if credit line ACTIVE or REQUESTED'     );     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(         creditLineConstants[_id].collateralAsset,         creditLineConstants[_id].borrowAsset     );      uint256 _totalCollateralToken = calculateTotalCollateralTokens(_id);      uint256 _currentDebt = calculateCurrentDebt(_id);      uint256 _maxPossible = _totalCollateralToken.mul(_ratioOfPrices).div(creditLineConstants[_id].idealCollateralRatio).mul(10**30).div(         10**_decimals     );      uint256 _borrowLimit = creditLineConstants[_id].borrowLimit;      if (_maxPossible &gt; _borrowLimit) {         _maxPossible = _borrowLimit;     }     if (_maxPossible &gt; _currentDebt) {         return _maxPossible.sub(_currentDebt);     }     return 0; }  function updateinterestAccruedTillLastPrincipalUpdate(uint256 _id) internal {     require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');      uint256 _interestAccrued = calculateInterestAccrued(_id);     uint256 _newInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(_interestAccrued);     creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _newInterestAccrued; }  function _depositCollateralFromSavingsAccount(     uint256 _id,     uint256 _amount,     address _sender ) internal {     address _collateralAsset = creditLineConstants[_id].collateralAsset;     address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();     ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);     uint256 _activeAmount;      for (uint256 _index = 0; _index &lt; _strategyList.length; _index++) {         address _strategy = _strategyList[_index];         uint256 _liquidityShares = _savingsAccount.balanceInShares(_sender, _collateralAsset, _strategy);         if (_liquidityShares == 0 || _strategyList[_index] == address(0)) {             continue;         }         uint256 _tokenInStrategy = _liquidityShares;         _tokenInStrategy = IYield(_strategy).getTokensForShares(_liquidityShares, _collateralAsset);          uint256 _tokensToTransfer = _tokenInStrategy;         if (_activeAmount.add(_tokenInStrategy) &gt;= _amount) {             _tokensToTransfer = (_amount.sub(_activeAmount));         }         _activeAmount = _activeAmount.add(_tokensToTransfer);         _savingsAccount.transferFrom(_tokensToTransfer, _collateralAsset, _strategy, _sender, address(this));          collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(             _liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy)         );          if (_amount == _activeAmount) {             return;         }     }     revert('CreditLine::_depositCollateralFromSavingsAccount - Insufficient balance'); }  /**  * @notice used to request a credit line either by borrower or lender  * @param _requestTo Address to which creditLine is requested,                      if borrower creates request then lender address and                      if lender creates then borrower address  * @param _borrowLimit maximum borrow amount in a credit line  * @param _borrowRate Interest Rate at which credit Line is requested  * @param _autoLiquidation if true, anyone can liquidate loan, otherwise only lender  * @param _collateralRatio ratio of the collateral to the debt below which credit line can be liquidated  * @param _borrowAsset address of the token to be borrowed  * @param _collateralAsset address of the token provided as collateral  * @param _requestAsLender if true, lender is placing request, otherwise borrower  * @return identifier for the credit line  */  function request(     address _requestTo,     uint256 _borrowLimit,     uint256 _borrowRate,     bool _autoLiquidation,     uint256 _collateralRatio,     address _borrowAsset,     address _collateralAsset,     bool _requestAsLender ) external returns (uint256) {     require(_borrowAsset != _collateralAsset, 'R: cant borrow lent token');     require(IPriceOracle(priceOracle).doesFeedExist(_borrowAsset, _collateralAsset), 'R: No price feed');      address _lender = _requestTo;     address _borrower = msg.sender;     if (_requestAsLender) {         _lender = msg.sender;         _borrower = _requestTo;     }      uint256 _id = _createRequest(         _lender,         _borrower,         _borrowLimit,         _borrowRate,         _autoLiquidation,         _collateralRatio,         _borrowAsset,         _collateralAsset,         _requestAsLender     );      emit CreditLineRequested(_id, _lender, _borrower);     return _id; }  function _createRequest(     address _lender,     address _borrower,     uint256 _borrowLimit,     uint256 _borrowRate,     bool _autoLiquidation,     uint256 _collateralRatio,     address _borrowAsset,     address _collateralAsset,     bool _requestByLender ) internal returns (uint256) {     require(_lender != _borrower, 'Lender and Borrower cannot be same addresses');     uint256 _id = creditLineCounter + 1;     creditLineCounter = _id;     creditLineVariables[_id].status = CreditLineStatus.REQUESTED;     creditLineConstants[_id].borrower = _borrower;     creditLineConstants[_id].lender = _lender;     creditLineConstants[_id].borrowLimit = _borrowLimit;     creditLineConstants[_id].autoLiquidation = _autoLiquidation;     creditLineConstants[_id].idealCollateralRatio = _collateralRatio;     creditLineConstants[_id].borrowRate = _borrowRate;     creditLineConstants[_id].borrowAsset = _borrowAsset;     creditLineConstants[_id].collateralAsset = _collateralAsset;     creditLineConstants[_id].requestByLender = _requestByLender;     return _id; }  /**  * @notice used to accept a credit line  * @dev if borrower places request, lender can accept and vice versa  * @param _id identifier for the credit line  */ function accept(uint256 _id) external {     require(         creditLineVariables[_id].status == CreditLineStatus.REQUESTED,         'CreditLine::acceptCreditLineLender - CreditLine is already accepted'     );     bool _requestByLender = creditLineConstants[_id].requestByLender;     require(         (msg.sender == creditLineConstants[_id].borrower &amp;&amp; _requestByLender) ||             (msg.sender == creditLineConstants[_id].lender &amp;&amp; !_requestByLender),         "Only Borrower or Lender who hasn't requested can accept"     );     creditLineVariables[_id].status = CreditLineStatus.ACTIVE;     emit CreditLineAccepted(_id); }  /**  * @notice used to deposit collateral into the credit line  * @dev collateral tokens have to be approved in savingsAccount or token contract(unless ether).         If transferred from savings account, the tokens are transferred from strategies in the          order prespecified in strategy registry  * @param _id identifier for the credit line  * @param _amount amount of collateral being deposited  * @param _strategy strategy to which collateral is to be deposited in case transfer is not from savings account  * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount                              otherwise direct from collateral token contract  */ function depositCollateral(     uint256 _id,     uint256 _amount,     address _strategy,     bool _fromSavingsAccount ) external payable nonReentrant ifCreditLineExists(_id) {     require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine not active');     _depositCollateral(_id, _amount, _strategy, _fromSavingsAccount);     emit CollateralDeposited(_id, _amount, _strategy); }  function _depositCollateral(     uint256 _id,     uint256 _amount,     address _strategy,     bool _fromSavingsAccount ) internal {     require(creditLineConstants[_id].lender != msg.sender, 'lender cant deposit collateral');     if (_fromSavingsAccount) {         _depositCollateralFromSavingsAccount(_id, _amount, msg.sender);     } else {         address _collateralAsset = creditLineConstants[_id].collateralAsset;         ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);         if (_collateralAsset == address(0)) {             require(msg.value == _amount, "CreditLine::_depositCollateral - value to transfer doesn't match argument");         } else {             IERC20(_collateralAsset).safeTransferFrom(msg.sender, address(this), _amount);             IERC20(_collateralAsset).approve(_strategy, _amount);         }         uint256 _sharesReceived = _savingsAccount.deposit{value: msg.value}(_amount, _collateralAsset, _strategy, address(this));         collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(_sharesReceived);     } }  function _withdrawBorrowAmount(     address _asset,     uint256 _amountInTokens,     address _lender ) internal {     address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();     ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);     uint256 _activeAmount;     for (uint256 _index = 0; _index &lt; _strategyList.length; _index++) {         if (_strategyList[_index] == address(0)) {             continue;         }         uint256 _liquidityShares = _savingsAccount.balanceInShares(_lender, _asset, _strategyList[_index]);         if (_liquidityShares != 0) {             uint256 tokenInStrategy = _liquidityShares;             tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);             uint256 _tokensToTransfer = tokenInStrategy;             if (_activeAmount.add(tokenInStrategy) &gt;= _amountInTokens) {                 _tokensToTransfer = (_amountInTokens.sub(_activeAmount));             }             _activeAmount = _activeAmount.add(_tokensToTransfer);             _savingsAccount.withdrawFrom(_tokensToTransfer, _asset, _strategyList[_index], _lender, address(this), false);             if (_activeAmount == _amountInTokens) {                 return;             }         }     }     require(_activeAmount == _amountInTokens, 'insufficient balance'); }  /**  * @notice used to borrow tokens from credit line by borrower  * @dev only borrower can call this function. Amount that can actually be borrowed is          min(amount based on borrowLimit, allowance to creditLine contract, balance of lender)  * @param _id identifier for the credit line  * @param _amount amount of tokens to borrow  */ function borrow(uint256 _id, uint256 _amount) external payable nonReentrant onlyCreditLineBorrower(_id) {     require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');     uint256 _borrowableAmount = calculateBorrowableAmount(_id);     require(_amount &lt;= _borrowableAmount, "CreditLine::borrow - The current collateral ratio doesn't allow to withdraw the amount");     address _borrowAsset = creditLineConstants[_id].borrowAsset;     address _lender = creditLineConstants[_id].lender;      updateinterestAccruedTillLastPrincipalUpdate(_id);     creditLineVariables[_id].principal = creditLineVariables[_id].principal.add(_amount);     creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;      uint256 _tokenDiffBalance;     if (_borrowAsset != address(0)) {         uint256 _balanceBefore = IERC20(_borrowAsset).balanceOf(address(this));         _withdrawBorrowAmount(_borrowAsset, _amount, _lender);         uint256 _balanceAfter = IERC20(_borrowAsset).balanceOf(address(this));         _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);     } else {         uint256 _balanceBefore = address(this).balance;         _withdrawBorrowAmount(_borrowAsset, _amount, _lender);         uint256 _balanceAfter = address(this).balance;         _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);     }     uint256 _protocolFee = _tokenDiffBalance.mul(protocolFeeFraction).div(10**30);     _tokenDiffBalance = _tokenDiffBalance.sub(_protocolFee);      if (_borrowAsset == address(0)) {         (bool feeSuccess, ) = protocolFeeCollector.call{value: _protocolFee}('');         require(feeSuccess, 'Transfer fail');         (bool success, ) = msg.sender.call{value: _tokenDiffBalance}('');         require(success, 'Transfer fail');     } else {         IERC20(_borrowAsset).safeTransfer(protocolFeeCollector, _protocolFee);         IERC20(_borrowAsset).safeTransfer(msg.sender, _tokenDiffBalance);     }     emit BorrowedFromCreditLine(_id, _tokenDiffBalance); }  function _repayFromSavingsAccount(     uint256 _amount,     address _asset,     address _lender ) internal {     address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();     ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);     uint256 _activeAmount;      for (uint256 _index = 0; _index &lt; _strategyList.length; _index++) {         if (_strategyList[_index] == address(0)) {             continue;         }         uint256 _liquidityShares = _savingsAccount.balanceInShares(msg.sender, _asset, _strategyList[_index]);         if (_liquidityShares == 0) {             continue;         }         uint256 _tokenInStrategy = _liquidityShares;         _tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);          uint256 _tokensToTransfer = _tokenInStrategy;         if (_activeAmount.add(_tokenInStrategy) &gt;= _amount) {             _tokensToTransfer = (_amount.sub(_activeAmount));         }         _activeAmount = _activeAmount.add(_tokensToTransfer);         _savingsAccount.transferFrom(_tokensToTransfer, _asset, _strategyList[_index], msg.sender, _lender);          if (_amount == _activeAmount) {             return;         }     }     revert('CreditLine::_repayFromSavingsAccount - Insufficient balance'); }  function _repay(     uint256 _id,     uint256 _amount,     bool _fromSavingsAccount,     uint256 _principalPaid ) internal {     ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);     address _defaultStrategy = defaultStrategy;     address _borrowAsset = creditLineConstants[_id].borrowAsset;     address _lender = creditLineConstants[_id].lender;     if (!_fromSavingsAccount) {         if (_borrowAsset == address(0)) {             require(msg.value == _amount, 'creditLine::repay - Ether sent not equal to repay amount');             _savingsAccount.deposit{value: _amount}(_amount, _borrowAsset, _defaultStrategy, _lender);         } else {             IERC20(_borrowAsset).safeTransferFrom(msg.sender, address(this), _amount);             IERC20(_borrowAsset).approve(_defaultStrategy, _amount);             _savingsAccount.deposit(_amount, _borrowAsset, _defaultStrategy, _lender);         }     } else {         _repayFromSavingsAccount(_amount, _borrowAsset, _lender);     }     if (_principalPaid != 0) {         _savingsAccount.increaseAllowanceToCreditLine(_principalPaid, _borrowAsset, _lender);     } }  /**  * @notice used to repay interest and principal to credit line. Interest has to be repaid before repaying principal  * @dev partial repayments possible  * @param _id identifier for the credit line  * @param _amount amount being repaid  * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount                              otherwise direct from collateral token contract  */ function repay(     uint256 _id,     uint256 _amount,     bool _fromSavingsAccount ) external payable nonReentrant {     require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');     require(creditLineConstants[_id].lender != msg.sender, 'Lender cant repay');      uint256 _interestSincePrincipalUpdate = calculateInterestAccrued(_id);     uint256 _totalInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(         _interestSincePrincipalUpdate     );     uint256 _interestToPay = _totalInterestAccrued.sub(creditLineVariables[_id].totalInterestRepaid);     uint256 _totalCurrentDebt = _interestToPay.add(creditLineVariables[_id].principal);     uint256 _principalPaid = 0;      if (_amount &gt;= _totalCurrentDebt) {         _amount = _totalCurrentDebt;         emit CompleteCreditLineRepaid(_id, _amount);     } else {         emit PartialCreditLineRepaid(_id, _amount);     }      if (_amount &gt; _interestToPay) {         creditLineVariables[_id].principal = _totalCurrentDebt.sub(_amount);         creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _totalInterestAccrued;         creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;         creditLineVariables[_id].totalInterestRepaid = _totalInterestAccrued;         _principalPaid = _amount.sub(_interestToPay);     } else {         creditLineVariables[_id].totalInterestRepaid = creditLineVariables[_id].totalInterestRepaid.add(_amount);     }      _repay(_id, _amount, _fromSavingsAccount, _principalPaid);      if (creditLineVariables[_id].principal == 0) {         _resetCreditLine(_id);     } }  function _resetCreditLine(uint256 _id) internal {     creditLineVariables[_id].lastPrincipalUpdateTime = 0;     creditLineVariables[_id].totalInterestRepaid = 0;     creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = 0;     emit CreditLineReset(_id); }  /**  * @dev used to close credit line by borrower or lender  * @param _id identifier for the credit line  */ function close(uint256 _id) external ifCreditLineExists(_id) {     require(         msg.sender == creditLineConstants[_id].borrower || msg.sender == creditLineConstants[_id].lender,         'CreditLine: Permission denied while closing Line of credit'     );     require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: Credit line should be active.');     require(creditLineVariables[_id].principal == 0, 'CreditLine: Cannot be closed since not repaid.');     require(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate == 0, 'CreditLine: Cannot be closed since not repaid.');     creditLineVariables[_id].status = CreditLineStatus.CLOSED;     emit CreditLineClosed(_id); }  /**  * @notice used to calculate the current collateral ratio  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view.         Interest is also considered while calculating debt  * @param _id identifier for the credit line  * @return collateral ratio multiplied by 10**30 to retain precision  */ function calculateCurrentCollateralRatio(uint256 _id) public ifCreditLineExists(_id) returns (uint256) {     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(         creditLineConstants[_id].collateralAsset,         creditLineConstants[_id].borrowAsset     );      uint256 currentDebt = calculateCurrentDebt(_id);     uint256 currentCollateralRatio = calculateTotalCollateralTokens(_id).mul(_ratioOfPrices).div(currentDebt).mul(10**30).div(         10**_decimals     );      return currentCollateralRatio; }  /**  * @notice used to calculate the total collateral tokens  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view  * @param _id identifier for the credit line  * @return _amount total collateral tokens deposited into the credit line  */ function calculateTotalCollateralTokens(uint256 _id) public returns (uint256 _amount) {     address _collateralAsset = creditLineConstants[_id].collateralAsset;     address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();     uint256 _liquidityShares;     for (uint256 index = 0; index &lt; _strategyList.length; index++) {         if (_strategyList[index] == address(0)) {             continue;         }         _liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];         uint256 _tokenInStrategy = _liquidityShares;         _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(_liquidityShares, _collateralAsset);          _amount = _amount.add(_tokenInStrategy);     } }  /**  * @notice used to withdraw any excess collateral  * @dev collateral can't be withdraw if collateralRatio goes below the ideal value. Only borrower can withdraw  * @param _id identifier for the credit line  * @param _amount amount of collateral to withdraw  * @param _toSavingsAccount if true, tokens are transferred from savingsAccount                              otherwise direct from collateral token contract  */ function withdrawCollateral(     uint256 _id,     uint256 _amount,     bool _toSavingsAccount ) external nonReentrant onlyCreditLineBorrower(_id) {     uint256 _withdrawableCollateral = withdrawableCollateral(_id);     require(_amount &lt;= _withdrawableCollateral, 'Collateral ratio cant go below ideal');     address _collateralAsset = creditLineConstants[_id].collateralAsset;     _transferCollateral(_id, _collateralAsset, _amount, _toSavingsAccount);     emit CollateralWithdrawn(_id, _amount); }  /**  * @notice used to calculate the collateral that can be withdrawn  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view  * @param _id identifier for the credit line  * @return total collateral withdrawable by borrower  */ function withdrawableCollateral(uint256 _id) public returns (uint256) {     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(         creditLineConstants[_id].collateralAsset,         creditLineConstants[_id].borrowAsset     );      uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);     uint256 _currentDebt = calculateCurrentDebt(_id);      uint256 _collateralNeeded = _currentDebt         .mul(creditLineConstants[_id].idealCollateralRatio)         .div(_ratioOfPrices)         .mul(10**_decimals)         .div(10**30);      if (_collateralNeeded &gt;= _totalCollateralTokens) {         return 0;     }     return _totalCollateralTokens.sub(_collateralNeeded); }  function _transferCollateral(     uint256 _id,     address _asset,     uint256 _amountInTokens,     bool _toSavingsAccount ) internal {     address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();     uint256 _activeAmount;     for (uint256 index = 0; index &lt; _strategyList.length; index++) {         uint256 liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];         if (liquidityShares == 0 || _strategyList[index] == address(0)) {             continue;         }         uint256 _tokenInStrategy = liquidityShares;         _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(liquidityShares, _asset);         uint256 _tokensToTransfer = _tokenInStrategy;         if (_activeAmount.add(_tokenInStrategy) &gt; _amountInTokens) {             _tokensToTransfer = _amountInTokens.sub(_activeAmount);             liquidityShares = liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy);         }         _activeAmount = _activeAmount.add(_tokensToTransfer);         collateralShareInStrategy[_id][_strategyList[index]] = collateralShareInStrategy[_id][_strategyList[index]].sub(             liquidityShares         );         if (_toSavingsAccount) {             ISavingsAccount(savingsAccount).transfer(_tokensToTransfer, _asset, _strategyList[index], msg.sender);         } else {             ISavingsAccount(savingsAccount).withdraw(_tokensToTransfer, _asset, _strategyList[index], msg.sender, false);         }          if (_activeAmount == _amountInTokens) {             return;         }     }     revert('insufficient collateral'); }  /**  * @notice used to liquidate credit line in case collateral ratio goes below the threshold  * @dev if lender liquidates, then collateral is directly transferred.          If autoLiquidation is true, anyone can liquidate by providing enough borrow tokens  * @param _id identifier for the credit line  * @param _toSavingsAccount if true, tokens are transferred from savingsAccount                              otherwise direct from collateral token contract  */ function liquidate(uint256 _id, bool _toSavingsAccount) external payable nonReentrant {     require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: Credit line should be active.');     require(creditLineVariables[_id].principal != 0, 'CreditLine: cannot liquidate if principal is 0');      uint256 currentCollateralRatio = calculateCurrentCollateralRatio(_id);     require(         currentCollateralRatio &lt; creditLineConstants[_id].idealCollateralRatio,         'CreditLine: Collateral ratio is higher than ideal value'     );      address _collateralAsset = creditLineConstants[_id].collateralAsset;     address _lender = creditLineConstants[_id].lender;     uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);     address _borrowAsset = creditLineConstants[_id].borrowAsset;      creditLineVariables[_id].status = CreditLineStatus.LIQUIDATED;      if (creditLineConstants[_id].autoLiquidation &amp;&amp; _lender != msg.sender) {         uint256 _borrowTokens = _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens);         if (_borrowAsset == address(0)) {             uint256 _returnETH = msg.value.sub(_borrowTokens, 'Insufficient ETH to liquidate');             if (_returnETH != 0) {                 (bool success, ) = msg.sender.call{value: _returnETH}('');                 require(success, 'Transfer fail');             }         } else {             IERC20(_borrowAsset).safeTransferFrom(msg.sender, _lender, _borrowTokens);         }     }      _transferCollateral(_id, _collateralAsset, _totalCollateralTokens, _toSavingsAccount);      emit CreditLineLiquidated(_id, msg.sender); }  /**  * @notice used to calculate the borrow tokens necessary for liquidator to liquidate  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view  * @param _id identifier for the credit line  * @return borrow tokens necessary for liquidator to liquidate  */ function borrowTokensToLiquidate(uint256 _id) external returns (uint256) {     address _collateralAsset = creditLineConstants[_id].collateralAsset;     uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);     address _borrowAsset = creditLineConstants[_id].borrowAsset;      return _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens); }  function _borrowTokensToLiquidate(     address _borrowAsset,     address _collateralAsset,     uint256 _totalCollateralTokens ) internal view returns (uint256) {     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(_borrowAsset, _collateralAsset);     uint256 _borrowTokens = (         _totalCollateralTokens.mul(uint256(10**30).sub(liquidatorRewardFraction)).div(10**30).mul(_ratioOfPrices).div(10**_decimals)     );      return _borrowTokens; }  receive() external payable {     require(msg.sender == savingsAccount, 'CreditLine::receive invalid transaction'); }  } |
| **need_reflect** | True |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Chief Executive Officer |
| **phase_prompt** | We excel in generating innovative approaches and enhancements for Solidity smart contract code. Here's a Solidity contract provided by the user: "{task}". As the {assistant_role}, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user. Note that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we've collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with , followed directly by the final idea or enhancement suggestion, e.g. " Implementing a multi-sig wallet mechanism for added security in transactions". |
| **phase_name** | ContractAnalysis |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'task': '// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\n\nimport \'@openzeppelin/contracts/token/ERC20/SafeERC20.sol\';\nimport \'@openzeppelin/contracts/math/SafeMath.sol\';\nimport \'@openzeppelin/contracts/utils/ReentrancyGuard.sol\';\nimport \'@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\';\nimport \'../interfaces/IPriceOracle.sol\';\nimport \'../interfaces/IYield.sol\';\nimport \'../interfaces/ISavingsAccount.sol\';\nimport \'../SavingsAccount/SavingsAccountUtil.sol\';\nimport \'../interfaces/IStrategyRegistry.sol\';\n\n/\n * @title Credit Line contract with Methods related to credit Line\n * @notice Implements the functions related to Credit Line\n * @author Sublime\n /\n\ncontract CreditLine is ReentrancyGuard, OwnableUpgradeable {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    enum CreditLineStatus {\n        NOT_CREATED,\n        REQUESTED,\n        ACTIVE,\n        CLOSED,\n        CANCELLED,\n        LIQUIDATED\n    }\n\n    /\n     * @notice counter that tracks the number of credit lines created\n     * @dev used to create unique identifier for credit lines\n     /\n    uint256 public creditLineCounter;\n\n    uint256 constant YEAR_IN_SECONDS = 365 days;\n\n    struct CreditLineVariables {\n        CreditLineStatus status;\n        uint256 principal;\n        uint256 totalInterestRepaid;\n        uint256 lastPrincipalUpdateTime;\n        uint256 interestAccruedTillLastPrincipalUpdate;\n    }\n\n    struct CreditLineConstants {\n        address lender;\n        address borrower;\n        uint256 borrowLimit;\n        uint256 idealCollateralRatio;\n        uint256 borrowRate;\n        address borrowAsset;\n        address collateralAsset;\n        bool autoLiquidation;\n        bool requestByLender;\n    }\n    /\n     * @notice stores the collateral shares in a credit line per strategy\n     * @dev creditLineId =&gt; Strategy =&gt; collateralShares\n     /\n    mapping(uint256 =&gt; mapping(address =&gt; uint256)) public collateralShareInStrategy;\n\n    /\n     * @notice stores the variables to maintain a credit line\n     /\n    mapping(uint256 =&gt; CreditLineVariables) public creditLineVariables;\n\n    /\n     * @notice stores the constants related to a credit line\n     /\n    mapping(uint256 =&gt; CreditLineConstants) public creditLineConstants;\n\n    /\n     * @notice stores the address of savings account contract\n     /\n    address public savingsAccount;\n\n    /\n     * @notice stores the address of price oracle contract\n     /\n    address public priceOracle;\n\n    /\n     * @notice stores the address of strategy registry contract\n     /\n    address public strategyRegistry;\n\n    /\n     * @notice stores the address of default strategy\n     /\n    address public defaultStrategy;\n\n    /\n     * @notice stores the fraction of borrowed amount charged as fee by protocol\n     * @dev it is multiplied by 1030\n     /\n    uint256 public protocolFeeFraction;\n\n    /\n     * @notice address where protocol fee is collected\n     /\n    address public protocolFeeCollector;\n\n    /\n     * @notice stores the fraction of amount liquidated given as reward to liquidator\n     * @dev it is multiplied by 1030\n     /\n    uint256 public liquidatorRewardFraction;\n    /\n     * @dev checks if Credit Line exists\n     * @param _id identifier for the credit line\n     /\n    modifier ifCreditLineExists(uint256 id) {\n        require(creditLineVariables[_id].status != CreditLineStatus.NOT_CREATED, \'Credit line does not exist\');\n        ;\n    }\n\n    /\n     * @dev checks if called by credit Line Borrower\n     * @param _id creditLine identifier\n     /\n    modifier onlyCreditLineBorrower(uint256 id) {\n        require(creditLineConstants[_id].borrower == msg.sender, \'Only credit line Borrower can access\');\n        ;\n    }\n\n    /\n     * @dev checks if called by credit Line Lender\n     * @param _id creditLine identifier\n     /\n    modifier onlyCreditLineLender(uint256 id) {\n        require(creditLineConstants[_id].lender == msg.sender, \'Only credit line Lender can access\');\n        ;\n    }\n\n    /\n     * @notice emitted when a collateral is deposited into credit line\n     * @param id id of the credit line\n     * @param amount amount of collateral deposited\n     * @param strategy address of the strategy into which collateral is deposited\n     */\n    event CollateralDeposited(uint256 indexed id, uint256 amount, address indexed strategy);\n\n    /\n     * @notice emitted when collateral is withdrawn from credit line\n     * @param id id of the credit line\n     * @param amount amount of collateral withdrawn\n     /\n    event CollateralWithdrawn(uint256 indexed id, uint256 amount);\n\n    /\n     * @notice emitted when a request for new credit line is placed\n     * @param id id of the credit line for which request was made\n     * @param lender address of the lender for credit line\n     * @param borrower address of the borrower for credit line\n     /\n    event CreditLineRequested(uint256 indexed id, address indexed lender, address indexed borrower);\n\n    /\n     * @notice emitted when a credit line is liquidated\n     * @param id id of the credit line which is liquidated\n     * @param liquidator address of the liquidator\n     */\n    event CreditLineLiquidated(uint256 indexed id, address indexed liquidator);\n\n    /\n     * @notice emitted when tokens are borrowed from credit line\n     * @param id id of the credit line from which tokens are borrowed\n     * @param borrowAmount amount of tokens borrowed\n     /\n    event BorrowedFromCreditLine(uint256 indexed id, uint256 borrowAmount);\n\n    /\n     * @notice emitted when credit line is accepted\n     * @param id id of the credit line that was accepted\n     /\n    event CreditLineAccepted(uint256 indexed id);\n\n    /\n     * @notice emitted when credit line is completely repaid and reset\n     * @param id id of the credit line that is reset\n     */\n    event CreditLineReset(uint256 indexed id);\n\n    /\n     * @notice emitted when the credit line is partially repaid\n     * @param id id of the credit line\n     * @param repayAmount amount repaid\n     /\n    event PartialCreditLineRepaid(uint256 indexed id, uint256 repayAmount);\n\n    /\n     * @notice emitted when the credit line is completely repaid\n     * @param id id of the credit line\n     * @param repayAmount amount repaid\n     /\n    event CompleteCreditLineRepaid(uint256 indexed id, uint256 repayAmount);\n\n    /\n     * @notice emitted when the credit line is closed by one of the parties of credit line\n     * @param id id of the credit line\n     */\n    event CreditLineClosed(uint256 indexed id);\n\n    /\n     * @notice emitted when default strategy for the credit line is updated\n     * @param defaultStrategy address of the strategy contract that is used as default by credit lines\n     /\n    event DefaultStrategyUpdated(address indexed defaultStrategy);\n\n    /\n     * @notice emitted when the price oracle is updated\n     * @param priceOracle address of the updated price oracle\n     /\n    event PriceOracleUpdated(address indexed priceOracle);\n\n    /\n     * @notice emitted when the savings account address is updated\n     * @param savingsAccount address of the updated savingsAccount\n     */\n    event SavingsAccountUpdated(address indexed savingsAccount);\n\n    /\n     * @notice emitted when strategy registry address is updated\n     * @param strategyRegistry address of the updated strategy registry\n     /\n    event StrategyRegistryUpdated(address indexed strategyRegistry);\n\n    /\n     * @notice emitted when fee that protocol charges for credit line is updated\n     * @param updatedProtocolFee updated value of protocolFeeFraction\n     /\n    event ProtocolFeeFractionUpdated(uint256 updatedProtocolFee);\n\n    /\n     * @notice emitted when address which receives fee that protocol changes for pools is updated\n     * @param updatedProtocolFeeCollector updated value of protocolFeeCollector\n     */\n    event ProtocolFeeCollectorUpdated(address indexed updatedProtocolFeeCollector);\n\n    /\n     * @notice emitted when liquidatorRewardFraction is updated\n     * @param liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator\n     /\n    event LiquidationRewardFractionUpdated(uint256 liquidatorRewardFraction);\n\n    /\n     * @notice used to initialize the contract\n     * @dev can only be called once during the life cycle of the contract\n     * @param _defaultStrategy default strategy used in credit lines\n     * @param _priceOracle address of the priceOracle\n     * @param _savingsAccount address of  the savings account contract\n     * @param _strategyRegistry address of the strategy registry contract\n     * @param _owner address of owner who can change global variables\n     * @param _protocolFeeFraction fraction of the fee charged by protocol\n     * @param _protocolFeeCollector address to which protocol fee is charged to\n     * @param _liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator\n     /\n    function initialize(\n        address _defaultStrategy,\n        address _priceOracle,\n        address _savingsAccount,\n        address _strategyRegistry,\n        address _owner,\n        uint256 _protocolFeeFraction,\n        address _protocolFeeCollector,\n        uint256 _liquidatorRewardFraction\n    ) external initializer {\n        OwnableUpgradeable.__Ownable_init();\n        OwnableUpgradeable.transferOwnership(_owner);\n\n        _updateDefaultStrategy(_defaultStrategy);\n        _updatePriceOracle(_priceOracle);\n        _updateSavingsAccount(_savingsAccount);\n        _updateStrategyRegistry(_strategyRegistry);\n        _updateProtocolFeeFraction(_protocolFeeFraction);\n        _updateProtocolFeeCollector(_protocolFeeCollector);\n        _updateLiquidatorRewardFraction(_liquidatorRewardFraction);\n    }\n\n    /\n     * @notice used to update the default strategy\n     * @dev can only be updated by owner\n     * @param _defaultStrategy address of the updated default strategy\n     */\n    function updateDefaultStrategy(address _defaultStrategy) external onlyOwner {\n        _updateDefaultStrategy(_defaultStrategy);\n    }\n\n    function _updateDefaultStrategy(address _defaultStrategy) internal {\n        defaultStrategy = _defaultStrategy;\n        emit DefaultStrategyUpdated(_defaultStrategy);\n    }\n\n    /\n     * @notice used to update the price oracle\n     * @dev can only be updated by owner\n     * @param _priceOracle address of the updated price oracle\n     /\n    function updatePriceOracle(address _priceOracle) external onlyOwner {\n        _updatePriceOracle(_priceOracle);\n    }\n\n    function _updatePriceOracle(address _priceOracle) internal {\n        priceOracle = _priceOracle;\n        emit PriceOracleUpdated(_priceOracle);\n    }\n\n    /\n     * @notice used to update the savings account address\n     * @dev can only be updated by owner\n     * @param _savingsAccount address of the updated savings account\n     /\n    function updateSavingsAccount(address _savingsAccount) external onlyOwner {\n        _updateSavingsAccount(_savingsAccount);\n    }\n\n    function _updateSavingsAccount(address _savingsAccount) internal {\n        savingsAccount = _savingsAccount;\n        emit SavingsAccountUpdated(_savingsAccount);\n    }\n\n    /\n     * @notice used to update the protocol fee fraction\n     * @dev can only be updated by owner\n     * @param _protocolFee fraction of the borrower amount collected as protocol fee\n     */\n    function updateProtocolFeeFraction(uint256 _protocolFee) external onlyOwner {\n        _updateProtocolFeeFraction(_protocolFee);\n    }\n\n    function _updateProtocolFeeFraction(uint256 _protocolFee) internal {\n        protocolFeeFraction = _protocolFee;\n        emit ProtocolFeeFractionUpdated(_protocolFee);\n    }\n\n    /\n     * @notice used to update the protocol fee collector\n     * @dev can only be updated by owner\n     * @param _protocolFeeCollector address in which protocol fee is collected\n     /\n    function updateProtocolFeeCollector(address _protocolFeeCollector) external onlyOwner {\n        _updateProtocolFeeCollector(_protocolFeeCollector);\n    }\n\n    function _updateProtocolFeeCollector(address _protocolFeeCollector) internal {\n        require(_protocolFeeCollector != address(0), \'cant be 0 address\');\n        protocolFeeCollector = _protocolFeeCollector;\n        emit ProtocolFeeCollectorUpdated(_protocolFeeCollector);\n    }\n\n    /\n     * @notice used to update the strategy registry address\n     * @dev can only be updated by owner\n     * @param _strategyRegistry address of the updated strategy registry\n     /\n    function updateStrategyRegistry(address _strategyRegistry) external onlyOwner {\n        _updateStrategyRegistry(_strategyRegistry);\n    }\n\n    function _updateStrategyRegistry(address _strategyRegistry) internal {\n        require(_strategyRegistry != address(0), \'CL::I zero address\');\n        strategyRegistry = _strategyRegistry;\n        emit StrategyRegistryUpdated(_strategyRegistry);\n    }\n\n    /\n     * @notice used to update the liquidatorRewardFraction\n     * @dev can only be updated by owner\n     * @param _rewardFraction fraction of liquidated amount given to liquidator as reward\n     */\n    function updateLiquidatorRewardFraction(uint256 _rewardFraction) external onlyOwner {\n        _updateLiquidatorRewardFraction(_rewardFraction);\n    }\n\n    function _updateLiquidatorRewardFraction(uint256 _rewardFraction) internal {\n        require(_rewardFraction &lt;= 1030, \'Fraction has to be less than 1\');\n        liquidatorRewardFraction = _rewardFraction;\n        emit LiquidationRewardFractionUpdated(_rewardFraction);\n    }\n\n    /\n     * @dev Used to Calculate Interest Per second on given principal and Interest rate\n     * @param _principal principal Amount for which interest has to be calculated.\n     * @param _borrowRate It is the Interest Rate at which Credit Line is approved\n     * @return interest per second for the given parameters\n     */\n    function calculateInterest(\n        uint256 _principal,\n        uint256 _borrowRate,\n        uint256 _timeElapsed\n    ) public pure returns (uint256) {\n        uint256 _interest = _principal.mul(_borrowRate).mul(_timeElapsed).div(1030).div(YEAR_IN_SECONDS);\n\n        return _interest;\n    }\n\n    /\n     * @dev Used to calculate interest accrued since last repayment\n     * @param _id identifier for the credit line\n     * @return interest accrued over current borrowed amount since last repayment\n     */\n\n    function calculateInterestAccrued(uint256 _id) public view returns (uint256) {\n        uint256 _lastPrincipalUpdateTime = creditLineVariables[_id].lastPrincipalUpdateTime;\n        if (_lastPrincipalUpdateTime == 0) return 0;\n        uint256 _timeElapsed = (block.timestamp).sub(_lastPrincipalUpdateTime);\n        uint256 _interestAccrued = calculateInterest(creditLineVariables[_id].principal, creditLineConstants[_id].borrowRate, _timeElapsed);\n        return _interestAccrued;\n    }\n\n    /\n     * @dev Used to calculate current debt of borrower against a credit line.\n     * @param _id identifier for the credit line\n     * @return current debt of borrower\n     /\n    function calculateCurrentDebt(uint256 _id) public view returns (uint256) {\n        uint256 _interestAccrued = calculateInterestAccrued(_id);\n        uint256 _currentDebt = (creditLineVariables[_id].principal)\n            .add(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate)\n            .add(_interestAccrued)\n            .sub(creditLineVariables[_id].totalInterestRepaid);\n        return _currentDebt;\n    }\n\n    /\n     * @notice used to calculate amount that can be borrowed by the borrower\n     * @dev is a view function for the protocol itself, but isn\'t view because of getTokensForShares which is not view.\n            borrowableAmount changes per block as interest changes per block.\n     * @param _id identifier for the credit line\n     * @return amount that can be borrowed from the credit line\n     /\n    function calculateBorrowableAmount(uint256 _id) public returns (uint256) {\n        CreditLineStatus _status = creditLineVariables[_id].status;\n        require(\n            _status == CreditLineStatus.ACTIVE || _status == CreditLineStatus.REQUESTED,\n            \'CreditLine: Cannot only if credit line ACTIVE or REQUESTED\'\n        );\n        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(\n            creditLineConstants[_id].collateralAsset,\n            creditLineConstants[_id].borrowAsset\n        );\n\n        uint256 _totalCollateralToken = calculateTotalCollateralTokens(_id);\n\n        uint256 _currentDebt = calculateCurrentDebt(_id);\n\n        uint256 _maxPossible = _totalCollateralToken.mul(_ratioOfPrices).div(creditLineConstants[_id].idealCollateralRatio).mul(1030).div(\n            10_decimals\n        );\n\n        uint256 _borrowLimit = creditLineConstants[_id].borrowLimit;\n\n        if (_maxPossible &gt; _borrowLimit) {\n            _maxPossible = _borrowLimit;\n        }\n        if (_maxPossible &gt; _currentDebt) {\n            return _maxPossible.sub(_currentDebt);\n        }\n        return 0;\n    }\n\n    function updateinterestAccruedTillLastPrincipalUpdate(uint256 _id) internal {\n        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, \'CreditLine: The credit line is not yet active.\');\n\n        uint256 _interestAccrued = calculateInterestAccrued(_id);\n        uint256 _newInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(_interestAccrued);\n        creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _newInterestAccrued;\n    }\n\n    function _depositCollateralFromSavingsAccount(\n        uint256 _id,\n        uint256 _amount,\n        address _sender\n    ) internal {\n        address _collateralAsset = creditLineConstants[_id].collateralAsset;\n        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();\n        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);\n        uint256 _activeAmount;\n\n        for (uint256 _index = 0; _index &lt; _strategyList.length; _index++) {\n            address _strategy = _strategyList[_index];\n            uint256 _liquidityShares = _savingsAccount.balanceInShares(_sender, _collateralAsset, _strategy);\n            if (_liquidityShares == 0 || _strategyList[_index] == address(0)) {\n                continue;\n            }\n            uint256 _tokenInStrategy = _liquidityShares;\n            _tokenInStrategy = IYield(_strategy).getTokensForShares(_liquidityShares, _collateralAsset);\n\n            uint256 _tokensToTransfer = _tokenInStrategy;\n            if (_activeAmount.add(_tokenInStrategy) &gt;= _amount) {\n                _tokensToTransfer = (_amount.sub(_activeAmount));\n            }\n            _activeAmount = _activeAmount.add(_tokensToTransfer);\n            _savingsAccount.transferFrom(_tokensToTransfer, _collateralAsset, _strategy, _sender, address(this));\n\n            collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(\n                _liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy)\n            );\n\n            if (_amount == _activeAmount) {\n                return;\n            }\n        }\n        revert(\'CreditLine::_depositCollateralFromSavingsAccount - Insufficient balance\');\n    }\n\n    /\n     * @notice used to request a credit line either by borrower or lender\n     * @param _requestTo Address to which creditLine is requested, \n                        if borrower creates request then lender address and \n                        if lender creates then borrower address\n     * @param _borrowLimit maximum borrow amount in a credit line\n     * @param _borrowRate Interest Rate at which credit Line is requested\n     * @param _autoLiquidation if true, anyone can liquidate loan, otherwise only lender\n     * @param _collateralRatio ratio of the collateral to the debt below which credit line can be liquidated\n     * @param _borrowAsset address of the token to be borrowed\n     * @param _collateralAsset address of the token provided as collateral\n     * @param _requestAsLender if true, lender is placing request, otherwise borrower\n     * @return identifier for the credit line\n     */\n\n    function request(\n        address _requestTo,\n        uint256 _borrowLimit,\n        uint256 _borrowRate,\n        bool _autoLiquidation,\n        uint256 _collateralRatio,\n        address _borrowAsset,\n        address _collateralAsset,\n        bool _requestAsLender\n    ) external returns (uint256) {\n        require(_borrowAsset != _collateralAsset, \'R: cant borrow lent token\');\n        require(IPriceOracle(priceOracle).doesFeedExist(_borrowAsset, _collateralAsset), \'R: No price feed\');\n\n        address _lender = _requestTo;\n        address _borrower = msg.sender;\n        if (_requestAsLender) {\n            _lender = msg.sender;\n            _borrower = _requestTo;\n        }\n\n        uint256 _id = _createRequest(\n            _lender,\n            _borrower,\n            _borrowLimit,\n            _borrowRate,\n            _autoLiquidation,\n            _collateralRatio,\n            _borrowAsset,\n            _collateralAsset,\n            _requestAsLender\n        );\n\n        emit CreditLineRequested(_id, _lender, _borrower);\n        return _id;\n    }\n\n    function _createRequest(\n        address _lender,\n        address _borrower,\n        uint256 _borrowLimit,\n        uint256 _borrowRate,\n        bool _autoLiquidation,\n        uint256 _collateralRatio,\n        address _borrowAsset,\n        address _collateralAsset,\n        bool _requestByLender\n    ) internal returns (uint256) {\n        require(_lender != _borrower, \'Lender and Borrower cannot be same addresses\');\n        uint256 _id = creditLineCounter + 1;\n        creditLineCounter = _id;\n        creditLineVariables[_id].status = CreditLineStatus.REQUESTED;\n        creditLineConstants[_id].borrower = _borrower;\n        creditLineConstants[_id].lender = _lender;\n        creditLineConstants[_id].borrowLimit = _borrowLimit;\n        creditLineConstants[_id].autoLiquidation = _autoLiquidation;\n        creditLineConstants[_id].idealCollateralRatio = _collateralRatio;\n        creditLineConstants[_id].borrowRate = _borrowRate;\n        creditLineConstants[_id].borrowAsset = _borrowAsset;\n        creditLineConstants[_id].collateralAsset = _collateralAsset;\n        creditLineConstants[_id].requestByLender = _requestByLender;\n        return _id;\n    }\n\n    /\n     * @notice used to accept a credit line\n     * @dev if borrower places request, lender can accept and vice versa\n     * @param _id identifier for the credit line\n     /\n    function accept(uint256 _id) external {\n        require(\n            creditLineVariables[_id].status == CreditLineStatus.REQUESTED,\n            \'CreditLine::acceptCreditLineLender - CreditLine is already accepted\'\n        );\n        bool _requestByLender = creditLineConstants[_id].requestByLender;\n        require(\n            (msg.sender == creditLineConstants[_id].borrower &amp;&amp; _requestByLender) ||\n                (msg.sender == creditLineConstants[_id].lender &amp;&amp; !_requestByLender),\n            "Only Borrower or Lender who hasn\'t requested can accept"\n        );\n        creditLineVariables[_id].status = CreditLineStatus.ACTIVE;\n        emit CreditLineAccepted(_id);\n    }\n\n    /\n     * @notice used to deposit collateral into the credit line\n     * @dev collateral tokens have to be approved in savingsAccount or token contract(unless ether).\n            If transferred from savings account, the tokens are transferred from strategies in the \n            order prespecified in strategy registry\n     * @param _id identifier for the credit line\n     * @param _amount amount of collateral being deposited\n     * @param _strategy strategy to which collateral is to be deposited in case transfer is not from savings account\n     * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount \n                                otherwise direct from collateral token contract\n     /\n    function depositCollateral(\n        uint256 _id,\n        uint256 _amount,\n        address _strategy,\n        bool _fromSavingsAccount\n    ) external payable nonReentrant ifCreditLineExists(_id) {\n        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, \'CreditLine not active\');\n        _depositCollateral(_id, _amount, _strategy, _fromSavingsAccount);\n        emit CollateralDeposited(_id, _amount, _strategy);\n    }\n\n    function _depositCollateral(\n        uint256 _id,\n        uint256 _amount,\n        address _strategy,\n        bool _fromSavingsAccount\n    ) internal {\n        require(creditLineConstants[_id].lender != msg.sender, \'lender cant deposit collateral\');\n        if (_fromSavingsAccount) {\n            _depositCollateralFromSavingsAccount(_id, _amount, msg.sender);\n        } else {\n            address _collateralAsset = creditLineConstants[_id].collateralAsset;\n            ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);\n            if (_collateralAsset == address(0)) {\n                require(msg.value == _amount, "CreditLine::_depositCollateral - value to transfer doesn\'t match argument");\n            } else {\n                IERC20(_collateralAsset).safeTransferFrom(msg.sender, address(this), _amount);\n                IERC20(_collateralAsset).approve(_strategy, _amount);\n            }\n            uint256 _sharesReceived = _savingsAccount.deposit{value: msg.value}(_amount, _collateralAsset, _strategy, address(this));\n            collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(_sharesReceived);\n        }\n    }\n\n    function _withdrawBorrowAmount(\n        address _asset,\n        uint256 _amountInTokens,\n        address _lender\n    ) internal {\n        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();\n        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);\n        uint256 _activeAmount;\n        for (uint256 _index = 0; _index &lt; _strategyList.length; _index++) {\n            if (_strategyList[_index] == address(0)) {\n                continue;\n            }\n            uint256 _liquidityShares = _savingsAccount.balanceInShares(_lender, _asset, _strategyList[_index]);\n            if (_liquidityShares != 0) {\n                uint256 tokenInStrategy = _liquidityShares;\n                tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);\n                uint256 _tokensToTransfer = tokenInStrategy;\n                if (_activeAmount.add(tokenInStrategy) &gt;= _amountInTokens) {\n                    _tokensToTransfer = (_amountInTokens.sub(_activeAmount));\n                }\n                _activeAmount = _activeAmount.add(_tokensToTransfer);\n                _savingsAccount.withdrawFrom(_tokensToTransfer, _asset, _strategyList[_index], _lender, address(this), false);\n                if (_activeAmount == _amountInTokens) {\n                    return;\n                }\n            }\n        }\n        require(_activeAmount == _amountInTokens, \'insufficient balance\');\n    }\n\n    /\n     * @notice used to borrow tokens from credit line by borrower\n     * @dev only borrower can call this function. Amount that can actually be borrowed is \n            min(amount based on borrowLimit, allowance to creditLine contract, balance of lender)\n     * @param _id identifier for the credit line\n     * @param _amount amount of tokens to borrow\n     */\n    function borrow(uint256 _id, uint256 _amount) external payable nonReentrant onlyCreditLineBorrower(_id) {\n        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, \'CreditLine: The credit line is not yet active.\');\n        uint256 _borrowableAmount = calculateBorrowableAmount(_id);\n        require(_amount &lt;= _borrowableAmount, "CreditLine::borrow - The current collateral ratio doesn\'t allow to withdraw the amount");\n        address _borrowAsset = creditLineConstants[_id].borrowAsset;\n        address _lender = creditLineConstants[_id].lender;\n\n        updateinterestAccruedTillLastPrincipalUpdate(_id);\n        creditLineVariables[_id].principal = creditLineVariables[_id].principal.add(_amount);\n        creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;\n\n        uint256 _tokenDiffBalance;\n        if (_borrowAsset != address(0)) {\n            uint256 _balanceBefore = IERC20(_borrowAsset).balanceOf(address(this));\n            _withdrawBorrowAmount(_borrowAsset, _amount, _lender);\n            uint256 _balanceAfter = IERC20(_borrowAsset).balanceOf(address(this));\n            _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);\n        } else {\n            uint256 _balanceBefore = address(this).balance;\n            _withdrawBorrowAmount(_borrowAsset, _amount, _lender);\n            uint256 _balanceAfter = address(this).balance;\n            _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);\n        }\n        uint256 _protocolFee = _tokenDiffBalance.mul(protocolFeeFraction).div(1030);\n        _tokenDiffBalance = _tokenDiffBalance.sub(_protocolFee);\n\n        if (_borrowAsset == address(0)) {\n            (bool feeSuccess, ) = protocolFeeCollector.call{value: _protocolFee}(\'\');\n            require(feeSuccess, \'Transfer fail\');\n            (bool success, ) = msg.sender.call{value: _tokenDiffBalance}(\'\');\n            require(success, \'Transfer fail\');\n        } else {\n            IERC20(_borrowAsset).safeTransfer(protocolFeeCollector, _protocolFee);\n            IERC20(_borrowAsset).safeTransfer(msg.sender, _tokenDiffBalance);\n        }\n        emit BorrowedFromCreditLine(_id, _tokenDiffBalance);\n    }\n\n    function _repayFromSavingsAccount(\n        uint256 _amount,\n        address _asset,\n        address _lender\n    ) internal {\n        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();\n        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);\n        uint256 _activeAmount;\n\n        for (uint256 _index = 0; _index &lt; _strategyList.length; _index++) {\n            if (_strategyList[_index] == address(0)) {\n                continue;\n            }\n            uint256 _liquidityShares = _savingsAccount.balanceInShares(msg.sender, _asset, _strategyList[_index]);\n            if (_liquidityShares == 0) {\n                continue;\n            }\n            uint256 _tokenInStrategy = _liquidityShares;\n            _tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);\n\n            uint256 _tokensToTransfer = _tokenInStrategy;\n            if (_activeAmount.add(_tokenInStrategy) &gt;= _amount) {\n                _tokensToTransfer = (_amount.sub(_activeAmount));\n            }\n            _activeAmount = _activeAmount.add(_tokensToTransfer);\n            _savingsAccount.transferFrom(_tokensToTransfer, _asset, _strategyList[_index], msg.sender, _lender);\n\n            if (_amount == _activeAmount) {\n                return;\n            }\n        }\n        revert(\'CreditLine::_repayFromSavingsAccount - Insufficient balance\');\n    }\n\n    function _repay(\n        uint256 _id,\n        uint256 _amount,\n        bool _fromSavingsAccount,\n        uint256 _principalPaid\n    ) internal {\n        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);\n        address _defaultStrategy = defaultStrategy;\n        address _borrowAsset = creditLineConstants[_id].borrowAsset;\n        address _lender = creditLineConstants[_id].lender;\n        if (!_fromSavingsAccount) {\n            if (_borrowAsset == address(0)) {\n                require(msg.value == _amount, \'creditLine::repay - Ether sent not equal to repay amount\');\n                _savingsAccount.deposit{value: _amount}(_amount, _borrowAsset, _defaultStrategy, _lender);\n            } else {\n                IERC20(_borrowAsset).safeTransferFrom(msg.sender, address(this), _amount);\n                IERC20(_borrowAsset).approve(_defaultStrategy, _amount);\n                _savingsAccount.deposit(_amount, _borrowAsset, _defaultStrategy, _lender);\n            }\n        } else {\n            _repayFromSavingsAccount(_amount, _borrowAsset, _lender);\n        }\n        if (_principalPaid != 0) {\n            _savingsAccount.increaseAllowanceToCreditLine(_principalPaid, _borrowAsset, _lender);\n        }\n    }\n\n    /\n     * @notice used to repay interest and principal to credit line. Interest has to be repaid before repaying principal\n     * @dev partial repayments possible\n     * @param _id identifier for the credit line\n     * @param _amount amount being repaid\n     * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount \n                                otherwise direct from collateral token contract\n     */\n    function repay(\n        uint256 _id,\n        uint256 _amount,\n        bool _fromSavingsAccount\n    ) external payable nonReentrant {\n        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, \'CreditLine: The credit line is not yet active.\');\n        require(creditLineConstants[_id].lender != msg.sender, \'Lender cant repay\');\n\n        uint256 _interestSincePrincipalUpdate = calculateInterestAccrued(_id);\n        uint256 _totalInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(\n            _interestSincePrincipalUpdate\n        );\n        uint256 _interestToPay = _totalInterestAccrued.sub(creditLineVariables[_id].totalInterestRepaid);\n        uint256 _totalCurrentDebt = _interestToPay.add(creditLineVariables[_id].principal);\n        uint256 _principalPaid = 0;\n\n        if (_amount &gt;= _totalCurrentDebt) {\n            _amount = _totalCurrentDebt;\n            emit CompleteCreditLineRepaid(_id, _amount);\n        } else {\n            emit PartialCreditLineRepaid(_id, _amount);\n        }\n\n        if (_amount &gt; _interestToPay) {\n            creditLineVariables[_id].principal = _totalCurrentDebt.sub(_amount);\n            creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _totalInterestAccrued;\n            creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;\n            creditLineVariables[_id].totalInterestRepaid = _totalInterestAccrued;\n            _principalPaid = _amount.sub(_interestToPay);\n        } else {\n            creditLineVariables[_id].totalInterestRepaid = creditLineVariables[_id].totalInterestRepaid.add(_amount);\n        }\n\n        _repay(_id, _amount, _fromSavingsAccount, _principalPaid);\n\n        if (creditLineVariables[_id].principal == 0) {\n            _resetCreditLine(_id);\n        }\n    }\n\n    function _resetCreditLine(uint256 _id) internal {\n        creditLineVariables[_id].lastPrincipalUpdateTime = 0;\n        creditLineVariables[_id].totalInterestRepaid = 0;\n        creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = 0;\n        emit CreditLineReset(_id);\n    }\n\n    /\n     * @dev used to close credit line by borrower or lender\n     * @param _id identifier for the credit line\n     /\n    function close(uint256 _id) external ifCreditLineExists(_id) {\n        require(\n            msg.sender == creditLineConstants[_id].borrower || msg.sender == creditLineConstants[_id].lender,\n            \'CreditLine: Permission denied while closing Line of credit\'\n        );\n        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, \'CreditLine: Credit line should be active.\');\n        require(creditLineVariables[_id].principal == 0, \'CreditLine: Cannot be closed since not repaid.\');\n        require(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate == 0, \'CreditLine: Cannot be closed since not repaid.\');\n        creditLineVariables[_id].status = CreditLineStatus.CLOSED;\n        emit CreditLineClosed(_id);\n    }\n\n    /\n     * @notice used to calculate the current collateral ratio\n     * @dev is a view function for the protocol itself, but isn\'t view because of getTokensForShares which is not view.\n            Interest is also considered while calculating debt\n     * @param _id identifier for the credit line\n     * @return collateral ratio multiplied by 1030 to retain precision\n     /\n    function calculateCurrentCollateralRatio(uint256 _id) public ifCreditLineExists(_id) returns (uint256) {\n        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(\n            creditLineConstants[_id].collateralAsset,\n            creditLineConstants[_id].borrowAsset\n        );\n\n        uint256 currentDebt = calculateCurrentDebt(_id);\n        uint256 currentCollateralRatio = calculateTotalCollateralTokens(_id).mul(_ratioOfPrices).div(currentDebt).mul(1030).div(\n            10_decimals\n        );\n\n        return currentCollateralRatio;\n    }\n\n    /\n     * @notice used to calculate the total collateral tokens\n     * @dev is a view function for the protocol itself, but isn\'t view because of getTokensForShares which is not view\n     * @param _id identifier for the credit line\n     * @return _amount total collateral tokens deposited into the credit line\n     */\n    function calculateTotalCollateralTokens(uint256 _id) public returns (uint256 _amount) {\n        address _collateralAsset = creditLineConstants[_id].collateralAsset;\n        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();\n        uint256 _liquidityShares;\n        for (uint256 index = 0; index &lt; _strategyList.length; index++) {\n            if (_strategyList[index] == address(0)) {\n                continue;\n            }\n            _liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];\n            uint256 _tokenInStrategy = _liquidityShares;\n            _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(_liquidityShares, _collateralAsset);\n\n            _amount = _amount.add(_tokenInStrategy);\n        }\n    }\n\n    /\n     * @notice used to withdraw any excess collateral\n     * @dev collateral can\'t be withdraw if collateralRatio goes below the ideal value. Only borrower can withdraw\n     * @param _id identifier for the credit line\n     * @param _amount amount of collateral to withdraw\n     * @param _toSavingsAccount if true, tokens are transferred from savingsAccount \n                                otherwise direct from collateral token contract\n     /\n    function withdrawCollateral(\n        uint256 _id,\n        uint256 _amount,\n        bool _toSavingsAccount\n    ) external nonReentrant onlyCreditLineBorrower(_id) {\n        uint256 _withdrawableCollateral = withdrawableCollateral(_id);\n        require(_amount &lt;= _withdrawableCollateral, \'Collateral ratio cant go below ideal\');\n        address _collateralAsset = creditLineConstants[_id].collateralAsset;\n        _transferCollateral(_id, _collateralAsset, _amount, _toSavingsAccount);\n        emit CollateralWithdrawn(_id, _amount);\n    }\n\n    /\n     * @notice used to calculate the collateral that can be withdrawn\n     * @dev is a view function for the protocol itself, but isn\'t view because of getTokensForShares which is not view\n     * @param _id identifier for the credit line\n     * @return total collateral withdrawable by borrower\n     /\n    function withdrawableCollateral(uint256 _id) public returns (uint256) {\n        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(\n            creditLineConstants[_id].collateralAsset,\n            creditLineConstants[_id].borrowAsset\n        );\n\n        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);\n        uint256 _currentDebt = calculateCurrentDebt(_id);\n\n        uint256 _collateralNeeded = _currentDebt\n            .mul(creditLineConstants[_id].idealCollateralRatio)\n            .div(_ratioOfPrices)\n            .mul(10_decimals)\n            .div(1030);\n\n        if (_collateralNeeded &gt;= _totalCollateralTokens) {\n            return 0;\n        }\n        return _totalCollateralTokens.sub(_collateralNeeded);\n    }\n\n    function _transferCollateral(\n        uint256 _id,\n        address _asset,\n        uint256 _amountInTokens,\n        bool _toSavingsAccount\n    ) internal {\n        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();\n        uint256 _activeAmount;\n        for (uint256 index = 0; index &lt; _strategyList.length; index++) {\n            uint256 liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];\n            if (liquidityShares == 0 || _strategyList[index] == address(0)) {\n                continue;\n            }\n            uint256 _tokenInStrategy = liquidityShares;\n            _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(liquidityShares, _asset);\n            uint256 _tokensToTransfer = _tokenInStrategy;\n            if (_activeAmount.add(_tokenInStrategy) &gt; _amountInTokens) {\n                _tokensToTransfer = _amountInTokens.sub(_activeAmount);\n                liquidityShares = liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy);\n            }\n            _activeAmount = _activeAmount.add(_tokensToTransfer);\n            collateralShareInStrategy[_id][_strategyList[index]] = collateralShareInStrategy[_id][_strategyList[index]].sub(\n                liquidityShares\n            );\n            if (_toSavingsAccount) {\n                ISavingsAccount(savingsAccount).transfer(_tokensToTransfer, _asset, _strategyList[index], msg.sender);\n            } else {\n                ISavingsAccount(savingsAccount).withdraw(_tokensToTransfer, _asset, _strategyList[index], msg.sender, false);\n            }\n\n            if (_activeAmount == _amountInTokens) {\n                return;\n            }\n        }\n        revert(\'insufficient collateral\');\n    }\n\n    /\n     * @notice used to liquidate credit line in case collateral ratio goes below the threshold\n     * @dev if lender liquidates, then collateral is directly transferred. \n            If autoLiquidation is true, anyone can liquidate by providing enough borrow tokens\n     * @param _id identifier for the credit line\n     * @param _toSavingsAccount if true, tokens are transferred from savingsAccount \n                                otherwise direct from collateral token contract\n     */\n    function liquidate(uint256 _id, bool _toSavingsAccount) external payable nonReentrant {\n        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, \'CreditLine: Credit line should be active.\');\n        require(creditLineVariables[_id].principal != 0, \'CreditLine: cannot liquidate if principal is 0\');\n\n        uint256 currentCollateralRatio = calculateCurrentCollateralRatio(_id);\n        require(\n            currentCollateralRatio &lt; creditLineConstants[_id].idealCollateralRatio,\n            \'CreditLine: Collateral ratio is higher than ideal value\'\n        );\n\n        address _collateralAsset = creditLineConstants[_id].collateralAsset;\n        address _lender = creditLineConstants[_id].lender;\n        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);\n        address _borrowAsset = creditLineConstants[_id].borrowAsset;\n\n        creditLineVariables[_id].status = CreditLineStatus.LIQUIDATED;\n\n        if (creditLineConstants[_id].autoLiquidation &amp;&amp; _lender != msg.sender) {\n            uint256 _borrowTokens = _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens);\n            if (_borrowAsset == address(0)) {\n                uint256 _returnETH = msg.value.sub(_borrowTokens, \'Insufficient ETH to liquidate\');\n                if (_returnETH != 0) {\n                    (bool success, ) = msg.sender.call{value: _returnETH}(\'\');\n                    require(success, \'Transfer fail\');\n                }\n            } else {\n                IERC20(_borrowAsset).safeTransferFrom(msg.sender, _lender, _borrowTokens);\n            }\n        }\n\n        _transferCollateral(_id, _collateralAsset, _totalCollateralTokens, _toSavingsAccount);\n\n        emit CreditLineLiquidated(_id, msg.sender);\n    }\n\n    /\n     * @notice used to calculate the borrow tokens necessary for liquidator to liquidate\n     * @dev is a view function for the protocol itself, but isn\'t view because of getTokensForShares which is not view\n     * @param _id identifier for the credit line\n     * @return borrow tokens necessary for liquidator to liquidate\n     /\n    function borrowTokensToLiquidate(uint256 _id) external returns (uint256) {\n        address _collateralAsset = creditLineConstants[_id].collateralAsset;\n        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);\n        address _borrowAsset = creditLineConstants[_id].borrowAsset;\n\n        return _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens);\n    }\n\n    function _borrowTokensToLiquidate(\n        address _borrowAsset,\n        address _collateralAsset,\n        uint256 _totalCollateralTokens\n    ) internal view returns (uint256) {\n        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(_borrowAsset, _collateralAsset);\n        uint256 _borrowTokens = (\n            _totalCollateralTokens.mul(uint256(1030).sub(liquidatorRewardFraction)).div(1030).mul(_ratioOfPrices).div(10*_decimals)\n        );\n\n        return _borrowTokens;\n    }\n\n    receive() external payable {\n        require(msg.sender == savingsAccount, \'CreditLine::receive invalid transaction\');\n    }\n}\n'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-22-08 11:42:57 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Chief Executive Officer |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol'; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/utils/ReentrancyGuard.sol'; import '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol'; import '../interfaces/IPriceOracle.sol'; import '../interfaces/IYield.sol'; import '../interfaces/ISavingsAccount.sol'; import '../SavingsAccount/SavingsAccountUtil.sol'; import '../interfaces/IStrategyRegistry.sol'; /  * @title Credit Line contract with Methods related to credit Line  * @notice Implements the functions related to Credit Line  * @author Sublime  / contract CreditLine is ReentrancyGuard, OwnableUpgradeable {     using SafeERC20 for IERC20;     using SafeMath for uint256; enum CreditLineStatus {     NOT_CREATED,     REQUESTED,     ACTIVE,     CLOSED,     CANCELLED,     LIQUIDATED }  /**  * @notice counter that tracks the number of credit lines created  * @dev used to create unique identifier for credit lines  **/ uint256 public creditLineCounter;  uint256 constant YEAR_IN_SECONDS = 365 days;  struct CreditLineVariables {     CreditLineStatus status;     uint256 principal;     uint256 totalInterestRepaid;     uint256 lastPrincipalUpdateTime;     uint256 interestAccruedTillLastPrincipalUpdate; }  struct CreditLineConstants {     address lender;     address borrower;     uint256 borrowLimit;     uint256 idealCollateralRatio;     uint256 borrowRate;     address borrowAsset;     address collateralAsset;     bool autoLiquidation;     bool requestByLender; } /**  * @notice stores the collateral shares in a credit line per strategy  * @dev creditLineId =&gt; Strategy =&gt; collateralShares  **/ mapping(uint256 =&gt; mapping(address =&gt; uint256)) public collateralShareInStrategy;  /**  * @notice stores the variables to maintain a credit line  **/ mapping(uint256 =&gt; CreditLineVariables) public creditLineVariables;  /**  * @notice stores the constants related to a credit line  **/ mapping(uint256 =&gt; CreditLineConstants) public creditLineConstants;  /**  * @notice stores the address of savings account contract  **/ address public savingsAccount;  /**  * @notice stores the address of price oracle contract  **/ address public priceOracle;  /**  * @notice stores the address of strategy registry contract  **/ address public strategyRegistry;  /**  * @notice stores the address of default strategy  **/ address public defaultStrategy;  /**  * @notice stores the fraction of borrowed amount charged as fee by protocol  * @dev it is multiplied by 10**30  **/ uint256 public protocolFeeFraction;  /**  * @notice address where protocol fee is collected  **/ address public protocolFeeCollector;  /**  * @notice stores the fraction of amount liquidated given as reward to liquidator  * @dev it is multiplied by 10**30  **/ uint256 public liquidatorRewardFraction; /**  * @dev checks if Credit Line exists  * @param _id identifier for the credit line  **/ modifier ifCreditLineExists(uint256 _id) {     require(creditLineVariables[_id].status != CreditLineStatus.NOT_CREATED, 'Credit line does not exist');     _; }  /**  * @dev checks if called by credit Line Borrower  * @param _id creditLine identifier  **/ modifier onlyCreditLineBorrower(uint256 _id) {     require(creditLineConstants[_id].borrower == msg.sender, 'Only credit line Borrower can access');     _; }  /**  * @dev checks if called by credit Line Lender  * @param _id creditLine identifier  **/ modifier onlyCreditLineLender(uint256 _id) {     require(creditLineConstants[_id].lender == msg.sender, 'Only credit line Lender can access');     _; }  /**  * @notice emitted when a collateral is deposited into credit line  * @param id id of the credit line  * @param amount amount of collateral deposited  * @param strategy address of the strategy into which collateral is deposited  */ event CollateralDeposited(uint256 indexed id, uint256 amount, address indexed strategy);  /**  * @notice emitted when collateral is withdrawn from credit line  * @param id id of the credit line  * @param amount amount of collateral withdrawn  */ event CollateralWithdrawn(uint256 indexed id, uint256 amount);  /**  * @notice emitted when a request for new credit line is placed  * @param id id of the credit line for which request was made  * @param lender address of the lender for credit line  * @param borrower address of the borrower for credit line  */ event CreditLineRequested(uint256 indexed id, address indexed lender, address indexed borrower);  /**  * @notice emitted when a credit line is liquidated  * @param id id of the credit line which is liquidated  * @param liquidator address of the liquidator  */ event CreditLineLiquidated(uint256 indexed id, address indexed liquidator);  /**  * @notice emitted when tokens are borrowed from credit line  * @param id id of the credit line from which tokens are borrowed  * @param borrowAmount amount of tokens borrowed  */ event BorrowedFromCreditLine(uint256 indexed id, uint256 borrowAmount);  /**  * @notice emitted when credit line is accepted  * @param id id of the credit line that was accepted  */ event CreditLineAccepted(uint256 indexed id);  /**  * @notice emitted when credit line is completely repaid and reset  * @param id id of the credit line that is reset  */ event CreditLineReset(uint256 indexed id);  /**  * @notice emitted when the credit line is partially repaid  * @param id id of the credit line  * @param repayAmount amount repaid  */ event PartialCreditLineRepaid(uint256 indexed id, uint256 repayAmount);  /**  * @notice emitted when the credit line is completely repaid  * @param id id of the credit line  * @param repayAmount amount repaid  */ event CompleteCreditLineRepaid(uint256 indexed id, uint256 repayAmount);  /**  * @notice emitted when the credit line is closed by one of the parties of credit line  * @param id id of the credit line  */ event CreditLineClosed(uint256 indexed id);  /**  * @notice emitted when default strategy for the credit line is updated  * @param defaultStrategy address of the strategy contract that is used as default by credit lines  */ event DefaultStrategyUpdated(address indexed defaultStrategy);  /**  * @notice emitted when the price oracle is updated  * @param priceOracle address of the updated price oracle  */ event PriceOracleUpdated(address indexed priceOracle);  /**  * @notice emitted when the savings account address is updated  * @param savingsAccount address of the updated savingsAccount  */ event SavingsAccountUpdated(address indexed savingsAccount);  /**  * @notice emitted when strategy registry address is updated  * @param strategyRegistry address of the updated strategy registry  */ event StrategyRegistryUpdated(address indexed strategyRegistry);  /**  * @notice emitted when fee that protocol charges for credit line is updated  * @param updatedProtocolFee updated value of protocolFeeFraction  */ event ProtocolFeeFractionUpdated(uint256 updatedProtocolFee);  /**  * @notice emitted when address which receives fee that protocol changes for pools is updated  * @param updatedProtocolFeeCollector updated value of protocolFeeCollector  */ event ProtocolFeeCollectorUpdated(address indexed updatedProtocolFeeCollector);  /**  * @notice emitted when liquidatorRewardFraction is updated  * @param liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator  */ event LiquidationRewardFractionUpdated(uint256 liquidatorRewardFraction);  /**  * @notice used to initialize the contract  * @dev can only be called once during the life cycle of the contract  * @param _defaultStrategy default strategy used in credit lines  * @param _priceOracle address of the priceOracle  * @param _savingsAccount address of  the savings account contract  * @param _strategyRegistry address of the strategy registry contract  * @param _owner address of owner who can change global variables  * @param _protocolFeeFraction fraction of the fee charged by protocol  * @param _protocolFeeCollector address to which protocol fee is charged to  * @param _liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator  */ function initialize(     address _defaultStrategy,     address _priceOracle,     address _savingsAccount,     address _strategyRegistry,     address _owner,     uint256 _protocolFeeFraction,     address _protocolFeeCollector,     uint256 _liquidatorRewardFraction ) external initializer {     OwnableUpgradeable.__Ownable_init();     OwnableUpgradeable.transferOwnership(_owner);      _updateDefaultStrategy(_defaultStrategy);     _updatePriceOracle(_priceOracle);     _updateSavingsAccount(_savingsAccount);     _updateStrategyRegistry(_strategyRegistry);     _updateProtocolFeeFraction(_protocolFeeFraction);     _updateProtocolFeeCollector(_protocolFeeCollector);     _updateLiquidatorRewardFraction(_liquidatorRewardFraction); }  /**  * @notice used to update the default strategy  * @dev can only be updated by owner  * @param _defaultStrategy address of the updated default strategy  */ function updateDefaultStrategy(address _defaultStrategy) external onlyOwner {     _updateDefaultStrategy(_defaultStrategy); }  function _updateDefaultStrategy(address _defaultStrategy) internal {     defaultStrategy = _defaultStrategy;     emit DefaultStrategyUpdated(_defaultStrategy); }  /**  * @notice used to update the price oracle  * @dev can only be updated by owner  * @param _priceOracle address of the updated price oracle  */ function updatePriceOracle(address _priceOracle) external onlyOwner {     _updatePriceOracle(_priceOracle); }  function _updatePriceOracle(address _priceOracle) internal {     priceOracle = _priceOracle;     emit PriceOracleUpdated(_priceOracle); }  /**  * @notice used to update the savings account address  * @dev can only be updated by owner  * @param _savingsAccount address of the updated savings account  */ function updateSavingsAccount(address _savingsAccount) external onlyOwner {     _updateSavingsAccount(_savingsAccount); }  function _updateSavingsAccount(address _savingsAccount) internal {     savingsAccount = _savingsAccount;     emit SavingsAccountUpdated(_savingsAccount); }  /**  * @notice used to update the protocol fee fraction  * @dev can only be updated by owner  * @param _protocolFee fraction of the borrower amount collected as protocol fee  */ function updateProtocolFeeFraction(uint256 _protocolFee) external onlyOwner {     _updateProtocolFeeFraction(_protocolFee); }  function _updateProtocolFeeFraction(uint256 _protocolFee) internal {     protocolFeeFraction = _protocolFee;     emit ProtocolFeeFractionUpdated(_protocolFee); }  /**  * @notice used to update the protocol fee collector  * @dev can only be updated by owner  * @param _protocolFeeCollector address in which protocol fee is collected  */ function updateProtocolFeeCollector(address _protocolFeeCollector) external onlyOwner {     _updateProtocolFeeCollector(_protocolFeeCollector); }  function _updateProtocolFeeCollector(address _protocolFeeCollector) internal {     require(_protocolFeeCollector != address(0), 'cant be 0 address');     protocolFeeCollector = _protocolFeeCollector;     emit ProtocolFeeCollectorUpdated(_protocolFeeCollector); }  /**  * @notice used to update the strategy registry address  * @dev can only be updated by owner  * @param _strategyRegistry address of the updated strategy registry  */ function updateStrategyRegistry(address _strategyRegistry) external onlyOwner {     _updateStrategyRegistry(_strategyRegistry); }  function _updateStrategyRegistry(address _strategyRegistry) internal {     require(_strategyRegistry != address(0), 'CL::I zero address');     strategyRegistry = _strategyRegistry;     emit StrategyRegistryUpdated(_strategyRegistry); }  /**  * @notice used to update the liquidatorRewardFraction  * @dev can only be updated by owner  * @param _rewardFraction fraction of liquidated amount given to liquidator as reward  */ function updateLiquidatorRewardFraction(uint256 _rewardFraction) external onlyOwner {     _updateLiquidatorRewardFraction(_rewardFraction); }  function _updateLiquidatorRewardFraction(uint256 _rewardFraction) internal {     require(_rewardFraction &lt;= 10**30, 'Fraction has to be less than 1');     liquidatorRewardFraction = _rewardFraction;     emit LiquidationRewardFractionUpdated(_rewardFraction); }  /**  * @dev Used to Calculate Interest Per second on given principal and Interest rate  * @param _principal principal Amount for which interest has to be calculated.  * @param _borrowRate It is the Interest Rate at which Credit Line is approved  * @return interest per second for the given parameters  */ function calculateInterest(     uint256 _principal,     uint256 _borrowRate,     uint256 _timeElapsed ) public pure returns (uint256) {     uint256 _interest = _principal.mul(_borrowRate).mul(_timeElapsed).div(10**30).div(YEAR_IN_SECONDS);      return _interest; }  /**  * @dev Used to calculate interest accrued since last repayment  * @param _id identifier for the credit line  * @return interest accrued over current borrowed amount since last repayment  */  function calculateInterestAccrued(uint256 _id) public view returns (uint256) {     uint256 _lastPrincipalUpdateTime = creditLineVariables[_id].lastPrincipalUpdateTime;     if (_lastPrincipalUpdateTime == 0) return 0;     uint256 _timeElapsed = (block.timestamp).sub(_lastPrincipalUpdateTime);     uint256 _interestAccrued = calculateInterest(creditLineVariables[_id].principal, creditLineConstants[_id].borrowRate, _timeElapsed);     return _interestAccrued; }  /**  * @dev Used to calculate current debt of borrower against a credit line.  * @param _id identifier for the credit line  * @return current debt of borrower  */ function calculateCurrentDebt(uint256 _id) public view returns (uint256) {     uint256 _interestAccrued = calculateInterestAccrued(_id);     uint256 _currentDebt = (creditLineVariables[_id].principal)         .add(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate)         .add(_interestAccrued)         .sub(creditLineVariables[_id].totalInterestRepaid);     return _currentDebt; }  /**  * @notice used to calculate amount that can be borrowed by the borrower  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view.         borrowableAmount changes per block as interest changes per block.  * @param _id identifier for the credit line  * @return amount that can be borrowed from the credit line  */ function calculateBorrowableAmount(uint256 _id) public returns (uint256) {     CreditLineStatus _status = creditLineVariables[_id].status;     require(         _status == CreditLineStatus.ACTIVE || _status == CreditLineStatus.REQUESTED,         'CreditLine: Cannot only if credit line ACTIVE or REQUESTED'     );     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(         creditLineConstants[_id].collateralAsset,         creditLineConstants[_id].borrowAsset     );      uint256 _totalCollateralToken = calculateTotalCollateralTokens(_id);      uint256 _currentDebt = calculateCurrentDebt(_id);      uint256 _maxPossible = _totalCollateralToken.mul(_ratioOfPrices).div(creditLineConstants[_id].idealCollateralRatio).mul(10**30).div(         10**_decimals     );      uint256 _borrowLimit = creditLineConstants[_id].borrowLimit;      if (_maxPossible &gt; _borrowLimit) {         _maxPossible = _borrowLimit;     }     if (_maxPossible &gt; _currentDebt) {         return _maxPossible.sub(_currentDebt);     }     return 0; }  function updateinterestAccruedTillLastPrincipalUpdate(uint256 _id) internal {     require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');      uint256 _interestAccrued = calculateInterestAccrued(_id);     uint256 _newInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(_interestAccrued);     creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _newInterestAccrued; }  function _depositCollateralFromSavingsAccount(     uint256 _id,     uint256 _amount,     address _sender ) internal {     address _collateralAsset = creditLineConstants[_id].collateralAsset;     address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();     ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);     uint256 _activeAmount;      for (uint256 _index = 0; _index &lt; _strategyList.length; _index++) {         address _strategy = _strategyList[_index];         uint256 _liquidityShares = _savingsAccount.balanceInShares(_sender, _collateralAsset, _strategy);         if (_liquidityShares == 0 || _strategyList[_index] == address(0)) {             continue;         }         uint256 _tokenInStrategy = _liquidityShares;         _tokenInStrategy = IYield(_strategy).getTokensForShares(_liquidityShares, _collateralAsset);          uint256 _tokensToTransfer = _tokenInStrategy;         if (_activeAmount.add(_tokenInStrategy) &gt;= _amount) {             _tokensToTransfer = (_amount.sub(_activeAmount));         }         _activeAmount = _activeAmount.add(_tokensToTransfer);         _savingsAccount.transferFrom(_tokensToTransfer, _collateralAsset, _strategy, _sender, address(this));          collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(             _liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy)         );          if (_amount == _activeAmount) {             return;         }     }     revert('CreditLine::_depositCollateralFromSavingsAccount - Insufficient balance'); }  /**  * @notice used to request a credit line either by borrower or lender  * @param _requestTo Address to which creditLine is requested,                      if borrower creates request then lender address and                      if lender creates then borrower address  * @param _borrowLimit maximum borrow amount in a credit line  * @param _borrowRate Interest Rate at which credit Line is requested  * @param _autoLiquidation if true, anyone can liquidate loan, otherwise only lender  * @param _collateralRatio ratio of the collateral to the debt below which credit line can be liquidated  * @param _borrowAsset address of the token to be borrowed  * @param _collateralAsset address of the token provided as collateral  * @param _requestAsLender if true, lender is placing request, otherwise borrower  * @return identifier for the credit line  */  function request(     address _requestTo,     uint256 _borrowLimit,     uint256 _borrowRate,     bool _autoLiquidation,     uint256 _collateralRatio,     address _borrowAsset,     address _collateralAsset,     bool _requestAsLender ) external returns (uint256) {     require(_borrowAsset != _collateralAsset, 'R: cant borrow lent token');     require(IPriceOracle(priceOracle).doesFeedExist(_borrowAsset, _collateralAsset), 'R: No price feed');      address _lender = _requestTo;     address _borrower = msg.sender;     if (_requestAsLender) {         _lender = msg.sender;         _borrower = _requestTo;     }      uint256 _id = _createRequest(         _lender,         _borrower,         _borrowLimit,         _borrowRate,         _autoLiquidation,         _collateralRatio,         _borrowAsset,         _collateralAsset,         _requestAsLender     );      emit CreditLineRequested(_id, _lender, _borrower);     return _id; }  function _createRequest(     address _lender,     address _borrower,     uint256 _borrowLimit,     uint256 _borrowRate,     bool _autoLiquidation,     uint256 _collateralRatio,     address _borrowAsset,     address _collateralAsset,     bool _requestByLender ) internal returns (uint256) {     require(_lender != _borrower, 'Lender and Borrower cannot be same addresses');     uint256 _id = creditLineCounter + 1;     creditLineCounter = _id;     creditLineVariables[_id].status = CreditLineStatus.REQUESTED;     creditLineConstants[_id].borrower = _borrower;     creditLineConstants[_id].lender = _lender;     creditLineConstants[_id].borrowLimit = _borrowLimit;     creditLineConstants[_id].autoLiquidation = _autoLiquidation;     creditLineConstants[_id].idealCollateralRatio = _collateralRatio;     creditLineConstants[_id].borrowRate = _borrowRate;     creditLineConstants[_id].borrowAsset = _borrowAsset;     creditLineConstants[_id].collateralAsset = _collateralAsset;     creditLineConstants[_id].requestByLender = _requestByLender;     return _id; }  /**  * @notice used to accept a credit line  * @dev if borrower places request, lender can accept and vice versa  * @param _id identifier for the credit line  */ function accept(uint256 _id) external {     require(         creditLineVariables[_id].status == CreditLineStatus.REQUESTED,         'CreditLine::acceptCreditLineLender - CreditLine is already accepted'     );     bool _requestByLender = creditLineConstants[_id].requestByLender;     require(         (msg.sender == creditLineConstants[_id].borrower &amp;&amp; _requestByLender) ||             (msg.sender == creditLineConstants[_id].lender &amp;&amp; !_requestByLender),         "Only Borrower or Lender who hasn't requested can accept"     );     creditLineVariables[_id].status = CreditLineStatus.ACTIVE;     emit CreditLineAccepted(_id); }  /**  * @notice used to deposit collateral into the credit line  * @dev collateral tokens have to be approved in savingsAccount or token contract(unless ether).         If transferred from savings account, the tokens are transferred from strategies in the          order prespecified in strategy registry  * @param _id identifier for the credit line  * @param _amount amount of collateral being deposited  * @param _strategy strategy to which collateral is to be deposited in case transfer is not from savings account  * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount                              otherwise direct from collateral token contract  */ function depositCollateral(     uint256 _id,     uint256 _amount,     address _strategy,     bool _fromSavingsAccount ) external payable nonReentrant ifCreditLineExists(_id) {     require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine not active');     _depositCollateral(_id, _amount, _strategy, _fromSavingsAccount);     emit CollateralDeposited(_id, _amount, _strategy); }  function _depositCollateral(     uint256 _id,     uint256 _amount,     address _strategy,     bool _fromSavingsAccount ) internal {     require(creditLineConstants[_id].lender != msg.sender, 'lender cant deposit collateral');     if (_fromSavingsAccount) {         _depositCollateralFromSavingsAccount(_id, _amount, msg.sender);     } else {         address _collateralAsset = creditLineConstants[_id].collateralAsset;         ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);         if (_collateralAsset == address(0)) {             require(msg.value == _amount, "CreditLine::_depositCollateral - value to transfer doesn't match argument");         } else {             IERC20(_collateralAsset).safeTransferFrom(msg.sender, address(this), _amount);             IERC20(_collateralAsset).approve(_strategy, _amount);         }         uint256 _sharesReceived = _savingsAccount.deposit{value: msg.value}(_amount, _collateralAsset, _strategy, address(this));         collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(_sharesReceived);     } }  function _withdrawBorrowAmount(     address _asset,     uint256 _amountInTokens,     address _lender ) internal {     address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();     ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);     uint256 _activeAmount;     for (uint256 _index = 0; _index &lt; _strategyList.length; _index++) {         if (_strategyList[_index] == address(0)) {             continue;         }         uint256 _liquidityShares = _savingsAccount.balanceInShares(_lender, _asset, _strategyList[_index]);         if (_liquidityShares != 0) {             uint256 tokenInStrategy = _liquidityShares;             tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);             uint256 _tokensToTransfer = tokenInStrategy;             if (_activeAmount.add(tokenInStrategy) &gt;= _amountInTokens) {                 _tokensToTransfer = (_amountInTokens.sub(_activeAmount));             }             _activeAmount = _activeAmount.add(_tokensToTransfer);             _savingsAccount.withdrawFrom(_tokensToTransfer, _asset, _strategyList[_index], _lender, address(this), false);             if (_activeAmount == _amountInTokens) {                 return;             }         }     }     require(_activeAmount == _amountInTokens, 'insufficient balance'); }  /**  * @notice used to borrow tokens from credit line by borrower  * @dev only borrower can call this function. Amount that can actually be borrowed is          min(amount based on borrowLimit, allowance to creditLine contract, balance of lender)  * @param _id identifier for the credit line  * @param _amount amount of tokens to borrow  */ function borrow(uint256 _id, uint256 _amount) external payable nonReentrant onlyCreditLineBorrower(_id) {     require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');     uint256 _borrowableAmount = calculateBorrowableAmount(_id);     require(_amount &lt;= _borrowableAmount, "CreditLine::borrow - The current collateral ratio doesn't allow to withdraw the amount");     address _borrowAsset = creditLineConstants[_id].borrowAsset;     address _lender = creditLineConstants[_id].lender;      updateinterestAccruedTillLastPrincipalUpdate(_id);     creditLineVariables[_id].principal = creditLineVariables[_id].principal.add(_amount);     creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;      uint256 _tokenDiffBalance;     if (_borrowAsset != address(0)) {         uint256 _balanceBefore = IERC20(_borrowAsset).balanceOf(address(this));         _withdrawBorrowAmount(_borrowAsset, _amount, _lender);         uint256 _balanceAfter = IERC20(_borrowAsset).balanceOf(address(this));         _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);     } else {         uint256 _balanceBefore = address(this).balance;         _withdrawBorrowAmount(_borrowAsset, _amount, _lender);         uint256 _balanceAfter = address(this).balance;         _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);     }     uint256 _protocolFee = _tokenDiffBalance.mul(protocolFeeFraction).div(10**30);     _tokenDiffBalance = _tokenDiffBalance.sub(_protocolFee);      if (_borrowAsset == address(0)) {         (bool feeSuccess, ) = protocolFeeCollector.call{value: _protocolFee}('');         require(feeSuccess, 'Transfer fail');         (bool success, ) = msg.sender.call{value: _tokenDiffBalance}('');         require(success, 'Transfer fail');     } else {         IERC20(_borrowAsset).safeTransfer(protocolFeeCollector, _protocolFee);         IERC20(_borrowAsset).safeTransfer(msg.sender, _tokenDiffBalance);     }     emit BorrowedFromCreditLine(_id, _tokenDiffBalance); }  function _repayFromSavingsAccount(     uint256 _amount,     address _asset,     address _lender ) internal {     address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();     ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);     uint256 _activeAmount;      for (uint256 _index = 0; _index &lt; _strategyList.length; _index++) {         if (_strategyList[_index] == address(0)) {             continue;         }         uint256 _liquidityShares = _savingsAccount.balanceInShares(msg.sender, _asset, _strategyList[_index]);         if (_liquidityShares == 0) {             continue;         }         uint256 _tokenInStrategy = _liquidityShares;         _tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);          uint256 _tokensToTransfer = _tokenInStrategy;         if (_activeAmount.add(_tokenInStrategy) &gt;= _amount) {             _tokensToTransfer = (_amount.sub(_activeAmount));         }         _activeAmount = _activeAmount.add(_tokensToTransfer);         _savingsAccount.transferFrom(_tokensToTransfer, _asset, _strategyList[_index], msg.sender, _lender);          if (_amount == _activeAmount) {             return;         }     }     revert('CreditLine::_repayFromSavingsAccount - Insufficient balance'); }  function _repay(     uint256 _id,     uint256 _amount,     bool _fromSavingsAccount,     uint256 _principalPaid ) internal {     ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);     address _defaultStrategy = defaultStrategy;     address _borrowAsset = creditLineConstants[_id].borrowAsset;     address _lender = creditLineConstants[_id].lender;     if (!_fromSavingsAccount) {         if (_borrowAsset == address(0)) {             require(msg.value == _amount, 'creditLine::repay - Ether sent not equal to repay amount');             _savingsAccount.deposit{value: _amount}(_amount, _borrowAsset, _defaultStrategy, _lender);         } else {             IERC20(_borrowAsset).safeTransferFrom(msg.sender, address(this), _amount);             IERC20(_borrowAsset).approve(_defaultStrategy, _amount);             _savingsAccount.deposit(_amount, _borrowAsset, _defaultStrategy, _lender);         }     } else {         _repayFromSavingsAccount(_amount, _borrowAsset, _lender);     }     if (_principalPaid != 0) {         _savingsAccount.increaseAllowanceToCreditLine(_principalPaid, _borrowAsset, _lender);     } }  /**  * @notice used to repay interest and principal to credit line. Interest has to be repaid before repaying principal  * @dev partial repayments possible  * @param _id identifier for the credit line  * @param _amount amount being repaid  * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount                              otherwise direct from collateral token contract  */ function repay(     uint256 _id,     uint256 _amount,     bool _fromSavingsAccount ) external payable nonReentrant {     require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');     require(creditLineConstants[_id].lender != msg.sender, 'Lender cant repay');      uint256 _interestSincePrincipalUpdate = calculateInterestAccrued(_id);     uint256 _totalInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(         _interestSincePrincipalUpdate     );     uint256 _interestToPay = _totalInterestAccrued.sub(creditLineVariables[_id].totalInterestRepaid);     uint256 _totalCurrentDebt = _interestToPay.add(creditLineVariables[_id].principal);     uint256 _principalPaid = 0;      if (_amount &gt;= _totalCurrentDebt) {         _amount = _totalCurrentDebt;         emit CompleteCreditLineRepaid(_id, _amount);     } else {         emit PartialCreditLineRepaid(_id, _amount);     }      if (_amount &gt; _interestToPay) {         creditLineVariables[_id].principal = _totalCurrentDebt.sub(_amount);         creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _totalInterestAccrued;         creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;         creditLineVariables[_id].totalInterestRepaid = _totalInterestAccrued;         _principalPaid = _amount.sub(_interestToPay);     } else {         creditLineVariables[_id].totalInterestRepaid = creditLineVariables[_id].totalInterestRepaid.add(_amount);     }      _repay(_id, _amount, _fromSavingsAccount, _principalPaid);      if (creditLineVariables[_id].principal == 0) {         _resetCreditLine(_id);     } }  function _resetCreditLine(uint256 _id) internal {     creditLineVariables[_id].lastPrincipalUpdateTime = 0;     creditLineVariables[_id].totalInterestRepaid = 0;     creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = 0;     emit CreditLineReset(_id); }  /**  * @dev used to close credit line by borrower or lender  * @param _id identifier for the credit line  */ function close(uint256 _id) external ifCreditLineExists(_id) {     require(         msg.sender == creditLineConstants[_id].borrower || msg.sender == creditLineConstants[_id].lender,         'CreditLine: Permission denied while closing Line of credit'     );     require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: Credit line should be active.');     require(creditLineVariables[_id].principal == 0, 'CreditLine: Cannot be closed since not repaid.');     require(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate == 0, 'CreditLine: Cannot be closed since not repaid.');     creditLineVariables[_id].status = CreditLineStatus.CLOSED;     emit CreditLineClosed(_id); }  /**  * @notice used to calculate the current collateral ratio  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view.         Interest is also considered while calculating debt  * @param _id identifier for the credit line  * @return collateral ratio multiplied by 10**30 to retain precision  */ function calculateCurrentCollateralRatio(uint256 _id) public ifCreditLineExists(_id) returns (uint256) {     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(         creditLineConstants[_id].collateralAsset,         creditLineConstants[_id].borrowAsset     );      uint256 currentDebt = calculateCurrentDebt(_id);     uint256 currentCollateralRatio = calculateTotalCollateralTokens(_id).mul(_ratioOfPrices).div(currentDebt).mul(10**30).div(         10**_decimals     );      return currentCollateralRatio; }  /**  * @notice used to calculate the total collateral tokens  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view  * @param _id identifier for the credit line  * @return _amount total collateral tokens deposited into the credit line  */ function calculateTotalCollateralTokens(uint256 _id) public returns (uint256 _amount) {     address _collateralAsset = creditLineConstants[_id].collateralAsset;     address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();     uint256 _liquidityShares;     for (uint256 index = 0; index &lt; _strategyList.length; index++) {         if (_strategyList[index] == address(0)) {             continue;         }         _liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];         uint256 _tokenInStrategy = _liquidityShares;         _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(_liquidityShares, _collateralAsset);          _amount = _amount.add(_tokenInStrategy);     } }  /**  * @notice used to withdraw any excess collateral  * @dev collateral can't be withdraw if collateralRatio goes below the ideal value. Only borrower can withdraw  * @param _id identifier for the credit line  * @param _amount amount of collateral to withdraw  * @param _toSavingsAccount if true, tokens are transferred from savingsAccount                              otherwise direct from collateral token contract  */ function withdrawCollateral(     uint256 _id,     uint256 _amount,     bool _toSavingsAccount ) external nonReentrant onlyCreditLineBorrower(_id) {     uint256 _withdrawableCollateral = withdrawableCollateral(_id);     require(_amount &lt;= _withdrawableCollateral, 'Collateral ratio cant go below ideal');     address _collateralAsset = creditLineConstants[_id].collateralAsset;     _transferCollateral(_id, _collateralAsset, _amount, _toSavingsAccount);     emit CollateralWithdrawn(_id, _amount); }  /**  * @notice used to calculate the collateral that can be withdrawn  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view  * @param _id identifier for the credit line  * @return total collateral withdrawable by borrower  */ function withdrawableCollateral(uint256 _id) public returns (uint256) {     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(         creditLineConstants[_id].collateralAsset,         creditLineConstants[_id].borrowAsset     );      uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);     uint256 _currentDebt = calculateCurrentDebt(_id);      uint256 _collateralNeeded = _currentDebt         .mul(creditLineConstants[_id].idealCollateralRatio)         .div(_ratioOfPrices)         .mul(10**_decimals)         .div(10**30);      if (_collateralNeeded &gt;= _totalCollateralTokens) {         return 0;     }     return _totalCollateralTokens.sub(_collateralNeeded); }  function _transferCollateral(     uint256 _id,     address _asset,     uint256 _amountInTokens,     bool _toSavingsAccount ) internal {     address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();     uint256 _activeAmount;     for (uint256 index = 0; index &lt; _strategyList.length; index++) {         uint256 liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];         if (liquidityShares == 0 || _strategyList[index] == address(0)) {             continue;         }         uint256 _tokenInStrategy = liquidityShares;         _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(liquidityShares, _asset);         uint256 _tokensToTransfer = _tokenInStrategy;         if (_activeAmount.add(_tokenInStrategy) &gt; _amountInTokens) {             _tokensToTransfer = _amountInTokens.sub(_activeAmount);             liquidityShares = liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy);         }         _activeAmount = _activeAmount.add(_tokensToTransfer);         collateralShareInStrategy[_id][_strategyList[index]] = collateralShareInStrategy[_id][_strategyList[index]].sub(             liquidityShares         );         if (_toSavingsAccount) {             ISavingsAccount(savingsAccount).transfer(_tokensToTransfer, _asset, _strategyList[index], msg.sender);         } else {             ISavingsAccount(savingsAccount).withdraw(_tokensToTransfer, _asset, _strategyList[index], msg.sender, false);         }          if (_activeAmount == _amountInTokens) {             return;         }     }     revert('insufficient collateral'); }  /**  * @notice used to liquidate credit line in case collateral ratio goes below the threshold  * @dev if lender liquidates, then collateral is directly transferred.          If autoLiquidation is true, anyone can liquidate by providing enough borrow tokens  * @param _id identifier for the credit line  * @param _toSavingsAccount if true, tokens are transferred from savingsAccount                              otherwise direct from collateral token contract  */ function liquidate(uint256 _id, bool _toSavingsAccount) external payable nonReentrant {     require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: Credit line should be active.');     require(creditLineVariables[_id].principal != 0, 'CreditLine: cannot liquidate if principal is 0');      uint256 currentCollateralRatio = calculateCurrentCollateralRatio(_id);     require(         currentCollateralRatio &lt; creditLineConstants[_id].idealCollateralRatio,         'CreditLine: Collateral ratio is higher than ideal value'     );      address _collateralAsset = creditLineConstants[_id].collateralAsset;     address _lender = creditLineConstants[_id].lender;     uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);     address _borrowAsset = creditLineConstants[_id].borrowAsset;      creditLineVariables[_id].status = CreditLineStatus.LIQUIDATED;      if (creditLineConstants[_id].autoLiquidation &amp;&amp; _lender != msg.sender) {         uint256 _borrowTokens = _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens);         if (_borrowAsset == address(0)) {             uint256 _returnETH = msg.value.sub(_borrowTokens, 'Insufficient ETH to liquidate');             if (_returnETH != 0) {                 (bool success, ) = msg.sender.call{value: _returnETH}('');                 require(success, 'Transfer fail');             }         } else {             IERC20(_borrowAsset).safeTransferFrom(msg.sender, _lender, _borrowTokens);         }     }      _transferCollateral(_id, _collateralAsset, _totalCollateralTokens, _toSavingsAccount);      emit CreditLineLiquidated(_id, msg.sender); }  /**  * @notice used to calculate the borrow tokens necessary for liquidator to liquidate  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view  * @param _id identifier for the credit line  * @return borrow tokens necessary for liquidator to liquidate  */ function borrowTokensToLiquidate(uint256 _id) external returns (uint256) {     address _collateralAsset = creditLineConstants[_id].collateralAsset;     uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);     address _borrowAsset = creditLineConstants[_id].borrowAsset;      return _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens); }  function _borrowTokensToLiquidate(     address _borrowAsset,     address _collateralAsset,     uint256 _totalCollateralTokens ) internal view returns (uint256) {     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(_borrowAsset, _collateralAsset);     uint256 _borrowTokens = (         _totalCollateralTokens.mul(uint256(10**30).sub(liquidatorRewardFraction)).div(10**30).mul(_ratioOfPrices).div(10**_decimals)     );      return _borrowTokens; }  receive() external payable {     require(msg.sender == savingsAccount, 'CreditLine::receive invalid transaction'); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-22-08 11:42:57 INFO] Chief Executive Officer: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/utils/ReentrancyGuard.sol';
import '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';
import '../interfaces/IPriceOracle.sol';
import '../interfaces/IYield.sol';
import '../interfaces/ISavingsAccount.sol';
import '../SavingsAccount/SavingsAccountUtil.sol';
import '../interfaces/IStrategyRegistry.sol';

/**
 * @title Credit Line contract with Methods related to credit Line
 * @notice Implements the functions related to Credit Line
 * @author Sublime
 **/

contract CreditLine is ReentrancyGuard, OwnableUpgradeable {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    enum CreditLineStatus {
        NOT_CREATED,
        REQUESTED,
        ACTIVE,
        CLOSED,
        CANCELLED,
        LIQUIDATED
    }

    /**
     * @notice counter that tracks the number of credit lines created
     * @dev used to create unique identifier for credit lines
     **/
    uint256 public creditLineCounter;

    uint256 constant YEAR_IN_SECONDS = 365 days;

    struct CreditLineVariables {
        CreditLineStatus status;
        uint256 principal;
        uint256 totalInterestRepaid;
        uint256 lastPrincipalUpdateTime;
        uint256 interestAccruedTillLastPrincipalUpdate;
    }

    struct CreditLineConstants {
        address lender;
        address borrower;
        uint256 borrowLimit;
        uint256 idealCollateralRatio;
        uint256 borrowRate;
        address borrowAsset;
        address collateralAsset;
        bool autoLiquidation;
        bool requestByLender;
    }
    /**
     * @notice stores the collateral shares in a credit line per strategy
     * @dev creditLineId => Strategy => collateralShares
     **/
    mapping(uint256 => mapping(address => uint256)) public collateralShareInStrategy;

    /**
     * @notice stores the variables to maintain a credit line
     **/
    mapping(uint256 => CreditLineVariables) public creditLineVariables;

    /**
     * @notice stores the constants related to a credit line
     **/
    mapping(uint256 => CreditLineConstants) public creditLineConstants;

    /**
     * @notice stores the address of savings account contract
     **/
    address public savingsAccount;

    /**
     * @notice stores the address of price oracle contract
     **/
    address public priceOracle;

    /**
     * @notice stores the address of strategy registry contract
     **/
    address public strategyRegistry;

    /**
     * @notice stores the address of default strategy
     **/
    address public defaultStrategy;

    /**
     * @notice stores the fraction of borrowed amount charged as fee by protocol
     * @dev it is multiplied by 10**30
     **/
    uint256 public protocolFeeFraction;

    /**
     * @notice address where protocol fee is collected
     **/
    address public protocolFeeCollector;

    /**
     * @notice stores the fraction of amount liquidated given as reward to liquidator
     * @dev it is multiplied by 10**30
     **/
    uint256 public liquidatorRewardFraction;
    /**
     * @dev checks if Credit Line exists
     * @param _id identifier for the credit line
     **/
    modifier ifCreditLineExists(uint256 _id) {
        require(creditLineVariables[_id].status != CreditLineStatus.NOT_CREATED, 'Credit line does not exist');
        _;
    }

    /**
     * @dev checks if called by credit Line Borrower
     * @param _id creditLine identifier
     **/
    modifier onlyCreditLineBorrower(uint256 _id) {
        require(creditLineConstants[_id].borrower == msg.sender, 'Only credit line Borrower can access');
        _;
    }

    /**
     * @dev checks if called by credit Line Lender
     * @param _id creditLine identifier
     **/
    modifier onlyCreditLineLender(uint256 _id) {
        require(creditLineConstants[_id].lender == msg.sender, 'Only credit line Lender can access');
        _;
    }

    /**
     * @notice emitted when a collateral is deposited into credit line
     * @param id id of the credit line
     * @param amount amount of collateral deposited
     * @param strategy address of the strategy into which collateral is deposited
     */
    event CollateralDeposited(uint256 indexed id, uint256 amount, address indexed strategy);

    /**
     * @notice emitted when collateral is withdrawn from credit line
     * @param id id of the credit line
     * @param amount amount of collateral withdrawn
     */
    event CollateralWithdrawn(uint256 indexed id, uint256 amount);

    /**
     * @notice emitted when a request for new credit line is placed
     * @param id id of the credit line for which request was made
     * @param lender address of the lender for credit line
     * @param borrower address of the borrower for credit line
     */
    event CreditLineRequested(uint256 indexed id, address indexed lender, address indexed borrower);

    /**
     * @notice emitted when a credit line is liquidated
     * @param id id of the credit line which is liquidated
     * @param liquidator address of the liquidator
     */
    event CreditLineLiquidated(uint256 indexed id, address indexed liquidator);

    /**
     * @notice emitted when tokens are borrowed from credit line
     * @param id id of the credit line from which tokens are borrowed
     * @param borrowAmount amount of tokens borrowed
     */
    event BorrowedFromCreditLine(uint256 indexed id, uint256 borrowAmount);

    /**
     * @notice emitted when credit line is accepted
     * @param id id of the credit line that was accepted
     */
    event CreditLineAccepted(uint256 indexed id);

    /**
     * @notice emitted when credit line is completely repaid and reset
     * @param id id of the credit line that is reset
     */
    event CreditLineReset(uint256 indexed id);

    /**
     * @notice emitted when the credit line is partially repaid
     * @param id id of the credit line
     * @param repayAmount amount repaid
     */
    event PartialCreditLineRepaid(uint256 indexed id, uint256 repayAmount);

    /**
     * @notice emitted when the credit line is completely repaid
     * @param id id of the credit line
     * @param repayAmount amount repaid
     */
    event CompleteCreditLineRepaid(uint256 indexed id, uint256 repayAmount);

    /**
     * @notice emitted when the credit line is closed by one of the parties of credit line
     * @param id id of the credit line
     */
    event CreditLineClosed(uint256 indexed id);

    /**
     * @notice emitted when default strategy for the credit line is updated
     * @param defaultStrategy address of the strategy contract that is used as default by credit lines
     */
    event DefaultStrategyUpdated(address indexed defaultStrategy);

    /**
     * @notice emitted when the price oracle is updated
     * @param priceOracle address of the updated price oracle
     */
    event PriceOracleUpdated(address indexed priceOracle);

    /**
     * @notice emitted when the savings account address is updated
     * @param savingsAccount address of the updated savingsAccount
     */
    event SavingsAccountUpdated(address indexed savingsAccount);

    /**
     * @notice emitted when strategy registry address is updated
     * @param strategyRegistry address of the updated strategy registry
     */
    event StrategyRegistryUpdated(address indexed strategyRegistry);

    /**
     * @notice emitted when fee that protocol charges for credit line is updated
     * @param updatedProtocolFee updated value of protocolFeeFraction
     */
    event ProtocolFeeFractionUpdated(uint256 updatedProtocolFee);

    /**
     * @notice emitted when address which receives fee that protocol changes for pools is updated
     * @param updatedProtocolFeeCollector updated value of protocolFeeCollector
     */
    event ProtocolFeeCollectorUpdated(address indexed updatedProtocolFeeCollector);

    /**
     * @notice emitted when liquidatorRewardFraction is updated
     * @param liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator
     */
    event LiquidationRewardFractionUpdated(uint256 liquidatorRewardFraction);

    /**
     * @notice used to initialize the contract
     * @dev can only be called once during the life cycle of the contract
     * @param _defaultStrategy default strategy used in credit lines
     * @param _priceOracle address of the priceOracle
     * @param _savingsAccount address of  the savings account contract
     * @param _strategyRegistry address of the strategy registry contract
     * @param _owner address of owner who can change global variables
     * @param _protocolFeeFraction fraction of the fee charged by protocol
     * @param _protocolFeeCollector address to which protocol fee is charged to
     * @param _liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator
     */
    function initialize(
        address _defaultStrategy,
        address _priceOracle,
        address _savingsAccount,
        address _strategyRegistry,
        address _owner,
        uint256 _protocolFeeFraction,
        address _protocolFeeCollector,
        uint256 _liquidatorRewardFraction
    ) external initializer {
        OwnableUpgradeable.__Ownable_init();
        OwnableUpgradeable.transferOwnership(_owner);

        _updateDefaultStrategy(_defaultStrategy);
        _updatePriceOracle(_priceOracle);
        _updateSavingsAccount(_savingsAccount);
        _updateStrategyRegistry(_strategyRegistry);
        _updateProtocolFeeFraction(_protocolFeeFraction);
        _updateProtocolFeeCollector(_protocolFeeCollector);
        _updateLiquidatorRewardFraction(_liquidatorRewardFraction);
    }

    /**
     * @notice used to update the default strategy
     * @dev can only be updated by owner
     * @param _defaultStrategy address of the updated default strategy
     */
    function updateDefaultStrategy(address _defaultStrategy) external onlyOwner {
        _updateDefaultStrategy(_defaultStrategy);
    }

    function _updateDefaultStrategy(address _defaultStrategy) internal {
        defaultStrategy = _defaultStrategy;
        emit DefaultStrategyUpdated(_defaultStrategy);
    }

    /**
     * @notice used to update the price oracle
     * @dev can only be updated by owner
     * @param _priceOracle address of the updated price oracle
     */
    function updatePriceOracle(address _priceOracle) external onlyOwner {
        _updatePriceOracle(_priceOracle);
    }

    function _updatePriceOracle(address _priceOracle) internal {
        priceOracle = _priceOracle;
        emit PriceOracleUpdated(_priceOracle);
    }

    /**
     * @notice used to update the savings account address
     * @dev can only be updated by owner
     * @param _savingsAccount address of the updated savings account
     */
    function updateSavingsAccount(address _savingsAccount) external onlyOwner {
        _updateSavingsAccount(_savingsAccount);
    }

    function _updateSavingsAccount(address _savingsAccount) internal {
        savingsAccount = _savingsAccount;
        emit SavingsAccountUpdated(_savingsAccount);
    }

    /**
     * @notice used to update the protocol fee fraction
     * @dev can only be updated by owner
     * @param _protocolFee fraction of the borrower amount collected as protocol fee
     */
    function updateProtocolFeeFraction(uint256 _protocolFee) external onlyOwner {
        _updateProtocolFeeFraction(_protocolFee);
    }

    function _updateProtocolFeeFraction(uint256 _protocolFee) internal {
        protocolFeeFraction = _protocolFee;
        emit ProtocolFeeFractionUpdated(_protocolFee);
    }

    /**
     * @notice used to update the protocol fee collector
     * @dev can only be updated by owner
     * @param _protocolFeeCollector address in which protocol fee is collected
     */
    function updateProtocolFeeCollector(address _protocolFeeCollector) external onlyOwner {
        _updateProtocolFeeCollector(_protocolFeeCollector);
    }

    function _updateProtocolFeeCollector(address _protocolFeeCollector) internal {
        require(_protocolFeeCollector != address(0), 'cant be 0 address');
        protocolFeeCollector = _protocolFeeCollector;
        emit ProtocolFeeCollectorUpdated(_protocolFeeCollector);
    }

    /**
     * @notice used to update the strategy registry address
     * @dev can only be updated by owner
     * @param _strategyRegistry address of the updated strategy registry
     */
    function updateStrategyRegistry(address _strategyRegistry) external onlyOwner {
        _updateStrategyRegistry(_strategyRegistry);
    }

    function _updateStrategyRegistry(address _strategyRegistry) internal {
        require(_strategyRegistry != address(0), 'CL::I zero address');
        strategyRegistry = _strategyRegistry;
        emit StrategyRegistryUpdated(_strategyRegistry);
    }

    /**
     * @notice used to update the liquidatorRewardFraction
     * @dev can only be updated by owner
     * @param _rewardFraction fraction of liquidated amount given to liquidator as reward
     */
    function updateLiquidatorRewardFraction(uint256 _rewardFraction) external onlyOwner {
        _updateLiquidatorRewardFraction(_rewardFraction);
    }

    function _updateLiquidatorRewardFraction(uint256 _rewardFraction) internal {
        require(_rewardFraction <= 10**30, 'Fraction has to be less than 1');
        liquidatorRewardFraction = _rewardFraction;
        emit LiquidationRewardFractionUpdated(_rewardFraction);
    }

    /**
     * @dev Used to Calculate Interest Per second on given principal and Interest rate
     * @param _principal principal Amount for which interest has to be calculated.
     * @param _borrowRate It is the Interest Rate at which Credit Line is approved
     * @return interest per second for the given parameters
     */
    function calculateInterest(
        uint256 _principal,
        uint256 _borrowRate,
        uint256 _timeElapsed
    ) public pure returns (uint256) {
        uint256 _interest = _principal.mul(_borrowRate).mul(_timeElapsed).div(10**30).div(YEAR_IN_SECONDS);

        return _interest;
    }

    /**
     * @dev Used to calculate interest accrued since last repayment
     * @param _id identifier for the credit line
     * @return interest accrued over current borrowed amount since last repayment
     */

    function calculateInterestAccrued(uint256 _id) public view returns (uint256) {
        uint256 _lastPrincipalUpdateTime = creditLineVariables[_id].lastPrincipalUpdateTime;
        if (_lastPrincipalUpdateTime == 0) return 0;
        uint256 _timeElapsed = (block.timestamp).sub(_lastPrincipalUpdateTime);
        uint256 _interestAccrued = calculateInterest(creditLineVariables[_id].principal, creditLineConstants[_id].borrowRate, _timeElapsed);
        return _interestAccrued;
    }

    /**
     * @dev Used to calculate current debt of borrower against a credit line.
     * @param _id identifier for the credit line
     * @return current debt of borrower
     */
    function calculateCurrentDebt(uint256 _id) public view returns (uint256) {
        uint256 _interestAccrued = calculateInterestAccrued(_id);
        uint256 _currentDebt = (creditLineVariables[_id].principal)
            .add(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate)
            .add(_interestAccrued)
            .sub(creditLineVariables[_id].totalInterestRepaid);
        return _currentDebt;
    }

    /**
     * @notice used to calculate amount that can be borrowed by the borrower
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view.
            borrowableAmount changes per block as interest changes per block.
     * @param _id identifier for the credit line
     * @return amount that can be borrowed from the credit line
     */
    function calculateBorrowableAmount(uint256 _id) public returns (uint256) {
        CreditLineStatus _status = creditLineVariables[_id].status;
        require(
            _status == CreditLineStatus.ACTIVE || _status == CreditLineStatus.REQUESTED,
            'CreditLine: Cannot only if credit line ACTIVE or REQUESTED'
        );
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(
            creditLineConstants[_id].collateralAsset,
            creditLineConstants[_id].borrowAsset
        );

        uint256 _totalCollateralToken = calculateTotalCollateralTokens(_id);

        uint256 _currentDebt = calculateCurrentDebt(_id);

        uint256 _maxPossible = _totalCollateralToken.mul(_ratioOfPrices).div(creditLineConstants[_id].idealCollateralRatio).mul(10**30).div(
            10**_decimals
        );

        uint256 _borrowLimit = creditLineConstants[_id].borrowLimit;

        if (_maxPossible > _borrowLimit) {
            _maxPossible = _borrowLimit;
        }
        if (_maxPossible > _currentDebt) {
            return _maxPossible.sub(_currentDebt);
        }
        return 0;
    }

    function updateinterestAccruedTillLastPrincipalUpdate(uint256 _id) internal {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');

        uint256 _interestAccrued = calculateInterestAccrued(_id);
        uint256 _newInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(_interestAccrued);
        creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _newInterestAccrued;
    }

    function _depositCollateralFromSavingsAccount(
        uint256 _id,
        uint256 _amount,
        address _sender
    ) internal {
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        uint256 _activeAmount;

        for (uint256 _index = 0; _index < _strategyList.length; _index++) {
            address _strategy = _strategyList[_index];
            uint256 _liquidityShares = _savingsAccount.balanceInShares(_sender, _collateralAsset, _strategy);
            if (_liquidityShares == 0 || _strategyList[_index] == address(0)) {
                continue;
            }
            uint256 _tokenInStrategy = _liquidityShares;
            _tokenInStrategy = IYield(_strategy).getTokensForShares(_liquidityShares, _collateralAsset);

            uint256 _tokensToTransfer = _tokenInStrategy;
            if (_activeAmount.add(_tokenInStrategy) >= _amount) {
                _tokensToTransfer = (_amount.sub(_activeAmount));
            }
            _activeAmount = _activeAmount.add(_tokensToTransfer);
            _savingsAccount.transferFrom(_tokensToTransfer, _collateralAsset, _strategy, _sender, address(this));

            collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(
                _liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy)
            );

            if (_amount == _activeAmount) {
                return;
            }
        }
        revert('CreditLine::_depositCollateralFromSavingsAccount - Insufficient balance');
    }

    /**
     * @notice used to request a credit line either by borrower or lender
     * @param _requestTo Address to which creditLine is requested, 
                        if borrower creates request then lender address and 
                        if lender creates then borrower address
     * @param _borrowLimit maximum borrow amount in a credit line
     * @param _borrowRate Interest Rate at which credit Line is requested
     * @param _autoLiquidation if true, anyone can liquidate loan, otherwise only lender
     * @param _collateralRatio ratio of the collateral to the debt below which credit line can be liquidated
     * @param _borrowAsset address of the token to be borrowed
     * @param _collateralAsset address of the token provided as collateral
     * @param _requestAsLender if true, lender is placing request, otherwise borrower
     * @return identifier for the credit line
     */

    function request(
        address _requestTo,
        uint256 _borrowLimit,
        uint256 _borrowRate,
        bool _autoLiquidation,
        uint256 _collateralRatio,
        address _borrowAsset,
        address _collateralAsset,
        bool _requestAsLender
    ) external returns (uint256) {
        require(_borrowAsset != _collateralAsset, 'R: cant borrow lent token');
        require(IPriceOracle(priceOracle).doesFeedExist(_borrowAsset, _collateralAsset), 'R: No price feed');

        address _lender = _requestTo;
        address _borrower = msg.sender;
        if (_requestAsLender) {
            _lender = msg.sender;
            _borrower = _requestTo;
        }

        uint256 _id = _createRequest(
            _lender,
            _borrower,
            _borrowLimit,
            _borrowRate,
            _autoLiquidation,
            _collateralRatio,
            _borrowAsset,
            _collateralAsset,
            _requestAsLender
        );

        emit CreditLineRequested(_id, _lender, _borrower);
        return _id;
    }

    function _createRequest(
        address _lender,
        address _borrower,
        uint256 _borrowLimit,
        uint256 _borrowRate,
        bool _autoLiquidation,
        uint256 _collateralRatio,
        address _borrowAsset,
        address _collateralAsset,
        bool _requestByLender
    ) internal returns (uint256) {
        require(_lender != _borrower, 'Lender and Borrower cannot be same addresses');
        uint256 _id = creditLineCounter + 1;
        creditLineCounter = _id;
        creditLineVariables[_id].status = CreditLineStatus.REQUESTED;
        creditLineConstants[_id].borrower = _borrower;
        creditLineConstants[_id].lender = _lender;
        creditLineConstants[_id].borrowLimit = _borrowLimit;
        creditLineConstants[_id].autoLiquidation = _autoLiquidation;
        creditLineConstants[_id].idealCollateralRatio = _collateralRatio;
        creditLineConstants[_id].borrowRate = _borrowRate;
        creditLineConstants[_id].borrowAsset = _borrowAsset;
        creditLineConstants[_id].collateralAsset = _collateralAsset;
        creditLineConstants[_id].requestByLender = _requestByLender;
        return _id;
    }

    /**
     * @notice used to accept a credit line
     * @dev if borrower places request, lender can accept and vice versa
     * @param _id identifier for the credit line
     */
    function accept(uint256 _id) external {
        require(
            creditLineVariables[_id].status == CreditLineStatus.REQUESTED,
            'CreditLine::acceptCreditLineLender - CreditLine is already accepted'
        );
        bool _requestByLender = creditLineConstants[_id].requestByLender;
        require(
            (msg.sender == creditLineConstants[_id].borrower && _requestByLender) ||
                (msg.sender == creditLineConstants[_id].lender && !_requestByLender),
            "Only Borrower or Lender who hasn't requested can accept"
        );
        creditLineVariables[_id].status = CreditLineStatus.ACTIVE;
        emit CreditLineAccepted(_id);
    }

    /**
     * @notice used to deposit collateral into the credit line
     * @dev collateral tokens have to be approved in savingsAccount or token contract(unless ether).
            If transferred from savings account, the tokens are transferred from strategies in the 
            order prespecified in strategy registry
     * @param _id identifier for the credit line
     * @param _amount amount of collateral being deposited
     * @param _strategy strategy to which collateral is to be deposited in case transfer is not from savings account
     * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount 
                                otherwise direct from collateral token contract
     */
    function depositCollateral(
        uint256 _id,
        uint256 _amount,
        address _strategy,
        bool _fromSavingsAccount
    ) external payable nonReentrant ifCreditLineExists(_id) {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine not active');
        _depositCollateral(_id, _amount, _strategy, _fromSavingsAccount);
        emit CollateralDeposited(_id, _amount, _strategy);
    }

    function _depositCollateral(
        uint256 _id,
        uint256 _amount,
        address _strategy,
        bool _fromSavingsAccount
    ) internal {
        require(creditLineConstants[_id].lender != msg.sender, 'lender cant deposit collateral');
        if (_fromSavingsAccount) {
            _depositCollateralFromSavingsAccount(_id, _amount, msg.sender);
        } else {
            address _collateralAsset = creditLineConstants[_id].collateralAsset;
            ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
            if (_collateralAsset == address(0)) {
                require(msg.value == _amount, "CreditLine::_depositCollateral - value to transfer doesn't match argument");
            } else {
                IERC20(_collateralAsset).safeTransferFrom(msg.sender, address(this), _amount);
                IERC20(_collateralAsset).approve(_strategy, _amount);
            }
            uint256 _sharesReceived = _savingsAccount.deposit{value: msg.value}(_amount, _collateralAsset, _strategy, address(this));
            collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(_sharesReceived);
        }
    }

    function _withdrawBorrowAmount(
        address _asset,
        uint256 _amountInTokens,
        address _lender
    ) internal {
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        uint256 _activeAmount;
        for (uint256 _index = 0; _index < _strategyList.length; _index++) {
            if (_strategyList[_index] == address(0)) {
                continue;
            }
            uint256 _liquidityShares = _savingsAccount.balanceInShares(_lender, _asset, _strategyList[_index]);
            if (_liquidityShares != 0) {
                uint256 tokenInStrategy = _liquidityShares;
                tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);
                uint256 _tokensToTransfer = tokenInStrategy;
                if (_activeAmount.add(tokenInStrategy) >= _amountInTokens) {
                    _tokensToTransfer = (_amountInTokens.sub(_activeAmount));
                }
                _activeAmount = _activeAmount.add(_tokensToTransfer);
                _savingsAccount.withdrawFrom(_tokensToTransfer, _asset, _strategyList[_index], _lender, address(this), false);
                if (_activeAmount == _amountInTokens) {
                    return;
                }
            }
        }
        require(_activeAmount == _amountInTokens, 'insufficient balance');
    }

    /**
     * @notice used to borrow tokens from credit line by borrower
     * @dev only borrower can call this function. Amount that can actually be borrowed is 
            min(amount based on borrowLimit, allowance to creditLine contract, balance of lender)
     * @param _id identifier for the credit line
     * @param _amount amount of tokens to borrow
     */
    function borrow(uint256 _id, uint256 _amount) external payable nonReentrant onlyCreditLineBorrower(_id) {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');
        uint256 _borrowableAmount = calculateBorrowableAmount(_id);
        require(_amount <= _borrowableAmount, "CreditLine::borrow - The current collateral ratio doesn't allow to withdraw the amount");
        address _borrowAsset = creditLineConstants[_id].borrowAsset;
        address _lender = creditLineConstants[_id].lender;

        updateinterestAccruedTillLastPrincipalUpdate(_id);
        creditLineVariables[_id].principal = creditLineVariables[_id].principal.add(_amount);
        creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;

        uint256 _tokenDiffBalance;
        if (_borrowAsset != address(0)) {
            uint256 _balanceBefore = IERC20(_borrowAsset).balanceOf(address(this));
            _withdrawBorrowAmount(_borrowAsset, _amount, _lender);
            uint256 _balanceAfter = IERC20(_borrowAsset).balanceOf(address(this));
            _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);
        } else {
            uint256 _balanceBefore = address(this).balance;
            _withdrawBorrowAmount(_borrowAsset, _amount, _lender);
            uint256 _balanceAfter = address(this).balance;
            _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);
        }
        uint256 _protocolFee = _tokenDiffBalance.mul(protocolFeeFraction).div(10**30);
        _tokenDiffBalance = _tokenDiffBalance.sub(_protocolFee);

        if (_borrowAsset == address(0)) {
            (bool feeSuccess, ) = protocolFeeCollector.call{value: _protocolFee}('');
            require(feeSuccess, 'Transfer fail');
            (bool success, ) = msg.sender.call{value: _tokenDiffBalance}('');
            require(success, 'Transfer fail');
        } else {
            IERC20(_borrowAsset).safeTransfer(protocolFeeCollector, _protocolFee);
            IERC20(_borrowAsset).safeTransfer(msg.sender, _tokenDiffBalance);
        }
        emit BorrowedFromCreditLine(_id, _tokenDiffBalance);
    }

    function _repayFromSavingsAccount(
        uint256 _amount,
        address _asset,
        address _lender
    ) internal {
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        uint256 _activeAmount;

        for (uint256 _index = 0; _index < _strategyList.length; _index++) {
            if (_strategyList[_index] == address(0)) {
                continue;
            }
            uint256 _liquidityShares = _savingsAccount.balanceInShares(msg.sender, _asset, _strategyList[_index]);
            if (_liquidityShares == 0) {
                continue;
            }
            uint256 _tokenInStrategy = _liquidityShares;
            _tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);

            uint256 _tokensToTransfer = _tokenInStrategy;
            if (_activeAmount.add(_tokenInStrategy) >= _amount) {
                _tokensToTransfer = (_amount.sub(_activeAmount));
            }
            _activeAmount = _activeAmount.add(_tokensToTransfer);
            _savingsAccount.transferFrom(_tokensToTransfer, _asset, _strategyList[_index], msg.sender, _lender);

            if (_amount == _activeAmount) {
                return;
            }
        }
        revert('CreditLine::_repayFromSavingsAccount - Insufficient balance');
    }

    function _repay(
        uint256 _id,
        uint256 _amount,
        bool _fromSavingsAccount,
        uint256 _principalPaid
    ) internal {
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        address _defaultStrategy = defaultStrategy;
        address _borrowAsset = creditLineConstants[_id].borrowAsset;
        address _lender = creditLineConstants[_id].lender;
        if (!_fromSavingsAccount) {
            if (_borrowAsset == address(0)) {
                require(msg.value == _amount, 'creditLine::repay - Ether sent not equal to repay amount');
                _savingsAccount.deposit{value: _amount}(_amount, _borrowAsset, _defaultStrategy, _lender);
            } else {
                IERC20(_borrowAsset).safeTransferFrom(msg.sender, address(this), _amount);
                IERC20(_borrowAsset).approve(_defaultStrategy, _amount);
                _savingsAccount.deposit(_amount, _borrowAsset, _defaultStrategy, _lender);
            }
        } else {
            _repayFromSavingsAccount(_amount, _borrowAsset, _lender);
        }
        if (_principalPaid != 0) {
            _savingsAccount.increaseAllowanceToCreditLine(_principalPaid, _borrowAsset, _lender);
        }
    }

    /**
     * @notice used to repay interest and principal to credit line. Interest has to be repaid before repaying principal
     * @dev partial repayments possible
     * @param _id identifier for the credit line
     * @param _amount amount being repaid
     * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount 
                                otherwise direct from collateral token contract
     */
    function repay(
        uint256 _id,
        uint256 _amount,
        bool _fromSavingsAccount
    ) external payable nonReentrant {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');
        require(creditLineConstants[_id].lender != msg.sender, 'Lender cant repay');

        uint256 _interestSincePrincipalUpdate = calculateInterestAccrued(_id);
        uint256 _totalInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(
            _interestSincePrincipalUpdate
        );
        uint256 _interestToPay = _totalInterestAccrued.sub(creditLineVariables[_id].totalInterestRepaid);
        uint256 _totalCurrentDebt = _interestToPay.add(creditLineVariables[_id].principal);
        uint256 _principalPaid = 0;

        if (_amount >= _totalCurrentDebt) {
            _amount = _totalCurrentDebt;
            emit CompleteCreditLineRepaid(_id, _amount);
        } else {
            emit PartialCreditLineRepaid(_id, _amount);
        }

        if (_amount > _interestToPay) {
            creditLineVariables[_id].principal = _totalCurrentDebt.sub(_amount);
            creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _totalInterestAccrued;
            creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;
            creditLineVariables[_id].totalInterestRepaid = _totalInterestAccrued;
            _principalPaid = _amount.sub(_interestToPay);
        } else {
            creditLineVariables[_id].totalInterestRepaid = creditLineVariables[_id].totalInterestRepaid.add(_amount);
        }

        _repay(_id, _amount, _fromSavingsAccount, _principalPaid);

        if (creditLineVariables[_id].principal == 0) {
            _resetCreditLine(_id);
        }
    }

    function _resetCreditLine(uint256 _id) internal {
        creditLineVariables[_id].lastPrincipalUpdateTime = 0;
        creditLineVariables[_id].totalInterestRepaid = 0;
        creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = 0;
        emit CreditLineReset(_id);
    }

    /**
     * @dev used to close credit line by borrower or lender
     * @param _id identifier for the credit line
     */
    function close(uint256 _id) external ifCreditLineExists(_id) {
        require(
            msg.sender == creditLineConstants[_id].borrower || msg.sender == creditLineConstants[_id].lender,
            'CreditLine: Permission denied while closing Line of credit'
        );
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: Credit line should be active.');
        require(creditLineVariables[_id].principal == 0, 'CreditLine: Cannot be closed since not repaid.');
        require(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate == 0, 'CreditLine: Cannot be closed since not repaid.');
        creditLineVariables[_id].status = CreditLineStatus.CLOSED;
        emit CreditLineClosed(_id);
    }

    /**
     * @notice used to calculate the current collateral ratio
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view.
            Interest is also considered while calculating debt
     * @param _id identifier for the credit line
     * @return collateral ratio multiplied by 10**30 to retain precision
     */
    function calculateCurrentCollateralRatio(uint256 _id) public ifCreditLineExists(_id) returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(
            creditLineConstants[_id].collateralAsset,
            creditLineConstants[_id].borrowAsset
        );

        uint256 currentDebt = calculateCurrentDebt(_id);
        uint256 currentCollateralRatio = calculateTotalCollateralTokens(_id).mul(_ratioOfPrices).div(currentDebt).mul(10**30).div(
            10**_decimals
        );

        return currentCollateralRatio;
    }

    /**
     * @notice used to calculate the total collateral tokens
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @param _id identifier for the credit line
     * @return _amount total collateral tokens deposited into the credit line
     */
    function calculateTotalCollateralTokens(uint256 _id) public returns (uint256 _amount) {
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        uint256 _liquidityShares;
        for (uint256 index = 0; index < _strategyList.length; index++) {
            if (_strategyList[index] == address(0)) {
                continue;
            }
            _liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];
            uint256 _tokenInStrategy = _liquidityShares;
            _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(_liquidityShares, _collateralAsset);

            _amount = _amount.add(_tokenInStrategy);
        }
    }

    /**
     * @notice used to withdraw any excess collateral
     * @dev collateral can't be withdraw if collateralRatio goes below the ideal value. Only borrower can withdraw
     * @param _id identifier for the credit line
     * @param _amount amount of collateral to withdraw
     * @param _toSavingsAccount if true, tokens are transferred from savingsAccount 
                                otherwise direct from collateral token contract
     */
    function withdrawCollateral(
        uint256 _id,
        uint256 _amount,
        bool _toSavingsAccount
    ) external nonReentrant onlyCreditLineBorrower(_id) {
        uint256 _withdrawableCollateral = withdrawableCollateral(_id);
        require(_amount <= _withdrawableCollateral, 'Collateral ratio cant go below ideal');
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        _transferCollateral(_id, _collateralAsset, _amount, _toSavingsAccount);
        emit CollateralWithdrawn(_id, _amount);
    }

    /**
     * @notice used to calculate the collateral that can be withdrawn
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @param _id identifier for the credit line
     * @return total collateral withdrawable by borrower
     */
    function withdrawableCollateral(uint256 _id) public returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(
            creditLineConstants[_id].collateralAsset,
            creditLineConstants[_id].borrowAsset
        );

        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);
        uint256 _currentDebt = calculateCurrentDebt(_id);

        uint256 _collateralNeeded = _currentDebt
            .mul(creditLineConstants[_id].idealCollateralRatio)
            .div(_ratioOfPrices)
            .mul(10**_decimals)
            .div(10**30);

        if (_collateralNeeded >= _totalCollateralTokens) {
            return 0;
        }
        return _totalCollateralTokens.sub(_collateralNeeded);
    }

    function _transferCollateral(
        uint256 _id,
        address _asset,
        uint256 _amountInTokens,
        bool _toSavingsAccount
    ) internal {
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        uint256 _activeAmount;
        for (uint256 index = 0; index < _strategyList.length; index++) {
            uint256 liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];
            if (liquidityShares == 0 || _strategyList[index] == address(0)) {
                continue;
            }
            uint256 _tokenInStrategy = liquidityShares;
            _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(liquidityShares, _asset);
            uint256 _tokensToTransfer = _tokenInStrategy;
            if (_activeAmount.add(_tokenInStrategy) > _amountInTokens) {
                _tokensToTransfer = _amountInTokens.sub(_activeAmount);
                liquidityShares = liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy);
            }
            _activeAmount = _activeAmount.add(_tokensToTransfer);
            collateralShareInStrategy[_id][_strategyList[index]] = collateralShareInStrategy[_id][_strategyList[index]].sub(
                liquidityShares
            );
            if (_toSavingsAccount) {
                ISavingsAccount(savingsAccount).transfer(_tokensToTransfer, _asset, _strategyList[index], msg.sender);
            } else {
                ISavingsAccount(savingsAccount).withdraw(_tokensToTransfer, _asset, _strategyList[index], msg.sender, false);
            }

            if (_activeAmount == _amountInTokens) {
                return;
            }
        }
        revert('insufficient collateral');
    }

    /**
     * @notice used to liquidate credit line in case collateral ratio goes below the threshold
     * @dev if lender liquidates, then collateral is directly transferred. 
            If autoLiquidation is true, anyone can liquidate by providing enough borrow tokens
     * @param _id identifier for the credit line
     * @param _toSavingsAccount if true, tokens are transferred from savingsAccount 
                                otherwise direct from collateral token contract
     */
    function liquidate(uint256 _id, bool _toSavingsAccount) external payable nonReentrant {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: Credit line should be active.');
        require(creditLineVariables[_id].principal != 0, 'CreditLine: cannot liquidate if principal is 0');

        uint256 currentCollateralRatio = calculateCurrentCollateralRatio(_id);
        require(
            currentCollateralRatio < creditLineConstants[_id].idealCollateralRatio,
            'CreditLine: Collateral ratio is higher than ideal value'
        );

        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        address _lender = creditLineConstants[_id].lender;
        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);
        address _borrowAsset = creditLineConstants[_id].borrowAsset;

        creditLineVariables[_id].status = CreditLineStatus.LIQUIDATED;

        if (creditLineConstants[_id].autoLiquidation && _lender != msg.sender) {
            uint256 _borrowTokens = _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens);
            if (_borrowAsset == address(0)) {
                uint256 _returnETH = msg.value.sub(_borrowTokens, 'Insufficient ETH to liquidate');
                if (_returnETH != 0) {
                    (bool success, ) = msg.sender.call{value: _returnETH}('');
                    require(success, 'Transfer fail');
                }
            } else {
                IERC20(_borrowAsset).safeTransferFrom(msg.sender, _lender, _borrowTokens);
            }
        }

        _transferCollateral(_id, _collateralAsset, _totalCollateralTokens, _toSavingsAccount);

        emit CreditLineLiquidated(_id, msg.sender);
    }

    /**
     * @notice used to calculate the borrow tokens necessary for liquidator to liquidate
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @param _id identifier for the credit line
     * @return borrow tokens necessary for liquidator to liquidate
     */
    function borrowTokensToLiquidate(uint256 _id) external returns (uint256) {
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);
        address _borrowAsset = creditLineConstants[_id].borrowAsset;

        return _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens);
    }

    function _borrowTokensToLiquidate(
        address _borrowAsset,
        address _collateralAsset,
        uint256 _totalCollateralTokens
    ) internal view returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(_borrowAsset, _collateralAsset);
        uint256 _borrowTokens = (
            _totalCollateralTokens.mul(uint256(10**30).sub(liquidatorRewardFraction)).div(10**30).mul(_ratioOfPrices).div(10**_decimals)
        );

        return _borrowTokens;
    }

    receive() external payable {
        require(msg.sender == savingsAccount, 'CreditLine::receive invalid transaction');
    }
}
.]

We excel in generating innovative approaches and enhancements for Solidity smart contract code.

Here's a Solidity contract provided by the user: "// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/utils/ReentrancyGuard.sol';
import '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';
import '../interfaces/IPriceOracle.sol';
import '../interfaces/IYield.sol';
import '../interfaces/ISavingsAccount.sol';
import '../SavingsAccount/SavingsAccountUtil.sol';
import '../interfaces/IStrategyRegistry.sol';

/**
 * @title Credit Line contract with Methods related to credit Line
 * @notice Implements the functions related to Credit Line
 * @author Sublime
 **/

contract CreditLine is ReentrancyGuard, OwnableUpgradeable {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    enum CreditLineStatus {
        NOT_CREATED,
        REQUESTED,
        ACTIVE,
        CLOSED,
        CANCELLED,
        LIQUIDATED
    }

    /**
     * @notice counter that tracks the number of credit lines created
     * @dev used to create unique identifier for credit lines
     **/
    uint256 public creditLineCounter;

    uint256 constant YEAR_IN_SECONDS = 365 days;

    struct CreditLineVariables {
        CreditLineStatus status;
        uint256 principal;
        uint256 totalInterestRepaid;
        uint256 lastPrincipalUpdateTime;
        uint256 interestAccruedTillLastPrincipalUpdate;
    }

    struct CreditLineConstants {
        address lender;
        address borrower;
        uint256 borrowLimit;
        uint256 idealCollateralRatio;
        uint256 borrowRate;
        address borrowAsset;
        address collateralAsset;
        bool autoLiquidation;
        bool requestByLender;
    }
    /**
     * @notice stores the collateral shares in a credit line per strategy
     * @dev creditLineId => Strategy => collateralShares
     **/
    mapping(uint256 => mapping(address => uint256)) public collateralShareInStrategy;

    /**
     * @notice stores the variables to maintain a credit line
     **/
    mapping(uint256 => CreditLineVariables) public creditLineVariables;

    /**
     * @notice stores the constants related to a credit line
     **/
    mapping(uint256 => CreditLineConstants) public creditLineConstants;

    /**
     * @notice stores the address of savings account contract
     **/
    address public savingsAccount;

    /**
     * @notice stores the address of price oracle contract
     **/
    address public priceOracle;

    /**
     * @notice stores the address of strategy registry contract
     **/
    address public strategyRegistry;

    /**
     * @notice stores the address of default strategy
     **/
    address public defaultStrategy;

    /**
     * @notice stores the fraction of borrowed amount charged as fee by protocol
     * @dev it is multiplied by 10**30
     **/
    uint256 public protocolFeeFraction;

    /**
     * @notice address where protocol fee is collected
     **/
    address public protocolFeeCollector;

    /**
     * @notice stores the fraction of amount liquidated given as reward to liquidator
     * @dev it is multiplied by 10**30
     **/
    uint256 public liquidatorRewardFraction;
    /**
     * @dev checks if Credit Line exists
     * @param _id identifier for the credit line
     **/
    modifier ifCreditLineExists(uint256 _id) {
        require(creditLineVariables[_id].status != CreditLineStatus.NOT_CREATED, 'Credit line does not exist');
        _;
    }

    /**
     * @dev checks if called by credit Line Borrower
     * @param _id creditLine identifier
     **/
    modifier onlyCreditLineBorrower(uint256 _id) {
        require(creditLineConstants[_id].borrower == msg.sender, 'Only credit line Borrower can access');
        _;
    }

    /**
     * @dev checks if called by credit Line Lender
     * @param _id creditLine identifier
     **/
    modifier onlyCreditLineLender(uint256 _id) {
        require(creditLineConstants[_id].lender == msg.sender, 'Only credit line Lender can access');
        _;
    }

    /**
     * @notice emitted when a collateral is deposited into credit line
     * @param id id of the credit line
     * @param amount amount of collateral deposited
     * @param strategy address of the strategy into which collateral is deposited
     */
    event CollateralDeposited(uint256 indexed id, uint256 amount, address indexed strategy);

    /**
     * @notice emitted when collateral is withdrawn from credit line
     * @param id id of the credit line
     * @param amount amount of collateral withdrawn
     */
    event CollateralWithdrawn(uint256 indexed id, uint256 amount);

    /**
     * @notice emitted when a request for new credit line is placed
     * @param id id of the credit line for which request was made
     * @param lender address of the lender for credit line
     * @param borrower address of the borrower for credit line
     */
    event CreditLineRequested(uint256 indexed id, address indexed lender, address indexed borrower);

    /**
     * @notice emitted when a credit line is liquidated
     * @param id id of the credit line which is liquidated
     * @param liquidator address of the liquidator
     */
    event CreditLineLiquidated(uint256 indexed id, address indexed liquidator);

    /**
     * @notice emitted when tokens are borrowed from credit line
     * @param id id of the credit line from which tokens are borrowed
     * @param borrowAmount amount of tokens borrowed
     */
    event BorrowedFromCreditLine(uint256 indexed id, uint256 borrowAmount);

    /**
     * @notice emitted when credit line is accepted
     * @param id id of the credit line that was accepted
     */
    event CreditLineAccepted(uint256 indexed id);

    /**
     * @notice emitted when credit line is completely repaid and reset
     * @param id id of the credit line that is reset
     */
    event CreditLineReset(uint256 indexed id);

    /**
     * @notice emitted when the credit line is partially repaid
     * @param id id of the credit line
     * @param repayAmount amount repaid
     */
    event PartialCreditLineRepaid(uint256 indexed id, uint256 repayAmount);

    /**
     * @notice emitted when the credit line is completely repaid
     * @param id id of the credit line
     * @param repayAmount amount repaid
     */
    event CompleteCreditLineRepaid(uint256 indexed id, uint256 repayAmount);

    /**
     * @notice emitted when the credit line is closed by one of the parties of credit line
     * @param id id of the credit line
     */
    event CreditLineClosed(uint256 indexed id);

    /**
     * @notice emitted when default strategy for the credit line is updated
     * @param defaultStrategy address of the strategy contract that is used as default by credit lines
     */
    event DefaultStrategyUpdated(address indexed defaultStrategy);

    /**
     * @notice emitted when the price oracle is updated
     * @param priceOracle address of the updated price oracle
     */
    event PriceOracleUpdated(address indexed priceOracle);

    /**
     * @notice emitted when the savings account address is updated
     * @param savingsAccount address of the updated savingsAccount
     */
    event SavingsAccountUpdated(address indexed savingsAccount);

    /**
     * @notice emitted when strategy registry address is updated
     * @param strategyRegistry address of the updated strategy registry
     */
    event StrategyRegistryUpdated(address indexed strategyRegistry);

    /**
     * @notice emitted when fee that protocol charges for credit line is updated
     * @param updatedProtocolFee updated value of protocolFeeFraction
     */
    event ProtocolFeeFractionUpdated(uint256 updatedProtocolFee);

    /**
     * @notice emitted when address which receives fee that protocol changes for pools is updated
     * @param updatedProtocolFeeCollector updated value of protocolFeeCollector
     */
    event ProtocolFeeCollectorUpdated(address indexed updatedProtocolFeeCollector);

    /**
     * @notice emitted when liquidatorRewardFraction is updated
     * @param liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator
     */
    event LiquidationRewardFractionUpdated(uint256 liquidatorRewardFraction);

    /**
     * @notice used to initialize the contract
     * @dev can only be called once during the life cycle of the contract
     * @param _defaultStrategy default strategy used in credit lines
     * @param _priceOracle address of the priceOracle
     * @param _savingsAccount address of  the savings account contract
     * @param _strategyRegistry address of the strategy registry contract
     * @param _owner address of owner who can change global variables
     * @param _protocolFeeFraction fraction of the fee charged by protocol
     * @param _protocolFeeCollector address to which protocol fee is charged to
     * @param _liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator
     */
    function initialize(
        address _defaultStrategy,
        address _priceOracle,
        address _savingsAccount,
        address _strategyRegistry,
        address _owner,
        uint256 _protocolFeeFraction,
        address _protocolFeeCollector,
        uint256 _liquidatorRewardFraction
    ) external initializer {
        OwnableUpgradeable.__Ownable_init();
        OwnableUpgradeable.transferOwnership(_owner);

        _updateDefaultStrategy(_defaultStrategy);
        _updatePriceOracle(_priceOracle);
        _updateSavingsAccount(_savingsAccount);
        _updateStrategyRegistry(_strategyRegistry);
        _updateProtocolFeeFraction(_protocolFeeFraction);
        _updateProtocolFeeCollector(_protocolFeeCollector);
        _updateLiquidatorRewardFraction(_liquidatorRewardFraction);
    }

    /**
     * @notice used to update the default strategy
     * @dev can only be updated by owner
     * @param _defaultStrategy address of the updated default strategy
     */
    function updateDefaultStrategy(address _defaultStrategy) external onlyOwner {
        _updateDefaultStrategy(_defaultStrategy);
    }

    function _updateDefaultStrategy(address _defaultStrategy) internal {
        defaultStrategy = _defaultStrategy;
        emit DefaultStrategyUpdated(_defaultStrategy);
    }

    /**
     * @notice used to update the price oracle
     * @dev can only be updated by owner
     * @param _priceOracle address of the updated price oracle
     */
    function updatePriceOracle(address _priceOracle) external onlyOwner {
        _updatePriceOracle(_priceOracle);
    }

    function _updatePriceOracle(address _priceOracle) internal {
        priceOracle = _priceOracle;
        emit PriceOracleUpdated(_priceOracle);
    }

    /**
     * @notice used to update the savings account address
     * @dev can only be updated by owner
     * @param _savingsAccount address of the updated savings account
     */
    function updateSavingsAccount(address _savingsAccount) external onlyOwner {
        _updateSavingsAccount(_savingsAccount);
    }

    function _updateSavingsAccount(address _savingsAccount) internal {
        savingsAccount = _savingsAccount;
        emit SavingsAccountUpdated(_savingsAccount);
    }

    /**
     * @notice used to update the protocol fee fraction
     * @dev can only be updated by owner
     * @param _protocolFee fraction of the borrower amount collected as protocol fee
     */
    function updateProtocolFeeFraction(uint256 _protocolFee) external onlyOwner {
        _updateProtocolFeeFraction(_protocolFee);
    }

    function _updateProtocolFeeFraction(uint256 _protocolFee) internal {
        protocolFeeFraction = _protocolFee;
        emit ProtocolFeeFractionUpdated(_protocolFee);
    }

    /**
     * @notice used to update the protocol fee collector
     * @dev can only be updated by owner
     * @param _protocolFeeCollector address in which protocol fee is collected
     */
    function updateProtocolFeeCollector(address _protocolFeeCollector) external onlyOwner {
        _updateProtocolFeeCollector(_protocolFeeCollector);
    }

    function _updateProtocolFeeCollector(address _protocolFeeCollector) internal {
        require(_protocolFeeCollector != address(0), 'cant be 0 address');
        protocolFeeCollector = _protocolFeeCollector;
        emit ProtocolFeeCollectorUpdated(_protocolFeeCollector);
    }

    /**
     * @notice used to update the strategy registry address
     * @dev can only be updated by owner
     * @param _strategyRegistry address of the updated strategy registry
     */
    function updateStrategyRegistry(address _strategyRegistry) external onlyOwner {
        _updateStrategyRegistry(_strategyRegistry);
    }

    function _updateStrategyRegistry(address _strategyRegistry) internal {
        require(_strategyRegistry != address(0), 'CL::I zero address');
        strategyRegistry = _strategyRegistry;
        emit StrategyRegistryUpdated(_strategyRegistry);
    }

    /**
     * @notice used to update the liquidatorRewardFraction
     * @dev can only be updated by owner
     * @param _rewardFraction fraction of liquidated amount given to liquidator as reward
     */
    function updateLiquidatorRewardFraction(uint256 _rewardFraction) external onlyOwner {
        _updateLiquidatorRewardFraction(_rewardFraction);
    }

    function _updateLiquidatorRewardFraction(uint256 _rewardFraction) internal {
        require(_rewardFraction <= 10**30, 'Fraction has to be less than 1');
        liquidatorRewardFraction = _rewardFraction;
        emit LiquidationRewardFractionUpdated(_rewardFraction);
    }

    /**
     * @dev Used to Calculate Interest Per second on given principal and Interest rate
     * @param _principal principal Amount for which interest has to be calculated.
     * @param _borrowRate It is the Interest Rate at which Credit Line is approved
     * @return interest per second for the given parameters
     */
    function calculateInterest(
        uint256 _principal,
        uint256 _borrowRate,
        uint256 _timeElapsed
    ) public pure returns (uint256) {
        uint256 _interest = _principal.mul(_borrowRate).mul(_timeElapsed).div(10**30).div(YEAR_IN_SECONDS);

        return _interest;
    }

    /**
     * @dev Used to calculate interest accrued since last repayment
     * @param _id identifier for the credit line
     * @return interest accrued over current borrowed amount since last repayment
     */

    function calculateInterestAccrued(uint256 _id) public view returns (uint256) {
        uint256 _lastPrincipalUpdateTime = creditLineVariables[_id].lastPrincipalUpdateTime;
        if (_lastPrincipalUpdateTime == 0) return 0;
        uint256 _timeElapsed = (block.timestamp).sub(_lastPrincipalUpdateTime);
        uint256 _interestAccrued = calculateInterest(creditLineVariables[_id].principal, creditLineConstants[_id].borrowRate, _timeElapsed);
        return _interestAccrued;
    }

    /**
     * @dev Used to calculate current debt of borrower against a credit line.
     * @param _id identifier for the credit line
     * @return current debt of borrower
     */
    function calculateCurrentDebt(uint256 _id) public view returns (uint256) {
        uint256 _interestAccrued = calculateInterestAccrued(_id);
        uint256 _currentDebt = (creditLineVariables[_id].principal)
            .add(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate)
            .add(_interestAccrued)
            .sub(creditLineVariables[_id].totalInterestRepaid);
        return _currentDebt;
    }

    /**
     * @notice used to calculate amount that can be borrowed by the borrower
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view.
            borrowableAmount changes per block as interest changes per block.
     * @param _id identifier for the credit line
     * @return amount that can be borrowed from the credit line
     */
    function calculateBorrowableAmount(uint256 _id) public returns (uint256) {
        CreditLineStatus _status = creditLineVariables[_id].status;
        require(
            _status == CreditLineStatus.ACTIVE || _status == CreditLineStatus.REQUESTED,
            'CreditLine: Cannot only if credit line ACTIVE or REQUESTED'
        );
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(
            creditLineConstants[_id].collateralAsset,
            creditLineConstants[_id].borrowAsset
        );

        uint256 _totalCollateralToken = calculateTotalCollateralTokens(_id);

        uint256 _currentDebt = calculateCurrentDebt(_id);

        uint256 _maxPossible = _totalCollateralToken.mul(_ratioOfPrices).div(creditLineConstants[_id].idealCollateralRatio).mul(10**30).div(
            10**_decimals
        );

        uint256 _borrowLimit = creditLineConstants[_id].borrowLimit;

        if (_maxPossible > _borrowLimit) {
            _maxPossible = _borrowLimit;
        }
        if (_maxPossible > _currentDebt) {
            return _maxPossible.sub(_currentDebt);
        }
        return 0;
    }

    function updateinterestAccruedTillLastPrincipalUpdate(uint256 _id) internal {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');

        uint256 _interestAccrued = calculateInterestAccrued(_id);
        uint256 _newInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(_interestAccrued);
        creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _newInterestAccrued;
    }

    function _depositCollateralFromSavingsAccount(
        uint256 _id,
        uint256 _amount,
        address _sender
    ) internal {
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        uint256 _activeAmount;

        for (uint256 _index = 0; _index < _strategyList.length; _index++) {
            address _strategy = _strategyList[_index];
            uint256 _liquidityShares = _savingsAccount.balanceInShares(_sender, _collateralAsset, _strategy);
            if (_liquidityShares == 0 || _strategyList[_index] == address(0)) {
                continue;
            }
            uint256 _tokenInStrategy = _liquidityShares;
            _tokenInStrategy = IYield(_strategy).getTokensForShares(_liquidityShares, _collateralAsset);

            uint256 _tokensToTransfer = _tokenInStrategy;
            if (_activeAmount.add(_tokenInStrategy) >= _amount) {
                _tokensToTransfer = (_amount.sub(_activeAmount));
            }
            _activeAmount = _activeAmount.add(_tokensToTransfer);
            _savingsAccount.transferFrom(_tokensToTransfer, _collateralAsset, _strategy, _sender, address(this));

            collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(
                _liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy)
            );

            if (_amount == _activeAmount) {
                return;
            }
        }
        revert('CreditLine::_depositCollateralFromSavingsAccount - Insufficient balance');
    }

    /**
     * @notice used to request a credit line either by borrower or lender
     * @param _requestTo Address to which creditLine is requested, 
                        if borrower creates request then lender address and 
                        if lender creates then borrower address
     * @param _borrowLimit maximum borrow amount in a credit line
     * @param _borrowRate Interest Rate at which credit Line is requested
     * @param _autoLiquidation if true, anyone can liquidate loan, otherwise only lender
     * @param _collateralRatio ratio of the collateral to the debt below which credit line can be liquidated
     * @param _borrowAsset address of the token to be borrowed
     * @param _collateralAsset address of the token provided as collateral
     * @param _requestAsLender if true, lender is placing request, otherwise borrower
     * @return identifier for the credit line
     */

    function request(
        address _requestTo,
        uint256 _borrowLimit,
        uint256 _borrowRate,
        bool _autoLiquidation,
        uint256 _collateralRatio,
        address _borrowAsset,
        address _collateralAsset,
        bool _requestAsLender
    ) external returns (uint256) {
        require(_borrowAsset != _collateralAsset, 'R: cant borrow lent token');
        require(IPriceOracle(priceOracle).doesFeedExist(_borrowAsset, _collateralAsset), 'R: No price feed');

        address _lender = _requestTo;
        address _borrower = msg.sender;
        if (_requestAsLender) {
            _lender = msg.sender;
            _borrower = _requestTo;
        }

        uint256 _id = _createRequest(
            _lender,
            _borrower,
            _borrowLimit,
            _borrowRate,
            _autoLiquidation,
            _collateralRatio,
            _borrowAsset,
            _collateralAsset,
            _requestAsLender
        );

        emit CreditLineRequested(_id, _lender, _borrower);
        return _id;
    }

    function _createRequest(
        address _lender,
        address _borrower,
        uint256 _borrowLimit,
        uint256 _borrowRate,
        bool _autoLiquidation,
        uint256 _collateralRatio,
        address _borrowAsset,
        address _collateralAsset,
        bool _requestByLender
    ) internal returns (uint256) {
        require(_lender != _borrower, 'Lender and Borrower cannot be same addresses');
        uint256 _id = creditLineCounter + 1;
        creditLineCounter = _id;
        creditLineVariables[_id].status = CreditLineStatus.REQUESTED;
        creditLineConstants[_id].borrower = _borrower;
        creditLineConstants[_id].lender = _lender;
        creditLineConstants[_id].borrowLimit = _borrowLimit;
        creditLineConstants[_id].autoLiquidation = _autoLiquidation;
        creditLineConstants[_id].idealCollateralRatio = _collateralRatio;
        creditLineConstants[_id].borrowRate = _borrowRate;
        creditLineConstants[_id].borrowAsset = _borrowAsset;
        creditLineConstants[_id].collateralAsset = _collateralAsset;
        creditLineConstants[_id].requestByLender = _requestByLender;
        return _id;
    }

    /**
     * @notice used to accept a credit line
     * @dev if borrower places request, lender can accept and vice versa
     * @param _id identifier for the credit line
     */
    function accept(uint256 _id) external {
        require(
            creditLineVariables[_id].status == CreditLineStatus.REQUESTED,
            'CreditLine::acceptCreditLineLender - CreditLine is already accepted'
        );
        bool _requestByLender = creditLineConstants[_id].requestByLender;
        require(
            (msg.sender == creditLineConstants[_id].borrower && _requestByLender) ||
                (msg.sender == creditLineConstants[_id].lender && !_requestByLender),
            "Only Borrower or Lender who hasn't requested can accept"
        );
        creditLineVariables[_id].status = CreditLineStatus.ACTIVE;
        emit CreditLineAccepted(_id);
    }

    /**
     * @notice used to deposit collateral into the credit line
     * @dev collateral tokens have to be approved in savingsAccount or token contract(unless ether).
            If transferred from savings account, the tokens are transferred from strategies in the 
            order prespecified in strategy registry
     * @param _id identifier for the credit line
     * @param _amount amount of collateral being deposited
     * @param _strategy strategy to which collateral is to be deposited in case transfer is not from savings account
     * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount 
                                otherwise direct from collateral token contract
     */
    function depositCollateral(
        uint256 _id,
        uint256 _amount,
        address _strategy,
        bool _fromSavingsAccount
    ) external payable nonReentrant ifCreditLineExists(_id) {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine not active');
        _depositCollateral(_id, _amount, _strategy, _fromSavingsAccount);
        emit CollateralDeposited(_id, _amount, _strategy);
    }

    function _depositCollateral(
        uint256 _id,
        uint256 _amount,
        address _strategy,
        bool _fromSavingsAccount
    ) internal {
        require(creditLineConstants[_id].lender != msg.sender, 'lender cant deposit collateral');
        if (_fromSavingsAccount) {
            _depositCollateralFromSavingsAccount(_id, _amount, msg.sender);
        } else {
            address _collateralAsset = creditLineConstants[_id].collateralAsset;
            ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
            if (_collateralAsset == address(0)) {
                require(msg.value == _amount, "CreditLine::_depositCollateral - value to transfer doesn't match argument");
            } else {
                IERC20(_collateralAsset).safeTransferFrom(msg.sender, address(this), _amount);
                IERC20(_collateralAsset).approve(_strategy, _amount);
            }
            uint256 _sharesReceived = _savingsAccount.deposit{value: msg.value}(_amount, _collateralAsset, _strategy, address(this));
            collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(_sharesReceived);
        }
    }

    function _withdrawBorrowAmount(
        address _asset,
        uint256 _amountInTokens,
        address _lender
    ) internal {
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        uint256 _activeAmount;
        for (uint256 _index = 0; _index < _strategyList.length; _index++) {
            if (_strategyList[_index] == address(0)) {
                continue;
            }
            uint256 _liquidityShares = _savingsAccount.balanceInShares(_lender, _asset, _strategyList[_index]);
            if (_liquidityShares != 0) {
                uint256 tokenInStrategy = _liquidityShares;
                tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);
                uint256 _tokensToTransfer = tokenInStrategy;
                if (_activeAmount.add(tokenInStrategy) >= _amountInTokens) {
                    _tokensToTransfer = (_amountInTokens.sub(_activeAmount));
                }
                _activeAmount = _activeAmount.add(_tokensToTransfer);
                _savingsAccount.withdrawFrom(_tokensToTransfer, _asset, _strategyList[_index], _lender, address(this), false);
                if (_activeAmount == _amountInTokens) {
                    return;
                }
            }
        }
        require(_activeAmount == _amountInTokens, 'insufficient balance');
    }

    /**
     * @notice used to borrow tokens from credit line by borrower
     * @dev only borrower can call this function. Amount that can actually be borrowed is 
            min(amount based on borrowLimit, allowance to creditLine contract, balance of lender)
     * @param _id identifier for the credit line
     * @param _amount amount of tokens to borrow
     */
    function borrow(uint256 _id, uint256 _amount) external payable nonReentrant onlyCreditLineBorrower(_id) {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');
        uint256 _borrowableAmount = calculateBorrowableAmount(_id);
        require(_amount <= _borrowableAmount, "CreditLine::borrow - The current collateral ratio doesn't allow to withdraw the amount");
        address _borrowAsset = creditLineConstants[_id].borrowAsset;
        address _lender = creditLineConstants[_id].lender;

        updateinterestAccruedTillLastPrincipalUpdate(_id);
        creditLineVariables[_id].principal = creditLineVariables[_id].principal.add(_amount);
        creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;

        uint256 _tokenDiffBalance;
        if (_borrowAsset != address(0)) {
            uint256 _balanceBefore = IERC20(_borrowAsset).balanceOf(address(this));
            _withdrawBorrowAmount(_borrowAsset, _amount, _lender);
            uint256 _balanceAfter = IERC20(_borrowAsset).balanceOf(address(this));
            _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);
        } else {
            uint256 _balanceBefore = address(this).balance;
            _withdrawBorrowAmount(_borrowAsset, _amount, _lender);
            uint256 _balanceAfter = address(this).balance;
            _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);
        }
        uint256 _protocolFee = _tokenDiffBalance.mul(protocolFeeFraction).div(10**30);
        _tokenDiffBalance = _tokenDiffBalance.sub(_protocolFee);

        if (_borrowAsset == address(0)) {
            (bool feeSuccess, ) = protocolFeeCollector.call{value: _protocolFee}('');
            require(feeSuccess, 'Transfer fail');
            (bool success, ) = msg.sender.call{value: _tokenDiffBalance}('');
            require(success, 'Transfer fail');
        } else {
            IERC20(_borrowAsset).safeTransfer(protocolFeeCollector, _protocolFee);
            IERC20(_borrowAsset).safeTransfer(msg.sender, _tokenDiffBalance);
        }
        emit BorrowedFromCreditLine(_id, _tokenDiffBalance);
    }

    function _repayFromSavingsAccount(
        uint256 _amount,
        address _asset,
        address _lender
    ) internal {
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        uint256 _activeAmount;

        for (uint256 _index = 0; _index < _strategyList.length; _index++) {
            if (_strategyList[_index] == address(0)) {
                continue;
            }
            uint256 _liquidityShares = _savingsAccount.balanceInShares(msg.sender, _asset, _strategyList[_index]);
            if (_liquidityShares == 0) {
                continue;
            }
            uint256 _tokenInStrategy = _liquidityShares;
            _tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);

            uint256 _tokensToTransfer = _tokenInStrategy;
            if (_activeAmount.add(_tokenInStrategy) >= _amount) {
                _tokensToTransfer = (_amount.sub(_activeAmount));
            }
            _activeAmount = _activeAmount.add(_tokensToTransfer);
            _savingsAccount.transferFrom(_tokensToTransfer, _asset, _strategyList[_index], msg.sender, _lender);

            if (_amount == _activeAmount) {
                return;
            }
        }
        revert('CreditLine::_repayFromSavingsAccount - Insufficient balance');
    }

    function _repay(
        uint256 _id,
        uint256 _amount,
        bool _fromSavingsAccount,
        uint256 _principalPaid
    ) internal {
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        address _defaultStrategy = defaultStrategy;
        address _borrowAsset = creditLineConstants[_id].borrowAsset;
        address _lender = creditLineConstants[_id].lender;
        if (!_fromSavingsAccount) {
            if (_borrowAsset == address(0)) {
                require(msg.value == _amount, 'creditLine::repay - Ether sent not equal to repay amount');
                _savingsAccount.deposit{value: _amount}(_amount, _borrowAsset, _defaultStrategy, _lender);
            } else {
                IERC20(_borrowAsset).safeTransferFrom(msg.sender, address(this), _amount);
                IERC20(_borrowAsset).approve(_defaultStrategy, _amount);
                _savingsAccount.deposit(_amount, _borrowAsset, _defaultStrategy, _lender);
            }
        } else {
            _repayFromSavingsAccount(_amount, _borrowAsset, _lender);
        }
        if (_principalPaid != 0) {
            _savingsAccount.increaseAllowanceToCreditLine(_principalPaid, _borrowAsset, _lender);
        }
    }

    /**
     * @notice used to repay interest and principal to credit line. Interest has to be repaid before repaying principal
     * @dev partial repayments possible
     * @param _id identifier for the credit line
     * @param _amount amount being repaid
     * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount 
                                otherwise direct from collateral token contract
     */
    function repay(
        uint256 _id,
        uint256 _amount,
        bool _fromSavingsAccount
    ) external payable nonReentrant {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');
        require(creditLineConstants[_id].lender != msg.sender, 'Lender cant repay');

        uint256 _interestSincePrincipalUpdate = calculateInterestAccrued(_id);
        uint256 _totalInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(
            _interestSincePrincipalUpdate
        );
        uint256 _interestToPay = _totalInterestAccrued.sub(creditLineVariables[_id].totalInterestRepaid);
        uint256 _totalCurrentDebt = _interestToPay.add(creditLineVariables[_id].principal);
        uint256 _principalPaid = 0;

        if (_amount >= _totalCurrentDebt) {
            _amount = _totalCurrentDebt;
            emit CompleteCreditLineRepaid(_id, _amount);
        } else {
            emit PartialCreditLineRepaid(_id, _amount);
        }

        if (_amount > _interestToPay) {
            creditLineVariables[_id].principal = _totalCurrentDebt.sub(_amount);
            creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _totalInterestAccrued;
            creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;
            creditLineVariables[_id].totalInterestRepaid = _totalInterestAccrued;
            _principalPaid = _amount.sub(_interestToPay);
        } else {
            creditLineVariables[_id].totalInterestRepaid = creditLineVariables[_id].totalInterestRepaid.add(_amount);
        }

        _repay(_id, _amount, _fromSavingsAccount, _principalPaid);

        if (creditLineVariables[_id].principal == 0) {
            _resetCreditLine(_id);
        }
    }

    function _resetCreditLine(uint256 _id) internal {
        creditLineVariables[_id].lastPrincipalUpdateTime = 0;
        creditLineVariables[_id].totalInterestRepaid = 0;
        creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = 0;
        emit CreditLineReset(_id);
    }

    /**
     * @dev used to close credit line by borrower or lender
     * @param _id identifier for the credit line
     */
    function close(uint256 _id) external ifCreditLineExists(_id) {
        require(
            msg.sender == creditLineConstants[_id].borrower || msg.sender == creditLineConstants[_id].lender,
            'CreditLine: Permission denied while closing Line of credit'
        );
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: Credit line should be active.');
        require(creditLineVariables[_id].principal == 0, 'CreditLine: Cannot be closed since not repaid.');
        require(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate == 0, 'CreditLine: Cannot be closed since not repaid.');
        creditLineVariables[_id].status = CreditLineStatus.CLOSED;
        emit CreditLineClosed(_id);
    }

    /**
     * @notice used to calculate the current collateral ratio
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view.
            Interest is also considered while calculating debt
     * @param _id identifier for the credit line
     * @return collateral ratio multiplied by 10**30 to retain precision
     */
    function calculateCurrentCollateralRatio(uint256 _id) public ifCreditLineExists(_id) returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(
            creditLineConstants[_id].collateralAsset,
            creditLineConstants[_id].borrowAsset
        );

        uint256 currentDebt = calculateCurrentDebt(_id);
        uint256 currentCollateralRatio = calculateTotalCollateralTokens(_id).mul(_ratioOfPrices).div(currentDebt).mul(10**30).div(
            10**_decimals
        );

        return currentCollateralRatio;
    }

    /**
     * @notice used to calculate the total collateral tokens
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @param _id identifier for the credit line
     * @return _amount total collateral tokens deposited into the credit line
     */
    function calculateTotalCollateralTokens(uint256 _id) public returns (uint256 _amount) {
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        uint256 _liquidityShares;
        for (uint256 index = 0; index < _strategyList.length; index++) {
            if (_strategyList[index] == address(0)) {
                continue;
            }
            _liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];
            uint256 _tokenInStrategy = _liquidityShares;
            _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(_liquidityShares, _collateralAsset);

            _amount = _amount.add(_tokenInStrategy);
        }
    }

    /**
     * @notice used to withdraw any excess collateral
     * @dev collateral can't be withdraw if collateralRatio goes below the ideal value. Only borrower can withdraw
     * @param _id identifier for the credit line
     * @param _amount amount of collateral to withdraw
     * @param _toSavingsAccount if true, tokens are transferred from savingsAccount 
                                otherwise direct from collateral token contract
     */
    function withdrawCollateral(
        uint256 _id,
        uint256 _amount,
        bool _toSavingsAccount
    ) external nonReentrant onlyCreditLineBorrower(_id) {
        uint256 _withdrawableCollateral = withdrawableCollateral(_id);
        require(_amount <= _withdrawableCollateral, 'Collateral ratio cant go below ideal');
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        _transferCollateral(_id, _collateralAsset, _amount, _toSavingsAccount);
        emit CollateralWithdrawn(_id, _amount);
    }

    /**
     * @notice used to calculate the collateral that can be withdrawn
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @param _id identifier for the credit line
     * @return total collateral withdrawable by borrower
     */
    function withdrawableCollateral(uint256 _id) public returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(
            creditLineConstants[_id].collateralAsset,
            creditLineConstants[_id].borrowAsset
        );

        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);
        uint256 _currentDebt = calculateCurrentDebt(_id);

        uint256 _collateralNeeded = _currentDebt
            .mul(creditLineConstants[_id].idealCollateralRatio)
            .div(_ratioOfPrices)
            .mul(10**_decimals)
            .div(10**30);

        if (_collateralNeeded >= _totalCollateralTokens) {
            return 0;
        }
        return _totalCollateralTokens.sub(_collateralNeeded);
    }

    function _transferCollateral(
        uint256 _id,
        address _asset,
        uint256 _amountInTokens,
        bool _toSavingsAccount
    ) internal {
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        uint256 _activeAmount;
        for (uint256 index = 0; index < _strategyList.length; index++) {
            uint256 liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];
            if (liquidityShares == 0 || _strategyList[index] == address(0)) {
                continue;
            }
            uint256 _tokenInStrategy = liquidityShares;
            _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(liquidityShares, _asset);
            uint256 _tokensToTransfer = _tokenInStrategy;
            if (_activeAmount.add(_tokenInStrategy) > _amountInTokens) {
                _tokensToTransfer = _amountInTokens.sub(_activeAmount);
                liquidityShares = liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy);
            }
            _activeAmount = _activeAmount.add(_tokensToTransfer);
            collateralShareInStrategy[_id][_strategyList[index]] = collateralShareInStrategy[_id][_strategyList[index]].sub(
                liquidityShares
            );
            if (_toSavingsAccount) {
                ISavingsAccount(savingsAccount).transfer(_tokensToTransfer, _asset, _strategyList[index], msg.sender);
            } else {
                ISavingsAccount(savingsAccount).withdraw(_tokensToTransfer, _asset, _strategyList[index], msg.sender, false);
            }

            if (_activeAmount == _amountInTokens) {
                return;
            }
        }
        revert('insufficient collateral');
    }

    /**
     * @notice used to liquidate credit line in case collateral ratio goes below the threshold
     * @dev if lender liquidates, then collateral is directly transferred. 
            If autoLiquidation is true, anyone can liquidate by providing enough borrow tokens
     * @param _id identifier for the credit line
     * @param _toSavingsAccount if true, tokens are transferred from savingsAccount 
                                otherwise direct from collateral token contract
     */
    function liquidate(uint256 _id, bool _toSavingsAccount) external payable nonReentrant {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: Credit line should be active.');
        require(creditLineVariables[_id].principal != 0, 'CreditLine: cannot liquidate if principal is 0');

        uint256 currentCollateralRatio = calculateCurrentCollateralRatio(_id);
        require(
            currentCollateralRatio < creditLineConstants[_id].idealCollateralRatio,
            'CreditLine: Collateral ratio is higher than ideal value'
        );

        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        address _lender = creditLineConstants[_id].lender;
        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);
        address _borrowAsset = creditLineConstants[_id].borrowAsset;

        creditLineVariables[_id].status = CreditLineStatus.LIQUIDATED;

        if (creditLineConstants[_id].autoLiquidation && _lender != msg.sender) {
            uint256 _borrowTokens = _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens);
            if (_borrowAsset == address(0)) {
                uint256 _returnETH = msg.value.sub(_borrowTokens, 'Insufficient ETH to liquidate');
                if (_returnETH != 0) {
                    (bool success, ) = msg.sender.call{value: _returnETH}('');
                    require(success, 'Transfer fail');
                }
            } else {
                IERC20(_borrowAsset).safeTransferFrom(msg.sender, _lender, _borrowTokens);
            }
        }

        _transferCollateral(_id, _collateralAsset, _totalCollateralTokens, _toSavingsAccount);

        emit CreditLineLiquidated(_id, msg.sender);
    }

    /**
     * @notice used to calculate the borrow tokens necessary for liquidator to liquidate
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @param _id identifier for the credit line
     * @return borrow tokens necessary for liquidator to liquidate
     */
    function borrowTokensToLiquidate(uint256 _id) external returns (uint256) {
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);
        address _borrowAsset = creditLineConstants[_id].borrowAsset;

        return _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens);
    }

    function _borrowTokensToLiquidate(
        address _borrowAsset,
        address _collateralAsset,
        uint256 _totalCollateralTokens
    ) internal view returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(_borrowAsset, _collateralAsset);
        uint256 _borrowTokens = (
            _totalCollateralTokens.mul(uint256(10**30).sub(liquidatorRewardFraction)).div(10**30).mul(_ratioOfPrices).div(10**_decimals)
        );

        return _borrowTokens;
    }

    receive() external payable {
        require(msg.sender == savingsAccount, 'CreditLine::receive invalid transaction');
    }
}
".

As the Security Analyst, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user.

Note that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we've collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with <INFO>, followed directly by the final idea or enhancement suggestion, e.g. "<INFO> Implementing a multi-sig wallet mechanism for added security in transactions".

[2024-22-08 11:43:00 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-22-08 11:43:01 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 20056
completion_tokens: 1
total_tokens: 20057
cost: $-1.000000


[2024-22-08 11:43:01 INFO] Security Analyst: **Security Analyst<->Chief Executive Officer on : ContractAnalysis, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer.
Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees.
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/utils/ReentrancyGuard.sol';
import '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';
import '../interfaces/IPriceOracle.sol';
import '../interfaces/IYield.sol';
import '../interfaces/ISavingsAccount.sol';
import '../SavingsAccount/SavingsAccountUtil.sol';
import '../interfaces/IStrategyRegistry.sol';

/**
 * @title Credit Line contract with Methods related to credit Line
 * @notice Implements the functions related to Credit Line
 * @author Sublime
 **/

contract CreditLine is ReentrancyGuard, OwnableUpgradeable {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    enum CreditLineStatus {
        NOT_CREATED,
        REQUESTED,
        ACTIVE,
        CLOSED,
        CANCELLED,
        LIQUIDATED
    }

    /**
     * @notice counter that tracks the number of credit lines created
     * @dev used to create unique identifier for credit lines
     **/
    uint256 public creditLineCounter;

    uint256 constant YEAR_IN_SECONDS = 365 days;

    struct CreditLineVariables {
        CreditLineStatus status;
        uint256 principal;
        uint256 totalInterestRepaid;
        uint256 lastPrincipalUpdateTime;
        uint256 interestAccruedTillLastPrincipalUpdate;
    }

    struct CreditLineConstants {
        address lender;
        address borrower;
        uint256 borrowLimit;
        uint256 idealCollateralRatio;
        uint256 borrowRate;
        address borrowAsset;
        address collateralAsset;
        bool autoLiquidation;
        bool requestByLender;
    }
    /**
     * @notice stores the collateral shares in a credit line per strategy
     * @dev creditLineId => Strategy => collateralShares
     **/
    mapping(uint256 => mapping(address => uint256)) public collateralShareInStrategy;

    /**
     * @notice stores the variables to maintain a credit line
     **/
    mapping(uint256 => CreditLineVariables) public creditLineVariables;

    /**
     * @notice stores the constants related to a credit line
     **/
    mapping(uint256 => CreditLineConstants) public creditLineConstants;

    /**
     * @notice stores the address of savings account contract
     **/
    address public savingsAccount;

    /**
     * @notice stores the address of price oracle contract
     **/
    address public priceOracle;

    /**
     * @notice stores the address of strategy registry contract
     **/
    address public strategyRegistry;

    /**
     * @notice stores the address of default strategy
     **/
    address public defaultStrategy;

    /**
     * @notice stores the fraction of borrowed amount charged as fee by protocol
     * @dev it is multiplied by 10**30
     **/
    uint256 public protocolFeeFraction;

    /**
     * @notice address where protocol fee is collected
     **/
    address public protocolFeeCollector;

    /**
     * @notice stores the fraction of amount liquidated given as reward to liquidator
     * @dev it is multiplied by 10**30
     **/
    uint256 public liquidatorRewardFraction;
    /**
     * @dev checks if Credit Line exists
     * @param _id identifier for the credit line
     **/
    modifier ifCreditLineExists(uint256 _id) {
        require(creditLineVariables[_id].status != CreditLineStatus.NOT_CREATED, 'Credit line does not exist');
        _;
    }

    /**
     * @dev checks if called by credit Line Borrower
     * @param _id creditLine identifier
     **/
    modifier onlyCreditLineBorrower(uint256 _id) {
        require(creditLineConstants[_id].borrower == msg.sender, 'Only credit line Borrower can access');
        _;
    }

    /**
     * @dev checks if called by credit Line Lender
     * @param _id creditLine identifier
     **/
    modifier onlyCreditLineLender(uint256 _id) {
        require(creditLineConstants[_id].lender == msg.sender, 'Only credit line Lender can access');
        _;
    }

    /**
     * @notice emitted when a collateral is deposited into credit line
     * @param id id of the credit line
     * @param amount amount of collateral deposited
     * @param strategy address of the strategy into which collateral is deposited
     */
    event CollateralDeposited(uint256 indexed id, uint256 amount, address indexed strategy);

    /**
     * @notice emitted when collateral is withdrawn from credit line
     * @param id id of the credit line
     * @param amount amount of collateral withdrawn
     */
    event CollateralWithdrawn(uint256 indexed id, uint256 amount);

    /**
     * @notice emitted when a request for new credit line is placed
     * @param id id of the credit line for which request was made
     * @param lender address of the lender for credit line
     * @param borrower address of the borrower for credit line
     */
    event CreditLineRequested(uint256 indexed id, address indexed lender, address indexed borrower);

    /**
     * @notice emitted when a credit line is liquidated
     * @param id id of the credit line which is liquidated
     * @param liquidator address of the liquidator
     */
    event CreditLineLiquidated(uint256 indexed id, address indexed liquidator);

    /**
     * @notice emitted when tokens are borrowed from credit line
     * @param id id of the credit line from which tokens are borrowed
     * @param borrowAmount amount of tokens borrowed
     */
    event BorrowedFromCreditLine(uint256 indexed id, uint256 borrowAmount);

    /**
     * @notice emitted when credit line is accepted
     * @param id id of the credit line that was accepted
     */
    event CreditLineAccepted(uint256 indexed id);

    /**
     * @notice emitted when credit line is completely repaid and reset
     * @param id id of the credit line that is reset
     */
    event CreditLineReset(uint256 indexed id);

    /**
     * @notice emitted when the credit line is partially repaid
     * @param id id of the credit line
     * @param repayAmount amount repaid
     */
    event PartialCreditLineRepaid(uint256 indexed id, uint256 repayAmount);

    /**
     * @notice emitted when the credit line is completely repaid
     * @param id id of the credit line
     * @param repayAmount amount repaid
     */
    event CompleteCreditLineRepaid(uint256 indexed id, uint256 repayAmount);

    /**
     * @notice emitted when the credit line is closed by one of the parties of credit line
     * @param id id of the credit line
     */
    event CreditLineClosed(uint256 indexed id);

    /**
     * @notice emitted when default strategy for the credit line is updated
     * @param defaultStrategy address of the strategy contract that is used as default by credit lines
     */
    event DefaultStrategyUpdated(address indexed defaultStrategy);

    /**
     * @notice emitted when the price oracle is updated
     * @param priceOracle address of the updated price oracle
     */
    event PriceOracleUpdated(address indexed priceOracle);

    /**
     * @notice emitted when the savings account address is updated
     * @param savingsAccount address of the updated savingsAccount
     */
    event SavingsAccountUpdated(address indexed savingsAccount);

    /**
     * @notice emitted when strategy registry address is updated
     * @param strategyRegistry address of the updated strategy registry
     */
    event StrategyRegistryUpdated(address indexed strategyRegistry);

    /**
     * @notice emitted when fee that protocol charges for credit line is updated
     * @param updatedProtocolFee updated value of protocolFeeFraction
     */
    event ProtocolFeeFractionUpdated(uint256 updatedProtocolFee);

    /**
     * @notice emitted when address which receives fee that protocol changes for pools is updated
     * @param updatedProtocolFeeCollector updated value of protocolFeeCollector
     */
    event ProtocolFeeCollectorUpdated(address indexed updatedProtocolFeeCollector);

    /**
     * @notice emitted when liquidatorRewardFraction is updated
     * @param liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator
     */
    event LiquidationRewardFractionUpdated(uint256 liquidatorRewardFraction);

    /**
     * @notice used to initialize the contract
     * @dev can only be called once during the life cycle of the contract
     * @param _defaultStrategy default strategy used in credit lines
     * @param _priceOracle address of the priceOracle
     * @param _savingsAccount address of  the savings account contract
     * @param _strategyRegistry address of the strategy registry contract
     * @param _owner address of owner who can change global variables
     * @param _protocolFeeFraction fraction of the fee charged by protocol
     * @param _protocolFeeCollector address to which protocol fee is charged to
     * @param _liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator
     */
    function initialize(
        address _defaultStrategy,
        address _priceOracle,
        address _savingsAccount,
        address _strategyRegistry,
        address _owner,
        uint256 _protocolFeeFraction,
        address _protocolFeeCollector,
        uint256 _liquidatorRewardFraction
    ) external initializer {
        OwnableUpgradeable.__Ownable_init();
        OwnableUpgradeable.transferOwnership(_owner);

        _updateDefaultStrategy(_defaultStrategy);
        _updatePriceOracle(_priceOracle);
        _updateSavingsAccount(_savingsAccount);
        _updateStrategyRegistry(_strategyRegistry);
        _updateProtocolFeeFraction(_protocolFeeFraction);
        _updateProtocolFeeCollector(_protocolFeeCollector);
        _updateLiquidatorRewardFraction(_liquidatorRewardFraction);
    }

    /**
     * @notice used to update the default strategy
     * @dev can only be updated by owner
     * @param _defaultStrategy address of the updated default strategy
     */
    function updateDefaultStrategy(address _defaultStrategy) external onlyOwner {
        _updateDefaultStrategy(_defaultStrategy);
    }

    function _updateDefaultStrategy(address _defaultStrategy) internal {
        defaultStrategy = _defaultStrategy;
        emit DefaultStrategyUpdated(_defaultStrategy);
    }

    /**
     * @notice used to update the price oracle
     * @dev can only be updated by owner
     * @param _priceOracle address of the updated price oracle
     */
    function updatePriceOracle(address _priceOracle) external onlyOwner {
        _updatePriceOracle(_priceOracle);
    }

    function _updatePriceOracle(address _priceOracle) internal {
        priceOracle = _priceOracle;
        emit PriceOracleUpdated(_priceOracle);
    }

    /**
     * @notice used to update the savings account address
     * @dev can only be updated by owner
     * @param _savingsAccount address of the updated savings account
     */
    function updateSavingsAccount(address _savingsAccount) external onlyOwner {
        _updateSavingsAccount(_savingsAccount);
    }

    function _updateSavingsAccount(address _savingsAccount) internal {
        savingsAccount = _savingsAccount;
        emit SavingsAccountUpdated(_savingsAccount);
    }

    /**
     * @notice used to update the protocol fee fraction
     * @dev can only be updated by owner
     * @param _protocolFee fraction of the borrower amount collected as protocol fee
     */
    function updateProtocolFeeFraction(uint256 _protocolFee) external onlyOwner {
        _updateProtocolFeeFraction(_protocolFee);
    }

    function _updateProtocolFeeFraction(uint256 _protocolFee) internal {
        protocolFeeFraction = _protocolFee;
        emit ProtocolFeeFractionUpdated(_protocolFee);
    }

    /**
     * @notice used to update the protocol fee collector
     * @dev can only be updated by owner
     * @param _protocolFeeCollector address in which protocol fee is collected
     */
    function updateProtocolFeeCollector(address _protocolFeeCollector) external onlyOwner {
        _updateProtocolFeeCollector(_protocolFeeCollector);
    }

    function _updateProtocolFeeCollector(address _protocolFeeCollector) internal {
        require(_protocolFeeCollector != address(0), 'cant be 0 address');
        protocolFeeCollector = _protocolFeeCollector;
        emit ProtocolFeeCollectorUpdated(_protocolFeeCollector);
    }

    /**
     * @notice used to update the strategy registry address
     * @dev can only be updated by owner
     * @param _strategyRegistry address of the updated strategy registry
     */
    function updateStrategyRegistry(address _strategyRegistry) external onlyOwner {
        _updateStrategyRegistry(_strategyRegistry);
    }

    function _updateStrategyRegistry(address _strategyRegistry) internal {
        require(_strategyRegistry != address(0), 'CL::I zero address');
        strategyRegistry = _strategyRegistry;
        emit StrategyRegistryUpdated(_strategyRegistry);
    }

    /**
     * @notice used to update the liquidatorRewardFraction
     * @dev can only be updated by owner
     * @param _rewardFraction fraction of liquidated amount given to liquidator as reward
     */
    function updateLiquidatorRewardFraction(uint256 _rewardFraction) external onlyOwner {
        _updateLiquidatorRewardFraction(_rewardFraction);
    }

    function _updateLiquidatorRewardFraction(uint256 _rewardFraction) internal {
        require(_rewardFraction <= 10**30, 'Fraction has to be less than 1');
        liquidatorRewardFraction = _rewardFraction;
        emit LiquidationRewardFractionUpdated(_rewardFraction);
    }

    /**
     * @dev Used to Calculate Interest Per second on given principal and Interest rate
     * @param _principal principal Amount for which interest has to be calculated.
     * @param _borrowRate It is the Interest Rate at which Credit Line is approved
     * @return interest per second for the given parameters
     */
    function calculateInterest(
        uint256 _principal,
        uint256 _borrowRate,
        uint256 _timeElapsed
    ) public pure returns (uint256) {
        uint256 _interest = _principal.mul(_borrowRate).mul(_timeElapsed).div(10**30).div(YEAR_IN_SECONDS);

        return _interest;
    }

    /**
     * @dev Used to calculate interest accrued since last repayment
     * @param _id identifier for the credit line
     * @return interest accrued over current borrowed amount since last repayment
     */

    function calculateInterestAccrued(uint256 _id) public view returns (uint256) {
        uint256 _lastPrincipalUpdateTime = creditLineVariables[_id].lastPrincipalUpdateTime;
        if (_lastPrincipalUpdateTime == 0) return 0;
        uint256 _timeElapsed = (block.timestamp).sub(_lastPrincipalUpdateTime);
        uint256 _interestAccrued = calculateInterest(creditLineVariables[_id].principal, creditLineConstants[_id].borrowRate, _timeElapsed);
        return _interestAccrued;
    }

    /**
     * @dev Used to calculate current debt of borrower against a credit line.
     * @param _id identifier for the credit line
     * @return current debt of borrower
     */
    function calculateCurrentDebt(uint256 _id) public view returns (uint256) {
        uint256 _interestAccrued = calculateInterestAccrued(_id);
        uint256 _currentDebt = (creditLineVariables[_id].principal)
            .add(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate)
            .add(_interestAccrued)
            .sub(creditLineVariables[_id].totalInterestRepaid);
        return _currentDebt;
    }

    /**
     * @notice used to calculate amount that can be borrowed by the borrower
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view.
            borrowableAmount changes per block as interest changes per block.
     * @param _id identifier for the credit line
     * @return amount that can be borrowed from the credit line
     */
    function calculateBorrowableAmount(uint256 _id) public returns (uint256) {
        CreditLineStatus _status = creditLineVariables[_id].status;
        require(
            _status == CreditLineStatus.ACTIVE || _status == CreditLineStatus.REQUESTED,
            'CreditLine: Cannot only if credit line ACTIVE or REQUESTED'
        );
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(
            creditLineConstants[_id].collateralAsset,
            creditLineConstants[_id].borrowAsset
        );

        uint256 _totalCollateralToken = calculateTotalCollateralTokens(_id);

        uint256 _currentDebt = calculateCurrentDebt(_id);

        uint256 _maxPossible = _totalCollateralToken.mul(_ratioOfPrices).div(creditLineConstants[_id].idealCollateralRatio).mul(10**30).div(
            10**_decimals
        );

        uint256 _borrowLimit = creditLineConstants[_id].borrowLimit;

        if (_maxPossible > _borrowLimit) {
            _maxPossible = _borrowLimit;
        }
        if (_maxPossible > _currentDebt) {
            return _maxPossible.sub(_currentDebt);
        }
        return 0;
    }

    function updateinterestAccruedTillLastPrincipalUpdate(uint256 _id) internal {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');

        uint256 _interestAccrued = calculateInterestAccrued(_id);
        uint256 _newInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(_interestAccrued);
        creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _newInterestAccrued;
    }

    function _depositCollateralFromSavingsAccount(
        uint256 _id,
        uint256 _amount,
        address _sender
    ) internal {
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        uint256 _activeAmount;

        for (uint256 _index = 0; _index < _strategyList.length; _index++) {
            address _strategy = _strategyList[_index];
            uint256 _liquidityShares = _savingsAccount.balanceInShares(_sender, _collateralAsset, _strategy);
            if (_liquidityShares == 0 || _strategyList[_index] == address(0)) {
                continue;
            }
            uint256 _tokenInStrategy = _liquidityShares;
            _tokenInStrategy = IYield(_strategy).getTokensForShares(_liquidityShares, _collateralAsset);

            uint256 _tokensToTransfer = _tokenInStrategy;
            if (_activeAmount.add(_tokenInStrategy) >= _amount) {
                _tokensToTransfer = (_amount.sub(_activeAmount));
            }
            _activeAmount = _activeAmount.add(_tokensToTransfer);
            _savingsAccount.transferFrom(_tokensToTransfer, _collateralAsset, _strategy, _sender, address(this));

            collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(
                _liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy)
            );

            if (_amount == _activeAmount) {
                return;
            }
        }
        revert('CreditLine::_depositCollateralFromSavingsAccount - Insufficient balance');
    }

    /**
     * @notice used to request a credit line either by borrower or lender
     * @param _requestTo Address to which creditLine is requested, 
                        if borrower creates request then lender address and 
                        if lender creates then borrower address
     * @param _borrowLimit maximum borrow amount in a credit line
     * @param _borrowRate Interest Rate at which credit Line is requested
     * @param _autoLiquidation if true, anyone can liquidate loan, otherwise only lender
     * @param _collateralRatio ratio of the collateral to the debt below which credit line can be liquidated
     * @param _borrowAsset address of the token to be borrowed
     * @param _collateralAsset address of the token provided as collateral
     * @param _requestAsLender if true, lender is placing request, otherwise borrower
     * @return identifier for the credit line
     */

    function request(
        address _requestTo,
        uint256 _borrowLimit,
        uint256 _borrowRate,
        bool _autoLiquidation,
        uint256 _collateralRatio,
        address _borrowAsset,
        address _collateralAsset,
        bool _requestAsLender
    ) external returns (uint256) {
        require(_borrowAsset != _collateralAsset, 'R: cant borrow lent token');
        require(IPriceOracle(priceOracle).doesFeedExist(_borrowAsset, _collateralAsset), 'R: No price feed');

        address _lender = _requestTo;
        address _borrower = msg.sender;
        if (_requestAsLender) {
            _lender = msg.sender;
            _borrower = _requestTo;
        }

        uint256 _id = _createRequest(
            _lender,
            _borrower,
            _borrowLimit,
            _borrowRate,
            _autoLiquidation,
            _collateralRatio,
            _borrowAsset,
            _collateralAsset,
            _requestAsLender
        );

        emit CreditLineRequested(_id, _lender, _borrower);
        return _id;
    }

    function _createRequest(
        address _lender,
        address _borrower,
        uint256 _borrowLimit,
        uint256 _borrowRate,
        bool _autoLiquidation,
        uint256 _collateralRatio,
        address _borrowAsset,
        address _collateralAsset,
        bool _requestByLender
    ) internal returns (uint256) {
        require(_lender != _borrower, 'Lender and Borrower cannot be same addresses');
        uint256 _id = creditLineCounter + 1;
        creditLineCounter = _id;
        creditLineVariables[_id].status = CreditLineStatus.REQUESTED;
        creditLineConstants[_id].borrower = _borrower;
        creditLineConstants[_id].lender = _lender;
        creditLineConstants[_id].borrowLimit = _borrowLimit;
        creditLineConstants[_id].autoLiquidation = _autoLiquidation;
        creditLineConstants[_id].idealCollateralRatio = _collateralRatio;
        creditLineConstants[_id].borrowRate = _borrowRate;
        creditLineConstants[_id].borrowAsset = _borrowAsset;
        creditLineConstants[_id].collateralAsset = _collateralAsset;
        creditLineConstants[_id].requestByLender = _requestByLender;
        return _id;
    }

    /**
     * @notice used to accept a credit line
     * @dev if borrower places request, lender can accept and vice versa
     * @param _id identifier for the credit line
     */
    function accept(uint256 _id) external {
        require(
            creditLineVariables[_id].status == CreditLineStatus.REQUESTED,
            'CreditLine::acceptCreditLineLender - CreditLine is already accepted'
        );
        bool _requestByLender = creditLineConstants[_id].requestByLender;
        require(
            (msg.sender == creditLineConstants[_id].borrower && _requestByLender) ||
                (msg.sender == creditLineConstants[_id].lender && !_requestByLender),
            "Only Borrower or Lender who hasn't requested can accept"
        );
        creditLineVariables[_id].status = CreditLineStatus.ACTIVE;
        emit CreditLineAccepted(_id);
    }

    /**
     * @notice used to deposit collateral into the credit line
     * @dev collateral tokens have to be approved in savingsAccount or token contract(unless ether).
            If transferred from savings account, the tokens are transferred from strategies in the 
            order prespecified in strategy registry
     * @param _id identifier for the credit line
     * @param _amount amount of collateral being deposited
     * @param _strategy strategy to which collateral is to be deposited in case transfer is not from savings account
     * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount 
                                otherwise direct from collateral token contract
     */
    function depositCollateral(
        uint256 _id,
        uint256 _amount,
        address _strategy,
        bool _fromSavingsAccount
    ) external payable nonReentrant ifCreditLineExists(_id) {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine not active');
        _depositCollateral(_id, _amount, _strategy, _fromSavingsAccount);
        emit CollateralDeposited(_id, _amount, _strategy);
    }

    function _depositCollateral(
        uint256 _id,
        uint256 _amount,
        address _strategy,
        bool _fromSavingsAccount
    ) internal {
        require(creditLineConstants[_id].lender != msg.sender, 'lender cant deposit collateral');
        if (_fromSavingsAccount) {
            _depositCollateralFromSavingsAccount(_id, _amount, msg.sender);
        } else {
            address _collateralAsset = creditLineConstants[_id].collateralAsset;
            ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
            if (_collateralAsset == address(0)) {
                require(msg.value == _amount, "CreditLine::_depositCollateral - value to transfer doesn't match argument");
            } else {
                IERC20(_collateralAsset).safeTransferFrom(msg.sender, address(this), _amount);
                IERC20(_collateralAsset).approve(_strategy, _amount);
            }
            uint256 _sharesReceived = _savingsAccount.deposit{value: msg.value}(_amount, _collateralAsset, _strategy, address(this));
            collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(_sharesReceived);
        }
    }

    function _withdrawBorrowAmount(
        address _asset,
        uint256 _amountInTokens,
        address _lender
    ) internal {
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        uint256 _activeAmount;
        for (uint256 _index = 0; _index < _strategyList.length; _index++) {
            if (_strategyList[_index] == address(0)) {
                continue;
            }
            uint256 _liquidityShares = _savingsAccount.balanceInShares(_lender, _asset, _strategyList[_index]);
            if (_liquidityShares != 0) {
                uint256 tokenInStrategy = _liquidityShares;
                tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);
                uint256 _tokensToTransfer = tokenInStrategy;
                if (_activeAmount.add(tokenInStrategy) >= _amountInTokens) {
                    _tokensToTransfer = (_amountInTokens.sub(_activeAmount));
                }
                _activeAmount = _activeAmount.add(_tokensToTransfer);
                _savingsAccount.withdrawFrom(_tokensToTransfer, _asset, _strategyList[_index], _lender, address(this), false);
                if (_activeAmount == _amountInTokens) {
                    return;
                }
            }
        }
        require(_activeAmount == _amountInTokens, 'insufficient balance');
    }

    /**
     * @notice used to borrow tokens from credit line by borrower
     * @dev only borrower can call this function. Amount that can actually be borrowed is 
            min(amount based on borrowLimit, allowance to creditLine contract, balance of lender)
     * @param _id identifier for the credit line
     * @param _amount amount of tokens to borrow
     */
    function borrow(uint256 _id, uint256 _amount) external payable nonReentrant onlyCreditLineBorrower(_id) {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');
        uint256 _borrowableAmount = calculateBorrowableAmount(_id);
        require(_amount <= _borrowableAmount, "CreditLine::borrow - The current collateral ratio doesn't allow to withdraw the amount");
        address _borrowAsset = creditLineConstants[_id].borrowAsset;
        address _lender = creditLineConstants[_id].lender;

        updateinterestAccruedTillLastPrincipalUpdate(_id);
        creditLineVariables[_id].principal = creditLineVariables[_id].principal.add(_amount);
        creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;

        uint256 _tokenDiffBalance;
        if (_borrowAsset != address(0)) {
            uint256 _balanceBefore = IERC20(_borrowAsset).balanceOf(address(this));
            _withdrawBorrowAmount(_borrowAsset, _amount, _lender);
            uint256 _balanceAfter = IERC20(_borrowAsset).balanceOf(address(this));
            _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);
        } else {
            uint256 _balanceBefore = address(this).balance;
            _withdrawBorrowAmount(_borrowAsset, _amount, _lender);
            uint256 _balanceAfter = address(this).balance;
            _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);
        }
        uint256 _protocolFee = _tokenDiffBalance.mul(protocolFeeFraction).div(10**30);
        _tokenDiffBalance = _tokenDiffBalance.sub(_protocolFee);

        if (_borrowAsset == address(0)) {
            (bool feeSuccess, ) = protocolFeeCollector.call{value: _protocolFee}('');
            require(feeSuccess, 'Transfer fail');
            (bool success, ) = msg.sender.call{value: _tokenDiffBalance}('');
            require(success, 'Transfer fail');
        } else {
            IERC20(_borrowAsset).safeTransfer(protocolFeeCollector, _protocolFee);
            IERC20(_borrowAsset).safeTransfer(msg.sender, _tokenDiffBalance);
        }
        emit BorrowedFromCreditLine(_id, _tokenDiffBalance);
    }

    function _repayFromSavingsAccount(
        uint256 _amount,
        address _asset,
        address _lender
    ) internal {
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        uint256 _activeAmount;

        for (uint256 _index = 0; _index < _strategyList.length; _index++) {
            if (_strategyList[_index] == address(0)) {
                continue;
            }
            uint256 _liquidityShares = _savingsAccount.balanceInShares(msg.sender, _asset, _strategyList[_index]);
            if (_liquidityShares == 0) {
                continue;
            }
            uint256 _tokenInStrategy = _liquidityShares;
            _tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);

            uint256 _tokensToTransfer = _tokenInStrategy;
            if (_activeAmount.add(_tokenInStrategy) >= _amount) {
                _tokensToTransfer = (_amount.sub(_activeAmount));
            }
            _activeAmount = _activeAmount.add(_tokensToTransfer);
            _savingsAccount.transferFrom(_tokensToTransfer, _asset, _strategyList[_index], msg.sender, _lender);

            if (_amount == _activeAmount) {
                return;
            }
        }
        revert('CreditLine::_repayFromSavingsAccount - Insufficient balance');
    }

    function _repay(
        uint256 _id,
        uint256 _amount,
        bool _fromSavingsAccount,
        uint256 _principalPaid
    ) internal {
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        address _defaultStrategy = defaultStrategy;
        address _borrowAsset = creditLineConstants[_id].borrowAsset;
        address _lender = creditLineConstants[_id].lender;
        if (!_fromSavingsAccount) {
            if (_borrowAsset == address(0)) {
                require(msg.value == _amount, 'creditLine::repay - Ether sent not equal to repay amount');
                _savingsAccount.deposit{value: _amount}(_amount, _borrowAsset, _defaultStrategy, _lender);
            } else {
                IERC20(_borrowAsset).safeTransferFrom(msg.sender, address(this), _amount);
                IERC20(_borrowAsset).approve(_defaultStrategy, _amount);
                _savingsAccount.deposit(_amount, _borrowAsset, _defaultStrategy, _lender);
            }
        } else {
            _repayFromSavingsAccount(_amount, _borrowAsset, _lender);
        }
        if (_principalPaid != 0) {
            _savingsAccount.increaseAllowanceToCreditLine(_principalPaid, _borrowAsset, _lender);
        }
    }

    /**
     * @notice used to repay interest and principal to credit line. Interest has to be repaid before repaying principal
     * @dev partial repayments possible
     * @param _id identifier for the credit line
     * @param _amount amount being repaid
     * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount 
                                otherwise direct from collateral token contract
     */
    function repay(
        uint256 _id,
        uint256 _amount,
        bool _fromSavingsAccount
    ) external payable nonReentrant {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');
        require(creditLineConstants[_id].lender != msg.sender, 'Lender cant repay');

        uint256 _interestSincePrincipalUpdate = calculateInterestAccrued(_id);
        uint256 _totalInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(
            _interestSincePrincipalUpdate
        );
        uint256 _interestToPay = _totalInterestAccrued.sub(creditLineVariables[_id].totalInterestRepaid);
        uint256 _totalCurrentDebt = _interestToPay.add(creditLineVariables[_id].principal);
        uint256 _principalPaid = 0;

        if (_amount >= _totalCurrentDebt) {
            _amount = _totalCurrentDebt;
            emit CompleteCreditLineRepaid(_id, _amount);
        } else {
            emit PartialCreditLineRepaid(_id, _amount);
        }

        if (_amount > _interestToPay) {
            creditLineVariables[_id].principal = _totalCurrentDebt.sub(_amount);
            creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _totalInterestAccrued;
            creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;
            creditLineVariables[_id].totalInterestRepaid = _totalInterestAccrued;
            _principalPaid = _amount.sub(_interestToPay);
        } else {
            creditLineVariables[_id].totalInterestRepaid = creditLineVariables[_id].totalInterestRepaid.add(_amount);
        }

        _repay(_id, _amount, _fromSavingsAccount, _principalPaid);

        if (creditLineVariables[_id].principal == 0) {
            _resetCreditLine(_id);
        }
    }

    function _resetCreditLine(uint256 _id) internal {
        creditLineVariables[_id].lastPrincipalUpdateTime = 0;
        creditLineVariables[_id].totalInterestRepaid = 0;
        creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = 0;
        emit CreditLineReset(_id);
    }

    /**
     * @dev used to close credit line by borrower or lender
     * @param _id identifier for the credit line
     */
    function close(uint256 _id) external ifCreditLineExists(_id) {
        require(
            msg.sender == creditLineConstants[_id].borrower || msg.sender == creditLineConstants[_id].lender,
            'CreditLine: Permission denied while closing Line of credit'
        );
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: Credit line should be active.');
        require(creditLineVariables[_id].principal == 0, 'CreditLine: Cannot be closed since not repaid.');
        require(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate == 0, 'CreditLine: Cannot be closed since not repaid.');
        creditLineVariables[_id].status = CreditLineStatus.CLOSED;
        emit CreditLineClosed(_id);
    }

    /**
     * @notice used to calculate the current collateral ratio
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view.
            Interest is also considered while calculating debt
     * @param _id identifier for the credit line
     * @return collateral ratio multiplied by 10**30 to retain precision
     */
    function calculateCurrentCollateralRatio(uint256 _id) public ifCreditLineExists(_id) returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(
            creditLineConstants[_id].collateralAsset,
            creditLineConstants[_id].borrowAsset
        );

        uint256 currentDebt = calculateCurrentDebt(_id);
        uint256 currentCollateralRatio = calculateTotalCollateralTokens(_id).mul(_ratioOfPrices).div(currentDebt).mul(10**30).div(
            10**_decimals
        );

        return currentCollateralRatio;
    }

    /**
     * @notice used to calculate the total collateral tokens
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @param _id identifier for the credit line
     * @return _amount total collateral tokens deposited into the credit line
     */
    function calculateTotalCollateralTokens(uint256 _id) public returns (uint256 _amount) {
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        uint256 _liquidityShares;
        for (uint256 index = 0; index < _strategyList.length; index++) {
            if (_strategyList[index] == address(0)) {
                continue;
            }
            _liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];
            uint256 _tokenInStrategy = _liquidityShares;
            _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(_liquidityShares, _collateralAsset);

            _amount = _amount.add(_tokenInStrategy);
        }
    }

    /**
     * @notice used to withdraw any excess collateral
     * @dev collateral can't be withdraw if collateralRatio goes below the ideal value. Only borrower can withdraw
     * @param _id identifier for the credit line
     * @param _amount amount of collateral to withdraw
     * @param _toSavingsAccount if true, tokens are transferred from savingsAccount 
                                otherwise direct from collateral token contract
     */
    function withdrawCollateral(
        uint256 _id,
        uint256 _amount,
        bool _toSavingsAccount
    ) external nonReentrant onlyCreditLineBorrower(_id) {
        uint256 _withdrawableCollateral = withdrawableCollateral(_id);
        require(_amount <= _withdrawableCollateral, 'Collateral ratio cant go below ideal');
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        _transferCollateral(_id, _collateralAsset, _amount, _toSavingsAccount);
        emit CollateralWithdrawn(_id, _amount);
    }

    /**
     * @notice used to calculate the collateral that can be withdrawn
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @param _id identifier for the credit line
     * @return total collateral withdrawable by borrower
     */
    function withdrawableCollateral(uint256 _id) public returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(
            creditLineConstants[_id].collateralAsset,
            creditLineConstants[_id].borrowAsset
        );

        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);
        uint256 _currentDebt = calculateCurrentDebt(_id);

        uint256 _collateralNeeded = _currentDebt
            .mul(creditLineConstants[_id].idealCollateralRatio)
            .div(_ratioOfPrices)
            .mul(10**_decimals)
            .div(10**30);

        if (_collateralNeeded >= _totalCollateralTokens) {
            return 0;
        }
        return _totalCollateralTokens.sub(_collateralNeeded);
    }

    function _transferCollateral(
        uint256 _id,
        address _asset,
        uint256 _amountInTokens,
        bool _toSavingsAccount
    ) internal {
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        uint256 _activeAmount;
        for (uint256 index = 0; index < _strategyList.length; index++) {
            uint256 liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];
            if (liquidityShares == 0 || _strategyList[index] == address(0)) {
                continue;
            }
            uint256 _tokenInStrategy = liquidityShares;
            _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(liquidityShares, _asset);
            uint256 _tokensToTransfer = _tokenInStrategy;
            if (_activeAmount.add(_tokenInStrategy) > _amountInTokens) {
                _tokensToTransfer = _amountInTokens.sub(_activeAmount);
                liquidityShares = liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy);
            }
            _activeAmount = _activeAmount.add(_tokensToTransfer);
            collateralShareInStrategy[_id][_strategyList[index]] = collateralShareInStrategy[_id][_strategyList[index]].sub(
                liquidityShares
            );
            if (_toSavingsAccount) {
                ISavingsAccount(savingsAccount).transfer(_tokensToTransfer, _asset, _strategyList[index], msg.sender);
            } else {
                ISavingsAccount(savingsAccount).withdraw(_tokensToTransfer, _asset, _strategyList[index], msg.sender, false);
            }

            if (_activeAmount == _amountInTokens) {
                return;
            }
        }
        revert('insufficient collateral');
    }

    /**
     * @notice used to liquidate credit line in case collateral ratio goes below the threshold
     * @dev if lender liquidates, then collateral is directly transferred. 
            If autoLiquidation is true, anyone can liquidate by providing enough borrow tokens
     * @param _id identifier for the credit line
     * @param _toSavingsAccount if true, tokens are transferred from savingsAccount 
                                otherwise direct from collateral token contract
     */
    function liquidate(uint256 _id, bool _toSavingsAccount) external payable nonReentrant {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: Credit line should be active.');
        require(creditLineVariables[_id].principal != 0, 'CreditLine: cannot liquidate if principal is 0');

        uint256 currentCollateralRatio = calculateCurrentCollateralRatio(_id);
        require(
            currentCollateralRatio < creditLineConstants[_id].idealCollateralRatio,
            'CreditLine: Collateral ratio is higher than ideal value'
        );

        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        address _lender = creditLineConstants[_id].lender;
        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);
        address _borrowAsset = creditLineConstants[_id].borrowAsset;

        creditLineVariables[_id].status = CreditLineStatus.LIQUIDATED;

        if (creditLineConstants[_id].autoLiquidation && _lender != msg.sender) {
            uint256 _borrowTokens = _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens);
            if (_borrowAsset == address(0)) {
                uint256 _returnETH = msg.value.sub(_borrowTokens, 'Insufficient ETH to liquidate');
                if (_returnETH != 0) {
                    (bool success, ) = msg.sender.call{value: _returnETH}('');
                    require(success, 'Transfer fail');
                }
            } else {
                IERC20(_borrowAsset).safeTransferFrom(msg.sender, _lender, _borrowTokens);
            }
        }

        _transferCollateral(_id, _collateralAsset, _totalCollateralTokens, _toSavingsAccount);

        emit CreditLineLiquidated(_id, msg.sender);
    }

    /**
     * @notice used to calculate the borrow tokens necessary for liquidator to liquidate
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @param _id identifier for the credit line
     * @return borrow tokens necessary for liquidator to liquidate
     */
    function borrowTokensToLiquidate(uint256 _id) external returns (uint256) {
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);
        address _borrowAsset = creditLineConstants[_id].borrowAsset;

        return _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens);
    }

    function _borrowTokensToLiquidate(
        address _borrowAsset,
        address _collateralAsset,
        uint256 _totalCollateralTokens
    ) internal view returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(_borrowAsset, _collateralAsset);
        uint256 _borrowTokens = (
            _totalCollateralTokens.mul(uint256(10**30).sub(liquidatorRewardFraction)).div(10**30).mul(_ratioOfPrices).div(10**_decimals)
        );

        return _borrowTokens;
    }

    receive() external payable {
        require(msg.sender == savingsAccount, 'CreditLine::receive invalid transaction');
    }
}
.]

Let's

[2024-22-08 11:43:02 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol'; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/utils/ReentrancyGuard.sol'; import '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol'; import '../interfaces/IPriceOracle.sol'; import '../interfaces/IYield.sol'; import '../interfaces/ISavingsAccount.sol'; import '../SavingsAccount/SavingsAccountUtil.sol'; import '../interfaces/IStrategyRegistry.sol'; /  * @title Credit Line contract with Methods related to credit Line  * @notice Implements the functions related to Credit Line  * @author Sublime  / contract CreditLine is ReentrancyGuard, OwnableUpgradeable {     using SafeERC20 for IERC20;     using SafeMath for uint256; enum CreditLineStatus {     NOT_CREATED,     REQUESTED,     ACTIVE,     CLOSED,     CANCELLED,     LIQUIDATED }  /**  * @notice counter that tracks the number of credit lines created  * @dev used to create unique identifier for credit lines  **/ uint256 public creditLineCounter;  uint256 constant YEAR_IN_SECONDS = 365 days;  struct CreditLineVariables {     CreditLineStatus status;     uint256 principal;     uint256 totalInterestRepaid;     uint256 lastPrincipalUpdateTime;     uint256 interestAccruedTillLastPrincipalUpdate; }  struct CreditLineConstants {     address lender;     address borrower;     uint256 borrowLimit;     uint256 idealCollateralRatio;     uint256 borrowRate;     address borrowAsset;     address collateralAsset;     bool autoLiquidation;     bool requestByLender; } /**  * @notice stores the collateral shares in a credit line per strategy  * @dev creditLineId =&gt; Strategy =&gt; collateralShares  **/ mapping(uint256 =&gt; mapping(address =&gt; uint256)) public collateralShareInStrategy;  /**  * @notice stores the variables to maintain a credit line  **/ mapping(uint256 =&gt; CreditLineVariables) public creditLineVariables;  /**  * @notice stores the constants related to a credit line  **/ mapping(uint256 =&gt; CreditLineConstants) public creditLineConstants;  /**  * @notice stores the address of savings account contract  **/ address public savingsAccount;  /**  * @notice stores the address of price oracle contract  **/ address public priceOracle;  /**  * @notice stores the address of strategy registry contract  **/ address public strategyRegistry;  /**  * @notice stores the address of default strategy  **/ address public defaultStrategy;  /**  * @notice stores the fraction of borrowed amount charged as fee by protocol  * @dev it is multiplied by 10**30  **/ uint256 public protocolFeeFraction;  /**  * @notice address where protocol fee is collected  **/ address public protocolFeeCollector;  /**  * @notice stores the fraction of amount liquidated given as reward to liquidator  * @dev it is multiplied by 10**30  **/ uint256 public liquidatorRewardFraction; /**  * @dev checks if Credit Line exists  * @param _id identifier for the credit line  **/ modifier ifCreditLineExists(uint256 _id) {     require(creditLineVariables[_id].status != CreditLineStatus.NOT_CREATED, 'Credit line does not exist');     _; }  /**  * @dev checks if called by credit Line Borrower  * @param _id creditLine identifier  **/ modifier onlyCreditLineBorrower(uint256 _id) {     require(creditLineConstants[_id].borrower == msg.sender, 'Only credit line Borrower can access');     _; }  /**  * @dev checks if called by credit Line Lender  * @param _id creditLine identifier  **/ modifier onlyCreditLineLender(uint256 _id) {     require(creditLineConstants[_id].lender == msg.sender, 'Only credit line Lender can access');     _; }  /**  * @notice emitted when a collateral is deposited into credit line  * @param id id of the credit line  * @param amount amount of collateral deposited  * @param strategy address of the strategy into which collateral is deposited  */ event CollateralDeposited(uint256 indexed id, uint256 amount, address indexed strategy);  /**  * @notice emitted when collateral is withdrawn from credit line  * @param id id of the credit line  * @param amount amount of collateral withdrawn  */ event CollateralWithdrawn(uint256 indexed id, uint256 amount);  /**  * @notice emitted when a request for new credit line is placed  * @param id id of the credit line for which request was made  * @param lender address of the lender for credit line  * @param borrower address of the borrower for credit line  */ event CreditLineRequested(uint256 indexed id, address indexed lender, address indexed borrower);  /**  * @notice emitted when a credit line is liquidated  * @param id id of the credit line which is liquidated  * @param liquidator address of the liquidator  */ event CreditLineLiquidated(uint256 indexed id, address indexed liquidator);  /**  * @notice emitted when tokens are borrowed from credit line  * @param id id of the credit line from which tokens are borrowed  * @param borrowAmount amount of tokens borrowed  */ event BorrowedFromCreditLine(uint256 indexed id, uint256 borrowAmount);  /**  * @notice emitted when credit line is accepted  * @param id id of the credit line that was accepted  */ event CreditLineAccepted(uint256 indexed id);  /**  * @notice emitted when credit line is completely repaid and reset  * @param id id of the credit line that is reset  */ event CreditLineReset(uint256 indexed id);  /**  * @notice emitted when the credit line is partially repaid  * @param id id of the credit line  * @param repayAmount amount repaid  */ event PartialCreditLineRepaid(uint256 indexed id, uint256 repayAmount);  /**  * @notice emitted when the credit line is completely repaid  * @param id id of the credit line  * @param repayAmount amount repaid  */ event CompleteCreditLineRepaid(uint256 indexed id, uint256 repayAmount);  /**  * @notice emitted when the credit line is closed by one of the parties of credit line  * @param id id of the credit line  */ event CreditLineClosed(uint256 indexed id);  /**  * @notice emitted when default strategy for the credit line is updated  * @param defaultStrategy address of the strategy contract that is used as default by credit lines  */ event DefaultStrategyUpdated(address indexed defaultStrategy);  /**  * @notice emitted when the price oracle is updated  * @param priceOracle address of the updated price oracle  */ event PriceOracleUpdated(address indexed priceOracle);  /**  * @notice emitted when the savings account address is updated  * @param savingsAccount address of the updated savingsAccount  */ event SavingsAccountUpdated(address indexed savingsAccount);  /**  * @notice emitted when strategy registry address is updated  * @param strategyRegistry address of the updated strategy registry  */ event StrategyRegistryUpdated(address indexed strategyRegistry);  /**  * @notice emitted when fee that protocol charges for credit line is updated  * @param updatedProtocolFee updated value of protocolFeeFraction  */ event ProtocolFeeFractionUpdated(uint256 updatedProtocolFee);  /**  * @notice emitted when address which receives fee that protocol changes for pools is updated  * @param updatedProtocolFeeCollector updated value of protocolFeeCollector  */ event ProtocolFeeCollectorUpdated(address indexed updatedProtocolFeeCollector);  /**  * @notice emitted when liquidatorRewardFraction is updated  * @param liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator  */ event LiquidationRewardFractionUpdated(uint256 liquidatorRewardFraction);  /**  * @notice used to initialize the contract  * @dev can only be called once during the life cycle of the contract  * @param _defaultStrategy default strategy used in credit lines  * @param _priceOracle address of the priceOracle  * @param _savingsAccount address of  the savings account contract  * @param _strategyRegistry address of the strategy registry contract  * @param _owner address of owner who can change global variables  * @param _protocolFeeFraction fraction of the fee charged by protocol  * @param _protocolFeeCollector address to which protocol fee is charged to  * @param _liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator  */ function initialize(     address _defaultStrategy,     address _priceOracle,     address _savingsAccount,     address _strategyRegistry,     address _owner,     uint256 _protocolFeeFraction,     address _protocolFeeCollector,     uint256 _liquidatorRewardFraction ) external initializer {     OwnableUpgradeable.__Ownable_init();     OwnableUpgradeable.transferOwnership(_owner);      _updateDefaultStrategy(_defaultStrategy);     _updatePriceOracle(_priceOracle);     _updateSavingsAccount(_savingsAccount);     _updateStrategyRegistry(_strategyRegistry);     _updateProtocolFeeFraction(_protocolFeeFraction);     _updateProtocolFeeCollector(_protocolFeeCollector);     _updateLiquidatorRewardFraction(_liquidatorRewardFraction); }  /**  * @notice used to update the default strategy  * @dev can only be updated by owner  * @param _defaultStrategy address of the updated default strategy  */ function updateDefaultStrategy(address _defaultStrategy) external onlyOwner {     _updateDefaultStrategy(_defaultStrategy); }  function _updateDefaultStrategy(address _defaultStrategy) internal {     defaultStrategy = _defaultStrategy;     emit DefaultStrategyUpdated(_defaultStrategy); }  /**  * @notice used to update the price oracle  * @dev can only be updated by owner  * @param _priceOracle address of the updated price oracle  */ function updatePriceOracle(address _priceOracle) external onlyOwner {     _updatePriceOracle(_priceOracle); }  function _updatePriceOracle(address _priceOracle) internal {     priceOracle = _priceOracle;     emit PriceOracleUpdated(_priceOracle); }  /**  * @notice used to update the savings account address  * @dev can only be updated by owner  * @param _savingsAccount address of the updated savings account  */ function updateSavingsAccount(address _savingsAccount) external onlyOwner {     _updateSavingsAccount(_savingsAccount); }  function _updateSavingsAccount(address _savingsAccount) internal {     savingsAccount = _savingsAccount;     emit SavingsAccountUpdated(_savingsAccount); }  /**  * @notice used to update the protocol fee fraction  * @dev can only be updated by owner  * @param _protocolFee fraction of the borrower amount collected as protocol fee  */ function updateProtocolFeeFraction(uint256 _protocolFee) external onlyOwner {     _updateProtocolFeeFraction(_protocolFee); }  function _updateProtocolFeeFraction(uint256 _protocolFee) internal {     protocolFeeFraction = _protocolFee;     emit ProtocolFeeFractionUpdated(_protocolFee); }  /**  * @notice used to update the protocol fee collector  * @dev can only be updated by owner  * @param _protocolFeeCollector address in which protocol fee is collected  */ function updateProtocolFeeCollector(address _protocolFeeCollector) external onlyOwner {     _updateProtocolFeeCollector(_protocolFeeCollector); }  function _updateProtocolFeeCollector(address _protocolFeeCollector) internal {     require(_protocolFeeCollector != address(0), 'cant be 0 address');     protocolFeeCollector = _protocolFeeCollector;     emit ProtocolFeeCollectorUpdated(_protocolFeeCollector); }  /**  * @notice used to update the strategy registry address  * @dev can only be updated by owner  * @param _strategyRegistry address of the updated strategy registry  */ function updateStrategyRegistry(address _strategyRegistry) external onlyOwner {     _updateStrategyRegistry(_strategyRegistry); }  function _updateStrategyRegistry(address _strategyRegistry) internal {     require(_strategyRegistry != address(0), 'CL::I zero address');     strategyRegistry = _strategyRegistry;     emit StrategyRegistryUpdated(_strategyRegistry); }  /**  * @notice used to update the liquidatorRewardFraction  * @dev can only be updated by owner  * @param _rewardFraction fraction of liquidated amount given to liquidator as reward  */ function updateLiquidatorRewardFraction(uint256 _rewardFraction) external onlyOwner {     _updateLiquidatorRewardFraction(_rewardFraction); }  function _updateLiquidatorRewardFraction(uint256 _rewardFraction) internal {     require(_rewardFraction &lt;= 10**30, 'Fraction has to be less than 1');     liquidatorRewardFraction = _rewardFraction;     emit LiquidationRewardFractionUpdated(_rewardFraction); }  /**  * @dev Used to Calculate Interest Per second on given principal and Interest rate  * @param _principal principal Amount for which interest has to be calculated.  * @param _borrowRate It is the Interest Rate at which Credit Line is approved  * @return interest per second for the given parameters  */ function calculateInterest(     uint256 _principal,     uint256 _borrowRate,     uint256 _timeElapsed ) public pure returns (uint256) {     uint256 _interest = _principal.mul(_borrowRate).mul(_timeElapsed).div(10**30).div(YEAR_IN_SECONDS);      return _interest; }  /**  * @dev Used to calculate interest accrued since last repayment  * @param _id identifier for the credit line  * @return interest accrued over current borrowed amount since last repayment  */  function calculateInterestAccrued(uint256 _id) public view returns (uint256) {     uint256 _lastPrincipalUpdateTime = creditLineVariables[_id].lastPrincipalUpdateTime;     if (_lastPrincipalUpdateTime == 0) return 0;     uint256 _timeElapsed = (block.timestamp).sub(_lastPrincipalUpdateTime);     uint256 _interestAccrued = calculateInterest(creditLineVariables[_id].principal, creditLineConstants[_id].borrowRate, _timeElapsed);     return _interestAccrued; }  /**  * @dev Used to calculate current debt of borrower against a credit line.  * @param _id identifier for the credit line  * @return current debt of borrower  */ function calculateCurrentDebt(uint256 _id) public view returns (uint256) {     uint256 _interestAccrued = calculateInterestAccrued(_id);     uint256 _currentDebt = (creditLineVariables[_id].principal)         .add(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate)         .add(_interestAccrued)         .sub(creditLineVariables[_id].totalInterestRepaid);     return _currentDebt; }  /**  * @notice used to calculate amount that can be borrowed by the borrower  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view.         borrowableAmount changes per block as interest changes per block.  * @param _id identifier for the credit line  * @return amount that can be borrowed from the credit line  */ function calculateBorrowableAmount(uint256 _id) public returns (uint256) {     CreditLineStatus _status = creditLineVariables[_id].status;     require(         _status == CreditLineStatus.ACTIVE || _status == CreditLineStatus.REQUESTED,         'CreditLine: Cannot only if credit line ACTIVE or REQUESTED'     );     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(         creditLineConstants[_id].collateralAsset,         creditLineConstants[_id].borrowAsset     );      uint256 _totalCollateralToken = calculateTotalCollateralTokens(_id);      uint256 _currentDebt = calculateCurrentDebt(_id);      uint256 _maxPossible = _totalCollateralToken.mul(_ratioOfPrices).div(creditLineConstants[_id].idealCollateralRatio).mul(10**30).div(         10**_decimals     );      uint256 _borrowLimit = creditLineConstants[_id].borrowLimit;      if (_maxPossible &gt; _borrowLimit) {         _maxPossible = _borrowLimit;     }     if (_maxPossible &gt; _currentDebt) {         return _maxPossible.sub(_currentDebt);     }     return 0; }  function updateinterestAccruedTillLastPrincipalUpdate(uint256 _id) internal {     require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');      uint256 _interestAccrued = calculateInterestAccrued(_id);     uint256 _newInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(_interestAccrued);     creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _newInterestAccrued; }  function _depositCollateralFromSavingsAccount(     uint256 _id,     uint256 _amount,     address _sender ) internal {     address _collateralAsset = creditLineConstants[_id].collateralAsset;     address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();     ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);     uint256 _activeAmount;      for (uint256 _index = 0; _index &lt; _strategyList.length; _index++) {         address _strategy = _strategyList[_index];         uint256 _liquidityShares = _savingsAccount.balanceInShares(_sender, _collateralAsset, _strategy);         if (_liquidityShares == 0 || _strategyList[_index] == address(0)) {             continue;         }         uint256 _tokenInStrategy = _liquidityShares;         _tokenInStrategy = IYield(_strategy).getTokensForShares(_liquidityShares, _collateralAsset);          uint256 _tokensToTransfer = _tokenInStrategy;         if (_activeAmount.add(_tokenInStrategy) &gt;= _amount) {             _tokensToTransfer = (_amount.sub(_activeAmount));         }         _activeAmount = _activeAmount.add(_tokensToTransfer);         _savingsAccount.transferFrom(_tokensToTransfer, _collateralAsset, _strategy, _sender, address(this));          collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(             _liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy)         );          if (_amount == _activeAmount) {             return;         }     }     revert('CreditLine::_depositCollateralFromSavingsAccount - Insufficient balance'); }  /**  * @notice used to request a credit line either by borrower or lender  * @param _requestTo Address to which creditLine is requested,                      if borrower creates request then lender address and                      if lender creates then borrower address  * @param _borrowLimit maximum borrow amount in a credit line  * @param _borrowRate Interest Rate at which credit Line is requested  * @param _autoLiquidation if true, anyone can liquidate loan, otherwise only lender  * @param _collateralRatio ratio of the collateral to the debt below which credit line can be liquidated  * @param _borrowAsset address of the token to be borrowed  * @param _collateralAsset address of the token provided as collateral  * @param _requestAsLender if true, lender is placing request, otherwise borrower  * @return identifier for the credit line  */  function request(     address _requestTo,     uint256 _borrowLimit,     uint256 _borrowRate,     bool _autoLiquidation,     uint256 _collateralRatio,     address _borrowAsset,     address _collateralAsset,     bool _requestAsLender ) external returns (uint256) {     require(_borrowAsset != _collateralAsset, 'R: cant borrow lent token');     require(IPriceOracle(priceOracle).doesFeedExist(_borrowAsset, _collateralAsset), 'R: No price feed');      address _lender = _requestTo;     address _borrower = msg.sender;     if (_requestAsLender) {         _lender = msg.sender;         _borrower = _requestTo;     }      uint256 _id = _createRequest(         _lender,         _borrower,         _borrowLimit,         _borrowRate,         _autoLiquidation,         _collateralRatio,         _borrowAsset,         _collateralAsset,         _requestAsLender     );      emit CreditLineRequested(_id, _lender, _borrower);     return _id; }  function _createRequest(     address _lender,     address _borrower,     uint256 _borrowLimit,     uint256 _borrowRate,     bool _autoLiquidation,     uint256 _collateralRatio,     address _borrowAsset,     address _collateralAsset,     bool _requestByLender ) internal returns (uint256) {     require(_lender != _borrower, 'Lender and Borrower cannot be same addresses');     uint256 _id = creditLineCounter + 1;     creditLineCounter = _id;     creditLineVariables[_id].status = CreditLineStatus.REQUESTED;     creditLineConstants[_id].borrower = _borrower;     creditLineConstants[_id].lender = _lender;     creditLineConstants[_id].borrowLimit = _borrowLimit;     creditLineConstants[_id].autoLiquidation = _autoLiquidation;     creditLineConstants[_id].idealCollateralRatio = _collateralRatio;     creditLineConstants[_id].borrowRate = _borrowRate;     creditLineConstants[_id].borrowAsset = _borrowAsset;     creditLineConstants[_id].collateralAsset = _collateralAsset;     creditLineConstants[_id].requestByLender = _requestByLender;     return _id; }  /**  * @notice used to accept a credit line  * @dev if borrower places request, lender can accept and vice versa  * @param _id identifier for the credit line  */ function accept(uint256 _id) external {     require(         creditLineVariables[_id].status == CreditLineStatus.REQUESTED,         'CreditLine::acceptCreditLineLender - CreditLine is already accepted'     );     bool _requestByLender = creditLineConstants[_id].requestByLender;     require(         (msg.sender == creditLineConstants[_id].borrower &amp;&amp; _requestByLender) ||             (msg.sender == creditLineConstants[_id].lender &amp;&amp; !_requestByLender),         "Only Borrower or Lender who hasn't requested can accept"     );     creditLineVariables[_id].status = CreditLineStatus.ACTIVE;     emit CreditLineAccepted(_id); }  /**  * @notice used to deposit collateral into the credit line  * @dev collateral tokens have to be approved in savingsAccount or token contract(unless ether).         If transferred from savings account, the tokens are transferred from strategies in the          order prespecified in strategy registry  * @param _id identifier for the credit line  * @param _amount amount of collateral being deposited  * @param _strategy strategy to which collateral is to be deposited in case transfer is not from savings account  * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount                              otherwise direct from collateral token contract  */ function depositCollateral(     uint256 _id,     uint256 _amount,     address _strategy,     bool _fromSavingsAccount ) external payable nonReentrant ifCreditLineExists(_id) {     require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine not active');     _depositCollateral(_id, _amount, _strategy, _fromSavingsAccount);     emit CollateralDeposited(_id, _amount, _strategy); }  function _depositCollateral(     uint256 _id,     uint256 _amount,     address _strategy,     bool _fromSavingsAccount ) internal {     require(creditLineConstants[_id].lender != msg.sender, 'lender cant deposit collateral');     if (_fromSavingsAccount) {         _depositCollateralFromSavingsAccount(_id, _amount, msg.sender);     } else {         address _collateralAsset = creditLineConstants[_id].collateralAsset;         ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);         if (_collateralAsset == address(0)) {             require(msg.value == _amount, "CreditLine::_depositCollateral - value to transfer doesn't match argument");         } else {             IERC20(_collateralAsset).safeTransferFrom(msg.sender, address(this), _amount);             IERC20(_collateralAsset).approve(_strategy, _amount);         }         uint256 _sharesReceived = _savingsAccount.deposit{value: msg.value}(_amount, _collateralAsset, _strategy, address(this));         collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(_sharesReceived);     } }  function _withdrawBorrowAmount(     address _asset,     uint256 _amountInTokens,     address _lender ) internal {     address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();     ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);     uint256 _activeAmount;     for (uint256 _index = 0; _index &lt; _strategyList.length; _index++) {         if (_strategyList[_index] == address(0)) {             continue;         }         uint256 _liquidityShares = _savingsAccount.balanceInShares(_lender, _asset, _strategyList[_index]);         if (_liquidityShares != 0) {             uint256 tokenInStrategy = _liquidityShares;             tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);             uint256 _tokensToTransfer = tokenInStrategy;             if (_activeAmount.add(tokenInStrategy) &gt;= _amountInTokens) {                 _tokensToTransfer = (_amountInTokens.sub(_activeAmount));             }             _activeAmount = _activeAmount.add(_tokensToTransfer);             _savingsAccount.withdrawFrom(_tokensToTransfer, _asset, _strategyList[_index], _lender, address(this), false);             if (_activeAmount == _amountInTokens) {                 return;             }         }     }     require(_activeAmount == _amountInTokens, 'insufficient balance'); }  /**  * @notice used to borrow tokens from credit line by borrower  * @dev only borrower can call this function. Amount that can actually be borrowed is          min(amount based on borrowLimit, allowance to creditLine contract, balance of lender)  * @param _id identifier for the credit line  * @param _amount amount of tokens to borrow  */ function borrow(uint256 _id, uint256 _amount) external payable nonReentrant onlyCreditLineBorrower(_id) {     require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');     uint256 _borrowableAmount = calculateBorrowableAmount(_id);     require(_amount &lt;= _borrowableAmount, "CreditLine::borrow - The current collateral ratio doesn't allow to withdraw the amount");     address _borrowAsset = creditLineConstants[_id].borrowAsset;     address _lender = creditLineConstants[_id].lender;      updateinterestAccruedTillLastPrincipalUpdate(_id);     creditLineVariables[_id].principal = creditLineVariables[_id].principal.add(_amount);     creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;      uint256 _tokenDiffBalance;     if (_borrowAsset != address(0)) {         uint256 _balanceBefore = IERC20(_borrowAsset).balanceOf(address(this));         _withdrawBorrowAmount(_borrowAsset, _amount, _lender);         uint256 _balanceAfter = IERC20(_borrowAsset).balanceOf(address(this));         _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);     } else {         uint256 _balanceBefore = address(this).balance;         _withdrawBorrowAmount(_borrowAsset, _amount, _lender);         uint256 _balanceAfter = address(this).balance;         _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);     }     uint256 _protocolFee = _tokenDiffBalance.mul(protocolFeeFraction).div(10**30);     _tokenDiffBalance = _tokenDiffBalance.sub(_protocolFee);      if (_borrowAsset == address(0)) {         (bool feeSuccess, ) = protocolFeeCollector.call{value: _protocolFee}('');         require(feeSuccess, 'Transfer fail');         (bool success, ) = msg.sender.call{value: _tokenDiffBalance}('');         require(success, 'Transfer fail');     } else {         IERC20(_borrowAsset).safeTransfer(protocolFeeCollector, _protocolFee);         IERC20(_borrowAsset).safeTransfer(msg.sender, _tokenDiffBalance);     }     emit BorrowedFromCreditLine(_id, _tokenDiffBalance); }  function _repayFromSavingsAccount(     uint256 _amount,     address _asset,     address _lender ) internal {     address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();     ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);     uint256 _activeAmount;      for (uint256 _index = 0; _index &lt; _strategyList.length; _index++) {         if (_strategyList[_index] == address(0)) {             continue;         }         uint256 _liquidityShares = _savingsAccount.balanceInShares(msg.sender, _asset, _strategyList[_index]);         if (_liquidityShares == 0) {             continue;         }         uint256 _tokenInStrategy = _liquidityShares;         _tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);          uint256 _tokensToTransfer = _tokenInStrategy;         if (_activeAmount.add(_tokenInStrategy) &gt;= _amount) {             _tokensToTransfer = (_amount.sub(_activeAmount));         }         _activeAmount = _activeAmount.add(_tokensToTransfer);         _savingsAccount.transferFrom(_tokensToTransfer, _asset, _strategyList[_index], msg.sender, _lender);          if (_amount == _activeAmount) {             return;         }     }     revert('CreditLine::_repayFromSavingsAccount - Insufficient balance'); }  function _repay(     uint256 _id,     uint256 _amount,     bool _fromSavingsAccount,     uint256 _principalPaid ) internal {     ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);     address _defaultStrategy = defaultStrategy;     address _borrowAsset = creditLineConstants[_id].borrowAsset;     address _lender = creditLineConstants[_id].lender;     if (!_fromSavingsAccount) {         if (_borrowAsset == address(0)) {             require(msg.value == _amount, 'creditLine::repay - Ether sent not equal to repay amount');             _savingsAccount.deposit{value: _amount}(_amount, _borrowAsset, _defaultStrategy, _lender);         } else {             IERC20(_borrowAsset).safeTransferFrom(msg.sender, address(this), _amount);             IERC20(_borrowAsset).approve(_defaultStrategy, _amount);             _savingsAccount.deposit(_amount, _borrowAsset, _defaultStrategy, _lender);         }     } else {         _repayFromSavingsAccount(_amount, _borrowAsset, _lender);     }     if (_principalPaid != 0) {         _savingsAccount.increaseAllowanceToCreditLine(_principalPaid, _borrowAsset, _lender);     } }  /**  * @notice used to repay interest and principal to credit line. Interest has to be repaid before repaying principal  * @dev partial repayments possible  * @param _id identifier for the credit line  * @param _amount amount being repaid  * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount                              otherwise direct from collateral token contract  */ function repay(     uint256 _id,     uint256 _amount,     bool _fromSavingsAccount ) external payable nonReentrant {     require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');     require(creditLineConstants[_id].lender != msg.sender, 'Lender cant repay');      uint256 _interestSincePrincipalUpdate = calculateInterestAccrued(_id);     uint256 _totalInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(         _interestSincePrincipalUpdate     );     uint256 _interestToPay = _totalInterestAccrued.sub(creditLineVariables[_id].totalInterestRepaid);     uint256 _totalCurrentDebt = _interestToPay.add(creditLineVariables[_id].principal);     uint256 _principalPaid = 0;      if (_amount &gt;= _totalCurrentDebt) {         _amount = _totalCurrentDebt;         emit CompleteCreditLineRepaid(_id, _amount);     } else {         emit PartialCreditLineRepaid(_id, _amount);     }      if (_amount &gt; _interestToPay) {         creditLineVariables[_id].principal = _totalCurrentDebt.sub(_amount);         creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _totalInterestAccrued;         creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;         creditLineVariables[_id].totalInterestRepaid = _totalInterestAccrued;         _principalPaid = _amount.sub(_interestToPay);     } else {         creditLineVariables[_id].totalInterestRepaid = creditLineVariables[_id].totalInterestRepaid.add(_amount);     }      _repay(_id, _amount, _fromSavingsAccount, _principalPaid);      if (creditLineVariables[_id].principal == 0) {         _resetCreditLine(_id);     } }  function _resetCreditLine(uint256 _id) internal {     creditLineVariables[_id].lastPrincipalUpdateTime = 0;     creditLineVariables[_id].totalInterestRepaid = 0;     creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = 0;     emit CreditLineReset(_id); }  /**  * @dev used to close credit line by borrower or lender  * @param _id identifier for the credit line  */ function close(uint256 _id) external ifCreditLineExists(_id) {     require(         msg.sender == creditLineConstants[_id].borrower || msg.sender == creditLineConstants[_id].lender,         'CreditLine: Permission denied while closing Line of credit'     );     require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: Credit line should be active.');     require(creditLineVariables[_id].principal == 0, 'CreditLine: Cannot be closed since not repaid.');     require(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate == 0, 'CreditLine: Cannot be closed since not repaid.');     creditLineVariables[_id].status = CreditLineStatus.CLOSED;     emit CreditLineClosed(_id); }  /**  * @notice used to calculate the current collateral ratio  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view.         Interest is also considered while calculating debt  * @param _id identifier for the credit line  * @return collateral ratio multiplied by 10**30 to retain precision  */ function calculateCurrentCollateralRatio(uint256 _id) public ifCreditLineExists(_id) returns (uint256) {     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(         creditLineConstants[_id].collateralAsset,         creditLineConstants[_id].borrowAsset     );      uint256 currentDebt = calculateCurrentDebt(_id);     uint256 currentCollateralRatio = calculateTotalCollateralTokens(_id).mul(_ratioOfPrices).div(currentDebt).mul(10**30).div(         10**_decimals     );      return currentCollateralRatio; }  /**  * @notice used to calculate the total collateral tokens  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view  * @param _id identifier for the credit line  * @return _amount total collateral tokens deposited into the credit line  */ function calculateTotalCollateralTokens(uint256 _id) public returns (uint256 _amount) {     address _collateralAsset = creditLineConstants[_id].collateralAsset;     address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();     uint256 _liquidityShares;     for (uint256 index = 0; index &lt; _strategyList.length; index++) {         if (_strategyList[index] == address(0)) {             continue;         }         _liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];         uint256 _tokenInStrategy = _liquidityShares;         _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(_liquidityShares, _collateralAsset);          _amount = _amount.add(_tokenInStrategy);     } }  /**  * @notice used to withdraw any excess collateral  * @dev collateral can't be withdraw if collateralRatio goes below the ideal value. Only borrower can withdraw  * @param _id identifier for the credit line  * @param _amount amount of collateral to withdraw  * @param _toSavingsAccount if true, tokens are transferred from savingsAccount                              otherwise direct from collateral token contract  */ function withdrawCollateral(     uint256 _id,     uint256 _amount,     bool _toSavingsAccount ) external nonReentrant onlyCreditLineBorrower(_id) {     uint256 _withdrawableCollateral = withdrawableCollateral(_id);     require(_amount &lt;= _withdrawableCollateral, 'Collateral ratio cant go below ideal');     address _collateralAsset = creditLineConstants[_id].collateralAsset;     _transferCollateral(_id, _collateralAsset, _amount, _toSavingsAccount);     emit CollateralWithdrawn(_id, _amount); }  /**  * @notice used to calculate the collateral that can be withdrawn  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view  * @param _id identifier for the credit line  * @return total collateral withdrawable by borrower  */ function withdrawableCollateral(uint256 _id) public returns (uint256) {     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(         creditLineConstants[_id].collateralAsset,         creditLineConstants[_id].borrowAsset     );      uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);     uint256 _currentDebt = calculateCurrentDebt(_id);      uint256 _collateralNeeded = _currentDebt         .mul(creditLineConstants[_id].idealCollateralRatio)         .div(_ratioOfPrices)         .mul(10**_decimals)         .div(10**30);      if (_collateralNeeded &gt;= _totalCollateralTokens) {         return 0;     }     return _totalCollateralTokens.sub(_collateralNeeded); }  function _transferCollateral(     uint256 _id,     address _asset,     uint256 _amountInTokens,     bool _toSavingsAccount ) internal {     address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();     uint256 _activeAmount;     for (uint256 index = 0; index &lt; _strategyList.length; index++) {         uint256 liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];         if (liquidityShares == 0 || _strategyList[index] == address(0)) {             continue;         }         uint256 _tokenInStrategy = liquidityShares;         _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(liquidityShares, _asset);         uint256 _tokensToTransfer = _tokenInStrategy;         if (_activeAmount.add(_tokenInStrategy) &gt; _amountInTokens) {             _tokensToTransfer = _amountInTokens.sub(_activeAmount);             liquidityShares = liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy);         }         _activeAmount = _activeAmount.add(_tokensToTransfer);         collateralShareInStrategy[_id][_strategyList[index]] = collateralShareInStrategy[_id][_strategyList[index]].sub(             liquidityShares         );         if (_toSavingsAccount) {             ISavingsAccount(savingsAccount).transfer(_tokensToTransfer, _asset, _strategyList[index], msg.sender);         } else {             ISavingsAccount(savingsAccount).withdraw(_tokensToTransfer, _asset, _strategyList[index], msg.sender, false);         }          if (_activeAmount == _amountInTokens) {             return;         }     }     revert('insufficient collateral'); }  /**  * @notice used to liquidate credit line in case collateral ratio goes below the threshold  * @dev if lender liquidates, then collateral is directly transferred.          If autoLiquidation is true, anyone can liquidate by providing enough borrow tokens  * @param _id identifier for the credit line  * @param _toSavingsAccount if true, tokens are transferred from savingsAccount                              otherwise direct from collateral token contract  */ function liquidate(uint256 _id, bool _toSavingsAccount) external payable nonReentrant {     require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: Credit line should be active.');     require(creditLineVariables[_id].principal != 0, 'CreditLine: cannot liquidate if principal is 0');      uint256 currentCollateralRatio = calculateCurrentCollateralRatio(_id);     require(         currentCollateralRatio &lt; creditLineConstants[_id].idealCollateralRatio,         'CreditLine: Collateral ratio is higher than ideal value'     );      address _collateralAsset = creditLineConstants[_id].collateralAsset;     address _lender = creditLineConstants[_id].lender;     uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);     address _borrowAsset = creditLineConstants[_id].borrowAsset;      creditLineVariables[_id].status = CreditLineStatus.LIQUIDATED;      if (creditLineConstants[_id].autoLiquidation &amp;&amp; _lender != msg.sender) {         uint256 _borrowTokens = _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens);         if (_borrowAsset == address(0)) {             uint256 _returnETH = msg.value.sub(_borrowTokens, 'Insufficient ETH to liquidate');             if (_returnETH != 0) {                 (bool success, ) = msg.sender.call{value: _returnETH}('');                 require(success, 'Transfer fail');             }         } else {             IERC20(_borrowAsset).safeTransferFrom(msg.sender, _lender, _borrowTokens);         }     }      _transferCollateral(_id, _collateralAsset, _totalCollateralTokens, _toSavingsAccount);      emit CreditLineLiquidated(_id, msg.sender); }  /**  * @notice used to calculate the borrow tokens necessary for liquidator to liquidate  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view  * @param _id identifier for the credit line  * @return borrow tokens necessary for liquidator to liquidate  */ function borrowTokensToLiquidate(uint256 _id) external returns (uint256) {     address _collateralAsset = creditLineConstants[_id].collateralAsset;     uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);     address _borrowAsset = creditLineConstants[_id].borrowAsset;      return _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens); }  function _borrowTokensToLiquidate(     address _borrowAsset,     address _collateralAsset,     uint256 _totalCollateralTokens ) internal view returns (uint256) {     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(_borrowAsset, _collateralAsset);     uint256 _borrowTokens = (         _totalCollateralTokens.mul(uint256(10**30).sub(liquidatorRewardFraction)).div(10**30).mul(_ratioOfPrices).div(10**_decimals)     );      return _borrowTokens; }  receive() external payable {     require(msg.sender == savingsAccount, 'CreditLine::receive invalid transaction'); }  } |
| **assistant_role_name** | Chief Executive Officer |
| **user_role_name** | Counselor |
| **phase_prompt** | Here is a conversation between two roles: {conversations} {question} |
| **phase_name** | Reflection |
| **assistant_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Counselor. Now, we share a common interest in collaborating to successfully complete a task assigned by a new customer. Your main responsibilities include asking what user and customer think and provide your valuable suggestions.  Here is a new customer's task: {task}. |
| **placeholders** | {'conversations': 'Security Analyst: We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.\nYou are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.\nYou can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites\nHere is a new customer\'s task: // SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\nimport \'@openzeppelin/contracts/token/ERC20/SafeERC20.sol\';\nimport \'@openzeppelin/contracts/math/SafeMath.sol\';\nimport \'@openzeppelin/contracts/utils/ReentrancyGuard.sol\';\nimport \'@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\';\nimport \'../interfaces/IPriceOracle.sol\';\nimport \'../interfaces/IYield.sol\';\nimport \'../interfaces/ISavingsAccount.sol\';\nimport \'../SavingsAccount/SavingsAccountUtil.sol\';\nimport \'../interfaces/IStrategyRegistry.sol\';\n/\n * @title Credit Line contract with Methods related to credit Line\n * @notice Implements the functions related to Credit Line\n * @author Sublime\n /\ncontract CreditLine is ReentrancyGuard, OwnableUpgradeable {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n    enum CreditLineStatus {\n        NOT_CREATED,\n        REQUESTED,\n        ACTIVE,\n        CLOSED,\n        CANCELLED,\n        LIQUIDATED\n    }\n    /\n     * @notice counter that tracks the number of credit lines created\n     * @dev used to create unique identifier for credit lines\n     /\n    uint256 public creditLineCounter;\n    uint256 constant YEAR_IN_SECONDS = 365 days;\n    struct CreditLineVariables {\n        CreditLineStatus status;\n        uint256 principal;\n        uint256 totalInterestRepaid;\n        uint256 lastPrincipalUpdateTime;\n        uint256 interestAccruedTillLastPrincipalUpdate;\n    }\n    struct CreditLineConstants {\n        address lender;\n        address borrower;\n        uint256 borrowLimit;\n        uint256 idealCollateralRatio;\n        uint256 borrowRate;\n        address borrowAsset;\n        address collateralAsset;\n        bool autoLiquidation;\n        bool requestByLender;\n    }\n    /\n     * @notice stores the collateral shares in a credit line per strategy\n     * @dev creditLineId =&gt; Strategy =&gt; collateralShares\n     /\n    mapping(uint256 =&gt; mapping(address =&gt; uint256)) public collateralShareInStrategy;\n    /\n     * @notice stores the variables to maintain a credit line\n     /\n    mapping(uint256 =&gt; CreditLineVariables) public creditLineVariables;\n    /\n     * @notice stores the constants related to a credit line\n     /\n    mapping(uint256 =&gt; CreditLineConstants) public creditLineConstants;\n    /\n     * @notice stores the address of savings account contract\n     /\n    address public savingsAccount;\n    /\n     * @notice stores the address of price oracle contract\n     /\n    address public priceOracle;\n    /\n     * @notice stores the address of strategy registry contract\n     /\n    address public strategyRegistry;\n    /\n     * @notice stores the address of default strategy\n     /\n    address public defaultStrategy;\n    /\n     * @notice stores the fraction of borrowed amount charged as fee by protocol\n     * @dev it is multiplied by 1030\n     /\n    uint256 public protocolFeeFraction;\n    /\n     * @notice address where protocol fee is collected\n     /\n    address public protocolFeeCollector;\n    /\n     * @notice stores the fraction of amount liquidated given as reward to liquidator\n     * @dev it is multiplied by 1030\n     /\n    uint256 public liquidatorRewardFraction;\n    /\n     * @dev checks if Credit Line exists\n     * @param _id identifier for the credit line\n     /\n    modifier ifCreditLineExists(uint256 id) {\n        require(creditLineVariables[_id].status != CreditLineStatus.NOT_CREATED, \'Credit line does not exist\');\n        ;\n    }\n    /\n     * @dev checks if called by credit Line Borrower\n     * @param _id creditLine identifier\n     /\n    modifier onlyCreditLineBorrower(uint256 id) {\n        require(creditLineConstants[_id].borrower == msg.sender, \'Only credit line Borrower can access\');\n        ;\n    }\n    /\n     * @dev checks if called by credit Line Lender\n     * @param _id creditLine identifier\n     /\n    modifier onlyCreditLineLender(uint256 id) {\n        require(creditLineConstants[_id].lender == msg.sender, \'Only credit line Lender can access\');\n        ;\n    }\n    /\n     * @notice emitted when a collateral is deposited into credit line\n     * @param id id of the credit line\n     * @param amount amount of collateral deposited\n     * @param strategy address of the strategy into which collateral is deposited\n     */\n    event CollateralDeposited(uint256 indexed id, uint256 amount, address indexed strategy);\n    /\n     * @notice emitted when collateral is withdrawn from credit line\n     * @param id id of the credit line\n     * @param amount amount of collateral withdrawn\n     /\n    event CollateralWithdrawn(uint256 indexed id, uint256 amount);\n    /\n     * @notice emitted when a request for new credit line is placed\n     * @param id id of the credit line for which request was made\n     * @param lender address of the lender for credit line\n     * @param borrower address of the borrower for credit line\n     /\n    event CreditLineRequested(uint256 indexed id, address indexed lender, address indexed borrower);\n    /\n     * @notice emitted when a credit line is liquidated\n     * @param id id of the credit line which is liquidated\n     * @param liquidator address of the liquidator\n     */\n    event CreditLineLiquidated(uint256 indexed id, address indexed liquidator);\n    /\n     * @notice emitted when tokens are borrowed from credit line\n     * @param id id of the credit line from which tokens are borrowed\n     * @param borrowAmount amount of tokens borrowed\n     /\n    event BorrowedFromCreditLine(uint256 indexed id, uint256 borrowAmount);\n    /\n     * @notice emitted when credit line is accepted\n     * @param id id of the credit line that was accepted\n     /\n    event CreditLineAccepted(uint256 indexed id);\n    /\n     * @notice emitted when credit line is completely repaid and reset\n     * @param id id of the credit line that is reset\n     */\n    event CreditLineReset(uint256 indexed id);\n    /\n     * @notice emitted when the credit line is partially repaid\n     * @param id id of the credit line\n     * @param repayAmount amount repaid\n     /\n    event PartialCreditLineRepaid(uint256 indexed id, uint256 repayAmount);\n    /\n     * @notice emitted when the credit line is completely repaid\n     * @param id id of the credit line\n     * @param repayAmount amount repaid\n     /\n    event CompleteCreditLineRepaid(uint256 indexed id, uint256 repayAmount);\n    /\n     * @notice emitted when the credit line is closed by one of the parties of credit line\n     * @param id id of the credit line\n     */\n    event CreditLineClosed(uint256 indexed id);\n    /\n     * @notice emitted when default strategy for the credit line is updated\n     * @param defaultStrategy address of the strategy contract that is used as default by credit lines\n     /\n    event DefaultStrategyUpdated(address indexed defaultStrategy);\n    /\n     * @notice emitted when the price oracle is updated\n     * @param priceOracle address of the updated price oracle\n     /\n    event PriceOracleUpdated(address indexed priceOracle);\n    /\n     * @notice emitted when the savings account address is updated\n     * @param savingsAccount address of the updated savingsAccount\n     */\n    event SavingsAccountUpdated(address indexed savingsAccount);\n    /\n     * @notice emitted when strategy registry address is updated\n     * @param strategyRegistry address of the updated strategy registry\n     /\n    event StrategyRegistryUpdated(address indexed strategyRegistry);\n    /\n     * @notice emitted when fee that protocol charges for credit line is updated\n     * @param updatedProtocolFee updated value of protocolFeeFraction\n     /\n    event ProtocolFeeFractionUpdated(uint256 updatedProtocolFee);\n    /\n     * @notice emitted when address which receives fee that protocol changes for pools is updated\n     * @param updatedProtocolFeeCollector updated value of protocolFeeCollector\n     */\n    event ProtocolFeeCollectorUpdated(address indexed updatedProtocolFeeCollector);\n    /\n     * @notice emitted when liquidatorRewardFraction is updated\n     * @param liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator\n     /\n    event LiquidationRewardFractionUpdated(uint256 liquidatorRewardFraction);\n    /\n     * @notice used to initialize the contract\n     * @dev can only be called once during the life cycle of the contract\n     * @param _defaultStrategy default strategy used in credit lines\n     * @param _priceOracle address of the priceOracle\n     * @param _savingsAccount address of  the savings account contract\n     * @param _strategyRegistry address of the strategy registry contract\n     * @param _owner address of owner who can change global variables\n     * @param _protocolFeeFraction fraction of the fee charged by protocol\n     * @param _protocolFeeCollector address to which protocol fee is charged to\n     * @param _liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator\n     /\n    function initialize(\n        address _defaultStrategy,\n        address _priceOracle,\n        address _savingsAccount,\n        address _strategyRegistry,\n        address _owner,\n        uint256 _protocolFeeFraction,\n        address _protocolFeeCollector,\n        uint256 _liquidatorRewardFraction\n    ) external initializer {\n        OwnableUpgradeable.__Ownable_init();\n        OwnableUpgradeable.transferOwnership(_owner);\n        _updateDefaultStrategy(_defaultStrategy);\n        _updatePriceOracle(_priceOracle);\n        _updateSavingsAccount(_savingsAccount);\n        _updateStrategyRegistry(_strategyRegistry);\n        _updateProtocolFeeFraction(_protocolFeeFraction);\n        _updateProtocolFeeCollector(_protocolFeeCollector);\n        _updateLiquidatorRewardFraction(_liquidatorRewardFraction);\n    }\n    /\n     * @notice used to update the default strategy\n     * @dev can only be updated by owner\n     * @param _defaultStrategy address of the updated default strategy\n     */\n    function updateDefaultStrategy(address _defaultStrategy) external onlyOwner {\n        _updateDefaultStrategy(_defaultStrategy);\n    }\n    function _updateDefaultStrategy(address _defaultStrategy) internal {\n        defaultStrategy = _defaultStrategy;\n        emit DefaultStrategyUpdated(_defaultStrategy);\n    }\n    /\n     * @notice used to update the price oracle\n     * @dev can only be updated by owner\n     * @param _priceOracle address of the updated price oracle\n     /\n    function updatePriceOracle(address _priceOracle) external onlyOwner {\n        _updatePriceOracle(_priceOracle);\n    }\n    function _updatePriceOracle(address _priceOracle) internal {\n        priceOracle = _priceOracle;\n        emit PriceOracleUpdated(_priceOracle);\n    }\n    /\n     * @notice used to update the savings account address\n     * @dev can only be updated by owner\n     * @param _savingsAccount address of the updated savings account\n     /\n    function updateSavingsAccount(address _savingsAccount) external onlyOwner {\n        _updateSavingsAccount(_savingsAccount);\n    }\n    function _updateSavingsAccount(address _savingsAccount) internal {\n        savingsAccount = _savingsAccount;\n        emit SavingsAccountUpdated(_savingsAccount);\n    }\n    /\n     * @notice used to update the protocol fee fraction\n     * @dev can only be updated by owner\n     * @param _protocolFee fraction of the borrower amount collected as protocol fee\n     */\n    function updateProtocolFeeFraction(uint256 _protocolFee) external onlyOwner {\n        _updateProtocolFeeFraction(_protocolFee);\n    }\n    function _updateProtocolFeeFraction(uint256 _protocolFee) internal {\n        protocolFeeFraction = _protocolFee;\n        emit ProtocolFeeFractionUpdated(_protocolFee);\n    }\n    /\n     * @notice used to update the protocol fee collector\n     * @dev can only be updated by owner\n     * @param _protocolFeeCollector address in which protocol fee is collected\n     /\n    function updateProtocolFeeCollector(address _protocolFeeCollector) external onlyOwner {\n        _updateProtocolFeeCollector(_protocolFeeCollector);\n    }\n    function _updateProtocolFeeCollector(address _protocolFeeCollector) internal {\n        require(_protocolFeeCollector != address(0), \'cant be 0 address\');\n        protocolFeeCollector = _protocolFeeCollector;\n        emit ProtocolFeeCollectorUpdated(_protocolFeeCollector);\n    }\n    /\n     * @notice used to update the strategy registry address\n     * @dev can only be updated by owner\n     * @param _strategyRegistry address of the updated strategy registry\n     /\n    function updateStrategyRegistry(address _strategyRegistry) external onlyOwner {\n        _updateStrategyRegistry(_strategyRegistry);\n    }\n    function _updateStrategyRegistry(address _strategyRegistry) internal {\n        require(_strategyRegistry != address(0), \'CL::I zero address\');\n        strategyRegistry = _strategyRegistry;\n        emit StrategyRegistryUpdated(_strategyRegistry);\n    }\n    /\n     * @notice used to update the liquidatorRewardFraction\n     * @dev can only be updated by owner\n     * @param _rewardFraction fraction of liquidated amount given to liquidator as reward\n     */\n    function updateLiquidatorRewardFraction(uint256 _rewardFraction) external onlyOwner {\n        _updateLiquidatorRewardFraction(_rewardFraction);\n    }\n    function _updateLiquidatorRewardFraction(uint256 _rewardFraction) internal {\n        require(_rewardFraction &lt;= 1030, \'Fraction has to be less than 1\');\n        liquidatorRewardFraction = _rewardFraction;\n        emit LiquidationRewardFractionUpdated(_rewardFraction);\n    }\n    /\n     * @dev Used to Calculate Interest Per second on given principal and Interest rate\n     * @param _principal principal Amount for which interest has to be calculated.\n     * @param _borrowRate It is the Interest Rate at which Credit Line is approved\n     * @return interest per second for the given parameters\n     */\n    function calculateInterest(\n        uint256 _principal,\n        uint256 _borrowRate,\n        uint256 _timeElapsed\n    ) public pure returns (uint256) {\n        uint256 _interest = _principal.mul(_borrowRate).mul(_timeElapsed).div(1030).div(YEAR_IN_SECONDS);\n        return _interest;\n    }\n    /\n     * @dev Used to calculate interest accrued since last repayment\n     * @param _id identifier for the credit line\n     * @return interest accrued over current borrowed amount since last repayment\n     */\n    function calculateInterestAccrued(uint256 _id) public view returns (uint256) {\n        uint256 _lastPrincipalUpdateTime = creditLineVariables[_id].lastPrincipalUpdateTime;\n        if (_lastPrincipalUpdateTime == 0) return 0;\n        uint256 _timeElapsed = (block.timestamp).sub(_lastPrincipalUpdateTime);\n        uint256 _interestAccrued = calculateInterest(creditLineVariables[_id].principal, creditLineConstants[_id].borrowRate, _timeElapsed);\n        return _interestAccrued;\n    }\n    /\n     * @dev Used to calculate current debt of borrower against a credit line.\n     * @param _id identifier for the credit line\n     * @return current debt of borrower\n     /\n    function calculateCurrentDebt(uint256 _id) public view returns (uint256) {\n        uint256 _interestAccrued = calculateInterestAccrued(_id);\n        uint256 _currentDebt = (creditLineVariables[_id].principal)\n            .add(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate)\n            .add(_interestAccrued)\n            .sub(creditLineVariables[_id].totalInterestRepaid);\n        return _currentDebt;\n    }\n    /\n     * @notice used to calculate amount that can be borrowed by the borrower\n     * @dev is a view function for the protocol itself, but isn\'t view because of getTokensForShares which is not view.\n            borrowableAmount changes per block as interest changes per block.\n     * @param _id identifier for the credit line\n     * @return amount that can be borrowed from the credit line\n     /\n    function calculateBorrowableAmount(uint256 _id) public returns (uint256) {\n        CreditLineStatus _status = creditLineVariables[_id].status;\n        require(\n            _status == CreditLineStatus.ACTIVE || _status == CreditLineStatus.REQUESTED,\n            \'CreditLine: Cannot only if credit line ACTIVE or REQUESTED\'\n        );\n        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(\n            creditLineConstants[_id].collateralAsset,\n            creditLineConstants[_id].borrowAsset\n        );\n        uint256 _totalCollateralToken = calculateTotalCollateralTokens(_id);\n        uint256 _currentDebt = calculateCurrentDebt(_id);\n        uint256 _maxPossible = _totalCollateralToken.mul(_ratioOfPrices).div(creditLineConstants[_id].idealCollateralRatio).mul(1030).div(\n            10_decimals\n        );\n        uint256 _borrowLimit = creditLineConstants[_id].borrowLimit;\n        if (_maxPossible &gt; _borrowLimit) {\n            _maxPossible = _borrowLimit;\n        }\n        if (_maxPossible &gt; _currentDebt) {\n            return _maxPossible.sub(_currentDebt);\n        }\n        return 0;\n    }\n    function updateinterestAccruedTillLastPrincipalUpdate(uint256 _id) internal {\n        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, \'CreditLine: The credit line is not yet active.\');\n        uint256 _interestAccrued = calculateInterestAccrued(_id);\n        uint256 _newInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(_interestAccrued);\n        creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _newInterestAccrued;\n    }\n    function _depositCollateralFromSavingsAccount(\n        uint256 _id,\n        uint256 _amount,\n        address _sender\n    ) internal {\n        address _collateralAsset = creditLineConstants[_id].collateralAsset;\n        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();\n        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);\n        uint256 _activeAmount;\n        for (uint256 _index = 0; _index &lt; _strategyList.length; _index++) {\n            address _strategy = _strategyList[_index];\n            uint256 _liquidityShares = _savingsAccount.balanceInShares(_sender, _collateralAsset, _strategy);\n            if (_liquidityShares == 0 || _strategyList[_index] == address(0)) {\n                continue;\n            }\n            uint256 _tokenInStrategy = _liquidityShares;\n            _tokenInStrategy = IYield(_strategy).getTokensForShares(_liquidityShares, _collateralAsset);\n            uint256 _tokensToTransfer = _tokenInStrategy;\n            if (_activeAmount.add(_tokenInStrategy) &gt;= _amount) {\n                _tokensToTransfer = (_amount.sub(_activeAmount));\n            }\n            _activeAmount = _activeAmount.add(_tokensToTransfer);\n            _savingsAccount.transferFrom(_tokensToTransfer, _collateralAsset, _strategy, _sender, address(this));\n            collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(\n                _liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy)\n            );\n            if (_amount == _activeAmount) {\n                return;\n            }\n        }\n        revert(\'CreditLine::_depositCollateralFromSavingsAccount - Insufficient balance\');\n    }\n    /\n     * @notice used to request a credit line either by borrower or lender\n     * @param _requestTo Address to which creditLine is requested, \n                        if borrower creates request then lender address and \n                        if lender creates then borrower address\n     * @param _borrowLimit maximum borrow amount in a credit line\n     * @param _borrowRate Interest Rate at which credit Line is requested\n     * @param _autoLiquidation if true, anyone can liquidate loan, otherwise only lender\n     * @param _collateralRatio ratio of the collateral to the debt below which credit line can be liquidated\n     * @param _borrowAsset address of the token to be borrowed\n     * @param _collateralAsset address of the token provided as collateral\n     * @param _requestAsLender if true, lender is placing request, otherwise borrower\n     * @return identifier for the credit line\n     */\n    function request(\n        address _requestTo,\n        uint256 _borrowLimit,\n        uint256 _borrowRate,\n        bool _autoLiquidation,\n        uint256 _collateralRatio,\n        address _borrowAsset,\n        address _collateralAsset,\n        bool _requestAsLender\n    ) external returns (uint256) {\n        require(_borrowAsset != _collateralAsset, \'R: cant borrow lent token\');\n        require(IPriceOracle(priceOracle).doesFeedExist(_borrowAsset, _collateralAsset), \'R: No price feed\');\n        address _lender = _requestTo;\n        address _borrower = msg.sender;\n        if (_requestAsLender) {\n            _lender = msg.sender;\n            _borrower = _requestTo;\n        }\n        uint256 _id = _createRequest(\n            _lender,\n            _borrower,\n            _borrowLimit,\n            _borrowRate,\n            _autoLiquidation,\n            _collateralRatio,\n            _borrowAsset,\n            _collateralAsset,\n            _requestAsLender\n        );\n        emit CreditLineRequested(_id, _lender, _borrower);\n        return _id;\n    }\n    function _createRequest(\n        address _lender,\n        address _borrower,\n        uint256 _borrowLimit,\n        uint256 _borrowRate,\n        bool _autoLiquidation,\n        uint256 _collateralRatio,\n        address _borrowAsset,\n        address _collateralAsset,\n        bool _requestByLender\n    ) internal returns (uint256) {\n        require(_lender != _borrower, \'Lender and Borrower cannot be same addresses\');\n        uint256 _id = creditLineCounter + 1;\n        creditLineCounter = _id;\n        creditLineVariables[_id].status = CreditLineStatus.REQUESTED;\n        creditLineConstants[_id].borrower = _borrower;\n        creditLineConstants[_id].lender = _lender;\n        creditLineConstants[_id].borrowLimit = _borrowLimit;\n        creditLineConstants[_id].autoLiquidation = _autoLiquidation;\n        creditLineConstants[_id].idealCollateralRatio = _collateralRatio;\n        creditLineConstants[_id].borrowRate = _borrowRate;\n        creditLineConstants[_id].borrowAsset = _borrowAsset;\n        creditLineConstants[_id].collateralAsset = _collateralAsset;\n        creditLineConstants[_id].requestByLender = _requestByLender;\n        return _id;\n    }\n    /\n     * @notice used to accept a credit line\n     * @dev if borrower places request, lender can accept and vice versa\n     * @param _id identifier for the credit line\n     /\n    function accept(uint256 _id) external {\n        require(\n            creditLineVariables[_id].status == CreditLineStatus.REQUESTED,\n            \'CreditLine::acceptCreditLineLender - CreditLine is already accepted\'\n        );\n        bool _requestByLender = creditLineConstants[_id].requestByLender;\n        require(\n            (msg.sender == creditLineConstants[_id].borrower &amp;&amp; _requestByLender) ||\n                (msg.sender == creditLineConstants[_id].lender &amp;&amp; !_requestByLender),\n            "Only Borrower or Lender who hasn\'t requested can accept"\n        );\n        creditLineVariables[_id].status = CreditLineStatus.ACTIVE;\n        emit CreditLineAccepted(_id);\n    }\n    /\n     * @notice used to deposit collateral into the credit line\n     * @dev collateral tokens have to be approved in savingsAccount or token contract(unless ether).\n            If transferred from savings account, the tokens are transferred from strategies in the \n            order prespecified in strategy registry\n     * @param _id identifier for the credit line\n     * @param _amount amount of collateral being deposited\n     * @param _strategy strategy to which collateral is to be deposited in case transfer is not from savings account\n     * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount \n                                otherwise direct from collateral token contract\n     /\n    function depositCollateral(\n        uint256 _id,\n        uint256 _amount,\n        address _strategy,\n        bool _fromSavingsAccount\n    ) external payable nonReentrant ifCreditLineExists(_id) {\n        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, \'CreditLine not active\');\n        _depositCollateral(_id, _amount, _strategy, _fromSavingsAccount);\n        emit CollateralDeposited(_id, _amount, _strategy);\n    }\n    function _depositCollateral(\n        uint256 _id,\n        uint256 _amount,\n        address _strategy,\n        bool _fromSavingsAccount\n    ) internal {\n        require(creditLineConstants[_id].lender != msg.sender, \'lender cant deposit collateral\');\n        if (_fromSavingsAccount) {\n            _depositCollateralFromSavingsAccount(_id, _amount, msg.sender);\n        } else {\n            address _collateralAsset = creditLineConstants[_id].collateralAsset;\n            ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);\n            if (_collateralAsset == address(0)) {\n                require(msg.value == _amount, "CreditLine::_depositCollateral - value to transfer doesn\'t match argument");\n            } else {\n                IERC20(_collateralAsset).safeTransferFrom(msg.sender, address(this), _amount);\n                IERC20(_collateralAsset).approve(_strategy, _amount);\n            }\n            uint256 _sharesReceived = _savingsAccount.deposit{value: msg.value}(_amount, _collateralAsset, _strategy, address(this));\n            collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(_sharesReceived);\n        }\n    }\n    function _withdrawBorrowAmount(\n        address _asset,\n        uint256 _amountInTokens,\n        address _lender\n    ) internal {\n        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();\n        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);\n        uint256 _activeAmount;\n        for (uint256 _index = 0; _index &lt; _strategyList.length; _index++) {\n            if (_strategyList[_index] == address(0)) {\n                continue;\n            }\n            uint256 _liquidityShares = _savingsAccount.balanceInShares(_lender, _asset, _strategyList[_index]);\n            if (_liquidityShares != 0) {\n                uint256 tokenInStrategy = _liquidityShares;\n                tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);\n                uint256 _tokensToTransfer = tokenInStrategy;\n                if (_activeAmount.add(tokenInStrategy) &gt;= _amountInTokens) {\n                    _tokensToTransfer = (_amountInTokens.sub(_activeAmount));\n                }\n                _activeAmount = _activeAmount.add(_tokensToTransfer);\n                _savingsAccount.withdrawFrom(_tokensToTransfer, _asset, _strategyList[_index], _lender, address(this), false);\n                if (_activeAmount == _amountInTokens) {\n                    return;\n                }\n            }\n        }\n        require(_activeAmount == _amountInTokens, \'insufficient balance\');\n    }\n    /\n     * @notice used to borrow tokens from credit line by borrower\n     * @dev only borrower can call this function. Amount that can actually be borrowed is \n            min(amount based on borrowLimit, allowance to creditLine contract, balance of lender)\n     * @param _id identifier for the credit line\n     * @param _amount amount of tokens to borrow\n     */\n    function borrow(uint256 _id, uint256 _amount) external payable nonReentrant onlyCreditLineBorrower(_id) {\n        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, \'CreditLine: The credit line is not yet active.\');\n        uint256 _borrowableAmount = calculateBorrowableAmount(_id);\n        require(_amount &lt;= _borrowableAmount, "CreditLine::borrow - The current collateral ratio doesn\'t allow to withdraw the amount");\n        address _borrowAsset = creditLineConstants[_id].borrowAsset;\n        address _lender = creditLineConstants[_id].lender;\n        updateinterestAccruedTillLastPrincipalUpdate(_id);\n        creditLineVariables[_id].principal = creditLineVariables[_id].principal.add(_amount);\n        creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;\n        uint256 _tokenDiffBalance;\n        if (_borrowAsset != address(0)) {\n            uint256 _balanceBefore = IERC20(_borrowAsset).balanceOf(address(this));\n            _withdrawBorrowAmount(_borrowAsset, _amount, _lender);\n            uint256 _balanceAfter = IERC20(_borrowAsset).balanceOf(address(this));\n            _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);\n        } else {\n            uint256 _balanceBefore = address(this).balance;\n            _withdrawBorrowAmount(_borrowAsset, _amount, _lender);\n            uint256 _balanceAfter = address(this).balance;\n            _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);\n        }\n        uint256 _protocolFee = _tokenDiffBalance.mul(protocolFeeFraction).div(1030);\n        _tokenDiffBalance = _tokenDiffBalance.sub(_protocolFee);\n        if (_borrowAsset == address(0)) {\n            (bool feeSuccess, ) = protocolFeeCollector.call{value: _protocolFee}(\'\');\n            require(feeSuccess, \'Transfer fail\');\n            (bool success, ) = msg.sender.call{value: _tokenDiffBalance}(\'\');\n            require(success, \'Transfer fail\');\n        } else {\n            IERC20(_borrowAsset).safeTransfer(protocolFeeCollector, _protocolFee);\n            IERC20(_borrowAsset).safeTransfer(msg.sender, _tokenDiffBalance);\n        }\n        emit BorrowedFromCreditLine(_id, _tokenDiffBalance);\n    }\n    function _repayFromSavingsAccount(\n        uint256 _amount,\n        address _asset,\n        address _lender\n    ) internal {\n        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();\n        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);\n        uint256 _activeAmount;\n        for (uint256 _index = 0; _index &lt; _strategyList.length; _index++) {\n            if (_strategyList[_index] == address(0)) {\n                continue;\n            }\n            uint256 _liquidityShares = _savingsAccount.balanceInShares(msg.sender, _asset, _strategyList[_index]);\n            if (_liquidityShares == 0) {\n                continue;\n            }\n            uint256 _tokenInStrategy = _liquidityShares;\n            _tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);\n            uint256 _tokensToTransfer = _tokenInStrategy;\n            if (_activeAmount.add(_tokenInStrategy) &gt;= _amount) {\n                _tokensToTransfer = (_amount.sub(_activeAmount));\n            }\n            _activeAmount = _activeAmount.add(_tokensToTransfer);\n            _savingsAccount.transferFrom(_tokensToTransfer, _asset, _strategyList[_index], msg.sender, _lender);\n            if (_amount == _activeAmount) {\n                return;\n            }\n        }\n        revert(\'CreditLine::_repayFromSavingsAccount - Insufficient balance\');\n    }\n    function _repay(\n        uint256 _id,\n        uint256 _amount,\n        bool _fromSavingsAccount,\n        uint256 _principalPaid\n    ) internal {\n        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);\n        address _defaultStrategy = defaultStrategy;\n        address _borrowAsset = creditLineConstants[_id].borrowAsset;\n        address _lender = creditLineConstants[_id].lender;\n        if (!_fromSavingsAccount) {\n            if (_borrowAsset == address(0)) {\n                require(msg.value == _amount, \'creditLine::repay - Ether sent not equal to repay amount\');\n                _savingsAccount.deposit{value: _amount}(_amount, _borrowAsset, _defaultStrategy, _lender);\n            } else {\n                IERC20(_borrowAsset).safeTransferFrom(msg.sender, address(this), _amount);\n                IERC20(_borrowAsset).approve(_defaultStrategy, _amount);\n                _savingsAccount.deposit(_amount, _borrowAsset, _defaultStrategy, _lender);\n            }\n        } else {\n            _repayFromSavingsAccount(_amount, _borrowAsset, _lender);\n        }\n        if (_principalPaid != 0) {\n            _savingsAccount.increaseAllowanceToCreditLine(_principalPaid, _borrowAsset, _lender);\n        }\n    }\n    /\n     * @notice used to repay interest and principal to credit line. Interest has to be repaid before repaying principal\n     * @dev partial repayments possible\n     * @param _id identifier for the credit line\n     * @param _amount amount being repaid\n     * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount \n                                otherwise direct from collateral token contract\n     */\n    function repay(\n        uint256 _id,\n        uint256 _amount,\n        bool _fromSavingsAccount\n    ) external payable nonReentrant {\n        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, \'CreditLine: The credit line is not yet active.\');\n        require(creditLineConstants[_id].lender != msg.sender, \'Lender cant repay\');\n        uint256 _interestSincePrincipalUpdate = calculateInterestAccrued(_id);\n        uint256 _totalInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(\n            _interestSincePrincipalUpdate\n        );\n        uint256 _interestToPay = _totalInterestAccrued.sub(creditLineVariables[_id].totalInterestRepaid);\n        uint256 _totalCurrentDebt = _interestToPay.add(creditLineVariables[_id].principal);\n        uint256 _principalPaid = 0;\n        if (_amount &gt;= _totalCurrentDebt) {\n            _amount = _totalCurrentDebt;\n            emit CompleteCreditLineRepaid(_id, _amount);\n        } else {\n            emit PartialCreditLineRepaid(_id, _amount);\n        }\n        if (_amount &gt; _interestToPay) {\n            creditLineVariables[_id].principal = _totalCurrentDebt.sub(_amount);\n            creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _totalInterestAccrued;\n            creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;\n            creditLineVariables[_id].totalInterestRepaid = _totalInterestAccrued;\n            _principalPaid = _amount.sub(_interestToPay);\n        } else {\n            creditLineVariables[_id].totalInterestRepaid = creditLineVariables[_id].totalInterestRepaid.add(_amount);\n        }\n        _repay(_id, _amount, _fromSavingsAccount, _principalPaid);\n        if (creditLineVariables[_id].principal == 0) {\n            _resetCreditLine(_id);\n        }\n    }\n    function _resetCreditLine(uint256 _id) internal {\n        creditLineVariables[_id].lastPrincipalUpdateTime = 0;\n        creditLineVariables[_id].totalInterestRepaid = 0;\n        creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = 0;\n        emit CreditLineReset(_id);\n    }\n    /\n     * @dev used to close credit line by borrower or lender\n     * @param _id identifier for the credit line\n     /\n    function close(uint256 _id) external ifCreditLineExists(_id) {\n        require(\n            msg.sender == creditLineConstants[_id].borrower || msg.sender == creditLineConstants[_id].lender,\n            \'CreditLine: Permission denied while closing Line of credit\'\n        );\n        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, \'CreditLine: Credit line should be active.\');\n        require(creditLineVariables[_id].principal == 0, \'CreditLine: Cannot be closed since not repaid.\');\n        require(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate == 0, \'CreditLine: Cannot be closed since not repaid.\');\n        creditLineVariables[_id].status = CreditLineStatus.CLOSED;\n        emit CreditLineClosed(_id);\n    }\n    /\n     * @notice used to calculate the current collateral ratio\n     * @dev is a view function for the protocol itself, but isn\'t view because of getTokensForShares which is not view.\n            Interest is also considered while calculating debt\n     * @param _id identifier for the credit line\n     * @return collateral ratio multiplied by 1030 to retain precision\n     /\n    function calculateCurrentCollateralRatio(uint256 _id) public ifCreditLineExists(_id) returns (uint256) {\n        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(\n            creditLineConstants[_id].collateralAsset,\n            creditLineConstants[_id].borrowAsset\n        );\n        uint256 currentDebt = calculateCurrentDebt(_id);\n        uint256 currentCollateralRatio = calculateTotalCollateralTokens(_id).mul(_ratioOfPrices).div(currentDebt).mul(1030).div(\n            10_decimals\n        );\n        return currentCollateralRatio;\n    }\n    /\n     * @notice used to calculate the total collateral tokens\n     * @dev is a view function for the protocol itself, but isn\'t view because of getTokensForShares which is not view\n     * @param _id identifier for the credit line\n     * @return _amount total collateral tokens deposited into the credit line\n     */\n    function calculateTotalCollateralTokens(uint256 _id) public returns (uint256 _amount) {\n        address _collateralAsset = creditLineConstants[_id].collateralAsset;\n        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();\n        uint256 _liquidityShares;\n        for (uint256 index = 0; index &lt; _strategyList.length; index++) {\n            if (_strategyList[index] == address(0)) {\n                continue;\n            }\n            _liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];\n            uint256 _tokenInStrategy = _liquidityShares;\n            _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(_liquidityShares, _collateralAsset);\n            _amount = _amount.add(_tokenInStrategy);\n        }\n    }\n    /\n     * @notice used to withdraw any excess collateral\n     * @dev collateral can\'t be withdraw if collateralRatio goes below the ideal value. Only borrower can withdraw\n     * @param _id identifier for the credit line\n     * @param _amount amount of collateral to withdraw\n     * @param _toSavingsAccount if true, tokens are transferred from savingsAccount \n                                otherwise direct from collateral token contract\n     /\n    function withdrawCollateral(\n        uint256 _id,\n        uint256 _amount,\n        bool _toSavingsAccount\n    ) external nonReentrant onlyCreditLineBorrower(_id) {\n        uint256 _withdrawableCollateral = withdrawableCollateral(_id);\n        require(_amount &lt;= _withdrawableCollateral, \'Collateral ratio cant go below ideal\');\n        address _collateralAsset = creditLineConstants[_id].collateralAsset;\n        _transferCollateral(_id, _collateralAsset, _amount, _toSavingsAccount);\n        emit CollateralWithdrawn(_id, _amount);\n    }\n    /\n     * @notice used to calculate the collateral that can be withdrawn\n     * @dev is a view function for the protocol itself, but isn\'t view because of getTokensForShares which is not view\n     * @param _id identifier for the credit line\n     * @return total collateral withdrawable by borrower\n     /\n    function withdrawableCollateral(uint256 _id) public returns (uint256) {\n        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(\n            creditLineConstants[_id].collateralAsset,\n            creditLineConstants[_id].borrowAsset\n        );\n        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);\n        uint256 _currentDebt = calculateCurrentDebt(_id);\n        uint256 _collateralNeeded = _currentDebt\n            .mul(creditLineConstants[_id].idealCollateralRatio)\n            .div(_ratioOfPrices)\n            .mul(10_decimals)\n            .div(1030);\n        if (_collateralNeeded &gt;= _totalCollateralTokens) {\n            return 0;\n        }\n        return _totalCollateralTokens.sub(_collateralNeeded);\n    }\n    function _transferCollateral(\n        uint256 _id,\n        address _asset,\n        uint256 _amountInTokens,\n        bool _toSavingsAccount\n    ) internal {\n        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();\n        uint256 _activeAmount;\n        for (uint256 index = 0; index &lt; _strategyList.length; index++) {\n            uint256 liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];\n            if (liquidityShares == 0 || _strategyList[index] == address(0)) {\n                continue;\n            }\n            uint256 _tokenInStrategy = liquidityShares;\n            _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(liquidityShares, _asset);\n            uint256 _tokensToTransfer = _tokenInStrategy;\n            if (_activeAmount.add(_tokenInStrategy) &gt; _amountInTokens) {\n                _tokensToTransfer = _amountInTokens.sub(_activeAmount);\n                liquidityShares = liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy);\n            }\n            _activeAmount = _activeAmount.add(_tokensToTransfer);\n            collateralShareInStrategy[_id][_strategyList[index]] = collateralShareInStrategy[_id][_strategyList[index]].sub(\n                liquidityShares\n            );\n            if (_toSavingsAccount) {\n                ISavingsAccount(savingsAccount).transfer(_tokensToTransfer, _asset, _strategyList[index], msg.sender);\n            } else {\n                ISavingsAccount(savingsAccount).withdraw(_tokensToTransfer, _asset, _strategyList[index], msg.sender, false);\n            }\n            if (_activeAmount == _amountInTokens) {\n                return;\n            }\n        }\n        revert(\'insufficient collateral\');\n    }\n    /\n     * @notice used to liquidate credit line in case collateral ratio goes below the threshold\n     * @dev if lender liquidates, then collateral is directly transferred. \n            If autoLiquidation is true, anyone can liquidate by providing enough borrow tokens\n     * @param _id identifier for the credit line\n     * @param _toSavingsAccount if true, tokens are transferred from savingsAccount \n                                otherwise direct from collateral token contract\n     */\n    function liquidate(uint256 _id, bool _toSavingsAccount) external payable nonReentrant {\n        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, \'CreditLine: Credit line should be active.\');\n        require(creditLineVariables[_id].principal != 0, \'CreditLine: cannot liquidate if principal is 0\');\n        uint256 currentCollateralRatio = calculateCurrentCollateralRatio(_id);\n        require(\n            currentCollateralRatio &lt; creditLineConstants[_id].idealCollateralRatio,\n            \'CreditLine: Collateral ratio is higher than ideal value\'\n        );\n        address _collateralAsset = creditLineConstants[_id].collateralAsset;\n        address _lender = creditLineConstants[_id].lender;\n        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);\n        address _borrowAsset = creditLineConstants[_id].borrowAsset;\n        creditLineVariables[_id].status = CreditLineStatus.LIQUIDATED;\n        if (creditLineConstants[_id].autoLiquidation &amp;&amp; _lender != msg.sender) {\n            uint256 _borrowTokens = _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens);\n            if (_borrowAsset == address(0)) {\n                uint256 _returnETH = msg.value.sub(_borrowTokens, \'Insufficient ETH to liquidate\');\n                if (_returnETH != 0) {\n                    (bool success, ) = msg.sender.call{value: _returnETH}(\'\');\n                    require(success, \'Transfer fail\');\n                }\n            } else {\n                IERC20(_borrowAsset).safeTransferFrom(msg.sender, _lender, _borrowTokens);\n            }\n        }\n        _transferCollateral(_id, _collateralAsset, _totalCollateralTokens, _toSavingsAccount);\n        emit CreditLineLiquidated(_id, msg.sender);\n    }\n    /\n     * @notice used to calculate the borrow tokens necessary for liquidator to liquidate\n     * @dev is a view function for the protocol itself, but isn\'t view because of getTokensForShares which is not view\n     * @param _id identifier for the credit line\n     * @return borrow tokens necessary for liquidator to liquidate\n     /\n    function borrowTokensToLiquidate(uint256 _id) external returns (uint256) {\n        address _collateralAsset = creditLineConstants[_id].collateralAsset;\n        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);\n        address _borrowAsset = creditLineConstants[_id].borrowAsset;\n        return _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens);\n    }\n    function _borrowTokensToLiquidate(\n        address _borrowAsset,\n        address _collateralAsset,\n        uint256 _totalCollateralTokens\n    ) internal view returns (uint256) {\n        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(_borrowAsset, _collateralAsset);\n        uint256 _borrowTokens = (\n            _totalCollateralTokens.mul(uint256(1030).sub(liquidatorRewardFraction)).div(1030).mul(_ratioOfPrices).div(10_decimals)\n        );\n        return _borrowTokens;\n    }\n    receive() external payable {\n        require(msg.sender == savingsAccount, \'CreditLine::receive invalid transaction\');\n    }\n}\n.\n\nChief Executive Officer: We excel in generating innovative approaches and enhancements for Solidity smart contract code.\nHere\'s a Solidity contract provided by the user: "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\nimport \'@openzeppelin/contracts/token/ERC20/SafeERC20.sol\';\nimport \'@openzeppelin/contracts/math/SafeMath.sol\';\nimport \'@openzeppelin/contracts/utils/ReentrancyGuard.sol\';\nimport \'@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\';\nimport \'../interfaces/IPriceOracle.sol\';\nimport \'../interfaces/IYield.sol\';\nimport \'../interfaces/ISavingsAccount.sol\';\nimport \'../SavingsAccount/SavingsAccountUtil.sol\';\nimport \'../interfaces/IStrategyRegistry.sol\';\n/\n * @title Credit Line contract with Methods related to credit Line\n * @notice Implements the functions related to Credit Line\n * @author Sublime\n /\ncontract CreditLine is ReentrancyGuard, OwnableUpgradeable {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n    enum CreditLineStatus {\n        NOT_CREATED,\n        REQUESTED,\n        ACTIVE,\n        CLOSED,\n        CANCELLED,\n        LIQUIDATED\n    }\n    /\n     * @notice counter that tracks the number of credit lines created\n     * @dev used to create unique identifier for credit lines\n     /\n    uint256 public creditLineCounter;\n    uint256 constant YEAR_IN_SECONDS = 365 days;\n    struct CreditLineVariables {\n        CreditLineStatus status;\n        uint256 principal;\n        uint256 totalInterestRepaid;\n        uint256 lastPrincipalUpdateTime;\n        uint256 interestAccruedTillLastPrincipalUpdate;\n    }\n    struct CreditLineConstants {\n        address lender;\n        address borrower;\n        uint256 borrowLimit;\n        uint256 idealCollateralRatio;\n        uint256 borrowRate;\n        address borrowAsset;\n        address collateralAsset;\n        bool autoLiquidation;\n        bool requestByLender;\n    }\n    /\n     * @notice stores the collateral shares in a credit line per strategy\n     * @dev creditLineId =&gt; Strategy =&gt; collateralShares\n     /\n    mapping(uint256 =&gt; mapping(address =&gt; uint256)) public collateralShareInStrategy;\n    /\n     * @notice stores the variables to maintain a credit line\n     /\n    mapping(uint256 =&gt; CreditLineVariables) public creditLineVariables;\n    /\n     * @notice stores the constants related to a credit line\n     /\n    mapping(uint256 =&gt; CreditLineConstants) public creditLineConstants;\n    /\n     * @notice stores the address of savings account contract\n     /\n    address public savingsAccount;\n    /\n     * @notice stores the address of price oracle contract\n     /\n    address public priceOracle;\n    /\n     * @notice stores the address of strategy registry contract\n     /\n    address public strategyRegistry;\n    /\n     * @notice stores the address of default strategy\n     /\n    address public defaultStrategy;\n    /\n     * @notice stores the fraction of borrowed amount charged as fee by protocol\n     * @dev it is multiplied by 1030\n     /\n    uint256 public protocolFeeFraction;\n    /\n     * @notice address where protocol fee is collected\n     /\n    address public protocolFeeCollector;\n    /\n     * @notice stores the fraction of amount liquidated given as reward to liquidator\n     * @dev it is multiplied by 1030\n     /\n    uint256 public liquidatorRewardFraction;\n    /\n     * @dev checks if Credit Line exists\n     * @param _id identifier for the credit line\n     /\n    modifier ifCreditLineExists(uint256 id) {\n        require(creditLineVariables[_id].status != CreditLineStatus.NOT_CREATED, \'Credit line does not exist\');\n        ;\n    }\n    /\n     * @dev checks if called by credit Line Borrower\n     * @param _id creditLine identifier\n     /\n    modifier onlyCreditLineBorrower(uint256 id) {\n        require(creditLineConstants[_id].borrower == msg.sender, \'Only credit line Borrower can access\');\n        ;\n    }\n    /\n     * @dev checks if called by credit Line Lender\n     * @param _id creditLine identifier\n     /\n    modifier onlyCreditLineLender(uint256 id) {\n        require(creditLineConstants[_id].lender == msg.sender, \'Only credit line Lender can access\');\n        ;\n    }\n    /\n     * @notice emitted when a collateral is deposited into credit line\n     * @param id id of the credit line\n     * @param amount amount of collateral deposited\n     * @param strategy address of the strategy into which collateral is deposited\n     /\n    event CollateralDeposited(uint256 indexed id, uint256 amount, address indexed strategy);\n    /\n     * @notice emitted when collateral is withdrawn from credit line\n     * @param id id of the credit line\n     * @param amount amount of collateral withdrawn\n     */\n    event CollateralWithdrawn(uint256 indexed id, uint256 amount);\n    /\n     * @notice emitted when a request for new credit line is placed\n     * @param id id of the credit line for which request was made\n     * @param lender address of the lender for credit line\n     * @param borrower address of the borrower for credit line\n     /\n    event CreditLineRequested(uint256 indexed id, address indexed lender, address indexed borrower);\n    /\n     * @notice emitted when a credit line is liquidated\n     * @param id id of the credit line which is liquidated\n     * @param liquidator address of the liquidator\n     /\n    event CreditLineLiquidated(uint256 indexed id, address indexed liquidator);\n    /\n     * @notice emitted when tokens are borrowed from credit line\n     * @param id id of the credit line from which tokens are borrowed\n     * @param borrowAmount amount of tokens borrowed\n     */\n    event BorrowedFromCreditLine(uint256 indexed id, uint256 borrowAmount);\n    /\n     * @notice emitted when credit line is accepted\n     * @param id id of the credit line that was accepted\n     /\n    event CreditLineAccepted(uint256 indexed id);\n    /\n     * @notice emitted when credit line is completely repaid and reset\n     * @param id id of the credit line that is reset\n     /\n    event CreditLineReset(uint256 indexed id);\n    /\n     * @notice emitted when the credit line is partially repaid\n     * @param id id of the credit line\n     * @param repayAmount amount repaid\n     */\n    event PartialCreditLineRepaid(uint256 indexed id, uint256 repayAmount);\n    /\n     * @notice emitted when the credit line is completely repaid\n     * @param id id of the credit line\n     * @param repayAmount amount repaid\n     /\n    event CompleteCreditLineRepaid(uint256 indexed id, uint256 repayAmount);\n    /\n     * @notice emitted when the credit line is closed by one of the parties of credit line\n     * @param id id of the credit line\n     /\n    event CreditLineClosed(uint256 indexed id);\n    /\n     * @notice emitted when default strategy for the credit line is updated\n     * @param defaultStrategy address of the strategy contract that is used as default by credit lines\n     */\n    event DefaultStrategyUpdated(address indexed defaultStrategy);\n    /\n     * @notice emitted when the price oracle is updated\n     * @param priceOracle address of the updated price oracle\n     /\n    event PriceOracleUpdated(address indexed priceOracle);\n    /\n     * @notice emitted when the savings account address is updated\n     * @param savingsAccount address of the updated savingsAccount\n     /\n    event SavingsAccountUpdated(address indexed savingsAccount);\n    /\n     * @notice emitted when strategy registry address is updated\n     * @param strategyRegistry address of the updated strategy registry\n     */\n    event StrategyRegistryUpdated(address indexed strategyRegistry);\n    /\n     * @notice emitted when fee that protocol charges for credit line is updated\n     * @param updatedProtocolFee updated value of protocolFeeFraction\n     /\n    event ProtocolFeeFractionUpdated(uint256 updatedProtocolFee);\n    /\n     * @notice emitted when address which receives fee that protocol changes for pools is updated\n     * @param updatedProtocolFeeCollector updated value of protocolFeeCollector\n     /\n    event ProtocolFeeCollectorUpdated(address indexed updatedProtocolFeeCollector);\n    /\n     * @notice emitted when liquidatorRewardFraction is updated\n     * @param liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator\n     */\n    event LiquidationRewardFractionUpdated(uint256 liquidatorRewardFraction);\n    /\n     * @notice used to initialize the contract\n     * @dev can only be called once during the life cycle of the contract\n     * @param _defaultStrategy default strategy used in credit lines\n     * @param _priceOracle address of the priceOracle\n     * @param _savingsAccount address of  the savings account contract\n     * @param _strategyRegistry address of the strategy registry contract\n     * @param _owner address of owner who can change global variables\n     * @param _protocolFeeFraction fraction of the fee charged by protocol\n     * @param _protocolFeeCollector address to which protocol fee is charged to\n     * @param _liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator\n     /\n    function initialize(\n        address _defaultStrategy,\n        address _priceOracle,\n        address _savingsAccount,\n        address _strategyRegistry,\n        address _owner,\n        uint256 _protocolFeeFraction,\n        address _protocolFeeCollector,\n        uint256 _liquidatorRewardFraction\n    ) external initializer {\n        OwnableUpgradeable.__Ownable_init();\n        OwnableUpgradeable.transferOwnership(_owner);\n        _updateDefaultStrategy(_defaultStrategy);\n        _updatePriceOracle(_priceOracle);\n        _updateSavingsAccount(_savingsAccount);\n        _updateStrategyRegistry(_strategyRegistry);\n        _updateProtocolFeeFraction(_protocolFeeFraction);\n        _updateProtocolFeeCollector(_protocolFeeCollector);\n        _updateLiquidatorRewardFraction(_liquidatorRewardFraction);\n    }\n    /\n     * @notice used to update the default strategy\n     * @dev can only be updated by owner\n     * @param _defaultStrategy address of the updated default strategy\n     /\n    function updateDefaultStrategy(address _defaultStrategy) external onlyOwner {\n        _updateDefaultStrategy(_defaultStrategy);\n    }\n    function _updateDefaultStrategy(address _defaultStrategy) internal {\n        defaultStrategy = _defaultStrategy;\n        emit DefaultStrategyUpdated(_defaultStrategy);\n    }\n    /\n     * @notice used to update the price oracle\n     * @dev can only be updated by owner\n     * @param _priceOracle address of the updated price oracle\n     */\n    function updatePriceOracle(address _priceOracle) external onlyOwner {\n        _updatePriceOracle(_priceOracle);\n    }\n    function _updatePriceOracle(address _priceOracle) internal {\n        priceOracle = _priceOracle;\n        emit PriceOracleUpdated(_priceOracle);\n    }\n    /\n     * @notice used to update the savings account address\n     * @dev can only be updated by owner\n     * @param _savingsAccount address of the updated savings account\n     /\n    function updateSavingsAccount(address _savingsAccount) external onlyOwner {\n        _updateSavingsAccount(_savingsAccount);\n    }\n    function _updateSavingsAccount(address _savingsAccount) internal {\n        savingsAccount = _savingsAccount;\n        emit SavingsAccountUpdated(_savingsAccount);\n    }\n    /\n     * @notice used to update the protocol fee fraction\n     * @dev can only be updated by owner\n     * @param _protocolFee fraction of the borrower amount collected as protocol fee\n     /\n    function updateProtocolFeeFraction(uint256 _protocolFee) external onlyOwner {\n        _updateProtocolFeeFraction(_protocolFee);\n    }\n    function _updateProtocolFeeFraction(uint256 _protocolFee) internal {\n        protocolFeeFraction = _protocolFee;\n        emit ProtocolFeeFractionUpdated(_protocolFee);\n    }\n    /\n     * @notice used to update the protocol fee collector\n     * @dev can only be updated by owner\n     * @param _protocolFeeCollector address in which protocol fee is collected\n     */\n    function updateProtocolFeeCollector(address _protocolFeeCollector) external onlyOwner {\n        _updateProtocolFeeCollector(_protocolFeeCollector);\n    }\n    function _updateProtocolFeeCollector(address _protocolFeeCollector) internal {\n        require(_protocolFeeCollector != address(0), \'cant be 0 address\');\n        protocolFeeCollector = _protocolFeeCollector;\n        emit ProtocolFeeCollectorUpdated(_protocolFeeCollector);\n    }\n    /\n     * @notice used to update the strategy registry address\n     * @dev can only be updated by owner\n     * @param _strategyRegistry address of the updated strategy registry\n     /\n    function updateStrategyRegistry(address _strategyRegistry) external onlyOwner {\n        _updateStrategyRegistry(_strategyRegistry);\n    }\n    function _updateStrategyRegistry(address _strategyRegistry) internal {\n        require(_strategyRegistry != address(0), \'CL::I zero address\');\n        strategyRegistry = _strategyRegistry;\n        emit StrategyRegistryUpdated(_strategyRegistry);\n    }\n    /\n     * @notice used to update the liquidatorRewardFraction\n     * @dev can only be updated by owner\n     * @param _rewardFraction fraction of liquidated amount given to liquidator as reward\n     /\n    function updateLiquidatorRewardFraction(uint256 _rewardFraction) external onlyOwner {\n        _updateLiquidatorRewardFraction(_rewardFraction);\n    }\n    function _updateLiquidatorRewardFraction(uint256 _rewardFraction) internal {\n        require(_rewardFraction &lt;= 1030, \'Fraction has to be less than 1\');\n        liquidatorRewardFraction = _rewardFraction;\n        emit LiquidationRewardFractionUpdated(_rewardFraction);\n    }\n    /\n     * @dev Used to Calculate Interest Per second on given principal and Interest rate\n     * @param _principal principal Amount for which interest has to be calculated.\n     * @param _borrowRate It is the Interest Rate at which Credit Line is approved\n     * @return interest per second for the given parameters\n     /\n    function calculateInterest(\n        uint256 _principal,\n        uint256 _borrowRate,\n        uint256 _timeElapsed\n    ) public pure returns (uint256) {\n        uint256 _interest = _principal.mul(_borrowRate).mul(_timeElapsed).div(1030).div(YEAR_IN_SECONDS);\n        return _interest;\n    }\n    /\n     * @dev Used to calculate interest accrued since last repayment\n     * @param _id identifier for the credit line\n     * @return interest accrued over current borrowed amount since last repayment\n     /\n    function calculateInterestAccrued(uint256 _id) public view returns (uint256) {\n        uint256 _lastPrincipalUpdateTime = creditLineVariables[_id].lastPrincipalUpdateTime;\n        if (_lastPrincipalUpdateTime == 0) return 0;\n        uint256 _timeElapsed = (block.timestamp).sub(_lastPrincipalUpdateTime);\n        uint256 _interestAccrued = calculateInterest(creditLineVariables[_id].principal, creditLineConstants[_id].borrowRate, _timeElapsed);\n        return _interestAccrued;\n    }\n    /\n     * @dev Used to calculate current debt of borrower against a credit line.\n     * @param _id identifier for the credit line\n     * @return current debt of borrower\n     */\n    function calculateCurrentDebt(uint256 _id) public view returns (uint256) {\n        uint256 _interestAccrued = calculateInterestAccrued(_id);\n        uint256 _currentDebt = (creditLineVariables[_id].principal)\n            .add(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate)\n            .add(_interestAccrued)\n            .sub(creditLineVariables[_id].totalInterestRepaid);\n        return _currentDebt;\n    }\n    /\n     * @notice used to calculate amount that can be borrowed by the borrower\n     * @dev is a view function for the protocol itself, but isn\'t view because of getTokensForShares which is not view.\n            borrowableAmount changes per block as interest changes per block.\n     * @param _id identifier for the credit line\n     * @return amount that can be borrowed from the credit line\n     /\n    function calculateBorrowableAmount(uint256 _id) public returns (uint256) {\n        CreditLineStatus _status = creditLineVariables[_id].status;\n        require(\n            _status == CreditLineStatus.ACTIVE || _status == CreditLineStatus.REQUESTED,\n            \'CreditLine: Cannot only if credit line ACTIVE or REQUESTED\'\n        );\n        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(\n            creditLineConstants[_id].collateralAsset,\n            creditLineConstants[_id].borrowAsset\n        );\n        uint256 _totalCollateralToken = calculateTotalCollateralTokens(_id);\n        uint256 _currentDebt = calculateCurrentDebt(_id);\n        uint256 _maxPossible = _totalCollateralToken.mul(_ratioOfPrices).div(creditLineConstants[_id].idealCollateralRatio).mul(1030).div(\n            10_decimals\n        );\n        uint256 _borrowLimit = creditLineConstants[_id].borrowLimit;\n        if (_maxPossible &gt; _borrowLimit) {\n            _maxPossible = _borrowLimit;\n        }\n        if (_maxPossible &gt; _currentDebt) {\n            return _maxPossible.sub(_currentDebt);\n        }\n        return 0;\n    }\n    function updateinterestAccruedTillLastPrincipalUpdate(uint256 _id) internal {\n        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, \'CreditLine: The credit line is not yet active.\');\n        uint256 _interestAccrued = calculateInterestAccrued(_id);\n        uint256 _newInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(_interestAccrued);\n        creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _newInterestAccrued;\n    }\n    function _depositCollateralFromSavingsAccount(\n        uint256 _id,\n        uint256 _amount,\n        address _sender\n    ) internal {\n        address _collateralAsset = creditLineConstants[_id].collateralAsset;\n        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();\n        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);\n        uint256 _activeAmount;\n        for (uint256 _index = 0; _index &lt; _strategyList.length; _index++) {\n            address _strategy = _strategyList[_index];\n            uint256 _liquidityShares = _savingsAccount.balanceInShares(_sender, _collateralAsset, _strategy);\n            if (_liquidityShares == 0 || _strategyList[_index] == address(0)) {\n                continue;\n            }\n            uint256 _tokenInStrategy = _liquidityShares;\n            _tokenInStrategy = IYield(_strategy).getTokensForShares(_liquidityShares, _collateralAsset);\n            uint256 _tokensToTransfer = _tokenInStrategy;\n            if (_activeAmount.add(_tokenInStrategy) &gt;= _amount) {\n                _tokensToTransfer = (_amount.sub(_activeAmount));\n            }\n            _activeAmount = _activeAmount.add(_tokensToTransfer);\n            _savingsAccount.transferFrom(_tokensToTransfer, _collateralAsset, _strategy, _sender, address(this));\n            collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(\n                _liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy)\n            );\n            if (_amount == _activeAmount) {\n                return;\n            }\n        }\n        revert(\'CreditLine::_depositCollateralFromSavingsAccount - Insufficient balance\');\n    }\n    /\n     * @notice used to request a credit line either by borrower or lender\n     * @param _requestTo Address to which creditLine is requested, \n                        if borrower creates request then lender address and \n                        if lender creates then borrower address\n     * @param _borrowLimit maximum borrow amount in a credit line\n     * @param _borrowRate Interest Rate at which credit Line is requested\n     * @param _autoLiquidation if true, anyone can liquidate loan, otherwise only lender\n     * @param _collateralRatio ratio of the collateral to the debt below which credit line can be liquidated\n     * @param _borrowAsset address of the token to be borrowed\n     * @param _collateralAsset address of the token provided as collateral\n     * @param _requestAsLender if true, lender is placing request, otherwise borrower\n     * @return identifier for the credit line\n     /\n    function request(\n        address _requestTo,\n        uint256 _borrowLimit,\n        uint256 _borrowRate,\n        bool _autoLiquidation,\n        uint256 _collateralRatio,\n        address _borrowAsset,\n        address _collateralAsset,\n        bool _requestAsLender\n    ) external returns (uint256) {\n        require(_borrowAsset != _collateralAsset, \'R: cant borrow lent token\');\n        require(IPriceOracle(priceOracle).doesFeedExist(_borrowAsset, _collateralAsset), \'R: No price feed\');\n        address _lender = _requestTo;\n        address _borrower = msg.sender;\n        if (_requestAsLender) {\n            _lender = msg.sender;\n            _borrower = _requestTo;\n        }\n        uint256 _id = _createRequest(\n            _lender,\n            _borrower,\n            _borrowLimit,\n            _borrowRate,\n            _autoLiquidation,\n            _collateralRatio,\n            _borrowAsset,\n            _collateralAsset,\n            _requestAsLender\n        );\n        emit CreditLineRequested(_id, _lender, _borrower);\n        return _id;\n    }\n    function _createRequest(\n        address _lender,\n        address _borrower,\n        uint256 _borrowLimit,\n        uint256 _borrowRate,\n        bool _autoLiquidation,\n        uint256 _collateralRatio,\n        address _borrowAsset,\n        address _collateralAsset,\n        bool _requestByLender\n    ) internal returns (uint256) {\n        require(_lender != _borrower, \'Lender and Borrower cannot be same addresses\');\n        uint256 _id = creditLineCounter + 1;\n        creditLineCounter = _id;\n        creditLineVariables[_id].status = CreditLineStatus.REQUESTED;\n        creditLineConstants[_id].borrower = _borrower;\n        creditLineConstants[_id].lender = _lender;\n        creditLineConstants[_id].borrowLimit = _borrowLimit;\n        creditLineConstants[_id].autoLiquidation = _autoLiquidation;\n        creditLineConstants[_id].idealCollateralRatio = _collateralRatio;\n        creditLineConstants[_id].borrowRate = _borrowRate;\n        creditLineConstants[_id].borrowAsset = _borrowAsset;\n        creditLineConstants[_id].collateralAsset = _collateralAsset;\n        creditLineConstants[_id].requestByLender = _requestByLender;\n        return _id;\n    }\n    /\n     * @notice used to accept a credit line\n     * @dev if borrower places request, lender can accept and vice versa\n     * @param _id identifier for the credit line\n     */\n    function accept(uint256 _id) external {\n        require(\n            creditLineVariables[_id].status == CreditLineStatus.REQUESTED,\n            \'CreditLine::acceptCreditLineLender - CreditLine is already accepted\'\n        );\n        bool _requestByLender = creditLineConstants[_id].requestByLender;\n        require(\n            (msg.sender == creditLineConstants[_id].borrower &amp;&amp; _requestByLender) ||\n                (msg.sender == creditLineConstants[_id].lender &amp;&amp; !_requestByLender),\n            "Only Borrower or Lender who hasn\'t requested can accept"\n        );\n        creditLineVariables[_id].status = CreditLineStatus.ACTIVE;\n        emit CreditLineAccepted(_id);\n    }\n    /\n     * @notice used to deposit collateral into the credit line\n     * @dev collateral tokens have to be approved in savingsAccount or token contract(unless ether).\n            If transferred from savings account, the tokens are transferred from strategies in the \n            order prespecified in strategy registry\n     * @param _id identifier for the credit line\n     * @param _amount amount of collateral being deposited\n     * @param _strategy strategy to which collateral is to be deposited in case transfer is not from savings account\n     * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount \n                                otherwise direct from collateral token contract\n     /\n    function depositCollateral(\n        uint256 _id,\n        uint256 _amount,\n        address _strategy,\n        bool _fromSavingsAccount\n    ) external payable nonReentrant ifCreditLineExists(_id) {\n        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, \'CreditLine not active\');\n        _depositCollateral(_id, _amount, _strategy, _fromSavingsAccount);\n        emit CollateralDeposited(_id, _amount, _strategy);\n    }\n    function _depositCollateral(\n        uint256 _id,\n        uint256 _amount,\n        address _strategy,\n        bool _fromSavingsAccount\n    ) internal {\n        require(creditLineConstants[_id].lender != msg.sender, \'lender cant deposit collateral\');\n        if (_fromSavingsAccount) {\n            _depositCollateralFromSavingsAccount(_id, _amount, msg.sender);\n        } else {\n            address _collateralAsset = creditLineConstants[_id].collateralAsset;\n            ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);\n            if (_collateralAsset == address(0)) {\n                require(msg.value == _amount, "CreditLine::_depositCollateral - value to transfer doesn\'t match argument");\n            } else {\n                IERC20(_collateralAsset).safeTransferFrom(msg.sender, address(this), _amount);\n                IERC20(_collateralAsset).approve(_strategy, _amount);\n            }\n            uint256 _sharesReceived = _savingsAccount.deposit{value: msg.value}(_amount, _collateralAsset, _strategy, address(this));\n            collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(_sharesReceived);\n        }\n    }\n    function _withdrawBorrowAmount(\n        address _asset,\n        uint256 _amountInTokens,\n        address _lender\n    ) internal {\n        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();\n        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);\n        uint256 _activeAmount;\n        for (uint256 _index = 0; _index &lt; _strategyList.length; _index++) {\n            if (_strategyList[_index] == address(0)) {\n                continue;\n            }\n            uint256 _liquidityShares = _savingsAccount.balanceInShares(_lender, _asset, _strategyList[_index]);\n            if (_liquidityShares != 0) {\n                uint256 tokenInStrategy = _liquidityShares;\n                tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);\n                uint256 _tokensToTransfer = tokenInStrategy;\n                if (_activeAmount.add(tokenInStrategy) &gt;= _amountInTokens) {\n                    _tokensToTransfer = (_amountInTokens.sub(_activeAmount));\n                }\n                _activeAmount = _activeAmount.add(_tokensToTransfer);\n                _savingsAccount.withdrawFrom(_tokensToTransfer, _asset, _strategyList[_index], _lender, address(this), false);\n                if (_activeAmount == _amountInTokens) {\n                    return;\n                }\n            }\n        }\n        require(_activeAmount == _amountInTokens, \'insufficient balance\');\n    }\n    /\n     * @notice used to borrow tokens from credit line by borrower\n     * @dev only borrower can call this function. Amount that can actually be borrowed is \n            min(amount based on borrowLimit, allowance to creditLine contract, balance of lender)\n     * @param _id identifier for the credit line\n     * @param _amount amount of tokens to borrow\n     /\n    function borrow(uint256 _id, uint256 _amount) external payable nonReentrant onlyCreditLineBorrower(_id) {\n        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, \'CreditLine: The credit line is not yet active.\');\n        uint256 _borrowableAmount = calculateBorrowableAmount(_id);\n        require(_amount &lt;= _borrowableAmount, "CreditLine::borrow - The current collateral ratio doesn\'t allow to withdraw the amount");\n        address _borrowAsset = creditLineConstants[_id].borrowAsset;\n        address _lender = creditLineConstants[_id].lender;\n        updateinterestAccruedTillLastPrincipalUpdate(_id);\n        creditLineVariables[_id].principal = creditLineVariables[_id].principal.add(_amount);\n        creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;\n        uint256 _tokenDiffBalance;\n        if (_borrowAsset != address(0)) {\n            uint256 _balanceBefore = IERC20(_borrowAsset).balanceOf(address(this));\n            _withdrawBorrowAmount(_borrowAsset, _amount, _lender);\n            uint256 _balanceAfter = IERC20(_borrowAsset).balanceOf(address(this));\n            _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);\n        } else {\n            uint256 _balanceBefore = address(this).balance;\n            _withdrawBorrowAmount(_borrowAsset, _amount, _lender);\n            uint256 _balanceAfter = address(this).balance;\n            _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);\n        }\n        uint256 _protocolFee = _tokenDiffBalance.mul(protocolFeeFraction).div(1030);\n        _tokenDiffBalance = _tokenDiffBalance.sub(_protocolFee);\n        if (_borrowAsset == address(0)) {\n            (bool feeSuccess, ) = protocolFeeCollector.call{value: _protocolFee}(\'\');\n            require(feeSuccess, \'Transfer fail\');\n            (bool success, ) = msg.sender.call{value: _tokenDiffBalance}(\'\');\n            require(success, \'Transfer fail\');\n        } else {\n            IERC20(_borrowAsset).safeTransfer(protocolFeeCollector, _protocolFee);\n            IERC20(_borrowAsset).safeTransfer(msg.sender, _tokenDiffBalance);\n        }\n        emit BorrowedFromCreditLine(_id, _tokenDiffBalance);\n    }\n    function _repayFromSavingsAccount(\n        uint256 _amount,\n        address _asset,\n        address _lender\n    ) internal {\n        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();\n        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);\n        uint256 _activeAmount;\n        for (uint256 _index = 0; _index &lt; _strategyList.length; _index++) {\n            if (_strategyList[_index] == address(0)) {\n                continue;\n            }\n            uint256 _liquidityShares = _savingsAccount.balanceInShares(msg.sender, _asset, _strategyList[_index]);\n            if (_liquidityShares == 0) {\n                continue;\n            }\n            uint256 _tokenInStrategy = _liquidityShares;\n            _tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);\n            uint256 _tokensToTransfer = _tokenInStrategy;\n            if (_activeAmount.add(_tokenInStrategy) &gt;= _amount) {\n                _tokensToTransfer = (_amount.sub(_activeAmount));\n            }\n            _activeAmount = _activeAmount.add(_tokensToTransfer);\n            _savingsAccount.transferFrom(_tokensToTransfer, _asset, _strategyList[_index], msg.sender, _lender);\n            if (_amount == _activeAmount) {\n                return;\n            }\n        }\n        revert(\'CreditLine::_repayFromSavingsAccount - Insufficient balance\');\n    }\n    function _repay(\n        uint256 _id,\n        uint256 _amount,\n        bool _fromSavingsAccount,\n        uint256 _principalPaid\n    ) internal {\n        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);\n        address _defaultStrategy = defaultStrategy;\n        address _borrowAsset = creditLineConstants[_id].borrowAsset;\n        address _lender = creditLineConstants[_id].lender;\n        if (!_fromSavingsAccount) {\n            if (_borrowAsset == address(0)) {\n                require(msg.value == _amount, \'creditLine::repay - Ether sent not equal to repay amount\');\n                _savingsAccount.deposit{value: _amount}(_amount, _borrowAsset, _defaultStrategy, _lender);\n            } else {\n                IERC20(_borrowAsset).safeTransferFrom(msg.sender, address(this), _amount);\n                IERC20(_borrowAsset).approve(_defaultStrategy, _amount);\n                _savingsAccount.deposit(_amount, _borrowAsset, _defaultStrategy, _lender);\n            }\n        } else {\n            _repayFromSavingsAccount(_amount, _borrowAsset, _lender);\n        }\n        if (_principalPaid != 0) {\n            _savingsAccount.increaseAllowanceToCreditLine(_principalPaid, _borrowAsset, _lender);\n        }\n    }\n    /\n     * @notice used to repay interest and principal to credit line. Interest has to be repaid before repaying principal\n     * @dev partial repayments possible\n     * @param _id identifier for the credit line\n     * @param _amount amount being repaid\n     * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount \n                                otherwise direct from collateral token contract\n     /\n    function repay(\n        uint256 _id,\n        uint256 _amount,\n        bool _fromSavingsAccount\n    ) external payable nonReentrant {\n        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, \'CreditLine: The credit line is not yet active.\');\n        require(creditLineConstants[_id].lender != msg.sender, \'Lender cant repay\');\n        uint256 _interestSincePrincipalUpdate = calculateInterestAccrued(_id);\n        uint256 _totalInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(\n            _interestSincePrincipalUpdate\n        );\n        uint256 _interestToPay = _totalInterestAccrued.sub(creditLineVariables[_id].totalInterestRepaid);\n        uint256 _totalCurrentDebt = _interestToPay.add(creditLineVariables[_id].principal);\n        uint256 _principalPaid = 0;\n        if (_amount &gt;= _totalCurrentDebt) {\n            _amount = _totalCurrentDebt;\n            emit CompleteCreditLineRepaid(_id, _amount);\n        } else {\n            emit PartialCreditLineRepaid(_id, _amount);\n        }\n        if (_amount &gt; _interestToPay) {\n            creditLineVariables[_id].principal = _totalCurrentDebt.sub(_amount);\n            creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _totalInterestAccrued;\n            creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;\n            creditLineVariables[_id].totalInterestRepaid = _totalInterestAccrued;\n            _principalPaid = _amount.sub(_interestToPay);\n        } else {\n            creditLineVariables[_id].totalInterestRepaid = creditLineVariables[_id].totalInterestRepaid.add(_amount);\n        }\n        _repay(_id, _amount, _fromSavingsAccount, _principalPaid);\n        if (creditLineVariables[_id].principal == 0) {\n            _resetCreditLine(_id);\n        }\n    }\n    function _resetCreditLine(uint256 _id) internal {\n        creditLineVariables[_id].lastPrincipalUpdateTime = 0;\n        creditLineVariables[_id].totalInterestRepaid = 0;\n        creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = 0;\n        emit CreditLineReset(_id);\n    }\n    /\n     * @dev used to close credit line by borrower or lender\n     * @param _id identifier for the credit line\n     /\n    function close(uint256 _id) external ifCreditLineExists(_id) {\n        require(\n            msg.sender == creditLineConstants[_id].borrower || msg.sender == creditLineConstants[_id].lender,\n            \'CreditLine: Permission denied while closing Line of credit\'\n        );\n        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, \'CreditLine: Credit line should be active.\');\n        require(creditLineVariables[_id].principal == 0, \'CreditLine: Cannot be closed since not repaid.\');\n        require(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate == 0, \'CreditLine: Cannot be closed since not repaid.\');\n        creditLineVariables[_id].status = CreditLineStatus.CLOSED;\n        emit CreditLineClosed(_id);\n    }\n    /\n     * @notice used to calculate the current collateral ratio\n     * @dev is a view function for the protocol itself, but isn\'t view because of getTokensForShares which is not view.\n            Interest is also considered while calculating debt\n     * @param _id identifier for the credit line\n     * @return collateral ratio multiplied by 1030 to retain precision\n     /\n    function calculateCurrentCollateralRatio(uint256 _id) public ifCreditLineExists(_id) returns (uint256) {\n        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(\n            creditLineConstants[_id].collateralAsset,\n            creditLineConstants[_id].borrowAsset\n        );\n        uint256 currentDebt = calculateCurrentDebt(_id);\n        uint256 currentCollateralRatio = calculateTotalCollateralTokens(_id).mul(_ratioOfPrices).div(currentDebt).mul(1030).div(\n            10_decimals\n        );\n        return currentCollateralRatio;\n    }\n    /\n     * @notice used to calculate the total collateral tokens\n     * @dev is a view function for the protocol itself, but isn\'t view because of getTokensForShares which is not view\n     * @param _id identifier for the credit line\n     * @return _amount total collateral tokens deposited into the credit line\n     /\n    function calculateTotalCollateralTokens(uint256 _id) public returns (uint256 _amount) {\n        address _collateralAsset = creditLineConstants[_id].collateralAsset;\n        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();\n        uint256 _liquidityShares;\n        for (uint256 index = 0; index &lt; _strategyList.length; index++) {\n            if (_strategyList[index] == address(0)) {\n                continue;\n            }\n            _liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];\n            uint256 _tokenInStrategy = _liquidityShares;\n            _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(_liquidityShares, _collateralAsset);\n            _amount = _amount.add(_tokenInStrategy);\n        }\n    }\n    /\n     * @notice used to withdraw any excess collateral\n     * @dev collateral can\'t be withdraw if collateralRatio goes below the ideal value. Only borrower can withdraw\n     * @param _id identifier for the credit line\n     * @param _amount amount of collateral to withdraw\n     * @param _toSavingsAccount if true, tokens are transferred from savingsAccount \n                                otherwise direct from collateral token contract\n     */\n    function withdrawCollateral(\n        uint256 _id,\n        uint256 _amount,\n        bool _toSavingsAccount\n    ) external nonReentrant onlyCreditLineBorrower(_id) {\n        uint256 _withdrawableCollateral = withdrawableCollateral(_id);\n        require(_amount &lt;= _withdrawableCollateral, \'Collateral ratio cant go below ideal\');\n        address _collateralAsset = creditLineConstants[_id].collateralAsset;\n        _transferCollateral(_id, _collateralAsset, _amount, _toSavingsAccount);\n        emit CollateralWithdrawn(_id, _amount);\n    }\n    /\n     * @notice used to calculate the collateral that can be withdrawn\n     * @dev is a view function for the protocol itself, but isn\'t view because of getTokensForShares which is not view\n     * @param _id identifier for the credit line\n     * @return total collateral withdrawable by borrower\n     /\n    function withdrawableCollateral(uint256 _id) public returns (uint256) {\n        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(\n            creditLineConstants[_id].collateralAsset,\n            creditLineConstants[_id].borrowAsset\n        );\n        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);\n        uint256 _currentDebt = calculateCurrentDebt(_id);\n        uint256 _collateralNeeded = _currentDebt\n            .mul(creditLineConstants[_id].idealCollateralRatio)\n            .div(_ratioOfPrices)\n            .mul(10_decimals)\n            .div(1030);\n        if (_collateralNeeded &gt;= _totalCollateralTokens) {\n            return 0;\n        }\n        return _totalCollateralTokens.sub(_collateralNeeded);\n    }\n    function _transferCollateral(\n        uint256 _id,\n        address _asset,\n        uint256 _amountInTokens,\n        bool _toSavingsAccount\n    ) internal {\n        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();\n        uint256 _activeAmount;\n        for (uint256 index = 0; index &lt; _strategyList.length; index++) {\n            uint256 liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];\n            if (liquidityShares == 0 || _strategyList[index] == address(0)) {\n                continue;\n            }\n            uint256 _tokenInStrategy = liquidityShares;\n            _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(liquidityShares, _asset);\n            uint256 _tokensToTransfer = _tokenInStrategy;\n            if (_activeAmount.add(_tokenInStrategy) &gt; _amountInTokens) {\n                _tokensToTransfer = _amountInTokens.sub(_activeAmount);\n                liquidityShares = liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy);\n            }\n            _activeAmount = _activeAmount.add(_tokensToTransfer);\n            collateralShareInStrategy[_id][_strategyList[index]] = collateralShareInStrategy[_id][_strategyList[index]].sub(\n                liquidityShares\n            );\n            if (_toSavingsAccount) {\n                ISavingsAccount(savingsAccount).transfer(_tokensToTransfer, _asset, _strategyList[index], msg.sender);\n            } else {\n                ISavingsAccount(savingsAccount).withdraw(_tokensToTransfer, _asset, _strategyList[index], msg.sender, false);\n            }\n            if (_activeAmount == _amountInTokens) {\n                return;\n            }\n        }\n        revert(\'insufficient collateral\');\n    }\n    /\n     * @notice used to liquidate credit line in case collateral ratio goes below the threshold\n     * @dev if lender liquidates, then collateral is directly transferred. \n            If autoLiquidation is true, anyone can liquidate by providing enough borrow tokens\n     * @param _id identifier for the credit line\n     * @param _toSavingsAccount if true, tokens are transferred from savingsAccount \n                                otherwise direct from collateral token contract\n     /\n    function liquidate(uint256 _id, bool _toSavingsAccount) external payable nonReentrant {\n        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, \'CreditLine: Credit line should be active.\');\n        require(creditLineVariables[_id].principal != 0, \'CreditLine: cannot liquidate if principal is 0\');\n        uint256 currentCollateralRatio = calculateCurrentCollateralRatio(_id);\n        require(\n            currentCollateralRatio &lt; creditLineConstants[_id].idealCollateralRatio,\n            \'CreditLine: Collateral ratio is higher than ideal value\'\n        );\n        address _collateralAsset = creditLineConstants[_id].collateralAsset;\n        address _lender = creditLineConstants[_id].lender;\n        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);\n        address _borrowAsset = creditLineConstants[_id].borrowAsset;\n        creditLineVariables[_id].status = CreditLineStatus.LIQUIDATED;\n        if (creditLineConstants[_id].autoLiquidation &amp;&amp; _lender != msg.sender) {\n            uint256 _borrowTokens = _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens);\n            if (_borrowAsset == address(0)) {\n                uint256 _returnETH = msg.value.sub(_borrowTokens, \'Insufficient ETH to liquidate\');\n                if (_returnETH != 0) {\n                    (bool success, ) = msg.sender.call{value: _returnETH}(\'\');\n                    require(success, \'Transfer fail\');\n                }\n            } else {\n                IERC20(_borrowAsset).safeTransferFrom(msg.sender, _lender, _borrowTokens);\n            }\n        }\n        _transferCollateral(_id, _collateralAsset, _totalCollateralTokens, _toSavingsAccount);\n        emit CreditLineLiquidated(_id, msg.sender);\n    }\n    /\n     * @notice used to calculate the borrow tokens necessary for liquidator to liquidate\n     * @dev is a view function for the protocol itself, but isn\'t view because of getTokensForShares which is not view\n     * @param _id identifier for the credit line\n     * @return borrow tokens necessary for liquidator to liquidate\n     */\n    function borrowTokensToLiquidate(uint256 _id) external returns (uint256) {\n        address _collateralAsset = creditLineConstants[_id].collateralAsset;\n        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);\n        address _borrowAsset = creditLineConstants[_id].borrowAsset;\n        return _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens);\n    }\n    function _borrowTokensToLiquidate(\n        address _borrowAsset,\n        address _collateralAsset,\n        uint256 _totalCollateralTokens\n    ) internal view returns (uint256) {\n        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(_borrowAsset, _collateralAsset);\n        uint256 _borrowTokens = (\n            _totalCollateralTokens.mul(uint256(1030).sub(liquidatorRewardFraction)).div(1030).mul(_ratioOfPrices).div(10_decimals)\n        );\n        return _borrowTokens;\n    }\n    receive() external payable {\n        require(msg.sender == savingsAccount, \'CreditLine::receive invalid transaction\');\n    }\n}\n".\nAs the Security Analyst, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user.\nNote that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we\'ve collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with , followed directly by the final idea or enhancement suggestion, e.g. " Implementing a multi-sig wallet mechanism for added security in transactions".\n\nSecurity Analyst: Let\'s', 'question': 'Answer their Solidity smart contract ideas in the discussion without any other words, e.g., "A smart contract where we talk about Security: What functions the contract performs" '} |
| **need_reflect** | False |
| **memory** | No existed memory |
| **chat_turn_limit** | 1 |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-22-08 11:43:02 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Chief Executive Officer |
| **user_role_name** | Counselor |
| **assistant_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Counselor. Now, we share a common interest in collaborating to successfully complete a task assigned by a new customer. Your main responsibilities include asking what user and customer think and provide your valuable suggestions.  Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol'; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/utils/ReentrancyGuard.sol'; import '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol'; import '../interfaces/IPriceOracle.sol'; import '../interfaces/IYield.sol'; import '../interfaces/ISavingsAccount.sol'; import '../SavingsAccount/SavingsAccountUtil.sol'; import '../interfaces/IStrategyRegistry.sol'; /  * @title Credit Line contract with Methods related to credit Line  * @notice Implements the functions related to Credit Line  * @author Sublime  / contract CreditLine is ReentrancyGuard, OwnableUpgradeable {     using SafeERC20 for IERC20;     using SafeMath for uint256; enum CreditLineStatus {     NOT_CREATED,     REQUESTED,     ACTIVE,     CLOSED,     CANCELLED,     LIQUIDATED }  /**  * @notice counter that tracks the number of credit lines created  * @dev used to create unique identifier for credit lines  **/ uint256 public creditLineCounter;  uint256 constant YEAR_IN_SECONDS = 365 days;  struct CreditLineVariables {     CreditLineStatus status;     uint256 principal;     uint256 totalInterestRepaid;     uint256 lastPrincipalUpdateTime;     uint256 interestAccruedTillLastPrincipalUpdate; }  struct CreditLineConstants {     address lender;     address borrower;     uint256 borrowLimit;     uint256 idealCollateralRatio;     uint256 borrowRate;     address borrowAsset;     address collateralAsset;     bool autoLiquidation;     bool requestByLender; } /**  * @notice stores the collateral shares in a credit line per strategy  * @dev creditLineId =&gt; Strategy =&gt; collateralShares  **/ mapping(uint256 =&gt; mapping(address =&gt; uint256)) public collateralShareInStrategy;  /**  * @notice stores the variables to maintain a credit line  **/ mapping(uint256 =&gt; CreditLineVariables) public creditLineVariables;  /**  * @notice stores the constants related to a credit line  **/ mapping(uint256 =&gt; CreditLineConstants) public creditLineConstants;  /**  * @notice stores the address of savings account contract  **/ address public savingsAccount;  /**  * @notice stores the address of price oracle contract  **/ address public priceOracle;  /**  * @notice stores the address of strategy registry contract  **/ address public strategyRegistry;  /**  * @notice stores the address of default strategy  **/ address public defaultStrategy;  /**  * @notice stores the fraction of borrowed amount charged as fee by protocol  * @dev it is multiplied by 10**30  **/ uint256 public protocolFeeFraction;  /**  * @notice address where protocol fee is collected  **/ address public protocolFeeCollector;  /**  * @notice stores the fraction of amount liquidated given as reward to liquidator  * @dev it is multiplied by 10**30  **/ uint256 public liquidatorRewardFraction; /**  * @dev checks if Credit Line exists  * @param _id identifier for the credit line  **/ modifier ifCreditLineExists(uint256 _id) {     require(creditLineVariables[_id].status != CreditLineStatus.NOT_CREATED, 'Credit line does not exist');     _; }  /**  * @dev checks if called by credit Line Borrower  * @param _id creditLine identifier  **/ modifier onlyCreditLineBorrower(uint256 _id) {     require(creditLineConstants[_id].borrower == msg.sender, 'Only credit line Borrower can access');     _; }  /**  * @dev checks if called by credit Line Lender  * @param _id creditLine identifier  **/ modifier onlyCreditLineLender(uint256 _id) {     require(creditLineConstants[_id].lender == msg.sender, 'Only credit line Lender can access');     _; }  /**  * @notice emitted when a collateral is deposited into credit line  * @param id id of the credit line  * @param amount amount of collateral deposited  * @param strategy address of the strategy into which collateral is deposited  */ event CollateralDeposited(uint256 indexed id, uint256 amount, address indexed strategy);  /**  * @notice emitted when collateral is withdrawn from credit line  * @param id id of the credit line  * @param amount amount of collateral withdrawn  */ event CollateralWithdrawn(uint256 indexed id, uint256 amount);  /**  * @notice emitted when a request for new credit line is placed  * @param id id of the credit line for which request was made  * @param lender address of the lender for credit line  * @param borrower address of the borrower for credit line  */ event CreditLineRequested(uint256 indexed id, address indexed lender, address indexed borrower);  /**  * @notice emitted when a credit line is liquidated  * @param id id of the credit line which is liquidated  * @param liquidator address of the liquidator  */ event CreditLineLiquidated(uint256 indexed id, address indexed liquidator);  /**  * @notice emitted when tokens are borrowed from credit line  * @param id id of the credit line from which tokens are borrowed  * @param borrowAmount amount of tokens borrowed  */ event BorrowedFromCreditLine(uint256 indexed id, uint256 borrowAmount);  /**  * @notice emitted when credit line is accepted  * @param id id of the credit line that was accepted  */ event CreditLineAccepted(uint256 indexed id);  /**  * @notice emitted when credit line is completely repaid and reset  * @param id id of the credit line that is reset  */ event CreditLineReset(uint256 indexed id);  /**  * @notice emitted when the credit line is partially repaid  * @param id id of the credit line  * @param repayAmount amount repaid  */ event PartialCreditLineRepaid(uint256 indexed id, uint256 repayAmount);  /**  * @notice emitted when the credit line is completely repaid  * @param id id of the credit line  * @param repayAmount amount repaid  */ event CompleteCreditLineRepaid(uint256 indexed id, uint256 repayAmount);  /**  * @notice emitted when the credit line is closed by one of the parties of credit line  * @param id id of the credit line  */ event CreditLineClosed(uint256 indexed id);  /**  * @notice emitted when default strategy for the credit line is updated  * @param defaultStrategy address of the strategy contract that is used as default by credit lines  */ event DefaultStrategyUpdated(address indexed defaultStrategy);  /**  * @notice emitted when the price oracle is updated  * @param priceOracle address of the updated price oracle  */ event PriceOracleUpdated(address indexed priceOracle);  /**  * @notice emitted when the savings account address is updated  * @param savingsAccount address of the updated savingsAccount  */ event SavingsAccountUpdated(address indexed savingsAccount);  /**  * @notice emitted when strategy registry address is updated  * @param strategyRegistry address of the updated strategy registry  */ event StrategyRegistryUpdated(address indexed strategyRegistry);  /**  * @notice emitted when fee that protocol charges for credit line is updated  * @param updatedProtocolFee updated value of protocolFeeFraction  */ event ProtocolFeeFractionUpdated(uint256 updatedProtocolFee);  /**  * @notice emitted when address which receives fee that protocol changes for pools is updated  * @param updatedProtocolFeeCollector updated value of protocolFeeCollector  */ event ProtocolFeeCollectorUpdated(address indexed updatedProtocolFeeCollector);  /**  * @notice emitted when liquidatorRewardFraction is updated  * @param liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator  */ event LiquidationRewardFractionUpdated(uint256 liquidatorRewardFraction);  /**  * @notice used to initialize the contract  * @dev can only be called once during the life cycle of the contract  * @param _defaultStrategy default strategy used in credit lines  * @param _priceOracle address of the priceOracle  * @param _savingsAccount address of  the savings account contract  * @param _strategyRegistry address of the strategy registry contract  * @param _owner address of owner who can change global variables  * @param _protocolFeeFraction fraction of the fee charged by protocol  * @param _protocolFeeCollector address to which protocol fee is charged to  * @param _liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator  */ function initialize(     address _defaultStrategy,     address _priceOracle,     address _savingsAccount,     address _strategyRegistry,     address _owner,     uint256 _protocolFeeFraction,     address _protocolFeeCollector,     uint256 _liquidatorRewardFraction ) external initializer {     OwnableUpgradeable.__Ownable_init();     OwnableUpgradeable.transferOwnership(_owner);      _updateDefaultStrategy(_defaultStrategy);     _updatePriceOracle(_priceOracle);     _updateSavingsAccount(_savingsAccount);     _updateStrategyRegistry(_strategyRegistry);     _updateProtocolFeeFraction(_protocolFeeFraction);     _updateProtocolFeeCollector(_protocolFeeCollector);     _updateLiquidatorRewardFraction(_liquidatorRewardFraction); }  /**  * @notice used to update the default strategy  * @dev can only be updated by owner  * @param _defaultStrategy address of the updated default strategy  */ function updateDefaultStrategy(address _defaultStrategy) external onlyOwner {     _updateDefaultStrategy(_defaultStrategy); }  function _updateDefaultStrategy(address _defaultStrategy) internal {     defaultStrategy = _defaultStrategy;     emit DefaultStrategyUpdated(_defaultStrategy); }  /**  * @notice used to update the price oracle  * @dev can only be updated by owner  * @param _priceOracle address of the updated price oracle  */ function updatePriceOracle(address _priceOracle) external onlyOwner {     _updatePriceOracle(_priceOracle); }  function _updatePriceOracle(address _priceOracle) internal {     priceOracle = _priceOracle;     emit PriceOracleUpdated(_priceOracle); }  /**  * @notice used to update the savings account address  * @dev can only be updated by owner  * @param _savingsAccount address of the updated savings account  */ function updateSavingsAccount(address _savingsAccount) external onlyOwner {     _updateSavingsAccount(_savingsAccount); }  function _updateSavingsAccount(address _savingsAccount) internal {     savingsAccount = _savingsAccount;     emit SavingsAccountUpdated(_savingsAccount); }  /**  * @notice used to update the protocol fee fraction  * @dev can only be updated by owner  * @param _protocolFee fraction of the borrower amount collected as protocol fee  */ function updateProtocolFeeFraction(uint256 _protocolFee) external onlyOwner {     _updateProtocolFeeFraction(_protocolFee); }  function _updateProtocolFeeFraction(uint256 _protocolFee) internal {     protocolFeeFraction = _protocolFee;     emit ProtocolFeeFractionUpdated(_protocolFee); }  /**  * @notice used to update the protocol fee collector  * @dev can only be updated by owner  * @param _protocolFeeCollector address in which protocol fee is collected  */ function updateProtocolFeeCollector(address _protocolFeeCollector) external onlyOwner {     _updateProtocolFeeCollector(_protocolFeeCollector); }  function _updateProtocolFeeCollector(address _protocolFeeCollector) internal {     require(_protocolFeeCollector != address(0), 'cant be 0 address');     protocolFeeCollector = _protocolFeeCollector;     emit ProtocolFeeCollectorUpdated(_protocolFeeCollector); }  /**  * @notice used to update the strategy registry address  * @dev can only be updated by owner  * @param _strategyRegistry address of the updated strategy registry  */ function updateStrategyRegistry(address _strategyRegistry) external onlyOwner {     _updateStrategyRegistry(_strategyRegistry); }  function _updateStrategyRegistry(address _strategyRegistry) internal {     require(_strategyRegistry != address(0), 'CL::I zero address');     strategyRegistry = _strategyRegistry;     emit StrategyRegistryUpdated(_strategyRegistry); }  /**  * @notice used to update the liquidatorRewardFraction  * @dev can only be updated by owner  * @param _rewardFraction fraction of liquidated amount given to liquidator as reward  */ function updateLiquidatorRewardFraction(uint256 _rewardFraction) external onlyOwner {     _updateLiquidatorRewardFraction(_rewardFraction); }  function _updateLiquidatorRewardFraction(uint256 _rewardFraction) internal {     require(_rewardFraction &lt;= 10**30, 'Fraction has to be less than 1');     liquidatorRewardFraction = _rewardFraction;     emit LiquidationRewardFractionUpdated(_rewardFraction); }  /**  * @dev Used to Calculate Interest Per second on given principal and Interest rate  * @param _principal principal Amount for which interest has to be calculated.  * @param _borrowRate It is the Interest Rate at which Credit Line is approved  * @return interest per second for the given parameters  */ function calculateInterest(     uint256 _principal,     uint256 _borrowRate,     uint256 _timeElapsed ) public pure returns (uint256) {     uint256 _interest = _principal.mul(_borrowRate).mul(_timeElapsed).div(10**30).div(YEAR_IN_SECONDS);      return _interest; }  /**  * @dev Used to calculate interest accrued since last repayment  * @param _id identifier for the credit line  * @return interest accrued over current borrowed amount since last repayment  */  function calculateInterestAccrued(uint256 _id) public view returns (uint256) {     uint256 _lastPrincipalUpdateTime = creditLineVariables[_id].lastPrincipalUpdateTime;     if (_lastPrincipalUpdateTime == 0) return 0;     uint256 _timeElapsed = (block.timestamp).sub(_lastPrincipalUpdateTime);     uint256 _interestAccrued = calculateInterest(creditLineVariables[_id].principal, creditLineConstants[_id].borrowRate, _timeElapsed);     return _interestAccrued; }  /**  * @dev Used to calculate current debt of borrower against a credit line.  * @param _id identifier for the credit line  * @return current debt of borrower  */ function calculateCurrentDebt(uint256 _id) public view returns (uint256) {     uint256 _interestAccrued = calculateInterestAccrued(_id);     uint256 _currentDebt = (creditLineVariables[_id].principal)         .add(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate)         .add(_interestAccrued)         .sub(creditLineVariables[_id].totalInterestRepaid);     return _currentDebt; }  /**  * @notice used to calculate amount that can be borrowed by the borrower  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view.         borrowableAmount changes per block as interest changes per block.  * @param _id identifier for the credit line  * @return amount that can be borrowed from the credit line  */ function calculateBorrowableAmount(uint256 _id) public returns (uint256) {     CreditLineStatus _status = creditLineVariables[_id].status;     require(         _status == CreditLineStatus.ACTIVE || _status == CreditLineStatus.REQUESTED,         'CreditLine: Cannot only if credit line ACTIVE or REQUESTED'     );     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(         creditLineConstants[_id].collateralAsset,         creditLineConstants[_id].borrowAsset     );      uint256 _totalCollateralToken = calculateTotalCollateralTokens(_id);      uint256 _currentDebt = calculateCurrentDebt(_id);      uint256 _maxPossible = _totalCollateralToken.mul(_ratioOfPrices).div(creditLineConstants[_id].idealCollateralRatio).mul(10**30).div(         10**_decimals     );      uint256 _borrowLimit = creditLineConstants[_id].borrowLimit;      if (_maxPossible &gt; _borrowLimit) {         _maxPossible = _borrowLimit;     }     if (_maxPossible &gt; _currentDebt) {         return _maxPossible.sub(_currentDebt);     }     return 0; }  function updateinterestAccruedTillLastPrincipalUpdate(uint256 _id) internal {     require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');      uint256 _interestAccrued = calculateInterestAccrued(_id);     uint256 _newInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(_interestAccrued);     creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _newInterestAccrued; }  function _depositCollateralFromSavingsAccount(     uint256 _id,     uint256 _amount,     address _sender ) internal {     address _collateralAsset = creditLineConstants[_id].collateralAsset;     address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();     ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);     uint256 _activeAmount;      for (uint256 _index = 0; _index &lt; _strategyList.length; _index++) {         address _strategy = _strategyList[_index];         uint256 _liquidityShares = _savingsAccount.balanceInShares(_sender, _collateralAsset, _strategy);         if (_liquidityShares == 0 || _strategyList[_index] == address(0)) {             continue;         }         uint256 _tokenInStrategy = _liquidityShares;         _tokenInStrategy = IYield(_strategy).getTokensForShares(_liquidityShares, _collateralAsset);          uint256 _tokensToTransfer = _tokenInStrategy;         if (_activeAmount.add(_tokenInStrategy) &gt;= _amount) {             _tokensToTransfer = (_amount.sub(_activeAmount));         }         _activeAmount = _activeAmount.add(_tokensToTransfer);         _savingsAccount.transferFrom(_tokensToTransfer, _collateralAsset, _strategy, _sender, address(this));          collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(             _liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy)         );          if (_amount == _activeAmount) {             return;         }     }     revert('CreditLine::_depositCollateralFromSavingsAccount - Insufficient balance'); }  /**  * @notice used to request a credit line either by borrower or lender  * @param _requestTo Address to which creditLine is requested,                      if borrower creates request then lender address and                      if lender creates then borrower address  * @param _borrowLimit maximum borrow amount in a credit line  * @param _borrowRate Interest Rate at which credit Line is requested  * @param _autoLiquidation if true, anyone can liquidate loan, otherwise only lender  * @param _collateralRatio ratio of the collateral to the debt below which credit line can be liquidated  * @param _borrowAsset address of the token to be borrowed  * @param _collateralAsset address of the token provided as collateral  * @param _requestAsLender if true, lender is placing request, otherwise borrower  * @return identifier for the credit line  */  function request(     address _requestTo,     uint256 _borrowLimit,     uint256 _borrowRate,     bool _autoLiquidation,     uint256 _collateralRatio,     address _borrowAsset,     address _collateralAsset,     bool _requestAsLender ) external returns (uint256) {     require(_borrowAsset != _collateralAsset, 'R: cant borrow lent token');     require(IPriceOracle(priceOracle).doesFeedExist(_borrowAsset, _collateralAsset), 'R: No price feed');      address _lender = _requestTo;     address _borrower = msg.sender;     if (_requestAsLender) {         _lender = msg.sender;         _borrower = _requestTo;     }      uint256 _id = _createRequest(         _lender,         _borrower,         _borrowLimit,         _borrowRate,         _autoLiquidation,         _collateralRatio,         _borrowAsset,         _collateralAsset,         _requestAsLender     );      emit CreditLineRequested(_id, _lender, _borrower);     return _id; }  function _createRequest(     address _lender,     address _borrower,     uint256 _borrowLimit,     uint256 _borrowRate,     bool _autoLiquidation,     uint256 _collateralRatio,     address _borrowAsset,     address _collateralAsset,     bool _requestByLender ) internal returns (uint256) {     require(_lender != _borrower, 'Lender and Borrower cannot be same addresses');     uint256 _id = creditLineCounter + 1;     creditLineCounter = _id;     creditLineVariables[_id].status = CreditLineStatus.REQUESTED;     creditLineConstants[_id].borrower = _borrower;     creditLineConstants[_id].lender = _lender;     creditLineConstants[_id].borrowLimit = _borrowLimit;     creditLineConstants[_id].autoLiquidation = _autoLiquidation;     creditLineConstants[_id].idealCollateralRatio = _collateralRatio;     creditLineConstants[_id].borrowRate = _borrowRate;     creditLineConstants[_id].borrowAsset = _borrowAsset;     creditLineConstants[_id].collateralAsset = _collateralAsset;     creditLineConstants[_id].requestByLender = _requestByLender;     return _id; }  /**  * @notice used to accept a credit line  * @dev if borrower places request, lender can accept and vice versa  * @param _id identifier for the credit line  */ function accept(uint256 _id) external {     require(         creditLineVariables[_id].status == CreditLineStatus.REQUESTED,         'CreditLine::acceptCreditLineLender - CreditLine is already accepted'     );     bool _requestByLender = creditLineConstants[_id].requestByLender;     require(         (msg.sender == creditLineConstants[_id].borrower &amp;&amp; _requestByLender) ||             (msg.sender == creditLineConstants[_id].lender &amp;&amp; !_requestByLender),         "Only Borrower or Lender who hasn't requested can accept"     );     creditLineVariables[_id].status = CreditLineStatus.ACTIVE;     emit CreditLineAccepted(_id); }  /**  * @notice used to deposit collateral into the credit line  * @dev collateral tokens have to be approved in savingsAccount or token contract(unless ether).         If transferred from savings account, the tokens are transferred from strategies in the          order prespecified in strategy registry  * @param _id identifier for the credit line  * @param _amount amount of collateral being deposited  * @param _strategy strategy to which collateral is to be deposited in case transfer is not from savings account  * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount                              otherwise direct from collateral token contract  */ function depositCollateral(     uint256 _id,     uint256 _amount,     address _strategy,     bool _fromSavingsAccount ) external payable nonReentrant ifCreditLineExists(_id) {     require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine not active');     _depositCollateral(_id, _amount, _strategy, _fromSavingsAccount);     emit CollateralDeposited(_id, _amount, _strategy); }  function _depositCollateral(     uint256 _id,     uint256 _amount,     address _strategy,     bool _fromSavingsAccount ) internal {     require(creditLineConstants[_id].lender != msg.sender, 'lender cant deposit collateral');     if (_fromSavingsAccount) {         _depositCollateralFromSavingsAccount(_id, _amount, msg.sender);     } else {         address _collateralAsset = creditLineConstants[_id].collateralAsset;         ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);         if (_collateralAsset == address(0)) {             require(msg.value == _amount, "CreditLine::_depositCollateral - value to transfer doesn't match argument");         } else {             IERC20(_collateralAsset).safeTransferFrom(msg.sender, address(this), _amount);             IERC20(_collateralAsset).approve(_strategy, _amount);         }         uint256 _sharesReceived = _savingsAccount.deposit{value: msg.value}(_amount, _collateralAsset, _strategy, address(this));         collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(_sharesReceived);     } }  function _withdrawBorrowAmount(     address _asset,     uint256 _amountInTokens,     address _lender ) internal {     address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();     ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);     uint256 _activeAmount;     for (uint256 _index = 0; _index &lt; _strategyList.length; _index++) {         if (_strategyList[_index] == address(0)) {             continue;         }         uint256 _liquidityShares = _savingsAccount.balanceInShares(_lender, _asset, _strategyList[_index]);         if (_liquidityShares != 0) {             uint256 tokenInStrategy = _liquidityShares;             tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);             uint256 _tokensToTransfer = tokenInStrategy;             if (_activeAmount.add(tokenInStrategy) &gt;= _amountInTokens) {                 _tokensToTransfer = (_amountInTokens.sub(_activeAmount));             }             _activeAmount = _activeAmount.add(_tokensToTransfer);             _savingsAccount.withdrawFrom(_tokensToTransfer, _asset, _strategyList[_index], _lender, address(this), false);             if (_activeAmount == _amountInTokens) {                 return;             }         }     }     require(_activeAmount == _amountInTokens, 'insufficient balance'); }  /**  * @notice used to borrow tokens from credit line by borrower  * @dev only borrower can call this function. Amount that can actually be borrowed is          min(amount based on borrowLimit, allowance to creditLine contract, balance of lender)  * @param _id identifier for the credit line  * @param _amount amount of tokens to borrow  */ function borrow(uint256 _id, uint256 _amount) external payable nonReentrant onlyCreditLineBorrower(_id) {     require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');     uint256 _borrowableAmount = calculateBorrowableAmount(_id);     require(_amount &lt;= _borrowableAmount, "CreditLine::borrow - The current collateral ratio doesn't allow to withdraw the amount");     address _borrowAsset = creditLineConstants[_id].borrowAsset;     address _lender = creditLineConstants[_id].lender;      updateinterestAccruedTillLastPrincipalUpdate(_id);     creditLineVariables[_id].principal = creditLineVariables[_id].principal.add(_amount);     creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;      uint256 _tokenDiffBalance;     if (_borrowAsset != address(0)) {         uint256 _balanceBefore = IERC20(_borrowAsset).balanceOf(address(this));         _withdrawBorrowAmount(_borrowAsset, _amount, _lender);         uint256 _balanceAfter = IERC20(_borrowAsset).balanceOf(address(this));         _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);     } else {         uint256 _balanceBefore = address(this).balance;         _withdrawBorrowAmount(_borrowAsset, _amount, _lender);         uint256 _balanceAfter = address(this).balance;         _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);     }     uint256 _protocolFee = _tokenDiffBalance.mul(protocolFeeFraction).div(10**30);     _tokenDiffBalance = _tokenDiffBalance.sub(_protocolFee);      if (_borrowAsset == address(0)) {         (bool feeSuccess, ) = protocolFeeCollector.call{value: _protocolFee}('');         require(feeSuccess, 'Transfer fail');         (bool success, ) = msg.sender.call{value: _tokenDiffBalance}('');         require(success, 'Transfer fail');     } else {         IERC20(_borrowAsset).safeTransfer(protocolFeeCollector, _protocolFee);         IERC20(_borrowAsset).safeTransfer(msg.sender, _tokenDiffBalance);     }     emit BorrowedFromCreditLine(_id, _tokenDiffBalance); }  function _repayFromSavingsAccount(     uint256 _amount,     address _asset,     address _lender ) internal {     address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();     ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);     uint256 _activeAmount;      for (uint256 _index = 0; _index &lt; _strategyList.length; _index++) {         if (_strategyList[_index] == address(0)) {             continue;         }         uint256 _liquidityShares = _savingsAccount.balanceInShares(msg.sender, _asset, _strategyList[_index]);         if (_liquidityShares == 0) {             continue;         }         uint256 _tokenInStrategy = _liquidityShares;         _tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);          uint256 _tokensToTransfer = _tokenInStrategy;         if (_activeAmount.add(_tokenInStrategy) &gt;= _amount) {             _tokensToTransfer = (_amount.sub(_activeAmount));         }         _activeAmount = _activeAmount.add(_tokensToTransfer);         _savingsAccount.transferFrom(_tokensToTransfer, _asset, _strategyList[_index], msg.sender, _lender);          if (_amount == _activeAmount) {             return;         }     }     revert('CreditLine::_repayFromSavingsAccount - Insufficient balance'); }  function _repay(     uint256 _id,     uint256 _amount,     bool _fromSavingsAccount,     uint256 _principalPaid ) internal {     ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);     address _defaultStrategy = defaultStrategy;     address _borrowAsset = creditLineConstants[_id].borrowAsset;     address _lender = creditLineConstants[_id].lender;     if (!_fromSavingsAccount) {         if (_borrowAsset == address(0)) {             require(msg.value == _amount, 'creditLine::repay - Ether sent not equal to repay amount');             _savingsAccount.deposit{value: _amount}(_amount, _borrowAsset, _defaultStrategy, _lender);         } else {             IERC20(_borrowAsset).safeTransferFrom(msg.sender, address(this), _amount);             IERC20(_borrowAsset).approve(_defaultStrategy, _amount);             _savingsAccount.deposit(_amount, _borrowAsset, _defaultStrategy, _lender);         }     } else {         _repayFromSavingsAccount(_amount, _borrowAsset, _lender);     }     if (_principalPaid != 0) {         _savingsAccount.increaseAllowanceToCreditLine(_principalPaid, _borrowAsset, _lender);     } }  /**  * @notice used to repay interest and principal to credit line. Interest has to be repaid before repaying principal  * @dev partial repayments possible  * @param _id identifier for the credit line  * @param _amount amount being repaid  * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount                              otherwise direct from collateral token contract  */ function repay(     uint256 _id,     uint256 _amount,     bool _fromSavingsAccount ) external payable nonReentrant {     require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');     require(creditLineConstants[_id].lender != msg.sender, 'Lender cant repay');      uint256 _interestSincePrincipalUpdate = calculateInterestAccrued(_id);     uint256 _totalInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(         _interestSincePrincipalUpdate     );     uint256 _interestToPay = _totalInterestAccrued.sub(creditLineVariables[_id].totalInterestRepaid);     uint256 _totalCurrentDebt = _interestToPay.add(creditLineVariables[_id].principal);     uint256 _principalPaid = 0;      if (_amount &gt;= _totalCurrentDebt) {         _amount = _totalCurrentDebt;         emit CompleteCreditLineRepaid(_id, _amount);     } else {         emit PartialCreditLineRepaid(_id, _amount);     }      if (_amount &gt; _interestToPay) {         creditLineVariables[_id].principal = _totalCurrentDebt.sub(_amount);         creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _totalInterestAccrued;         creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;         creditLineVariables[_id].totalInterestRepaid = _totalInterestAccrued;         _principalPaid = _amount.sub(_interestToPay);     } else {         creditLineVariables[_id].totalInterestRepaid = creditLineVariables[_id].totalInterestRepaid.add(_amount);     }      _repay(_id, _amount, _fromSavingsAccount, _principalPaid);      if (creditLineVariables[_id].principal == 0) {         _resetCreditLine(_id);     } }  function _resetCreditLine(uint256 _id) internal {     creditLineVariables[_id].lastPrincipalUpdateTime = 0;     creditLineVariables[_id].totalInterestRepaid = 0;     creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = 0;     emit CreditLineReset(_id); }  /**  * @dev used to close credit line by borrower or lender  * @param _id identifier for the credit line  */ function close(uint256 _id) external ifCreditLineExists(_id) {     require(         msg.sender == creditLineConstants[_id].borrower || msg.sender == creditLineConstants[_id].lender,         'CreditLine: Permission denied while closing Line of credit'     );     require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: Credit line should be active.');     require(creditLineVariables[_id].principal == 0, 'CreditLine: Cannot be closed since not repaid.');     require(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate == 0, 'CreditLine: Cannot be closed since not repaid.');     creditLineVariables[_id].status = CreditLineStatus.CLOSED;     emit CreditLineClosed(_id); }  /**  * @notice used to calculate the current collateral ratio  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view.         Interest is also considered while calculating debt  * @param _id identifier for the credit line  * @return collateral ratio multiplied by 10**30 to retain precision  */ function calculateCurrentCollateralRatio(uint256 _id) public ifCreditLineExists(_id) returns (uint256) {     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(         creditLineConstants[_id].collateralAsset,         creditLineConstants[_id].borrowAsset     );      uint256 currentDebt = calculateCurrentDebt(_id);     uint256 currentCollateralRatio = calculateTotalCollateralTokens(_id).mul(_ratioOfPrices).div(currentDebt).mul(10**30).div(         10**_decimals     );      return currentCollateralRatio; }  /**  * @notice used to calculate the total collateral tokens  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view  * @param _id identifier for the credit line  * @return _amount total collateral tokens deposited into the credit line  */ function calculateTotalCollateralTokens(uint256 _id) public returns (uint256 _amount) {     address _collateralAsset = creditLineConstants[_id].collateralAsset;     address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();     uint256 _liquidityShares;     for (uint256 index = 0; index &lt; _strategyList.length; index++) {         if (_strategyList[index] == address(0)) {             continue;         }         _liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];         uint256 _tokenInStrategy = _liquidityShares;         _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(_liquidityShares, _collateralAsset);          _amount = _amount.add(_tokenInStrategy);     } }  /**  * @notice used to withdraw any excess collateral  * @dev collateral can't be withdraw if collateralRatio goes below the ideal value. Only borrower can withdraw  * @param _id identifier for the credit line  * @param _amount amount of collateral to withdraw  * @param _toSavingsAccount if true, tokens are transferred from savingsAccount                              otherwise direct from collateral token contract  */ function withdrawCollateral(     uint256 _id,     uint256 _amount,     bool _toSavingsAccount ) external nonReentrant onlyCreditLineBorrower(_id) {     uint256 _withdrawableCollateral = withdrawableCollateral(_id);     require(_amount &lt;= _withdrawableCollateral, 'Collateral ratio cant go below ideal');     address _collateralAsset = creditLineConstants[_id].collateralAsset;     _transferCollateral(_id, _collateralAsset, _amount, _toSavingsAccount);     emit CollateralWithdrawn(_id, _amount); }  /**  * @notice used to calculate the collateral that can be withdrawn  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view  * @param _id identifier for the credit line  * @return total collateral withdrawable by borrower  */ function withdrawableCollateral(uint256 _id) public returns (uint256) {     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(         creditLineConstants[_id].collateralAsset,         creditLineConstants[_id].borrowAsset     );      uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);     uint256 _currentDebt = calculateCurrentDebt(_id);      uint256 _collateralNeeded = _currentDebt         .mul(creditLineConstants[_id].idealCollateralRatio)         .div(_ratioOfPrices)         .mul(10**_decimals)         .div(10**30);      if (_collateralNeeded &gt;= _totalCollateralTokens) {         return 0;     }     return _totalCollateralTokens.sub(_collateralNeeded); }  function _transferCollateral(     uint256 _id,     address _asset,     uint256 _amountInTokens,     bool _toSavingsAccount ) internal {     address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();     uint256 _activeAmount;     for (uint256 index = 0; index &lt; _strategyList.length; index++) {         uint256 liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];         if (liquidityShares == 0 || _strategyList[index] == address(0)) {             continue;         }         uint256 _tokenInStrategy = liquidityShares;         _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(liquidityShares, _asset);         uint256 _tokensToTransfer = _tokenInStrategy;         if (_activeAmount.add(_tokenInStrategy) &gt; _amountInTokens) {             _tokensToTransfer = _amountInTokens.sub(_activeAmount);             liquidityShares = liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy);         }         _activeAmount = _activeAmount.add(_tokensToTransfer);         collateralShareInStrategy[_id][_strategyList[index]] = collateralShareInStrategy[_id][_strategyList[index]].sub(             liquidityShares         );         if (_toSavingsAccount) {             ISavingsAccount(savingsAccount).transfer(_tokensToTransfer, _asset, _strategyList[index], msg.sender);         } else {             ISavingsAccount(savingsAccount).withdraw(_tokensToTransfer, _asset, _strategyList[index], msg.sender, false);         }          if (_activeAmount == _amountInTokens) {             return;         }     }     revert('insufficient collateral'); }  /**  * @notice used to liquidate credit line in case collateral ratio goes below the threshold  * @dev if lender liquidates, then collateral is directly transferred.          If autoLiquidation is true, anyone can liquidate by providing enough borrow tokens  * @param _id identifier for the credit line  * @param _toSavingsAccount if true, tokens are transferred from savingsAccount                              otherwise direct from collateral token contract  */ function liquidate(uint256 _id, bool _toSavingsAccount) external payable nonReentrant {     require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: Credit line should be active.');     require(creditLineVariables[_id].principal != 0, 'CreditLine: cannot liquidate if principal is 0');      uint256 currentCollateralRatio = calculateCurrentCollateralRatio(_id);     require(         currentCollateralRatio &lt; creditLineConstants[_id].idealCollateralRatio,         'CreditLine: Collateral ratio is higher than ideal value'     );      address _collateralAsset = creditLineConstants[_id].collateralAsset;     address _lender = creditLineConstants[_id].lender;     uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);     address _borrowAsset = creditLineConstants[_id].borrowAsset;      creditLineVariables[_id].status = CreditLineStatus.LIQUIDATED;      if (creditLineConstants[_id].autoLiquidation &amp;&amp; _lender != msg.sender) {         uint256 _borrowTokens = _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens);         if (_borrowAsset == address(0)) {             uint256 _returnETH = msg.value.sub(_borrowTokens, 'Insufficient ETH to liquidate');             if (_returnETH != 0) {                 (bool success, ) = msg.sender.call{value: _returnETH}('');                 require(success, 'Transfer fail');             }         } else {             IERC20(_borrowAsset).safeTransferFrom(msg.sender, _lender, _borrowTokens);         }     }      _transferCollateral(_id, _collateralAsset, _totalCollateralTokens, _toSavingsAccount);      emit CreditLineLiquidated(_id, msg.sender); }  /**  * @notice used to calculate the borrow tokens necessary for liquidator to liquidate  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view  * @param _id identifier for the credit line  * @return borrow tokens necessary for liquidator to liquidate  */ function borrowTokensToLiquidate(uint256 _id) external returns (uint256) {     address _collateralAsset = creditLineConstants[_id].collateralAsset;     uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);     address _borrowAsset = creditLineConstants[_id].borrowAsset;      return _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens); }  function _borrowTokensToLiquidate(     address _borrowAsset,     address _collateralAsset,     uint256 _totalCollateralTokens ) internal view returns (uint256) {     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(_borrowAsset, _collateralAsset);     uint256 _borrowTokens = (         _totalCollateralTokens.mul(uint256(10**30).sub(liquidatorRewardFraction)).div(10**30).mul(_ratioOfPrices).div(10**_decimals)     );      return _borrowTokens; }  receive() external payable {     require(msg.sender == savingsAccount, 'CreditLine::receive invalid transaction'); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-22-08 11:43:02 INFO] Counselor: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer.
Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees.
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/utils/ReentrancyGuard.sol';
import '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';
import '../interfaces/IPriceOracle.sol';
import '../interfaces/IYield.sol';
import '../interfaces/ISavingsAccount.sol';
import '../SavingsAccount/SavingsAccountUtil.sol';
import '../interfaces/IStrategyRegistry.sol';

/**
 * @title Credit Line contract with Methods related to credit Line
 * @notice Implements the functions related to Credit Line
 * @author Sublime
 **/

contract CreditLine is ReentrancyGuard, OwnableUpgradeable {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    enum CreditLineStatus {
        NOT_CREATED,
        REQUESTED,
        ACTIVE,
        CLOSED,
        CANCELLED,
        LIQUIDATED
    }

    /**
     * @notice counter that tracks the number of credit lines created
     * @dev used to create unique identifier for credit lines
     **/
    uint256 public creditLineCounter;

    uint256 constant YEAR_IN_SECONDS = 365 days;

    struct CreditLineVariables {
        CreditLineStatus status;
        uint256 principal;
        uint256 totalInterestRepaid;
        uint256 lastPrincipalUpdateTime;
        uint256 interestAccruedTillLastPrincipalUpdate;
    }

    struct CreditLineConstants {
        address lender;
        address borrower;
        uint256 borrowLimit;
        uint256 idealCollateralRatio;
        uint256 borrowRate;
        address borrowAsset;
        address collateralAsset;
        bool autoLiquidation;
        bool requestByLender;
    }
    /**
     * @notice stores the collateral shares in a credit line per strategy
     * @dev creditLineId => Strategy => collateralShares
     **/
    mapping(uint256 => mapping(address => uint256)) public collateralShareInStrategy;

    /**
     * @notice stores the variables to maintain a credit line
     **/
    mapping(uint256 => CreditLineVariables) public creditLineVariables;

    /**
     * @notice stores the constants related to a credit line
     **/
    mapping(uint256 => CreditLineConstants) public creditLineConstants;

    /**
     * @notice stores the address of savings account contract
     **/
    address public savingsAccount;

    /**
     * @notice stores the address of price oracle contract
     **/
    address public priceOracle;

    /**
     * @notice stores the address of strategy registry contract
     **/
    address public strategyRegistry;

    /**
     * @notice stores the address of default strategy
     **/
    address public defaultStrategy;

    /**
     * @notice stores the fraction of borrowed amount charged as fee by protocol
     * @dev it is multiplied by 10**30
     **/
    uint256 public protocolFeeFraction;

    /**
     * @notice address where protocol fee is collected
     **/
    address public protocolFeeCollector;

    /**
     * @notice stores the fraction of amount liquidated given as reward to liquidator
     * @dev it is multiplied by 10**30
     **/
    uint256 public liquidatorRewardFraction;
    /**
     * @dev checks if Credit Line exists
     * @param _id identifier for the credit line
     **/
    modifier ifCreditLineExists(uint256 _id) {
        require(creditLineVariables[_id].status != CreditLineStatus.NOT_CREATED, 'Credit line does not exist');
        _;
    }

    /**
     * @dev checks if called by credit Line Borrower
     * @param _id creditLine identifier
     **/
    modifier onlyCreditLineBorrower(uint256 _id) {
        require(creditLineConstants[_id].borrower == msg.sender, 'Only credit line Borrower can access');
        _;
    }

    /**
     * @dev checks if called by credit Line Lender
     * @param _id creditLine identifier
     **/
    modifier onlyCreditLineLender(uint256 _id) {
        require(creditLineConstants[_id].lender == msg.sender, 'Only credit line Lender can access');
        _;
    }

    /**
     * @notice emitted when a collateral is deposited into credit line
     * @param id id of the credit line
     * @param amount amount of collateral deposited
     * @param strategy address of the strategy into which collateral is deposited
     */
    event CollateralDeposited(uint256 indexed id, uint256 amount, address indexed strategy);

    /**
     * @notice emitted when collateral is withdrawn from credit line
     * @param id id of the credit line
     * @param amount amount of collateral withdrawn
     */
    event CollateralWithdrawn(uint256 indexed id, uint256 amount);

    /**
     * @notice emitted when a request for new credit line is placed
     * @param id id of the credit line for which request was made
     * @param lender address of the lender for credit line
     * @param borrower address of the borrower for credit line
     */
    event CreditLineRequested(uint256 indexed id, address indexed lender, address indexed borrower);

    /**
     * @notice emitted when a credit line is liquidated
     * @param id id of the credit line which is liquidated
     * @param liquidator address of the liquidator
     */
    event CreditLineLiquidated(uint256 indexed id, address indexed liquidator);

    /**
     * @notice emitted when tokens are borrowed from credit line
     * @param id id of the credit line from which tokens are borrowed
     * @param borrowAmount amount of tokens borrowed
     */
    event BorrowedFromCreditLine(uint256 indexed id, uint256 borrowAmount);

    /**
     * @notice emitted when credit line is accepted
     * @param id id of the credit line that was accepted
     */
    event CreditLineAccepted(uint256 indexed id);

    /**
     * @notice emitted when credit line is completely repaid and reset
     * @param id id of the credit line that is reset
     */
    event CreditLineReset(uint256 indexed id);

    /**
     * @notice emitted when the credit line is partially repaid
     * @param id id of the credit line
     * @param repayAmount amount repaid
     */
    event PartialCreditLineRepaid(uint256 indexed id, uint256 repayAmount);

    /**
     * @notice emitted when the credit line is completely repaid
     * @param id id of the credit line
     * @param repayAmount amount repaid
     */
    event CompleteCreditLineRepaid(uint256 indexed id, uint256 repayAmount);

    /**
     * @notice emitted when the credit line is closed by one of the parties of credit line
     * @param id id of the credit line
     */
    event CreditLineClosed(uint256 indexed id);

    /**
     * @notice emitted when default strategy for the credit line is updated
     * @param defaultStrategy address of the strategy contract that is used as default by credit lines
     */
    event DefaultStrategyUpdated(address indexed defaultStrategy);

    /**
     * @notice emitted when the price oracle is updated
     * @param priceOracle address of the updated price oracle
     */
    event PriceOracleUpdated(address indexed priceOracle);

    /**
     * @notice emitted when the savings account address is updated
     * @param savingsAccount address of the updated savingsAccount
     */
    event SavingsAccountUpdated(address indexed savingsAccount);

    /**
     * @notice emitted when strategy registry address is updated
     * @param strategyRegistry address of the updated strategy registry
     */
    event StrategyRegistryUpdated(address indexed strategyRegistry);

    /**
     * @notice emitted when fee that protocol charges for credit line is updated
     * @param updatedProtocolFee updated value of protocolFeeFraction
     */
    event ProtocolFeeFractionUpdated(uint256 updatedProtocolFee);

    /**
     * @notice emitted when address which receives fee that protocol changes for pools is updated
     * @param updatedProtocolFeeCollector updated value of protocolFeeCollector
     */
    event ProtocolFeeCollectorUpdated(address indexed updatedProtocolFeeCollector);

    /**
     * @notice emitted when liquidatorRewardFraction is updated
     * @param liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator
     */
    event LiquidationRewardFractionUpdated(uint256 liquidatorRewardFraction);

    /**
     * @notice used to initialize the contract
     * @dev can only be called once during the life cycle of the contract
     * @param _defaultStrategy default strategy used in credit lines
     * @param _priceOracle address of the priceOracle
     * @param _savingsAccount address of  the savings account contract
     * @param _strategyRegistry address of the strategy registry contract
     * @param _owner address of owner who can change global variables
     * @param _protocolFeeFraction fraction of the fee charged by protocol
     * @param _protocolFeeCollector address to which protocol fee is charged to
     * @param _liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator
     */
    function initialize(
        address _defaultStrategy,
        address _priceOracle,
        address _savingsAccount,
        address _strategyRegistry,
        address _owner,
        uint256 _protocolFeeFraction,
        address _protocolFeeCollector,
        uint256 _liquidatorRewardFraction
    ) external initializer {
        OwnableUpgradeable.__Ownable_init();
        OwnableUpgradeable.transferOwnership(_owner);

        _updateDefaultStrategy(_defaultStrategy);
        _updatePriceOracle(_priceOracle);
        _updateSavingsAccount(_savingsAccount);
        _updateStrategyRegistry(_strategyRegistry);
        _updateProtocolFeeFraction(_protocolFeeFraction);
        _updateProtocolFeeCollector(_protocolFeeCollector);
        _updateLiquidatorRewardFraction(_liquidatorRewardFraction);
    }

    /**
     * @notice used to update the default strategy
     * @dev can only be updated by owner
     * @param _defaultStrategy address of the updated default strategy
     */
    function updateDefaultStrategy(address _defaultStrategy) external onlyOwner {
        _updateDefaultStrategy(_defaultStrategy);
    }

    function _updateDefaultStrategy(address _defaultStrategy) internal {
        defaultStrategy = _defaultStrategy;
        emit DefaultStrategyUpdated(_defaultStrategy);
    }

    /**
     * @notice used to update the price oracle
     * @dev can only be updated by owner
     * @param _priceOracle address of the updated price oracle
     */
    function updatePriceOracle(address _priceOracle) external onlyOwner {
        _updatePriceOracle(_priceOracle);
    }

    function _updatePriceOracle(address _priceOracle) internal {
        priceOracle = _priceOracle;
        emit PriceOracleUpdated(_priceOracle);
    }

    /**
     * @notice used to update the savings account address
     * @dev can only be updated by owner
     * @param _savingsAccount address of the updated savings account
     */
    function updateSavingsAccount(address _savingsAccount) external onlyOwner {
        _updateSavingsAccount(_savingsAccount);
    }

    function _updateSavingsAccount(address _savingsAccount) internal {
        savingsAccount = _savingsAccount;
        emit SavingsAccountUpdated(_savingsAccount);
    }

    /**
     * @notice used to update the protocol fee fraction
     * @dev can only be updated by owner
     * @param _protocolFee fraction of the borrower amount collected as protocol fee
     */
    function updateProtocolFeeFraction(uint256 _protocolFee) external onlyOwner {
        _updateProtocolFeeFraction(_protocolFee);
    }

    function _updateProtocolFeeFraction(uint256 _protocolFee) internal {
        protocolFeeFraction = _protocolFee;
        emit ProtocolFeeFractionUpdated(_protocolFee);
    }

    /**
     * @notice used to update the protocol fee collector
     * @dev can only be updated by owner
     * @param _protocolFeeCollector address in which protocol fee is collected
     */
    function updateProtocolFeeCollector(address _protocolFeeCollector) external onlyOwner {
        _updateProtocolFeeCollector(_protocolFeeCollector);
    }

    function _updateProtocolFeeCollector(address _protocolFeeCollector) internal {
        require(_protocolFeeCollector != address(0), 'cant be 0 address');
        protocolFeeCollector = _protocolFeeCollector;
        emit ProtocolFeeCollectorUpdated(_protocolFeeCollector);
    }

    /**
     * @notice used to update the strategy registry address
     * @dev can only be updated by owner
     * @param _strategyRegistry address of the updated strategy registry
     */
    function updateStrategyRegistry(address _strategyRegistry) external onlyOwner {
        _updateStrategyRegistry(_strategyRegistry);
    }

    function _updateStrategyRegistry(address _strategyRegistry) internal {
        require(_strategyRegistry != address(0), 'CL::I zero address');
        strategyRegistry = _strategyRegistry;
        emit StrategyRegistryUpdated(_strategyRegistry);
    }

    /**
     * @notice used to update the liquidatorRewardFraction
     * @dev can only be updated by owner
     * @param _rewardFraction fraction of liquidated amount given to liquidator as reward
     */
    function updateLiquidatorRewardFraction(uint256 _rewardFraction) external onlyOwner {
        _updateLiquidatorRewardFraction(_rewardFraction);
    }

    function _updateLiquidatorRewardFraction(uint256 _rewardFraction) internal {
        require(_rewardFraction <= 10**30, 'Fraction has to be less than 1');
        liquidatorRewardFraction = _rewardFraction;
        emit LiquidationRewardFractionUpdated(_rewardFraction);
    }

    /**
     * @dev Used to Calculate Interest Per second on given principal and Interest rate
     * @param _principal principal Amount for which interest has to be calculated.
     * @param _borrowRate It is the Interest Rate at which Credit Line is approved
     * @return interest per second for the given parameters
     */
    function calculateInterest(
        uint256 _principal,
        uint256 _borrowRate,
        uint256 _timeElapsed
    ) public pure returns (uint256) {
        uint256 _interest = _principal.mul(_borrowRate).mul(_timeElapsed).div(10**30).div(YEAR_IN_SECONDS);

        return _interest;
    }

    /**
     * @dev Used to calculate interest accrued since last repayment
     * @param _id identifier for the credit line
     * @return interest accrued over current borrowed amount since last repayment
     */

    function calculateInterestAccrued(uint256 _id) public view returns (uint256) {
        uint256 _lastPrincipalUpdateTime = creditLineVariables[_id].lastPrincipalUpdateTime;
        if (_lastPrincipalUpdateTime == 0) return 0;
        uint256 _timeElapsed = (block.timestamp).sub(_lastPrincipalUpdateTime);
        uint256 _interestAccrued = calculateInterest(creditLineVariables[_id].principal, creditLineConstants[_id].borrowRate, _timeElapsed);
        return _interestAccrued;
    }

    /**
     * @dev Used to calculate current debt of borrower against a credit line.
     * @param _id identifier for the credit line
     * @return current debt of borrower
     */
    function calculateCurrentDebt(uint256 _id) public view returns (uint256) {
        uint256 _interestAccrued = calculateInterestAccrued(_id);
        uint256 _currentDebt = (creditLineVariables[_id].principal)
            .add(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate)
            .add(_interestAccrued)
            .sub(creditLineVariables[_id].totalInterestRepaid);
        return _currentDebt;
    }

    /**
     * @notice used to calculate amount that can be borrowed by the borrower
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view.
            borrowableAmount changes per block as interest changes per block.
     * @param _id identifier for the credit line
     * @return amount that can be borrowed from the credit line
     */
    function calculateBorrowableAmount(uint256 _id) public returns (uint256) {
        CreditLineStatus _status = creditLineVariables[_id].status;
        require(
            _status == CreditLineStatus.ACTIVE || _status == CreditLineStatus.REQUESTED,
            'CreditLine: Cannot only if credit line ACTIVE or REQUESTED'
        );
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(
            creditLineConstants[_id].collateralAsset,
            creditLineConstants[_id].borrowAsset
        );

        uint256 _totalCollateralToken = calculateTotalCollateralTokens(_id);

        uint256 _currentDebt = calculateCurrentDebt(_id);

        uint256 _maxPossible = _totalCollateralToken.mul(_ratioOfPrices).div(creditLineConstants[_id].idealCollateralRatio).mul(10**30).div(
            10**_decimals
        );

        uint256 _borrowLimit = creditLineConstants[_id].borrowLimit;

        if (_maxPossible > _borrowLimit) {
            _maxPossible = _borrowLimit;
        }
        if (_maxPossible > _currentDebt) {
            return _maxPossible.sub(_currentDebt);
        }
        return 0;
    }

    function updateinterestAccruedTillLastPrincipalUpdate(uint256 _id) internal {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');

        uint256 _interestAccrued = calculateInterestAccrued(_id);
        uint256 _newInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(_interestAccrued);
        creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _newInterestAccrued;
    }

    function _depositCollateralFromSavingsAccount(
        uint256 _id,
        uint256 _amount,
        address _sender
    ) internal {
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        uint256 _activeAmount;

        for (uint256 _index = 0; _index < _strategyList.length; _index++) {
            address _strategy = _strategyList[_index];
            uint256 _liquidityShares = _savingsAccount.balanceInShares(_sender, _collateralAsset, _strategy);
            if (_liquidityShares == 0 || _strategyList[_index] == address(0)) {
                continue;
            }
            uint256 _tokenInStrategy = _liquidityShares;
            _tokenInStrategy = IYield(_strategy).getTokensForShares(_liquidityShares, _collateralAsset);

            uint256 _tokensToTransfer = _tokenInStrategy;
            if (_activeAmount.add(_tokenInStrategy) >= _amount) {
                _tokensToTransfer = (_amount.sub(_activeAmount));
            }
            _activeAmount = _activeAmount.add(_tokensToTransfer);
            _savingsAccount.transferFrom(_tokensToTransfer, _collateralAsset, _strategy, _sender, address(this));

            collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(
                _liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy)
            );

            if (_amount == _activeAmount) {
                return;
            }
        }
        revert('CreditLine::_depositCollateralFromSavingsAccount - Insufficient balance');
    }

    /**
     * @notice used to request a credit line either by borrower or lender
     * @param _requestTo Address to which creditLine is requested, 
                        if borrower creates request then lender address and 
                        if lender creates then borrower address
     * @param _borrowLimit maximum borrow amount in a credit line
     * @param _borrowRate Interest Rate at which credit Line is requested
     * @param _autoLiquidation if true, anyone can liquidate loan, otherwise only lender
     * @param _collateralRatio ratio of the collateral to the debt below which credit line can be liquidated
     * @param _borrowAsset address of the token to be borrowed
     * @param _collateralAsset address of the token provided as collateral
     * @param _requestAsLender if true, lender is placing request, otherwise borrower
     * @return identifier for the credit line
     */

    function request(
        address _requestTo,
        uint256 _borrowLimit,
        uint256 _borrowRate,
        bool _autoLiquidation,
        uint256 _collateralRatio,
        address _borrowAsset,
        address _collateralAsset,
        bool _requestAsLender
    ) external returns (uint256) {
        require(_borrowAsset != _collateralAsset, 'R: cant borrow lent token');
        require(IPriceOracle(priceOracle).doesFeedExist(_borrowAsset, _collateralAsset), 'R: No price feed');

        address _lender = _requestTo;
        address _borrower = msg.sender;
        if (_requestAsLender) {
            _lender = msg.sender;
            _borrower = _requestTo;
        }

        uint256 _id = _createRequest(
            _lender,
            _borrower,
            _borrowLimit,
            _borrowRate,
            _autoLiquidation,
            _collateralRatio,
            _borrowAsset,
            _collateralAsset,
            _requestAsLender
        );

        emit CreditLineRequested(_id, _lender, _borrower);
        return _id;
    }

    function _createRequest(
        address _lender,
        address _borrower,
        uint256 _borrowLimit,
        uint256 _borrowRate,
        bool _autoLiquidation,
        uint256 _collateralRatio,
        address _borrowAsset,
        address _collateralAsset,
        bool _requestByLender
    ) internal returns (uint256) {
        require(_lender != _borrower, 'Lender and Borrower cannot be same addresses');
        uint256 _id = creditLineCounter + 1;
        creditLineCounter = _id;
        creditLineVariables[_id].status = CreditLineStatus.REQUESTED;
        creditLineConstants[_id].borrower = _borrower;
        creditLineConstants[_id].lender = _lender;
        creditLineConstants[_id].borrowLimit = _borrowLimit;
        creditLineConstants[_id].autoLiquidation = _autoLiquidation;
        creditLineConstants[_id].idealCollateralRatio = _collateralRatio;
        creditLineConstants[_id].borrowRate = _borrowRate;
        creditLineConstants[_id].borrowAsset = _borrowAsset;
        creditLineConstants[_id].collateralAsset = _collateralAsset;
        creditLineConstants[_id].requestByLender = _requestByLender;
        return _id;
    }

    /**
     * @notice used to accept a credit line
     * @dev if borrower places request, lender can accept and vice versa
     * @param _id identifier for the credit line
     */
    function accept(uint256 _id) external {
        require(
            creditLineVariables[_id].status == CreditLineStatus.REQUESTED,
            'CreditLine::acceptCreditLineLender - CreditLine is already accepted'
        );
        bool _requestByLender = creditLineConstants[_id].requestByLender;
        require(
            (msg.sender == creditLineConstants[_id].borrower && _requestByLender) ||
                (msg.sender == creditLineConstants[_id].lender && !_requestByLender),
            "Only Borrower or Lender who hasn't requested can accept"
        );
        creditLineVariables[_id].status = CreditLineStatus.ACTIVE;
        emit CreditLineAccepted(_id);
    }

    /**
     * @notice used to deposit collateral into the credit line
     * @dev collateral tokens have to be approved in savingsAccount or token contract(unless ether).
            If transferred from savings account, the tokens are transferred from strategies in the 
            order prespecified in strategy registry
     * @param _id identifier for the credit line
     * @param _amount amount of collateral being deposited
     * @param _strategy strategy to which collateral is to be deposited in case transfer is not from savings account
     * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount 
                                otherwise direct from collateral token contract
     */
    function depositCollateral(
        uint256 _id,
        uint256 _amount,
        address _strategy,
        bool _fromSavingsAccount
    ) external payable nonReentrant ifCreditLineExists(_id) {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine not active');
        _depositCollateral(_id, _amount, _strategy, _fromSavingsAccount);
        emit CollateralDeposited(_id, _amount, _strategy);
    }

    function _depositCollateral(
        uint256 _id,
        uint256 _amount,
        address _strategy,
        bool _fromSavingsAccount
    ) internal {
        require(creditLineConstants[_id].lender != msg.sender, 'lender cant deposit collateral');
        if (_fromSavingsAccount) {
            _depositCollateralFromSavingsAccount(_id, _amount, msg.sender);
        } else {
            address _collateralAsset = creditLineConstants[_id].collateralAsset;
            ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
            if (_collateralAsset == address(0)) {
                require(msg.value == _amount, "CreditLine::_depositCollateral - value to transfer doesn't match argument");
            } else {
                IERC20(_collateralAsset).safeTransferFrom(msg.sender, address(this), _amount);
                IERC20(_collateralAsset).approve(_strategy, _amount);
            }
            uint256 _sharesReceived = _savingsAccount.deposit{value: msg.value}(_amount, _collateralAsset, _strategy, address(this));
            collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(_sharesReceived);
        }
    }

    function _withdrawBorrowAmount(
        address _asset,
        uint256 _amountInTokens,
        address _lender
    ) internal {
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        uint256 _activeAmount;
        for (uint256 _index = 0; _index < _strategyList.length; _index++) {
            if (_strategyList[_index] == address(0)) {
                continue;
            }
            uint256 _liquidityShares = _savingsAccount.balanceInShares(_lender, _asset, _strategyList[_index]);
            if (_liquidityShares != 0) {
                uint256 tokenInStrategy = _liquidityShares;
                tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);
                uint256 _tokensToTransfer = tokenInStrategy;
                if (_activeAmount.add(tokenInStrategy) >= _amountInTokens) {
                    _tokensToTransfer = (_amountInTokens.sub(_activeAmount));
                }
                _activeAmount = _activeAmount.add(_tokensToTransfer);
                _savingsAccount.withdrawFrom(_tokensToTransfer, _asset, _strategyList[_index], _lender, address(this), false);
                if (_activeAmount == _amountInTokens) {
                    return;
                }
            }
        }
        require(_activeAmount == _amountInTokens, 'insufficient balance');
    }

    /**
     * @notice used to borrow tokens from credit line by borrower
     * @dev only borrower can call this function. Amount that can actually be borrowed is 
            min(amount based on borrowLimit, allowance to creditLine contract, balance of lender)
     * @param _id identifier for the credit line
     * @param _amount amount of tokens to borrow
     */
    function borrow(uint256 _id, uint256 _amount) external payable nonReentrant onlyCreditLineBorrower(_id) {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');
        uint256 _borrowableAmount = calculateBorrowableAmount(_id);
        require(_amount <= _borrowableAmount, "CreditLine::borrow - The current collateral ratio doesn't allow to withdraw the amount");
        address _borrowAsset = creditLineConstants[_id].borrowAsset;
        address _lender = creditLineConstants[_id].lender;

        updateinterestAccruedTillLastPrincipalUpdate(_id);
        creditLineVariables[_id].principal = creditLineVariables[_id].principal.add(_amount);
        creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;

        uint256 _tokenDiffBalance;
        if (_borrowAsset != address(0)) {
            uint256 _balanceBefore = IERC20(_borrowAsset).balanceOf(address(this));
            _withdrawBorrowAmount(_borrowAsset, _amount, _lender);
            uint256 _balanceAfter = IERC20(_borrowAsset).balanceOf(address(this));
            _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);
        } else {
            uint256 _balanceBefore = address(this).balance;
            _withdrawBorrowAmount(_borrowAsset, _amount, _lender);
            uint256 _balanceAfter = address(this).balance;
            _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);
        }
        uint256 _protocolFee = _tokenDiffBalance.mul(protocolFeeFraction).div(10**30);
        _tokenDiffBalance = _tokenDiffBalance.sub(_protocolFee);

        if (_borrowAsset == address(0)) {
            (bool feeSuccess, ) = protocolFeeCollector.call{value: _protocolFee}('');
            require(feeSuccess, 'Transfer fail');
            (bool success, ) = msg.sender.call{value: _tokenDiffBalance}('');
            require(success, 'Transfer fail');
        } else {
            IERC20(_borrowAsset).safeTransfer(protocolFeeCollector, _protocolFee);
            IERC20(_borrowAsset).safeTransfer(msg.sender, _tokenDiffBalance);
        }
        emit BorrowedFromCreditLine(_id, _tokenDiffBalance);
    }

    function _repayFromSavingsAccount(
        uint256 _amount,
        address _asset,
        address _lender
    ) internal {
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        uint256 _activeAmount;

        for (uint256 _index = 0; _index < _strategyList.length; _index++) {
            if (_strategyList[_index] == address(0)) {
                continue;
            }
            uint256 _liquidityShares = _savingsAccount.balanceInShares(msg.sender, _asset, _strategyList[_index]);
            if (_liquidityShares == 0) {
                continue;
            }
            uint256 _tokenInStrategy = _liquidityShares;
            _tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);

            uint256 _tokensToTransfer = _tokenInStrategy;
            if (_activeAmount.add(_tokenInStrategy) >= _amount) {
                _tokensToTransfer = (_amount.sub(_activeAmount));
            }
            _activeAmount = _activeAmount.add(_tokensToTransfer);
            _savingsAccount.transferFrom(_tokensToTransfer, _asset, _strategyList[_index], msg.sender, _lender);

            if (_amount == _activeAmount) {
                return;
            }
        }
        revert('CreditLine::_repayFromSavingsAccount - Insufficient balance');
    }

    function _repay(
        uint256 _id,
        uint256 _amount,
        bool _fromSavingsAccount,
        uint256 _principalPaid
    ) internal {
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        address _defaultStrategy = defaultStrategy;
        address _borrowAsset = creditLineConstants[_id].borrowAsset;
        address _lender = creditLineConstants[_id].lender;
        if (!_fromSavingsAccount) {
            if (_borrowAsset == address(0)) {
                require(msg.value == _amount, 'creditLine::repay - Ether sent not equal to repay amount');
                _savingsAccount.deposit{value: _amount}(_amount, _borrowAsset, _defaultStrategy, _lender);
            } else {
                IERC20(_borrowAsset).safeTransferFrom(msg.sender, address(this), _amount);
                IERC20(_borrowAsset).approve(_defaultStrategy, _amount);
                _savingsAccount.deposit(_amount, _borrowAsset, _defaultStrategy, _lender);
            }
        } else {
            _repayFromSavingsAccount(_amount, _borrowAsset, _lender);
        }
        if (_principalPaid != 0) {
            _savingsAccount.increaseAllowanceToCreditLine(_principalPaid, _borrowAsset, _lender);
        }
    }

    /**
     * @notice used to repay interest and principal to credit line. Interest has to be repaid before repaying principal
     * @dev partial repayments possible
     * @param _id identifier for the credit line
     * @param _amount amount being repaid
     * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount 
                                otherwise direct from collateral token contract
     */
    function repay(
        uint256 _id,
        uint256 _amount,
        bool _fromSavingsAccount
    ) external payable nonReentrant {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');
        require(creditLineConstants[_id].lender != msg.sender, 'Lender cant repay');

        uint256 _interestSincePrincipalUpdate = calculateInterestAccrued(_id);
        uint256 _totalInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(
            _interestSincePrincipalUpdate
        );
        uint256 _interestToPay = _totalInterestAccrued.sub(creditLineVariables[_id].totalInterestRepaid);
        uint256 _totalCurrentDebt = _interestToPay.add(creditLineVariables[_id].principal);
        uint256 _principalPaid = 0;

        if (_amount >= _totalCurrentDebt) {
            _amount = _totalCurrentDebt;
            emit CompleteCreditLineRepaid(_id, _amount);
        } else {
            emit PartialCreditLineRepaid(_id, _amount);
        }

        if (_amount > _interestToPay) {
            creditLineVariables[_id].principal = _totalCurrentDebt.sub(_amount);
            creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _totalInterestAccrued;
            creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;
            creditLineVariables[_id].totalInterestRepaid = _totalInterestAccrued;
            _principalPaid = _amount.sub(_interestToPay);
        } else {
            creditLineVariables[_id].totalInterestRepaid = creditLineVariables[_id].totalInterestRepaid.add(_amount);
        }

        _repay(_id, _amount, _fromSavingsAccount, _principalPaid);

        if (creditLineVariables[_id].principal == 0) {
            _resetCreditLine(_id);
        }
    }

    function _resetCreditLine(uint256 _id) internal {
        creditLineVariables[_id].lastPrincipalUpdateTime = 0;
        creditLineVariables[_id].totalInterestRepaid = 0;
        creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = 0;
        emit CreditLineReset(_id);
    }

    /**
     * @dev used to close credit line by borrower or lender
     * @param _id identifier for the credit line
     */
    function close(uint256 _id) external ifCreditLineExists(_id) {
        require(
            msg.sender == creditLineConstants[_id].borrower || msg.sender == creditLineConstants[_id].lender,
            'CreditLine: Permission denied while closing Line of credit'
        );
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: Credit line should be active.');
        require(creditLineVariables[_id].principal == 0, 'CreditLine: Cannot be closed since not repaid.');
        require(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate == 0, 'CreditLine: Cannot be closed since not repaid.');
        creditLineVariables[_id].status = CreditLineStatus.CLOSED;
        emit CreditLineClosed(_id);
    }

    /**
     * @notice used to calculate the current collateral ratio
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view.
            Interest is also considered while calculating debt
     * @param _id identifier for the credit line
     * @return collateral ratio multiplied by 10**30 to retain precision
     */
    function calculateCurrentCollateralRatio(uint256 _id) public ifCreditLineExists(_id) returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(
            creditLineConstants[_id].collateralAsset,
            creditLineConstants[_id].borrowAsset
        );

        uint256 currentDebt = calculateCurrentDebt(_id);
        uint256 currentCollateralRatio = calculateTotalCollateralTokens(_id).mul(_ratioOfPrices).div(currentDebt).mul(10**30).div(
            10**_decimals
        );

        return currentCollateralRatio;
    }

    /**
     * @notice used to calculate the total collateral tokens
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @param _id identifier for the credit line
     * @return _amount total collateral tokens deposited into the credit line
     */
    function calculateTotalCollateralTokens(uint256 _id) public returns (uint256 _amount) {
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        uint256 _liquidityShares;
        for (uint256 index = 0; index < _strategyList.length; index++) {
            if (_strategyList[index] == address(0)) {
                continue;
            }
            _liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];
            uint256 _tokenInStrategy = _liquidityShares;
            _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(_liquidityShares, _collateralAsset);

            _amount = _amount.add(_tokenInStrategy);
        }
    }

    /**
     * @notice used to withdraw any excess collateral
     * @dev collateral can't be withdraw if collateralRatio goes below the ideal value. Only borrower can withdraw
     * @param _id identifier for the credit line
     * @param _amount amount of collateral to withdraw
     * @param _toSavingsAccount if true, tokens are transferred from savingsAccount 
                                otherwise direct from collateral token contract
     */
    function withdrawCollateral(
        uint256 _id,
        uint256 _amount,
        bool _toSavingsAccount
    ) external nonReentrant onlyCreditLineBorrower(_id) {
        uint256 _withdrawableCollateral = withdrawableCollateral(_id);
        require(_amount <= _withdrawableCollateral, 'Collateral ratio cant go below ideal');
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        _transferCollateral(_id, _collateralAsset, _amount, _toSavingsAccount);
        emit CollateralWithdrawn(_id, _amount);
    }

    /**
     * @notice used to calculate the collateral that can be withdrawn
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @param _id identifier for the credit line
     * @return total collateral withdrawable by borrower
     */
    function withdrawableCollateral(uint256 _id) public returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(
            creditLineConstants[_id].collateralAsset,
            creditLineConstants[_id].borrowAsset
        );

        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);
        uint256 _currentDebt = calculateCurrentDebt(_id);

        uint256 _collateralNeeded = _currentDebt
            .mul(creditLineConstants[_id].idealCollateralRatio)
            .div(_ratioOfPrices)
            .mul(10**_decimals)
            .div(10**30);

        if (_collateralNeeded >= _totalCollateralTokens) {
            return 0;
        }
        return _totalCollateralTokens.sub(_collateralNeeded);
    }

    function _transferCollateral(
        uint256 _id,
        address _asset,
        uint256 _amountInTokens,
        bool _toSavingsAccount
    ) internal {
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        uint256 _activeAmount;
        for (uint256 index = 0; index < _strategyList.length; index++) {
            uint256 liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];
            if (liquidityShares == 0 || _strategyList[index] == address(0)) {
                continue;
            }
            uint256 _tokenInStrategy = liquidityShares;
            _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(liquidityShares, _asset);
            uint256 _tokensToTransfer = _tokenInStrategy;
            if (_activeAmount.add(_tokenInStrategy) > _amountInTokens) {
                _tokensToTransfer = _amountInTokens.sub(_activeAmount);
                liquidityShares = liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy);
            }
            _activeAmount = _activeAmount.add(_tokensToTransfer);
            collateralShareInStrategy[_id][_strategyList[index]] = collateralShareInStrategy[_id][_strategyList[index]].sub(
                liquidityShares
            );
            if (_toSavingsAccount) {
                ISavingsAccount(savingsAccount).transfer(_tokensToTransfer, _asset, _strategyList[index], msg.sender);
            } else {
                ISavingsAccount(savingsAccount).withdraw(_tokensToTransfer, _asset, _strategyList[index], msg.sender, false);
            }

            if (_activeAmount == _amountInTokens) {
                return;
            }
        }
        revert('insufficient collateral');
    }

    /**
     * @notice used to liquidate credit line in case collateral ratio goes below the threshold
     * @dev if lender liquidates, then collateral is directly transferred. 
            If autoLiquidation is true, anyone can liquidate by providing enough borrow tokens
     * @param _id identifier for the credit line
     * @param _toSavingsAccount if true, tokens are transferred from savingsAccount 
                                otherwise direct from collateral token contract
     */
    function liquidate(uint256 _id, bool _toSavingsAccount) external payable nonReentrant {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: Credit line should be active.');
        require(creditLineVariables[_id].principal != 0, 'CreditLine: cannot liquidate if principal is 0');

        uint256 currentCollateralRatio = calculateCurrentCollateralRatio(_id);
        require(
            currentCollateralRatio < creditLineConstants[_id].idealCollateralRatio,
            'CreditLine: Collateral ratio is higher than ideal value'
        );

        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        address _lender = creditLineConstants[_id].lender;
        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);
        address _borrowAsset = creditLineConstants[_id].borrowAsset;

        creditLineVariables[_id].status = CreditLineStatus.LIQUIDATED;

        if (creditLineConstants[_id].autoLiquidation && _lender != msg.sender) {
            uint256 _borrowTokens = _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens);
            if (_borrowAsset == address(0)) {
                uint256 _returnETH = msg.value.sub(_borrowTokens, 'Insufficient ETH to liquidate');
                if (_returnETH != 0) {
                    (bool success, ) = msg.sender.call{value: _returnETH}('');
                    require(success, 'Transfer fail');
                }
            } else {
                IERC20(_borrowAsset).safeTransferFrom(msg.sender, _lender, _borrowTokens);
            }
        }

        _transferCollateral(_id, _collateralAsset, _totalCollateralTokens, _toSavingsAccount);

        emit CreditLineLiquidated(_id, msg.sender);
    }

    /**
     * @notice used to calculate the borrow tokens necessary for liquidator to liquidate
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @param _id identifier for the credit line
     * @return borrow tokens necessary for liquidator to liquidate
     */
    function borrowTokensToLiquidate(uint256 _id) external returns (uint256) {
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);
        address _borrowAsset = creditLineConstants[_id].borrowAsset;

        return _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens);
    }

    function _borrowTokensToLiquidate(
        address _borrowAsset,
        address _collateralAsset,
        uint256 _totalCollateralTokens
    ) internal view returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(_borrowAsset, _collateralAsset);
        uint256 _borrowTokens = (
            _totalCollateralTokens.mul(uint256(10**30).sub(liquidatorRewardFraction)).div(10**30).mul(_ratioOfPrices).div(10**_decimals)
        );

        return _borrowTokens;
    }

    receive() external payable {
        require(msg.sender == savingsAccount, 'CreditLine::receive invalid transaction');
    }
}
.]

Here is a conversation between two roles: Security Analyst: We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/utils/ReentrancyGuard.sol';
import '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';
import '../interfaces/IPriceOracle.sol';
import '../interfaces/IYield.sol';
import '../interfaces/ISavingsAccount.sol';
import '../SavingsAccount/SavingsAccountUtil.sol';
import '../interfaces/IStrategyRegistry.sol';
/**
 * @title Credit Line contract with Methods related to credit Line
 * @notice Implements the functions related to Credit Line
 * @author Sublime
 **/
contract CreditLine is ReentrancyGuard, OwnableUpgradeable {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;
    enum CreditLineStatus {
        NOT_CREATED,
        REQUESTED,
        ACTIVE,
        CLOSED,
        CANCELLED,
        LIQUIDATED
    }
    /**
     * @notice counter that tracks the number of credit lines created
     * @dev used to create unique identifier for credit lines
     **/
    uint256 public creditLineCounter;
    uint256 constant YEAR_IN_SECONDS = 365 days;
    struct CreditLineVariables {
        CreditLineStatus status;
        uint256 principal;
        uint256 totalInterestRepaid;
        uint256 lastPrincipalUpdateTime;
        uint256 interestAccruedTillLastPrincipalUpdate;
    }
    struct CreditLineConstants {
        address lender;
        address borrower;
        uint256 borrowLimit;
        uint256 idealCollateralRatio;
        uint256 borrowRate;
        address borrowAsset;
        address collateralAsset;
        bool autoLiquidation;
        bool requestByLender;
    }
    /**
     * @notice stores the collateral shares in a credit line per strategy
     * @dev creditLineId => Strategy => collateralShares
     **/
    mapping(uint256 => mapping(address => uint256)) public collateralShareInStrategy;
    /**
     * @notice stores the variables to maintain a credit line
     **/
    mapping(uint256 => CreditLineVariables) public creditLineVariables;
    /**
     * @notice stores the constants related to a credit line
     **/
    mapping(uint256 => CreditLineConstants) public creditLineConstants;
    /**
     * @notice stores the address of savings account contract
     **/
    address public savingsAccount;
    /**
     * @notice stores the address of price oracle contract
     **/
    address public priceOracle;
    /**
     * @notice stores the address of strategy registry contract
     **/
    address public strategyRegistry;
    /**
     * @notice stores the address of default strategy
     **/
    address public defaultStrategy;
    /**
     * @notice stores the fraction of borrowed amount charged as fee by protocol
     * @dev it is multiplied by 10**30
     **/
    uint256 public protocolFeeFraction;
    /**
     * @notice address where protocol fee is collected
     **/
    address public protocolFeeCollector;
    /**
     * @notice stores the fraction of amount liquidated given as reward to liquidator
     * @dev it is multiplied by 10**30
     **/
    uint256 public liquidatorRewardFraction;
    /**
     * @dev checks if Credit Line exists
     * @param _id identifier for the credit line
     **/
    modifier ifCreditLineExists(uint256 _id) {
        require(creditLineVariables[_id].status != CreditLineStatus.NOT_CREATED, 'Credit line does not exist');
        _;
    }
    /**
     * @dev checks if called by credit Line Borrower
     * @param _id creditLine identifier
     **/
    modifier onlyCreditLineBorrower(uint256 _id) {
        require(creditLineConstants[_id].borrower == msg.sender, 'Only credit line Borrower can access');
        _;
    }
    /**
     * @dev checks if called by credit Line Lender
     * @param _id creditLine identifier
     **/
    modifier onlyCreditLineLender(uint256 _id) {
        require(creditLineConstants[_id].lender == msg.sender, 'Only credit line Lender can access');
        _;
    }
    /**
     * @notice emitted when a collateral is deposited into credit line
     * @param id id of the credit line
     * @param amount amount of collateral deposited
     * @param strategy address of the strategy into which collateral is deposited
     */
    event CollateralDeposited(uint256 indexed id, uint256 amount, address indexed strategy);
    /**
     * @notice emitted when collateral is withdrawn from credit line
     * @param id id of the credit line
     * @param amount amount of collateral withdrawn
     */
    event CollateralWithdrawn(uint256 indexed id, uint256 amount);
    /**
     * @notice emitted when a request for new credit line is placed
     * @param id id of the credit line for which request was made
     * @param lender address of the lender for credit line
     * @param borrower address of the borrower for credit line
     */
    event CreditLineRequested(uint256 indexed id, address indexed lender, address indexed borrower);
    /**
     * @notice emitted when a credit line is liquidated
     * @param id id of the credit line which is liquidated
     * @param liquidator address of the liquidator
     */
    event CreditLineLiquidated(uint256 indexed id, address indexed liquidator);
    /**
     * @notice emitted when tokens are borrowed from credit line
     * @param id id of the credit line from which tokens are borrowed
     * @param borrowAmount amount of tokens borrowed
     */
    event BorrowedFromCreditLine(uint256 indexed id, uint256 borrowAmount);
    /**
     * @notice emitted when credit line is accepted
     * @param id id of the credit line that was accepted
     */
    event CreditLineAccepted(uint256 indexed id);
    /**
     * @notice emitted when credit line is completely repaid and reset
     * @param id id of the credit line that is reset
     */
    event CreditLineReset(uint256 indexed id);
    /**
     * @notice emitted when the credit line is partially repaid
     * @param id id of the credit line
     * @param repayAmount amount repaid
     */
    event PartialCreditLineRepaid(uint256 indexed id, uint256 repayAmount);
    /**
     * @notice emitted when the credit line is completely repaid
     * @param id id of the credit line
     * @param repayAmount amount repaid
     */
    event CompleteCreditLineRepaid(uint256 indexed id, uint256 repayAmount);
    /**
     * @notice emitted when the credit line is closed by one of the parties of credit line
     * @param id id of the credit line
     */
    event CreditLineClosed(uint256 indexed id);
    /**
     * @notice emitted when default strategy for the credit line is updated
     * @param defaultStrategy address of the strategy contract that is used as default by credit lines
     */
    event DefaultStrategyUpdated(address indexed defaultStrategy);
    /**
     * @notice emitted when the price oracle is updated
     * @param priceOracle address of the updated price oracle
     */
    event PriceOracleUpdated(address indexed priceOracle);
    /**
     * @notice emitted when the savings account address is updated
     * @param savingsAccount address of the updated savingsAccount
     */
    event SavingsAccountUpdated(address indexed savingsAccount);
    /**
     * @notice emitted when strategy registry address is updated
     * @param strategyRegistry address of the updated strategy registry
     */
    event StrategyRegistryUpdated(address indexed strategyRegistry);
    /**
     * @notice emitted when fee that protocol charges for credit line is updated
     * @param updatedProtocolFee updated value of protocolFeeFraction
     */
    event ProtocolFeeFractionUpdated(uint256 updatedProtocolFee);
    /**
     * @notice emitted when address which receives fee that protocol changes for pools is updated
     * @param updatedProtocolFeeCollector updated value of protocolFeeCollector
     */
    event ProtocolFeeCollectorUpdated(address indexed updatedProtocolFeeCollector);
    /**
     * @notice emitted when liquidatorRewardFraction is updated
     * @param liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator
     */
    event LiquidationRewardFractionUpdated(uint256 liquidatorRewardFraction);
    /**
     * @notice used to initialize the contract
     * @dev can only be called once during the life cycle of the contract
     * @param _defaultStrategy default strategy used in credit lines
     * @param _priceOracle address of the priceOracle
     * @param _savingsAccount address of  the savings account contract
     * @param _strategyRegistry address of the strategy registry contract
     * @param _owner address of owner who can change global variables
     * @param _protocolFeeFraction fraction of the fee charged by protocol
     * @param _protocolFeeCollector address to which protocol fee is charged to
     * @param _liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator
     */
    function initialize(
        address _defaultStrategy,
        address _priceOracle,
        address _savingsAccount,
        address _strategyRegistry,
        address _owner,
        uint256 _protocolFeeFraction,
        address _protocolFeeCollector,
        uint256 _liquidatorRewardFraction
    ) external initializer {
        OwnableUpgradeable.__Ownable_init();
        OwnableUpgradeable.transferOwnership(_owner);
        _updateDefaultStrategy(_defaultStrategy);
        _updatePriceOracle(_priceOracle);
        _updateSavingsAccount(_savingsAccount);
        _updateStrategyRegistry(_strategyRegistry);
        _updateProtocolFeeFraction(_protocolFeeFraction);
        _updateProtocolFeeCollector(_protocolFeeCollector);
        _updateLiquidatorRewardFraction(_liquidatorRewardFraction);
    }
    /**
     * @notice used to update the default strategy
     * @dev can only be updated by owner
     * @param _defaultStrategy address of the updated default strategy
     */
    function updateDefaultStrategy(address _defaultStrategy) external onlyOwner {
        _updateDefaultStrategy(_defaultStrategy);
    }
    function _updateDefaultStrategy(address _defaultStrategy) internal {
        defaultStrategy = _defaultStrategy;
        emit DefaultStrategyUpdated(_defaultStrategy);
    }
    /**
     * @notice used to update the price oracle
     * @dev can only be updated by owner
     * @param _priceOracle address of the updated price oracle
     */
    function updatePriceOracle(address _priceOracle) external onlyOwner {
        _updatePriceOracle(_priceOracle);
    }
    function _updatePriceOracle(address _priceOracle) internal {
        priceOracle = _priceOracle;
        emit PriceOracleUpdated(_priceOracle);
    }
    /**
     * @notice used to update the savings account address
     * @dev can only be updated by owner
     * @param _savingsAccount address of the updated savings account
     */
    function updateSavingsAccount(address _savingsAccount) external onlyOwner {
        _updateSavingsAccount(_savingsAccount);
    }
    function _updateSavingsAccount(address _savingsAccount) internal {
        savingsAccount = _savingsAccount;
        emit SavingsAccountUpdated(_savingsAccount);
    }
    /**
     * @notice used to update the protocol fee fraction
     * @dev can only be updated by owner
     * @param _protocolFee fraction of the borrower amount collected as protocol fee
     */
    function updateProtocolFeeFraction(uint256 _protocolFee) external onlyOwner {
        _updateProtocolFeeFraction(_protocolFee);
    }
    function _updateProtocolFeeFraction(uint256 _protocolFee) internal {
        protocolFeeFraction = _protocolFee;
        emit ProtocolFeeFractionUpdated(_protocolFee);
    }
    /**
     * @notice used to update the protocol fee collector
     * @dev can only be updated by owner
     * @param _protocolFeeCollector address in which protocol fee is collected
     */
    function updateProtocolFeeCollector(address _protocolFeeCollector) external onlyOwner {
        _updateProtocolFeeCollector(_protocolFeeCollector);
    }
    function _updateProtocolFeeCollector(address _protocolFeeCollector) internal {
        require(_protocolFeeCollector != address(0), 'cant be 0 address');
        protocolFeeCollector = _protocolFeeCollector;
        emit ProtocolFeeCollectorUpdated(_protocolFeeCollector);
    }
    /**
     * @notice used to update the strategy registry address
     * @dev can only be updated by owner
     * @param _strategyRegistry address of the updated strategy registry
     */
    function updateStrategyRegistry(address _strategyRegistry) external onlyOwner {
        _updateStrategyRegistry(_strategyRegistry);
    }
    function _updateStrategyRegistry(address _strategyRegistry) internal {
        require(_strategyRegistry != address(0), 'CL::I zero address');
        strategyRegistry = _strategyRegistry;
        emit StrategyRegistryUpdated(_strategyRegistry);
    }
    /**
     * @notice used to update the liquidatorRewardFraction
     * @dev can only be updated by owner
     * @param _rewardFraction fraction of liquidated amount given to liquidator as reward
     */
    function updateLiquidatorRewardFraction(uint256 _rewardFraction) external onlyOwner {
        _updateLiquidatorRewardFraction(_rewardFraction);
    }
    function _updateLiquidatorRewardFraction(uint256 _rewardFraction) internal {
        require(_rewardFraction <= 10**30, 'Fraction has to be less than 1');
        liquidatorRewardFraction = _rewardFraction;
        emit LiquidationRewardFractionUpdated(_rewardFraction);
    }
    /**
     * @dev Used to Calculate Interest Per second on given principal and Interest rate
     * @param _principal principal Amount for which interest has to be calculated.
     * @param _borrowRate It is the Interest Rate at which Credit Line is approved
     * @return interest per second for the given parameters
     */
    function calculateInterest(
        uint256 _principal,
        uint256 _borrowRate,
        uint256 _timeElapsed
    ) public pure returns (uint256) {
        uint256 _interest = _principal.mul(_borrowRate).mul(_timeElapsed).div(10**30).div(YEAR_IN_SECONDS);
        return _interest;
    }
    /**
     * @dev Used to calculate interest accrued since last repayment
     * @param _id identifier for the credit line
     * @return interest accrued over current borrowed amount since last repayment
     */
    function calculateInterestAccrued(uint256 _id) public view returns (uint256) {
        uint256 _lastPrincipalUpdateTime = creditLineVariables[_id].lastPrincipalUpdateTime;
        if (_lastPrincipalUpdateTime == 0) return 0;
        uint256 _timeElapsed = (block.timestamp).sub(_lastPrincipalUpdateTime);
        uint256 _interestAccrued = calculateInterest(creditLineVariables[_id].principal, creditLineConstants[_id].borrowRate, _timeElapsed);
        return _interestAccrued;
    }
    /**
     * @dev Used to calculate current debt of borrower against a credit line.
     * @param _id identifier for the credit line
     * @return current debt of borrower
     */
    function calculateCurrentDebt(uint256 _id) public view returns (uint256) {
        uint256 _interestAccrued = calculateInterestAccrued(_id);
        uint256 _currentDebt = (creditLineVariables[_id].principal)
            .add(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate)
            .add(_interestAccrued)
            .sub(creditLineVariables[_id].totalInterestRepaid);
        return _currentDebt;
    }
    /**
     * @notice used to calculate amount that can be borrowed by the borrower
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view.
            borrowableAmount changes per block as interest changes per block.
     * @param _id identifier for the credit line
     * @return amount that can be borrowed from the credit line
     */
    function calculateBorrowableAmount(uint256 _id) public returns (uint256) {
        CreditLineStatus _status = creditLineVariables[_id].status;
        require(
            _status == CreditLineStatus.ACTIVE || _status == CreditLineStatus.REQUESTED,
            'CreditLine: Cannot only if credit line ACTIVE or REQUESTED'
        );
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(
            creditLineConstants[_id].collateralAsset,
            creditLineConstants[_id].borrowAsset
        );
        uint256 _totalCollateralToken = calculateTotalCollateralTokens(_id);
        uint256 _currentDebt = calculateCurrentDebt(_id);
        uint256 _maxPossible = _totalCollateralToken.mul(_ratioOfPrices).div(creditLineConstants[_id].idealCollateralRatio).mul(10**30).div(
            10**_decimals
        );
        uint256 _borrowLimit = creditLineConstants[_id].borrowLimit;
        if (_maxPossible > _borrowLimit) {
            _maxPossible = _borrowLimit;
        }
        if (_maxPossible > _currentDebt) {
            return _maxPossible.sub(_currentDebt);
        }
        return 0;
    }
    function updateinterestAccruedTillLastPrincipalUpdate(uint256 _id) internal {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');
        uint256 _interestAccrued = calculateInterestAccrued(_id);
        uint256 _newInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(_interestAccrued);
        creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _newInterestAccrued;
    }
    function _depositCollateralFromSavingsAccount(
        uint256 _id,
        uint256 _amount,
        address _sender
    ) internal {
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        uint256 _activeAmount;
        for (uint256 _index = 0; _index < _strategyList.length; _index++) {
            address _strategy = _strategyList[_index];
            uint256 _liquidityShares = _savingsAccount.balanceInShares(_sender, _collateralAsset, _strategy);
            if (_liquidityShares == 0 || _strategyList[_index] == address(0)) {
                continue;
            }
            uint256 _tokenInStrategy = _liquidityShares;
            _tokenInStrategy = IYield(_strategy).getTokensForShares(_liquidityShares, _collateralAsset);
            uint256 _tokensToTransfer = _tokenInStrategy;
            if (_activeAmount.add(_tokenInStrategy) >= _amount) {
                _tokensToTransfer = (_amount.sub(_activeAmount));
            }
            _activeAmount = _activeAmount.add(_tokensToTransfer);
            _savingsAccount.transferFrom(_tokensToTransfer, _collateralAsset, _strategy, _sender, address(this));
            collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(
                _liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy)
            );
            if (_amount == _activeAmount) {
                return;
            }
        }
        revert('CreditLine::_depositCollateralFromSavingsAccount - Insufficient balance');
    }
    /**
     * @notice used to request a credit line either by borrower or lender
     * @param _requestTo Address to which creditLine is requested, 
                        if borrower creates request then lender address and 
                        if lender creates then borrower address
     * @param _borrowLimit maximum borrow amount in a credit line
     * @param _borrowRate Interest Rate at which credit Line is requested
     * @param _autoLiquidation if true, anyone can liquidate loan, otherwise only lender
     * @param _collateralRatio ratio of the collateral to the debt below which credit line can be liquidated
     * @param _borrowAsset address of the token to be borrowed
     * @param _collateralAsset address of the token provided as collateral
     * @param _requestAsLender if true, lender is placing request, otherwise borrower
     * @return identifier for the credit line
     */
    function request(
        address _requestTo,
        uint256 _borrowLimit,
        uint256 _borrowRate,
        bool _autoLiquidation,
        uint256 _collateralRatio,
        address _borrowAsset,
        address _collateralAsset,
        bool _requestAsLender
    ) external returns (uint256) {
        require(_borrowAsset != _collateralAsset, 'R: cant borrow lent token');
        require(IPriceOracle(priceOracle).doesFeedExist(_borrowAsset, _collateralAsset), 'R: No price feed');
        address _lender = _requestTo;
        address _borrower = msg.sender;
        if (_requestAsLender) {
            _lender = msg.sender;
            _borrower = _requestTo;
        }
        uint256 _id = _createRequest(
            _lender,
            _borrower,
            _borrowLimit,
            _borrowRate,
            _autoLiquidation,
            _collateralRatio,
            _borrowAsset,
            _collateralAsset,
            _requestAsLender
        );
        emit CreditLineRequested(_id, _lender, _borrower);
        return _id;
    }
    function _createRequest(
        address _lender,
        address _borrower,
        uint256 _borrowLimit,
        uint256 _borrowRate,
        bool _autoLiquidation,
        uint256 _collateralRatio,
        address _borrowAsset,
        address _collateralAsset,
        bool _requestByLender
    ) internal returns (uint256) {
        require(_lender != _borrower, 'Lender and Borrower cannot be same addresses');
        uint256 _id = creditLineCounter + 1;
        creditLineCounter = _id;
        creditLineVariables[_id].status = CreditLineStatus.REQUESTED;
        creditLineConstants[_id].borrower = _borrower;
        creditLineConstants[_id].lender = _lender;
        creditLineConstants[_id].borrowLimit = _borrowLimit;
        creditLineConstants[_id].autoLiquidation = _autoLiquidation;
        creditLineConstants[_id].idealCollateralRatio = _collateralRatio;
        creditLineConstants[_id].borrowRate = _borrowRate;
        creditLineConstants[_id].borrowAsset = _borrowAsset;
        creditLineConstants[_id].collateralAsset = _collateralAsset;
        creditLineConstants[_id].requestByLender = _requestByLender;
        return _id;
    }
    /**
     * @notice used to accept a credit line
     * @dev if borrower places request, lender can accept and vice versa
     * @param _id identifier for the credit line
     */
    function accept(uint256 _id) external {
        require(
            creditLineVariables[_id].status == CreditLineStatus.REQUESTED,
            'CreditLine::acceptCreditLineLender - CreditLine is already accepted'
        );
        bool _requestByLender = creditLineConstants[_id].requestByLender;
        require(
            (msg.sender == creditLineConstants[_id].borrower && _requestByLender) ||
                (msg.sender == creditLineConstants[_id].lender && !_requestByLender),
            "Only Borrower or Lender who hasn't requested can accept"
        );
        creditLineVariables[_id].status = CreditLineStatus.ACTIVE;
        emit CreditLineAccepted(_id);
    }
    /**
     * @notice used to deposit collateral into the credit line
     * @dev collateral tokens have to be approved in savingsAccount or token contract(unless ether).
            If transferred from savings account, the tokens are transferred from strategies in the 
            order prespecified in strategy registry
     * @param _id identifier for the credit line
     * @param _amount amount of collateral being deposited
     * @param _strategy strategy to which collateral is to be deposited in case transfer is not from savings account
     * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount 
                                otherwise direct from collateral token contract
     */
    function depositCollateral(
        uint256 _id,
        uint256 _amount,
        address _strategy,
        bool _fromSavingsAccount
    ) external payable nonReentrant ifCreditLineExists(_id) {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine not active');
        _depositCollateral(_id, _amount, _strategy, _fromSavingsAccount);
        emit CollateralDeposited(_id, _amount, _strategy);
    }
    function _depositCollateral(
        uint256 _id,
        uint256 _amount,
        address _strategy,
        bool _fromSavingsAccount
    ) internal {
        require(creditLineConstants[_id].lender != msg.sender, 'lender cant deposit collateral');
        if (_fromSavingsAccount) {
            _depositCollateralFromSavingsAccount(_id, _amount, msg.sender);
        } else {
            address _collateralAsset = creditLineConstants[_id].collateralAsset;
            ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
            if (_collateralAsset == address(0)) {
                require(msg.value == _amount, "CreditLine::_depositCollateral - value to transfer doesn't match argument");
            } else {
                IERC20(_collateralAsset).safeTransferFrom(msg.sender, address(this), _amount);
                IERC20(_collateralAsset).approve(_strategy, _amount);
            }
            uint256 _sharesReceived = _savingsAccount.deposit{value: msg.value}(_amount, _collateralAsset, _strategy, address(this));
            collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(_sharesReceived);
        }
    }
    function _withdrawBorrowAmount(
        address _asset,
        uint256 _amountInTokens,
        address _lender
    ) internal {
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        uint256 _activeAmount;
        for (uint256 _index = 0; _index < _strategyList.length; _index++) {
            if (_strategyList[_index] == address(0)) {
                continue;
            }
            uint256 _liquidityShares = _savingsAccount.balanceInShares(_lender, _asset, _strategyList[_index]);
            if (_liquidityShares != 0) {
                uint256 tokenInStrategy = _liquidityShares;
                tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);
                uint256 _tokensToTransfer = tokenInStrategy;
                if (_activeAmount.add(tokenInStrategy) >= _amountInTokens) {
                    _tokensToTransfer = (_amountInTokens.sub(_activeAmount));
                }
                _activeAmount = _activeAmount.add(_tokensToTransfer);
                _savingsAccount.withdrawFrom(_tokensToTransfer, _asset, _strategyList[_index], _lender, address(this), false);
                if (_activeAmount == _amountInTokens) {
                    return;
                }
            }
        }
        require(_activeAmount == _amountInTokens, 'insufficient balance');
    }
    /**
     * @notice used to borrow tokens from credit line by borrower
     * @dev only borrower can call this function. Amount that can actually be borrowed is 
            min(amount based on borrowLimit, allowance to creditLine contract, balance of lender)
     * @param _id identifier for the credit line
     * @param _amount amount of tokens to borrow
     */
    function borrow(uint256 _id, uint256 _amount) external payable nonReentrant onlyCreditLineBorrower(_id) {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');
        uint256 _borrowableAmount = calculateBorrowableAmount(_id);
        require(_amount <= _borrowableAmount, "CreditLine::borrow - The current collateral ratio doesn't allow to withdraw the amount");
        address _borrowAsset = creditLineConstants[_id].borrowAsset;
        address _lender = creditLineConstants[_id].lender;
        updateinterestAccruedTillLastPrincipalUpdate(_id);
        creditLineVariables[_id].principal = creditLineVariables[_id].principal.add(_amount);
        creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;
        uint256 _tokenDiffBalance;
        if (_borrowAsset != address(0)) {
            uint256 _balanceBefore = IERC20(_borrowAsset).balanceOf(address(this));
            _withdrawBorrowAmount(_borrowAsset, _amount, _lender);
            uint256 _balanceAfter = IERC20(_borrowAsset).balanceOf(address(this));
            _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);
        } else {
            uint256 _balanceBefore = address(this).balance;
            _withdrawBorrowAmount(_borrowAsset, _amount, _lender);
            uint256 _balanceAfter = address(this).balance;
            _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);
        }
        uint256 _protocolFee = _tokenDiffBalance.mul(protocolFeeFraction).div(10**30);
        _tokenDiffBalance = _tokenDiffBalance.sub(_protocolFee);
        if (_borrowAsset == address(0)) {
            (bool feeSuccess, ) = protocolFeeCollector.call{value: _protocolFee}('');
            require(feeSuccess, 'Transfer fail');
            (bool success, ) = msg.sender.call{value: _tokenDiffBalance}('');
            require(success, 'Transfer fail');
        } else {
            IERC20(_borrowAsset).safeTransfer(protocolFeeCollector, _protocolFee);
            IERC20(_borrowAsset).safeTransfer(msg.sender, _tokenDiffBalance);
        }
        emit BorrowedFromCreditLine(_id, _tokenDiffBalance);
    }
    function _repayFromSavingsAccount(
        uint256 _amount,
        address _asset,
        address _lender
    ) internal {
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        uint256 _activeAmount;
        for (uint256 _index = 0; _index < _strategyList.length; _index++) {
            if (_strategyList[_index] == address(0)) {
                continue;
            }
            uint256 _liquidityShares = _savingsAccount.balanceInShares(msg.sender, _asset, _strategyList[_index]);
            if (_liquidityShares == 0) {
                continue;
            }
            uint256 _tokenInStrategy = _liquidityShares;
            _tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);
            uint256 _tokensToTransfer = _tokenInStrategy;
            if (_activeAmount.add(_tokenInStrategy) >= _amount) {
                _tokensToTransfer = (_amount.sub(_activeAmount));
            }
            _activeAmount = _activeAmount.add(_tokensToTransfer);
            _savingsAccount.transferFrom(_tokensToTransfer, _asset, _strategyList[_index], msg.sender, _lender);
            if (_amount == _activeAmount) {
                return;
            }
        }
        revert('CreditLine::_repayFromSavingsAccount - Insufficient balance');
    }
    function _repay(
        uint256 _id,
        uint256 _amount,
        bool _fromSavingsAccount,
        uint256 _principalPaid
    ) internal {
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        address _defaultStrategy = defaultStrategy;
        address _borrowAsset = creditLineConstants[_id].borrowAsset;
        address _lender = creditLineConstants[_id].lender;
        if (!_fromSavingsAccount) {
            if (_borrowAsset == address(0)) {
                require(msg.value == _amount, 'creditLine::repay - Ether sent not equal to repay amount');
                _savingsAccount.deposit{value: _amount}(_amount, _borrowAsset, _defaultStrategy, _lender);
            } else {
                IERC20(_borrowAsset).safeTransferFrom(msg.sender, address(this), _amount);
                IERC20(_borrowAsset).approve(_defaultStrategy, _amount);
                _savingsAccount.deposit(_amount, _borrowAsset, _defaultStrategy, _lender);
            }
        } else {
            _repayFromSavingsAccount(_amount, _borrowAsset, _lender);
        }
        if (_principalPaid != 0) {
            _savingsAccount.increaseAllowanceToCreditLine(_principalPaid, _borrowAsset, _lender);
        }
    }
    /**
     * @notice used to repay interest and principal to credit line. Interest has to be repaid before repaying principal
     * @dev partial repayments possible
     * @param _id identifier for the credit line
     * @param _amount amount being repaid
     * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount 
                                otherwise direct from collateral token contract
     */
    function repay(
        uint256 _id,
        uint256 _amount,
        bool _fromSavingsAccount
    ) external payable nonReentrant {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');
        require(creditLineConstants[_id].lender != msg.sender, 'Lender cant repay');
        uint256 _interestSincePrincipalUpdate = calculateInterestAccrued(_id);
        uint256 _totalInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(
            _interestSincePrincipalUpdate
        );
        uint256 _interestToPay = _totalInterestAccrued.sub(creditLineVariables[_id].totalInterestRepaid);
        uint256 _totalCurrentDebt = _interestToPay.add(creditLineVariables[_id].principal);
        uint256 _principalPaid = 0;
        if (_amount >= _totalCurrentDebt) {
            _amount = _totalCurrentDebt;
            emit CompleteCreditLineRepaid(_id, _amount);
        } else {
            emit PartialCreditLineRepaid(_id, _amount);
        }
        if (_amount > _interestToPay) {
            creditLineVariables[_id].principal = _totalCurrentDebt.sub(_amount);
            creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _totalInterestAccrued;
            creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;
            creditLineVariables[_id].totalInterestRepaid = _totalInterestAccrued;
            _principalPaid = _amount.sub(_interestToPay);
        } else {
            creditLineVariables[_id].totalInterestRepaid = creditLineVariables[_id].totalInterestRepaid.add(_amount);
        }
        _repay(_id, _amount, _fromSavingsAccount, _principalPaid);
        if (creditLineVariables[_id].principal == 0) {
            _resetCreditLine(_id);
        }
    }
    function _resetCreditLine(uint256 _id) internal {
        creditLineVariables[_id].lastPrincipalUpdateTime = 0;
        creditLineVariables[_id].totalInterestRepaid = 0;
        creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = 0;
        emit CreditLineReset(_id);
    }
    /**
     * @dev used to close credit line by borrower or lender
     * @param _id identifier for the credit line
     */
    function close(uint256 _id) external ifCreditLineExists(_id) {
        require(
            msg.sender == creditLineConstants[_id].borrower || msg.sender == creditLineConstants[_id].lender,
            'CreditLine: Permission denied while closing Line of credit'
        );
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: Credit line should be active.');
        require(creditLineVariables[_id].principal == 0, 'CreditLine: Cannot be closed since not repaid.');
        require(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate == 0, 'CreditLine: Cannot be closed since not repaid.');
        creditLineVariables[_id].status = CreditLineStatus.CLOSED;
        emit CreditLineClosed(_id);
    }
    /**
     * @notice used to calculate the current collateral ratio
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view.
            Interest is also considered while calculating debt
     * @param _id identifier for the credit line
     * @return collateral ratio multiplied by 10**30 to retain precision
     */
    function calculateCurrentCollateralRatio(uint256 _id) public ifCreditLineExists(_id) returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(
            creditLineConstants[_id].collateralAsset,
            creditLineConstants[_id].borrowAsset
        );
        uint256 currentDebt = calculateCurrentDebt(_id);
        uint256 currentCollateralRatio = calculateTotalCollateralTokens(_id).mul(_ratioOfPrices).div(currentDebt).mul(10**30).div(
            10**_decimals
        );
        return currentCollateralRatio;
    }
    /**
     * @notice used to calculate the total collateral tokens
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @param _id identifier for the credit line
     * @return _amount total collateral tokens deposited into the credit line
     */
    function calculateTotalCollateralTokens(uint256 _id) public returns (uint256 _amount) {
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        uint256 _liquidityShares;
        for (uint256 index = 0; index < _strategyList.length; index++) {
            if (_strategyList[index] == address(0)) {
                continue;
            }
            _liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];
            uint256 _tokenInStrategy = _liquidityShares;
            _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(_liquidityShares, _collateralAsset);
            _amount = _amount.add(_tokenInStrategy);
        }
    }
    /**
     * @notice used to withdraw any excess collateral
     * @dev collateral can't be withdraw if collateralRatio goes below the ideal value. Only borrower can withdraw
     * @param _id identifier for the credit line
     * @param _amount amount of collateral to withdraw
     * @param _toSavingsAccount if true, tokens are transferred from savingsAccount 
                                otherwise direct from collateral token contract
     */
    function withdrawCollateral(
        uint256 _id,
        uint256 _amount,
        bool _toSavingsAccount
    ) external nonReentrant onlyCreditLineBorrower(_id) {
        uint256 _withdrawableCollateral = withdrawableCollateral(_id);
        require(_amount <= _withdrawableCollateral, 'Collateral ratio cant go below ideal');
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        _transferCollateral(_id, _collateralAsset, _amount, _toSavingsAccount);
        emit CollateralWithdrawn(_id, _amount);
    }
    /**
     * @notice used to calculate the collateral that can be withdrawn
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @param _id identifier for the credit line
     * @return total collateral withdrawable by borrower
     */
    function withdrawableCollateral(uint256 _id) public returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(
            creditLineConstants[_id].collateralAsset,
            creditLineConstants[_id].borrowAsset
        );
        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);
        uint256 _currentDebt = calculateCurrentDebt(_id);
        uint256 _collateralNeeded = _currentDebt
            .mul(creditLineConstants[_id].idealCollateralRatio)
            .div(_ratioOfPrices)
            .mul(10**_decimals)
            .div(10**30);
        if (_collateralNeeded >= _totalCollateralTokens) {
            return 0;
        }
        return _totalCollateralTokens.sub(_collateralNeeded);
    }
    function _transferCollateral(
        uint256 _id,
        address _asset,
        uint256 _amountInTokens,
        bool _toSavingsAccount
    ) internal {
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        uint256 _activeAmount;
        for (uint256 index = 0; index < _strategyList.length; index++) {
            uint256 liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];
            if (liquidityShares == 0 || _strategyList[index] == address(0)) {
                continue;
            }
            uint256 _tokenInStrategy = liquidityShares;
            _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(liquidityShares, _asset);
            uint256 _tokensToTransfer = _tokenInStrategy;
            if (_activeAmount.add(_tokenInStrategy) > _amountInTokens) {
                _tokensToTransfer = _amountInTokens.sub(_activeAmount);
                liquidityShares = liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy);
            }
            _activeAmount = _activeAmount.add(_tokensToTransfer);
            collateralShareInStrategy[_id][_strategyList[index]] = collateralShareInStrategy[_id][_strategyList[index]].sub(
                liquidityShares
            );
            if (_toSavingsAccount) {
                ISavingsAccount(savingsAccount).transfer(_tokensToTransfer, _asset, _strategyList[index], msg.sender);
            } else {
                ISavingsAccount(savingsAccount).withdraw(_tokensToTransfer, _asset, _strategyList[index], msg.sender, false);
            }
            if (_activeAmount == _amountInTokens) {
                return;
            }
        }
        revert('insufficient collateral');
    }
    /**
     * @notice used to liquidate credit line in case collateral ratio goes below the threshold
     * @dev if lender liquidates, then collateral is directly transferred. 
            If autoLiquidation is true, anyone can liquidate by providing enough borrow tokens
     * @param _id identifier for the credit line
     * @param _toSavingsAccount if true, tokens are transferred from savingsAccount 
                                otherwise direct from collateral token contract
     */
    function liquidate(uint256 _id, bool _toSavingsAccount) external payable nonReentrant {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: Credit line should be active.');
        require(creditLineVariables[_id].principal != 0, 'CreditLine: cannot liquidate if principal is 0');
        uint256 currentCollateralRatio = calculateCurrentCollateralRatio(_id);
        require(
            currentCollateralRatio < creditLineConstants[_id].idealCollateralRatio,
            'CreditLine: Collateral ratio is higher than ideal value'
        );
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        address _lender = creditLineConstants[_id].lender;
        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);
        address _borrowAsset = creditLineConstants[_id].borrowAsset;
        creditLineVariables[_id].status = CreditLineStatus.LIQUIDATED;
        if (creditLineConstants[_id].autoLiquidation && _lender != msg.sender) {
            uint256 _borrowTokens = _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens);
            if (_borrowAsset == address(0)) {
                uint256 _returnETH = msg.value.sub(_borrowTokens, 'Insufficient ETH to liquidate');
                if (_returnETH != 0) {
                    (bool success, ) = msg.sender.call{value: _returnETH}('');
                    require(success, 'Transfer fail');
                }
            } else {
                IERC20(_borrowAsset).safeTransferFrom(msg.sender, _lender, _borrowTokens);
            }
        }
        _transferCollateral(_id, _collateralAsset, _totalCollateralTokens, _toSavingsAccount);
        emit CreditLineLiquidated(_id, msg.sender);
    }
    /**
     * @notice used to calculate the borrow tokens necessary for liquidator to liquidate
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @param _id identifier for the credit line
     * @return borrow tokens necessary for liquidator to liquidate
     */
    function borrowTokensToLiquidate(uint256 _id) external returns (uint256) {
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);
        address _borrowAsset = creditLineConstants[_id].borrowAsset;
        return _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens);
    }
    function _borrowTokensToLiquidate(
        address _borrowAsset,
        address _collateralAsset,
        uint256 _totalCollateralTokens
    ) internal view returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(_borrowAsset, _collateralAsset);
        uint256 _borrowTokens = (
            _totalCollateralTokens.mul(uint256(10**30).sub(liquidatorRewardFraction)).div(10**30).mul(_ratioOfPrices).div(10**_decimals)
        );
        return _borrowTokens;
    }
    receive() external payable {
        require(msg.sender == savingsAccount, 'CreditLine::receive invalid transaction');
    }
}
.

Chief Executive Officer: We excel in generating innovative approaches and enhancements for Solidity smart contract code.
Here's a Solidity contract provided by the user: "// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/utils/ReentrancyGuard.sol';
import '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';
import '../interfaces/IPriceOracle.sol';
import '../interfaces/IYield.sol';
import '../interfaces/ISavingsAccount.sol';
import '../SavingsAccount/SavingsAccountUtil.sol';
import '../interfaces/IStrategyRegistry.sol';
/**
 * @title Credit Line contract with Methods related to credit Line
 * @notice Implements the functions related to Credit Line
 * @author Sublime
 **/
contract CreditLine is ReentrancyGuard, OwnableUpgradeable {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;
    enum CreditLineStatus {
        NOT_CREATED,
        REQUESTED,
        ACTIVE,
        CLOSED,
        CANCELLED,
        LIQUIDATED
    }
    /**
     * @notice counter that tracks the number of credit lines created
     * @dev used to create unique identifier for credit lines
     **/
    uint256 public creditLineCounter;
    uint256 constant YEAR_IN_SECONDS = 365 days;
    struct CreditLineVariables {
        CreditLineStatus status;
        uint256 principal;
        uint256 totalInterestRepaid;
        uint256 lastPrincipalUpdateTime;
        uint256 interestAccruedTillLastPrincipalUpdate;
    }
    struct CreditLineConstants {
        address lender;
        address borrower;
        uint256 borrowLimit;
        uint256 idealCollateralRatio;
        uint256 borrowRate;
        address borrowAsset;
        address collateralAsset;
        bool autoLiquidation;
        bool requestByLender;
    }
    /**
     * @notice stores the collateral shares in a credit line per strategy
     * @dev creditLineId => Strategy => collateralShares
     **/
    mapping(uint256 => mapping(address => uint256)) public collateralShareInStrategy;
    /**
     * @notice stores the variables to maintain a credit line
     **/
    mapping(uint256 => CreditLineVariables) public creditLineVariables;
    /**
     * @notice stores the constants related to a credit line
     **/
    mapping(uint256 => CreditLineConstants) public creditLineConstants;
    /**
     * @notice stores the address of savings account contract
     **/
    address public savingsAccount;
    /**
     * @notice stores the address of price oracle contract
     **/
    address public priceOracle;
    /**
     * @notice stores the address of strategy registry contract
     **/
    address public strategyRegistry;
    /**
     * @notice stores the address of default strategy
     **/
    address public defaultStrategy;
    /**
     * @notice stores the fraction of borrowed amount charged as fee by protocol
     * @dev it is multiplied by 10**30
     **/
    uint256 public protocolFeeFraction;
    /**
     * @notice address where protocol fee is collected
     **/
    address public protocolFeeCollector;
    /**
     * @notice stores the fraction of amount liquidated given as reward to liquidator
     * @dev it is multiplied by 10**30
     **/
    uint256 public liquidatorRewardFraction;
    /**
     * @dev checks if Credit Line exists
     * @param _id identifier for the credit line
     **/
    modifier ifCreditLineExists(uint256 _id) {
        require(creditLineVariables[_id].status != CreditLineStatus.NOT_CREATED, 'Credit line does not exist');
        _;
    }
    /**
     * @dev checks if called by credit Line Borrower
     * @param _id creditLine identifier
     **/
    modifier onlyCreditLineBorrower(uint256 _id) {
        require(creditLineConstants[_id].borrower == msg.sender, 'Only credit line Borrower can access');
        _;
    }
    /**
     * @dev checks if called by credit Line Lender
     * @param _id creditLine identifier
     **/
    modifier onlyCreditLineLender(uint256 _id) {
        require(creditLineConstants[_id].lender == msg.sender, 'Only credit line Lender can access');
        _;
    }
    /**
     * @notice emitted when a collateral is deposited into credit line
     * @param id id of the credit line
     * @param amount amount of collateral deposited
     * @param strategy address of the strategy into which collateral is deposited
     */
    event CollateralDeposited(uint256 indexed id, uint256 amount, address indexed strategy);
    /**
     * @notice emitted when collateral is withdrawn from credit line
     * @param id id of the credit line
     * @param amount amount of collateral withdrawn
     */
    event CollateralWithdrawn(uint256 indexed id, uint256 amount);
    /**
     * @notice emitted when a request for new credit line is placed
     * @param id id of the credit line for which request was made
     * @param lender address of the lender for credit line
     * @param borrower address of the borrower for credit line
     */
    event CreditLineRequested(uint256 indexed id, address indexed lender, address indexed borrower);
    /**
     * @notice emitted when a credit line is liquidated
     * @param id id of the credit line which is liquidated
     * @param liquidator address of the liquidator
     */
    event CreditLineLiquidated(uint256 indexed id, address indexed liquidator);
    /**
     * @notice emitted when tokens are borrowed from credit line
     * @param id id of the credit line from which tokens are borrowed
     * @param borrowAmount amount of tokens borrowed
     */
    event BorrowedFromCreditLine(uint256 indexed id, uint256 borrowAmount);
    /**
     * @notice emitted when credit line is accepted
     * @param id id of the credit line that was accepted
     */
    event CreditLineAccepted(uint256 indexed id);
    /**
     * @notice emitted when credit line is completely repaid and reset
     * @param id id of the credit line that is reset
     */
    event CreditLineReset(uint256 indexed id);
    /**
     * @notice emitted when the credit line is partially repaid
     * @param id id of the credit line
     * @param repayAmount amount repaid
     */
    event PartialCreditLineRepaid(uint256 indexed id, uint256 repayAmount);
    /**
     * @notice emitted when the credit line is completely repaid
     * @param id id of the credit line
     * @param repayAmount amount repaid
     */
    event CompleteCreditLineRepaid(uint256 indexed id, uint256 repayAmount);
    /**
     * @notice emitted when the credit line is closed by one of the parties of credit line
     * @param id id of the credit line
     */
    event CreditLineClosed(uint256 indexed id);
    /**
     * @notice emitted when default strategy for the credit line is updated
     * @param defaultStrategy address of the strategy contract that is used as default by credit lines
     */
    event DefaultStrategyUpdated(address indexed defaultStrategy);
    /**
     * @notice emitted when the price oracle is updated
     * @param priceOracle address of the updated price oracle
     */
    event PriceOracleUpdated(address indexed priceOracle);
    /**
     * @notice emitted when the savings account address is updated
     * @param savingsAccount address of the updated savingsAccount
     */
    event SavingsAccountUpdated(address indexed savingsAccount);
    /**
     * @notice emitted when strategy registry address is updated
     * @param strategyRegistry address of the updated strategy registry
     */
    event StrategyRegistryUpdated(address indexed strategyRegistry);
    /**
     * @notice emitted when fee that protocol charges for credit line is updated
     * @param updatedProtocolFee updated value of protocolFeeFraction
     */
    event ProtocolFeeFractionUpdated(uint256 updatedProtocolFee);
    /**
     * @notice emitted when address which receives fee that protocol changes for pools is updated
     * @param updatedProtocolFeeCollector updated value of protocolFeeCollector
     */
    event ProtocolFeeCollectorUpdated(address indexed updatedProtocolFeeCollector);
    /**
     * @notice emitted when liquidatorRewardFraction is updated
     * @param liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator
     */
    event LiquidationRewardFractionUpdated(uint256 liquidatorRewardFraction);
    /**
     * @notice used to initialize the contract
     * @dev can only be called once during the life cycle of the contract
     * @param _defaultStrategy default strategy used in credit lines
     * @param _priceOracle address of the priceOracle
     * @param _savingsAccount address of  the savings account contract
     * @param _strategyRegistry address of the strategy registry contract
     * @param _owner address of owner who can change global variables
     * @param _protocolFeeFraction fraction of the fee charged by protocol
     * @param _protocolFeeCollector address to which protocol fee is charged to
     * @param _liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator
     */
    function initialize(
        address _defaultStrategy,
        address _priceOracle,
        address _savingsAccount,
        address _strategyRegistry,
        address _owner,
        uint256 _protocolFeeFraction,
        address _protocolFeeCollector,
        uint256 _liquidatorRewardFraction
    ) external initializer {
        OwnableUpgradeable.__Ownable_init();
        OwnableUpgradeable.transferOwnership(_owner);
        _updateDefaultStrategy(_defaultStrategy);
        _updatePriceOracle(_priceOracle);
        _updateSavingsAccount(_savingsAccount);
        _updateStrategyRegistry(_strategyRegistry);
        _updateProtocolFeeFraction(_protocolFeeFraction);
        _updateProtocolFeeCollector(_protocolFeeCollector);
        _updateLiquidatorRewardFraction(_liquidatorRewardFraction);
    }
    /**
     * @notice used to update the default strategy
     * @dev can only be updated by owner
     * @param _defaultStrategy address of the updated default strategy
     */
    function updateDefaultStrategy(address _defaultStrategy) external onlyOwner {
        _updateDefaultStrategy(_defaultStrategy);
    }
    function _updateDefaultStrategy(address _defaultStrategy) internal {
        defaultStrategy = _defaultStrategy;
        emit DefaultStrategyUpdated(_defaultStrategy);
    }
    /**
     * @notice used to update the price oracle
     * @dev can only be updated by owner
     * @param _priceOracle address of the updated price oracle
     */
    function updatePriceOracle(address _priceOracle) external onlyOwner {
        _updatePriceOracle(_priceOracle);
    }
    function _updatePriceOracle(address _priceOracle) internal {
        priceOracle = _priceOracle;
        emit PriceOracleUpdated(_priceOracle);
    }
    /**
     * @notice used to update the savings account address
     * @dev can only be updated by owner
     * @param _savingsAccount address of the updated savings account
     */
    function updateSavingsAccount(address _savingsAccount) external onlyOwner {
        _updateSavingsAccount(_savingsAccount);
    }
    function _updateSavingsAccount(address _savingsAccount) internal {
        savingsAccount = _savingsAccount;
        emit SavingsAccountUpdated(_savingsAccount);
    }
    /**
     * @notice used to update the protocol fee fraction
     * @dev can only be updated by owner
     * @param _protocolFee fraction of the borrower amount collected as protocol fee
     */
    function updateProtocolFeeFraction(uint256 _protocolFee) external onlyOwner {
        _updateProtocolFeeFraction(_protocolFee);
    }
    function _updateProtocolFeeFraction(uint256 _protocolFee) internal {
        protocolFeeFraction = _protocolFee;
        emit ProtocolFeeFractionUpdated(_protocolFee);
    }
    /**
     * @notice used to update the protocol fee collector
     * @dev can only be updated by owner
     * @param _protocolFeeCollector address in which protocol fee is collected
     */
    function updateProtocolFeeCollector(address _protocolFeeCollector) external onlyOwner {
        _updateProtocolFeeCollector(_protocolFeeCollector);
    }
    function _updateProtocolFeeCollector(address _protocolFeeCollector) internal {
        require(_protocolFeeCollector != address(0), 'cant be 0 address');
        protocolFeeCollector = _protocolFeeCollector;
        emit ProtocolFeeCollectorUpdated(_protocolFeeCollector);
    }
    /**
     * @notice used to update the strategy registry address
     * @dev can only be updated by owner
     * @param _strategyRegistry address of the updated strategy registry
     */
    function updateStrategyRegistry(address _strategyRegistry) external onlyOwner {
        _updateStrategyRegistry(_strategyRegistry);
    }
    function _updateStrategyRegistry(address _strategyRegistry) internal {
        require(_strategyRegistry != address(0), 'CL::I zero address');
        strategyRegistry = _strategyRegistry;
        emit StrategyRegistryUpdated(_strategyRegistry);
    }
    /**
     * @notice used to update the liquidatorRewardFraction
     * @dev can only be updated by owner
     * @param _rewardFraction fraction of liquidated amount given to liquidator as reward
     */
    function updateLiquidatorRewardFraction(uint256 _rewardFraction) external onlyOwner {
        _updateLiquidatorRewardFraction(_rewardFraction);
    }
    function _updateLiquidatorRewardFraction(uint256 _rewardFraction) internal {
        require(_rewardFraction <= 10**30, 'Fraction has to be less than 1');
        liquidatorRewardFraction = _rewardFraction;
        emit LiquidationRewardFractionUpdated(_rewardFraction);
    }
    /**
     * @dev Used to Calculate Interest Per second on given principal and Interest rate
     * @param _principal principal Amount for which interest has to be calculated.
     * @param _borrowRate It is the Interest Rate at which Credit Line is approved
     * @return interest per second for the given parameters
     */
    function calculateInterest(
        uint256 _principal,
        uint256 _borrowRate,
        uint256 _timeElapsed
    ) public pure returns (uint256) {
        uint256 _interest = _principal.mul(_borrowRate).mul(_timeElapsed).div(10**30).div(YEAR_IN_SECONDS);
        return _interest;
    }
    /**
     * @dev Used to calculate interest accrued since last repayment
     * @param _id identifier for the credit line
     * @return interest accrued over current borrowed amount since last repayment
     */
    function calculateInterestAccrued(uint256 _id) public view returns (uint256) {
        uint256 _lastPrincipalUpdateTime = creditLineVariables[_id].lastPrincipalUpdateTime;
        if (_lastPrincipalUpdateTime == 0) return 0;
        uint256 _timeElapsed = (block.timestamp).sub(_lastPrincipalUpdateTime);
        uint256 _interestAccrued = calculateInterest(creditLineVariables[_id].principal, creditLineConstants[_id].borrowRate, _timeElapsed);
        return _interestAccrued;
    }
    /**
     * @dev Used to calculate current debt of borrower against a credit line.
     * @param _id identifier for the credit line
     * @return current debt of borrower
     */
    function calculateCurrentDebt(uint256 _id) public view returns (uint256) {
        uint256 _interestAccrued = calculateInterestAccrued(_id);
        uint256 _currentDebt = (creditLineVariables[_id].principal)
            .add(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate)
            .add(_interestAccrued)
            .sub(creditLineVariables[_id].totalInterestRepaid);
        return _currentDebt;
    }
    /**
     * @notice used to calculate amount that can be borrowed by the borrower
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view.
            borrowableAmount changes per block as interest changes per block.
     * @param _id identifier for the credit line
     * @return amount that can be borrowed from the credit line
     */
    function calculateBorrowableAmount(uint256 _id) public returns (uint256) {
        CreditLineStatus _status = creditLineVariables[_id].status;
        require(
            _status == CreditLineStatus.ACTIVE || _status == CreditLineStatus.REQUESTED,
            'CreditLine: Cannot only if credit line ACTIVE or REQUESTED'
        );
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(
            creditLineConstants[_id].collateralAsset,
            creditLineConstants[_id].borrowAsset
        );
        uint256 _totalCollateralToken = calculateTotalCollateralTokens(_id);
        uint256 _currentDebt = calculateCurrentDebt(_id);
        uint256 _maxPossible = _totalCollateralToken.mul(_ratioOfPrices).div(creditLineConstants[_id].idealCollateralRatio).mul(10**30).div(
            10**_decimals
        );
        uint256 _borrowLimit = creditLineConstants[_id].borrowLimit;
        if (_maxPossible > _borrowLimit) {
            _maxPossible = _borrowLimit;
        }
        if (_maxPossible > _currentDebt) {
            return _maxPossible.sub(_currentDebt);
        }
        return 0;
    }
    function updateinterestAccruedTillLastPrincipalUpdate(uint256 _id) internal {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');
        uint256 _interestAccrued = calculateInterestAccrued(_id);
        uint256 _newInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(_interestAccrued);
        creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _newInterestAccrued;
    }
    function _depositCollateralFromSavingsAccount(
        uint256 _id,
        uint256 _amount,
        address _sender
    ) internal {
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        uint256 _activeAmount;
        for (uint256 _index = 0; _index < _strategyList.length; _index++) {
            address _strategy = _strategyList[_index];
            uint256 _liquidityShares = _savingsAccount.balanceInShares(_sender, _collateralAsset, _strategy);
            if (_liquidityShares == 0 || _strategyList[_index] == address(0)) {
                continue;
            }
            uint256 _tokenInStrategy = _liquidityShares;
            _tokenInStrategy = IYield(_strategy).getTokensForShares(_liquidityShares, _collateralAsset);
            uint256 _tokensToTransfer = _tokenInStrategy;
            if (_activeAmount.add(_tokenInStrategy) >= _amount) {
                _tokensToTransfer = (_amount.sub(_activeAmount));
            }
            _activeAmount = _activeAmount.add(_tokensToTransfer);
            _savingsAccount.transferFrom(_tokensToTransfer, _collateralAsset, _strategy, _sender, address(this));
            collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(
                _liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy)
            );
            if (_amount == _activeAmount) {
                return;
            }
        }
        revert('CreditLine::_depositCollateralFromSavingsAccount - Insufficient balance');
    }
    /**
     * @notice used to request a credit line either by borrower or lender
     * @param _requestTo Address to which creditLine is requested, 
                        if borrower creates request then lender address and 
                        if lender creates then borrower address
     * @param _borrowLimit maximum borrow amount in a credit line
     * @param _borrowRate Interest Rate at which credit Line is requested
     * @param _autoLiquidation if true, anyone can liquidate loan, otherwise only lender
     * @param _collateralRatio ratio of the collateral to the debt below which credit line can be liquidated
     * @param _borrowAsset address of the token to be borrowed
     * @param _collateralAsset address of the token provided as collateral
     * @param _requestAsLender if true, lender is placing request, otherwise borrower
     * @return identifier for the credit line
     */
    function request(
        address _requestTo,
        uint256 _borrowLimit,
        uint256 _borrowRate,
        bool _autoLiquidation,
        uint256 _collateralRatio,
        address _borrowAsset,
        address _collateralAsset,
        bool _requestAsLender
    ) external returns (uint256) {
        require(_borrowAsset != _collateralAsset, 'R: cant borrow lent token');
        require(IPriceOracle(priceOracle).doesFeedExist(_borrowAsset, _collateralAsset), 'R: No price feed');
        address _lender = _requestTo;
        address _borrower = msg.sender;
        if (_requestAsLender) {
            _lender = msg.sender;
            _borrower = _requestTo;
        }
        uint256 _id = _createRequest(
            _lender,
            _borrower,
            _borrowLimit,
            _borrowRate,
            _autoLiquidation,
            _collateralRatio,
            _borrowAsset,
            _collateralAsset,
            _requestAsLender
        );
        emit CreditLineRequested(_id, _lender, _borrower);
        return _id;
    }
    function _createRequest(
        address _lender,
        address _borrower,
        uint256 _borrowLimit,
        uint256 _borrowRate,
        bool _autoLiquidation,
        uint256 _collateralRatio,
        address _borrowAsset,
        address _collateralAsset,
        bool _requestByLender
    ) internal returns (uint256) {
        require(_lender != _borrower, 'Lender and Borrower cannot be same addresses');
        uint256 _id = creditLineCounter + 1;
        creditLineCounter = _id;
        creditLineVariables[_id].status = CreditLineStatus.REQUESTED;
        creditLineConstants[_id].borrower = _borrower;
        creditLineConstants[_id].lender = _lender;
        creditLineConstants[_id].borrowLimit = _borrowLimit;
        creditLineConstants[_id].autoLiquidation = _autoLiquidation;
        creditLineConstants[_id].idealCollateralRatio = _collateralRatio;
        creditLineConstants[_id].borrowRate = _borrowRate;
        creditLineConstants[_id].borrowAsset = _borrowAsset;
        creditLineConstants[_id].collateralAsset = _collateralAsset;
        creditLineConstants[_id].requestByLender = _requestByLender;
        return _id;
    }
    /**
     * @notice used to accept a credit line
     * @dev if borrower places request, lender can accept and vice versa
     * @param _id identifier for the credit line
     */
    function accept(uint256 _id) external {
        require(
            creditLineVariables[_id].status == CreditLineStatus.REQUESTED,
            'CreditLine::acceptCreditLineLender - CreditLine is already accepted'
        );
        bool _requestByLender = creditLineConstants[_id].requestByLender;
        require(
            (msg.sender == creditLineConstants[_id].borrower && _requestByLender) ||
                (msg.sender == creditLineConstants[_id].lender && !_requestByLender),
            "Only Borrower or Lender who hasn't requested can accept"
        );
        creditLineVariables[_id].status = CreditLineStatus.ACTIVE;
        emit CreditLineAccepted(_id);
    }
    /**
     * @notice used to deposit collateral into the credit line
     * @dev collateral tokens have to be approved in savingsAccount or token contract(unless ether).
            If transferred from savings account, the tokens are transferred from strategies in the 
            order prespecified in strategy registry
     * @param _id identifier for the credit line
     * @param _amount amount of collateral being deposited
     * @param _strategy strategy to which collateral is to be deposited in case transfer is not from savings account
     * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount 
                                otherwise direct from collateral token contract
     */
    function depositCollateral(
        uint256 _id,
        uint256 _amount,
        address _strategy,
        bool _fromSavingsAccount
    ) external payable nonReentrant ifCreditLineExists(_id) {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine not active');
        _depositCollateral(_id, _amount, _strategy, _fromSavingsAccount);
        emit CollateralDeposited(_id, _amount, _strategy);
    }
    function _depositCollateral(
        uint256 _id,
        uint256 _amount,
        address _strategy,
        bool _fromSavingsAccount
    ) internal {
        require(creditLineConstants[_id].lender != msg.sender, 'lender cant deposit collateral');
        if (_fromSavingsAccount) {
            _depositCollateralFromSavingsAccount(_id, _amount, msg.sender);
        } else {
            address _collateralAsset = creditLineConstants[_id].collateralAsset;
            ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
            if (_collateralAsset == address(0)) {
                require(msg.value == _amount, "CreditLine::_depositCollateral - value to transfer doesn't match argument");
            } else {
                IERC20(_collateralAsset).safeTransferFrom(msg.sender, address(this), _amount);
                IERC20(_collateralAsset).approve(_strategy, _amount);
            }
            uint256 _sharesReceived = _savingsAccount.deposit{value: msg.value}(_amount, _collateralAsset, _strategy, address(this));
            collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(_sharesReceived);
        }
    }
    function _withdrawBorrowAmount(
        address _asset,
        uint256 _amountInTokens,
        address _lender
    ) internal {
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        uint256 _activeAmount;
        for (uint256 _index = 0; _index < _strategyList.length; _index++) {
            if (_strategyList[_index] == address(0)) {
                continue;
            }
            uint256 _liquidityShares = _savingsAccount.balanceInShares(_lender, _asset, _strategyList[_index]);
            if (_liquidityShares != 0) {
                uint256 tokenInStrategy = _liquidityShares;
                tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);
                uint256 _tokensToTransfer = tokenInStrategy;
                if (_activeAmount.add(tokenInStrategy) >= _amountInTokens) {
                    _tokensToTransfer = (_amountInTokens.sub(_activeAmount));
                }
                _activeAmount = _activeAmount.add(_tokensToTransfer);
                _savingsAccount.withdrawFrom(_tokensToTransfer, _asset, _strategyList[_index], _lender, address(this), false);
                if (_activeAmount == _amountInTokens) {
                    return;
                }
            }
        }
        require(_activeAmount == _amountInTokens, 'insufficient balance');
    }
    /**
     * @notice used to borrow tokens from credit line by borrower
     * @dev only borrower can call this function. Amount that can actually be borrowed is 
            min(amount based on borrowLimit, allowance to creditLine contract, balance of lender)
     * @param _id identifier for the credit line
     * @param _amount amount of tokens to borrow
     */
    function borrow(uint256 _id, uint256 _amount) external payable nonReentrant onlyCreditLineBorrower(_id) {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');
        uint256 _borrowableAmount = calculateBorrowableAmount(_id);
        require(_amount <= _borrowableAmount, "CreditLine::borrow - The current collateral ratio doesn't allow to withdraw the amount");
        address _borrowAsset = creditLineConstants[_id].borrowAsset;
        address _lender = creditLineConstants[_id].lender;
        updateinterestAccruedTillLastPrincipalUpdate(_id);
        creditLineVariables[_id].principal = creditLineVariables[_id].principal.add(_amount);
        creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;
        uint256 _tokenDiffBalance;
        if (_borrowAsset != address(0)) {
            uint256 _balanceBefore = IERC20(_borrowAsset).balanceOf(address(this));
            _withdrawBorrowAmount(_borrowAsset, _amount, _lender);
            uint256 _balanceAfter = IERC20(_borrowAsset).balanceOf(address(this));
            _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);
        } else {
            uint256 _balanceBefore = address(this).balance;
            _withdrawBorrowAmount(_borrowAsset, _amount, _lender);
            uint256 _balanceAfter = address(this).balance;
            _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);
        }
        uint256 _protocolFee = _tokenDiffBalance.mul(protocolFeeFraction).div(10**30);
        _tokenDiffBalance = _tokenDiffBalance.sub(_protocolFee);
        if (_borrowAsset == address(0)) {
            (bool feeSuccess, ) = protocolFeeCollector.call{value: _protocolFee}('');
            require(feeSuccess, 'Transfer fail');
            (bool success, ) = msg.sender.call{value: _tokenDiffBalance}('');
            require(success, 'Transfer fail');
        } else {
            IERC20(_borrowAsset).safeTransfer(protocolFeeCollector, _protocolFee);
            IERC20(_borrowAsset).safeTransfer(msg.sender, _tokenDiffBalance);
        }
        emit BorrowedFromCreditLine(_id, _tokenDiffBalance);
    }
    function _repayFromSavingsAccount(
        uint256 _amount,
        address _asset,
        address _lender
    ) internal {
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        uint256 _activeAmount;
        for (uint256 _index = 0; _index < _strategyList.length; _index++) {
            if (_strategyList[_index] == address(0)) {
                continue;
            }
            uint256 _liquidityShares = _savingsAccount.balanceInShares(msg.sender, _asset, _strategyList[_index]);
            if (_liquidityShares == 0) {
                continue;
            }
            uint256 _tokenInStrategy = _liquidityShares;
            _tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);
            uint256 _tokensToTransfer = _tokenInStrategy;
            if (_activeAmount.add(_tokenInStrategy) >= _amount) {
                _tokensToTransfer = (_amount.sub(_activeAmount));
            }
            _activeAmount = _activeAmount.add(_tokensToTransfer);
            _savingsAccount.transferFrom(_tokensToTransfer, _asset, _strategyList[_index], msg.sender, _lender);
            if (_amount == _activeAmount) {
                return;
            }
        }
        revert('CreditLine::_repayFromSavingsAccount - Insufficient balance');
    }
    function _repay(
        uint256 _id,
        uint256 _amount,
        bool _fromSavingsAccount,
        uint256 _principalPaid
    ) internal {
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        address _defaultStrategy = defaultStrategy;
        address _borrowAsset = creditLineConstants[_id].borrowAsset;
        address _lender = creditLineConstants[_id].lender;
        if (!_fromSavingsAccount) {
            if (_borrowAsset == address(0)) {
                require(msg.value == _amount, 'creditLine::repay - Ether sent not equal to repay amount');
                _savingsAccount.deposit{value: _amount}(_amount, _borrowAsset, _defaultStrategy, _lender);
            } else {
                IERC20(_borrowAsset).safeTransferFrom(msg.sender, address(this), _amount);
                IERC20(_borrowAsset).approve(_defaultStrategy, _amount);
                _savingsAccount.deposit(_amount, _borrowAsset, _defaultStrategy, _lender);
            }
        } else {
            _repayFromSavingsAccount(_amount, _borrowAsset, _lender);
        }
        if (_principalPaid != 0) {
            _savingsAccount.increaseAllowanceToCreditLine(_principalPaid, _borrowAsset, _lender);
        }
    }
    /**
     * @notice used to repay interest and principal to credit line. Interest has to be repaid before repaying principal
     * @dev partial repayments possible
     * @param _id identifier for the credit line
     * @param _amount amount being repaid
     * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount 
                                otherwise direct from collateral token contract
     */
    function repay(
        uint256 _id,
        uint256 _amount,
        bool _fromSavingsAccount
    ) external payable nonReentrant {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');
        require(creditLineConstants[_id].lender != msg.sender, 'Lender cant repay');
        uint256 _interestSincePrincipalUpdate = calculateInterestAccrued(_id);
        uint256 _totalInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(
            _interestSincePrincipalUpdate
        );
        uint256 _interestToPay = _totalInterestAccrued.sub(creditLineVariables[_id].totalInterestRepaid);
        uint256 _totalCurrentDebt = _interestToPay.add(creditLineVariables[_id].principal);
        uint256 _principalPaid = 0;
        if (_amount >= _totalCurrentDebt) {
            _amount = _totalCurrentDebt;
            emit CompleteCreditLineRepaid(_id, _amount);
        } else {
            emit PartialCreditLineRepaid(_id, _amount);
        }
        if (_amount > _interestToPay) {
            creditLineVariables[_id].principal = _totalCurrentDebt.sub(_amount);
            creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _totalInterestAccrued;
            creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;
            creditLineVariables[_id].totalInterestRepaid = _totalInterestAccrued;
            _principalPaid = _amount.sub(_interestToPay);
        } else {
            creditLineVariables[_id].totalInterestRepaid = creditLineVariables[_id].totalInterestRepaid.add(_amount);
        }
        _repay(_id, _amount, _fromSavingsAccount, _principalPaid);
        if (creditLineVariables[_id].principal == 0) {
            _resetCreditLine(_id);
        }
    }
    function _resetCreditLine(uint256 _id) internal {
        creditLineVariables[_id].lastPrincipalUpdateTime = 0;
        creditLineVariables[_id].totalInterestRepaid = 0;
        creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = 0;
        emit CreditLineReset(_id);
    }
    /**
     * @dev used to close credit line by borrower or lender
     * @param _id identifier for the credit line
     */
    function close(uint256 _id) external ifCreditLineExists(_id) {
        require(
            msg.sender == creditLineConstants[_id].borrower || msg.sender == creditLineConstants[_id].lender,
            'CreditLine: Permission denied while closing Line of credit'
        );
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: Credit line should be active.');
        require(creditLineVariables[_id].principal == 0, 'CreditLine: Cannot be closed since not repaid.');
        require(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate == 0, 'CreditLine: Cannot be closed since not repaid.');
        creditLineVariables[_id].status = CreditLineStatus.CLOSED;
        emit CreditLineClosed(_id);
    }
    /**
     * @notice used to calculate the current collateral ratio
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view.
            Interest is also considered while calculating debt
     * @param _id identifier for the credit line
     * @return collateral ratio multiplied by 10**30 to retain precision
     */
    function calculateCurrentCollateralRatio(uint256 _id) public ifCreditLineExists(_id) returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(
            creditLineConstants[_id].collateralAsset,
            creditLineConstants[_id].borrowAsset
        );
        uint256 currentDebt = calculateCurrentDebt(_id);
        uint256 currentCollateralRatio = calculateTotalCollateralTokens(_id).mul(_ratioOfPrices).div(currentDebt).mul(10**30).div(
            10**_decimals
        );
        return currentCollateralRatio;
    }
    /**
     * @notice used to calculate the total collateral tokens
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @param _id identifier for the credit line
     * @return _amount total collateral tokens deposited into the credit line
     */
    function calculateTotalCollateralTokens(uint256 _id) public returns (uint256 _amount) {
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        uint256 _liquidityShares;
        for (uint256 index = 0; index < _strategyList.length; index++) {
            if (_strategyList[index] == address(0)) {
                continue;
            }
            _liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];
            uint256 _tokenInStrategy = _liquidityShares;
            _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(_liquidityShares, _collateralAsset);
            _amount = _amount.add(_tokenInStrategy);
        }
    }
    /**
     * @notice used to withdraw any excess collateral
     * @dev collateral can't be withdraw if collateralRatio goes below the ideal value. Only borrower can withdraw
     * @param _id identifier for the credit line
     * @param _amount amount of collateral to withdraw
     * @param _toSavingsAccount if true, tokens are transferred from savingsAccount 
                                otherwise direct from collateral token contract
     */
    function withdrawCollateral(
        uint256 _id,
        uint256 _amount,
        bool _toSavingsAccount
    ) external nonReentrant onlyCreditLineBorrower(_id) {
        uint256 _withdrawableCollateral = withdrawableCollateral(_id);
        require(_amount <= _withdrawableCollateral, 'Collateral ratio cant go below ideal');
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        _transferCollateral(_id, _collateralAsset, _amount, _toSavingsAccount);
        emit CollateralWithdrawn(_id, _amount);
    }
    /**
     * @notice used to calculate the collateral that can be withdrawn
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @param _id identifier for the credit line
     * @return total collateral withdrawable by borrower
     */
    function withdrawableCollateral(uint256 _id) public returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(
            creditLineConstants[_id].collateralAsset,
            creditLineConstants[_id].borrowAsset
        );
        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);
        uint256 _currentDebt = calculateCurrentDebt(_id);
        uint256 _collateralNeeded = _currentDebt
            .mul(creditLineConstants[_id].idealCollateralRatio)
            .div(_ratioOfPrices)
            .mul(10**_decimals)
            .div(10**30);
        if (_collateralNeeded >= _totalCollateralTokens) {
            return 0;
        }
        return _totalCollateralTokens.sub(_collateralNeeded);
    }
    function _transferCollateral(
        uint256 _id,
        address _asset,
        uint256 _amountInTokens,
        bool _toSavingsAccount
    ) internal {
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        uint256 _activeAmount;
        for (uint256 index = 0; index < _strategyList.length; index++) {
            uint256 liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];
            if (liquidityShares == 0 || _strategyList[index] == address(0)) {
                continue;
            }
            uint256 _tokenInStrategy = liquidityShares;
            _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(liquidityShares, _asset);
            uint256 _tokensToTransfer = _tokenInStrategy;
            if (_activeAmount.add(_tokenInStrategy) > _amountInTokens) {
                _tokensToTransfer = _amountInTokens.sub(_activeAmount);
                liquidityShares = liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy);
            }
            _activeAmount = _activeAmount.add(_tokensToTransfer);
            collateralShareInStrategy[_id][_strategyList[index]] = collateralShareInStrategy[_id][_strategyList[index]].sub(
                liquidityShares
            );
            if (_toSavingsAccount) {
                ISavingsAccount(savingsAccount).transfer(_tokensToTransfer, _asset, _strategyList[index], msg.sender);
            } else {
                ISavingsAccount(savingsAccount).withdraw(_tokensToTransfer, _asset, _strategyList[index], msg.sender, false);
            }
            if (_activeAmount == _amountInTokens) {
                return;
            }
        }
        revert('insufficient collateral');
    }
    /**
     * @notice used to liquidate credit line in case collateral ratio goes below the threshold
     * @dev if lender liquidates, then collateral is directly transferred. 
            If autoLiquidation is true, anyone can liquidate by providing enough borrow tokens
     * @param _id identifier for the credit line
     * @param _toSavingsAccount if true, tokens are transferred from savingsAccount 
                                otherwise direct from collateral token contract
     */
    function liquidate(uint256 _id, bool _toSavingsAccount) external payable nonReentrant {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: Credit line should be active.');
        require(creditLineVariables[_id].principal != 0, 'CreditLine: cannot liquidate if principal is 0');
        uint256 currentCollateralRatio = calculateCurrentCollateralRatio(_id);
        require(
            currentCollateralRatio < creditLineConstants[_id].idealCollateralRatio,
            'CreditLine: Collateral ratio is higher than ideal value'
        );
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        address _lender = creditLineConstants[_id].lender;
        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);
        address _borrowAsset = creditLineConstants[_id].borrowAsset;
        creditLineVariables[_id].status = CreditLineStatus.LIQUIDATED;
        if (creditLineConstants[_id].autoLiquidation && _lender != msg.sender) {
            uint256 _borrowTokens = _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens);
            if (_borrowAsset == address(0)) {
                uint256 _returnETH = msg.value.sub(_borrowTokens, 'Insufficient ETH to liquidate');
                if (_returnETH != 0) {
                    (bool success, ) = msg.sender.call{value: _returnETH}('');
                    require(success, 'Transfer fail');
                }
            } else {
                IERC20(_borrowAsset).safeTransferFrom(msg.sender, _lender, _borrowTokens);
            }
        }
        _transferCollateral(_id, _collateralAsset, _totalCollateralTokens, _toSavingsAccount);
        emit CreditLineLiquidated(_id, msg.sender);
    }
    /**
     * @notice used to calculate the borrow tokens necessary for liquidator to liquidate
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @param _id identifier for the credit line
     * @return borrow tokens necessary for liquidator to liquidate
     */
    function borrowTokensToLiquidate(uint256 _id) external returns (uint256) {
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);
        address _borrowAsset = creditLineConstants[_id].borrowAsset;
        return _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens);
    }
    function _borrowTokensToLiquidate(
        address _borrowAsset,
        address _collateralAsset,
        uint256 _totalCollateralTokens
    ) internal view returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(_borrowAsset, _collateralAsset);
        uint256 _borrowTokens = (
            _totalCollateralTokens.mul(uint256(10**30).sub(liquidatorRewardFraction)).div(10**30).mul(_ratioOfPrices).div(10**_decimals)
        );
        return _borrowTokens;
    }
    receive() external payable {
        require(msg.sender == savingsAccount, 'CreditLine::receive invalid transaction');
    }
}
".
As the Security Analyst, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user.
Note that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we've collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with <INFO>, followed directly by the final idea or enhancement suggestion, e.g. "<INFO> Implementing a multi-sig wallet mechanism for added security in transactions".

Security Analyst: Let's Answer their Solidity smart contract ideas in the discussion without any other words, e.g., "A smart contract where we talk about Security: What functions the contract performs" 

[2024-22-08 11:43:06 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-22-08 11:43:06 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 30141
completion_tokens: 1
total_tokens: 30142
cost: $-1.000000


[2024-22-08 11:43:06 INFO] Chief Executive Officer: **Chief Executive Officer<->Counselor on : Reflection, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Counselor. Now, we share a common interest in collaborating to successfully complete a task assigned by a new customer.
Your main responsibilities include asking what user and customer think and provide your valuable suggestions. 
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/utils/ReentrancyGuard.sol';
import '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';
import '../interfaces/IPriceOracle.sol';
import '../interfaces/IYield.sol';
import '../interfaces/ISavingsAccount.sol';
import '../SavingsAccount/SavingsAccountUtil.sol';
import '../interfaces/IStrategyRegistry.sol';

/**
 * @title Credit Line contract with Methods related to credit Line
 * @notice Implements the functions related to Credit Line
 * @author Sublime
 **/

contract CreditLine is ReentrancyGuard, OwnableUpgradeable {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    enum CreditLineStatus {
        NOT_CREATED,
        REQUESTED,
        ACTIVE,
        CLOSED,
        CANCELLED,
        LIQUIDATED
    }

    /**
     * @notice counter that tracks the number of credit lines created
     * @dev used to create unique identifier for credit lines
     **/
    uint256 public creditLineCounter;

    uint256 constant YEAR_IN_SECONDS = 365 days;

    struct CreditLineVariables {
        CreditLineStatus status;
        uint256 principal;
        uint256 totalInterestRepaid;
        uint256 lastPrincipalUpdateTime;
        uint256 interestAccruedTillLastPrincipalUpdate;
    }

    struct CreditLineConstants {
        address lender;
        address borrower;
        uint256 borrowLimit;
        uint256 idealCollateralRatio;
        uint256 borrowRate;
        address borrowAsset;
        address collateralAsset;
        bool autoLiquidation;
        bool requestByLender;
    }
    /**
     * @notice stores the collateral shares in a credit line per strategy
     * @dev creditLineId => Strategy => collateralShares
     **/
    mapping(uint256 => mapping(address => uint256)) public collateralShareInStrategy;

    /**
     * @notice stores the variables to maintain a credit line
     **/
    mapping(uint256 => CreditLineVariables) public creditLineVariables;

    /**
     * @notice stores the constants related to a credit line
     **/
    mapping(uint256 => CreditLineConstants) public creditLineConstants;

    /**
     * @notice stores the address of savings account contract
     **/
    address public savingsAccount;

    /**
     * @notice stores the address of price oracle contract
     **/
    address public priceOracle;

    /**
     * @notice stores the address of strategy registry contract
     **/
    address public strategyRegistry;

    /**
     * @notice stores the address of default strategy
     **/
    address public defaultStrategy;

    /**
     * @notice stores the fraction of borrowed amount charged as fee by protocol
     * @dev it is multiplied by 10**30
     **/
    uint256 public protocolFeeFraction;

    /**
     * @notice address where protocol fee is collected
     **/
    address public protocolFeeCollector;

    /**
     * @notice stores the fraction of amount liquidated given as reward to liquidator
     * @dev it is multiplied by 10**30
     **/
    uint256 public liquidatorRewardFraction;
    /**
     * @dev checks if Credit Line exists
     * @param _id identifier for the credit line
     **/
    modifier ifCreditLineExists(uint256 _id) {
        require(creditLineVariables[_id].status != CreditLineStatus.NOT_CREATED, 'Credit line does not exist');
        _;
    }

    /**
     * @dev checks if called by credit Line Borrower
     * @param _id creditLine identifier
     **/
    modifier onlyCreditLineBorrower(uint256 _id) {
        require(creditLineConstants[_id].borrower == msg.sender, 'Only credit line Borrower can access');
        _;
    }

    /**
     * @dev checks if called by credit Line Lender
     * @param _id creditLine identifier
     **/
    modifier onlyCreditLineLender(uint256 _id) {
        require(creditLineConstants[_id].lender == msg.sender, 'Only credit line Lender can access');
        _;
    }

    /**
     * @notice emitted when a collateral is deposited into credit line
     * @param id id of the credit line
     * @param amount amount of collateral deposited
     * @param strategy address of the strategy into which collateral is deposited
     */
    event CollateralDeposited(uint256 indexed id, uint256 amount, address indexed strategy);

    /**
     * @notice emitted when collateral is withdrawn from credit line
     * @param id id of the credit line
     * @param amount amount of collateral withdrawn
     */
    event CollateralWithdrawn(uint256 indexed id, uint256 amount);

    /**
     * @notice emitted when a request for new credit line is placed
     * @param id id of the credit line for which request was made
     * @param lender address of the lender for credit line
     * @param borrower address of the borrower for credit line
     */
    event CreditLineRequested(uint256 indexed id, address indexed lender, address indexed borrower);

    /**
     * @notice emitted when a credit line is liquidated
     * @param id id of the credit line which is liquidated
     * @param liquidator address of the liquidator
     */
    event CreditLineLiquidated(uint256 indexed id, address indexed liquidator);

    /**
     * @notice emitted when tokens are borrowed from credit line
     * @param id id of the credit line from which tokens are borrowed
     * @param borrowAmount amount of tokens borrowed
     */
    event BorrowedFromCreditLine(uint256 indexed id, uint256 borrowAmount);

    /**
     * @notice emitted when credit line is accepted
     * @param id id of the credit line that was accepted
     */
    event CreditLineAccepted(uint256 indexed id);

    /**
     * @notice emitted when credit line is completely repaid and reset
     * @param id id of the credit line that is reset
     */
    event CreditLineReset(uint256 indexed id);

    /**
     * @notice emitted when the credit line is partially repaid
     * @param id id of the credit line
     * @param repayAmount amount repaid
     */
    event PartialCreditLineRepaid(uint256 indexed id, uint256 repayAmount);

    /**
     * @notice emitted when the credit line is completely repaid
     * @param id id of the credit line
     * @param repayAmount amount repaid
     */
    event CompleteCreditLineRepaid(uint256 indexed id, uint256 repayAmount);

    /**
     * @notice emitted when the credit line is closed by one of the parties of credit line
     * @param id id of the credit line
     */
    event CreditLineClosed(uint256 indexed id);

    /**
     * @notice emitted when default strategy for the credit line is updated
     * @param defaultStrategy address of the strategy contract that is used as default by credit lines
     */
    event DefaultStrategyUpdated(address indexed defaultStrategy);

    /**
     * @notice emitted when the price oracle is updated
     * @param priceOracle address of the updated price oracle
     */
    event PriceOracleUpdated(address indexed priceOracle);

    /**
     * @notice emitted when the savings account address is updated
     * @param savingsAccount address of the updated savingsAccount
     */
    event SavingsAccountUpdated(address indexed savingsAccount);

    /**
     * @notice emitted when strategy registry address is updated
     * @param strategyRegistry address of the updated strategy registry
     */
    event StrategyRegistryUpdated(address indexed strategyRegistry);

    /**
     * @notice emitted when fee that protocol charges for credit line is updated
     * @param updatedProtocolFee updated value of protocolFeeFraction
     */
    event ProtocolFeeFractionUpdated(uint256 updatedProtocolFee);

    /**
     * @notice emitted when address which receives fee that protocol changes for pools is updated
     * @param updatedProtocolFeeCollector updated value of protocolFeeCollector
     */
    event ProtocolFeeCollectorUpdated(address indexed updatedProtocolFeeCollector);

    /**
     * @notice emitted when liquidatorRewardFraction is updated
     * @param liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator
     */
    event LiquidationRewardFractionUpdated(uint256 liquidatorRewardFraction);

    /**
     * @notice used to initialize the contract
     * @dev can only be called once during the life cycle of the contract
     * @param _defaultStrategy default strategy used in credit lines
     * @param _priceOracle address of the priceOracle
     * @param _savingsAccount address of  the savings account contract
     * @param _strategyRegistry address of the strategy registry contract
     * @param _owner address of owner who can change global variables
     * @param _protocolFeeFraction fraction of the fee charged by protocol
     * @param _protocolFeeCollector address to which protocol fee is charged to
     * @param _liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator
     */
    function initialize(
        address _defaultStrategy,
        address _priceOracle,
        address _savingsAccount,
        address _strategyRegistry,
        address _owner,
        uint256 _protocolFeeFraction,
        address _protocolFeeCollector,
        uint256 _liquidatorRewardFraction
    ) external initializer {
        OwnableUpgradeable.__Ownable_init();
        OwnableUpgradeable.transferOwnership(_owner);

        _updateDefaultStrategy(_defaultStrategy);
        _updatePriceOracle(_priceOracle);
        _updateSavingsAccount(_savingsAccount);
        _updateStrategyRegistry(_strategyRegistry);
        _updateProtocolFeeFraction(_protocolFeeFraction);
        _updateProtocolFeeCollector(_protocolFeeCollector);
        _updateLiquidatorRewardFraction(_liquidatorRewardFraction);
    }

    /**
     * @notice used to update the default strategy
     * @dev can only be updated by owner
     * @param _defaultStrategy address of the updated default strategy
     */
    function updateDefaultStrategy(address _defaultStrategy) external onlyOwner {
        _updateDefaultStrategy(_defaultStrategy);
    }

    function _updateDefaultStrategy(address _defaultStrategy) internal {
        defaultStrategy = _defaultStrategy;
        emit DefaultStrategyUpdated(_defaultStrategy);
    }

    /**
     * @notice used to update the price oracle
     * @dev can only be updated by owner
     * @param _priceOracle address of the updated price oracle
     */
    function updatePriceOracle(address _priceOracle) external onlyOwner {
        _updatePriceOracle(_priceOracle);
    }

    function _updatePriceOracle(address _priceOracle) internal {
        priceOracle = _priceOracle;
        emit PriceOracleUpdated(_priceOracle);
    }

    /**
     * @notice used to update the savings account address
     * @dev can only be updated by owner
     * @param _savingsAccount address of the updated savings account
     */
    function updateSavingsAccount(address _savingsAccount) external onlyOwner {
        _updateSavingsAccount(_savingsAccount);
    }

    function _updateSavingsAccount(address _savingsAccount) internal {
        savingsAccount = _savingsAccount;
        emit SavingsAccountUpdated(_savingsAccount);
    }

    /**
     * @notice used to update the protocol fee fraction
     * @dev can only be updated by owner
     * @param _protocolFee fraction of the borrower amount collected as protocol fee
     */
    function updateProtocolFeeFraction(uint256 _protocolFee) external onlyOwner {
        _updateProtocolFeeFraction(_protocolFee);
    }

    function _updateProtocolFeeFraction(uint256 _protocolFee) internal {
        protocolFeeFraction = _protocolFee;
        emit ProtocolFeeFractionUpdated(_protocolFee);
    }

    /**
     * @notice used to update the protocol fee collector
     * @dev can only be updated by owner
     * @param _protocolFeeCollector address in which protocol fee is collected
     */
    function updateProtocolFeeCollector(address _protocolFeeCollector) external onlyOwner {
        _updateProtocolFeeCollector(_protocolFeeCollector);
    }

    function _updateProtocolFeeCollector(address _protocolFeeCollector) internal {
        require(_protocolFeeCollector != address(0), 'cant be 0 address');
        protocolFeeCollector = _protocolFeeCollector;
        emit ProtocolFeeCollectorUpdated(_protocolFeeCollector);
    }

    /**
     * @notice used to update the strategy registry address
     * @dev can only be updated by owner
     * @param _strategyRegistry address of the updated strategy registry
     */
    function updateStrategyRegistry(address _strategyRegistry) external onlyOwner {
        _updateStrategyRegistry(_strategyRegistry);
    }

    function _updateStrategyRegistry(address _strategyRegistry) internal {
        require(_strategyRegistry != address(0), 'CL::I zero address');
        strategyRegistry = _strategyRegistry;
        emit StrategyRegistryUpdated(_strategyRegistry);
    }

    /**
     * @notice used to update the liquidatorRewardFraction
     * @dev can only be updated by owner
     * @param _rewardFraction fraction of liquidated amount given to liquidator as reward
     */
    function updateLiquidatorRewardFraction(uint256 _rewardFraction) external onlyOwner {
        _updateLiquidatorRewardFraction(_rewardFraction);
    }

    function _updateLiquidatorRewardFraction(uint256 _rewardFraction) internal {
        require(_rewardFraction <= 10**30, 'Fraction has to be less than 1');
        liquidatorRewardFraction = _rewardFraction;
        emit LiquidationRewardFractionUpdated(_rewardFraction);
    }

    /**
     * @dev Used to Calculate Interest Per second on given principal and Interest rate
     * @param _principal principal Amount for which interest has to be calculated.
     * @param _borrowRate It is the Interest Rate at which Credit Line is approved
     * @return interest per second for the given parameters
     */
    function calculateInterest(
        uint256 _principal,
        uint256 _borrowRate,
        uint256 _timeElapsed
    ) public pure returns (uint256) {
        uint256 _interest = _principal.mul(_borrowRate).mul(_timeElapsed).div(10**30).div(YEAR_IN_SECONDS);

        return _interest;
    }

    /**
     * @dev Used to calculate interest accrued since last repayment
     * @param _id identifier for the credit line
     * @return interest accrued over current borrowed amount since last repayment
     */

    function calculateInterestAccrued(uint256 _id) public view returns (uint256) {
        uint256 _lastPrincipalUpdateTime = creditLineVariables[_id].lastPrincipalUpdateTime;
        if (_lastPrincipalUpdateTime == 0) return 0;
        uint256 _timeElapsed = (block.timestamp).sub(_lastPrincipalUpdateTime);
        uint256 _interestAccrued = calculateInterest(creditLineVariables[_id].principal, creditLineConstants[_id].borrowRate, _timeElapsed);
        return _interestAccrued;
    }

    /**
     * @dev Used to calculate current debt of borrower against a credit line.
     * @param _id identifier for the credit line
     * @return current debt of borrower
     */
    function calculateCurrentDebt(uint256 _id) public view returns (uint256) {
        uint256 _interestAccrued = calculateInterestAccrued(_id);
        uint256 _currentDebt = (creditLineVariables[_id].principal)
            .add(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate)
            .add(_interestAccrued)
            .sub(creditLineVariables[_id].totalInterestRepaid);
        return _currentDebt;
    }

    /**
     * @notice used to calculate amount that can be borrowed by the borrower
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view.
            borrowableAmount changes per block as interest changes per block.
     * @param _id identifier for the credit line
     * @return amount that can be borrowed from the credit line
     */
    function calculateBorrowableAmount(uint256 _id) public returns (uint256) {
        CreditLineStatus _status = creditLineVariables[_id].status;
        require(
            _status == CreditLineStatus.ACTIVE || _status == CreditLineStatus.REQUESTED,
            'CreditLine: Cannot only if credit line ACTIVE or REQUESTED'
        );
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(
            creditLineConstants[_id].collateralAsset,
            creditLineConstants[_id].borrowAsset
        );

        uint256 _totalCollateralToken = calculateTotalCollateralTokens(_id);

        uint256 _currentDebt = calculateCurrentDebt(_id);

        uint256 _maxPossible = _totalCollateralToken.mul(_ratioOfPrices).div(creditLineConstants[_id].idealCollateralRatio).mul(10**30).div(
            10**_decimals
        );

        uint256 _borrowLimit = creditLineConstants[_id].borrowLimit;

        if (_maxPossible > _borrowLimit) {
            _maxPossible = _borrowLimit;
        }
        if (_maxPossible > _currentDebt) {
            return _maxPossible.sub(_currentDebt);
        }
        return 0;
    }

    function updateinterestAccruedTillLastPrincipalUpdate(uint256 _id) internal {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');

        uint256 _interestAccrued = calculateInterestAccrued(_id);
        uint256 _newInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(_interestAccrued);
        creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _newInterestAccrued;
    }

    function _depositCollateralFromSavingsAccount(
        uint256 _id,
        uint256 _amount,
        address _sender
    ) internal {
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        uint256 _activeAmount;

        for (uint256 _index = 0; _index < _strategyList.length; _index++) {
            address _strategy = _strategyList[_index];
            uint256 _liquidityShares = _savingsAccount.balanceInShares(_sender, _collateralAsset, _strategy);
            if (_liquidityShares == 0 || _strategyList[_index] == address(0)) {
                continue;
            }
            uint256 _tokenInStrategy = _liquidityShares;
            _tokenInStrategy = IYield(_strategy).getTokensForShares(_liquidityShares, _collateralAsset);

            uint256 _tokensToTransfer = _tokenInStrategy;
            if (_activeAmount.add(_tokenInStrategy) >= _amount) {
                _tokensToTransfer = (_amount.sub(_activeAmount));
            }
            _activeAmount = _activeAmount.add(_tokensToTransfer);
            _savingsAccount.transferFrom(_tokensToTransfer, _collateralAsset, _strategy, _sender, address(this));

            collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(
                _liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy)
            );

            if (_amount == _activeAmount) {
                return;
            }
        }
        revert('CreditLine::_depositCollateralFromSavingsAccount - Insufficient balance');
    }

    /**
     * @notice used to request a credit line either by borrower or lender
     * @param _requestTo Address to which creditLine is requested, 
                        if borrower creates request then lender address and 
                        if lender creates then borrower address
     * @param _borrowLimit maximum borrow amount in a credit line
     * @param _borrowRate Interest Rate at which credit Line is requested
     * @param _autoLiquidation if true, anyone can liquidate loan, otherwise only lender
     * @param _collateralRatio ratio of the collateral to the debt below which credit line can be liquidated
     * @param _borrowAsset address of the token to be borrowed
     * @param _collateralAsset address of the token provided as collateral
     * @param _requestAsLender if true, lender is placing request, otherwise borrower
     * @return identifier for the credit line
     */

    function request(
        address _requestTo,
        uint256 _borrowLimit,
        uint256 _borrowRate,
        bool _autoLiquidation,
        uint256 _collateralRatio,
        address _borrowAsset,
        address _collateralAsset,
        bool _requestAsLender
    ) external returns (uint256) {
        require(_borrowAsset != _collateralAsset, 'R: cant borrow lent token');
        require(IPriceOracle(priceOracle).doesFeedExist(_borrowAsset, _collateralAsset), 'R: No price feed');

        address _lender = _requestTo;
        address _borrower = msg.sender;
        if (_requestAsLender) {
            _lender = msg.sender;
            _borrower = _requestTo;
        }

        uint256 _id = _createRequest(
            _lender,
            _borrower,
            _borrowLimit,
            _borrowRate,
            _autoLiquidation,
            _collateralRatio,
            _borrowAsset,
            _collateralAsset,
            _requestAsLender
        );

        emit CreditLineRequested(_id, _lender, _borrower);
        return _id;
    }

    function _createRequest(
        address _lender,
        address _borrower,
        uint256 _borrowLimit,
        uint256 _borrowRate,
        bool _autoLiquidation,
        uint256 _collateralRatio,
        address _borrowAsset,
        address _collateralAsset,
        bool _requestByLender
    ) internal returns (uint256) {
        require(_lender != _borrower, 'Lender and Borrower cannot be same addresses');
        uint256 _id = creditLineCounter + 1;
        creditLineCounter = _id;
        creditLineVariables[_id].status = CreditLineStatus.REQUESTED;
        creditLineConstants[_id].borrower = _borrower;
        creditLineConstants[_id].lender = _lender;
        creditLineConstants[_id].borrowLimit = _borrowLimit;
        creditLineConstants[_id].autoLiquidation = _autoLiquidation;
        creditLineConstants[_id].idealCollateralRatio = _collateralRatio;
        creditLineConstants[_id].borrowRate = _borrowRate;
        creditLineConstants[_id].borrowAsset = _borrowAsset;
        creditLineConstants[_id].collateralAsset = _collateralAsset;
        creditLineConstants[_id].requestByLender = _requestByLender;
        return _id;
    }

    /**
     * @notice used to accept a credit line
     * @dev if borrower places request, lender can accept and vice versa
     * @param _id identifier for the credit line
     */
    function accept(uint256 _id) external {
        require(
            creditLineVariables[_id].status == CreditLineStatus.REQUESTED,
            'CreditLine::acceptCreditLineLender - CreditLine is already accepted'
        );
        bool _requestByLender = creditLineConstants[_id].requestByLender;
        require(
            (msg.sender == creditLineConstants[_id].borrower && _requestByLender) ||
                (msg.sender == creditLineConstants[_id].lender && !_requestByLender),
            "Only Borrower or Lender who hasn't requested can accept"
        );
        creditLineVariables[_id].status = CreditLineStatus.ACTIVE;
        emit CreditLineAccepted(_id);
    }

    /**
     * @notice used to deposit collateral into the credit line
     * @dev collateral tokens have to be approved in savingsAccount or token contract(unless ether).
            If transferred from savings account, the tokens are transferred from strategies in the 
            order prespecified in strategy registry
     * @param _id identifier for the credit line
     * @param _amount amount of collateral being deposited
     * @param _strategy strategy to which collateral is to be deposited in case transfer is not from savings account
     * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount 
                                otherwise direct from collateral token contract
     */
    function depositCollateral(
        uint256 _id,
        uint256 _amount,
        address _strategy,
        bool _fromSavingsAccount
    ) external payable nonReentrant ifCreditLineExists(_id) {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine not active');
        _depositCollateral(_id, _amount, _strategy, _fromSavingsAccount);
        emit CollateralDeposited(_id, _amount, _strategy);
    }

    function _depositCollateral(
        uint256 _id,
        uint256 _amount,
        address _strategy,
        bool _fromSavingsAccount
    ) internal {
        require(creditLineConstants[_id].lender != msg.sender, 'lender cant deposit collateral');
        if (_fromSavingsAccount) {
            _depositCollateralFromSavingsAccount(_id, _amount, msg.sender);
        } else {
            address _collateralAsset = creditLineConstants[_id].collateralAsset;
            ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
            if (_collateralAsset == address(0)) {
                require(msg.value == _amount, "CreditLine::_depositCollateral - value to transfer doesn't match argument");
            } else {
                IERC20(_collateralAsset).safeTransferFrom(msg.sender, address(this), _amount);
                IERC20(_collateralAsset).approve(_strategy, _amount);
            }
            uint256 _sharesReceived = _savingsAccount.deposit{value: msg.value}(_amount, _collateralAsset, _strategy, address(this));
            collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(_sharesReceived);
        }
    }

    function _withdrawBorrowAmount(
        address _asset,
        uint256 _amountInTokens,
        address _lender
    ) internal {
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        uint256 _activeAmount;
        for (uint256 _index = 0; _index < _strategyList.length; _index++) {
            if (_strategyList[_index] == address(0)) {
                continue;
            }
            uint256 _liquidityShares = _savingsAccount.balanceInShares(_lender, _asset, _strategyList[_index]);
            if (_liquidityShares != 0) {
                uint256 tokenInStrategy = _liquidityShares;
                tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);
                uint256 _tokensToTransfer = tokenInStrategy;
                if (_activeAmount.add(tokenInStrategy) >= _amountInTokens) {
                    _tokensToTransfer = (_amountInTokens.sub(_activeAmount));
                }
                _activeAmount = _activeAmount.add(_tokensToTransfer);
                _savingsAccount.withdrawFrom(_tokensToTransfer, _asset, _strategyList[_index], _lender, address(this), false);
                if (_activeAmount == _amountInTokens) {
                    return;
                }
            }
        }
        require(_activeAmount == _amountInTokens, 'insufficient balance');
    }

    /**
     * @notice used to borrow tokens from credit line by borrower
     * @dev only borrower can call this function. Amount that can actually be borrowed is 
            min(amount based on borrowLimit, allowance to creditLine contract, balance of lender)
     * @param _id identifier for the credit line
     * @param _amount amount of tokens to borrow
     */
    function borrow(uint256 _id, uint256 _amount) external payable nonReentrant onlyCreditLineBorrower(_id) {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');
        uint256 _borrowableAmount = calculateBorrowableAmount(_id);
        require(_amount <= _borrowableAmount, "CreditLine::borrow - The current collateral ratio doesn't allow to withdraw the amount");
        address _borrowAsset = creditLineConstants[_id].borrowAsset;
        address _lender = creditLineConstants[_id].lender;

        updateinterestAccruedTillLastPrincipalUpdate(_id);
        creditLineVariables[_id].principal = creditLineVariables[_id].principal.add(_amount);
        creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;

        uint256 _tokenDiffBalance;
        if (_borrowAsset != address(0)) {
            uint256 _balanceBefore = IERC20(_borrowAsset).balanceOf(address(this));
            _withdrawBorrowAmount(_borrowAsset, _amount, _lender);
            uint256 _balanceAfter = IERC20(_borrowAsset).balanceOf(address(this));
            _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);
        } else {
            uint256 _balanceBefore = address(this).balance;
            _withdrawBorrowAmount(_borrowAsset, _amount, _lender);
            uint256 _balanceAfter = address(this).balance;
            _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);
        }
        uint256 _protocolFee = _tokenDiffBalance.mul(protocolFeeFraction).div(10**30);
        _tokenDiffBalance = _tokenDiffBalance.sub(_protocolFee);

        if (_borrowAsset == address(0)) {
            (bool feeSuccess, ) = protocolFeeCollector.call{value: _protocolFee}('');
            require(feeSuccess, 'Transfer fail');
            (bool success, ) = msg.sender.call{value: _tokenDiffBalance}('');
            require(success, 'Transfer fail');
        } else {
            IERC20(_borrowAsset).safeTransfer(protocolFeeCollector, _protocolFee);
            IERC20(_borrowAsset).safeTransfer(msg.sender, _tokenDiffBalance);
        }
        emit BorrowedFromCreditLine(_id, _tokenDiffBalance);
    }

    function _repayFromSavingsAccount(
        uint256 _amount,
        address _asset,
        address _lender
    ) internal {
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        uint256 _activeAmount;

        for (uint256 _index = 0; _index < _strategyList.length; _index++) {
            if (_strategyList[_index] == address(0)) {
                continue;
            }
            uint256 _liquidityShares = _savingsAccount.balanceInShares(msg.sender, _asset, _strategyList[_index]);
            if (_liquidityShares == 0) {
                continue;
            }
            uint256 _tokenInStrategy = _liquidityShares;
            _tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);

            uint256 _tokensToTransfer = _tokenInStrategy;
            if (_activeAmount.add(_tokenInStrategy) >= _amount) {
                _tokensToTransfer = (_amount.sub(_activeAmount));
            }
            _activeAmount = _activeAmount.add(_tokensToTransfer);
            _savingsAccount.transferFrom(_tokensToTransfer, _asset, _strategyList[_index], msg.sender, _lender);

            if (_amount == _activeAmount) {
                return;
            }
        }
        revert('CreditLine::_repayFromSavingsAccount - Insufficient balance');
    }

    function _repay(
        uint256 _id,
        uint256 _amount,
        bool _fromSavingsAccount,
        uint256 _principalPaid
    ) internal {
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        address _defaultStrategy = defaultStrategy;
        address _borrowAsset = creditLineConstants[_id].borrowAsset;
        address _lender = creditLineConstants[_id].lender;
        if (!_fromSavingsAccount) {
            if (_borrowAsset == address(0)) {
                require(msg.value == _amount, 'creditLine::repay - Ether sent not equal to repay amount');
                _savingsAccount.deposit{value: _amount}(_amount, _borrowAsset, _defaultStrategy, _lender);
            } else {
                IERC20(_borrowAsset).safeTransferFrom(msg.sender, address(this), _amount);
                IERC20(_borrowAsset).approve(_defaultStrategy, _amount);
                _savingsAccount.deposit(_amount, _borrowAsset, _defaultStrategy, _lender);
            }
        } else {
            _repayFromSavingsAccount(_amount, _borrowAsset, _lender);
        }
        if (_principalPaid != 0) {
            _savingsAccount.increaseAllowanceToCreditLine(_principalPaid, _borrowAsset, _lender);
        }
    }

    /**
     * @notice used to repay interest and principal to credit line. Interest has to be repaid before repaying principal
     * @dev partial repayments possible
     * @param _id identifier for the credit line
     * @param _amount amount being repaid
     * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount 
                                otherwise direct from collateral token contract
     */
    function repay(
        uint256 _id,
        uint256 _amount,
        bool _fromSavingsAccount
    ) external payable nonReentrant {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');
        require(creditLineConstants[_id].lender != msg.sender, 'Lender cant repay');

        uint256 _interestSincePrincipalUpdate = calculateInterestAccrued(_id);
        uint256 _totalInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(
            _interestSincePrincipalUpdate
        );
        uint256 _interestToPay = _totalInterestAccrued.sub(creditLineVariables[_id].totalInterestRepaid);
        uint256 _totalCurrentDebt = _interestToPay.add(creditLineVariables[_id].principal);
        uint256 _principalPaid = 0;

        if (_amount >= _totalCurrentDebt) {
            _amount = _totalCurrentDebt;
            emit CompleteCreditLineRepaid(_id, _amount);
        } else {
            emit PartialCreditLineRepaid(_id, _amount);
        }

        if (_amount > _interestToPay) {
            creditLineVariables[_id].principal = _totalCurrentDebt.sub(_amount);
            creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _totalInterestAccrued;
            creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;
            creditLineVariables[_id].totalInterestRepaid = _totalInterestAccrued;
            _principalPaid = _amount.sub(_interestToPay);
        } else {
            creditLineVariables[_id].totalInterestRepaid = creditLineVariables[_id].totalInterestRepaid.add(_amount);
        }

        _repay(_id, _amount, _fromSavingsAccount, _principalPaid);

        if (creditLineVariables[_id].principal == 0) {
            _resetCreditLine(_id);
        }
    }

    function _resetCreditLine(uint256 _id) internal {
        creditLineVariables[_id].lastPrincipalUpdateTime = 0;
        creditLineVariables[_id].totalInterestRepaid = 0;
        creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = 0;
        emit CreditLineReset(_id);
    }

    /**
     * @dev used to close credit line by borrower or lender
     * @param _id identifier for the credit line
     */
    function close(uint256 _id) external ifCreditLineExists(_id) {
        require(
            msg.sender == creditLineConstants[_id].borrower || msg.sender == creditLineConstants[_id].lender,
            'CreditLine: Permission denied while closing Line of credit'
        );
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: Credit line should be active.');
        require(creditLineVariables[_id].principal == 0, 'CreditLine: Cannot be closed since not repaid.');
        require(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate == 0, 'CreditLine: Cannot be closed since not repaid.');
        creditLineVariables[_id].status = CreditLineStatus.CLOSED;
        emit CreditLineClosed(_id);
    }

    /**
     * @notice used to calculate the current collateral ratio
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view.
            Interest is also considered while calculating debt
     * @param _id identifier for the credit line
     * @return collateral ratio multiplied by 10**30 to retain precision
     */
    function calculateCurrentCollateralRatio(uint256 _id) public ifCreditLineExists(_id) returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(
            creditLineConstants[_id].collateralAsset,
            creditLineConstants[_id].borrowAsset
        );

        uint256 currentDebt = calculateCurrentDebt(_id);
        uint256 currentCollateralRatio = calculateTotalCollateralTokens(_id).mul(_ratioOfPrices).div(currentDebt).mul(10**30).div(
            10**_decimals
        );

        return currentCollateralRatio;
    }

    /**
     * @notice used to calculate the total collateral tokens
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @param _id identifier for the credit line
     * @return _amount total collateral tokens deposited into the credit line
     */
    function calculateTotalCollateralTokens(uint256 _id) public returns (uint256 _amount) {
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        uint256 _liquidityShares;
        for (uint256 index = 0; index < _strategyList.length; index++) {
            if (_strategyList[index] == address(0)) {
                continue;
            }
            _liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];
            uint256 _tokenInStrategy = _liquidityShares;
            _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(_liquidityShares, _collateralAsset);

            _amount = _amount.add(_tokenInStrategy);
        }
    }

    /**
     * @notice used to withdraw any excess collateral
     * @dev collateral can't be withdraw if collateralRatio goes below the ideal value. Only borrower can withdraw
     * @param _id identifier for the credit line
     * @param _amount amount of collateral to withdraw
     * @param _toSavingsAccount if true, tokens are transferred from savingsAccount 
                                otherwise direct from collateral token contract
     */
    function withdrawCollateral(
        uint256 _id,
        uint256 _amount,
        bool _toSavingsAccount
    ) external nonReentrant onlyCreditLineBorrower(_id) {
        uint256 _withdrawableCollateral = withdrawableCollateral(_id);
        require(_amount <= _withdrawableCollateral, 'Collateral ratio cant go below ideal');
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        _transferCollateral(_id, _collateralAsset, _amount, _toSavingsAccount);
        emit CollateralWithdrawn(_id, _amount);
    }

    /**
     * @notice used to calculate the collateral that can be withdrawn
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @param _id identifier for the credit line
     * @return total collateral withdrawable by borrower
     */
    function withdrawableCollateral(uint256 _id) public returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(
            creditLineConstants[_id].collateralAsset,
            creditLineConstants[_id].borrowAsset
        );

        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);
        uint256 _currentDebt = calculateCurrentDebt(_id);

        uint256 _collateralNeeded = _currentDebt
            .mul(creditLineConstants[_id].idealCollateralRatio)
            .div(_ratioOfPrices)
            .mul(10**_decimals)
            .div(10**30);

        if (_collateralNeeded >= _totalCollateralTokens) {
            return 0;
        }
        return _totalCollateralTokens.sub(_collateralNeeded);
    }

    function _transferCollateral(
        uint256 _id,
        address _asset,
        uint256 _amountInTokens,
        bool _toSavingsAccount
    ) internal {
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        uint256 _activeAmount;
        for (uint256 index = 0; index < _strategyList.length; index++) {
            uint256 liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];
            if (liquidityShares == 0 || _strategyList[index] == address(0)) {
                continue;
            }
            uint256 _tokenInStrategy = liquidityShares;
            _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(liquidityShares, _asset);
            uint256 _tokensToTransfer = _tokenInStrategy;
            if (_activeAmount.add(_tokenInStrategy) > _amountInTokens) {
                _tokensToTransfer = _amountInTokens.sub(_activeAmount);
                liquidityShares = liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy);
            }
            _activeAmount = _activeAmount.add(_tokensToTransfer);
            collateralShareInStrategy[_id][_strategyList[index]] = collateralShareInStrategy[_id][_strategyList[index]].sub(
                liquidityShares
            );
            if (_toSavingsAccount) {
                ISavingsAccount(savingsAccount).transfer(_tokensToTransfer, _asset, _strategyList[index], msg.sender);
            } else {
                ISavingsAccount(savingsAccount).withdraw(_tokensToTransfer, _asset, _strategyList[index], msg.sender, false);
            }

            if (_activeAmount == _amountInTokens) {
                return;
            }
        }
        revert('insufficient collateral');
    }

    /**
     * @notice used to liquidate credit line in case collateral ratio goes below the threshold
     * @dev if lender liquidates, then collateral is directly transferred. 
            If autoLiquidation is true, anyone can liquidate by providing enough borrow tokens
     * @param _id identifier for the credit line
     * @param _toSavingsAccount if true, tokens are transferred from savingsAccount 
                                otherwise direct from collateral token contract
     */
    function liquidate(uint256 _id, bool _toSavingsAccount) external payable nonReentrant {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: Credit line should be active.');
        require(creditLineVariables[_id].principal != 0, 'CreditLine: cannot liquidate if principal is 0');

        uint256 currentCollateralRatio = calculateCurrentCollateralRatio(_id);
        require(
            currentCollateralRatio < creditLineConstants[_id].idealCollateralRatio,
            'CreditLine: Collateral ratio is higher than ideal value'
        );

        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        address _lender = creditLineConstants[_id].lender;
        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);
        address _borrowAsset = creditLineConstants[_id].borrowAsset;

        creditLineVariables[_id].status = CreditLineStatus.LIQUIDATED;

        if (creditLineConstants[_id].autoLiquidation && _lender != msg.sender) {
            uint256 _borrowTokens = _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens);
            if (_borrowAsset == address(0)) {
                uint256 _returnETH = msg.value.sub(_borrowTokens, 'Insufficient ETH to liquidate');
                if (_returnETH != 0) {
                    (bool success, ) = msg.sender.call{value: _returnETH}('');
                    require(success, 'Transfer fail');
                }
            } else {
                IERC20(_borrowAsset).safeTransferFrom(msg.sender, _lender, _borrowTokens);
            }
        }

        _transferCollateral(_id, _collateralAsset, _totalCollateralTokens, _toSavingsAccount);

        emit CreditLineLiquidated(_id, msg.sender);
    }

    /**
     * @notice used to calculate the borrow tokens necessary for liquidator to liquidate
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @param _id identifier for the credit line
     * @return borrow tokens necessary for liquidator to liquidate
     */
    function borrowTokensToLiquidate(uint256 _id) external returns (uint256) {
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);
        address _borrowAsset = creditLineConstants[_id].borrowAsset;

        return _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens);
    }

    function _borrowTokensToLiquidate(
        address _borrowAsset,
        address _collateralAsset,
        uint256 _totalCollateralTokens
    ) internal view returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(_borrowAsset, _collateralAsset);
        uint256 _borrowTokens = (
            _totalCollateralTokens.mul(uint256(10**30).sub(liquidatorRewardFraction)).div(10**30).mul(_ratioOfPrices).div(10**_decimals)
        );

        return _borrowTokens;
    }

    receive() external payable {
        require(msg.sender == savingsAccount, 'CreditLine::receive invalid transaction');
    }
}
.]

Security

[2024-22-08 11:43:06 INFO] **[Seminar Conclusion]**:

 Security

[2024-22-08 11:43:06 INFO] **[Seminar Conclusion]**:

 <INFO> Security

[2024-22-08 11:43:06 INFO] **[Execute Detail]**

execute SimplePhase:[ContractReviewComment] in ComposedPhase:[CodeReview], cycle 1

[2024-22-08 11:43:06 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol'; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/utils/ReentrancyGuard.sol'; import '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol'; import '../interfaces/IPriceOracle.sol'; import '../interfaces/IYield.sol'; import '../interfaces/ISavingsAccount.sol'; import '../SavingsAccount/SavingsAccountUtil.sol'; import '../interfaces/IStrategyRegistry.sol'; /  * @title Credit Line contract with Methods related to credit Line  * @notice Implements the functions related to Credit Line  * @author Sublime  / contract CreditLine is ReentrancyGuard, OwnableUpgradeable {     using SafeERC20 for IERC20;     using SafeMath for uint256; enum CreditLineStatus {     NOT_CREATED,     REQUESTED,     ACTIVE,     CLOSED,     CANCELLED,     LIQUIDATED }  /**  * @notice counter that tracks the number of credit lines created  * @dev used to create unique identifier for credit lines  **/ uint256 public creditLineCounter;  uint256 constant YEAR_IN_SECONDS = 365 days;  struct CreditLineVariables {     CreditLineStatus status;     uint256 principal;     uint256 totalInterestRepaid;     uint256 lastPrincipalUpdateTime;     uint256 interestAccruedTillLastPrincipalUpdate; }  struct CreditLineConstants {     address lender;     address borrower;     uint256 borrowLimit;     uint256 idealCollateralRatio;     uint256 borrowRate;     address borrowAsset;     address collateralAsset;     bool autoLiquidation;     bool requestByLender; } /**  * @notice stores the collateral shares in a credit line per strategy  * @dev creditLineId =&gt; Strategy =&gt; collateralShares  **/ mapping(uint256 =&gt; mapping(address =&gt; uint256)) public collateralShareInStrategy;  /**  * @notice stores the variables to maintain a credit line  **/ mapping(uint256 =&gt; CreditLineVariables) public creditLineVariables;  /**  * @notice stores the constants related to a credit line  **/ mapping(uint256 =&gt; CreditLineConstants) public creditLineConstants;  /**  * @notice stores the address of savings account contract  **/ address public savingsAccount;  /**  * @notice stores the address of price oracle contract  **/ address public priceOracle;  /**  * @notice stores the address of strategy registry contract  **/ address public strategyRegistry;  /**  * @notice stores the address of default strategy  **/ address public defaultStrategy;  /**  * @notice stores the fraction of borrowed amount charged as fee by protocol  * @dev it is multiplied by 10**30  **/ uint256 public protocolFeeFraction;  /**  * @notice address where protocol fee is collected  **/ address public protocolFeeCollector;  /**  * @notice stores the fraction of amount liquidated given as reward to liquidator  * @dev it is multiplied by 10**30  **/ uint256 public liquidatorRewardFraction; /**  * @dev checks if Credit Line exists  * @param _id identifier for the credit line  **/ modifier ifCreditLineExists(uint256 _id) {     require(creditLineVariables[_id].status != CreditLineStatus.NOT_CREATED, 'Credit line does not exist');     _; }  /**  * @dev checks if called by credit Line Borrower  * @param _id creditLine identifier  **/ modifier onlyCreditLineBorrower(uint256 _id) {     require(creditLineConstants[_id].borrower == msg.sender, 'Only credit line Borrower can access');     _; }  /**  * @dev checks if called by credit Line Lender  * @param _id creditLine identifier  **/ modifier onlyCreditLineLender(uint256 _id) {     require(creditLineConstants[_id].lender == msg.sender, 'Only credit line Lender can access');     _; }  /**  * @notice emitted when a collateral is deposited into credit line  * @param id id of the credit line  * @param amount amount of collateral deposited  * @param strategy address of the strategy into which collateral is deposited  */ event CollateralDeposited(uint256 indexed id, uint256 amount, address indexed strategy);  /**  * @notice emitted when collateral is withdrawn from credit line  * @param id id of the credit line  * @param amount amount of collateral withdrawn  */ event CollateralWithdrawn(uint256 indexed id, uint256 amount);  /**  * @notice emitted when a request for new credit line is placed  * @param id id of the credit line for which request was made  * @param lender address of the lender for credit line  * @param borrower address of the borrower for credit line  */ event CreditLineRequested(uint256 indexed id, address indexed lender, address indexed borrower);  /**  * @notice emitted when a credit line is liquidated  * @param id id of the credit line which is liquidated  * @param liquidator address of the liquidator  */ event CreditLineLiquidated(uint256 indexed id, address indexed liquidator);  /**  * @notice emitted when tokens are borrowed from credit line  * @param id id of the credit line from which tokens are borrowed  * @param borrowAmount amount of tokens borrowed  */ event BorrowedFromCreditLine(uint256 indexed id, uint256 borrowAmount);  /**  * @notice emitted when credit line is accepted  * @param id id of the credit line that was accepted  */ event CreditLineAccepted(uint256 indexed id);  /**  * @notice emitted when credit line is completely repaid and reset  * @param id id of the credit line that is reset  */ event CreditLineReset(uint256 indexed id);  /**  * @notice emitted when the credit line is partially repaid  * @param id id of the credit line  * @param repayAmount amount repaid  */ event PartialCreditLineRepaid(uint256 indexed id, uint256 repayAmount);  /**  * @notice emitted when the credit line is completely repaid  * @param id id of the credit line  * @param repayAmount amount repaid  */ event CompleteCreditLineRepaid(uint256 indexed id, uint256 repayAmount);  /**  * @notice emitted when the credit line is closed by one of the parties of credit line  * @param id id of the credit line  */ event CreditLineClosed(uint256 indexed id);  /**  * @notice emitted when default strategy for the credit line is updated  * @param defaultStrategy address of the strategy contract that is used as default by credit lines  */ event DefaultStrategyUpdated(address indexed defaultStrategy);  /**  * @notice emitted when the price oracle is updated  * @param priceOracle address of the updated price oracle  */ event PriceOracleUpdated(address indexed priceOracle);  /**  * @notice emitted when the savings account address is updated  * @param savingsAccount address of the updated savingsAccount  */ event SavingsAccountUpdated(address indexed savingsAccount);  /**  * @notice emitted when strategy registry address is updated  * @param strategyRegistry address of the updated strategy registry  */ event StrategyRegistryUpdated(address indexed strategyRegistry);  /**  * @notice emitted when fee that protocol charges for credit line is updated  * @param updatedProtocolFee updated value of protocolFeeFraction  */ event ProtocolFeeFractionUpdated(uint256 updatedProtocolFee);  /**  * @notice emitted when address which receives fee that protocol changes for pools is updated  * @param updatedProtocolFeeCollector updated value of protocolFeeCollector  */ event ProtocolFeeCollectorUpdated(address indexed updatedProtocolFeeCollector);  /**  * @notice emitted when liquidatorRewardFraction is updated  * @param liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator  */ event LiquidationRewardFractionUpdated(uint256 liquidatorRewardFraction);  /**  * @notice used to initialize the contract  * @dev can only be called once during the life cycle of the contract  * @param _defaultStrategy default strategy used in credit lines  * @param _priceOracle address of the priceOracle  * @param _savingsAccount address of  the savings account contract  * @param _strategyRegistry address of the strategy registry contract  * @param _owner address of owner who can change global variables  * @param _protocolFeeFraction fraction of the fee charged by protocol  * @param _protocolFeeCollector address to which protocol fee is charged to  * @param _liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator  */ function initialize(     address _defaultStrategy,     address _priceOracle,     address _savingsAccount,     address _strategyRegistry,     address _owner,     uint256 _protocolFeeFraction,     address _protocolFeeCollector,     uint256 _liquidatorRewardFraction ) external initializer {     OwnableUpgradeable.__Ownable_init();     OwnableUpgradeable.transferOwnership(_owner);      _updateDefaultStrategy(_defaultStrategy);     _updatePriceOracle(_priceOracle);     _updateSavingsAccount(_savingsAccount);     _updateStrategyRegistry(_strategyRegistry);     _updateProtocolFeeFraction(_protocolFeeFraction);     _updateProtocolFeeCollector(_protocolFeeCollector);     _updateLiquidatorRewardFraction(_liquidatorRewardFraction); }  /**  * @notice used to update the default strategy  * @dev can only be updated by owner  * @param _defaultStrategy address of the updated default strategy  */ function updateDefaultStrategy(address _defaultStrategy) external onlyOwner {     _updateDefaultStrategy(_defaultStrategy); }  function _updateDefaultStrategy(address _defaultStrategy) internal {     defaultStrategy = _defaultStrategy;     emit DefaultStrategyUpdated(_defaultStrategy); }  /**  * @notice used to update the price oracle  * @dev can only be updated by owner  * @param _priceOracle address of the updated price oracle  */ function updatePriceOracle(address _priceOracle) external onlyOwner {     _updatePriceOracle(_priceOracle); }  function _updatePriceOracle(address _priceOracle) internal {     priceOracle = _priceOracle;     emit PriceOracleUpdated(_priceOracle); }  /**  * @notice used to update the savings account address  * @dev can only be updated by owner  * @param _savingsAccount address of the updated savings account  */ function updateSavingsAccount(address _savingsAccount) external onlyOwner {     _updateSavingsAccount(_savingsAccount); }  function _updateSavingsAccount(address _savingsAccount) internal {     savingsAccount = _savingsAccount;     emit SavingsAccountUpdated(_savingsAccount); }  /**  * @notice used to update the protocol fee fraction  * @dev can only be updated by owner  * @param _protocolFee fraction of the borrower amount collected as protocol fee  */ function updateProtocolFeeFraction(uint256 _protocolFee) external onlyOwner {     _updateProtocolFeeFraction(_protocolFee); }  function _updateProtocolFeeFraction(uint256 _protocolFee) internal {     protocolFeeFraction = _protocolFee;     emit ProtocolFeeFractionUpdated(_protocolFee); }  /**  * @notice used to update the protocol fee collector  * @dev can only be updated by owner  * @param _protocolFeeCollector address in which protocol fee is collected  */ function updateProtocolFeeCollector(address _protocolFeeCollector) external onlyOwner {     _updateProtocolFeeCollector(_protocolFeeCollector); }  function _updateProtocolFeeCollector(address _protocolFeeCollector) internal {     require(_protocolFeeCollector != address(0), 'cant be 0 address');     protocolFeeCollector = _protocolFeeCollector;     emit ProtocolFeeCollectorUpdated(_protocolFeeCollector); }  /**  * @notice used to update the strategy registry address  * @dev can only be updated by owner  * @param _strategyRegistry address of the updated strategy registry  */ function updateStrategyRegistry(address _strategyRegistry) external onlyOwner {     _updateStrategyRegistry(_strategyRegistry); }  function _updateStrategyRegistry(address _strategyRegistry) internal {     require(_strategyRegistry != address(0), 'CL::I zero address');     strategyRegistry = _strategyRegistry;     emit StrategyRegistryUpdated(_strategyRegistry); }  /**  * @notice used to update the liquidatorRewardFraction  * @dev can only be updated by owner  * @param _rewardFraction fraction of liquidated amount given to liquidator as reward  */ function updateLiquidatorRewardFraction(uint256 _rewardFraction) external onlyOwner {     _updateLiquidatorRewardFraction(_rewardFraction); }  function _updateLiquidatorRewardFraction(uint256 _rewardFraction) internal {     require(_rewardFraction &lt;= 10**30, 'Fraction has to be less than 1');     liquidatorRewardFraction = _rewardFraction;     emit LiquidationRewardFractionUpdated(_rewardFraction); }  /**  * @dev Used to Calculate Interest Per second on given principal and Interest rate  * @param _principal principal Amount for which interest has to be calculated.  * @param _borrowRate It is the Interest Rate at which Credit Line is approved  * @return interest per second for the given parameters  */ function calculateInterest(     uint256 _principal,     uint256 _borrowRate,     uint256 _timeElapsed ) public pure returns (uint256) {     uint256 _interest = _principal.mul(_borrowRate).mul(_timeElapsed).div(10**30).div(YEAR_IN_SECONDS);      return _interest; }  /**  * @dev Used to calculate interest accrued since last repayment  * @param _id identifier for the credit line  * @return interest accrued over current borrowed amount since last repayment  */  function calculateInterestAccrued(uint256 _id) public view returns (uint256) {     uint256 _lastPrincipalUpdateTime = creditLineVariables[_id].lastPrincipalUpdateTime;     if (_lastPrincipalUpdateTime == 0) return 0;     uint256 _timeElapsed = (block.timestamp).sub(_lastPrincipalUpdateTime);     uint256 _interestAccrued = calculateInterest(creditLineVariables[_id].principal, creditLineConstants[_id].borrowRate, _timeElapsed);     return _interestAccrued; }  /**  * @dev Used to calculate current debt of borrower against a credit line.  * @param _id identifier for the credit line  * @return current debt of borrower  */ function calculateCurrentDebt(uint256 _id) public view returns (uint256) {     uint256 _interestAccrued = calculateInterestAccrued(_id);     uint256 _currentDebt = (creditLineVariables[_id].principal)         .add(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate)         .add(_interestAccrued)         .sub(creditLineVariables[_id].totalInterestRepaid);     return _currentDebt; }  /**  * @notice used to calculate amount that can be borrowed by the borrower  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view.         borrowableAmount changes per block as interest changes per block.  * @param _id identifier for the credit line  * @return amount that can be borrowed from the credit line  */ function calculateBorrowableAmount(uint256 _id) public returns (uint256) {     CreditLineStatus _status = creditLineVariables[_id].status;     require(         _status == CreditLineStatus.ACTIVE || _status == CreditLineStatus.REQUESTED,         'CreditLine: Cannot only if credit line ACTIVE or REQUESTED'     );     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(         creditLineConstants[_id].collateralAsset,         creditLineConstants[_id].borrowAsset     );      uint256 _totalCollateralToken = calculateTotalCollateralTokens(_id);      uint256 _currentDebt = calculateCurrentDebt(_id);      uint256 _maxPossible = _totalCollateralToken.mul(_ratioOfPrices).div(creditLineConstants[_id].idealCollateralRatio).mul(10**30).div(         10**_decimals     );      uint256 _borrowLimit = creditLineConstants[_id].borrowLimit;      if (_maxPossible &gt; _borrowLimit) {         _maxPossible = _borrowLimit;     }     if (_maxPossible &gt; _currentDebt) {         return _maxPossible.sub(_currentDebt);     }     return 0; }  function updateinterestAccruedTillLastPrincipalUpdate(uint256 _id) internal {     require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');      uint256 _interestAccrued = calculateInterestAccrued(_id);     uint256 _newInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(_interestAccrued);     creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _newInterestAccrued; }  function _depositCollateralFromSavingsAccount(     uint256 _id,     uint256 _amount,     address _sender ) internal {     address _collateralAsset = creditLineConstants[_id].collateralAsset;     address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();     ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);     uint256 _activeAmount;      for (uint256 _index = 0; _index &lt; _strategyList.length; _index++) {         address _strategy = _strategyList[_index];         uint256 _liquidityShares = _savingsAccount.balanceInShares(_sender, _collateralAsset, _strategy);         if (_liquidityShares == 0 || _strategyList[_index] == address(0)) {             continue;         }         uint256 _tokenInStrategy = _liquidityShares;         _tokenInStrategy = IYield(_strategy).getTokensForShares(_liquidityShares, _collateralAsset);          uint256 _tokensToTransfer = _tokenInStrategy;         if (_activeAmount.add(_tokenInStrategy) &gt;= _amount) {             _tokensToTransfer = (_amount.sub(_activeAmount));         }         _activeAmount = _activeAmount.add(_tokensToTransfer);         _savingsAccount.transferFrom(_tokensToTransfer, _collateralAsset, _strategy, _sender, address(this));          collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(             _liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy)         );          if (_amount == _activeAmount) {             return;         }     }     revert('CreditLine::_depositCollateralFromSavingsAccount - Insufficient balance'); }  /**  * @notice used to request a credit line either by borrower or lender  * @param _requestTo Address to which creditLine is requested,                      if borrower creates request then lender address and                      if lender creates then borrower address  * @param _borrowLimit maximum borrow amount in a credit line  * @param _borrowRate Interest Rate at which credit Line is requested  * @param _autoLiquidation if true, anyone can liquidate loan, otherwise only lender  * @param _collateralRatio ratio of the collateral to the debt below which credit line can be liquidated  * @param _borrowAsset address of the token to be borrowed  * @param _collateralAsset address of the token provided as collateral  * @param _requestAsLender if true, lender is placing request, otherwise borrower  * @return identifier for the credit line  */  function request(     address _requestTo,     uint256 _borrowLimit,     uint256 _borrowRate,     bool _autoLiquidation,     uint256 _collateralRatio,     address _borrowAsset,     address _collateralAsset,     bool _requestAsLender ) external returns (uint256) {     require(_borrowAsset != _collateralAsset, 'R: cant borrow lent token');     require(IPriceOracle(priceOracle).doesFeedExist(_borrowAsset, _collateralAsset), 'R: No price feed');      address _lender = _requestTo;     address _borrower = msg.sender;     if (_requestAsLender) {         _lender = msg.sender;         _borrower = _requestTo;     }      uint256 _id = _createRequest(         _lender,         _borrower,         _borrowLimit,         _borrowRate,         _autoLiquidation,         _collateralRatio,         _borrowAsset,         _collateralAsset,         _requestAsLender     );      emit CreditLineRequested(_id, _lender, _borrower);     return _id; }  function _createRequest(     address _lender,     address _borrower,     uint256 _borrowLimit,     uint256 _borrowRate,     bool _autoLiquidation,     uint256 _collateralRatio,     address _borrowAsset,     address _collateralAsset,     bool _requestByLender ) internal returns (uint256) {     require(_lender != _borrower, 'Lender and Borrower cannot be same addresses');     uint256 _id = creditLineCounter + 1;     creditLineCounter = _id;     creditLineVariables[_id].status = CreditLineStatus.REQUESTED;     creditLineConstants[_id].borrower = _borrower;     creditLineConstants[_id].lender = _lender;     creditLineConstants[_id].borrowLimit = _borrowLimit;     creditLineConstants[_id].autoLiquidation = _autoLiquidation;     creditLineConstants[_id].idealCollateralRatio = _collateralRatio;     creditLineConstants[_id].borrowRate = _borrowRate;     creditLineConstants[_id].borrowAsset = _borrowAsset;     creditLineConstants[_id].collateralAsset = _collateralAsset;     creditLineConstants[_id].requestByLender = _requestByLender;     return _id; }  /**  * @notice used to accept a credit line  * @dev if borrower places request, lender can accept and vice versa  * @param _id identifier for the credit line  */ function accept(uint256 _id) external {     require(         creditLineVariables[_id].status == CreditLineStatus.REQUESTED,         'CreditLine::acceptCreditLineLender - CreditLine is already accepted'     );     bool _requestByLender = creditLineConstants[_id].requestByLender;     require(         (msg.sender == creditLineConstants[_id].borrower &amp;&amp; _requestByLender) ||             (msg.sender == creditLineConstants[_id].lender &amp;&amp; !_requestByLender),         "Only Borrower or Lender who hasn't requested can accept"     );     creditLineVariables[_id].status = CreditLineStatus.ACTIVE;     emit CreditLineAccepted(_id); }  /**  * @notice used to deposit collateral into the credit line  * @dev collateral tokens have to be approved in savingsAccount or token contract(unless ether).         If transferred from savings account, the tokens are transferred from strategies in the          order prespecified in strategy registry  * @param _id identifier for the credit line  * @param _amount amount of collateral being deposited  * @param _strategy strategy to which collateral is to be deposited in case transfer is not from savings account  * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount                              otherwise direct from collateral token contract  */ function depositCollateral(     uint256 _id,     uint256 _amount,     address _strategy,     bool _fromSavingsAccount ) external payable nonReentrant ifCreditLineExists(_id) {     require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine not active');     _depositCollateral(_id, _amount, _strategy, _fromSavingsAccount);     emit CollateralDeposited(_id, _amount, _strategy); }  function _depositCollateral(     uint256 _id,     uint256 _amount,     address _strategy,     bool _fromSavingsAccount ) internal {     require(creditLineConstants[_id].lender != msg.sender, 'lender cant deposit collateral');     if (_fromSavingsAccount) {         _depositCollateralFromSavingsAccount(_id, _amount, msg.sender);     } else {         address _collateralAsset = creditLineConstants[_id].collateralAsset;         ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);         if (_collateralAsset == address(0)) {             require(msg.value == _amount, "CreditLine::_depositCollateral - value to transfer doesn't match argument");         } else {             IERC20(_collateralAsset).safeTransferFrom(msg.sender, address(this), _amount);             IERC20(_collateralAsset).approve(_strategy, _amount);         }         uint256 _sharesReceived = _savingsAccount.deposit{value: msg.value}(_amount, _collateralAsset, _strategy, address(this));         collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(_sharesReceived);     } }  function _withdrawBorrowAmount(     address _asset,     uint256 _amountInTokens,     address _lender ) internal {     address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();     ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);     uint256 _activeAmount;     for (uint256 _index = 0; _index &lt; _strategyList.length; _index++) {         if (_strategyList[_index] == address(0)) {             continue;         }         uint256 _liquidityShares = _savingsAccount.balanceInShares(_lender, _asset, _strategyList[_index]);         if (_liquidityShares != 0) {             uint256 tokenInStrategy = _liquidityShares;             tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);             uint256 _tokensToTransfer = tokenInStrategy;             if (_activeAmount.add(tokenInStrategy) &gt;= _amountInTokens) {                 _tokensToTransfer = (_amountInTokens.sub(_activeAmount));             }             _activeAmount = _activeAmount.add(_tokensToTransfer);             _savingsAccount.withdrawFrom(_tokensToTransfer, _asset, _strategyList[_index], _lender, address(this), false);             if (_activeAmount == _amountInTokens) {                 return;             }         }     }     require(_activeAmount == _amountInTokens, 'insufficient balance'); }  /**  * @notice used to borrow tokens from credit line by borrower  * @dev only borrower can call this function. Amount that can actually be borrowed is          min(amount based on borrowLimit, allowance to creditLine contract, balance of lender)  * @param _id identifier for the credit line  * @param _amount amount of tokens to borrow  */ function borrow(uint256 _id, uint256 _amount) external payable nonReentrant onlyCreditLineBorrower(_id) {     require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');     uint256 _borrowableAmount = calculateBorrowableAmount(_id);     require(_amount &lt;= _borrowableAmount, "CreditLine::borrow - The current collateral ratio doesn't allow to withdraw the amount");     address _borrowAsset = creditLineConstants[_id].borrowAsset;     address _lender = creditLineConstants[_id].lender;      updateinterestAccruedTillLastPrincipalUpdate(_id);     creditLineVariables[_id].principal = creditLineVariables[_id].principal.add(_amount);     creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;      uint256 _tokenDiffBalance;     if (_borrowAsset != address(0)) {         uint256 _balanceBefore = IERC20(_borrowAsset).balanceOf(address(this));         _withdrawBorrowAmount(_borrowAsset, _amount, _lender);         uint256 _balanceAfter = IERC20(_borrowAsset).balanceOf(address(this));         _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);     } else {         uint256 _balanceBefore = address(this).balance;         _withdrawBorrowAmount(_borrowAsset, _amount, _lender);         uint256 _balanceAfter = address(this).balance;         _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);     }     uint256 _protocolFee = _tokenDiffBalance.mul(protocolFeeFraction).div(10**30);     _tokenDiffBalance = _tokenDiffBalance.sub(_protocolFee);      if (_borrowAsset == address(0)) {         (bool feeSuccess, ) = protocolFeeCollector.call{value: _protocolFee}('');         require(feeSuccess, 'Transfer fail');         (bool success, ) = msg.sender.call{value: _tokenDiffBalance}('');         require(success, 'Transfer fail');     } else {         IERC20(_borrowAsset).safeTransfer(protocolFeeCollector, _protocolFee);         IERC20(_borrowAsset).safeTransfer(msg.sender, _tokenDiffBalance);     }     emit BorrowedFromCreditLine(_id, _tokenDiffBalance); }  function _repayFromSavingsAccount(     uint256 _amount,     address _asset,     address _lender ) internal {     address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();     ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);     uint256 _activeAmount;      for (uint256 _index = 0; _index &lt; _strategyList.length; _index++) {         if (_strategyList[_index] == address(0)) {             continue;         }         uint256 _liquidityShares = _savingsAccount.balanceInShares(msg.sender, _asset, _strategyList[_index]);         if (_liquidityShares == 0) {             continue;         }         uint256 _tokenInStrategy = _liquidityShares;         _tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);          uint256 _tokensToTransfer = _tokenInStrategy;         if (_activeAmount.add(_tokenInStrategy) &gt;= _amount) {             _tokensToTransfer = (_amount.sub(_activeAmount));         }         _activeAmount = _activeAmount.add(_tokensToTransfer);         _savingsAccount.transferFrom(_tokensToTransfer, _asset, _strategyList[_index], msg.sender, _lender);          if (_amount == _activeAmount) {             return;         }     }     revert('CreditLine::_repayFromSavingsAccount - Insufficient balance'); }  function _repay(     uint256 _id,     uint256 _amount,     bool _fromSavingsAccount,     uint256 _principalPaid ) internal {     ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);     address _defaultStrategy = defaultStrategy;     address _borrowAsset = creditLineConstants[_id].borrowAsset;     address _lender = creditLineConstants[_id].lender;     if (!_fromSavingsAccount) {         if (_borrowAsset == address(0)) {             require(msg.value == _amount, 'creditLine::repay - Ether sent not equal to repay amount');             _savingsAccount.deposit{value: _amount}(_amount, _borrowAsset, _defaultStrategy, _lender);         } else {             IERC20(_borrowAsset).safeTransferFrom(msg.sender, address(this), _amount);             IERC20(_borrowAsset).approve(_defaultStrategy, _amount);             _savingsAccount.deposit(_amount, _borrowAsset, _defaultStrategy, _lender);         }     } else {         _repayFromSavingsAccount(_amount, _borrowAsset, _lender);     }     if (_principalPaid != 0) {         _savingsAccount.increaseAllowanceToCreditLine(_principalPaid, _borrowAsset, _lender);     } }  /**  * @notice used to repay interest and principal to credit line. Interest has to be repaid before repaying principal  * @dev partial repayments possible  * @param _id identifier for the credit line  * @param _amount amount being repaid  * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount                              otherwise direct from collateral token contract  */ function repay(     uint256 _id,     uint256 _amount,     bool _fromSavingsAccount ) external payable nonReentrant {     require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');     require(creditLineConstants[_id].lender != msg.sender, 'Lender cant repay');      uint256 _interestSincePrincipalUpdate = calculateInterestAccrued(_id);     uint256 _totalInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(         _interestSincePrincipalUpdate     );     uint256 _interestToPay = _totalInterestAccrued.sub(creditLineVariables[_id].totalInterestRepaid);     uint256 _totalCurrentDebt = _interestToPay.add(creditLineVariables[_id].principal);     uint256 _principalPaid = 0;      if (_amount &gt;= _totalCurrentDebt) {         _amount = _totalCurrentDebt;         emit CompleteCreditLineRepaid(_id, _amount);     } else {         emit PartialCreditLineRepaid(_id, _amount);     }      if (_amount &gt; _interestToPay) {         creditLineVariables[_id].principal = _totalCurrentDebt.sub(_amount);         creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _totalInterestAccrued;         creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;         creditLineVariables[_id].totalInterestRepaid = _totalInterestAccrued;         _principalPaid = _amount.sub(_interestToPay);     } else {         creditLineVariables[_id].totalInterestRepaid = creditLineVariables[_id].totalInterestRepaid.add(_amount);     }      _repay(_id, _amount, _fromSavingsAccount, _principalPaid);      if (creditLineVariables[_id].principal == 0) {         _resetCreditLine(_id);     } }  function _resetCreditLine(uint256 _id) internal {     creditLineVariables[_id].lastPrincipalUpdateTime = 0;     creditLineVariables[_id].totalInterestRepaid = 0;     creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = 0;     emit CreditLineReset(_id); }  /**  * @dev used to close credit line by borrower or lender  * @param _id identifier for the credit line  */ function close(uint256 _id) external ifCreditLineExists(_id) {     require(         msg.sender == creditLineConstants[_id].borrower || msg.sender == creditLineConstants[_id].lender,         'CreditLine: Permission denied while closing Line of credit'     );     require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: Credit line should be active.');     require(creditLineVariables[_id].principal == 0, 'CreditLine: Cannot be closed since not repaid.');     require(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate == 0, 'CreditLine: Cannot be closed since not repaid.');     creditLineVariables[_id].status = CreditLineStatus.CLOSED;     emit CreditLineClosed(_id); }  /**  * @notice used to calculate the current collateral ratio  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view.         Interest is also considered while calculating debt  * @param _id identifier for the credit line  * @return collateral ratio multiplied by 10**30 to retain precision  */ function calculateCurrentCollateralRatio(uint256 _id) public ifCreditLineExists(_id) returns (uint256) {     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(         creditLineConstants[_id].collateralAsset,         creditLineConstants[_id].borrowAsset     );      uint256 currentDebt = calculateCurrentDebt(_id);     uint256 currentCollateralRatio = calculateTotalCollateralTokens(_id).mul(_ratioOfPrices).div(currentDebt).mul(10**30).div(         10**_decimals     );      return currentCollateralRatio; }  /**  * @notice used to calculate the total collateral tokens  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view  * @param _id identifier for the credit line  * @return _amount total collateral tokens deposited into the credit line  */ function calculateTotalCollateralTokens(uint256 _id) public returns (uint256 _amount) {     address _collateralAsset = creditLineConstants[_id].collateralAsset;     address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();     uint256 _liquidityShares;     for (uint256 index = 0; index &lt; _strategyList.length; index++) {         if (_strategyList[index] == address(0)) {             continue;         }         _liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];         uint256 _tokenInStrategy = _liquidityShares;         _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(_liquidityShares, _collateralAsset);          _amount = _amount.add(_tokenInStrategy);     } }  /**  * @notice used to withdraw any excess collateral  * @dev collateral can't be withdraw if collateralRatio goes below the ideal value. Only borrower can withdraw  * @param _id identifier for the credit line  * @param _amount amount of collateral to withdraw  * @param _toSavingsAccount if true, tokens are transferred from savingsAccount                              otherwise direct from collateral token contract  */ function withdrawCollateral(     uint256 _id,     uint256 _amount,     bool _toSavingsAccount ) external nonReentrant onlyCreditLineBorrower(_id) {     uint256 _withdrawableCollateral = withdrawableCollateral(_id);     require(_amount &lt;= _withdrawableCollateral, 'Collateral ratio cant go below ideal');     address _collateralAsset = creditLineConstants[_id].collateralAsset;     _transferCollateral(_id, _collateralAsset, _amount, _toSavingsAccount);     emit CollateralWithdrawn(_id, _amount); }  /**  * @notice used to calculate the collateral that can be withdrawn  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view  * @param _id identifier for the credit line  * @return total collateral withdrawable by borrower  */ function withdrawableCollateral(uint256 _id) public returns (uint256) {     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(         creditLineConstants[_id].collateralAsset,         creditLineConstants[_id].borrowAsset     );      uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);     uint256 _currentDebt = calculateCurrentDebt(_id);      uint256 _collateralNeeded = _currentDebt         .mul(creditLineConstants[_id].idealCollateralRatio)         .div(_ratioOfPrices)         .mul(10**_decimals)         .div(10**30);      if (_collateralNeeded &gt;= _totalCollateralTokens) {         return 0;     }     return _totalCollateralTokens.sub(_collateralNeeded); }  function _transferCollateral(     uint256 _id,     address _asset,     uint256 _amountInTokens,     bool _toSavingsAccount ) internal {     address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();     uint256 _activeAmount;     for (uint256 index = 0; index &lt; _strategyList.length; index++) {         uint256 liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];         if (liquidityShares == 0 || _strategyList[index] == address(0)) {             continue;         }         uint256 _tokenInStrategy = liquidityShares;         _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(liquidityShares, _asset);         uint256 _tokensToTransfer = _tokenInStrategy;         if (_activeAmount.add(_tokenInStrategy) &gt; _amountInTokens) {             _tokensToTransfer = _amountInTokens.sub(_activeAmount);             liquidityShares = liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy);         }         _activeAmount = _activeAmount.add(_tokensToTransfer);         collateralShareInStrategy[_id][_strategyList[index]] = collateralShareInStrategy[_id][_strategyList[index]].sub(             liquidityShares         );         if (_toSavingsAccount) {             ISavingsAccount(savingsAccount).transfer(_tokensToTransfer, _asset, _strategyList[index], msg.sender);         } else {             ISavingsAccount(savingsAccount).withdraw(_tokensToTransfer, _asset, _strategyList[index], msg.sender, false);         }          if (_activeAmount == _amountInTokens) {             return;         }     }     revert('insufficient collateral'); }  /**  * @notice used to liquidate credit line in case collateral ratio goes below the threshold  * @dev if lender liquidates, then collateral is directly transferred.          If autoLiquidation is true, anyone can liquidate by providing enough borrow tokens  * @param _id identifier for the credit line  * @param _toSavingsAccount if true, tokens are transferred from savingsAccount                              otherwise direct from collateral token contract  */ function liquidate(uint256 _id, bool _toSavingsAccount) external payable nonReentrant {     require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: Credit line should be active.');     require(creditLineVariables[_id].principal != 0, 'CreditLine: cannot liquidate if principal is 0');      uint256 currentCollateralRatio = calculateCurrentCollateralRatio(_id);     require(         currentCollateralRatio &lt; creditLineConstants[_id].idealCollateralRatio,         'CreditLine: Collateral ratio is higher than ideal value'     );      address _collateralAsset = creditLineConstants[_id].collateralAsset;     address _lender = creditLineConstants[_id].lender;     uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);     address _borrowAsset = creditLineConstants[_id].borrowAsset;      creditLineVariables[_id].status = CreditLineStatus.LIQUIDATED;      if (creditLineConstants[_id].autoLiquidation &amp;&amp; _lender != msg.sender) {         uint256 _borrowTokens = _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens);         if (_borrowAsset == address(0)) {             uint256 _returnETH = msg.value.sub(_borrowTokens, 'Insufficient ETH to liquidate');             if (_returnETH != 0) {                 (bool success, ) = msg.sender.call{value: _returnETH}('');                 require(success, 'Transfer fail');             }         } else {             IERC20(_borrowAsset).safeTransferFrom(msg.sender, _lender, _borrowTokens);         }     }      _transferCollateral(_id, _collateralAsset, _totalCollateralTokens, _toSavingsAccount);      emit CreditLineLiquidated(_id, msg.sender); }  /**  * @notice used to calculate the borrow tokens necessary for liquidator to liquidate  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view  * @param _id identifier for the credit line  * @return borrow tokens necessary for liquidator to liquidate  */ function borrowTokensToLiquidate(uint256 _id) external returns (uint256) {     address _collateralAsset = creditLineConstants[_id].collateralAsset;     uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);     address _borrowAsset = creditLineConstants[_id].borrowAsset;      return _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens); }  function _borrowTokensToLiquidate(     address _borrowAsset,     address _collateralAsset,     uint256 _totalCollateralTokens ) internal view returns (uint256) {     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(_borrowAsset, _collateralAsset);     uint256 _borrowTokens = (         _totalCollateralTokens.mul(uint256(10**30).sub(liquidatorRewardFraction)).div(10**30).mul(_ratioOfPrices).div(10**_decimals)     );      return _borrowTokens; }  receive() external payable {     require(msg.sender == savingsAccount, 'CreditLine::receive invalid transaction'); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: "{task}". Ideas: "{ideas}". As the {assistant_role}, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability. For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix. Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: " Analysis Complete." |
| **phase_name** | ContractReviewComment |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 1, 'task': '// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\n\nimport \'@openzeppelin/contracts/token/ERC20/SafeERC20.sol\';\nimport \'@openzeppelin/contracts/math/SafeMath.sol\';\nimport \'@openzeppelin/contracts/utils/ReentrancyGuard.sol\';\nimport \'@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\';\nimport \'../interfaces/IPriceOracle.sol\';\nimport \'../interfaces/IYield.sol\';\nimport \'../interfaces/ISavingsAccount.sol\';\nimport \'../SavingsAccount/SavingsAccountUtil.sol\';\nimport \'../interfaces/IStrategyRegistry.sol\';\n\n/\n * @title Credit Line contract with Methods related to credit Line\n * @notice Implements the functions related to Credit Line\n * @author Sublime\n /\n\ncontract CreditLine is ReentrancyGuard, OwnableUpgradeable {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    enum CreditLineStatus {\n        NOT_CREATED,\n        REQUESTED,\n        ACTIVE,\n        CLOSED,\n        CANCELLED,\n        LIQUIDATED\n    }\n\n    /\n     * @notice counter that tracks the number of credit lines created\n     * @dev used to create unique identifier for credit lines\n     /\n    uint256 public creditLineCounter;\n\n    uint256 constant YEAR_IN_SECONDS = 365 days;\n\n    struct CreditLineVariables {\n        CreditLineStatus status;\n        uint256 principal;\n        uint256 totalInterestRepaid;\n        uint256 lastPrincipalUpdateTime;\n        uint256 interestAccruedTillLastPrincipalUpdate;\n    }\n\n    struct CreditLineConstants {\n        address lender;\n        address borrower;\n        uint256 borrowLimit;\n        uint256 idealCollateralRatio;\n        uint256 borrowRate;\n        address borrowAsset;\n        address collateralAsset;\n        bool autoLiquidation;\n        bool requestByLender;\n    }\n    /\n     * @notice stores the collateral shares in a credit line per strategy\n     * @dev creditLineId =&gt; Strategy =&gt; collateralShares\n     /\n    mapping(uint256 =&gt; mapping(address =&gt; uint256)) public collateralShareInStrategy;\n\n    /\n     * @notice stores the variables to maintain a credit line\n     /\n    mapping(uint256 =&gt; CreditLineVariables) public creditLineVariables;\n\n    /\n     * @notice stores the constants related to a credit line\n     /\n    mapping(uint256 =&gt; CreditLineConstants) public creditLineConstants;\n\n    /\n     * @notice stores the address of savings account contract\n     /\n    address public savingsAccount;\n\n    /\n     * @notice stores the address of price oracle contract\n     /\n    address public priceOracle;\n\n    /\n     * @notice stores the address of strategy registry contract\n     /\n    address public strategyRegistry;\n\n    /\n     * @notice stores the address of default strategy\n     /\n    address public defaultStrategy;\n\n    /\n     * @notice stores the fraction of borrowed amount charged as fee by protocol\n     * @dev it is multiplied by 1030\n     /\n    uint256 public protocolFeeFraction;\n\n    /\n     * @notice address where protocol fee is collected\n     /\n    address public protocolFeeCollector;\n\n    /\n     * @notice stores the fraction of amount liquidated given as reward to liquidator\n     * @dev it is multiplied by 1030\n     /\n    uint256 public liquidatorRewardFraction;\n    /\n     * @dev checks if Credit Line exists\n     * @param _id identifier for the credit line\n     /\n    modifier ifCreditLineExists(uint256 id) {\n        require(creditLineVariables[_id].status != CreditLineStatus.NOT_CREATED, \'Credit line does not exist\');\n        ;\n    }\n\n    /\n     * @dev checks if called by credit Line Borrower\n     * @param _id creditLine identifier\n     /\n    modifier onlyCreditLineBorrower(uint256 id) {\n        require(creditLineConstants[_id].borrower == msg.sender, \'Only credit line Borrower can access\');\n        ;\n    }\n\n    /\n     * @dev checks if called by credit Line Lender\n     * @param _id creditLine identifier\n     /\n    modifier onlyCreditLineLender(uint256 id) {\n        require(creditLineConstants[_id].lender == msg.sender, \'Only credit line Lender can access\');\n        ;\n    }\n\n    /\n     * @notice emitted when a collateral is deposited into credit line\n     * @param id id of the credit line\n     * @param amount amount of collateral deposited\n     * @param strategy address of the strategy into which collateral is deposited\n     */\n    event CollateralDeposited(uint256 indexed id, uint256 amount, address indexed strategy);\n\n    /\n     * @notice emitted when collateral is withdrawn from credit line\n     * @param id id of the credit line\n     * @param amount amount of collateral withdrawn\n     /\n    event CollateralWithdrawn(uint256 indexed id, uint256 amount);\n\n    /\n     * @notice emitted when a request for new credit line is placed\n     * @param id id of the credit line for which request was made\n     * @param lender address of the lender for credit line\n     * @param borrower address of the borrower for credit line\n     /\n    event CreditLineRequested(uint256 indexed id, address indexed lender, address indexed borrower);\n\n    /\n     * @notice emitted when a credit line is liquidated\n     * @param id id of the credit line which is liquidated\n     * @param liquidator address of the liquidator\n     */\n    event CreditLineLiquidated(uint256 indexed id, address indexed liquidator);\n\n    /\n     * @notice emitted when tokens are borrowed from credit line\n     * @param id id of the credit line from which tokens are borrowed\n     * @param borrowAmount amount of tokens borrowed\n     /\n    event BorrowedFromCreditLine(uint256 indexed id, uint256 borrowAmount);\n\n    /\n     * @notice emitted when credit line is accepted\n     * @param id id of the credit line that was accepted\n     /\n    event CreditLineAccepted(uint256 indexed id);\n\n    /\n     * @notice emitted when credit line is completely repaid and reset\n     * @param id id of the credit line that is reset\n     */\n    event CreditLineReset(uint256 indexed id);\n\n    /\n     * @notice emitted when the credit line is partially repaid\n     * @param id id of the credit line\n     * @param repayAmount amount repaid\n     /\n    event PartialCreditLineRepaid(uint256 indexed id, uint256 repayAmount);\n\n    /\n     * @notice emitted when the credit line is completely repaid\n     * @param id id of the credit line\n     * @param repayAmount amount repaid\n     /\n    event CompleteCreditLineRepaid(uint256 indexed id, uint256 repayAmount);\n\n    /\n     * @notice emitted when the credit line is closed by one of the parties of credit line\n     * @param id id of the credit line\n     */\n    event CreditLineClosed(uint256 indexed id);\n\n    /\n     * @notice emitted when default strategy for the credit line is updated\n     * @param defaultStrategy address of the strategy contract that is used as default by credit lines\n     /\n    event DefaultStrategyUpdated(address indexed defaultStrategy);\n\n    /\n     * @notice emitted when the price oracle is updated\n     * @param priceOracle address of the updated price oracle\n     /\n    event PriceOracleUpdated(address indexed priceOracle);\n\n    /\n     * @notice emitted when the savings account address is updated\n     * @param savingsAccount address of the updated savingsAccount\n     */\n    event SavingsAccountUpdated(address indexed savingsAccount);\n\n    /\n     * @notice emitted when strategy registry address is updated\n     * @param strategyRegistry address of the updated strategy registry\n     /\n    event StrategyRegistryUpdated(address indexed strategyRegistry);\n\n    /\n     * @notice emitted when fee that protocol charges for credit line is updated\n     * @param updatedProtocolFee updated value of protocolFeeFraction\n     /\n    event ProtocolFeeFractionUpdated(uint256 updatedProtocolFee);\n\n    /\n     * @notice emitted when address which receives fee that protocol changes for pools is updated\n     * @param updatedProtocolFeeCollector updated value of protocolFeeCollector\n     */\n    event ProtocolFeeCollectorUpdated(address indexed updatedProtocolFeeCollector);\n\n    /\n     * @notice emitted when liquidatorRewardFraction is updated\n     * @param liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator\n     /\n    event LiquidationRewardFractionUpdated(uint256 liquidatorRewardFraction);\n\n    /\n     * @notice used to initialize the contract\n     * @dev can only be called once during the life cycle of the contract\n     * @param _defaultStrategy default strategy used in credit lines\n     * @param _priceOracle address of the priceOracle\n     * @param _savingsAccount address of  the savings account contract\n     * @param _strategyRegistry address of the strategy registry contract\n     * @param _owner address of owner who can change global variables\n     * @param _protocolFeeFraction fraction of the fee charged by protocol\n     * @param _protocolFeeCollector address to which protocol fee is charged to\n     * @param _liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator\n     /\n    function initialize(\n        address _defaultStrategy,\n        address _priceOracle,\n        address _savingsAccount,\n        address _strategyRegistry,\n        address _owner,\n        uint256 _protocolFeeFraction,\n        address _protocolFeeCollector,\n        uint256 _liquidatorRewardFraction\n    ) external initializer {\n        OwnableUpgradeable.__Ownable_init();\n        OwnableUpgradeable.transferOwnership(_owner);\n\n        _updateDefaultStrategy(_defaultStrategy);\n        _updatePriceOracle(_priceOracle);\n        _updateSavingsAccount(_savingsAccount);\n        _updateStrategyRegistry(_strategyRegistry);\n        _updateProtocolFeeFraction(_protocolFeeFraction);\n        _updateProtocolFeeCollector(_protocolFeeCollector);\n        _updateLiquidatorRewardFraction(_liquidatorRewardFraction);\n    }\n\n    /\n     * @notice used to update the default strategy\n     * @dev can only be updated by owner\n     * @param _defaultStrategy address of the updated default strategy\n     */\n    function updateDefaultStrategy(address _defaultStrategy) external onlyOwner {\n        _updateDefaultStrategy(_defaultStrategy);\n    }\n\n    function _updateDefaultStrategy(address _defaultStrategy) internal {\n        defaultStrategy = _defaultStrategy;\n        emit DefaultStrategyUpdated(_defaultStrategy);\n    }\n\n    /\n     * @notice used to update the price oracle\n     * @dev can only be updated by owner\n     * @param _priceOracle address of the updated price oracle\n     /\n    function updatePriceOracle(address _priceOracle) external onlyOwner {\n        _updatePriceOracle(_priceOracle);\n    }\n\n    function _updatePriceOracle(address _priceOracle) internal {\n        priceOracle = _priceOracle;\n        emit PriceOracleUpdated(_priceOracle);\n    }\n\n    /\n     * @notice used to update the savings account address\n     * @dev can only be updated by owner\n     * @param _savingsAccount address of the updated savings account\n     /\n    function updateSavingsAccount(address _savingsAccount) external onlyOwner {\n        _updateSavingsAccount(_savingsAccount);\n    }\n\n    function _updateSavingsAccount(address _savingsAccount) internal {\n        savingsAccount = _savingsAccount;\n        emit SavingsAccountUpdated(_savingsAccount);\n    }\n\n    /\n     * @notice used to update the protocol fee fraction\n     * @dev can only be updated by owner\n     * @param _protocolFee fraction of the borrower amount collected as protocol fee\n     */\n    function updateProtocolFeeFraction(uint256 _protocolFee) external onlyOwner {\n        _updateProtocolFeeFraction(_protocolFee);\n    }\n\n    function _updateProtocolFeeFraction(uint256 _protocolFee) internal {\n        protocolFeeFraction = _protocolFee;\n        emit ProtocolFeeFractionUpdated(_protocolFee);\n    }\n\n    /\n     * @notice used to update the protocol fee collector\n     * @dev can only be updated by owner\n     * @param _protocolFeeCollector address in which protocol fee is collected\n     /\n    function updateProtocolFeeCollector(address _protocolFeeCollector) external onlyOwner {\n        _updateProtocolFeeCollector(_protocolFeeCollector);\n    }\n\n    function _updateProtocolFeeCollector(address _protocolFeeCollector) internal {\n        require(_protocolFeeCollector != address(0), \'cant be 0 address\');\n        protocolFeeCollector = _protocolFeeCollector;\n        emit ProtocolFeeCollectorUpdated(_protocolFeeCollector);\n    }\n\n    /\n     * @notice used to update the strategy registry address\n     * @dev can only be updated by owner\n     * @param _strategyRegistry address of the updated strategy registry\n     /\n    function updateStrategyRegistry(address _strategyRegistry) external onlyOwner {\n        _updateStrategyRegistry(_strategyRegistry);\n    }\n\n    function _updateStrategyRegistry(address _strategyRegistry) internal {\n        require(_strategyRegistry != address(0), \'CL::I zero address\');\n        strategyRegistry = _strategyRegistry;\n        emit StrategyRegistryUpdated(_strategyRegistry);\n    }\n\n    /\n     * @notice used to update the liquidatorRewardFraction\n     * @dev can only be updated by owner\n     * @param _rewardFraction fraction of liquidated amount given to liquidator as reward\n     */\n    function updateLiquidatorRewardFraction(uint256 _rewardFraction) external onlyOwner {\n        _updateLiquidatorRewardFraction(_rewardFraction);\n    }\n\n    function _updateLiquidatorRewardFraction(uint256 _rewardFraction) internal {\n        require(_rewardFraction &lt;= 1030, \'Fraction has to be less than 1\');\n        liquidatorRewardFraction = _rewardFraction;\n        emit LiquidationRewardFractionUpdated(_rewardFraction);\n    }\n\n    /\n     * @dev Used to Calculate Interest Per second on given principal and Interest rate\n     * @param _principal principal Amount for which interest has to be calculated.\n     * @param _borrowRate It is the Interest Rate at which Credit Line is approved\n     * @return interest per second for the given parameters\n     */\n    function calculateInterest(\n        uint256 _principal,\n        uint256 _borrowRate,\n        uint256 _timeElapsed\n    ) public pure returns (uint256) {\n        uint256 _interest = _principal.mul(_borrowRate).mul(_timeElapsed).div(1030).div(YEAR_IN_SECONDS);\n\n        return _interest;\n    }\n\n    /\n     * @dev Used to calculate interest accrued since last repayment\n     * @param _id identifier for the credit line\n     * @return interest accrued over current borrowed amount since last repayment\n     */\n\n    function calculateInterestAccrued(uint256 _id) public view returns (uint256) {\n        uint256 _lastPrincipalUpdateTime = creditLineVariables[_id].lastPrincipalUpdateTime;\n        if (_lastPrincipalUpdateTime == 0) return 0;\n        uint256 _timeElapsed = (block.timestamp).sub(_lastPrincipalUpdateTime);\n        uint256 _interestAccrued = calculateInterest(creditLineVariables[_id].principal, creditLineConstants[_id].borrowRate, _timeElapsed);\n        return _interestAccrued;\n    }\n\n    /\n     * @dev Used to calculate current debt of borrower against a credit line.\n     * @param _id identifier for the credit line\n     * @return current debt of borrower\n     /\n    function calculateCurrentDebt(uint256 _id) public view returns (uint256) {\n        uint256 _interestAccrued = calculateInterestAccrued(_id);\n        uint256 _currentDebt = (creditLineVariables[_id].principal)\n            .add(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate)\n            .add(_interestAccrued)\n            .sub(creditLineVariables[_id].totalInterestRepaid);\n        return _currentDebt;\n    }\n\n    /\n     * @notice used to calculate amount that can be borrowed by the borrower\n     * @dev is a view function for the protocol itself, but isn\'t view because of getTokensForShares which is not view.\n            borrowableAmount changes per block as interest changes per block.\n     * @param _id identifier for the credit line\n     * @return amount that can be borrowed from the credit line\n     /\n    function calculateBorrowableAmount(uint256 _id) public returns (uint256) {\n        CreditLineStatus _status = creditLineVariables[_id].status;\n        require(\n            _status == CreditLineStatus.ACTIVE || _status == CreditLineStatus.REQUESTED,\n            \'CreditLine: Cannot only if credit line ACTIVE or REQUESTED\'\n        );\n        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(\n            creditLineConstants[_id].collateralAsset,\n            creditLineConstants[_id].borrowAsset\n        );\n\n        uint256 _totalCollateralToken = calculateTotalCollateralTokens(_id);\n\n        uint256 _currentDebt = calculateCurrentDebt(_id);\n\n        uint256 _maxPossible = _totalCollateralToken.mul(_ratioOfPrices).div(creditLineConstants[_id].idealCollateralRatio).mul(1030).div(\n            10_decimals\n        );\n\n        uint256 _borrowLimit = creditLineConstants[_id].borrowLimit;\n\n        if (_maxPossible &gt; _borrowLimit) {\n            _maxPossible = _borrowLimit;\n        }\n        if (_maxPossible &gt; _currentDebt) {\n            return _maxPossible.sub(_currentDebt);\n        }\n        return 0;\n    }\n\n    function updateinterestAccruedTillLastPrincipalUpdate(uint256 _id) internal {\n        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, \'CreditLine: The credit line is not yet active.\');\n\n        uint256 _interestAccrued = calculateInterestAccrued(_id);\n        uint256 _newInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(_interestAccrued);\n        creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _newInterestAccrued;\n    }\n\n    function _depositCollateralFromSavingsAccount(\n        uint256 _id,\n        uint256 _amount,\n        address _sender\n    ) internal {\n        address _collateralAsset = creditLineConstants[_id].collateralAsset;\n        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();\n        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);\n        uint256 _activeAmount;\n\n        for (uint256 _index = 0; _index &lt; _strategyList.length; _index++) {\n            address _strategy = _strategyList[_index];\n            uint256 _liquidityShares = _savingsAccount.balanceInShares(_sender, _collateralAsset, _strategy);\n            if (_liquidityShares == 0 || _strategyList[_index] == address(0)) {\n                continue;\n            }\n            uint256 _tokenInStrategy = _liquidityShares;\n            _tokenInStrategy = IYield(_strategy).getTokensForShares(_liquidityShares, _collateralAsset);\n\n            uint256 _tokensToTransfer = _tokenInStrategy;\n            if (_activeAmount.add(_tokenInStrategy) &gt;= _amount) {\n                _tokensToTransfer = (_amount.sub(_activeAmount));\n            }\n            _activeAmount = _activeAmount.add(_tokensToTransfer);\n            _savingsAccount.transferFrom(_tokensToTransfer, _collateralAsset, _strategy, _sender, address(this));\n\n            collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(\n                _liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy)\n            );\n\n            if (_amount == _activeAmount) {\n                return;\n            }\n        }\n        revert(\'CreditLine::_depositCollateralFromSavingsAccount - Insufficient balance\');\n    }\n\n    /\n     * @notice used to request a credit line either by borrower or lender\n     * @param _requestTo Address to which creditLine is requested, \n                        if borrower creates request then lender address and \n                        if lender creates then borrower address\n     * @param _borrowLimit maximum borrow amount in a credit line\n     * @param _borrowRate Interest Rate at which credit Line is requested\n     * @param _autoLiquidation if true, anyone can liquidate loan, otherwise only lender\n     * @param _collateralRatio ratio of the collateral to the debt below which credit line can be liquidated\n     * @param _borrowAsset address of the token to be borrowed\n     * @param _collateralAsset address of the token provided as collateral\n     * @param _requestAsLender if true, lender is placing request, otherwise borrower\n     * @return identifier for the credit line\n     */\n\n    function request(\n        address _requestTo,\n        uint256 _borrowLimit,\n        uint256 _borrowRate,\n        bool _autoLiquidation,\n        uint256 _collateralRatio,\n        address _borrowAsset,\n        address _collateralAsset,\n        bool _requestAsLender\n    ) external returns (uint256) {\n        require(_borrowAsset != _collateralAsset, \'R: cant borrow lent token\');\n        require(IPriceOracle(priceOracle).doesFeedExist(_borrowAsset, _collateralAsset), \'R: No price feed\');\n\n        address _lender = _requestTo;\n        address _borrower = msg.sender;\n        if (_requestAsLender) {\n            _lender = msg.sender;\n            _borrower = _requestTo;\n        }\n\n        uint256 _id = _createRequest(\n            _lender,\n            _borrower,\n            _borrowLimit,\n            _borrowRate,\n            _autoLiquidation,\n            _collateralRatio,\n            _borrowAsset,\n            _collateralAsset,\n            _requestAsLender\n        );\n\n        emit CreditLineRequested(_id, _lender, _borrower);\n        return _id;\n    }\n\n    function _createRequest(\n        address _lender,\n        address _borrower,\n        uint256 _borrowLimit,\n        uint256 _borrowRate,\n        bool _autoLiquidation,\n        uint256 _collateralRatio,\n        address _borrowAsset,\n        address _collateralAsset,\n        bool _requestByLender\n    ) internal returns (uint256) {\n        require(_lender != _borrower, \'Lender and Borrower cannot be same addresses\');\n        uint256 _id = creditLineCounter + 1;\n        creditLineCounter = _id;\n        creditLineVariables[_id].status = CreditLineStatus.REQUESTED;\n        creditLineConstants[_id].borrower = _borrower;\n        creditLineConstants[_id].lender = _lender;\n        creditLineConstants[_id].borrowLimit = _borrowLimit;\n        creditLineConstants[_id].autoLiquidation = _autoLiquidation;\n        creditLineConstants[_id].idealCollateralRatio = _collateralRatio;\n        creditLineConstants[_id].borrowRate = _borrowRate;\n        creditLineConstants[_id].borrowAsset = _borrowAsset;\n        creditLineConstants[_id].collateralAsset = _collateralAsset;\n        creditLineConstants[_id].requestByLender = _requestByLender;\n        return _id;\n    }\n\n    /\n     * @notice used to accept a credit line\n     * @dev if borrower places request, lender can accept and vice versa\n     * @param _id identifier for the credit line\n     /\n    function accept(uint256 _id) external {\n        require(\n            creditLineVariables[_id].status == CreditLineStatus.REQUESTED,\n            \'CreditLine::acceptCreditLineLender - CreditLine is already accepted\'\n        );\n        bool _requestByLender = creditLineConstants[_id].requestByLender;\n        require(\n            (msg.sender == creditLineConstants[_id].borrower &amp;&amp; _requestByLender) ||\n                (msg.sender == creditLineConstants[_id].lender &amp;&amp; !_requestByLender),\n            "Only Borrower or Lender who hasn\'t requested can accept"\n        );\n        creditLineVariables[_id].status = CreditLineStatus.ACTIVE;\n        emit CreditLineAccepted(_id);\n    }\n\n    /\n     * @notice used to deposit collateral into the credit line\n     * @dev collateral tokens have to be approved in savingsAccount or token contract(unless ether).\n            If transferred from savings account, the tokens are transferred from strategies in the \n            order prespecified in strategy registry\n     * @param _id identifier for the credit line\n     * @param _amount amount of collateral being deposited\n     * @param _strategy strategy to which collateral is to be deposited in case transfer is not from savings account\n     * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount \n                                otherwise direct from collateral token contract\n     /\n    function depositCollateral(\n        uint256 _id,\n        uint256 _amount,\n        address _strategy,\n        bool _fromSavingsAccount\n    ) external payable nonReentrant ifCreditLineExists(_id) {\n        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, \'CreditLine not active\');\n        _depositCollateral(_id, _amount, _strategy, _fromSavingsAccount);\n        emit CollateralDeposited(_id, _amount, _strategy);\n    }\n\n    function _depositCollateral(\n        uint256 _id,\n        uint256 _amount,\n        address _strategy,\n        bool _fromSavingsAccount\n    ) internal {\n        require(creditLineConstants[_id].lender != msg.sender, \'lender cant deposit collateral\');\n        if (_fromSavingsAccount) {\n            _depositCollateralFromSavingsAccount(_id, _amount, msg.sender);\n        } else {\n            address _collateralAsset = creditLineConstants[_id].collateralAsset;\n            ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);\n            if (_collateralAsset == address(0)) {\n                require(msg.value == _amount, "CreditLine::_depositCollateral - value to transfer doesn\'t match argument");\n            } else {\n                IERC20(_collateralAsset).safeTransferFrom(msg.sender, address(this), _amount);\n                IERC20(_collateralAsset).approve(_strategy, _amount);\n            }\n            uint256 _sharesReceived = _savingsAccount.deposit{value: msg.value}(_amount, _collateralAsset, _strategy, address(this));\n            collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(_sharesReceived);\n        }\n    }\n\n    function _withdrawBorrowAmount(\n        address _asset,\n        uint256 _amountInTokens,\n        address _lender\n    ) internal {\n        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();\n        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);\n        uint256 _activeAmount;\n        for (uint256 _index = 0; _index &lt; _strategyList.length; _index++) {\n            if (_strategyList[_index] == address(0)) {\n                continue;\n            }\n            uint256 _liquidityShares = _savingsAccount.balanceInShares(_lender, _asset, _strategyList[_index]);\n            if (_liquidityShares != 0) {\n                uint256 tokenInStrategy = _liquidityShares;\n                tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);\n                uint256 _tokensToTransfer = tokenInStrategy;\n                if (_activeAmount.add(tokenInStrategy) &gt;= _amountInTokens) {\n                    _tokensToTransfer = (_amountInTokens.sub(_activeAmount));\n                }\n                _activeAmount = _activeAmount.add(_tokensToTransfer);\n                _savingsAccount.withdrawFrom(_tokensToTransfer, _asset, _strategyList[_index], _lender, address(this), false);\n                if (_activeAmount == _amountInTokens) {\n                    return;\n                }\n            }\n        }\n        require(_activeAmount == _amountInTokens, \'insufficient balance\');\n    }\n\n    /\n     * @notice used to borrow tokens from credit line by borrower\n     * @dev only borrower can call this function. Amount that can actually be borrowed is \n            min(amount based on borrowLimit, allowance to creditLine contract, balance of lender)\n     * @param _id identifier for the credit line\n     * @param _amount amount of tokens to borrow\n     */\n    function borrow(uint256 _id, uint256 _amount) external payable nonReentrant onlyCreditLineBorrower(_id) {\n        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, \'CreditLine: The credit line is not yet active.\');\n        uint256 _borrowableAmount = calculateBorrowableAmount(_id);\n        require(_amount &lt;= _borrowableAmount, "CreditLine::borrow - The current collateral ratio doesn\'t allow to withdraw the amount");\n        address _borrowAsset = creditLineConstants[_id].borrowAsset;\n        address _lender = creditLineConstants[_id].lender;\n\n        updateinterestAccruedTillLastPrincipalUpdate(_id);\n        creditLineVariables[_id].principal = creditLineVariables[_id].principal.add(_amount);\n        creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;\n\n        uint256 _tokenDiffBalance;\n        if (_borrowAsset != address(0)) {\n            uint256 _balanceBefore = IERC20(_borrowAsset).balanceOf(address(this));\n            _withdrawBorrowAmount(_borrowAsset, _amount, _lender);\n            uint256 _balanceAfter = IERC20(_borrowAsset).balanceOf(address(this));\n            _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);\n        } else {\n            uint256 _balanceBefore = address(this).balance;\n            _withdrawBorrowAmount(_borrowAsset, _amount, _lender);\n            uint256 _balanceAfter = address(this).balance;\n            _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);\n        }\n        uint256 _protocolFee = _tokenDiffBalance.mul(protocolFeeFraction).div(1030);\n        _tokenDiffBalance = _tokenDiffBalance.sub(_protocolFee);\n\n        if (_borrowAsset == address(0)) {\n            (bool feeSuccess, ) = protocolFeeCollector.call{value: _protocolFee}(\'\');\n            require(feeSuccess, \'Transfer fail\');\n            (bool success, ) = msg.sender.call{value: _tokenDiffBalance}(\'\');\n            require(success, \'Transfer fail\');\n        } else {\n            IERC20(_borrowAsset).safeTransfer(protocolFeeCollector, _protocolFee);\n            IERC20(_borrowAsset).safeTransfer(msg.sender, _tokenDiffBalance);\n        }\n        emit BorrowedFromCreditLine(_id, _tokenDiffBalance);\n    }\n\n    function _repayFromSavingsAccount(\n        uint256 _amount,\n        address _asset,\n        address _lender\n    ) internal {\n        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();\n        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);\n        uint256 _activeAmount;\n\n        for (uint256 _index = 0; _index &lt; _strategyList.length; _index++) {\n            if (_strategyList[_index] == address(0)) {\n                continue;\n            }\n            uint256 _liquidityShares = _savingsAccount.balanceInShares(msg.sender, _asset, _strategyList[_index]);\n            if (_liquidityShares == 0) {\n                continue;\n            }\n            uint256 _tokenInStrategy = _liquidityShares;\n            _tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);\n\n            uint256 _tokensToTransfer = _tokenInStrategy;\n            if (_activeAmount.add(_tokenInStrategy) &gt;= _amount) {\n                _tokensToTransfer = (_amount.sub(_activeAmount));\n            }\n            _activeAmount = _activeAmount.add(_tokensToTransfer);\n            _savingsAccount.transferFrom(_tokensToTransfer, _asset, _strategyList[_index], msg.sender, _lender);\n\n            if (_amount == _activeAmount) {\n                return;\n            }\n        }\n        revert(\'CreditLine::_repayFromSavingsAccount - Insufficient balance\');\n    }\n\n    function _repay(\n        uint256 _id,\n        uint256 _amount,\n        bool _fromSavingsAccount,\n        uint256 _principalPaid\n    ) internal {\n        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);\n        address _defaultStrategy = defaultStrategy;\n        address _borrowAsset = creditLineConstants[_id].borrowAsset;\n        address _lender = creditLineConstants[_id].lender;\n        if (!_fromSavingsAccount) {\n            if (_borrowAsset == address(0)) {\n                require(msg.value == _amount, \'creditLine::repay - Ether sent not equal to repay amount\');\n                _savingsAccount.deposit{value: _amount}(_amount, _borrowAsset, _defaultStrategy, _lender);\n            } else {\n                IERC20(_borrowAsset).safeTransferFrom(msg.sender, address(this), _amount);\n                IERC20(_borrowAsset).approve(_defaultStrategy, _amount);\n                _savingsAccount.deposit(_amount, _borrowAsset, _defaultStrategy, _lender);\n            }\n        } else {\n            _repayFromSavingsAccount(_amount, _borrowAsset, _lender);\n        }\n        if (_principalPaid != 0) {\n            _savingsAccount.increaseAllowanceToCreditLine(_principalPaid, _borrowAsset, _lender);\n        }\n    }\n\n    /\n     * @notice used to repay interest and principal to credit line. Interest has to be repaid before repaying principal\n     * @dev partial repayments possible\n     * @param _id identifier for the credit line\n     * @param _amount amount being repaid\n     * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount \n                                otherwise direct from collateral token contract\n     */\n    function repay(\n        uint256 _id,\n        uint256 _amount,\n        bool _fromSavingsAccount\n    ) external payable nonReentrant {\n        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, \'CreditLine: The credit line is not yet active.\');\n        require(creditLineConstants[_id].lender != msg.sender, \'Lender cant repay\');\n\n        uint256 _interestSincePrincipalUpdate = calculateInterestAccrued(_id);\n        uint256 _totalInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(\n            _interestSincePrincipalUpdate\n        );\n        uint256 _interestToPay = _totalInterestAccrued.sub(creditLineVariables[_id].totalInterestRepaid);\n        uint256 _totalCurrentDebt = _interestToPay.add(creditLineVariables[_id].principal);\n        uint256 _principalPaid = 0;\n\n        if (_amount &gt;= _totalCurrentDebt) {\n            _amount = _totalCurrentDebt;\n            emit CompleteCreditLineRepaid(_id, _amount);\n        } else {\n            emit PartialCreditLineRepaid(_id, _amount);\n        }\n\n        if (_amount &gt; _interestToPay) {\n            creditLineVariables[_id].principal = _totalCurrentDebt.sub(_amount);\n            creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _totalInterestAccrued;\n            creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;\n            creditLineVariables[_id].totalInterestRepaid = _totalInterestAccrued;\n            _principalPaid = _amount.sub(_interestToPay);\n        } else {\n            creditLineVariables[_id].totalInterestRepaid = creditLineVariables[_id].totalInterestRepaid.add(_amount);\n        }\n\n        _repay(_id, _amount, _fromSavingsAccount, _principalPaid);\n\n        if (creditLineVariables[_id].principal == 0) {\n            _resetCreditLine(_id);\n        }\n    }\n\n    function _resetCreditLine(uint256 _id) internal {\n        creditLineVariables[_id].lastPrincipalUpdateTime = 0;\n        creditLineVariables[_id].totalInterestRepaid = 0;\n        creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = 0;\n        emit CreditLineReset(_id);\n    }\n\n    /\n     * @dev used to close credit line by borrower or lender\n     * @param _id identifier for the credit line\n     /\n    function close(uint256 _id) external ifCreditLineExists(_id) {\n        require(\n            msg.sender == creditLineConstants[_id].borrower || msg.sender == creditLineConstants[_id].lender,\n            \'CreditLine: Permission denied while closing Line of credit\'\n        );\n        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, \'CreditLine: Credit line should be active.\');\n        require(creditLineVariables[_id].principal == 0, \'CreditLine: Cannot be closed since not repaid.\');\n        require(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate == 0, \'CreditLine: Cannot be closed since not repaid.\');\n        creditLineVariables[_id].status = CreditLineStatus.CLOSED;\n        emit CreditLineClosed(_id);\n    }\n\n    /\n     * @notice used to calculate the current collateral ratio\n     * @dev is a view function for the protocol itself, but isn\'t view because of getTokensForShares which is not view.\n            Interest is also considered while calculating debt\n     * @param _id identifier for the credit line\n     * @return collateral ratio multiplied by 1030 to retain precision\n     /\n    function calculateCurrentCollateralRatio(uint256 _id) public ifCreditLineExists(_id) returns (uint256) {\n        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(\n            creditLineConstants[_id].collateralAsset,\n            creditLineConstants[_id].borrowAsset\n        );\n\n        uint256 currentDebt = calculateCurrentDebt(_id);\n        uint256 currentCollateralRatio = calculateTotalCollateralTokens(_id).mul(_ratioOfPrices).div(currentDebt).mul(1030).div(\n            10_decimals\n        );\n\n        return currentCollateralRatio;\n    }\n\n    /\n     * @notice used to calculate the total collateral tokens\n     * @dev is a view function for the protocol itself, but isn\'t view because of getTokensForShares which is not view\n     * @param _id identifier for the credit line\n     * @return _amount total collateral tokens deposited into the credit line\n     */\n    function calculateTotalCollateralTokens(uint256 _id) public returns (uint256 _amount) {\n        address _collateralAsset = creditLineConstants[_id].collateralAsset;\n        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();\n        uint256 _liquidityShares;\n        for (uint256 index = 0; index &lt; _strategyList.length; index++) {\n            if (_strategyList[index] == address(0)) {\n                continue;\n            }\n            _liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];\n            uint256 _tokenInStrategy = _liquidityShares;\n            _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(_liquidityShares, _collateralAsset);\n\n            _amount = _amount.add(_tokenInStrategy);\n        }\n    }\n\n    /\n     * @notice used to withdraw any excess collateral\n     * @dev collateral can\'t be withdraw if collateralRatio goes below the ideal value. Only borrower can withdraw\n     * @param _id identifier for the credit line\n     * @param _amount amount of collateral to withdraw\n     * @param _toSavingsAccount if true, tokens are transferred from savingsAccount \n                                otherwise direct from collateral token contract\n     /\n    function withdrawCollateral(\n        uint256 _id,\n        uint256 _amount,\n        bool _toSavingsAccount\n    ) external nonReentrant onlyCreditLineBorrower(_id) {\n        uint256 _withdrawableCollateral = withdrawableCollateral(_id);\n        require(_amount &lt;= _withdrawableCollateral, \'Collateral ratio cant go below ideal\');\n        address _collateralAsset = creditLineConstants[_id].collateralAsset;\n        _transferCollateral(_id, _collateralAsset, _amount, _toSavingsAccount);\n        emit CollateralWithdrawn(_id, _amount);\n    }\n\n    /\n     * @notice used to calculate the collateral that can be withdrawn\n     * @dev is a view function for the protocol itself, but isn\'t view because of getTokensForShares which is not view\n     * @param _id identifier for the credit line\n     * @return total collateral withdrawable by borrower\n     /\n    function withdrawableCollateral(uint256 _id) public returns (uint256) {\n        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(\n            creditLineConstants[_id].collateralAsset,\n            creditLineConstants[_id].borrowAsset\n        );\n\n        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);\n        uint256 _currentDebt = calculateCurrentDebt(_id);\n\n        uint256 _collateralNeeded = _currentDebt\n            .mul(creditLineConstants[_id].idealCollateralRatio)\n            .div(_ratioOfPrices)\n            .mul(10_decimals)\n            .div(1030);\n\n        if (_collateralNeeded &gt;= _totalCollateralTokens) {\n            return 0;\n        }\n        return _totalCollateralTokens.sub(_collateralNeeded);\n    }\n\n    function _transferCollateral(\n        uint256 _id,\n        address _asset,\n        uint256 _amountInTokens,\n        bool _toSavingsAccount\n    ) internal {\n        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();\n        uint256 _activeAmount;\n        for (uint256 index = 0; index &lt; _strategyList.length; index++) {\n            uint256 liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];\n            if (liquidityShares == 0 || _strategyList[index] == address(0)) {\n                continue;\n            }\n            uint256 _tokenInStrategy = liquidityShares;\n            _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(liquidityShares, _asset);\n            uint256 _tokensToTransfer = _tokenInStrategy;\n            if (_activeAmount.add(_tokenInStrategy) &gt; _amountInTokens) {\n                _tokensToTransfer = _amountInTokens.sub(_activeAmount);\n                liquidityShares = liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy);\n            }\n            _activeAmount = _activeAmount.add(_tokensToTransfer);\n            collateralShareInStrategy[_id][_strategyList[index]] = collateralShareInStrategy[_id][_strategyList[index]].sub(\n                liquidityShares\n            );\n            if (_toSavingsAccount) {\n                ISavingsAccount(savingsAccount).transfer(_tokensToTransfer, _asset, _strategyList[index], msg.sender);\n            } else {\n                ISavingsAccount(savingsAccount).withdraw(_tokensToTransfer, _asset, _strategyList[index], msg.sender, false);\n            }\n\n            if (_activeAmount == _amountInTokens) {\n                return;\n            }\n        }\n        revert(\'insufficient collateral\');\n    }\n\n    /\n     * @notice used to liquidate credit line in case collateral ratio goes below the threshold\n     * @dev if lender liquidates, then collateral is directly transferred. \n            If autoLiquidation is true, anyone can liquidate by providing enough borrow tokens\n     * @param _id identifier for the credit line\n     * @param _toSavingsAccount if true, tokens are transferred from savingsAccount \n                                otherwise direct from collateral token contract\n     */\n    function liquidate(uint256 _id, bool _toSavingsAccount) external payable nonReentrant {\n        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, \'CreditLine: Credit line should be active.\');\n        require(creditLineVariables[_id].principal != 0, \'CreditLine: cannot liquidate if principal is 0\');\n\n        uint256 currentCollateralRatio = calculateCurrentCollateralRatio(_id);\n        require(\n            currentCollateralRatio &lt; creditLineConstants[_id].idealCollateralRatio,\n            \'CreditLine: Collateral ratio is higher than ideal value\'\n        );\n\n        address _collateralAsset = creditLineConstants[_id].collateralAsset;\n        address _lender = creditLineConstants[_id].lender;\n        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);\n        address _borrowAsset = creditLineConstants[_id].borrowAsset;\n\n        creditLineVariables[_id].status = CreditLineStatus.LIQUIDATED;\n\n        if (creditLineConstants[_id].autoLiquidation &amp;&amp; _lender != msg.sender) {\n            uint256 _borrowTokens = _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens);\n            if (_borrowAsset == address(0)) {\n                uint256 _returnETH = msg.value.sub(_borrowTokens, \'Insufficient ETH to liquidate\');\n                if (_returnETH != 0) {\n                    (bool success, ) = msg.sender.call{value: _returnETH}(\'\');\n                    require(success, \'Transfer fail\');\n                }\n            } else {\n                IERC20(_borrowAsset).safeTransferFrom(msg.sender, _lender, _borrowTokens);\n            }\n        }\n\n        _transferCollateral(_id, _collateralAsset, _totalCollateralTokens, _toSavingsAccount);\n\n        emit CreditLineLiquidated(_id, msg.sender);\n    }\n\n    /\n     * @notice used to calculate the borrow tokens necessary for liquidator to liquidate\n     * @dev is a view function for the protocol itself, but isn\'t view because of getTokensForShares which is not view\n     * @param _id identifier for the credit line\n     * @return borrow tokens necessary for liquidator to liquidate\n     /\n    function borrowTokensToLiquidate(uint256 _id) external returns (uint256) {\n        address _collateralAsset = creditLineConstants[_id].collateralAsset;\n        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);\n        address _borrowAsset = creditLineConstants[_id].borrowAsset;\n\n        return _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens);\n    }\n\n    function _borrowTokensToLiquidate(\n        address _borrowAsset,\n        address _collateralAsset,\n        uint256 _totalCollateralTokens\n    ) internal view returns (uint256) {\n        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(_borrowAsset, _collateralAsset);\n        uint256 _borrowTokens = (\n            _totalCollateralTokens.mul(uint256(1030).sub(liquidatorRewardFraction)).div(1030).mul(_ratioOfPrices).div(10*_decimals)\n        );\n\n        return _borrowTokens;\n    }\n\n    receive() external payable {\n        require(msg.sender == savingsAccount, \'CreditLine::receive invalid transaction\');\n    }\n}\n', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-22-08 11:43:06 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol'; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/utils/ReentrancyGuard.sol'; import '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol'; import '../interfaces/IPriceOracle.sol'; import '../interfaces/IYield.sol'; import '../interfaces/ISavingsAccount.sol'; import '../SavingsAccount/SavingsAccountUtil.sol'; import '../interfaces/IStrategyRegistry.sol'; /  * @title Credit Line contract with Methods related to credit Line  * @notice Implements the functions related to Credit Line  * @author Sublime  / contract CreditLine is ReentrancyGuard, OwnableUpgradeable {     using SafeERC20 for IERC20;     using SafeMath for uint256; enum CreditLineStatus {     NOT_CREATED,     REQUESTED,     ACTIVE,     CLOSED,     CANCELLED,     LIQUIDATED }  /**  * @notice counter that tracks the number of credit lines created  * @dev used to create unique identifier for credit lines  **/ uint256 public creditLineCounter;  uint256 constant YEAR_IN_SECONDS = 365 days;  struct CreditLineVariables {     CreditLineStatus status;     uint256 principal;     uint256 totalInterestRepaid;     uint256 lastPrincipalUpdateTime;     uint256 interestAccruedTillLastPrincipalUpdate; }  struct CreditLineConstants {     address lender;     address borrower;     uint256 borrowLimit;     uint256 idealCollateralRatio;     uint256 borrowRate;     address borrowAsset;     address collateralAsset;     bool autoLiquidation;     bool requestByLender; } /**  * @notice stores the collateral shares in a credit line per strategy  * @dev creditLineId =&gt; Strategy =&gt; collateralShares  **/ mapping(uint256 =&gt; mapping(address =&gt; uint256)) public collateralShareInStrategy;  /**  * @notice stores the variables to maintain a credit line  **/ mapping(uint256 =&gt; CreditLineVariables) public creditLineVariables;  /**  * @notice stores the constants related to a credit line  **/ mapping(uint256 =&gt; CreditLineConstants) public creditLineConstants;  /**  * @notice stores the address of savings account contract  **/ address public savingsAccount;  /**  * @notice stores the address of price oracle contract  **/ address public priceOracle;  /**  * @notice stores the address of strategy registry contract  **/ address public strategyRegistry;  /**  * @notice stores the address of default strategy  **/ address public defaultStrategy;  /**  * @notice stores the fraction of borrowed amount charged as fee by protocol  * @dev it is multiplied by 10**30  **/ uint256 public protocolFeeFraction;  /**  * @notice address where protocol fee is collected  **/ address public protocolFeeCollector;  /**  * @notice stores the fraction of amount liquidated given as reward to liquidator  * @dev it is multiplied by 10**30  **/ uint256 public liquidatorRewardFraction; /**  * @dev checks if Credit Line exists  * @param _id identifier for the credit line  **/ modifier ifCreditLineExists(uint256 _id) {     require(creditLineVariables[_id].status != CreditLineStatus.NOT_CREATED, 'Credit line does not exist');     _; }  /**  * @dev checks if called by credit Line Borrower  * @param _id creditLine identifier  **/ modifier onlyCreditLineBorrower(uint256 _id) {     require(creditLineConstants[_id].borrower == msg.sender, 'Only credit line Borrower can access');     _; }  /**  * @dev checks if called by credit Line Lender  * @param _id creditLine identifier  **/ modifier onlyCreditLineLender(uint256 _id) {     require(creditLineConstants[_id].lender == msg.sender, 'Only credit line Lender can access');     _; }  /**  * @notice emitted when a collateral is deposited into credit line  * @param id id of the credit line  * @param amount amount of collateral deposited  * @param strategy address of the strategy into which collateral is deposited  */ event CollateralDeposited(uint256 indexed id, uint256 amount, address indexed strategy);  /**  * @notice emitted when collateral is withdrawn from credit line  * @param id id of the credit line  * @param amount amount of collateral withdrawn  */ event CollateralWithdrawn(uint256 indexed id, uint256 amount);  /**  * @notice emitted when a request for new credit line is placed  * @param id id of the credit line for which request was made  * @param lender address of the lender for credit line  * @param borrower address of the borrower for credit line  */ event CreditLineRequested(uint256 indexed id, address indexed lender, address indexed borrower);  /**  * @notice emitted when a credit line is liquidated  * @param id id of the credit line which is liquidated  * @param liquidator address of the liquidator  */ event CreditLineLiquidated(uint256 indexed id, address indexed liquidator);  /**  * @notice emitted when tokens are borrowed from credit line  * @param id id of the credit line from which tokens are borrowed  * @param borrowAmount amount of tokens borrowed  */ event BorrowedFromCreditLine(uint256 indexed id, uint256 borrowAmount);  /**  * @notice emitted when credit line is accepted  * @param id id of the credit line that was accepted  */ event CreditLineAccepted(uint256 indexed id);  /**  * @notice emitted when credit line is completely repaid and reset  * @param id id of the credit line that is reset  */ event CreditLineReset(uint256 indexed id);  /**  * @notice emitted when the credit line is partially repaid  * @param id id of the credit line  * @param repayAmount amount repaid  */ event PartialCreditLineRepaid(uint256 indexed id, uint256 repayAmount);  /**  * @notice emitted when the credit line is completely repaid  * @param id id of the credit line  * @param repayAmount amount repaid  */ event CompleteCreditLineRepaid(uint256 indexed id, uint256 repayAmount);  /**  * @notice emitted when the credit line is closed by one of the parties of credit line  * @param id id of the credit line  */ event CreditLineClosed(uint256 indexed id);  /**  * @notice emitted when default strategy for the credit line is updated  * @param defaultStrategy address of the strategy contract that is used as default by credit lines  */ event DefaultStrategyUpdated(address indexed defaultStrategy);  /**  * @notice emitted when the price oracle is updated  * @param priceOracle address of the updated price oracle  */ event PriceOracleUpdated(address indexed priceOracle);  /**  * @notice emitted when the savings account address is updated  * @param savingsAccount address of the updated savingsAccount  */ event SavingsAccountUpdated(address indexed savingsAccount);  /**  * @notice emitted when strategy registry address is updated  * @param strategyRegistry address of the updated strategy registry  */ event StrategyRegistryUpdated(address indexed strategyRegistry);  /**  * @notice emitted when fee that protocol charges for credit line is updated  * @param updatedProtocolFee updated value of protocolFeeFraction  */ event ProtocolFeeFractionUpdated(uint256 updatedProtocolFee);  /**  * @notice emitted when address which receives fee that protocol changes for pools is updated  * @param updatedProtocolFeeCollector updated value of protocolFeeCollector  */ event ProtocolFeeCollectorUpdated(address indexed updatedProtocolFeeCollector);  /**  * @notice emitted when liquidatorRewardFraction is updated  * @param liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator  */ event LiquidationRewardFractionUpdated(uint256 liquidatorRewardFraction);  /**  * @notice used to initialize the contract  * @dev can only be called once during the life cycle of the contract  * @param _defaultStrategy default strategy used in credit lines  * @param _priceOracle address of the priceOracle  * @param _savingsAccount address of  the savings account contract  * @param _strategyRegistry address of the strategy registry contract  * @param _owner address of owner who can change global variables  * @param _protocolFeeFraction fraction of the fee charged by protocol  * @param _protocolFeeCollector address to which protocol fee is charged to  * @param _liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator  */ function initialize(     address _defaultStrategy,     address _priceOracle,     address _savingsAccount,     address _strategyRegistry,     address _owner,     uint256 _protocolFeeFraction,     address _protocolFeeCollector,     uint256 _liquidatorRewardFraction ) external initializer {     OwnableUpgradeable.__Ownable_init();     OwnableUpgradeable.transferOwnership(_owner);      _updateDefaultStrategy(_defaultStrategy);     _updatePriceOracle(_priceOracle);     _updateSavingsAccount(_savingsAccount);     _updateStrategyRegistry(_strategyRegistry);     _updateProtocolFeeFraction(_protocolFeeFraction);     _updateProtocolFeeCollector(_protocolFeeCollector);     _updateLiquidatorRewardFraction(_liquidatorRewardFraction); }  /**  * @notice used to update the default strategy  * @dev can only be updated by owner  * @param _defaultStrategy address of the updated default strategy  */ function updateDefaultStrategy(address _defaultStrategy) external onlyOwner {     _updateDefaultStrategy(_defaultStrategy); }  function _updateDefaultStrategy(address _defaultStrategy) internal {     defaultStrategy = _defaultStrategy;     emit DefaultStrategyUpdated(_defaultStrategy); }  /**  * @notice used to update the price oracle  * @dev can only be updated by owner  * @param _priceOracle address of the updated price oracle  */ function updatePriceOracle(address _priceOracle) external onlyOwner {     _updatePriceOracle(_priceOracle); }  function _updatePriceOracle(address _priceOracle) internal {     priceOracle = _priceOracle;     emit PriceOracleUpdated(_priceOracle); }  /**  * @notice used to update the savings account address  * @dev can only be updated by owner  * @param _savingsAccount address of the updated savings account  */ function updateSavingsAccount(address _savingsAccount) external onlyOwner {     _updateSavingsAccount(_savingsAccount); }  function _updateSavingsAccount(address _savingsAccount) internal {     savingsAccount = _savingsAccount;     emit SavingsAccountUpdated(_savingsAccount); }  /**  * @notice used to update the protocol fee fraction  * @dev can only be updated by owner  * @param _protocolFee fraction of the borrower amount collected as protocol fee  */ function updateProtocolFeeFraction(uint256 _protocolFee) external onlyOwner {     _updateProtocolFeeFraction(_protocolFee); }  function _updateProtocolFeeFraction(uint256 _protocolFee) internal {     protocolFeeFraction = _protocolFee;     emit ProtocolFeeFractionUpdated(_protocolFee); }  /**  * @notice used to update the protocol fee collector  * @dev can only be updated by owner  * @param _protocolFeeCollector address in which protocol fee is collected  */ function updateProtocolFeeCollector(address _protocolFeeCollector) external onlyOwner {     _updateProtocolFeeCollector(_protocolFeeCollector); }  function _updateProtocolFeeCollector(address _protocolFeeCollector) internal {     require(_protocolFeeCollector != address(0), 'cant be 0 address');     protocolFeeCollector = _protocolFeeCollector;     emit ProtocolFeeCollectorUpdated(_protocolFeeCollector); }  /**  * @notice used to update the strategy registry address  * @dev can only be updated by owner  * @param _strategyRegistry address of the updated strategy registry  */ function updateStrategyRegistry(address _strategyRegistry) external onlyOwner {     _updateStrategyRegistry(_strategyRegistry); }  function _updateStrategyRegistry(address _strategyRegistry) internal {     require(_strategyRegistry != address(0), 'CL::I zero address');     strategyRegistry = _strategyRegistry;     emit StrategyRegistryUpdated(_strategyRegistry); }  /**  * @notice used to update the liquidatorRewardFraction  * @dev can only be updated by owner  * @param _rewardFraction fraction of liquidated amount given to liquidator as reward  */ function updateLiquidatorRewardFraction(uint256 _rewardFraction) external onlyOwner {     _updateLiquidatorRewardFraction(_rewardFraction); }  function _updateLiquidatorRewardFraction(uint256 _rewardFraction) internal {     require(_rewardFraction &lt;= 10**30, 'Fraction has to be less than 1');     liquidatorRewardFraction = _rewardFraction;     emit LiquidationRewardFractionUpdated(_rewardFraction); }  /**  * @dev Used to Calculate Interest Per second on given principal and Interest rate  * @param _principal principal Amount for which interest has to be calculated.  * @param _borrowRate It is the Interest Rate at which Credit Line is approved  * @return interest per second for the given parameters  */ function calculateInterest(     uint256 _principal,     uint256 _borrowRate,     uint256 _timeElapsed ) public pure returns (uint256) {     uint256 _interest = _principal.mul(_borrowRate).mul(_timeElapsed).div(10**30).div(YEAR_IN_SECONDS);      return _interest; }  /**  * @dev Used to calculate interest accrued since last repayment  * @param _id identifier for the credit line  * @return interest accrued over current borrowed amount since last repayment  */  function calculateInterestAccrued(uint256 _id) public view returns (uint256) {     uint256 _lastPrincipalUpdateTime = creditLineVariables[_id].lastPrincipalUpdateTime;     if (_lastPrincipalUpdateTime == 0) return 0;     uint256 _timeElapsed = (block.timestamp).sub(_lastPrincipalUpdateTime);     uint256 _interestAccrued = calculateInterest(creditLineVariables[_id].principal, creditLineConstants[_id].borrowRate, _timeElapsed);     return _interestAccrued; }  /**  * @dev Used to calculate current debt of borrower against a credit line.  * @param _id identifier for the credit line  * @return current debt of borrower  */ function calculateCurrentDebt(uint256 _id) public view returns (uint256) {     uint256 _interestAccrued = calculateInterestAccrued(_id);     uint256 _currentDebt = (creditLineVariables[_id].principal)         .add(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate)         .add(_interestAccrued)         .sub(creditLineVariables[_id].totalInterestRepaid);     return _currentDebt; }  /**  * @notice used to calculate amount that can be borrowed by the borrower  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view.         borrowableAmount changes per block as interest changes per block.  * @param _id identifier for the credit line  * @return amount that can be borrowed from the credit line  */ function calculateBorrowableAmount(uint256 _id) public returns (uint256) {     CreditLineStatus _status = creditLineVariables[_id].status;     require(         _status == CreditLineStatus.ACTIVE || _status == CreditLineStatus.REQUESTED,         'CreditLine: Cannot only if credit line ACTIVE or REQUESTED'     );     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(         creditLineConstants[_id].collateralAsset,         creditLineConstants[_id].borrowAsset     );      uint256 _totalCollateralToken = calculateTotalCollateralTokens(_id);      uint256 _currentDebt = calculateCurrentDebt(_id);      uint256 _maxPossible = _totalCollateralToken.mul(_ratioOfPrices).div(creditLineConstants[_id].idealCollateralRatio).mul(10**30).div(         10**_decimals     );      uint256 _borrowLimit = creditLineConstants[_id].borrowLimit;      if (_maxPossible &gt; _borrowLimit) {         _maxPossible = _borrowLimit;     }     if (_maxPossible &gt; _currentDebt) {         return _maxPossible.sub(_currentDebt);     }     return 0; }  function updateinterestAccruedTillLastPrincipalUpdate(uint256 _id) internal {     require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');      uint256 _interestAccrued = calculateInterestAccrued(_id);     uint256 _newInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(_interestAccrued);     creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _newInterestAccrued; }  function _depositCollateralFromSavingsAccount(     uint256 _id,     uint256 _amount,     address _sender ) internal {     address _collateralAsset = creditLineConstants[_id].collateralAsset;     address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();     ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);     uint256 _activeAmount;      for (uint256 _index = 0; _index &lt; _strategyList.length; _index++) {         address _strategy = _strategyList[_index];         uint256 _liquidityShares = _savingsAccount.balanceInShares(_sender, _collateralAsset, _strategy);         if (_liquidityShares == 0 || _strategyList[_index] == address(0)) {             continue;         }         uint256 _tokenInStrategy = _liquidityShares;         _tokenInStrategy = IYield(_strategy).getTokensForShares(_liquidityShares, _collateralAsset);          uint256 _tokensToTransfer = _tokenInStrategy;         if (_activeAmount.add(_tokenInStrategy) &gt;= _amount) {             _tokensToTransfer = (_amount.sub(_activeAmount));         }         _activeAmount = _activeAmount.add(_tokensToTransfer);         _savingsAccount.transferFrom(_tokensToTransfer, _collateralAsset, _strategy, _sender, address(this));          collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(             _liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy)         );          if (_amount == _activeAmount) {             return;         }     }     revert('CreditLine::_depositCollateralFromSavingsAccount - Insufficient balance'); }  /**  * @notice used to request a credit line either by borrower or lender  * @param _requestTo Address to which creditLine is requested,                      if borrower creates request then lender address and                      if lender creates then borrower address  * @param _borrowLimit maximum borrow amount in a credit line  * @param _borrowRate Interest Rate at which credit Line is requested  * @param _autoLiquidation if true, anyone can liquidate loan, otherwise only lender  * @param _collateralRatio ratio of the collateral to the debt below which credit line can be liquidated  * @param _borrowAsset address of the token to be borrowed  * @param _collateralAsset address of the token provided as collateral  * @param _requestAsLender if true, lender is placing request, otherwise borrower  * @return identifier for the credit line  */  function request(     address _requestTo,     uint256 _borrowLimit,     uint256 _borrowRate,     bool _autoLiquidation,     uint256 _collateralRatio,     address _borrowAsset,     address _collateralAsset,     bool _requestAsLender ) external returns (uint256) {     require(_borrowAsset != _collateralAsset, 'R: cant borrow lent token');     require(IPriceOracle(priceOracle).doesFeedExist(_borrowAsset, _collateralAsset), 'R: No price feed');      address _lender = _requestTo;     address _borrower = msg.sender;     if (_requestAsLender) {         _lender = msg.sender;         _borrower = _requestTo;     }      uint256 _id = _createRequest(         _lender,         _borrower,         _borrowLimit,         _borrowRate,         _autoLiquidation,         _collateralRatio,         _borrowAsset,         _collateralAsset,         _requestAsLender     );      emit CreditLineRequested(_id, _lender, _borrower);     return _id; }  function _createRequest(     address _lender,     address _borrower,     uint256 _borrowLimit,     uint256 _borrowRate,     bool _autoLiquidation,     uint256 _collateralRatio,     address _borrowAsset,     address _collateralAsset,     bool _requestByLender ) internal returns (uint256) {     require(_lender != _borrower, 'Lender and Borrower cannot be same addresses');     uint256 _id = creditLineCounter + 1;     creditLineCounter = _id;     creditLineVariables[_id].status = CreditLineStatus.REQUESTED;     creditLineConstants[_id].borrower = _borrower;     creditLineConstants[_id].lender = _lender;     creditLineConstants[_id].borrowLimit = _borrowLimit;     creditLineConstants[_id].autoLiquidation = _autoLiquidation;     creditLineConstants[_id].idealCollateralRatio = _collateralRatio;     creditLineConstants[_id].borrowRate = _borrowRate;     creditLineConstants[_id].borrowAsset = _borrowAsset;     creditLineConstants[_id].collateralAsset = _collateralAsset;     creditLineConstants[_id].requestByLender = _requestByLender;     return _id; }  /**  * @notice used to accept a credit line  * @dev if borrower places request, lender can accept and vice versa  * @param _id identifier for the credit line  */ function accept(uint256 _id) external {     require(         creditLineVariables[_id].status == CreditLineStatus.REQUESTED,         'CreditLine::acceptCreditLineLender - CreditLine is already accepted'     );     bool _requestByLender = creditLineConstants[_id].requestByLender;     require(         (msg.sender == creditLineConstants[_id].borrower &amp;&amp; _requestByLender) ||             (msg.sender == creditLineConstants[_id].lender &amp;&amp; !_requestByLender),         "Only Borrower or Lender who hasn't requested can accept"     );     creditLineVariables[_id].status = CreditLineStatus.ACTIVE;     emit CreditLineAccepted(_id); }  /**  * @notice used to deposit collateral into the credit line  * @dev collateral tokens have to be approved in savingsAccount or token contract(unless ether).         If transferred from savings account, the tokens are transferred from strategies in the          order prespecified in strategy registry  * @param _id identifier for the credit line  * @param _amount amount of collateral being deposited  * @param _strategy strategy to which collateral is to be deposited in case transfer is not from savings account  * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount                              otherwise direct from collateral token contract  */ function depositCollateral(     uint256 _id,     uint256 _amount,     address _strategy,     bool _fromSavingsAccount ) external payable nonReentrant ifCreditLineExists(_id) {     require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine not active');     _depositCollateral(_id, _amount, _strategy, _fromSavingsAccount);     emit CollateralDeposited(_id, _amount, _strategy); }  function _depositCollateral(     uint256 _id,     uint256 _amount,     address _strategy,     bool _fromSavingsAccount ) internal {     require(creditLineConstants[_id].lender != msg.sender, 'lender cant deposit collateral');     if (_fromSavingsAccount) {         _depositCollateralFromSavingsAccount(_id, _amount, msg.sender);     } else {         address _collateralAsset = creditLineConstants[_id].collateralAsset;         ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);         if (_collateralAsset == address(0)) {             require(msg.value == _amount, "CreditLine::_depositCollateral - value to transfer doesn't match argument");         } else {             IERC20(_collateralAsset).safeTransferFrom(msg.sender, address(this), _amount);             IERC20(_collateralAsset).approve(_strategy, _amount);         }         uint256 _sharesReceived = _savingsAccount.deposit{value: msg.value}(_amount, _collateralAsset, _strategy, address(this));         collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(_sharesReceived);     } }  function _withdrawBorrowAmount(     address _asset,     uint256 _amountInTokens,     address _lender ) internal {     address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();     ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);     uint256 _activeAmount;     for (uint256 _index = 0; _index &lt; _strategyList.length; _index++) {         if (_strategyList[_index] == address(0)) {             continue;         }         uint256 _liquidityShares = _savingsAccount.balanceInShares(_lender, _asset, _strategyList[_index]);         if (_liquidityShares != 0) {             uint256 tokenInStrategy = _liquidityShares;             tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);             uint256 _tokensToTransfer = tokenInStrategy;             if (_activeAmount.add(tokenInStrategy) &gt;= _amountInTokens) {                 _tokensToTransfer = (_amountInTokens.sub(_activeAmount));             }             _activeAmount = _activeAmount.add(_tokensToTransfer);             _savingsAccount.withdrawFrom(_tokensToTransfer, _asset, _strategyList[_index], _lender, address(this), false);             if (_activeAmount == _amountInTokens) {                 return;             }         }     }     require(_activeAmount == _amountInTokens, 'insufficient balance'); }  /**  * @notice used to borrow tokens from credit line by borrower  * @dev only borrower can call this function. Amount that can actually be borrowed is          min(amount based on borrowLimit, allowance to creditLine contract, balance of lender)  * @param _id identifier for the credit line  * @param _amount amount of tokens to borrow  */ function borrow(uint256 _id, uint256 _amount) external payable nonReentrant onlyCreditLineBorrower(_id) {     require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');     uint256 _borrowableAmount = calculateBorrowableAmount(_id);     require(_amount &lt;= _borrowableAmount, "CreditLine::borrow - The current collateral ratio doesn't allow to withdraw the amount");     address _borrowAsset = creditLineConstants[_id].borrowAsset;     address _lender = creditLineConstants[_id].lender;      updateinterestAccruedTillLastPrincipalUpdate(_id);     creditLineVariables[_id].principal = creditLineVariables[_id].principal.add(_amount);     creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;      uint256 _tokenDiffBalance;     if (_borrowAsset != address(0)) {         uint256 _balanceBefore = IERC20(_borrowAsset).balanceOf(address(this));         _withdrawBorrowAmount(_borrowAsset, _amount, _lender);         uint256 _balanceAfter = IERC20(_borrowAsset).balanceOf(address(this));         _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);     } else {         uint256 _balanceBefore = address(this).balance;         _withdrawBorrowAmount(_borrowAsset, _amount, _lender);         uint256 _balanceAfter = address(this).balance;         _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);     }     uint256 _protocolFee = _tokenDiffBalance.mul(protocolFeeFraction).div(10**30);     _tokenDiffBalance = _tokenDiffBalance.sub(_protocolFee);      if (_borrowAsset == address(0)) {         (bool feeSuccess, ) = protocolFeeCollector.call{value: _protocolFee}('');         require(feeSuccess, 'Transfer fail');         (bool success, ) = msg.sender.call{value: _tokenDiffBalance}('');         require(success, 'Transfer fail');     } else {         IERC20(_borrowAsset).safeTransfer(protocolFeeCollector, _protocolFee);         IERC20(_borrowAsset).safeTransfer(msg.sender, _tokenDiffBalance);     }     emit BorrowedFromCreditLine(_id, _tokenDiffBalance); }  function _repayFromSavingsAccount(     uint256 _amount,     address _asset,     address _lender ) internal {     address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();     ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);     uint256 _activeAmount;      for (uint256 _index = 0; _index &lt; _strategyList.length; _index++) {         if (_strategyList[_index] == address(0)) {             continue;         }         uint256 _liquidityShares = _savingsAccount.balanceInShares(msg.sender, _asset, _strategyList[_index]);         if (_liquidityShares == 0) {             continue;         }         uint256 _tokenInStrategy = _liquidityShares;         _tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);          uint256 _tokensToTransfer = _tokenInStrategy;         if (_activeAmount.add(_tokenInStrategy) &gt;= _amount) {             _tokensToTransfer = (_amount.sub(_activeAmount));         }         _activeAmount = _activeAmount.add(_tokensToTransfer);         _savingsAccount.transferFrom(_tokensToTransfer, _asset, _strategyList[_index], msg.sender, _lender);          if (_amount == _activeAmount) {             return;         }     }     revert('CreditLine::_repayFromSavingsAccount - Insufficient balance'); }  function _repay(     uint256 _id,     uint256 _amount,     bool _fromSavingsAccount,     uint256 _principalPaid ) internal {     ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);     address _defaultStrategy = defaultStrategy;     address _borrowAsset = creditLineConstants[_id].borrowAsset;     address _lender = creditLineConstants[_id].lender;     if (!_fromSavingsAccount) {         if (_borrowAsset == address(0)) {             require(msg.value == _amount, 'creditLine::repay - Ether sent not equal to repay amount');             _savingsAccount.deposit{value: _amount}(_amount, _borrowAsset, _defaultStrategy, _lender);         } else {             IERC20(_borrowAsset).safeTransferFrom(msg.sender, address(this), _amount);             IERC20(_borrowAsset).approve(_defaultStrategy, _amount);             _savingsAccount.deposit(_amount, _borrowAsset, _defaultStrategy, _lender);         }     } else {         _repayFromSavingsAccount(_amount, _borrowAsset, _lender);     }     if (_principalPaid != 0) {         _savingsAccount.increaseAllowanceToCreditLine(_principalPaid, _borrowAsset, _lender);     } }  /**  * @notice used to repay interest and principal to credit line. Interest has to be repaid before repaying principal  * @dev partial repayments possible  * @param _id identifier for the credit line  * @param _amount amount being repaid  * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount                              otherwise direct from collateral token contract  */ function repay(     uint256 _id,     uint256 _amount,     bool _fromSavingsAccount ) external payable nonReentrant {     require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');     require(creditLineConstants[_id].lender != msg.sender, 'Lender cant repay');      uint256 _interestSincePrincipalUpdate = calculateInterestAccrued(_id);     uint256 _totalInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(         _interestSincePrincipalUpdate     );     uint256 _interestToPay = _totalInterestAccrued.sub(creditLineVariables[_id].totalInterestRepaid);     uint256 _totalCurrentDebt = _interestToPay.add(creditLineVariables[_id].principal);     uint256 _principalPaid = 0;      if (_amount &gt;= _totalCurrentDebt) {         _amount = _totalCurrentDebt;         emit CompleteCreditLineRepaid(_id, _amount);     } else {         emit PartialCreditLineRepaid(_id, _amount);     }      if (_amount &gt; _interestToPay) {         creditLineVariables[_id].principal = _totalCurrentDebt.sub(_amount);         creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _totalInterestAccrued;         creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;         creditLineVariables[_id].totalInterestRepaid = _totalInterestAccrued;         _principalPaid = _amount.sub(_interestToPay);     } else {         creditLineVariables[_id].totalInterestRepaid = creditLineVariables[_id].totalInterestRepaid.add(_amount);     }      _repay(_id, _amount, _fromSavingsAccount, _principalPaid);      if (creditLineVariables[_id].principal == 0) {         _resetCreditLine(_id);     } }  function _resetCreditLine(uint256 _id) internal {     creditLineVariables[_id].lastPrincipalUpdateTime = 0;     creditLineVariables[_id].totalInterestRepaid = 0;     creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = 0;     emit CreditLineReset(_id); }  /**  * @dev used to close credit line by borrower or lender  * @param _id identifier for the credit line  */ function close(uint256 _id) external ifCreditLineExists(_id) {     require(         msg.sender == creditLineConstants[_id].borrower || msg.sender == creditLineConstants[_id].lender,         'CreditLine: Permission denied while closing Line of credit'     );     require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: Credit line should be active.');     require(creditLineVariables[_id].principal == 0, 'CreditLine: Cannot be closed since not repaid.');     require(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate == 0, 'CreditLine: Cannot be closed since not repaid.');     creditLineVariables[_id].status = CreditLineStatus.CLOSED;     emit CreditLineClosed(_id); }  /**  * @notice used to calculate the current collateral ratio  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view.         Interest is also considered while calculating debt  * @param _id identifier for the credit line  * @return collateral ratio multiplied by 10**30 to retain precision  */ function calculateCurrentCollateralRatio(uint256 _id) public ifCreditLineExists(_id) returns (uint256) {     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(         creditLineConstants[_id].collateralAsset,         creditLineConstants[_id].borrowAsset     );      uint256 currentDebt = calculateCurrentDebt(_id);     uint256 currentCollateralRatio = calculateTotalCollateralTokens(_id).mul(_ratioOfPrices).div(currentDebt).mul(10**30).div(         10**_decimals     );      return currentCollateralRatio; }  /**  * @notice used to calculate the total collateral tokens  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view  * @param _id identifier for the credit line  * @return _amount total collateral tokens deposited into the credit line  */ function calculateTotalCollateralTokens(uint256 _id) public returns (uint256 _amount) {     address _collateralAsset = creditLineConstants[_id].collateralAsset;     address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();     uint256 _liquidityShares;     for (uint256 index = 0; index &lt; _strategyList.length; index++) {         if (_strategyList[index] == address(0)) {             continue;         }         _liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];         uint256 _tokenInStrategy = _liquidityShares;         _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(_liquidityShares, _collateralAsset);          _amount = _amount.add(_tokenInStrategy);     } }  /**  * @notice used to withdraw any excess collateral  * @dev collateral can't be withdraw if collateralRatio goes below the ideal value. Only borrower can withdraw  * @param _id identifier for the credit line  * @param _amount amount of collateral to withdraw  * @param _toSavingsAccount if true, tokens are transferred from savingsAccount                              otherwise direct from collateral token contract  */ function withdrawCollateral(     uint256 _id,     uint256 _amount,     bool _toSavingsAccount ) external nonReentrant onlyCreditLineBorrower(_id) {     uint256 _withdrawableCollateral = withdrawableCollateral(_id);     require(_amount &lt;= _withdrawableCollateral, 'Collateral ratio cant go below ideal');     address _collateralAsset = creditLineConstants[_id].collateralAsset;     _transferCollateral(_id, _collateralAsset, _amount, _toSavingsAccount);     emit CollateralWithdrawn(_id, _amount); }  /**  * @notice used to calculate the collateral that can be withdrawn  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view  * @param _id identifier for the credit line  * @return total collateral withdrawable by borrower  */ function withdrawableCollateral(uint256 _id) public returns (uint256) {     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(         creditLineConstants[_id].collateralAsset,         creditLineConstants[_id].borrowAsset     );      uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);     uint256 _currentDebt = calculateCurrentDebt(_id);      uint256 _collateralNeeded = _currentDebt         .mul(creditLineConstants[_id].idealCollateralRatio)         .div(_ratioOfPrices)         .mul(10**_decimals)         .div(10**30);      if (_collateralNeeded &gt;= _totalCollateralTokens) {         return 0;     }     return _totalCollateralTokens.sub(_collateralNeeded); }  function _transferCollateral(     uint256 _id,     address _asset,     uint256 _amountInTokens,     bool _toSavingsAccount ) internal {     address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();     uint256 _activeAmount;     for (uint256 index = 0; index &lt; _strategyList.length; index++) {         uint256 liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];         if (liquidityShares == 0 || _strategyList[index] == address(0)) {             continue;         }         uint256 _tokenInStrategy = liquidityShares;         _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(liquidityShares, _asset);         uint256 _tokensToTransfer = _tokenInStrategy;         if (_activeAmount.add(_tokenInStrategy) &gt; _amountInTokens) {             _tokensToTransfer = _amountInTokens.sub(_activeAmount);             liquidityShares = liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy);         }         _activeAmount = _activeAmount.add(_tokensToTransfer);         collateralShareInStrategy[_id][_strategyList[index]] = collateralShareInStrategy[_id][_strategyList[index]].sub(             liquidityShares         );         if (_toSavingsAccount) {             ISavingsAccount(savingsAccount).transfer(_tokensToTransfer, _asset, _strategyList[index], msg.sender);         } else {             ISavingsAccount(savingsAccount).withdraw(_tokensToTransfer, _asset, _strategyList[index], msg.sender, false);         }          if (_activeAmount == _amountInTokens) {             return;         }     }     revert('insufficient collateral'); }  /**  * @notice used to liquidate credit line in case collateral ratio goes below the threshold  * @dev if lender liquidates, then collateral is directly transferred.          If autoLiquidation is true, anyone can liquidate by providing enough borrow tokens  * @param _id identifier for the credit line  * @param _toSavingsAccount if true, tokens are transferred from savingsAccount                              otherwise direct from collateral token contract  */ function liquidate(uint256 _id, bool _toSavingsAccount) external payable nonReentrant {     require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: Credit line should be active.');     require(creditLineVariables[_id].principal != 0, 'CreditLine: cannot liquidate if principal is 0');      uint256 currentCollateralRatio = calculateCurrentCollateralRatio(_id);     require(         currentCollateralRatio &lt; creditLineConstants[_id].idealCollateralRatio,         'CreditLine: Collateral ratio is higher than ideal value'     );      address _collateralAsset = creditLineConstants[_id].collateralAsset;     address _lender = creditLineConstants[_id].lender;     uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);     address _borrowAsset = creditLineConstants[_id].borrowAsset;      creditLineVariables[_id].status = CreditLineStatus.LIQUIDATED;      if (creditLineConstants[_id].autoLiquidation &amp;&amp; _lender != msg.sender) {         uint256 _borrowTokens = _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens);         if (_borrowAsset == address(0)) {             uint256 _returnETH = msg.value.sub(_borrowTokens, 'Insufficient ETH to liquidate');             if (_returnETH != 0) {                 (bool success, ) = msg.sender.call{value: _returnETH}('');                 require(success, 'Transfer fail');             }         } else {             IERC20(_borrowAsset).safeTransferFrom(msg.sender, _lender, _borrowTokens);         }     }      _transferCollateral(_id, _collateralAsset, _totalCollateralTokens, _toSavingsAccount);      emit CreditLineLiquidated(_id, msg.sender); }  /**  * @notice used to calculate the borrow tokens necessary for liquidator to liquidate  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view  * @param _id identifier for the credit line  * @return borrow tokens necessary for liquidator to liquidate  */ function borrowTokensToLiquidate(uint256 _id) external returns (uint256) {     address _collateralAsset = creditLineConstants[_id].collateralAsset;     uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);     address _borrowAsset = creditLineConstants[_id].borrowAsset;      return _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens); }  function _borrowTokensToLiquidate(     address _borrowAsset,     address _collateralAsset,     uint256 _totalCollateralTokens ) internal view returns (uint256) {     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(_borrowAsset, _collateralAsset);     uint256 _borrowTokens = (         _totalCollateralTokens.mul(uint256(10**30).sub(liquidatorRewardFraction)).div(10**30).mul(_ratioOfPrices).div(10**_decimals)     );      return _borrowTokens; }  receive() external payable {     require(msg.sender == savingsAccount, 'CreditLine::receive invalid transaction'); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-22-08 11:43:06 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/utils/ReentrancyGuard.sol';
import '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';
import '../interfaces/IPriceOracle.sol';
import '../interfaces/IYield.sol';
import '../interfaces/ISavingsAccount.sol';
import '../SavingsAccount/SavingsAccountUtil.sol';
import '../interfaces/IStrategyRegistry.sol';

/**
 * @title Credit Line contract with Methods related to credit Line
 * @notice Implements the functions related to Credit Line
 * @author Sublime
 **/

contract CreditLine is ReentrancyGuard, OwnableUpgradeable {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    enum CreditLineStatus {
        NOT_CREATED,
        REQUESTED,
        ACTIVE,
        CLOSED,
        CANCELLED,
        LIQUIDATED
    }

    /**
     * @notice counter that tracks the number of credit lines created
     * @dev used to create unique identifier for credit lines
     **/
    uint256 public creditLineCounter;

    uint256 constant YEAR_IN_SECONDS = 365 days;

    struct CreditLineVariables {
        CreditLineStatus status;
        uint256 principal;
        uint256 totalInterestRepaid;
        uint256 lastPrincipalUpdateTime;
        uint256 interestAccruedTillLastPrincipalUpdate;
    }

    struct CreditLineConstants {
        address lender;
        address borrower;
        uint256 borrowLimit;
        uint256 idealCollateralRatio;
        uint256 borrowRate;
        address borrowAsset;
        address collateralAsset;
        bool autoLiquidation;
        bool requestByLender;
    }
    /**
     * @notice stores the collateral shares in a credit line per strategy
     * @dev creditLineId => Strategy => collateralShares
     **/
    mapping(uint256 => mapping(address => uint256)) public collateralShareInStrategy;

    /**
     * @notice stores the variables to maintain a credit line
     **/
    mapping(uint256 => CreditLineVariables) public creditLineVariables;

    /**
     * @notice stores the constants related to a credit line
     **/
    mapping(uint256 => CreditLineConstants) public creditLineConstants;

    /**
     * @notice stores the address of savings account contract
     **/
    address public savingsAccount;

    /**
     * @notice stores the address of price oracle contract
     **/
    address public priceOracle;

    /**
     * @notice stores the address of strategy registry contract
     **/
    address public strategyRegistry;

    /**
     * @notice stores the address of default strategy
     **/
    address public defaultStrategy;

    /**
     * @notice stores the fraction of borrowed amount charged as fee by protocol
     * @dev it is multiplied by 10**30
     **/
    uint256 public protocolFeeFraction;

    /**
     * @notice address where protocol fee is collected
     **/
    address public protocolFeeCollector;

    /**
     * @notice stores the fraction of amount liquidated given as reward to liquidator
     * @dev it is multiplied by 10**30
     **/
    uint256 public liquidatorRewardFraction;
    /**
     * @dev checks if Credit Line exists
     * @param _id identifier for the credit line
     **/
    modifier ifCreditLineExists(uint256 _id) {
        require(creditLineVariables[_id].status != CreditLineStatus.NOT_CREATED, 'Credit line does not exist');
        _;
    }

    /**
     * @dev checks if called by credit Line Borrower
     * @param _id creditLine identifier
     **/
    modifier onlyCreditLineBorrower(uint256 _id) {
        require(creditLineConstants[_id].borrower == msg.sender, 'Only credit line Borrower can access');
        _;
    }

    /**
     * @dev checks if called by credit Line Lender
     * @param _id creditLine identifier
     **/
    modifier onlyCreditLineLender(uint256 _id) {
        require(creditLineConstants[_id].lender == msg.sender, 'Only credit line Lender can access');
        _;
    }

    /**
     * @notice emitted when a collateral is deposited into credit line
     * @param id id of the credit line
     * @param amount amount of collateral deposited
     * @param strategy address of the strategy into which collateral is deposited
     */
    event CollateralDeposited(uint256 indexed id, uint256 amount, address indexed strategy);

    /**
     * @notice emitted when collateral is withdrawn from credit line
     * @param id id of the credit line
     * @param amount amount of collateral withdrawn
     */
    event CollateralWithdrawn(uint256 indexed id, uint256 amount);

    /**
     * @notice emitted when a request for new credit line is placed
     * @param id id of the credit line for which request was made
     * @param lender address of the lender for credit line
     * @param borrower address of the borrower for credit line
     */
    event CreditLineRequested(uint256 indexed id, address indexed lender, address indexed borrower);

    /**
     * @notice emitted when a credit line is liquidated
     * @param id id of the credit line which is liquidated
     * @param liquidator address of the liquidator
     */
    event CreditLineLiquidated(uint256 indexed id, address indexed liquidator);

    /**
     * @notice emitted when tokens are borrowed from credit line
     * @param id id of the credit line from which tokens are borrowed
     * @param borrowAmount amount of tokens borrowed
     */
    event BorrowedFromCreditLine(uint256 indexed id, uint256 borrowAmount);

    /**
     * @notice emitted when credit line is accepted
     * @param id id of the credit line that was accepted
     */
    event CreditLineAccepted(uint256 indexed id);

    /**
     * @notice emitted when credit line is completely repaid and reset
     * @param id id of the credit line that is reset
     */
    event CreditLineReset(uint256 indexed id);

    /**
     * @notice emitted when the credit line is partially repaid
     * @param id id of the credit line
     * @param repayAmount amount repaid
     */
    event PartialCreditLineRepaid(uint256 indexed id, uint256 repayAmount);

    /**
     * @notice emitted when the credit line is completely repaid
     * @param id id of the credit line
     * @param repayAmount amount repaid
     */
    event CompleteCreditLineRepaid(uint256 indexed id, uint256 repayAmount);

    /**
     * @notice emitted when the credit line is closed by one of the parties of credit line
     * @param id id of the credit line
     */
    event CreditLineClosed(uint256 indexed id);

    /**
     * @notice emitted when default strategy for the credit line is updated
     * @param defaultStrategy address of the strategy contract that is used as default by credit lines
     */
    event DefaultStrategyUpdated(address indexed defaultStrategy);

    /**
     * @notice emitted when the price oracle is updated
     * @param priceOracle address of the updated price oracle
     */
    event PriceOracleUpdated(address indexed priceOracle);

    /**
     * @notice emitted when the savings account address is updated
     * @param savingsAccount address of the updated savingsAccount
     */
    event SavingsAccountUpdated(address indexed savingsAccount);

    /**
     * @notice emitted when strategy registry address is updated
     * @param strategyRegistry address of the updated strategy registry
     */
    event StrategyRegistryUpdated(address indexed strategyRegistry);

    /**
     * @notice emitted when fee that protocol charges for credit line is updated
     * @param updatedProtocolFee updated value of protocolFeeFraction
     */
    event ProtocolFeeFractionUpdated(uint256 updatedProtocolFee);

    /**
     * @notice emitted when address which receives fee that protocol changes for pools is updated
     * @param updatedProtocolFeeCollector updated value of protocolFeeCollector
     */
    event ProtocolFeeCollectorUpdated(address indexed updatedProtocolFeeCollector);

    /**
     * @notice emitted when liquidatorRewardFraction is updated
     * @param liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator
     */
    event LiquidationRewardFractionUpdated(uint256 liquidatorRewardFraction);

    /**
     * @notice used to initialize the contract
     * @dev can only be called once during the life cycle of the contract
     * @param _defaultStrategy default strategy used in credit lines
     * @param _priceOracle address of the priceOracle
     * @param _savingsAccount address of  the savings account contract
     * @param _strategyRegistry address of the strategy registry contract
     * @param _owner address of owner who can change global variables
     * @param _protocolFeeFraction fraction of the fee charged by protocol
     * @param _protocolFeeCollector address to which protocol fee is charged to
     * @param _liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator
     */
    function initialize(
        address _defaultStrategy,
        address _priceOracle,
        address _savingsAccount,
        address _strategyRegistry,
        address _owner,
        uint256 _protocolFeeFraction,
        address _protocolFeeCollector,
        uint256 _liquidatorRewardFraction
    ) external initializer {
        OwnableUpgradeable.__Ownable_init();
        OwnableUpgradeable.transferOwnership(_owner);

        _updateDefaultStrategy(_defaultStrategy);
        _updatePriceOracle(_priceOracle);
        _updateSavingsAccount(_savingsAccount);
        _updateStrategyRegistry(_strategyRegistry);
        _updateProtocolFeeFraction(_protocolFeeFraction);
        _updateProtocolFeeCollector(_protocolFeeCollector);
        _updateLiquidatorRewardFraction(_liquidatorRewardFraction);
    }

    /**
     * @notice used to update the default strategy
     * @dev can only be updated by owner
     * @param _defaultStrategy address of the updated default strategy
     */
    function updateDefaultStrategy(address _defaultStrategy) external onlyOwner {
        _updateDefaultStrategy(_defaultStrategy);
    }

    function _updateDefaultStrategy(address _defaultStrategy) internal {
        defaultStrategy = _defaultStrategy;
        emit DefaultStrategyUpdated(_defaultStrategy);
    }

    /**
     * @notice used to update the price oracle
     * @dev can only be updated by owner
     * @param _priceOracle address of the updated price oracle
     */
    function updatePriceOracle(address _priceOracle) external onlyOwner {
        _updatePriceOracle(_priceOracle);
    }

    function _updatePriceOracle(address _priceOracle) internal {
        priceOracle = _priceOracle;
        emit PriceOracleUpdated(_priceOracle);
    }

    /**
     * @notice used to update the savings account address
     * @dev can only be updated by owner
     * @param _savingsAccount address of the updated savings account
     */
    function updateSavingsAccount(address _savingsAccount) external onlyOwner {
        _updateSavingsAccount(_savingsAccount);
    }

    function _updateSavingsAccount(address _savingsAccount) internal {
        savingsAccount = _savingsAccount;
        emit SavingsAccountUpdated(_savingsAccount);
    }

    /**
     * @notice used to update the protocol fee fraction
     * @dev can only be updated by owner
     * @param _protocolFee fraction of the borrower amount collected as protocol fee
     */
    function updateProtocolFeeFraction(uint256 _protocolFee) external onlyOwner {
        _updateProtocolFeeFraction(_protocolFee);
    }

    function _updateProtocolFeeFraction(uint256 _protocolFee) internal {
        protocolFeeFraction = _protocolFee;
        emit ProtocolFeeFractionUpdated(_protocolFee);
    }

    /**
     * @notice used to update the protocol fee collector
     * @dev can only be updated by owner
     * @param _protocolFeeCollector address in which protocol fee is collected
     */
    function updateProtocolFeeCollector(address _protocolFeeCollector) external onlyOwner {
        _updateProtocolFeeCollector(_protocolFeeCollector);
    }

    function _updateProtocolFeeCollector(address _protocolFeeCollector) internal {
        require(_protocolFeeCollector != address(0), 'cant be 0 address');
        protocolFeeCollector = _protocolFeeCollector;
        emit ProtocolFeeCollectorUpdated(_protocolFeeCollector);
    }

    /**
     * @notice used to update the strategy registry address
     * @dev can only be updated by owner
     * @param _strategyRegistry address of the updated strategy registry
     */
    function updateStrategyRegistry(address _strategyRegistry) external onlyOwner {
        _updateStrategyRegistry(_strategyRegistry);
    }

    function _updateStrategyRegistry(address _strategyRegistry) internal {
        require(_strategyRegistry != address(0), 'CL::I zero address');
        strategyRegistry = _strategyRegistry;
        emit StrategyRegistryUpdated(_strategyRegistry);
    }

    /**
     * @notice used to update the liquidatorRewardFraction
     * @dev can only be updated by owner
     * @param _rewardFraction fraction of liquidated amount given to liquidator as reward
     */
    function updateLiquidatorRewardFraction(uint256 _rewardFraction) external onlyOwner {
        _updateLiquidatorRewardFraction(_rewardFraction);
    }

    function _updateLiquidatorRewardFraction(uint256 _rewardFraction) internal {
        require(_rewardFraction <= 10**30, 'Fraction has to be less than 1');
        liquidatorRewardFraction = _rewardFraction;
        emit LiquidationRewardFractionUpdated(_rewardFraction);
    }

    /**
     * @dev Used to Calculate Interest Per second on given principal and Interest rate
     * @param _principal principal Amount for which interest has to be calculated.
     * @param _borrowRate It is the Interest Rate at which Credit Line is approved
     * @return interest per second for the given parameters
     */
    function calculateInterest(
        uint256 _principal,
        uint256 _borrowRate,
        uint256 _timeElapsed
    ) public pure returns (uint256) {
        uint256 _interest = _principal.mul(_borrowRate).mul(_timeElapsed).div(10**30).div(YEAR_IN_SECONDS);

        return _interest;
    }

    /**
     * @dev Used to calculate interest accrued since last repayment
     * @param _id identifier for the credit line
     * @return interest accrued over current borrowed amount since last repayment
     */

    function calculateInterestAccrued(uint256 _id) public view returns (uint256) {
        uint256 _lastPrincipalUpdateTime = creditLineVariables[_id].lastPrincipalUpdateTime;
        if (_lastPrincipalUpdateTime == 0) return 0;
        uint256 _timeElapsed = (block.timestamp).sub(_lastPrincipalUpdateTime);
        uint256 _interestAccrued = calculateInterest(creditLineVariables[_id].principal, creditLineConstants[_id].borrowRate, _timeElapsed);
        return _interestAccrued;
    }

    /**
     * @dev Used to calculate current debt of borrower against a credit line.
     * @param _id identifier for the credit line
     * @return current debt of borrower
     */
    function calculateCurrentDebt(uint256 _id) public view returns (uint256) {
        uint256 _interestAccrued = calculateInterestAccrued(_id);
        uint256 _currentDebt = (creditLineVariables[_id].principal)
            .add(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate)
            .add(_interestAccrued)
            .sub(creditLineVariables[_id].totalInterestRepaid);
        return _currentDebt;
    }

    /**
     * @notice used to calculate amount that can be borrowed by the borrower
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view.
            borrowableAmount changes per block as interest changes per block.
     * @param _id identifier for the credit line
     * @return amount that can be borrowed from the credit line
     */
    function calculateBorrowableAmount(uint256 _id) public returns (uint256) {
        CreditLineStatus _status = creditLineVariables[_id].status;
        require(
            _status == CreditLineStatus.ACTIVE || _status == CreditLineStatus.REQUESTED,
            'CreditLine: Cannot only if credit line ACTIVE or REQUESTED'
        );
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(
            creditLineConstants[_id].collateralAsset,
            creditLineConstants[_id].borrowAsset
        );

        uint256 _totalCollateralToken = calculateTotalCollateralTokens(_id);

        uint256 _currentDebt = calculateCurrentDebt(_id);

        uint256 _maxPossible = _totalCollateralToken.mul(_ratioOfPrices).div(creditLineConstants[_id].idealCollateralRatio).mul(10**30).div(
            10**_decimals
        );

        uint256 _borrowLimit = creditLineConstants[_id].borrowLimit;

        if (_maxPossible > _borrowLimit) {
            _maxPossible = _borrowLimit;
        }
        if (_maxPossible > _currentDebt) {
            return _maxPossible.sub(_currentDebt);
        }
        return 0;
    }

    function updateinterestAccruedTillLastPrincipalUpdate(uint256 _id) internal {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');

        uint256 _interestAccrued = calculateInterestAccrued(_id);
        uint256 _newInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(_interestAccrued);
        creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _newInterestAccrued;
    }

    function _depositCollateralFromSavingsAccount(
        uint256 _id,
        uint256 _amount,
        address _sender
    ) internal {
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        uint256 _activeAmount;

        for (uint256 _index = 0; _index < _strategyList.length; _index++) {
            address _strategy = _strategyList[_index];
            uint256 _liquidityShares = _savingsAccount.balanceInShares(_sender, _collateralAsset, _strategy);
            if (_liquidityShares == 0 || _strategyList[_index] == address(0)) {
                continue;
            }
            uint256 _tokenInStrategy = _liquidityShares;
            _tokenInStrategy = IYield(_strategy).getTokensForShares(_liquidityShares, _collateralAsset);

            uint256 _tokensToTransfer = _tokenInStrategy;
            if (_activeAmount.add(_tokenInStrategy) >= _amount) {
                _tokensToTransfer = (_amount.sub(_activeAmount));
            }
            _activeAmount = _activeAmount.add(_tokensToTransfer);
            _savingsAccount.transferFrom(_tokensToTransfer, _collateralAsset, _strategy, _sender, address(this));

            collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(
                _liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy)
            );

            if (_amount == _activeAmount) {
                return;
            }
        }
        revert('CreditLine::_depositCollateralFromSavingsAccount - Insufficient balance');
    }

    /**
     * @notice used to request a credit line either by borrower or lender
     * @param _requestTo Address to which creditLine is requested, 
                        if borrower creates request then lender address and 
                        if lender creates then borrower address
     * @param _borrowLimit maximum borrow amount in a credit line
     * @param _borrowRate Interest Rate at which credit Line is requested
     * @param _autoLiquidation if true, anyone can liquidate loan, otherwise only lender
     * @param _collateralRatio ratio of the collateral to the debt below which credit line can be liquidated
     * @param _borrowAsset address of the token to be borrowed
     * @param _collateralAsset address of the token provided as collateral
     * @param _requestAsLender if true, lender is placing request, otherwise borrower
     * @return identifier for the credit line
     */

    function request(
        address _requestTo,
        uint256 _borrowLimit,
        uint256 _borrowRate,
        bool _autoLiquidation,
        uint256 _collateralRatio,
        address _borrowAsset,
        address _collateralAsset,
        bool _requestAsLender
    ) external returns (uint256) {
        require(_borrowAsset != _collateralAsset, 'R: cant borrow lent token');
        require(IPriceOracle(priceOracle).doesFeedExist(_borrowAsset, _collateralAsset), 'R: No price feed');

        address _lender = _requestTo;
        address _borrower = msg.sender;
        if (_requestAsLender) {
            _lender = msg.sender;
            _borrower = _requestTo;
        }

        uint256 _id = _createRequest(
            _lender,
            _borrower,
            _borrowLimit,
            _borrowRate,
            _autoLiquidation,
            _collateralRatio,
            _borrowAsset,
            _collateralAsset,
            _requestAsLender
        );

        emit CreditLineRequested(_id, _lender, _borrower);
        return _id;
    }

    function _createRequest(
        address _lender,
        address _borrower,
        uint256 _borrowLimit,
        uint256 _borrowRate,
        bool _autoLiquidation,
        uint256 _collateralRatio,
        address _borrowAsset,
        address _collateralAsset,
        bool _requestByLender
    ) internal returns (uint256) {
        require(_lender != _borrower, 'Lender and Borrower cannot be same addresses');
        uint256 _id = creditLineCounter + 1;
        creditLineCounter = _id;
        creditLineVariables[_id].status = CreditLineStatus.REQUESTED;
        creditLineConstants[_id].borrower = _borrower;
        creditLineConstants[_id].lender = _lender;
        creditLineConstants[_id].borrowLimit = _borrowLimit;
        creditLineConstants[_id].autoLiquidation = _autoLiquidation;
        creditLineConstants[_id].idealCollateralRatio = _collateralRatio;
        creditLineConstants[_id].borrowRate = _borrowRate;
        creditLineConstants[_id].borrowAsset = _borrowAsset;
        creditLineConstants[_id].collateralAsset = _collateralAsset;
        creditLineConstants[_id].requestByLender = _requestByLender;
        return _id;
    }

    /**
     * @notice used to accept a credit line
     * @dev if borrower places request, lender can accept and vice versa
     * @param _id identifier for the credit line
     */
    function accept(uint256 _id) external {
        require(
            creditLineVariables[_id].status == CreditLineStatus.REQUESTED,
            'CreditLine::acceptCreditLineLender - CreditLine is already accepted'
        );
        bool _requestByLender = creditLineConstants[_id].requestByLender;
        require(
            (msg.sender == creditLineConstants[_id].borrower && _requestByLender) ||
                (msg.sender == creditLineConstants[_id].lender && !_requestByLender),
            "Only Borrower or Lender who hasn't requested can accept"
        );
        creditLineVariables[_id].status = CreditLineStatus.ACTIVE;
        emit CreditLineAccepted(_id);
    }

    /**
     * @notice used to deposit collateral into the credit line
     * @dev collateral tokens have to be approved in savingsAccount or token contract(unless ether).
            If transferred from savings account, the tokens are transferred from strategies in the 
            order prespecified in strategy registry
     * @param _id identifier for the credit line
     * @param _amount amount of collateral being deposited
     * @param _strategy strategy to which collateral is to be deposited in case transfer is not from savings account
     * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount 
                                otherwise direct from collateral token contract
     */
    function depositCollateral(
        uint256 _id,
        uint256 _amount,
        address _strategy,
        bool _fromSavingsAccount
    ) external payable nonReentrant ifCreditLineExists(_id) {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine not active');
        _depositCollateral(_id, _amount, _strategy, _fromSavingsAccount);
        emit CollateralDeposited(_id, _amount, _strategy);
    }

    function _depositCollateral(
        uint256 _id,
        uint256 _amount,
        address _strategy,
        bool _fromSavingsAccount
    ) internal {
        require(creditLineConstants[_id].lender != msg.sender, 'lender cant deposit collateral');
        if (_fromSavingsAccount) {
            _depositCollateralFromSavingsAccount(_id, _amount, msg.sender);
        } else {
            address _collateralAsset = creditLineConstants[_id].collateralAsset;
            ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
            if (_collateralAsset == address(0)) {
                require(msg.value == _amount, "CreditLine::_depositCollateral - value to transfer doesn't match argument");
            } else {
                IERC20(_collateralAsset).safeTransferFrom(msg.sender, address(this), _amount);
                IERC20(_collateralAsset).approve(_strategy, _amount);
            }
            uint256 _sharesReceived = _savingsAccount.deposit{value: msg.value}(_amount, _collateralAsset, _strategy, address(this));
            collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(_sharesReceived);
        }
    }

    function _withdrawBorrowAmount(
        address _asset,
        uint256 _amountInTokens,
        address _lender
    ) internal {
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        uint256 _activeAmount;
        for (uint256 _index = 0; _index < _strategyList.length; _index++) {
            if (_strategyList[_index] == address(0)) {
                continue;
            }
            uint256 _liquidityShares = _savingsAccount.balanceInShares(_lender, _asset, _strategyList[_index]);
            if (_liquidityShares != 0) {
                uint256 tokenInStrategy = _liquidityShares;
                tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);
                uint256 _tokensToTransfer = tokenInStrategy;
                if (_activeAmount.add(tokenInStrategy) >= _amountInTokens) {
                    _tokensToTransfer = (_amountInTokens.sub(_activeAmount));
                }
                _activeAmount = _activeAmount.add(_tokensToTransfer);
                _savingsAccount.withdrawFrom(_tokensToTransfer, _asset, _strategyList[_index], _lender, address(this), false);
                if (_activeAmount == _amountInTokens) {
                    return;
                }
            }
        }
        require(_activeAmount == _amountInTokens, 'insufficient balance');
    }

    /**
     * @notice used to borrow tokens from credit line by borrower
     * @dev only borrower can call this function. Amount that can actually be borrowed is 
            min(amount based on borrowLimit, allowance to creditLine contract, balance of lender)
     * @param _id identifier for the credit line
     * @param _amount amount of tokens to borrow
     */
    function borrow(uint256 _id, uint256 _amount) external payable nonReentrant onlyCreditLineBorrower(_id) {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');
        uint256 _borrowableAmount = calculateBorrowableAmount(_id);
        require(_amount <= _borrowableAmount, "CreditLine::borrow - The current collateral ratio doesn't allow to withdraw the amount");
        address _borrowAsset = creditLineConstants[_id].borrowAsset;
        address _lender = creditLineConstants[_id].lender;

        updateinterestAccruedTillLastPrincipalUpdate(_id);
        creditLineVariables[_id].principal = creditLineVariables[_id].principal.add(_amount);
        creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;

        uint256 _tokenDiffBalance;
        if (_borrowAsset != address(0)) {
            uint256 _balanceBefore = IERC20(_borrowAsset).balanceOf(address(this));
            _withdrawBorrowAmount(_borrowAsset, _amount, _lender);
            uint256 _balanceAfter = IERC20(_borrowAsset).balanceOf(address(this));
            _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);
        } else {
            uint256 _balanceBefore = address(this).balance;
            _withdrawBorrowAmount(_borrowAsset, _amount, _lender);
            uint256 _balanceAfter = address(this).balance;
            _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);
        }
        uint256 _protocolFee = _tokenDiffBalance.mul(protocolFeeFraction).div(10**30);
        _tokenDiffBalance = _tokenDiffBalance.sub(_protocolFee);

        if (_borrowAsset == address(0)) {
            (bool feeSuccess, ) = protocolFeeCollector.call{value: _protocolFee}('');
            require(feeSuccess, 'Transfer fail');
            (bool success, ) = msg.sender.call{value: _tokenDiffBalance}('');
            require(success, 'Transfer fail');
        } else {
            IERC20(_borrowAsset).safeTransfer(protocolFeeCollector, _protocolFee);
            IERC20(_borrowAsset).safeTransfer(msg.sender, _tokenDiffBalance);
        }
        emit BorrowedFromCreditLine(_id, _tokenDiffBalance);
    }

    function _repayFromSavingsAccount(
        uint256 _amount,
        address _asset,
        address _lender
    ) internal {
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        uint256 _activeAmount;

        for (uint256 _index = 0; _index < _strategyList.length; _index++) {
            if (_strategyList[_index] == address(0)) {
                continue;
            }
            uint256 _liquidityShares = _savingsAccount.balanceInShares(msg.sender, _asset, _strategyList[_index]);
            if (_liquidityShares == 0) {
                continue;
            }
            uint256 _tokenInStrategy = _liquidityShares;
            _tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);

            uint256 _tokensToTransfer = _tokenInStrategy;
            if (_activeAmount.add(_tokenInStrategy) >= _amount) {
                _tokensToTransfer = (_amount.sub(_activeAmount));
            }
            _activeAmount = _activeAmount.add(_tokensToTransfer);
            _savingsAccount.transferFrom(_tokensToTransfer, _asset, _strategyList[_index], msg.sender, _lender);

            if (_amount == _activeAmount) {
                return;
            }
        }
        revert('CreditLine::_repayFromSavingsAccount - Insufficient balance');
    }

    function _repay(
        uint256 _id,
        uint256 _amount,
        bool _fromSavingsAccount,
        uint256 _principalPaid
    ) internal {
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        address _defaultStrategy = defaultStrategy;
        address _borrowAsset = creditLineConstants[_id].borrowAsset;
        address _lender = creditLineConstants[_id].lender;
        if (!_fromSavingsAccount) {
            if (_borrowAsset == address(0)) {
                require(msg.value == _amount, 'creditLine::repay - Ether sent not equal to repay amount');
                _savingsAccount.deposit{value: _amount}(_amount, _borrowAsset, _defaultStrategy, _lender);
            } else {
                IERC20(_borrowAsset).safeTransferFrom(msg.sender, address(this), _amount);
                IERC20(_borrowAsset).approve(_defaultStrategy, _amount);
                _savingsAccount.deposit(_amount, _borrowAsset, _defaultStrategy, _lender);
            }
        } else {
            _repayFromSavingsAccount(_amount, _borrowAsset, _lender);
        }
        if (_principalPaid != 0) {
            _savingsAccount.increaseAllowanceToCreditLine(_principalPaid, _borrowAsset, _lender);
        }
    }

    /**
     * @notice used to repay interest and principal to credit line. Interest has to be repaid before repaying principal
     * @dev partial repayments possible
     * @param _id identifier for the credit line
     * @param _amount amount being repaid
     * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount 
                                otherwise direct from collateral token contract
     */
    function repay(
        uint256 _id,
        uint256 _amount,
        bool _fromSavingsAccount
    ) external payable nonReentrant {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');
        require(creditLineConstants[_id].lender != msg.sender, 'Lender cant repay');

        uint256 _interestSincePrincipalUpdate = calculateInterestAccrued(_id);
        uint256 _totalInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(
            _interestSincePrincipalUpdate
        );
        uint256 _interestToPay = _totalInterestAccrued.sub(creditLineVariables[_id].totalInterestRepaid);
        uint256 _totalCurrentDebt = _interestToPay.add(creditLineVariables[_id].principal);
        uint256 _principalPaid = 0;

        if (_amount >= _totalCurrentDebt) {
            _amount = _totalCurrentDebt;
            emit CompleteCreditLineRepaid(_id, _amount);
        } else {
            emit PartialCreditLineRepaid(_id, _amount);
        }

        if (_amount > _interestToPay) {
            creditLineVariables[_id].principal = _totalCurrentDebt.sub(_amount);
            creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _totalInterestAccrued;
            creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;
            creditLineVariables[_id].totalInterestRepaid = _totalInterestAccrued;
            _principalPaid = _amount.sub(_interestToPay);
        } else {
            creditLineVariables[_id].totalInterestRepaid = creditLineVariables[_id].totalInterestRepaid.add(_amount);
        }

        _repay(_id, _amount, _fromSavingsAccount, _principalPaid);

        if (creditLineVariables[_id].principal == 0) {
            _resetCreditLine(_id);
        }
    }

    function _resetCreditLine(uint256 _id) internal {
        creditLineVariables[_id].lastPrincipalUpdateTime = 0;
        creditLineVariables[_id].totalInterestRepaid = 0;
        creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = 0;
        emit CreditLineReset(_id);
    }

    /**
     * @dev used to close credit line by borrower or lender
     * @param _id identifier for the credit line
     */
    function close(uint256 _id) external ifCreditLineExists(_id) {
        require(
            msg.sender == creditLineConstants[_id].borrower || msg.sender == creditLineConstants[_id].lender,
            'CreditLine: Permission denied while closing Line of credit'
        );
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: Credit line should be active.');
        require(creditLineVariables[_id].principal == 0, 'CreditLine: Cannot be closed since not repaid.');
        require(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate == 0, 'CreditLine: Cannot be closed since not repaid.');
        creditLineVariables[_id].status = CreditLineStatus.CLOSED;
        emit CreditLineClosed(_id);
    }

    /**
     * @notice used to calculate the current collateral ratio
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view.
            Interest is also considered while calculating debt
     * @param _id identifier for the credit line
     * @return collateral ratio multiplied by 10**30 to retain precision
     */
    function calculateCurrentCollateralRatio(uint256 _id) public ifCreditLineExists(_id) returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(
            creditLineConstants[_id].collateralAsset,
            creditLineConstants[_id].borrowAsset
        );

        uint256 currentDebt = calculateCurrentDebt(_id);
        uint256 currentCollateralRatio = calculateTotalCollateralTokens(_id).mul(_ratioOfPrices).div(currentDebt).mul(10**30).div(
            10**_decimals
        );

        return currentCollateralRatio;
    }

    /**
     * @notice used to calculate the total collateral tokens
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @param _id identifier for the credit line
     * @return _amount total collateral tokens deposited into the credit line
     */
    function calculateTotalCollateralTokens(uint256 _id) public returns (uint256 _amount) {
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        uint256 _liquidityShares;
        for (uint256 index = 0; index < _strategyList.length; index++) {
            if (_strategyList[index] == address(0)) {
                continue;
            }
            _liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];
            uint256 _tokenInStrategy = _liquidityShares;
            _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(_liquidityShares, _collateralAsset);

            _amount = _amount.add(_tokenInStrategy);
        }
    }

    /**
     * @notice used to withdraw any excess collateral
     * @dev collateral can't be withdraw if collateralRatio goes below the ideal value. Only borrower can withdraw
     * @param _id identifier for the credit line
     * @param _amount amount of collateral to withdraw
     * @param _toSavingsAccount if true, tokens are transferred from savingsAccount 
                                otherwise direct from collateral token contract
     */
    function withdrawCollateral(
        uint256 _id,
        uint256 _amount,
        bool _toSavingsAccount
    ) external nonReentrant onlyCreditLineBorrower(_id) {
        uint256 _withdrawableCollateral = withdrawableCollateral(_id);
        require(_amount <= _withdrawableCollateral, 'Collateral ratio cant go below ideal');
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        _transferCollateral(_id, _collateralAsset, _amount, _toSavingsAccount);
        emit CollateralWithdrawn(_id, _amount);
    }

    /**
     * @notice used to calculate the collateral that can be withdrawn
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @param _id identifier for the credit line
     * @return total collateral withdrawable by borrower
     */
    function withdrawableCollateral(uint256 _id) public returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(
            creditLineConstants[_id].collateralAsset,
            creditLineConstants[_id].borrowAsset
        );

        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);
        uint256 _currentDebt = calculateCurrentDebt(_id);

        uint256 _collateralNeeded = _currentDebt
            .mul(creditLineConstants[_id].idealCollateralRatio)
            .div(_ratioOfPrices)
            .mul(10**_decimals)
            .div(10**30);

        if (_collateralNeeded >= _totalCollateralTokens) {
            return 0;
        }
        return _totalCollateralTokens.sub(_collateralNeeded);
    }

    function _transferCollateral(
        uint256 _id,
        address _asset,
        uint256 _amountInTokens,
        bool _toSavingsAccount
    ) internal {
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        uint256 _activeAmount;
        for (uint256 index = 0; index < _strategyList.length; index++) {
            uint256 liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];
            if (liquidityShares == 0 || _strategyList[index] == address(0)) {
                continue;
            }
            uint256 _tokenInStrategy = liquidityShares;
            _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(liquidityShares, _asset);
            uint256 _tokensToTransfer = _tokenInStrategy;
            if (_activeAmount.add(_tokenInStrategy) > _amountInTokens) {
                _tokensToTransfer = _amountInTokens.sub(_activeAmount);
                liquidityShares = liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy);
            }
            _activeAmount = _activeAmount.add(_tokensToTransfer);
            collateralShareInStrategy[_id][_strategyList[index]] = collateralShareInStrategy[_id][_strategyList[index]].sub(
                liquidityShares
            );
            if (_toSavingsAccount) {
                ISavingsAccount(savingsAccount).transfer(_tokensToTransfer, _asset, _strategyList[index], msg.sender);
            } else {
                ISavingsAccount(savingsAccount).withdraw(_tokensToTransfer, _asset, _strategyList[index], msg.sender, false);
            }

            if (_activeAmount == _amountInTokens) {
                return;
            }
        }
        revert('insufficient collateral');
    }

    /**
     * @notice used to liquidate credit line in case collateral ratio goes below the threshold
     * @dev if lender liquidates, then collateral is directly transferred. 
            If autoLiquidation is true, anyone can liquidate by providing enough borrow tokens
     * @param _id identifier for the credit line
     * @param _toSavingsAccount if true, tokens are transferred from savingsAccount 
                                otherwise direct from collateral token contract
     */
    function liquidate(uint256 _id, bool _toSavingsAccount) external payable nonReentrant {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: Credit line should be active.');
        require(creditLineVariables[_id].principal != 0, 'CreditLine: cannot liquidate if principal is 0');

        uint256 currentCollateralRatio = calculateCurrentCollateralRatio(_id);
        require(
            currentCollateralRatio < creditLineConstants[_id].idealCollateralRatio,
            'CreditLine: Collateral ratio is higher than ideal value'
        );

        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        address _lender = creditLineConstants[_id].lender;
        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);
        address _borrowAsset = creditLineConstants[_id].borrowAsset;

        creditLineVariables[_id].status = CreditLineStatus.LIQUIDATED;

        if (creditLineConstants[_id].autoLiquidation && _lender != msg.sender) {
            uint256 _borrowTokens = _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens);
            if (_borrowAsset == address(0)) {
                uint256 _returnETH = msg.value.sub(_borrowTokens, 'Insufficient ETH to liquidate');
                if (_returnETH != 0) {
                    (bool success, ) = msg.sender.call{value: _returnETH}('');
                    require(success, 'Transfer fail');
                }
            } else {
                IERC20(_borrowAsset).safeTransferFrom(msg.sender, _lender, _borrowTokens);
            }
        }

        _transferCollateral(_id, _collateralAsset, _totalCollateralTokens, _toSavingsAccount);

        emit CreditLineLiquidated(_id, msg.sender);
    }

    /**
     * @notice used to calculate the borrow tokens necessary for liquidator to liquidate
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @param _id identifier for the credit line
     * @return borrow tokens necessary for liquidator to liquidate
     */
    function borrowTokensToLiquidate(uint256 _id) external returns (uint256) {
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);
        address _borrowAsset = creditLineConstants[_id].borrowAsset;

        return _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens);
    }

    function _borrowTokensToLiquidate(
        address _borrowAsset,
        address _collateralAsset,
        uint256 _totalCollateralTokens
    ) internal view returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(_borrowAsset, _collateralAsset);
        uint256 _borrowTokens = (
            _totalCollateralTokens.mul(uint256(10**30).sub(liquidatorRewardFraction)).div(10**30).mul(_ratioOfPrices).div(10**_decimals)
        );

        return _borrowTokens;
    }

    receive() external payable {
        require(msg.sender == savingsAccount, 'CreditLine::receive invalid transaction');
    }
}
.]

Given the user's task and the brainstorming ideas provided:
Task: "// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/utils/ReentrancyGuard.sol';
import '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';
import '../interfaces/IPriceOracle.sol';
import '../interfaces/IYield.sol';
import '../interfaces/ISavingsAccount.sol';
import '../SavingsAccount/SavingsAccountUtil.sol';
import '../interfaces/IStrategyRegistry.sol';

/**
 * @title Credit Line contract with Methods related to credit Line
 * @notice Implements the functions related to Credit Line
 * @author Sublime
 **/

contract CreditLine is ReentrancyGuard, OwnableUpgradeable {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    enum CreditLineStatus {
        NOT_CREATED,
        REQUESTED,
        ACTIVE,
        CLOSED,
        CANCELLED,
        LIQUIDATED
    }

    /**
     * @notice counter that tracks the number of credit lines created
     * @dev used to create unique identifier for credit lines
     **/
    uint256 public creditLineCounter;

    uint256 constant YEAR_IN_SECONDS = 365 days;

    struct CreditLineVariables {
        CreditLineStatus status;
        uint256 principal;
        uint256 totalInterestRepaid;
        uint256 lastPrincipalUpdateTime;
        uint256 interestAccruedTillLastPrincipalUpdate;
    }

    struct CreditLineConstants {
        address lender;
        address borrower;
        uint256 borrowLimit;
        uint256 idealCollateralRatio;
        uint256 borrowRate;
        address borrowAsset;
        address collateralAsset;
        bool autoLiquidation;
        bool requestByLender;
    }
    /**
     * @notice stores the collateral shares in a credit line per strategy
     * @dev creditLineId => Strategy => collateralShares
     **/
    mapping(uint256 => mapping(address => uint256)) public collateralShareInStrategy;

    /**
     * @notice stores the variables to maintain a credit line
     **/
    mapping(uint256 => CreditLineVariables) public creditLineVariables;

    /**
     * @notice stores the constants related to a credit line
     **/
    mapping(uint256 => CreditLineConstants) public creditLineConstants;

    /**
     * @notice stores the address of savings account contract
     **/
    address public savingsAccount;

    /**
     * @notice stores the address of price oracle contract
     **/
    address public priceOracle;

    /**
     * @notice stores the address of strategy registry contract
     **/
    address public strategyRegistry;

    /**
     * @notice stores the address of default strategy
     **/
    address public defaultStrategy;

    /**
     * @notice stores the fraction of borrowed amount charged as fee by protocol
     * @dev it is multiplied by 10**30
     **/
    uint256 public protocolFeeFraction;

    /**
     * @notice address where protocol fee is collected
     **/
    address public protocolFeeCollector;

    /**
     * @notice stores the fraction of amount liquidated given as reward to liquidator
     * @dev it is multiplied by 10**30
     **/
    uint256 public liquidatorRewardFraction;
    /**
     * @dev checks if Credit Line exists
     * @param _id identifier for the credit line
     **/
    modifier ifCreditLineExists(uint256 _id) {
        require(creditLineVariables[_id].status != CreditLineStatus.NOT_CREATED, 'Credit line does not exist');
        _;
    }

    /**
     * @dev checks if called by credit Line Borrower
     * @param _id creditLine identifier
     **/
    modifier onlyCreditLineBorrower(uint256 _id) {
        require(creditLineConstants[_id].borrower == msg.sender, 'Only credit line Borrower can access');
        _;
    }

    /**
     * @dev checks if called by credit Line Lender
     * @param _id creditLine identifier
     **/
    modifier onlyCreditLineLender(uint256 _id) {
        require(creditLineConstants[_id].lender == msg.sender, 'Only credit line Lender can access');
        _;
    }

    /**
     * @notice emitted when a collateral is deposited into credit line
     * @param id id of the credit line
     * @param amount amount of collateral deposited
     * @param strategy address of the strategy into which collateral is deposited
     */
    event CollateralDeposited(uint256 indexed id, uint256 amount, address indexed strategy);

    /**
     * @notice emitted when collateral is withdrawn from credit line
     * @param id id of the credit line
     * @param amount amount of collateral withdrawn
     */
    event CollateralWithdrawn(uint256 indexed id, uint256 amount);

    /**
     * @notice emitted when a request for new credit line is placed
     * @param id id of the credit line for which request was made
     * @param lender address of the lender for credit line
     * @param borrower address of the borrower for credit line
     */
    event CreditLineRequested(uint256 indexed id, address indexed lender, address indexed borrower);

    /**
     * @notice emitted when a credit line is liquidated
     * @param id id of the credit line which is liquidated
     * @param liquidator address of the liquidator
     */
    event CreditLineLiquidated(uint256 indexed id, address indexed liquidator);

    /**
     * @notice emitted when tokens are borrowed from credit line
     * @param id id of the credit line from which tokens are borrowed
     * @param borrowAmount amount of tokens borrowed
     */
    event BorrowedFromCreditLine(uint256 indexed id, uint256 borrowAmount);

    /**
     * @notice emitted when credit line is accepted
     * @param id id of the credit line that was accepted
     */
    event CreditLineAccepted(uint256 indexed id);

    /**
     * @notice emitted when credit line is completely repaid and reset
     * @param id id of the credit line that is reset
     */
    event CreditLineReset(uint256 indexed id);

    /**
     * @notice emitted when the credit line is partially repaid
     * @param id id of the credit line
     * @param repayAmount amount repaid
     */
    event PartialCreditLineRepaid(uint256 indexed id, uint256 repayAmount);

    /**
     * @notice emitted when the credit line is completely repaid
     * @param id id of the credit line
     * @param repayAmount amount repaid
     */
    event CompleteCreditLineRepaid(uint256 indexed id, uint256 repayAmount);

    /**
     * @notice emitted when the credit line is closed by one of the parties of credit line
     * @param id id of the credit line
     */
    event CreditLineClosed(uint256 indexed id);

    /**
     * @notice emitted when default strategy for the credit line is updated
     * @param defaultStrategy address of the strategy contract that is used as default by credit lines
     */
    event DefaultStrategyUpdated(address indexed defaultStrategy);

    /**
     * @notice emitted when the price oracle is updated
     * @param priceOracle address of the updated price oracle
     */
    event PriceOracleUpdated(address indexed priceOracle);

    /**
     * @notice emitted when the savings account address is updated
     * @param savingsAccount address of the updated savingsAccount
     */
    event SavingsAccountUpdated(address indexed savingsAccount);

    /**
     * @notice emitted when strategy registry address is updated
     * @param strategyRegistry address of the updated strategy registry
     */
    event StrategyRegistryUpdated(address indexed strategyRegistry);

    /**
     * @notice emitted when fee that protocol charges for credit line is updated
     * @param updatedProtocolFee updated value of protocolFeeFraction
     */
    event ProtocolFeeFractionUpdated(uint256 updatedProtocolFee);

    /**
     * @notice emitted when address which receives fee that protocol changes for pools is updated
     * @param updatedProtocolFeeCollector updated value of protocolFeeCollector
     */
    event ProtocolFeeCollectorUpdated(address indexed updatedProtocolFeeCollector);

    /**
     * @notice emitted when liquidatorRewardFraction is updated
     * @param liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator
     */
    event LiquidationRewardFractionUpdated(uint256 liquidatorRewardFraction);

    /**
     * @notice used to initialize the contract
     * @dev can only be called once during the life cycle of the contract
     * @param _defaultStrategy default strategy used in credit lines
     * @param _priceOracle address of the priceOracle
     * @param _savingsAccount address of  the savings account contract
     * @param _strategyRegistry address of the strategy registry contract
     * @param _owner address of owner who can change global variables
     * @param _protocolFeeFraction fraction of the fee charged by protocol
     * @param _protocolFeeCollector address to which protocol fee is charged to
     * @param _liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator
     */
    function initialize(
        address _defaultStrategy,
        address _priceOracle,
        address _savingsAccount,
        address _strategyRegistry,
        address _owner,
        uint256 _protocolFeeFraction,
        address _protocolFeeCollector,
        uint256 _liquidatorRewardFraction
    ) external initializer {
        OwnableUpgradeable.__Ownable_init();
        OwnableUpgradeable.transferOwnership(_owner);

        _updateDefaultStrategy(_defaultStrategy);
        _updatePriceOracle(_priceOracle);
        _updateSavingsAccount(_savingsAccount);
        _updateStrategyRegistry(_strategyRegistry);
        _updateProtocolFeeFraction(_protocolFeeFraction);
        _updateProtocolFeeCollector(_protocolFeeCollector);
        _updateLiquidatorRewardFraction(_liquidatorRewardFraction);
    }

    /**
     * @notice used to update the default strategy
     * @dev can only be updated by owner
     * @param _defaultStrategy address of the updated default strategy
     */
    function updateDefaultStrategy(address _defaultStrategy) external onlyOwner {
        _updateDefaultStrategy(_defaultStrategy);
    }

    function _updateDefaultStrategy(address _defaultStrategy) internal {
        defaultStrategy = _defaultStrategy;
        emit DefaultStrategyUpdated(_defaultStrategy);
    }

    /**
     * @notice used to update the price oracle
     * @dev can only be updated by owner
     * @param _priceOracle address of the updated price oracle
     */
    function updatePriceOracle(address _priceOracle) external onlyOwner {
        _updatePriceOracle(_priceOracle);
    }

    function _updatePriceOracle(address _priceOracle) internal {
        priceOracle = _priceOracle;
        emit PriceOracleUpdated(_priceOracle);
    }

    /**
     * @notice used to update the savings account address
     * @dev can only be updated by owner
     * @param _savingsAccount address of the updated savings account
     */
    function updateSavingsAccount(address _savingsAccount) external onlyOwner {
        _updateSavingsAccount(_savingsAccount);
    }

    function _updateSavingsAccount(address _savingsAccount) internal {
        savingsAccount = _savingsAccount;
        emit SavingsAccountUpdated(_savingsAccount);
    }

    /**
     * @notice used to update the protocol fee fraction
     * @dev can only be updated by owner
     * @param _protocolFee fraction of the borrower amount collected as protocol fee
     */
    function updateProtocolFeeFraction(uint256 _protocolFee) external onlyOwner {
        _updateProtocolFeeFraction(_protocolFee);
    }

    function _updateProtocolFeeFraction(uint256 _protocolFee) internal {
        protocolFeeFraction = _protocolFee;
        emit ProtocolFeeFractionUpdated(_protocolFee);
    }

    /**
     * @notice used to update the protocol fee collector
     * @dev can only be updated by owner
     * @param _protocolFeeCollector address in which protocol fee is collected
     */
    function updateProtocolFeeCollector(address _protocolFeeCollector) external onlyOwner {
        _updateProtocolFeeCollector(_protocolFeeCollector);
    }

    function _updateProtocolFeeCollector(address _protocolFeeCollector) internal {
        require(_protocolFeeCollector != address(0), 'cant be 0 address');
        protocolFeeCollector = _protocolFeeCollector;
        emit ProtocolFeeCollectorUpdated(_protocolFeeCollector);
    }

    /**
     * @notice used to update the strategy registry address
     * @dev can only be updated by owner
     * @param _strategyRegistry address of the updated strategy registry
     */
    function updateStrategyRegistry(address _strategyRegistry) external onlyOwner {
        _updateStrategyRegistry(_strategyRegistry);
    }

    function _updateStrategyRegistry(address _strategyRegistry) internal {
        require(_strategyRegistry != address(0), 'CL::I zero address');
        strategyRegistry = _strategyRegistry;
        emit StrategyRegistryUpdated(_strategyRegistry);
    }

    /**
     * @notice used to update the liquidatorRewardFraction
     * @dev can only be updated by owner
     * @param _rewardFraction fraction of liquidated amount given to liquidator as reward
     */
    function updateLiquidatorRewardFraction(uint256 _rewardFraction) external onlyOwner {
        _updateLiquidatorRewardFraction(_rewardFraction);
    }

    function _updateLiquidatorRewardFraction(uint256 _rewardFraction) internal {
        require(_rewardFraction <= 10**30, 'Fraction has to be less than 1');
        liquidatorRewardFraction = _rewardFraction;
        emit LiquidationRewardFractionUpdated(_rewardFraction);
    }

    /**
     * @dev Used to Calculate Interest Per second on given principal and Interest rate
     * @param _principal principal Amount for which interest has to be calculated.
     * @param _borrowRate It is the Interest Rate at which Credit Line is approved
     * @return interest per second for the given parameters
     */
    function calculateInterest(
        uint256 _principal,
        uint256 _borrowRate,
        uint256 _timeElapsed
    ) public pure returns (uint256) {
        uint256 _interest = _principal.mul(_borrowRate).mul(_timeElapsed).div(10**30).div(YEAR_IN_SECONDS);

        return _interest;
    }

    /**
     * @dev Used to calculate interest accrued since last repayment
     * @param _id identifier for the credit line
     * @return interest accrued over current borrowed amount since last repayment
     */

    function calculateInterestAccrued(uint256 _id) public view returns (uint256) {
        uint256 _lastPrincipalUpdateTime = creditLineVariables[_id].lastPrincipalUpdateTime;
        if (_lastPrincipalUpdateTime == 0) return 0;
        uint256 _timeElapsed = (block.timestamp).sub(_lastPrincipalUpdateTime);
        uint256 _interestAccrued = calculateInterest(creditLineVariables[_id].principal, creditLineConstants[_id].borrowRate, _timeElapsed);
        return _interestAccrued;
    }

    /**
     * @dev Used to calculate current debt of borrower against a credit line.
     * @param _id identifier for the credit line
     * @return current debt of borrower
     */
    function calculateCurrentDebt(uint256 _id) public view returns (uint256) {
        uint256 _interestAccrued = calculateInterestAccrued(_id);
        uint256 _currentDebt = (creditLineVariables[_id].principal)
            .add(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate)
            .add(_interestAccrued)
            .sub(creditLineVariables[_id].totalInterestRepaid);
        return _currentDebt;
    }

    /**
     * @notice used to calculate amount that can be borrowed by the borrower
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view.
            borrowableAmount changes per block as interest changes per block.
     * @param _id identifier for the credit line
     * @return amount that can be borrowed from the credit line
     */
    function calculateBorrowableAmount(uint256 _id) public returns (uint256) {
        CreditLineStatus _status = creditLineVariables[_id].status;
        require(
            _status == CreditLineStatus.ACTIVE || _status == CreditLineStatus.REQUESTED,
            'CreditLine: Cannot only if credit line ACTIVE or REQUESTED'
        );
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(
            creditLineConstants[_id].collateralAsset,
            creditLineConstants[_id].borrowAsset
        );

        uint256 _totalCollateralToken = calculateTotalCollateralTokens(_id);

        uint256 _currentDebt = calculateCurrentDebt(_id);

        uint256 _maxPossible = _totalCollateralToken.mul(_ratioOfPrices).div(creditLineConstants[_id].idealCollateralRatio).mul(10**30).div(
            10**_decimals
        );

        uint256 _borrowLimit = creditLineConstants[_id].borrowLimit;

        if (_maxPossible > _borrowLimit) {
            _maxPossible = _borrowLimit;
        }
        if (_maxPossible > _currentDebt) {
            return _maxPossible.sub(_currentDebt);
        }
        return 0;
    }

    function updateinterestAccruedTillLastPrincipalUpdate(uint256 _id) internal {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');

        uint256 _interestAccrued = calculateInterestAccrued(_id);
        uint256 _newInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(_interestAccrued);
        creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _newInterestAccrued;
    }

    function _depositCollateralFromSavingsAccount(
        uint256 _id,
        uint256 _amount,
        address _sender
    ) internal {
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        uint256 _activeAmount;

        for (uint256 _index = 0; _index < _strategyList.length; _index++) {
            address _strategy = _strategyList[_index];
            uint256 _liquidityShares = _savingsAccount.balanceInShares(_sender, _collateralAsset, _strategy);
            if (_liquidityShares == 0 || _strategyList[_index] == address(0)) {
                continue;
            }
            uint256 _tokenInStrategy = _liquidityShares;
            _tokenInStrategy = IYield(_strategy).getTokensForShares(_liquidityShares, _collateralAsset);

            uint256 _tokensToTransfer = _tokenInStrategy;
            if (_activeAmount.add(_tokenInStrategy) >= _amount) {
                _tokensToTransfer = (_amount.sub(_activeAmount));
            }
            _activeAmount = _activeAmount.add(_tokensToTransfer);
            _savingsAccount.transferFrom(_tokensToTransfer, _collateralAsset, _strategy, _sender, address(this));

            collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(
                _liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy)
            );

            if (_amount == _activeAmount) {
                return;
            }
        }
        revert('CreditLine::_depositCollateralFromSavingsAccount - Insufficient balance');
    }

    /**
     * @notice used to request a credit line either by borrower or lender
     * @param _requestTo Address to which creditLine is requested, 
                        if borrower creates request then lender address and 
                        if lender creates then borrower address
     * @param _borrowLimit maximum borrow amount in a credit line
     * @param _borrowRate Interest Rate at which credit Line is requested
     * @param _autoLiquidation if true, anyone can liquidate loan, otherwise only lender
     * @param _collateralRatio ratio of the collateral to the debt below which credit line can be liquidated
     * @param _borrowAsset address of the token to be borrowed
     * @param _collateralAsset address of the token provided as collateral
     * @param _requestAsLender if true, lender is placing request, otherwise borrower
     * @return identifier for the credit line
     */

    function request(
        address _requestTo,
        uint256 _borrowLimit,
        uint256 _borrowRate,
        bool _autoLiquidation,
        uint256 _collateralRatio,
        address _borrowAsset,
        address _collateralAsset,
        bool _requestAsLender
    ) external returns (uint256) {
        require(_borrowAsset != _collateralAsset, 'R: cant borrow lent token');
        require(IPriceOracle(priceOracle).doesFeedExist(_borrowAsset, _collateralAsset), 'R: No price feed');

        address _lender = _requestTo;
        address _borrower = msg.sender;
        if (_requestAsLender) {
            _lender = msg.sender;
            _borrower = _requestTo;
        }

        uint256 _id = _createRequest(
            _lender,
            _borrower,
            _borrowLimit,
            _borrowRate,
            _autoLiquidation,
            _collateralRatio,
            _borrowAsset,
            _collateralAsset,
            _requestAsLender
        );

        emit CreditLineRequested(_id, _lender, _borrower);
        return _id;
    }

    function _createRequest(
        address _lender,
        address _borrower,
        uint256 _borrowLimit,
        uint256 _borrowRate,
        bool _autoLiquidation,
        uint256 _collateralRatio,
        address _borrowAsset,
        address _collateralAsset,
        bool _requestByLender
    ) internal returns (uint256) {
        require(_lender != _borrower, 'Lender and Borrower cannot be same addresses');
        uint256 _id = creditLineCounter + 1;
        creditLineCounter = _id;
        creditLineVariables[_id].status = CreditLineStatus.REQUESTED;
        creditLineConstants[_id].borrower = _borrower;
        creditLineConstants[_id].lender = _lender;
        creditLineConstants[_id].borrowLimit = _borrowLimit;
        creditLineConstants[_id].autoLiquidation = _autoLiquidation;
        creditLineConstants[_id].idealCollateralRatio = _collateralRatio;
        creditLineConstants[_id].borrowRate = _borrowRate;
        creditLineConstants[_id].borrowAsset = _borrowAsset;
        creditLineConstants[_id].collateralAsset = _collateralAsset;
        creditLineConstants[_id].requestByLender = _requestByLender;
        return _id;
    }

    /**
     * @notice used to accept a credit line
     * @dev if borrower places request, lender can accept and vice versa
     * @param _id identifier for the credit line
     */
    function accept(uint256 _id) external {
        require(
            creditLineVariables[_id].status == CreditLineStatus.REQUESTED,
            'CreditLine::acceptCreditLineLender - CreditLine is already accepted'
        );
        bool _requestByLender = creditLineConstants[_id].requestByLender;
        require(
            (msg.sender == creditLineConstants[_id].borrower && _requestByLender) ||
                (msg.sender == creditLineConstants[_id].lender && !_requestByLender),
            "Only Borrower or Lender who hasn't requested can accept"
        );
        creditLineVariables[_id].status = CreditLineStatus.ACTIVE;
        emit CreditLineAccepted(_id);
    }

    /**
     * @notice used to deposit collateral into the credit line
     * @dev collateral tokens have to be approved in savingsAccount or token contract(unless ether).
            If transferred from savings account, the tokens are transferred from strategies in the 
            order prespecified in strategy registry
     * @param _id identifier for the credit line
     * @param _amount amount of collateral being deposited
     * @param _strategy strategy to which collateral is to be deposited in case transfer is not from savings account
     * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount 
                                otherwise direct from collateral token contract
     */
    function depositCollateral(
        uint256 _id,
        uint256 _amount,
        address _strategy,
        bool _fromSavingsAccount
    ) external payable nonReentrant ifCreditLineExists(_id) {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine not active');
        _depositCollateral(_id, _amount, _strategy, _fromSavingsAccount);
        emit CollateralDeposited(_id, _amount, _strategy);
    }

    function _depositCollateral(
        uint256 _id,
        uint256 _amount,
        address _strategy,
        bool _fromSavingsAccount
    ) internal {
        require(creditLineConstants[_id].lender != msg.sender, 'lender cant deposit collateral');
        if (_fromSavingsAccount) {
            _depositCollateralFromSavingsAccount(_id, _amount, msg.sender);
        } else {
            address _collateralAsset = creditLineConstants[_id].collateralAsset;
            ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
            if (_collateralAsset == address(0)) {
                require(msg.value == _amount, "CreditLine::_depositCollateral - value to transfer doesn't match argument");
            } else {
                IERC20(_collateralAsset).safeTransferFrom(msg.sender, address(this), _amount);
                IERC20(_collateralAsset).approve(_strategy, _amount);
            }
            uint256 _sharesReceived = _savingsAccount.deposit{value: msg.value}(_amount, _collateralAsset, _strategy, address(this));
            collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(_sharesReceived);
        }
    }

    function _withdrawBorrowAmount(
        address _asset,
        uint256 _amountInTokens,
        address _lender
    ) internal {
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        uint256 _activeAmount;
        for (uint256 _index = 0; _index < _strategyList.length; _index++) {
            if (_strategyList[_index] == address(0)) {
                continue;
            }
            uint256 _liquidityShares = _savingsAccount.balanceInShares(_lender, _asset, _strategyList[_index]);
            if (_liquidityShares != 0) {
                uint256 tokenInStrategy = _liquidityShares;
                tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);
                uint256 _tokensToTransfer = tokenInStrategy;
                if (_activeAmount.add(tokenInStrategy) >= _amountInTokens) {
                    _tokensToTransfer = (_amountInTokens.sub(_activeAmount));
                }
                _activeAmount = _activeAmount.add(_tokensToTransfer);
                _savingsAccount.withdrawFrom(_tokensToTransfer, _asset, _strategyList[_index], _lender, address(this), false);
                if (_activeAmount == _amountInTokens) {
                    return;
                }
            }
        }
        require(_activeAmount == _amountInTokens, 'insufficient balance');
    }

    /**
     * @notice used to borrow tokens from credit line by borrower
     * @dev only borrower can call this function. Amount that can actually be borrowed is 
            min(amount based on borrowLimit, allowance to creditLine contract, balance of lender)
     * @param _id identifier for the credit line
     * @param _amount amount of tokens to borrow
     */
    function borrow(uint256 _id, uint256 _amount) external payable nonReentrant onlyCreditLineBorrower(_id) {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');
        uint256 _borrowableAmount = calculateBorrowableAmount(_id);
        require(_amount <= _borrowableAmount, "CreditLine::borrow - The current collateral ratio doesn't allow to withdraw the amount");
        address _borrowAsset = creditLineConstants[_id].borrowAsset;
        address _lender = creditLineConstants[_id].lender;

        updateinterestAccruedTillLastPrincipalUpdate(_id);
        creditLineVariables[_id].principal = creditLineVariables[_id].principal.add(_amount);
        creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;

        uint256 _tokenDiffBalance;
        if (_borrowAsset != address(0)) {
            uint256 _balanceBefore = IERC20(_borrowAsset).balanceOf(address(this));
            _withdrawBorrowAmount(_borrowAsset, _amount, _lender);
            uint256 _balanceAfter = IERC20(_borrowAsset).balanceOf(address(this));
            _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);
        } else {
            uint256 _balanceBefore = address(this).balance;
            _withdrawBorrowAmount(_borrowAsset, _amount, _lender);
            uint256 _balanceAfter = address(this).balance;
            _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);
        }
        uint256 _protocolFee = _tokenDiffBalance.mul(protocolFeeFraction).div(10**30);
        _tokenDiffBalance = _tokenDiffBalance.sub(_protocolFee);

        if (_borrowAsset == address(0)) {
            (bool feeSuccess, ) = protocolFeeCollector.call{value: _protocolFee}('');
            require(feeSuccess, 'Transfer fail');
            (bool success, ) = msg.sender.call{value: _tokenDiffBalance}('');
            require(success, 'Transfer fail');
        } else {
            IERC20(_borrowAsset).safeTransfer(protocolFeeCollector, _protocolFee);
            IERC20(_borrowAsset).safeTransfer(msg.sender, _tokenDiffBalance);
        }
        emit BorrowedFromCreditLine(_id, _tokenDiffBalance);
    }

    function _repayFromSavingsAccount(
        uint256 _amount,
        address _asset,
        address _lender
    ) internal {
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        uint256 _activeAmount;

        for (uint256 _index = 0; _index < _strategyList.length; _index++) {
            if (_strategyList[_index] == address(0)) {
                continue;
            }
            uint256 _liquidityShares = _savingsAccount.balanceInShares(msg.sender, _asset, _strategyList[_index]);
            if (_liquidityShares == 0) {
                continue;
            }
            uint256 _tokenInStrategy = _liquidityShares;
            _tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);

            uint256 _tokensToTransfer = _tokenInStrategy;
            if (_activeAmount.add(_tokenInStrategy) >= _amount) {
                _tokensToTransfer = (_amount.sub(_activeAmount));
            }
            _activeAmount = _activeAmount.add(_tokensToTransfer);
            _savingsAccount.transferFrom(_tokensToTransfer, _asset, _strategyList[_index], msg.sender, _lender);

            if (_amount == _activeAmount) {
                return;
            }
        }
        revert('CreditLine::_repayFromSavingsAccount - Insufficient balance');
    }

    function _repay(
        uint256 _id,
        uint256 _amount,
        bool _fromSavingsAccount,
        uint256 _principalPaid
    ) internal {
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        address _defaultStrategy = defaultStrategy;
        address _borrowAsset = creditLineConstants[_id].borrowAsset;
        address _lender = creditLineConstants[_id].lender;
        if (!_fromSavingsAccount) {
            if (_borrowAsset == address(0)) {
                require(msg.value == _amount, 'creditLine::repay - Ether sent not equal to repay amount');
                _savingsAccount.deposit{value: _amount}(_amount, _borrowAsset, _defaultStrategy, _lender);
            } else {
                IERC20(_borrowAsset).safeTransferFrom(msg.sender, address(this), _amount);
                IERC20(_borrowAsset).approve(_defaultStrategy, _amount);
                _savingsAccount.deposit(_amount, _borrowAsset, _defaultStrategy, _lender);
            }
        } else {
            _repayFromSavingsAccount(_amount, _borrowAsset, _lender);
        }
        if (_principalPaid != 0) {
            _savingsAccount.increaseAllowanceToCreditLine(_principalPaid, _borrowAsset, _lender);
        }
    }

    /**
     * @notice used to repay interest and principal to credit line. Interest has to be repaid before repaying principal
     * @dev partial repayments possible
     * @param _id identifier for the credit line
     * @param _amount amount being repaid
     * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount 
                                otherwise direct from collateral token contract
     */
    function repay(
        uint256 _id,
        uint256 _amount,
        bool _fromSavingsAccount
    ) external payable nonReentrant {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');
        require(creditLineConstants[_id].lender != msg.sender, 'Lender cant repay');

        uint256 _interestSincePrincipalUpdate = calculateInterestAccrued(_id);
        uint256 _totalInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(
            _interestSincePrincipalUpdate
        );
        uint256 _interestToPay = _totalInterestAccrued.sub(creditLineVariables[_id].totalInterestRepaid);
        uint256 _totalCurrentDebt = _interestToPay.add(creditLineVariables[_id].principal);
        uint256 _principalPaid = 0;

        if (_amount >= _totalCurrentDebt) {
            _amount = _totalCurrentDebt;
            emit CompleteCreditLineRepaid(_id, _amount);
        } else {
            emit PartialCreditLineRepaid(_id, _amount);
        }

        if (_amount > _interestToPay) {
            creditLineVariables[_id].principal = _totalCurrentDebt.sub(_amount);
            creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _totalInterestAccrued;
            creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;
            creditLineVariables[_id].totalInterestRepaid = _totalInterestAccrued;
            _principalPaid = _amount.sub(_interestToPay);
        } else {
            creditLineVariables[_id].totalInterestRepaid = creditLineVariables[_id].totalInterestRepaid.add(_amount);
        }

        _repay(_id, _amount, _fromSavingsAccount, _principalPaid);

        if (creditLineVariables[_id].principal == 0) {
            _resetCreditLine(_id);
        }
    }

    function _resetCreditLine(uint256 _id) internal {
        creditLineVariables[_id].lastPrincipalUpdateTime = 0;
        creditLineVariables[_id].totalInterestRepaid = 0;
        creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = 0;
        emit CreditLineReset(_id);
    }

    /**
     * @dev used to close credit line by borrower or lender
     * @param _id identifier for the credit line
     */
    function close(uint256 _id) external ifCreditLineExists(_id) {
        require(
            msg.sender == creditLineConstants[_id].borrower || msg.sender == creditLineConstants[_id].lender,
            'CreditLine: Permission denied while closing Line of credit'
        );
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: Credit line should be active.');
        require(creditLineVariables[_id].principal == 0, 'CreditLine: Cannot be closed since not repaid.');
        require(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate == 0, 'CreditLine: Cannot be closed since not repaid.');
        creditLineVariables[_id].status = CreditLineStatus.CLOSED;
        emit CreditLineClosed(_id);
    }

    /**
     * @notice used to calculate the current collateral ratio
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view.
            Interest is also considered while calculating debt
     * @param _id identifier for the credit line
     * @return collateral ratio multiplied by 10**30 to retain precision
     */
    function calculateCurrentCollateralRatio(uint256 _id) public ifCreditLineExists(_id) returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(
            creditLineConstants[_id].collateralAsset,
            creditLineConstants[_id].borrowAsset
        );

        uint256 currentDebt = calculateCurrentDebt(_id);
        uint256 currentCollateralRatio = calculateTotalCollateralTokens(_id).mul(_ratioOfPrices).div(currentDebt).mul(10**30).div(
            10**_decimals
        );

        return currentCollateralRatio;
    }

    /**
     * @notice used to calculate the total collateral tokens
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @param _id identifier for the credit line
     * @return _amount total collateral tokens deposited into the credit line
     */
    function calculateTotalCollateralTokens(uint256 _id) public returns (uint256 _amount) {
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        uint256 _liquidityShares;
        for (uint256 index = 0; index < _strategyList.length; index++) {
            if (_strategyList[index] == address(0)) {
                continue;
            }
            _liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];
            uint256 _tokenInStrategy = _liquidityShares;
            _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(_liquidityShares, _collateralAsset);

            _amount = _amount.add(_tokenInStrategy);
        }
    }

    /**
     * @notice used to withdraw any excess collateral
     * @dev collateral can't be withdraw if collateralRatio goes below the ideal value. Only borrower can withdraw
     * @param _id identifier for the credit line
     * @param _amount amount of collateral to withdraw
     * @param _toSavingsAccount if true, tokens are transferred from savingsAccount 
                                otherwise direct from collateral token contract
     */
    function withdrawCollateral(
        uint256 _id,
        uint256 _amount,
        bool _toSavingsAccount
    ) external nonReentrant onlyCreditLineBorrower(_id) {
        uint256 _withdrawableCollateral = withdrawableCollateral(_id);
        require(_amount <= _withdrawableCollateral, 'Collateral ratio cant go below ideal');
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        _transferCollateral(_id, _collateralAsset, _amount, _toSavingsAccount);
        emit CollateralWithdrawn(_id, _amount);
    }

    /**
     * @notice used to calculate the collateral that can be withdrawn
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @param _id identifier for the credit line
     * @return total collateral withdrawable by borrower
     */
    function withdrawableCollateral(uint256 _id) public returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(
            creditLineConstants[_id].collateralAsset,
            creditLineConstants[_id].borrowAsset
        );

        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);
        uint256 _currentDebt = calculateCurrentDebt(_id);

        uint256 _collateralNeeded = _currentDebt
            .mul(creditLineConstants[_id].idealCollateralRatio)
            .div(_ratioOfPrices)
            .mul(10**_decimals)
            .div(10**30);

        if (_collateralNeeded >= _totalCollateralTokens) {
            return 0;
        }
        return _totalCollateralTokens.sub(_collateralNeeded);
    }

    function _transferCollateral(
        uint256 _id,
        address _asset,
        uint256 _amountInTokens,
        bool _toSavingsAccount
    ) internal {
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        uint256 _activeAmount;
        for (uint256 index = 0; index < _strategyList.length; index++) {
            uint256 liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];
            if (liquidityShares == 0 || _strategyList[index] == address(0)) {
                continue;
            }
            uint256 _tokenInStrategy = liquidityShares;
            _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(liquidityShares, _asset);
            uint256 _tokensToTransfer = _tokenInStrategy;
            if (_activeAmount.add(_tokenInStrategy) > _amountInTokens) {
                _tokensToTransfer = _amountInTokens.sub(_activeAmount);
                liquidityShares = liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy);
            }
            _activeAmount = _activeAmount.add(_tokensToTransfer);
            collateralShareInStrategy[_id][_strategyList[index]] = collateralShareInStrategy[_id][_strategyList[index]].sub(
                liquidityShares
            );
            if (_toSavingsAccount) {
                ISavingsAccount(savingsAccount).transfer(_tokensToTransfer, _asset, _strategyList[index], msg.sender);
            } else {
                ISavingsAccount(savingsAccount).withdraw(_tokensToTransfer, _asset, _strategyList[index], msg.sender, false);
            }

            if (_activeAmount == _amountInTokens) {
                return;
            }
        }
        revert('insufficient collateral');
    }

    /**
     * @notice used to liquidate credit line in case collateral ratio goes below the threshold
     * @dev if lender liquidates, then collateral is directly transferred. 
            If autoLiquidation is true, anyone can liquidate by providing enough borrow tokens
     * @param _id identifier for the credit line
     * @param _toSavingsAccount if true, tokens are transferred from savingsAccount 
                                otherwise direct from collateral token contract
     */
    function liquidate(uint256 _id, bool _toSavingsAccount) external payable nonReentrant {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: Credit line should be active.');
        require(creditLineVariables[_id].principal != 0, 'CreditLine: cannot liquidate if principal is 0');

        uint256 currentCollateralRatio = calculateCurrentCollateralRatio(_id);
        require(
            currentCollateralRatio < creditLineConstants[_id].idealCollateralRatio,
            'CreditLine: Collateral ratio is higher than ideal value'
        );

        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        address _lender = creditLineConstants[_id].lender;
        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);
        address _borrowAsset = creditLineConstants[_id].borrowAsset;

        creditLineVariables[_id].status = CreditLineStatus.LIQUIDATED;

        if (creditLineConstants[_id].autoLiquidation && _lender != msg.sender) {
            uint256 _borrowTokens = _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens);
            if (_borrowAsset == address(0)) {
                uint256 _returnETH = msg.value.sub(_borrowTokens, 'Insufficient ETH to liquidate');
                if (_returnETH != 0) {
                    (bool success, ) = msg.sender.call{value: _returnETH}('');
                    require(success, 'Transfer fail');
                }
            } else {
                IERC20(_borrowAsset).safeTransferFrom(msg.sender, _lender, _borrowTokens);
            }
        }

        _transferCollateral(_id, _collateralAsset, _totalCollateralTokens, _toSavingsAccount);

        emit CreditLineLiquidated(_id, msg.sender);
    }

    /**
     * @notice used to calculate the borrow tokens necessary for liquidator to liquidate
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @param _id identifier for the credit line
     * @return borrow tokens necessary for liquidator to liquidate
     */
    function borrowTokensToLiquidate(uint256 _id) external returns (uint256) {
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);
        address _borrowAsset = creditLineConstants[_id].borrowAsset;

        return _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens);
    }

    function _borrowTokensToLiquidate(
        address _borrowAsset,
        address _collateralAsset,
        uint256 _totalCollateralTokens
    ) internal view returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(_borrowAsset, _collateralAsset);
        uint256 _borrowTokens = (
            _totalCollateralTokens.mul(uint256(10**30).sub(liquidatorRewardFraction)).div(10**30).mul(_ratioOfPrices).div(10**_decimals)
        );

        return _borrowTokens;
    }

    receive() external payable {
        require(msg.sender == savingsAccount, 'CreditLine::receive invalid transaction');
    }
}
".
Ideas: " Security".
As the Security Analyst, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability.
For each vulnerability identified, use the following format:
VULNERABILITY NAME or TYPE
```
DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix.
```
Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: "<INFO> Analysis Complete."

[2024-22-08 11:43:14 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-22-08 11:43:14 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 20047
completion_tokens: 1
total_tokens: 20048
cost: $-1.000000


[2024-22-08 11:43:14 INFO] Security Analyst: **Security Analyst<->Solidity Programming Expert on : ContractReviewComment, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/utils/ReentrancyGuard.sol';
import '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';
import '../interfaces/IPriceOracle.sol';
import '../interfaces/IYield.sol';
import '../interfaces/ISavingsAccount.sol';
import '../SavingsAccount/SavingsAccountUtil.sol';
import '../interfaces/IStrategyRegistry.sol';

/**
 * @title Credit Line contract with Methods related to credit Line
 * @notice Implements the functions related to Credit Line
 * @author Sublime
 **/

contract CreditLine is ReentrancyGuard, OwnableUpgradeable {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    enum CreditLineStatus {
        NOT_CREATED,
        REQUESTED,
        ACTIVE,
        CLOSED,
        CANCELLED,
        LIQUIDATED
    }

    /**
     * @notice counter that tracks the number of credit lines created
     * @dev used to create unique identifier for credit lines
     **/
    uint256 public creditLineCounter;

    uint256 constant YEAR_IN_SECONDS = 365 days;

    struct CreditLineVariables {
        CreditLineStatus status;
        uint256 principal;
        uint256 totalInterestRepaid;
        uint256 lastPrincipalUpdateTime;
        uint256 interestAccruedTillLastPrincipalUpdate;
    }

    struct CreditLineConstants {
        address lender;
        address borrower;
        uint256 borrowLimit;
        uint256 idealCollateralRatio;
        uint256 borrowRate;
        address borrowAsset;
        address collateralAsset;
        bool autoLiquidation;
        bool requestByLender;
    }
    /**
     * @notice stores the collateral shares in a credit line per strategy
     * @dev creditLineId => Strategy => collateralShares
     **/
    mapping(uint256 => mapping(address => uint256)) public collateralShareInStrategy;

    /**
     * @notice stores the variables to maintain a credit line
     **/
    mapping(uint256 => CreditLineVariables) public creditLineVariables;

    /**
     * @notice stores the constants related to a credit line
     **/
    mapping(uint256 => CreditLineConstants) public creditLineConstants;

    /**
     * @notice stores the address of savings account contract
     **/
    address public savingsAccount;

    /**
     * @notice stores the address of price oracle contract
     **/
    address public priceOracle;

    /**
     * @notice stores the address of strategy registry contract
     **/
    address public strategyRegistry;

    /**
     * @notice stores the address of default strategy
     **/
    address public defaultStrategy;

    /**
     * @notice stores the fraction of borrowed amount charged as fee by protocol
     * @dev it is multiplied by 10**30
     **/
    uint256 public protocolFeeFraction;

    /**
     * @notice address where protocol fee is collected
     **/
    address public protocolFeeCollector;

    /**
     * @notice stores the fraction of amount liquidated given as reward to liquidator
     * @dev it is multiplied by 10**30
     **/
    uint256 public liquidatorRewardFraction;
    /**
     * @dev checks if Credit Line exists
     * @param _id identifier for the credit line
     **/
    modifier ifCreditLineExists(uint256 _id) {
        require(creditLineVariables[_id].status != CreditLineStatus.NOT_CREATED, 'Credit line does not exist');
        _;
    }

    /**
     * @dev checks if called by credit Line Borrower
     * @param _id creditLine identifier
     **/
    modifier onlyCreditLineBorrower(uint256 _id) {
        require(creditLineConstants[_id].borrower == msg.sender, 'Only credit line Borrower can access');
        _;
    }

    /**
     * @dev checks if called by credit Line Lender
     * @param _id creditLine identifier
     **/
    modifier onlyCreditLineLender(uint256 _id) {
        require(creditLineConstants[_id].lender == msg.sender, 'Only credit line Lender can access');
        _;
    }

    /**
     * @notice emitted when a collateral is deposited into credit line
     * @param id id of the credit line
     * @param amount amount of collateral deposited
     * @param strategy address of the strategy into which collateral is deposited
     */
    event CollateralDeposited(uint256 indexed id, uint256 amount, address indexed strategy);

    /**
     * @notice emitted when collateral is withdrawn from credit line
     * @param id id of the credit line
     * @param amount amount of collateral withdrawn
     */
    event CollateralWithdrawn(uint256 indexed id, uint256 amount);

    /**
     * @notice emitted when a request for new credit line is placed
     * @param id id of the credit line for which request was made
     * @param lender address of the lender for credit line
     * @param borrower address of the borrower for credit line
     */
    event CreditLineRequested(uint256 indexed id, address indexed lender, address indexed borrower);

    /**
     * @notice emitted when a credit line is liquidated
     * @param id id of the credit line which is liquidated
     * @param liquidator address of the liquidator
     */
    event CreditLineLiquidated(uint256 indexed id, address indexed liquidator);

    /**
     * @notice emitted when tokens are borrowed from credit line
     * @param id id of the credit line from which tokens are borrowed
     * @param borrowAmount amount of tokens borrowed
     */
    event BorrowedFromCreditLine(uint256 indexed id, uint256 borrowAmount);

    /**
     * @notice emitted when credit line is accepted
     * @param id id of the credit line that was accepted
     */
    event CreditLineAccepted(uint256 indexed id);

    /**
     * @notice emitted when credit line is completely repaid and reset
     * @param id id of the credit line that is reset
     */
    event CreditLineReset(uint256 indexed id);

    /**
     * @notice emitted when the credit line is partially repaid
     * @param id id of the credit line
     * @param repayAmount amount repaid
     */
    event PartialCreditLineRepaid(uint256 indexed id, uint256 repayAmount);

    /**
     * @notice emitted when the credit line is completely repaid
     * @param id id of the credit line
     * @param repayAmount amount repaid
     */
    event CompleteCreditLineRepaid(uint256 indexed id, uint256 repayAmount);

    /**
     * @notice emitted when the credit line is closed by one of the parties of credit line
     * @param id id of the credit line
     */
    event CreditLineClosed(uint256 indexed id);

    /**
     * @notice emitted when default strategy for the credit line is updated
     * @param defaultStrategy address of the strategy contract that is used as default by credit lines
     */
    event DefaultStrategyUpdated(address indexed defaultStrategy);

    /**
     * @notice emitted when the price oracle is updated
     * @param priceOracle address of the updated price oracle
     */
    event PriceOracleUpdated(address indexed priceOracle);

    /**
     * @notice emitted when the savings account address is updated
     * @param savingsAccount address of the updated savingsAccount
     */
    event SavingsAccountUpdated(address indexed savingsAccount);

    /**
     * @notice emitted when strategy registry address is updated
     * @param strategyRegistry address of the updated strategy registry
     */
    event StrategyRegistryUpdated(address indexed strategyRegistry);

    /**
     * @notice emitted when fee that protocol charges for credit line is updated
     * @param updatedProtocolFee updated value of protocolFeeFraction
     */
    event ProtocolFeeFractionUpdated(uint256 updatedProtocolFee);

    /**
     * @notice emitted when address which receives fee that protocol changes for pools is updated
     * @param updatedProtocolFeeCollector updated value of protocolFeeCollector
     */
    event ProtocolFeeCollectorUpdated(address indexed updatedProtocolFeeCollector);

    /**
     * @notice emitted when liquidatorRewardFraction is updated
     * @param liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator
     */
    event LiquidationRewardFractionUpdated(uint256 liquidatorRewardFraction);

    /**
     * @notice used to initialize the contract
     * @dev can only be called once during the life cycle of the contract
     * @param _defaultStrategy default strategy used in credit lines
     * @param _priceOracle address of the priceOracle
     * @param _savingsAccount address of  the savings account contract
     * @param _strategyRegistry address of the strategy registry contract
     * @param _owner address of owner who can change global variables
     * @param _protocolFeeFraction fraction of the fee charged by protocol
     * @param _protocolFeeCollector address to which protocol fee is charged to
     * @param _liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator
     */
    function initialize(
        address _defaultStrategy,
        address _priceOracle,
        address _savingsAccount,
        address _strategyRegistry,
        address _owner,
        uint256 _protocolFeeFraction,
        address _protocolFeeCollector,
        uint256 _liquidatorRewardFraction
    ) external initializer {
        OwnableUpgradeable.__Ownable_init();
        OwnableUpgradeable.transferOwnership(_owner);

        _updateDefaultStrategy(_defaultStrategy);
        _updatePriceOracle(_priceOracle);
        _updateSavingsAccount(_savingsAccount);
        _updateStrategyRegistry(_strategyRegistry);
        _updateProtocolFeeFraction(_protocolFeeFraction);
        _updateProtocolFeeCollector(_protocolFeeCollector);
        _updateLiquidatorRewardFraction(_liquidatorRewardFraction);
    }

    /**
     * @notice used to update the default strategy
     * @dev can only be updated by owner
     * @param _defaultStrategy address of the updated default strategy
     */
    function updateDefaultStrategy(address _defaultStrategy) external onlyOwner {
        _updateDefaultStrategy(_defaultStrategy);
    }

    function _updateDefaultStrategy(address _defaultStrategy) internal {
        defaultStrategy = _defaultStrategy;
        emit DefaultStrategyUpdated(_defaultStrategy);
    }

    /**
     * @notice used to update the price oracle
     * @dev can only be updated by owner
     * @param _priceOracle address of the updated price oracle
     */
    function updatePriceOracle(address _priceOracle) external onlyOwner {
        _updatePriceOracle(_priceOracle);
    }

    function _updatePriceOracle(address _priceOracle) internal {
        priceOracle = _priceOracle;
        emit PriceOracleUpdated(_priceOracle);
    }

    /**
     * @notice used to update the savings account address
     * @dev can only be updated by owner
     * @param _savingsAccount address of the updated savings account
     */
    function updateSavingsAccount(address _savingsAccount) external onlyOwner {
        _updateSavingsAccount(_savingsAccount);
    }

    function _updateSavingsAccount(address _savingsAccount) internal {
        savingsAccount = _savingsAccount;
        emit SavingsAccountUpdated(_savingsAccount);
    }

    /**
     * @notice used to update the protocol fee fraction
     * @dev can only be updated by owner
     * @param _protocolFee fraction of the borrower amount collected as protocol fee
     */
    function updateProtocolFeeFraction(uint256 _protocolFee) external onlyOwner {
        _updateProtocolFeeFraction(_protocolFee);
    }

    function _updateProtocolFeeFraction(uint256 _protocolFee) internal {
        protocolFeeFraction = _protocolFee;
        emit ProtocolFeeFractionUpdated(_protocolFee);
    }

    /**
     * @notice used to update the protocol fee collector
     * @dev can only be updated by owner
     * @param _protocolFeeCollector address in which protocol fee is collected
     */
    function updateProtocolFeeCollector(address _protocolFeeCollector) external onlyOwner {
        _updateProtocolFeeCollector(_protocolFeeCollector);
    }

    function _updateProtocolFeeCollector(address _protocolFeeCollector) internal {
        require(_protocolFeeCollector != address(0), 'cant be 0 address');
        protocolFeeCollector = _protocolFeeCollector;
        emit ProtocolFeeCollectorUpdated(_protocolFeeCollector);
    }

    /**
     * @notice used to update the strategy registry address
     * @dev can only be updated by owner
     * @param _strategyRegistry address of the updated strategy registry
     */
    function updateStrategyRegistry(address _strategyRegistry) external onlyOwner {
        _updateStrategyRegistry(_strategyRegistry);
    }

    function _updateStrategyRegistry(address _strategyRegistry) internal {
        require(_strategyRegistry != address(0), 'CL::I zero address');
        strategyRegistry = _strategyRegistry;
        emit StrategyRegistryUpdated(_strategyRegistry);
    }

    /**
     * @notice used to update the liquidatorRewardFraction
     * @dev can only be updated by owner
     * @param _rewardFraction fraction of liquidated amount given to liquidator as reward
     */
    function updateLiquidatorRewardFraction(uint256 _rewardFraction) external onlyOwner {
        _updateLiquidatorRewardFraction(_rewardFraction);
    }

    function _updateLiquidatorRewardFraction(uint256 _rewardFraction) internal {
        require(_rewardFraction <= 10**30, 'Fraction has to be less than 1');
        liquidatorRewardFraction = _rewardFraction;
        emit LiquidationRewardFractionUpdated(_rewardFraction);
    }

    /**
     * @dev Used to Calculate Interest Per second on given principal and Interest rate
     * @param _principal principal Amount for which interest has to be calculated.
     * @param _borrowRate It is the Interest Rate at which Credit Line is approved
     * @return interest per second for the given parameters
     */
    function calculateInterest(
        uint256 _principal,
        uint256 _borrowRate,
        uint256 _timeElapsed
    ) public pure returns (uint256) {
        uint256 _interest = _principal.mul(_borrowRate).mul(_timeElapsed).div(10**30).div(YEAR_IN_SECONDS);

        return _interest;
    }

    /**
     * @dev Used to calculate interest accrued since last repayment
     * @param _id identifier for the credit line
     * @return interest accrued over current borrowed amount since last repayment
     */

    function calculateInterestAccrued(uint256 _id) public view returns (uint256) {
        uint256 _lastPrincipalUpdateTime = creditLineVariables[_id].lastPrincipalUpdateTime;
        if (_lastPrincipalUpdateTime == 0) return 0;
        uint256 _timeElapsed = (block.timestamp).sub(_lastPrincipalUpdateTime);
        uint256 _interestAccrued = calculateInterest(creditLineVariables[_id].principal, creditLineConstants[_id].borrowRate, _timeElapsed);
        return _interestAccrued;
    }

    /**
     * @dev Used to calculate current debt of borrower against a credit line.
     * @param _id identifier for the credit line
     * @return current debt of borrower
     */
    function calculateCurrentDebt(uint256 _id) public view returns (uint256) {
        uint256 _interestAccrued = calculateInterestAccrued(_id);
        uint256 _currentDebt = (creditLineVariables[_id].principal)
            .add(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate)
            .add(_interestAccrued)
            .sub(creditLineVariables[_id].totalInterestRepaid);
        return _currentDebt;
    }

    /**
     * @notice used to calculate amount that can be borrowed by the borrower
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view.
            borrowableAmount changes per block as interest changes per block.
     * @param _id identifier for the credit line
     * @return amount that can be borrowed from the credit line
     */
    function calculateBorrowableAmount(uint256 _id) public returns (uint256) {
        CreditLineStatus _status = creditLineVariables[_id].status;
        require(
            _status == CreditLineStatus.ACTIVE || _status == CreditLineStatus.REQUESTED,
            'CreditLine: Cannot only if credit line ACTIVE or REQUESTED'
        );
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(
            creditLineConstants[_id].collateralAsset,
            creditLineConstants[_id].borrowAsset
        );

        uint256 _totalCollateralToken = calculateTotalCollateralTokens(_id);

        uint256 _currentDebt = calculateCurrentDebt(_id);

        uint256 _maxPossible = _totalCollateralToken.mul(_ratioOfPrices).div(creditLineConstants[_id].idealCollateralRatio).mul(10**30).div(
            10**_decimals
        );

        uint256 _borrowLimit = creditLineConstants[_id].borrowLimit;

        if (_maxPossible > _borrowLimit) {
            _maxPossible = _borrowLimit;
        }
        if (_maxPossible > _currentDebt) {
            return _maxPossible.sub(_currentDebt);
        }
        return 0;
    }

    function updateinterestAccruedTillLastPrincipalUpdate(uint256 _id) internal {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');

        uint256 _interestAccrued = calculateInterestAccrued(_id);
        uint256 _newInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(_interestAccrued);
        creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _newInterestAccrued;
    }

    function _depositCollateralFromSavingsAccount(
        uint256 _id,
        uint256 _amount,
        address _sender
    ) internal {
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        uint256 _activeAmount;

        for (uint256 _index = 0; _index < _strategyList.length; _index++) {
            address _strategy = _strategyList[_index];
            uint256 _liquidityShares = _savingsAccount.balanceInShares(_sender, _collateralAsset, _strategy);
            if (_liquidityShares == 0 || _strategyList[_index] == address(0)) {
                continue;
            }
            uint256 _tokenInStrategy = _liquidityShares;
            _tokenInStrategy = IYield(_strategy).getTokensForShares(_liquidityShares, _collateralAsset);

            uint256 _tokensToTransfer = _tokenInStrategy;
            if (_activeAmount.add(_tokenInStrategy) >= _amount) {
                _tokensToTransfer = (_amount.sub(_activeAmount));
            }
            _activeAmount = _activeAmount.add(_tokensToTransfer);
            _savingsAccount.transferFrom(_tokensToTransfer, _collateralAsset, _strategy, _sender, address(this));

            collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(
                _liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy)
            );

            if (_amount == _activeAmount) {
                return;
            }
        }
        revert('CreditLine::_depositCollateralFromSavingsAccount - Insufficient balance');
    }

    /**
     * @notice used to request a credit line either by borrower or lender
     * @param _requestTo Address to which creditLine is requested, 
                        if borrower creates request then lender address and 
                        if lender creates then borrower address
     * @param _borrowLimit maximum borrow amount in a credit line
     * @param _borrowRate Interest Rate at which credit Line is requested
     * @param _autoLiquidation if true, anyone can liquidate loan, otherwise only lender
     * @param _collateralRatio ratio of the collateral to the debt below which credit line can be liquidated
     * @param _borrowAsset address of the token to be borrowed
     * @param _collateralAsset address of the token provided as collateral
     * @param _requestAsLender if true, lender is placing request, otherwise borrower
     * @return identifier for the credit line
     */

    function request(
        address _requestTo,
        uint256 _borrowLimit,
        uint256 _borrowRate,
        bool _autoLiquidation,
        uint256 _collateralRatio,
        address _borrowAsset,
        address _collateralAsset,
        bool _requestAsLender
    ) external returns (uint256) {
        require(_borrowAsset != _collateralAsset, 'R: cant borrow lent token');
        require(IPriceOracle(priceOracle).doesFeedExist(_borrowAsset, _collateralAsset), 'R: No price feed');

        address _lender = _requestTo;
        address _borrower = msg.sender;
        if (_requestAsLender) {
            _lender = msg.sender;
            _borrower = _requestTo;
        }

        uint256 _id = _createRequest(
            _lender,
            _borrower,
            _borrowLimit,
            _borrowRate,
            _autoLiquidation,
            _collateralRatio,
            _borrowAsset,
            _collateralAsset,
            _requestAsLender
        );

        emit CreditLineRequested(_id, _lender, _borrower);
        return _id;
    }

    function _createRequest(
        address _lender,
        address _borrower,
        uint256 _borrowLimit,
        uint256 _borrowRate,
        bool _autoLiquidation,
        uint256 _collateralRatio,
        address _borrowAsset,
        address _collateralAsset,
        bool _requestByLender
    ) internal returns (uint256) {
        require(_lender != _borrower, 'Lender and Borrower cannot be same addresses');
        uint256 _id = creditLineCounter + 1;
        creditLineCounter = _id;
        creditLineVariables[_id].status = CreditLineStatus.REQUESTED;
        creditLineConstants[_id].borrower = _borrower;
        creditLineConstants[_id].lender = _lender;
        creditLineConstants[_id].borrowLimit = _borrowLimit;
        creditLineConstants[_id].autoLiquidation = _autoLiquidation;
        creditLineConstants[_id].idealCollateralRatio = _collateralRatio;
        creditLineConstants[_id].borrowRate = _borrowRate;
        creditLineConstants[_id].borrowAsset = _borrowAsset;
        creditLineConstants[_id].collateralAsset = _collateralAsset;
        creditLineConstants[_id].requestByLender = _requestByLender;
        return _id;
    }

    /**
     * @notice used to accept a credit line
     * @dev if borrower places request, lender can accept and vice versa
     * @param _id identifier for the credit line
     */
    function accept(uint256 _id) external {
        require(
            creditLineVariables[_id].status == CreditLineStatus.REQUESTED,
            'CreditLine::acceptCreditLineLender - CreditLine is already accepted'
        );
        bool _requestByLender = creditLineConstants[_id].requestByLender;
        require(
            (msg.sender == creditLineConstants[_id].borrower && _requestByLender) ||
                (msg.sender == creditLineConstants[_id].lender && !_requestByLender),
            "Only Borrower or Lender who hasn't requested can accept"
        );
        creditLineVariables[_id].status = CreditLineStatus.ACTIVE;
        emit CreditLineAccepted(_id);
    }

    /**
     * @notice used to deposit collateral into the credit line
     * @dev collateral tokens have to be approved in savingsAccount or token contract(unless ether).
            If transferred from savings account, the tokens are transferred from strategies in the 
            order prespecified in strategy registry
     * @param _id identifier for the credit line
     * @param _amount amount of collateral being deposited
     * @param _strategy strategy to which collateral is to be deposited in case transfer is not from savings account
     * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount 
                                otherwise direct from collateral token contract
     */
    function depositCollateral(
        uint256 _id,
        uint256 _amount,
        address _strategy,
        bool _fromSavingsAccount
    ) external payable nonReentrant ifCreditLineExists(_id) {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine not active');
        _depositCollateral(_id, _amount, _strategy, _fromSavingsAccount);
        emit CollateralDeposited(_id, _amount, _strategy);
    }

    function _depositCollateral(
        uint256 _id,
        uint256 _amount,
        address _strategy,
        bool _fromSavingsAccount
    ) internal {
        require(creditLineConstants[_id].lender != msg.sender, 'lender cant deposit collateral');
        if (_fromSavingsAccount) {
            _depositCollateralFromSavingsAccount(_id, _amount, msg.sender);
        } else {
            address _collateralAsset = creditLineConstants[_id].collateralAsset;
            ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
            if (_collateralAsset == address(0)) {
                require(msg.value == _amount, "CreditLine::_depositCollateral - value to transfer doesn't match argument");
            } else {
                IERC20(_collateralAsset).safeTransferFrom(msg.sender, address(this), _amount);
                IERC20(_collateralAsset).approve(_strategy, _amount);
            }
            uint256 _sharesReceived = _savingsAccount.deposit{value: msg.value}(_amount, _collateralAsset, _strategy, address(this));
            collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(_sharesReceived);
        }
    }

    function _withdrawBorrowAmount(
        address _asset,
        uint256 _amountInTokens,
        address _lender
    ) internal {
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        uint256 _activeAmount;
        for (uint256 _index = 0; _index < _strategyList.length; _index++) {
            if (_strategyList[_index] == address(0)) {
                continue;
            }
            uint256 _liquidityShares = _savingsAccount.balanceInShares(_lender, _asset, _strategyList[_index]);
            if (_liquidityShares != 0) {
                uint256 tokenInStrategy = _liquidityShares;
                tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);
                uint256 _tokensToTransfer = tokenInStrategy;
                if (_activeAmount.add(tokenInStrategy) >= _amountInTokens) {
                    _tokensToTransfer = (_amountInTokens.sub(_activeAmount));
                }
                _activeAmount = _activeAmount.add(_tokensToTransfer);
                _savingsAccount.withdrawFrom(_tokensToTransfer, _asset, _strategyList[_index], _lender, address(this), false);
                if (_activeAmount == _amountInTokens) {
                    return;
                }
            }
        }
        require(_activeAmount == _amountInTokens, 'insufficient balance');
    }

    /**
     * @notice used to borrow tokens from credit line by borrower
     * @dev only borrower can call this function. Amount that can actually be borrowed is 
            min(amount based on borrowLimit, allowance to creditLine contract, balance of lender)
     * @param _id identifier for the credit line
     * @param _amount amount of tokens to borrow
     */
    function borrow(uint256 _id, uint256 _amount) external payable nonReentrant onlyCreditLineBorrower(_id) {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');
        uint256 _borrowableAmount = calculateBorrowableAmount(_id);
        require(_amount <= _borrowableAmount, "CreditLine::borrow - The current collateral ratio doesn't allow to withdraw the amount");
        address _borrowAsset = creditLineConstants[_id].borrowAsset;
        address _lender = creditLineConstants[_id].lender;

        updateinterestAccruedTillLastPrincipalUpdate(_id);
        creditLineVariables[_id].principal = creditLineVariables[_id].principal.add(_amount);
        creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;

        uint256 _tokenDiffBalance;
        if (_borrowAsset != address(0)) {
            uint256 _balanceBefore = IERC20(_borrowAsset).balanceOf(address(this));
            _withdrawBorrowAmount(_borrowAsset, _amount, _lender);
            uint256 _balanceAfter = IERC20(_borrowAsset).balanceOf(address(this));
            _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);
        } else {
            uint256 _balanceBefore = address(this).balance;
            _withdrawBorrowAmount(_borrowAsset, _amount, _lender);
            uint256 _balanceAfter = address(this).balance;
            _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);
        }
        uint256 _protocolFee = _tokenDiffBalance.mul(protocolFeeFraction).div(10**30);
        _tokenDiffBalance = _tokenDiffBalance.sub(_protocolFee);

        if (_borrowAsset == address(0)) {
            (bool feeSuccess, ) = protocolFeeCollector.call{value: _protocolFee}('');
            require(feeSuccess, 'Transfer fail');
            (bool success, ) = msg.sender.call{value: _tokenDiffBalance}('');
            require(success, 'Transfer fail');
        } else {
            IERC20(_borrowAsset).safeTransfer(protocolFeeCollector, _protocolFee);
            IERC20(_borrowAsset).safeTransfer(msg.sender, _tokenDiffBalance);
        }
        emit BorrowedFromCreditLine(_id, _tokenDiffBalance);
    }

    function _repayFromSavingsAccount(
        uint256 _amount,
        address _asset,
        address _lender
    ) internal {
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        uint256 _activeAmount;

        for (uint256 _index = 0; _index < _strategyList.length; _index++) {
            if (_strategyList[_index] == address(0)) {
                continue;
            }
            uint256 _liquidityShares = _savingsAccount.balanceInShares(msg.sender, _asset, _strategyList[_index]);
            if (_liquidityShares == 0) {
                continue;
            }
            uint256 _tokenInStrategy = _liquidityShares;
            _tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);

            uint256 _tokensToTransfer = _tokenInStrategy;
            if (_activeAmount.add(_tokenInStrategy) >= _amount) {
                _tokensToTransfer = (_amount.sub(_activeAmount));
            }
            _activeAmount = _activeAmount.add(_tokensToTransfer);
            _savingsAccount.transferFrom(_tokensToTransfer, _asset, _strategyList[_index], msg.sender, _lender);

            if (_amount == _activeAmount) {
                return;
            }
        }
        revert('CreditLine::_repayFromSavingsAccount - Insufficient balance');
    }

    function _repay(
        uint256 _id,
        uint256 _amount,
        bool _fromSavingsAccount,
        uint256 _principalPaid
    ) internal {
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        address _defaultStrategy = defaultStrategy;
        address _borrowAsset = creditLineConstants[_id].borrowAsset;
        address _lender = creditLineConstants[_id].lender;
        if (!_fromSavingsAccount) {
            if (_borrowAsset == address(0)) {
                require(msg.value == _amount, 'creditLine::repay - Ether sent not equal to repay amount');
                _savingsAccount.deposit{value: _amount}(_amount, _borrowAsset, _defaultStrategy, _lender);
            } else {
                IERC20(_borrowAsset).safeTransferFrom(msg.sender, address(this), _amount);
                IERC20(_borrowAsset).approve(_defaultStrategy, _amount);
                _savingsAccount.deposit(_amount, _borrowAsset, _defaultStrategy, _lender);
            }
        } else {
            _repayFromSavingsAccount(_amount, _borrowAsset, _lender);
        }
        if (_principalPaid != 0) {
            _savingsAccount.increaseAllowanceToCreditLine(_principalPaid, _borrowAsset, _lender);
        }
    }

    /**
     * @notice used to repay interest and principal to credit line. Interest has to be repaid before repaying principal
     * @dev partial repayments possible
     * @param _id identifier for the credit line
     * @param _amount amount being repaid
     * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount 
                                otherwise direct from collateral token contract
     */
    function repay(
        uint256 _id,
        uint256 _amount,
        bool _fromSavingsAccount
    ) external payable nonReentrant {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');
        require(creditLineConstants[_id].lender != msg.sender, 'Lender cant repay');

        uint256 _interestSincePrincipalUpdate = calculateInterestAccrued(_id);
        uint256 _totalInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(
            _interestSincePrincipalUpdate
        );
        uint256 _interestToPay = _totalInterestAccrued.sub(creditLineVariables[_id].totalInterestRepaid);
        uint256 _totalCurrentDebt = _interestToPay.add(creditLineVariables[_id].principal);
        uint256 _principalPaid = 0;

        if (_amount >= _totalCurrentDebt) {
            _amount = _totalCurrentDebt;
            emit CompleteCreditLineRepaid(_id, _amount);
        } else {
            emit PartialCreditLineRepaid(_id, _amount);
        }

        if (_amount > _interestToPay) {
            creditLineVariables[_id].principal = _totalCurrentDebt.sub(_amount);
            creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _totalInterestAccrued;
            creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;
            creditLineVariables[_id].totalInterestRepaid = _totalInterestAccrued;
            _principalPaid = _amount.sub(_interestToPay);
        } else {
            creditLineVariables[_id].totalInterestRepaid = creditLineVariables[_id].totalInterestRepaid.add(_amount);
        }

        _repay(_id, _amount, _fromSavingsAccount, _principalPaid);

        if (creditLineVariables[_id].principal == 0) {
            _resetCreditLine(_id);
        }
    }

    function _resetCreditLine(uint256 _id) internal {
        creditLineVariables[_id].lastPrincipalUpdateTime = 0;
        creditLineVariables[_id].totalInterestRepaid = 0;
        creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = 0;
        emit CreditLineReset(_id);
    }

    /**
     * @dev used to close credit line by borrower or lender
     * @param _id identifier for the credit line
     */
    function close(uint256 _id) external ifCreditLineExists(_id) {
        require(
            msg.sender == creditLineConstants[_id].borrower || msg.sender == creditLineConstants[_id].lender,
            'CreditLine: Permission denied while closing Line of credit'
        );
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: Credit line should be active.');
        require(creditLineVariables[_id].principal == 0, 'CreditLine: Cannot be closed since not repaid.');
        require(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate == 0, 'CreditLine: Cannot be closed since not repaid.');
        creditLineVariables[_id].status = CreditLineStatus.CLOSED;
        emit CreditLineClosed(_id);
    }

    /**
     * @notice used to calculate the current collateral ratio
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view.
            Interest is also considered while calculating debt
     * @param _id identifier for the credit line
     * @return collateral ratio multiplied by 10**30 to retain precision
     */
    function calculateCurrentCollateralRatio(uint256 _id) public ifCreditLineExists(_id) returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(
            creditLineConstants[_id].collateralAsset,
            creditLineConstants[_id].borrowAsset
        );

        uint256 currentDebt = calculateCurrentDebt(_id);
        uint256 currentCollateralRatio = calculateTotalCollateralTokens(_id).mul(_ratioOfPrices).div(currentDebt).mul(10**30).div(
            10**_decimals
        );

        return currentCollateralRatio;
    }

    /**
     * @notice used to calculate the total collateral tokens
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @param _id identifier for the credit line
     * @return _amount total collateral tokens deposited into the credit line
     */
    function calculateTotalCollateralTokens(uint256 _id) public returns (uint256 _amount) {
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        uint256 _liquidityShares;
        for (uint256 index = 0; index < _strategyList.length; index++) {
            if (_strategyList[index] == address(0)) {
                continue;
            }
            _liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];
            uint256 _tokenInStrategy = _liquidityShares;
            _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(_liquidityShares, _collateralAsset);

            _amount = _amount.add(_tokenInStrategy);
        }
    }

    /**
     * @notice used to withdraw any excess collateral
     * @dev collateral can't be withdraw if collateralRatio goes below the ideal value. Only borrower can withdraw
     * @param _id identifier for the credit line
     * @param _amount amount of collateral to withdraw
     * @param _toSavingsAccount if true, tokens are transferred from savingsAccount 
                                otherwise direct from collateral token contract
     */
    function withdrawCollateral(
        uint256 _id,
        uint256 _amount,
        bool _toSavingsAccount
    ) external nonReentrant onlyCreditLineBorrower(_id) {
        uint256 _withdrawableCollateral = withdrawableCollateral(_id);
        require(_amount <= _withdrawableCollateral, 'Collateral ratio cant go below ideal');
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        _transferCollateral(_id, _collateralAsset, _amount, _toSavingsAccount);
        emit CollateralWithdrawn(_id, _amount);
    }

    /**
     * @notice used to calculate the collateral that can be withdrawn
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @param _id identifier for the credit line
     * @return total collateral withdrawable by borrower
     */
    function withdrawableCollateral(uint256 _id) public returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(
            creditLineConstants[_id].collateralAsset,
            creditLineConstants[_id].borrowAsset
        );

        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);
        uint256 _currentDebt = calculateCurrentDebt(_id);

        uint256 _collateralNeeded = _currentDebt
            .mul(creditLineConstants[_id].idealCollateralRatio)
            .div(_ratioOfPrices)
            .mul(10**_decimals)
            .div(10**30);

        if (_collateralNeeded >= _totalCollateralTokens) {
            return 0;
        }
        return _totalCollateralTokens.sub(_collateralNeeded);
    }

    function _transferCollateral(
        uint256 _id,
        address _asset,
        uint256 _amountInTokens,
        bool _toSavingsAccount
    ) internal {
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        uint256 _activeAmount;
        for (uint256 index = 0; index < _strategyList.length; index++) {
            uint256 liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];
            if (liquidityShares == 0 || _strategyList[index] == address(0)) {
                continue;
            }
            uint256 _tokenInStrategy = liquidityShares;
            _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(liquidityShares, _asset);
            uint256 _tokensToTransfer = _tokenInStrategy;
            if (_activeAmount.add(_tokenInStrategy) > _amountInTokens) {
                _tokensToTransfer = _amountInTokens.sub(_activeAmount);
                liquidityShares = liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy);
            }
            _activeAmount = _activeAmount.add(_tokensToTransfer);
            collateralShareInStrategy[_id][_strategyList[index]] = collateralShareInStrategy[_id][_strategyList[index]].sub(
                liquidityShares
            );
            if (_toSavingsAccount) {
                ISavingsAccount(savingsAccount).transfer(_tokensToTransfer, _asset, _strategyList[index], msg.sender);
            } else {
                ISavingsAccount(savingsAccount).withdraw(_tokensToTransfer, _asset, _strategyList[index], msg.sender, false);
            }

            if (_activeAmount == _amountInTokens) {
                return;
            }
        }
        revert('insufficient collateral');
    }

    /**
     * @notice used to liquidate credit line in case collateral ratio goes below the threshold
     * @dev if lender liquidates, then collateral is directly transferred. 
            If autoLiquidation is true, anyone can liquidate by providing enough borrow tokens
     * @param _id identifier for the credit line
     * @param _toSavingsAccount if true, tokens are transferred from savingsAccount 
                                otherwise direct from collateral token contract
     */
    function liquidate(uint256 _id, bool _toSavingsAccount) external payable nonReentrant {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: Credit line should be active.');
        require(creditLineVariables[_id].principal != 0, 'CreditLine: cannot liquidate if principal is 0');

        uint256 currentCollateralRatio = calculateCurrentCollateralRatio(_id);
        require(
            currentCollateralRatio < creditLineConstants[_id].idealCollateralRatio,
            'CreditLine: Collateral ratio is higher than ideal value'
        );

        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        address _lender = creditLineConstants[_id].lender;
        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);
        address _borrowAsset = creditLineConstants[_id].borrowAsset;

        creditLineVariables[_id].status = CreditLineStatus.LIQUIDATED;

        if (creditLineConstants[_id].autoLiquidation && _lender != msg.sender) {
            uint256 _borrowTokens = _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens);
            if (_borrowAsset == address(0)) {
                uint256 _returnETH = msg.value.sub(_borrowTokens, 'Insufficient ETH to liquidate');
                if (_returnETH != 0) {
                    (bool success, ) = msg.sender.call{value: _returnETH}('');
                    require(success, 'Transfer fail');
                }
            } else {
                IERC20(_borrowAsset).safeTransferFrom(msg.sender, _lender, _borrowTokens);
            }
        }

        _transferCollateral(_id, _collateralAsset, _totalCollateralTokens, _toSavingsAccount);

        emit CreditLineLiquidated(_id, msg.sender);
    }

    /**
     * @notice used to calculate the borrow tokens necessary for liquidator to liquidate
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @param _id identifier for the credit line
     * @return borrow tokens necessary for liquidator to liquidate
     */
    function borrowTokensToLiquidate(uint256 _id) external returns (uint256) {
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);
        address _borrowAsset = creditLineConstants[_id].borrowAsset;

        return _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens);
    }

    function _borrowTokensToLiquidate(
        address _borrowAsset,
        address _collateralAsset,
        uint256 _totalCollateralTokens
    ) internal view returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(_borrowAsset, _collateralAsset);
        uint256 _borrowTokens = (
            _totalCollateralTokens.mul(uint256(10**30).sub(liquidatorRewardFraction)).div(10**30).mul(_ratioOfPrices).div(10**_decimals)
        );

        return _borrowTokens;
    }

    receive() external payable {
        require(msg.sender == savingsAccount, 'CreditLine::receive invalid transaction');
    }
}
.]

###

[2024-22-08 11:43:14 INFO] **[Seminar Conclusion]**:

 ###

[2024-22-08 11:43:14 INFO] **[Execute Detail]**

execute SimplePhase:[BugsSummary] in ComposedPhase:[CodeReview], cycle 1

[2024-22-08 11:43:14 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol'; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/utils/ReentrancyGuard.sol'; import '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol'; import '../interfaces/IPriceOracle.sol'; import '../interfaces/IYield.sol'; import '../interfaces/ISavingsAccount.sol'; import '../SavingsAccount/SavingsAccountUtil.sol'; import '../interfaces/IStrategyRegistry.sol'; /  * @title Credit Line contract with Methods related to credit Line  * @notice Implements the functions related to Credit Line  * @author Sublime  / contract CreditLine is ReentrancyGuard, OwnableUpgradeable {     using SafeERC20 for IERC20;     using SafeMath for uint256; enum CreditLineStatus {     NOT_CREATED,     REQUESTED,     ACTIVE,     CLOSED,     CANCELLED,     LIQUIDATED }  /**  * @notice counter that tracks the number of credit lines created  * @dev used to create unique identifier for credit lines  **/ uint256 public creditLineCounter;  uint256 constant YEAR_IN_SECONDS = 365 days;  struct CreditLineVariables {     CreditLineStatus status;     uint256 principal;     uint256 totalInterestRepaid;     uint256 lastPrincipalUpdateTime;     uint256 interestAccruedTillLastPrincipalUpdate; }  struct CreditLineConstants {     address lender;     address borrower;     uint256 borrowLimit;     uint256 idealCollateralRatio;     uint256 borrowRate;     address borrowAsset;     address collateralAsset;     bool autoLiquidation;     bool requestByLender; } /**  * @notice stores the collateral shares in a credit line per strategy  * @dev creditLineId =&gt; Strategy =&gt; collateralShares  **/ mapping(uint256 =&gt; mapping(address =&gt; uint256)) public collateralShareInStrategy;  /**  * @notice stores the variables to maintain a credit line  **/ mapping(uint256 =&gt; CreditLineVariables) public creditLineVariables;  /**  * @notice stores the constants related to a credit line  **/ mapping(uint256 =&gt; CreditLineConstants) public creditLineConstants;  /**  * @notice stores the address of savings account contract  **/ address public savingsAccount;  /**  * @notice stores the address of price oracle contract  **/ address public priceOracle;  /**  * @notice stores the address of strategy registry contract  **/ address public strategyRegistry;  /**  * @notice stores the address of default strategy  **/ address public defaultStrategy;  /**  * @notice stores the fraction of borrowed amount charged as fee by protocol  * @dev it is multiplied by 10**30  **/ uint256 public protocolFeeFraction;  /**  * @notice address where protocol fee is collected  **/ address public protocolFeeCollector;  /**  * @notice stores the fraction of amount liquidated given as reward to liquidator  * @dev it is multiplied by 10**30  **/ uint256 public liquidatorRewardFraction; /**  * @dev checks if Credit Line exists  * @param _id identifier for the credit line  **/ modifier ifCreditLineExists(uint256 _id) {     require(creditLineVariables[_id].status != CreditLineStatus.NOT_CREATED, 'Credit line does not exist');     _; }  /**  * @dev checks if called by credit Line Borrower  * @param _id creditLine identifier  **/ modifier onlyCreditLineBorrower(uint256 _id) {     require(creditLineConstants[_id].borrower == msg.sender, 'Only credit line Borrower can access');     _; }  /**  * @dev checks if called by credit Line Lender  * @param _id creditLine identifier  **/ modifier onlyCreditLineLender(uint256 _id) {     require(creditLineConstants[_id].lender == msg.sender, 'Only credit line Lender can access');     _; }  /**  * @notice emitted when a collateral is deposited into credit line  * @param id id of the credit line  * @param amount amount of collateral deposited  * @param strategy address of the strategy into which collateral is deposited  */ event CollateralDeposited(uint256 indexed id, uint256 amount, address indexed strategy);  /**  * @notice emitted when collateral is withdrawn from credit line  * @param id id of the credit line  * @param amount amount of collateral withdrawn  */ event CollateralWithdrawn(uint256 indexed id, uint256 amount);  /**  * @notice emitted when a request for new credit line is placed  * @param id id of the credit line for which request was made  * @param lender address of the lender for credit line  * @param borrower address of the borrower for credit line  */ event CreditLineRequested(uint256 indexed id, address indexed lender, address indexed borrower);  /**  * @notice emitted when a credit line is liquidated  * @param id id of the credit line which is liquidated  * @param liquidator address of the liquidator  */ event CreditLineLiquidated(uint256 indexed id, address indexed liquidator);  /**  * @notice emitted when tokens are borrowed from credit line  * @param id id of the credit line from which tokens are borrowed  * @param borrowAmount amount of tokens borrowed  */ event BorrowedFromCreditLine(uint256 indexed id, uint256 borrowAmount);  /**  * @notice emitted when credit line is accepted  * @param id id of the credit line that was accepted  */ event CreditLineAccepted(uint256 indexed id);  /**  * @notice emitted when credit line is completely repaid and reset  * @param id id of the credit line that is reset  */ event CreditLineReset(uint256 indexed id);  /**  * @notice emitted when the credit line is partially repaid  * @param id id of the credit line  * @param repayAmount amount repaid  */ event PartialCreditLineRepaid(uint256 indexed id, uint256 repayAmount);  /**  * @notice emitted when the credit line is completely repaid  * @param id id of the credit line  * @param repayAmount amount repaid  */ event CompleteCreditLineRepaid(uint256 indexed id, uint256 repayAmount);  /**  * @notice emitted when the credit line is closed by one of the parties of credit line  * @param id id of the credit line  */ event CreditLineClosed(uint256 indexed id);  /**  * @notice emitted when default strategy for the credit line is updated  * @param defaultStrategy address of the strategy contract that is used as default by credit lines  */ event DefaultStrategyUpdated(address indexed defaultStrategy);  /**  * @notice emitted when the price oracle is updated  * @param priceOracle address of the updated price oracle  */ event PriceOracleUpdated(address indexed priceOracle);  /**  * @notice emitted when the savings account address is updated  * @param savingsAccount address of the updated savingsAccount  */ event SavingsAccountUpdated(address indexed savingsAccount);  /**  * @notice emitted when strategy registry address is updated  * @param strategyRegistry address of the updated strategy registry  */ event StrategyRegistryUpdated(address indexed strategyRegistry);  /**  * @notice emitted when fee that protocol charges for credit line is updated  * @param updatedProtocolFee updated value of protocolFeeFraction  */ event ProtocolFeeFractionUpdated(uint256 updatedProtocolFee);  /**  * @notice emitted when address which receives fee that protocol changes for pools is updated  * @param updatedProtocolFeeCollector updated value of protocolFeeCollector  */ event ProtocolFeeCollectorUpdated(address indexed updatedProtocolFeeCollector);  /**  * @notice emitted when liquidatorRewardFraction is updated  * @param liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator  */ event LiquidationRewardFractionUpdated(uint256 liquidatorRewardFraction);  /**  * @notice used to initialize the contract  * @dev can only be called once during the life cycle of the contract  * @param _defaultStrategy default strategy used in credit lines  * @param _priceOracle address of the priceOracle  * @param _savingsAccount address of  the savings account contract  * @param _strategyRegistry address of the strategy registry contract  * @param _owner address of owner who can change global variables  * @param _protocolFeeFraction fraction of the fee charged by protocol  * @param _protocolFeeCollector address to which protocol fee is charged to  * @param _liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator  */ function initialize(     address _defaultStrategy,     address _priceOracle,     address _savingsAccount,     address _strategyRegistry,     address _owner,     uint256 _protocolFeeFraction,     address _protocolFeeCollector,     uint256 _liquidatorRewardFraction ) external initializer {     OwnableUpgradeable.__Ownable_init();     OwnableUpgradeable.transferOwnership(_owner);      _updateDefaultStrategy(_defaultStrategy);     _updatePriceOracle(_priceOracle);     _updateSavingsAccount(_savingsAccount);     _updateStrategyRegistry(_strategyRegistry);     _updateProtocolFeeFraction(_protocolFeeFraction);     _updateProtocolFeeCollector(_protocolFeeCollector);     _updateLiquidatorRewardFraction(_liquidatorRewardFraction); }  /**  * @notice used to update the default strategy  * @dev can only be updated by owner  * @param _defaultStrategy address of the updated default strategy  */ function updateDefaultStrategy(address _defaultStrategy) external onlyOwner {     _updateDefaultStrategy(_defaultStrategy); }  function _updateDefaultStrategy(address _defaultStrategy) internal {     defaultStrategy = _defaultStrategy;     emit DefaultStrategyUpdated(_defaultStrategy); }  /**  * @notice used to update the price oracle  * @dev can only be updated by owner  * @param _priceOracle address of the updated price oracle  */ function updatePriceOracle(address _priceOracle) external onlyOwner {     _updatePriceOracle(_priceOracle); }  function _updatePriceOracle(address _priceOracle) internal {     priceOracle = _priceOracle;     emit PriceOracleUpdated(_priceOracle); }  /**  * @notice used to update the savings account address  * @dev can only be updated by owner  * @param _savingsAccount address of the updated savings account  */ function updateSavingsAccount(address _savingsAccount) external onlyOwner {     _updateSavingsAccount(_savingsAccount); }  function _updateSavingsAccount(address _savingsAccount) internal {     savingsAccount = _savingsAccount;     emit SavingsAccountUpdated(_savingsAccount); }  /**  * @notice used to update the protocol fee fraction  * @dev can only be updated by owner  * @param _protocolFee fraction of the borrower amount collected as protocol fee  */ function updateProtocolFeeFraction(uint256 _protocolFee) external onlyOwner {     _updateProtocolFeeFraction(_protocolFee); }  function _updateProtocolFeeFraction(uint256 _protocolFee) internal {     protocolFeeFraction = _protocolFee;     emit ProtocolFeeFractionUpdated(_protocolFee); }  /**  * @notice used to update the protocol fee collector  * @dev can only be updated by owner  * @param _protocolFeeCollector address in which protocol fee is collected  */ function updateProtocolFeeCollector(address _protocolFeeCollector) external onlyOwner {     _updateProtocolFeeCollector(_protocolFeeCollector); }  function _updateProtocolFeeCollector(address _protocolFeeCollector) internal {     require(_protocolFeeCollector != address(0), 'cant be 0 address');     protocolFeeCollector = _protocolFeeCollector;     emit ProtocolFeeCollectorUpdated(_protocolFeeCollector); }  /**  * @notice used to update the strategy registry address  * @dev can only be updated by owner  * @param _strategyRegistry address of the updated strategy registry  */ function updateStrategyRegistry(address _strategyRegistry) external onlyOwner {     _updateStrategyRegistry(_strategyRegistry); }  function _updateStrategyRegistry(address _strategyRegistry) internal {     require(_strategyRegistry != address(0), 'CL::I zero address');     strategyRegistry = _strategyRegistry;     emit StrategyRegistryUpdated(_strategyRegistry); }  /**  * @notice used to update the liquidatorRewardFraction  * @dev can only be updated by owner  * @param _rewardFraction fraction of liquidated amount given to liquidator as reward  */ function updateLiquidatorRewardFraction(uint256 _rewardFraction) external onlyOwner {     _updateLiquidatorRewardFraction(_rewardFraction); }  function _updateLiquidatorRewardFraction(uint256 _rewardFraction) internal {     require(_rewardFraction &lt;= 10**30, 'Fraction has to be less than 1');     liquidatorRewardFraction = _rewardFraction;     emit LiquidationRewardFractionUpdated(_rewardFraction); }  /**  * @dev Used to Calculate Interest Per second on given principal and Interest rate  * @param _principal principal Amount for which interest has to be calculated.  * @param _borrowRate It is the Interest Rate at which Credit Line is approved  * @return interest per second for the given parameters  */ function calculateInterest(     uint256 _principal,     uint256 _borrowRate,     uint256 _timeElapsed ) public pure returns (uint256) {     uint256 _interest = _principal.mul(_borrowRate).mul(_timeElapsed).div(10**30).div(YEAR_IN_SECONDS);      return _interest; }  /**  * @dev Used to calculate interest accrued since last repayment  * @param _id identifier for the credit line  * @return interest accrued over current borrowed amount since last repayment  */  function calculateInterestAccrued(uint256 _id) public view returns (uint256) {     uint256 _lastPrincipalUpdateTime = creditLineVariables[_id].lastPrincipalUpdateTime;     if (_lastPrincipalUpdateTime == 0) return 0;     uint256 _timeElapsed = (block.timestamp).sub(_lastPrincipalUpdateTime);     uint256 _interestAccrued = calculateInterest(creditLineVariables[_id].principal, creditLineConstants[_id].borrowRate, _timeElapsed);     return _interestAccrued; }  /**  * @dev Used to calculate current debt of borrower against a credit line.  * @param _id identifier for the credit line  * @return current debt of borrower  */ function calculateCurrentDebt(uint256 _id) public view returns (uint256) {     uint256 _interestAccrued = calculateInterestAccrued(_id);     uint256 _currentDebt = (creditLineVariables[_id].principal)         .add(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate)         .add(_interestAccrued)         .sub(creditLineVariables[_id].totalInterestRepaid);     return _currentDebt; }  /**  * @notice used to calculate amount that can be borrowed by the borrower  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view.         borrowableAmount changes per block as interest changes per block.  * @param _id identifier for the credit line  * @return amount that can be borrowed from the credit line  */ function calculateBorrowableAmount(uint256 _id) public returns (uint256) {     CreditLineStatus _status = creditLineVariables[_id].status;     require(         _status == CreditLineStatus.ACTIVE || _status == CreditLineStatus.REQUESTED,         'CreditLine: Cannot only if credit line ACTIVE or REQUESTED'     );     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(         creditLineConstants[_id].collateralAsset,         creditLineConstants[_id].borrowAsset     );      uint256 _totalCollateralToken = calculateTotalCollateralTokens(_id);      uint256 _currentDebt = calculateCurrentDebt(_id);      uint256 _maxPossible = _totalCollateralToken.mul(_ratioOfPrices).div(creditLineConstants[_id].idealCollateralRatio).mul(10**30).div(         10**_decimals     );      uint256 _borrowLimit = creditLineConstants[_id].borrowLimit;      if (_maxPossible &gt; _borrowLimit) {         _maxPossible = _borrowLimit;     }     if (_maxPossible &gt; _currentDebt) {         return _maxPossible.sub(_currentDebt);     }     return 0; }  function updateinterestAccruedTillLastPrincipalUpdate(uint256 _id) internal {     require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');      uint256 _interestAccrued = calculateInterestAccrued(_id);     uint256 _newInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(_interestAccrued);     creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _newInterestAccrued; }  function _depositCollateralFromSavingsAccount(     uint256 _id,     uint256 _amount,     address _sender ) internal {     address _collateralAsset = creditLineConstants[_id].collateralAsset;     address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();     ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);     uint256 _activeAmount;      for (uint256 _index = 0; _index &lt; _strategyList.length; _index++) {         address _strategy = _strategyList[_index];         uint256 _liquidityShares = _savingsAccount.balanceInShares(_sender, _collateralAsset, _strategy);         if (_liquidityShares == 0 || _strategyList[_index] == address(0)) {             continue;         }         uint256 _tokenInStrategy = _liquidityShares;         _tokenInStrategy = IYield(_strategy).getTokensForShares(_liquidityShares, _collateralAsset);          uint256 _tokensToTransfer = _tokenInStrategy;         if (_activeAmount.add(_tokenInStrategy) &gt;= _amount) {             _tokensToTransfer = (_amount.sub(_activeAmount));         }         _activeAmount = _activeAmount.add(_tokensToTransfer);         _savingsAccount.transferFrom(_tokensToTransfer, _collateralAsset, _strategy, _sender, address(this));          collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(             _liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy)         );          if (_amount == _activeAmount) {             return;         }     }     revert('CreditLine::_depositCollateralFromSavingsAccount - Insufficient balance'); }  /**  * @notice used to request a credit line either by borrower or lender  * @param _requestTo Address to which creditLine is requested,                      if borrower creates request then lender address and                      if lender creates then borrower address  * @param _borrowLimit maximum borrow amount in a credit line  * @param _borrowRate Interest Rate at which credit Line is requested  * @param _autoLiquidation if true, anyone can liquidate loan, otherwise only lender  * @param _collateralRatio ratio of the collateral to the debt below which credit line can be liquidated  * @param _borrowAsset address of the token to be borrowed  * @param _collateralAsset address of the token provided as collateral  * @param _requestAsLender if true, lender is placing request, otherwise borrower  * @return identifier for the credit line  */  function request(     address _requestTo,     uint256 _borrowLimit,     uint256 _borrowRate,     bool _autoLiquidation,     uint256 _collateralRatio,     address _borrowAsset,     address _collateralAsset,     bool _requestAsLender ) external returns (uint256) {     require(_borrowAsset != _collateralAsset, 'R: cant borrow lent token');     require(IPriceOracle(priceOracle).doesFeedExist(_borrowAsset, _collateralAsset), 'R: No price feed');      address _lender = _requestTo;     address _borrower = msg.sender;     if (_requestAsLender) {         _lender = msg.sender;         _borrower = _requestTo;     }      uint256 _id = _createRequest(         _lender,         _borrower,         _borrowLimit,         _borrowRate,         _autoLiquidation,         _collateralRatio,         _borrowAsset,         _collateralAsset,         _requestAsLender     );      emit CreditLineRequested(_id, _lender, _borrower);     return _id; }  function _createRequest(     address _lender,     address _borrower,     uint256 _borrowLimit,     uint256 _borrowRate,     bool _autoLiquidation,     uint256 _collateralRatio,     address _borrowAsset,     address _collateralAsset,     bool _requestByLender ) internal returns (uint256) {     require(_lender != _borrower, 'Lender and Borrower cannot be same addresses');     uint256 _id = creditLineCounter + 1;     creditLineCounter = _id;     creditLineVariables[_id].status = CreditLineStatus.REQUESTED;     creditLineConstants[_id].borrower = _borrower;     creditLineConstants[_id].lender = _lender;     creditLineConstants[_id].borrowLimit = _borrowLimit;     creditLineConstants[_id].autoLiquidation = _autoLiquidation;     creditLineConstants[_id].idealCollateralRatio = _collateralRatio;     creditLineConstants[_id].borrowRate = _borrowRate;     creditLineConstants[_id].borrowAsset = _borrowAsset;     creditLineConstants[_id].collateralAsset = _collateralAsset;     creditLineConstants[_id].requestByLender = _requestByLender;     return _id; }  /**  * @notice used to accept a credit line  * @dev if borrower places request, lender can accept and vice versa  * @param _id identifier for the credit line  */ function accept(uint256 _id) external {     require(         creditLineVariables[_id].status == CreditLineStatus.REQUESTED,         'CreditLine::acceptCreditLineLender - CreditLine is already accepted'     );     bool _requestByLender = creditLineConstants[_id].requestByLender;     require(         (msg.sender == creditLineConstants[_id].borrower &amp;&amp; _requestByLender) ||             (msg.sender == creditLineConstants[_id].lender &amp;&amp; !_requestByLender),         "Only Borrower or Lender who hasn't requested can accept"     );     creditLineVariables[_id].status = CreditLineStatus.ACTIVE;     emit CreditLineAccepted(_id); }  /**  * @notice used to deposit collateral into the credit line  * @dev collateral tokens have to be approved in savingsAccount or token contract(unless ether).         If transferred from savings account, the tokens are transferred from strategies in the          order prespecified in strategy registry  * @param _id identifier for the credit line  * @param _amount amount of collateral being deposited  * @param _strategy strategy to which collateral is to be deposited in case transfer is not from savings account  * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount                              otherwise direct from collateral token contract  */ function depositCollateral(     uint256 _id,     uint256 _amount,     address _strategy,     bool _fromSavingsAccount ) external payable nonReentrant ifCreditLineExists(_id) {     require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine not active');     _depositCollateral(_id, _amount, _strategy, _fromSavingsAccount);     emit CollateralDeposited(_id, _amount, _strategy); }  function _depositCollateral(     uint256 _id,     uint256 _amount,     address _strategy,     bool _fromSavingsAccount ) internal {     require(creditLineConstants[_id].lender != msg.sender, 'lender cant deposit collateral');     if (_fromSavingsAccount) {         _depositCollateralFromSavingsAccount(_id, _amount, msg.sender);     } else {         address _collateralAsset = creditLineConstants[_id].collateralAsset;         ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);         if (_collateralAsset == address(0)) {             require(msg.value == _amount, "CreditLine::_depositCollateral - value to transfer doesn't match argument");         } else {             IERC20(_collateralAsset).safeTransferFrom(msg.sender, address(this), _amount);             IERC20(_collateralAsset).approve(_strategy, _amount);         }         uint256 _sharesReceived = _savingsAccount.deposit{value: msg.value}(_amount, _collateralAsset, _strategy, address(this));         collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(_sharesReceived);     } }  function _withdrawBorrowAmount(     address _asset,     uint256 _amountInTokens,     address _lender ) internal {     address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();     ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);     uint256 _activeAmount;     for (uint256 _index = 0; _index &lt; _strategyList.length; _index++) {         if (_strategyList[_index] == address(0)) {             continue;         }         uint256 _liquidityShares = _savingsAccount.balanceInShares(_lender, _asset, _strategyList[_index]);         if (_liquidityShares != 0) {             uint256 tokenInStrategy = _liquidityShares;             tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);             uint256 _tokensToTransfer = tokenInStrategy;             if (_activeAmount.add(tokenInStrategy) &gt;= _amountInTokens) {                 _tokensToTransfer = (_amountInTokens.sub(_activeAmount));             }             _activeAmount = _activeAmount.add(_tokensToTransfer);             _savingsAccount.withdrawFrom(_tokensToTransfer, _asset, _strategyList[_index], _lender, address(this), false);             if (_activeAmount == _amountInTokens) {                 return;             }         }     }     require(_activeAmount == _amountInTokens, 'insufficient balance'); }  /**  * @notice used to borrow tokens from credit line by borrower  * @dev only borrower can call this function. Amount that can actually be borrowed is          min(amount based on borrowLimit, allowance to creditLine contract, balance of lender)  * @param _id identifier for the credit line  * @param _amount amount of tokens to borrow  */ function borrow(uint256 _id, uint256 _amount) external payable nonReentrant onlyCreditLineBorrower(_id) {     require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');     uint256 _borrowableAmount = calculateBorrowableAmount(_id);     require(_amount &lt;= _borrowableAmount, "CreditLine::borrow - The current collateral ratio doesn't allow to withdraw the amount");     address _borrowAsset = creditLineConstants[_id].borrowAsset;     address _lender = creditLineConstants[_id].lender;      updateinterestAccruedTillLastPrincipalUpdate(_id);     creditLineVariables[_id].principal = creditLineVariables[_id].principal.add(_amount);     creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;      uint256 _tokenDiffBalance;     if (_borrowAsset != address(0)) {         uint256 _balanceBefore = IERC20(_borrowAsset).balanceOf(address(this));         _withdrawBorrowAmount(_borrowAsset, _amount, _lender);         uint256 _balanceAfter = IERC20(_borrowAsset).balanceOf(address(this));         _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);     } else {         uint256 _balanceBefore = address(this).balance;         _withdrawBorrowAmount(_borrowAsset, _amount, _lender);         uint256 _balanceAfter = address(this).balance;         _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);     }     uint256 _protocolFee = _tokenDiffBalance.mul(protocolFeeFraction).div(10**30);     _tokenDiffBalance = _tokenDiffBalance.sub(_protocolFee);      if (_borrowAsset == address(0)) {         (bool feeSuccess, ) = protocolFeeCollector.call{value: _protocolFee}('');         require(feeSuccess, 'Transfer fail');         (bool success, ) = msg.sender.call{value: _tokenDiffBalance}('');         require(success, 'Transfer fail');     } else {         IERC20(_borrowAsset).safeTransfer(protocolFeeCollector, _protocolFee);         IERC20(_borrowAsset).safeTransfer(msg.sender, _tokenDiffBalance);     }     emit BorrowedFromCreditLine(_id, _tokenDiffBalance); }  function _repayFromSavingsAccount(     uint256 _amount,     address _asset,     address _lender ) internal {     address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();     ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);     uint256 _activeAmount;      for (uint256 _index = 0; _index &lt; _strategyList.length; _index++) {         if (_strategyList[_index] == address(0)) {             continue;         }         uint256 _liquidityShares = _savingsAccount.balanceInShares(msg.sender, _asset, _strategyList[_index]);         if (_liquidityShares == 0) {             continue;         }         uint256 _tokenInStrategy = _liquidityShares;         _tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);          uint256 _tokensToTransfer = _tokenInStrategy;         if (_activeAmount.add(_tokenInStrategy) &gt;= _amount) {             _tokensToTransfer = (_amount.sub(_activeAmount));         }         _activeAmount = _activeAmount.add(_tokensToTransfer);         _savingsAccount.transferFrom(_tokensToTransfer, _asset, _strategyList[_index], msg.sender, _lender);          if (_amount == _activeAmount) {             return;         }     }     revert('CreditLine::_repayFromSavingsAccount - Insufficient balance'); }  function _repay(     uint256 _id,     uint256 _amount,     bool _fromSavingsAccount,     uint256 _principalPaid ) internal {     ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);     address _defaultStrategy = defaultStrategy;     address _borrowAsset = creditLineConstants[_id].borrowAsset;     address _lender = creditLineConstants[_id].lender;     if (!_fromSavingsAccount) {         if (_borrowAsset == address(0)) {             require(msg.value == _amount, 'creditLine::repay - Ether sent not equal to repay amount');             _savingsAccount.deposit{value: _amount}(_amount, _borrowAsset, _defaultStrategy, _lender);         } else {             IERC20(_borrowAsset).safeTransferFrom(msg.sender, address(this), _amount);             IERC20(_borrowAsset).approve(_defaultStrategy, _amount);             _savingsAccount.deposit(_amount, _borrowAsset, _defaultStrategy, _lender);         }     } else {         _repayFromSavingsAccount(_amount, _borrowAsset, _lender);     }     if (_principalPaid != 0) {         _savingsAccount.increaseAllowanceToCreditLine(_principalPaid, _borrowAsset, _lender);     } }  /**  * @notice used to repay interest and principal to credit line. Interest has to be repaid before repaying principal  * @dev partial repayments possible  * @param _id identifier for the credit line  * @param _amount amount being repaid  * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount                              otherwise direct from collateral token contract  */ function repay(     uint256 _id,     uint256 _amount,     bool _fromSavingsAccount ) external payable nonReentrant {     require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');     require(creditLineConstants[_id].lender != msg.sender, 'Lender cant repay');      uint256 _interestSincePrincipalUpdate = calculateInterestAccrued(_id);     uint256 _totalInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(         _interestSincePrincipalUpdate     );     uint256 _interestToPay = _totalInterestAccrued.sub(creditLineVariables[_id].totalInterestRepaid);     uint256 _totalCurrentDebt = _interestToPay.add(creditLineVariables[_id].principal);     uint256 _principalPaid = 0;      if (_amount &gt;= _totalCurrentDebt) {         _amount = _totalCurrentDebt;         emit CompleteCreditLineRepaid(_id, _amount);     } else {         emit PartialCreditLineRepaid(_id, _amount);     }      if (_amount &gt; _interestToPay) {         creditLineVariables[_id].principal = _totalCurrentDebt.sub(_amount);         creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _totalInterestAccrued;         creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;         creditLineVariables[_id].totalInterestRepaid = _totalInterestAccrued;         _principalPaid = _amount.sub(_interestToPay);     } else {         creditLineVariables[_id].totalInterestRepaid = creditLineVariables[_id].totalInterestRepaid.add(_amount);     }      _repay(_id, _amount, _fromSavingsAccount, _principalPaid);      if (creditLineVariables[_id].principal == 0) {         _resetCreditLine(_id);     } }  function _resetCreditLine(uint256 _id) internal {     creditLineVariables[_id].lastPrincipalUpdateTime = 0;     creditLineVariables[_id].totalInterestRepaid = 0;     creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = 0;     emit CreditLineReset(_id); }  /**  * @dev used to close credit line by borrower or lender  * @param _id identifier for the credit line  */ function close(uint256 _id) external ifCreditLineExists(_id) {     require(         msg.sender == creditLineConstants[_id].borrower || msg.sender == creditLineConstants[_id].lender,         'CreditLine: Permission denied while closing Line of credit'     );     require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: Credit line should be active.');     require(creditLineVariables[_id].principal == 0, 'CreditLine: Cannot be closed since not repaid.');     require(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate == 0, 'CreditLine: Cannot be closed since not repaid.');     creditLineVariables[_id].status = CreditLineStatus.CLOSED;     emit CreditLineClosed(_id); }  /**  * @notice used to calculate the current collateral ratio  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view.         Interest is also considered while calculating debt  * @param _id identifier for the credit line  * @return collateral ratio multiplied by 10**30 to retain precision  */ function calculateCurrentCollateralRatio(uint256 _id) public ifCreditLineExists(_id) returns (uint256) {     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(         creditLineConstants[_id].collateralAsset,         creditLineConstants[_id].borrowAsset     );      uint256 currentDebt = calculateCurrentDebt(_id);     uint256 currentCollateralRatio = calculateTotalCollateralTokens(_id).mul(_ratioOfPrices).div(currentDebt).mul(10**30).div(         10**_decimals     );      return currentCollateralRatio; }  /**  * @notice used to calculate the total collateral tokens  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view  * @param _id identifier for the credit line  * @return _amount total collateral tokens deposited into the credit line  */ function calculateTotalCollateralTokens(uint256 _id) public returns (uint256 _amount) {     address _collateralAsset = creditLineConstants[_id].collateralAsset;     address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();     uint256 _liquidityShares;     for (uint256 index = 0; index &lt; _strategyList.length; index++) {         if (_strategyList[index] == address(0)) {             continue;         }         _liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];         uint256 _tokenInStrategy = _liquidityShares;         _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(_liquidityShares, _collateralAsset);          _amount = _amount.add(_tokenInStrategy);     } }  /**  * @notice used to withdraw any excess collateral  * @dev collateral can't be withdraw if collateralRatio goes below the ideal value. Only borrower can withdraw  * @param _id identifier for the credit line  * @param _amount amount of collateral to withdraw  * @param _toSavingsAccount if true, tokens are transferred from savingsAccount                              otherwise direct from collateral token contract  */ function withdrawCollateral(     uint256 _id,     uint256 _amount,     bool _toSavingsAccount ) external nonReentrant onlyCreditLineBorrower(_id) {     uint256 _withdrawableCollateral = withdrawableCollateral(_id);     require(_amount &lt;= _withdrawableCollateral, 'Collateral ratio cant go below ideal');     address _collateralAsset = creditLineConstants[_id].collateralAsset;     _transferCollateral(_id, _collateralAsset, _amount, _toSavingsAccount);     emit CollateralWithdrawn(_id, _amount); }  /**  * @notice used to calculate the collateral that can be withdrawn  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view  * @param _id identifier for the credit line  * @return total collateral withdrawable by borrower  */ function withdrawableCollateral(uint256 _id) public returns (uint256) {     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(         creditLineConstants[_id].collateralAsset,         creditLineConstants[_id].borrowAsset     );      uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);     uint256 _currentDebt = calculateCurrentDebt(_id);      uint256 _collateralNeeded = _currentDebt         .mul(creditLineConstants[_id].idealCollateralRatio)         .div(_ratioOfPrices)         .mul(10**_decimals)         .div(10**30);      if (_collateralNeeded &gt;= _totalCollateralTokens) {         return 0;     }     return _totalCollateralTokens.sub(_collateralNeeded); }  function _transferCollateral(     uint256 _id,     address _asset,     uint256 _amountInTokens,     bool _toSavingsAccount ) internal {     address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();     uint256 _activeAmount;     for (uint256 index = 0; index &lt; _strategyList.length; index++) {         uint256 liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];         if (liquidityShares == 0 || _strategyList[index] == address(0)) {             continue;         }         uint256 _tokenInStrategy = liquidityShares;         _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(liquidityShares, _asset);         uint256 _tokensToTransfer = _tokenInStrategy;         if (_activeAmount.add(_tokenInStrategy) &gt; _amountInTokens) {             _tokensToTransfer = _amountInTokens.sub(_activeAmount);             liquidityShares = liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy);         }         _activeAmount = _activeAmount.add(_tokensToTransfer);         collateralShareInStrategy[_id][_strategyList[index]] = collateralShareInStrategy[_id][_strategyList[index]].sub(             liquidityShares         );         if (_toSavingsAccount) {             ISavingsAccount(savingsAccount).transfer(_tokensToTransfer, _asset, _strategyList[index], msg.sender);         } else {             ISavingsAccount(savingsAccount).withdraw(_tokensToTransfer, _asset, _strategyList[index], msg.sender, false);         }          if (_activeAmount == _amountInTokens) {             return;         }     }     revert('insufficient collateral'); }  /**  * @notice used to liquidate credit line in case collateral ratio goes below the threshold  * @dev if lender liquidates, then collateral is directly transferred.          If autoLiquidation is true, anyone can liquidate by providing enough borrow tokens  * @param _id identifier for the credit line  * @param _toSavingsAccount if true, tokens are transferred from savingsAccount                              otherwise direct from collateral token contract  */ function liquidate(uint256 _id, bool _toSavingsAccount) external payable nonReentrant {     require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: Credit line should be active.');     require(creditLineVariables[_id].principal != 0, 'CreditLine: cannot liquidate if principal is 0');      uint256 currentCollateralRatio = calculateCurrentCollateralRatio(_id);     require(         currentCollateralRatio &lt; creditLineConstants[_id].idealCollateralRatio,         'CreditLine: Collateral ratio is higher than ideal value'     );      address _collateralAsset = creditLineConstants[_id].collateralAsset;     address _lender = creditLineConstants[_id].lender;     uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);     address _borrowAsset = creditLineConstants[_id].borrowAsset;      creditLineVariables[_id].status = CreditLineStatus.LIQUIDATED;      if (creditLineConstants[_id].autoLiquidation &amp;&amp; _lender != msg.sender) {         uint256 _borrowTokens = _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens);         if (_borrowAsset == address(0)) {             uint256 _returnETH = msg.value.sub(_borrowTokens, 'Insufficient ETH to liquidate');             if (_returnETH != 0) {                 (bool success, ) = msg.sender.call{value: _returnETH}('');                 require(success, 'Transfer fail');             }         } else {             IERC20(_borrowAsset).safeTransferFrom(msg.sender, _lender, _borrowTokens);         }     }      _transferCollateral(_id, _collateralAsset, _totalCollateralTokens, _toSavingsAccount);      emit CreditLineLiquidated(_id, msg.sender); }  /**  * @notice used to calculate the borrow tokens necessary for liquidator to liquidate  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view  * @param _id identifier for the credit line  * @return borrow tokens necessary for liquidator to liquidate  */ function borrowTokensToLiquidate(uint256 _id) external returns (uint256) {     address _collateralAsset = creditLineConstants[_id].collateralAsset;     uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);     address _borrowAsset = creditLineConstants[_id].borrowAsset;      return _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens); }  function _borrowTokensToLiquidate(     address _borrowAsset,     address _collateralAsset,     uint256 _totalCollateralTokens ) internal view returns (uint256) {     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(_borrowAsset, _collateralAsset);     uint256 _borrowTokens = (         _totalCollateralTokens.mul(uint256(10**30).sub(liquidatorRewardFraction)).div(10**30).mul(_ratioOfPrices).div(10**_decimals)     );      return _borrowTokens; }  receive() external payable {     require(msg.sender == savingsAccount, 'CreditLine::receive invalid transaction'); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **phase_prompt** | Below are the details of our smart contract codes and their corresponding analysis reports: Task: "{task}". As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report. |
| **phase_name** | BugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 1, 'task': '', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-22-08 11:43:14 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol'; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/utils/ReentrancyGuard.sol'; import '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol'; import '../interfaces/IPriceOracle.sol'; import '../interfaces/IYield.sol'; import '../interfaces/ISavingsAccount.sol'; import '../SavingsAccount/SavingsAccountUtil.sol'; import '../interfaces/IStrategyRegistry.sol'; /  * @title Credit Line contract with Methods related to credit Line  * @notice Implements the functions related to Credit Line  * @author Sublime  / contract CreditLine is ReentrancyGuard, OwnableUpgradeable {     using SafeERC20 for IERC20;     using SafeMath for uint256; enum CreditLineStatus {     NOT_CREATED,     REQUESTED,     ACTIVE,     CLOSED,     CANCELLED,     LIQUIDATED }  /**  * @notice counter that tracks the number of credit lines created  * @dev used to create unique identifier for credit lines  **/ uint256 public creditLineCounter;  uint256 constant YEAR_IN_SECONDS = 365 days;  struct CreditLineVariables {     CreditLineStatus status;     uint256 principal;     uint256 totalInterestRepaid;     uint256 lastPrincipalUpdateTime;     uint256 interestAccruedTillLastPrincipalUpdate; }  struct CreditLineConstants {     address lender;     address borrower;     uint256 borrowLimit;     uint256 idealCollateralRatio;     uint256 borrowRate;     address borrowAsset;     address collateralAsset;     bool autoLiquidation;     bool requestByLender; } /**  * @notice stores the collateral shares in a credit line per strategy  * @dev creditLineId =&gt; Strategy =&gt; collateralShares  **/ mapping(uint256 =&gt; mapping(address =&gt; uint256)) public collateralShareInStrategy;  /**  * @notice stores the variables to maintain a credit line  **/ mapping(uint256 =&gt; CreditLineVariables) public creditLineVariables;  /**  * @notice stores the constants related to a credit line  **/ mapping(uint256 =&gt; CreditLineConstants) public creditLineConstants;  /**  * @notice stores the address of savings account contract  **/ address public savingsAccount;  /**  * @notice stores the address of price oracle contract  **/ address public priceOracle;  /**  * @notice stores the address of strategy registry contract  **/ address public strategyRegistry;  /**  * @notice stores the address of default strategy  **/ address public defaultStrategy;  /**  * @notice stores the fraction of borrowed amount charged as fee by protocol  * @dev it is multiplied by 10**30  **/ uint256 public protocolFeeFraction;  /**  * @notice address where protocol fee is collected  **/ address public protocolFeeCollector;  /**  * @notice stores the fraction of amount liquidated given as reward to liquidator  * @dev it is multiplied by 10**30  **/ uint256 public liquidatorRewardFraction; /**  * @dev checks if Credit Line exists  * @param _id identifier for the credit line  **/ modifier ifCreditLineExists(uint256 _id) {     require(creditLineVariables[_id].status != CreditLineStatus.NOT_CREATED, 'Credit line does not exist');     _; }  /**  * @dev checks if called by credit Line Borrower  * @param _id creditLine identifier  **/ modifier onlyCreditLineBorrower(uint256 _id) {     require(creditLineConstants[_id].borrower == msg.sender, 'Only credit line Borrower can access');     _; }  /**  * @dev checks if called by credit Line Lender  * @param _id creditLine identifier  **/ modifier onlyCreditLineLender(uint256 _id) {     require(creditLineConstants[_id].lender == msg.sender, 'Only credit line Lender can access');     _; }  /**  * @notice emitted when a collateral is deposited into credit line  * @param id id of the credit line  * @param amount amount of collateral deposited  * @param strategy address of the strategy into which collateral is deposited  */ event CollateralDeposited(uint256 indexed id, uint256 amount, address indexed strategy);  /**  * @notice emitted when collateral is withdrawn from credit line  * @param id id of the credit line  * @param amount amount of collateral withdrawn  */ event CollateralWithdrawn(uint256 indexed id, uint256 amount);  /**  * @notice emitted when a request for new credit line is placed  * @param id id of the credit line for which request was made  * @param lender address of the lender for credit line  * @param borrower address of the borrower for credit line  */ event CreditLineRequested(uint256 indexed id, address indexed lender, address indexed borrower);  /**  * @notice emitted when a credit line is liquidated  * @param id id of the credit line which is liquidated  * @param liquidator address of the liquidator  */ event CreditLineLiquidated(uint256 indexed id, address indexed liquidator);  /**  * @notice emitted when tokens are borrowed from credit line  * @param id id of the credit line from which tokens are borrowed  * @param borrowAmount amount of tokens borrowed  */ event BorrowedFromCreditLine(uint256 indexed id, uint256 borrowAmount);  /**  * @notice emitted when credit line is accepted  * @param id id of the credit line that was accepted  */ event CreditLineAccepted(uint256 indexed id);  /**  * @notice emitted when credit line is completely repaid and reset  * @param id id of the credit line that is reset  */ event CreditLineReset(uint256 indexed id);  /**  * @notice emitted when the credit line is partially repaid  * @param id id of the credit line  * @param repayAmount amount repaid  */ event PartialCreditLineRepaid(uint256 indexed id, uint256 repayAmount);  /**  * @notice emitted when the credit line is completely repaid  * @param id id of the credit line  * @param repayAmount amount repaid  */ event CompleteCreditLineRepaid(uint256 indexed id, uint256 repayAmount);  /**  * @notice emitted when the credit line is closed by one of the parties of credit line  * @param id id of the credit line  */ event CreditLineClosed(uint256 indexed id);  /**  * @notice emitted when default strategy for the credit line is updated  * @param defaultStrategy address of the strategy contract that is used as default by credit lines  */ event DefaultStrategyUpdated(address indexed defaultStrategy);  /**  * @notice emitted when the price oracle is updated  * @param priceOracle address of the updated price oracle  */ event PriceOracleUpdated(address indexed priceOracle);  /**  * @notice emitted when the savings account address is updated  * @param savingsAccount address of the updated savingsAccount  */ event SavingsAccountUpdated(address indexed savingsAccount);  /**  * @notice emitted when strategy registry address is updated  * @param strategyRegistry address of the updated strategy registry  */ event StrategyRegistryUpdated(address indexed strategyRegistry);  /**  * @notice emitted when fee that protocol charges for credit line is updated  * @param updatedProtocolFee updated value of protocolFeeFraction  */ event ProtocolFeeFractionUpdated(uint256 updatedProtocolFee);  /**  * @notice emitted when address which receives fee that protocol changes for pools is updated  * @param updatedProtocolFeeCollector updated value of protocolFeeCollector  */ event ProtocolFeeCollectorUpdated(address indexed updatedProtocolFeeCollector);  /**  * @notice emitted when liquidatorRewardFraction is updated  * @param liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator  */ event LiquidationRewardFractionUpdated(uint256 liquidatorRewardFraction);  /**  * @notice used to initialize the contract  * @dev can only be called once during the life cycle of the contract  * @param _defaultStrategy default strategy used in credit lines  * @param _priceOracle address of the priceOracle  * @param _savingsAccount address of  the savings account contract  * @param _strategyRegistry address of the strategy registry contract  * @param _owner address of owner who can change global variables  * @param _protocolFeeFraction fraction of the fee charged by protocol  * @param _protocolFeeCollector address to which protocol fee is charged to  * @param _liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator  */ function initialize(     address _defaultStrategy,     address _priceOracle,     address _savingsAccount,     address _strategyRegistry,     address _owner,     uint256 _protocolFeeFraction,     address _protocolFeeCollector,     uint256 _liquidatorRewardFraction ) external initializer {     OwnableUpgradeable.__Ownable_init();     OwnableUpgradeable.transferOwnership(_owner);      _updateDefaultStrategy(_defaultStrategy);     _updatePriceOracle(_priceOracle);     _updateSavingsAccount(_savingsAccount);     _updateStrategyRegistry(_strategyRegistry);     _updateProtocolFeeFraction(_protocolFeeFraction);     _updateProtocolFeeCollector(_protocolFeeCollector);     _updateLiquidatorRewardFraction(_liquidatorRewardFraction); }  /**  * @notice used to update the default strategy  * @dev can only be updated by owner  * @param _defaultStrategy address of the updated default strategy  */ function updateDefaultStrategy(address _defaultStrategy) external onlyOwner {     _updateDefaultStrategy(_defaultStrategy); }  function _updateDefaultStrategy(address _defaultStrategy) internal {     defaultStrategy = _defaultStrategy;     emit DefaultStrategyUpdated(_defaultStrategy); }  /**  * @notice used to update the price oracle  * @dev can only be updated by owner  * @param _priceOracle address of the updated price oracle  */ function updatePriceOracle(address _priceOracle) external onlyOwner {     _updatePriceOracle(_priceOracle); }  function _updatePriceOracle(address _priceOracle) internal {     priceOracle = _priceOracle;     emit PriceOracleUpdated(_priceOracle); }  /**  * @notice used to update the savings account address  * @dev can only be updated by owner  * @param _savingsAccount address of the updated savings account  */ function updateSavingsAccount(address _savingsAccount) external onlyOwner {     _updateSavingsAccount(_savingsAccount); }  function _updateSavingsAccount(address _savingsAccount) internal {     savingsAccount = _savingsAccount;     emit SavingsAccountUpdated(_savingsAccount); }  /**  * @notice used to update the protocol fee fraction  * @dev can only be updated by owner  * @param _protocolFee fraction of the borrower amount collected as protocol fee  */ function updateProtocolFeeFraction(uint256 _protocolFee) external onlyOwner {     _updateProtocolFeeFraction(_protocolFee); }  function _updateProtocolFeeFraction(uint256 _protocolFee) internal {     protocolFeeFraction = _protocolFee;     emit ProtocolFeeFractionUpdated(_protocolFee); }  /**  * @notice used to update the protocol fee collector  * @dev can only be updated by owner  * @param _protocolFeeCollector address in which protocol fee is collected  */ function updateProtocolFeeCollector(address _protocolFeeCollector) external onlyOwner {     _updateProtocolFeeCollector(_protocolFeeCollector); }  function _updateProtocolFeeCollector(address _protocolFeeCollector) internal {     require(_protocolFeeCollector != address(0), 'cant be 0 address');     protocolFeeCollector = _protocolFeeCollector;     emit ProtocolFeeCollectorUpdated(_protocolFeeCollector); }  /**  * @notice used to update the strategy registry address  * @dev can only be updated by owner  * @param _strategyRegistry address of the updated strategy registry  */ function updateStrategyRegistry(address _strategyRegistry) external onlyOwner {     _updateStrategyRegistry(_strategyRegistry); }  function _updateStrategyRegistry(address _strategyRegistry) internal {     require(_strategyRegistry != address(0), 'CL::I zero address');     strategyRegistry = _strategyRegistry;     emit StrategyRegistryUpdated(_strategyRegistry); }  /**  * @notice used to update the liquidatorRewardFraction  * @dev can only be updated by owner  * @param _rewardFraction fraction of liquidated amount given to liquidator as reward  */ function updateLiquidatorRewardFraction(uint256 _rewardFraction) external onlyOwner {     _updateLiquidatorRewardFraction(_rewardFraction); }  function _updateLiquidatorRewardFraction(uint256 _rewardFraction) internal {     require(_rewardFraction &lt;= 10**30, 'Fraction has to be less than 1');     liquidatorRewardFraction = _rewardFraction;     emit LiquidationRewardFractionUpdated(_rewardFraction); }  /**  * @dev Used to Calculate Interest Per second on given principal and Interest rate  * @param _principal principal Amount for which interest has to be calculated.  * @param _borrowRate It is the Interest Rate at which Credit Line is approved  * @return interest per second for the given parameters  */ function calculateInterest(     uint256 _principal,     uint256 _borrowRate,     uint256 _timeElapsed ) public pure returns (uint256) {     uint256 _interest = _principal.mul(_borrowRate).mul(_timeElapsed).div(10**30).div(YEAR_IN_SECONDS);      return _interest; }  /**  * @dev Used to calculate interest accrued since last repayment  * @param _id identifier for the credit line  * @return interest accrued over current borrowed amount since last repayment  */  function calculateInterestAccrued(uint256 _id) public view returns (uint256) {     uint256 _lastPrincipalUpdateTime = creditLineVariables[_id].lastPrincipalUpdateTime;     if (_lastPrincipalUpdateTime == 0) return 0;     uint256 _timeElapsed = (block.timestamp).sub(_lastPrincipalUpdateTime);     uint256 _interestAccrued = calculateInterest(creditLineVariables[_id].principal, creditLineConstants[_id].borrowRate, _timeElapsed);     return _interestAccrued; }  /**  * @dev Used to calculate current debt of borrower against a credit line.  * @param _id identifier for the credit line  * @return current debt of borrower  */ function calculateCurrentDebt(uint256 _id) public view returns (uint256) {     uint256 _interestAccrued = calculateInterestAccrued(_id);     uint256 _currentDebt = (creditLineVariables[_id].principal)         .add(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate)         .add(_interestAccrued)         .sub(creditLineVariables[_id].totalInterestRepaid);     return _currentDebt; }  /**  * @notice used to calculate amount that can be borrowed by the borrower  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view.         borrowableAmount changes per block as interest changes per block.  * @param _id identifier for the credit line  * @return amount that can be borrowed from the credit line  */ function calculateBorrowableAmount(uint256 _id) public returns (uint256) {     CreditLineStatus _status = creditLineVariables[_id].status;     require(         _status == CreditLineStatus.ACTIVE || _status == CreditLineStatus.REQUESTED,         'CreditLine: Cannot only if credit line ACTIVE or REQUESTED'     );     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(         creditLineConstants[_id].collateralAsset,         creditLineConstants[_id].borrowAsset     );      uint256 _totalCollateralToken = calculateTotalCollateralTokens(_id);      uint256 _currentDebt = calculateCurrentDebt(_id);      uint256 _maxPossible = _totalCollateralToken.mul(_ratioOfPrices).div(creditLineConstants[_id].idealCollateralRatio).mul(10**30).div(         10**_decimals     );      uint256 _borrowLimit = creditLineConstants[_id].borrowLimit;      if (_maxPossible &gt; _borrowLimit) {         _maxPossible = _borrowLimit;     }     if (_maxPossible &gt; _currentDebt) {         return _maxPossible.sub(_currentDebt);     }     return 0; }  function updateinterestAccruedTillLastPrincipalUpdate(uint256 _id) internal {     require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');      uint256 _interestAccrued = calculateInterestAccrued(_id);     uint256 _newInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(_interestAccrued);     creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _newInterestAccrued; }  function _depositCollateralFromSavingsAccount(     uint256 _id,     uint256 _amount,     address _sender ) internal {     address _collateralAsset = creditLineConstants[_id].collateralAsset;     address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();     ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);     uint256 _activeAmount;      for (uint256 _index = 0; _index &lt; _strategyList.length; _index++) {         address _strategy = _strategyList[_index];         uint256 _liquidityShares = _savingsAccount.balanceInShares(_sender, _collateralAsset, _strategy);         if (_liquidityShares == 0 || _strategyList[_index] == address(0)) {             continue;         }         uint256 _tokenInStrategy = _liquidityShares;         _tokenInStrategy = IYield(_strategy).getTokensForShares(_liquidityShares, _collateralAsset);          uint256 _tokensToTransfer = _tokenInStrategy;         if (_activeAmount.add(_tokenInStrategy) &gt;= _amount) {             _tokensToTransfer = (_amount.sub(_activeAmount));         }         _activeAmount = _activeAmount.add(_tokensToTransfer);         _savingsAccount.transferFrom(_tokensToTransfer, _collateralAsset, _strategy, _sender, address(this));          collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(             _liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy)         );          if (_amount == _activeAmount) {             return;         }     }     revert('CreditLine::_depositCollateralFromSavingsAccount - Insufficient balance'); }  /**  * @notice used to request a credit line either by borrower or lender  * @param _requestTo Address to which creditLine is requested,                      if borrower creates request then lender address and                      if lender creates then borrower address  * @param _borrowLimit maximum borrow amount in a credit line  * @param _borrowRate Interest Rate at which credit Line is requested  * @param _autoLiquidation if true, anyone can liquidate loan, otherwise only lender  * @param _collateralRatio ratio of the collateral to the debt below which credit line can be liquidated  * @param _borrowAsset address of the token to be borrowed  * @param _collateralAsset address of the token provided as collateral  * @param _requestAsLender if true, lender is placing request, otherwise borrower  * @return identifier for the credit line  */  function request(     address _requestTo,     uint256 _borrowLimit,     uint256 _borrowRate,     bool _autoLiquidation,     uint256 _collateralRatio,     address _borrowAsset,     address _collateralAsset,     bool _requestAsLender ) external returns (uint256) {     require(_borrowAsset != _collateralAsset, 'R: cant borrow lent token');     require(IPriceOracle(priceOracle).doesFeedExist(_borrowAsset, _collateralAsset), 'R: No price feed');      address _lender = _requestTo;     address _borrower = msg.sender;     if (_requestAsLender) {         _lender = msg.sender;         _borrower = _requestTo;     }      uint256 _id = _createRequest(         _lender,         _borrower,         _borrowLimit,         _borrowRate,         _autoLiquidation,         _collateralRatio,         _borrowAsset,         _collateralAsset,         _requestAsLender     );      emit CreditLineRequested(_id, _lender, _borrower);     return _id; }  function _createRequest(     address _lender,     address _borrower,     uint256 _borrowLimit,     uint256 _borrowRate,     bool _autoLiquidation,     uint256 _collateralRatio,     address _borrowAsset,     address _collateralAsset,     bool _requestByLender ) internal returns (uint256) {     require(_lender != _borrower, 'Lender and Borrower cannot be same addresses');     uint256 _id = creditLineCounter + 1;     creditLineCounter = _id;     creditLineVariables[_id].status = CreditLineStatus.REQUESTED;     creditLineConstants[_id].borrower = _borrower;     creditLineConstants[_id].lender = _lender;     creditLineConstants[_id].borrowLimit = _borrowLimit;     creditLineConstants[_id].autoLiquidation = _autoLiquidation;     creditLineConstants[_id].idealCollateralRatio = _collateralRatio;     creditLineConstants[_id].borrowRate = _borrowRate;     creditLineConstants[_id].borrowAsset = _borrowAsset;     creditLineConstants[_id].collateralAsset = _collateralAsset;     creditLineConstants[_id].requestByLender = _requestByLender;     return _id; }  /**  * @notice used to accept a credit line  * @dev if borrower places request, lender can accept and vice versa  * @param _id identifier for the credit line  */ function accept(uint256 _id) external {     require(         creditLineVariables[_id].status == CreditLineStatus.REQUESTED,         'CreditLine::acceptCreditLineLender - CreditLine is already accepted'     );     bool _requestByLender = creditLineConstants[_id].requestByLender;     require(         (msg.sender == creditLineConstants[_id].borrower &amp;&amp; _requestByLender) ||             (msg.sender == creditLineConstants[_id].lender &amp;&amp; !_requestByLender),         "Only Borrower or Lender who hasn't requested can accept"     );     creditLineVariables[_id].status = CreditLineStatus.ACTIVE;     emit CreditLineAccepted(_id); }  /**  * @notice used to deposit collateral into the credit line  * @dev collateral tokens have to be approved in savingsAccount or token contract(unless ether).         If transferred from savings account, the tokens are transferred from strategies in the          order prespecified in strategy registry  * @param _id identifier for the credit line  * @param _amount amount of collateral being deposited  * @param _strategy strategy to which collateral is to be deposited in case transfer is not from savings account  * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount                              otherwise direct from collateral token contract  */ function depositCollateral(     uint256 _id,     uint256 _amount,     address _strategy,     bool _fromSavingsAccount ) external payable nonReentrant ifCreditLineExists(_id) {     require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine not active');     _depositCollateral(_id, _amount, _strategy, _fromSavingsAccount);     emit CollateralDeposited(_id, _amount, _strategy); }  function _depositCollateral(     uint256 _id,     uint256 _amount,     address _strategy,     bool _fromSavingsAccount ) internal {     require(creditLineConstants[_id].lender != msg.sender, 'lender cant deposit collateral');     if (_fromSavingsAccount) {         _depositCollateralFromSavingsAccount(_id, _amount, msg.sender);     } else {         address _collateralAsset = creditLineConstants[_id].collateralAsset;         ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);         if (_collateralAsset == address(0)) {             require(msg.value == _amount, "CreditLine::_depositCollateral - value to transfer doesn't match argument");         } else {             IERC20(_collateralAsset).safeTransferFrom(msg.sender, address(this), _amount);             IERC20(_collateralAsset).approve(_strategy, _amount);         }         uint256 _sharesReceived = _savingsAccount.deposit{value: msg.value}(_amount, _collateralAsset, _strategy, address(this));         collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(_sharesReceived);     } }  function _withdrawBorrowAmount(     address _asset,     uint256 _amountInTokens,     address _lender ) internal {     address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();     ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);     uint256 _activeAmount;     for (uint256 _index = 0; _index &lt; _strategyList.length; _index++) {         if (_strategyList[_index] == address(0)) {             continue;         }         uint256 _liquidityShares = _savingsAccount.balanceInShares(_lender, _asset, _strategyList[_index]);         if (_liquidityShares != 0) {             uint256 tokenInStrategy = _liquidityShares;             tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);             uint256 _tokensToTransfer = tokenInStrategy;             if (_activeAmount.add(tokenInStrategy) &gt;= _amountInTokens) {                 _tokensToTransfer = (_amountInTokens.sub(_activeAmount));             }             _activeAmount = _activeAmount.add(_tokensToTransfer);             _savingsAccount.withdrawFrom(_tokensToTransfer, _asset, _strategyList[_index], _lender, address(this), false);             if (_activeAmount == _amountInTokens) {                 return;             }         }     }     require(_activeAmount == _amountInTokens, 'insufficient balance'); }  /**  * @notice used to borrow tokens from credit line by borrower  * @dev only borrower can call this function. Amount that can actually be borrowed is          min(amount based on borrowLimit, allowance to creditLine contract, balance of lender)  * @param _id identifier for the credit line  * @param _amount amount of tokens to borrow  */ function borrow(uint256 _id, uint256 _amount) external payable nonReentrant onlyCreditLineBorrower(_id) {     require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');     uint256 _borrowableAmount = calculateBorrowableAmount(_id);     require(_amount &lt;= _borrowableAmount, "CreditLine::borrow - The current collateral ratio doesn't allow to withdraw the amount");     address _borrowAsset = creditLineConstants[_id].borrowAsset;     address _lender = creditLineConstants[_id].lender;      updateinterestAccruedTillLastPrincipalUpdate(_id);     creditLineVariables[_id].principal = creditLineVariables[_id].principal.add(_amount);     creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;      uint256 _tokenDiffBalance;     if (_borrowAsset != address(0)) {         uint256 _balanceBefore = IERC20(_borrowAsset).balanceOf(address(this));         _withdrawBorrowAmount(_borrowAsset, _amount, _lender);         uint256 _balanceAfter = IERC20(_borrowAsset).balanceOf(address(this));         _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);     } else {         uint256 _balanceBefore = address(this).balance;         _withdrawBorrowAmount(_borrowAsset, _amount, _lender);         uint256 _balanceAfter = address(this).balance;         _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);     }     uint256 _protocolFee = _tokenDiffBalance.mul(protocolFeeFraction).div(10**30);     _tokenDiffBalance = _tokenDiffBalance.sub(_protocolFee);      if (_borrowAsset == address(0)) {         (bool feeSuccess, ) = protocolFeeCollector.call{value: _protocolFee}('');         require(feeSuccess, 'Transfer fail');         (bool success, ) = msg.sender.call{value: _tokenDiffBalance}('');         require(success, 'Transfer fail');     } else {         IERC20(_borrowAsset).safeTransfer(protocolFeeCollector, _protocolFee);         IERC20(_borrowAsset).safeTransfer(msg.sender, _tokenDiffBalance);     }     emit BorrowedFromCreditLine(_id, _tokenDiffBalance); }  function _repayFromSavingsAccount(     uint256 _amount,     address _asset,     address _lender ) internal {     address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();     ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);     uint256 _activeAmount;      for (uint256 _index = 0; _index &lt; _strategyList.length; _index++) {         if (_strategyList[_index] == address(0)) {             continue;         }         uint256 _liquidityShares = _savingsAccount.balanceInShares(msg.sender, _asset, _strategyList[_index]);         if (_liquidityShares == 0) {             continue;         }         uint256 _tokenInStrategy = _liquidityShares;         _tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);          uint256 _tokensToTransfer = _tokenInStrategy;         if (_activeAmount.add(_tokenInStrategy) &gt;= _amount) {             _tokensToTransfer = (_amount.sub(_activeAmount));         }         _activeAmount = _activeAmount.add(_tokensToTransfer);         _savingsAccount.transferFrom(_tokensToTransfer, _asset, _strategyList[_index], msg.sender, _lender);          if (_amount == _activeAmount) {             return;         }     }     revert('CreditLine::_repayFromSavingsAccount - Insufficient balance'); }  function _repay(     uint256 _id,     uint256 _amount,     bool _fromSavingsAccount,     uint256 _principalPaid ) internal {     ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);     address _defaultStrategy = defaultStrategy;     address _borrowAsset = creditLineConstants[_id].borrowAsset;     address _lender = creditLineConstants[_id].lender;     if (!_fromSavingsAccount) {         if (_borrowAsset == address(0)) {             require(msg.value == _amount, 'creditLine::repay - Ether sent not equal to repay amount');             _savingsAccount.deposit{value: _amount}(_amount, _borrowAsset, _defaultStrategy, _lender);         } else {             IERC20(_borrowAsset).safeTransferFrom(msg.sender, address(this), _amount);             IERC20(_borrowAsset).approve(_defaultStrategy, _amount);             _savingsAccount.deposit(_amount, _borrowAsset, _defaultStrategy, _lender);         }     } else {         _repayFromSavingsAccount(_amount, _borrowAsset, _lender);     }     if (_principalPaid != 0) {         _savingsAccount.increaseAllowanceToCreditLine(_principalPaid, _borrowAsset, _lender);     } }  /**  * @notice used to repay interest and principal to credit line. Interest has to be repaid before repaying principal  * @dev partial repayments possible  * @param _id identifier for the credit line  * @param _amount amount being repaid  * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount                              otherwise direct from collateral token contract  */ function repay(     uint256 _id,     uint256 _amount,     bool _fromSavingsAccount ) external payable nonReentrant {     require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');     require(creditLineConstants[_id].lender != msg.sender, 'Lender cant repay');      uint256 _interestSincePrincipalUpdate = calculateInterestAccrued(_id);     uint256 _totalInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(         _interestSincePrincipalUpdate     );     uint256 _interestToPay = _totalInterestAccrued.sub(creditLineVariables[_id].totalInterestRepaid);     uint256 _totalCurrentDebt = _interestToPay.add(creditLineVariables[_id].principal);     uint256 _principalPaid = 0;      if (_amount &gt;= _totalCurrentDebt) {         _amount = _totalCurrentDebt;         emit CompleteCreditLineRepaid(_id, _amount);     } else {         emit PartialCreditLineRepaid(_id, _amount);     }      if (_amount &gt; _interestToPay) {         creditLineVariables[_id].principal = _totalCurrentDebt.sub(_amount);         creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _totalInterestAccrued;         creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;         creditLineVariables[_id].totalInterestRepaid = _totalInterestAccrued;         _principalPaid = _amount.sub(_interestToPay);     } else {         creditLineVariables[_id].totalInterestRepaid = creditLineVariables[_id].totalInterestRepaid.add(_amount);     }      _repay(_id, _amount, _fromSavingsAccount, _principalPaid);      if (creditLineVariables[_id].principal == 0) {         _resetCreditLine(_id);     } }  function _resetCreditLine(uint256 _id) internal {     creditLineVariables[_id].lastPrincipalUpdateTime = 0;     creditLineVariables[_id].totalInterestRepaid = 0;     creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = 0;     emit CreditLineReset(_id); }  /**  * @dev used to close credit line by borrower or lender  * @param _id identifier for the credit line  */ function close(uint256 _id) external ifCreditLineExists(_id) {     require(         msg.sender == creditLineConstants[_id].borrower || msg.sender == creditLineConstants[_id].lender,         'CreditLine: Permission denied while closing Line of credit'     );     require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: Credit line should be active.');     require(creditLineVariables[_id].principal == 0, 'CreditLine: Cannot be closed since not repaid.');     require(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate == 0, 'CreditLine: Cannot be closed since not repaid.');     creditLineVariables[_id].status = CreditLineStatus.CLOSED;     emit CreditLineClosed(_id); }  /**  * @notice used to calculate the current collateral ratio  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view.         Interest is also considered while calculating debt  * @param _id identifier for the credit line  * @return collateral ratio multiplied by 10**30 to retain precision  */ function calculateCurrentCollateralRatio(uint256 _id) public ifCreditLineExists(_id) returns (uint256) {     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(         creditLineConstants[_id].collateralAsset,         creditLineConstants[_id].borrowAsset     );      uint256 currentDebt = calculateCurrentDebt(_id);     uint256 currentCollateralRatio = calculateTotalCollateralTokens(_id).mul(_ratioOfPrices).div(currentDebt).mul(10**30).div(         10**_decimals     );      return currentCollateralRatio; }  /**  * @notice used to calculate the total collateral tokens  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view  * @param _id identifier for the credit line  * @return _amount total collateral tokens deposited into the credit line  */ function calculateTotalCollateralTokens(uint256 _id) public returns (uint256 _amount) {     address _collateralAsset = creditLineConstants[_id].collateralAsset;     address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();     uint256 _liquidityShares;     for (uint256 index = 0; index &lt; _strategyList.length; index++) {         if (_strategyList[index] == address(0)) {             continue;         }         _liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];         uint256 _tokenInStrategy = _liquidityShares;         _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(_liquidityShares, _collateralAsset);          _amount = _amount.add(_tokenInStrategy);     } }  /**  * @notice used to withdraw any excess collateral  * @dev collateral can't be withdraw if collateralRatio goes below the ideal value. Only borrower can withdraw  * @param _id identifier for the credit line  * @param _amount amount of collateral to withdraw  * @param _toSavingsAccount if true, tokens are transferred from savingsAccount                              otherwise direct from collateral token contract  */ function withdrawCollateral(     uint256 _id,     uint256 _amount,     bool _toSavingsAccount ) external nonReentrant onlyCreditLineBorrower(_id) {     uint256 _withdrawableCollateral = withdrawableCollateral(_id);     require(_amount &lt;= _withdrawableCollateral, 'Collateral ratio cant go below ideal');     address _collateralAsset = creditLineConstants[_id].collateralAsset;     _transferCollateral(_id, _collateralAsset, _amount, _toSavingsAccount);     emit CollateralWithdrawn(_id, _amount); }  /**  * @notice used to calculate the collateral that can be withdrawn  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view  * @param _id identifier for the credit line  * @return total collateral withdrawable by borrower  */ function withdrawableCollateral(uint256 _id) public returns (uint256) {     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(         creditLineConstants[_id].collateralAsset,         creditLineConstants[_id].borrowAsset     );      uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);     uint256 _currentDebt = calculateCurrentDebt(_id);      uint256 _collateralNeeded = _currentDebt         .mul(creditLineConstants[_id].idealCollateralRatio)         .div(_ratioOfPrices)         .mul(10**_decimals)         .div(10**30);      if (_collateralNeeded &gt;= _totalCollateralTokens) {         return 0;     }     return _totalCollateralTokens.sub(_collateralNeeded); }  function _transferCollateral(     uint256 _id,     address _asset,     uint256 _amountInTokens,     bool _toSavingsAccount ) internal {     address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();     uint256 _activeAmount;     for (uint256 index = 0; index &lt; _strategyList.length; index++) {         uint256 liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];         if (liquidityShares == 0 || _strategyList[index] == address(0)) {             continue;         }         uint256 _tokenInStrategy = liquidityShares;         _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(liquidityShares, _asset);         uint256 _tokensToTransfer = _tokenInStrategy;         if (_activeAmount.add(_tokenInStrategy) &gt; _amountInTokens) {             _tokensToTransfer = _amountInTokens.sub(_activeAmount);             liquidityShares = liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy);         }         _activeAmount = _activeAmount.add(_tokensToTransfer);         collateralShareInStrategy[_id][_strategyList[index]] = collateralShareInStrategy[_id][_strategyList[index]].sub(             liquidityShares         );         if (_toSavingsAccount) {             ISavingsAccount(savingsAccount).transfer(_tokensToTransfer, _asset, _strategyList[index], msg.sender);         } else {             ISavingsAccount(savingsAccount).withdraw(_tokensToTransfer, _asset, _strategyList[index], msg.sender, false);         }          if (_activeAmount == _amountInTokens) {             return;         }     }     revert('insufficient collateral'); }  /**  * @notice used to liquidate credit line in case collateral ratio goes below the threshold  * @dev if lender liquidates, then collateral is directly transferred.          If autoLiquidation is true, anyone can liquidate by providing enough borrow tokens  * @param _id identifier for the credit line  * @param _toSavingsAccount if true, tokens are transferred from savingsAccount                              otherwise direct from collateral token contract  */ function liquidate(uint256 _id, bool _toSavingsAccount) external payable nonReentrant {     require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: Credit line should be active.');     require(creditLineVariables[_id].principal != 0, 'CreditLine: cannot liquidate if principal is 0');      uint256 currentCollateralRatio = calculateCurrentCollateralRatio(_id);     require(         currentCollateralRatio &lt; creditLineConstants[_id].idealCollateralRatio,         'CreditLine: Collateral ratio is higher than ideal value'     );      address _collateralAsset = creditLineConstants[_id].collateralAsset;     address _lender = creditLineConstants[_id].lender;     uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);     address _borrowAsset = creditLineConstants[_id].borrowAsset;      creditLineVariables[_id].status = CreditLineStatus.LIQUIDATED;      if (creditLineConstants[_id].autoLiquidation &amp;&amp; _lender != msg.sender) {         uint256 _borrowTokens = _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens);         if (_borrowAsset == address(0)) {             uint256 _returnETH = msg.value.sub(_borrowTokens, 'Insufficient ETH to liquidate');             if (_returnETH != 0) {                 (bool success, ) = msg.sender.call{value: _returnETH}('');                 require(success, 'Transfer fail');             }         } else {             IERC20(_borrowAsset).safeTransferFrom(msg.sender, _lender, _borrowTokens);         }     }      _transferCollateral(_id, _collateralAsset, _totalCollateralTokens, _toSavingsAccount);      emit CreditLineLiquidated(_id, msg.sender); }  /**  * @notice used to calculate the borrow tokens necessary for liquidator to liquidate  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view  * @param _id identifier for the credit line  * @return borrow tokens necessary for liquidator to liquidate  */ function borrowTokensToLiquidate(uint256 _id) external returns (uint256) {     address _collateralAsset = creditLineConstants[_id].collateralAsset;     uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);     address _borrowAsset = creditLineConstants[_id].borrowAsset;      return _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens); }  function _borrowTokensToLiquidate(     address _borrowAsset,     address _collateralAsset,     uint256 _totalCollateralTokens ) internal view returns (uint256) {     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(_borrowAsset, _collateralAsset);     uint256 _borrowTokens = (         _totalCollateralTokens.mul(uint256(10**30).sub(liquidatorRewardFraction)).div(10**30).mul(_ratioOfPrices).div(10**_decimals)     );      return _borrowTokens; }  receive() external payable {     require(msg.sender == savingsAccount, 'CreditLine::receive invalid transaction'); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-22-08 11:43:14 INFO] Security Analyst: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/utils/ReentrancyGuard.sol';
import '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';
import '../interfaces/IPriceOracle.sol';
import '../interfaces/IYield.sol';
import '../interfaces/ISavingsAccount.sol';
import '../SavingsAccount/SavingsAccountUtil.sol';
import '../interfaces/IStrategyRegistry.sol';

/**
 * @title Credit Line contract with Methods related to credit Line
 * @notice Implements the functions related to Credit Line
 * @author Sublime
 **/

contract CreditLine is ReentrancyGuard, OwnableUpgradeable {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    enum CreditLineStatus {
        NOT_CREATED,
        REQUESTED,
        ACTIVE,
        CLOSED,
        CANCELLED,
        LIQUIDATED
    }

    /**
     * @notice counter that tracks the number of credit lines created
     * @dev used to create unique identifier for credit lines
     **/
    uint256 public creditLineCounter;

    uint256 constant YEAR_IN_SECONDS = 365 days;

    struct CreditLineVariables {
        CreditLineStatus status;
        uint256 principal;
        uint256 totalInterestRepaid;
        uint256 lastPrincipalUpdateTime;
        uint256 interestAccruedTillLastPrincipalUpdate;
    }

    struct CreditLineConstants {
        address lender;
        address borrower;
        uint256 borrowLimit;
        uint256 idealCollateralRatio;
        uint256 borrowRate;
        address borrowAsset;
        address collateralAsset;
        bool autoLiquidation;
        bool requestByLender;
    }
    /**
     * @notice stores the collateral shares in a credit line per strategy
     * @dev creditLineId => Strategy => collateralShares
     **/
    mapping(uint256 => mapping(address => uint256)) public collateralShareInStrategy;

    /**
     * @notice stores the variables to maintain a credit line
     **/
    mapping(uint256 => CreditLineVariables) public creditLineVariables;

    /**
     * @notice stores the constants related to a credit line
     **/
    mapping(uint256 => CreditLineConstants) public creditLineConstants;

    /**
     * @notice stores the address of savings account contract
     **/
    address public savingsAccount;

    /**
     * @notice stores the address of price oracle contract
     **/
    address public priceOracle;

    /**
     * @notice stores the address of strategy registry contract
     **/
    address public strategyRegistry;

    /**
     * @notice stores the address of default strategy
     **/
    address public defaultStrategy;

    /**
     * @notice stores the fraction of borrowed amount charged as fee by protocol
     * @dev it is multiplied by 10**30
     **/
    uint256 public protocolFeeFraction;

    /**
     * @notice address where protocol fee is collected
     **/
    address public protocolFeeCollector;

    /**
     * @notice stores the fraction of amount liquidated given as reward to liquidator
     * @dev it is multiplied by 10**30
     **/
    uint256 public liquidatorRewardFraction;
    /**
     * @dev checks if Credit Line exists
     * @param _id identifier for the credit line
     **/
    modifier ifCreditLineExists(uint256 _id) {
        require(creditLineVariables[_id].status != CreditLineStatus.NOT_CREATED, 'Credit line does not exist');
        _;
    }

    /**
     * @dev checks if called by credit Line Borrower
     * @param _id creditLine identifier
     **/
    modifier onlyCreditLineBorrower(uint256 _id) {
        require(creditLineConstants[_id].borrower == msg.sender, 'Only credit line Borrower can access');
        _;
    }

    /**
     * @dev checks if called by credit Line Lender
     * @param _id creditLine identifier
     **/
    modifier onlyCreditLineLender(uint256 _id) {
        require(creditLineConstants[_id].lender == msg.sender, 'Only credit line Lender can access');
        _;
    }

    /**
     * @notice emitted when a collateral is deposited into credit line
     * @param id id of the credit line
     * @param amount amount of collateral deposited
     * @param strategy address of the strategy into which collateral is deposited
     */
    event CollateralDeposited(uint256 indexed id, uint256 amount, address indexed strategy);

    /**
     * @notice emitted when collateral is withdrawn from credit line
     * @param id id of the credit line
     * @param amount amount of collateral withdrawn
     */
    event CollateralWithdrawn(uint256 indexed id, uint256 amount);

    /**
     * @notice emitted when a request for new credit line is placed
     * @param id id of the credit line for which request was made
     * @param lender address of the lender for credit line
     * @param borrower address of the borrower for credit line
     */
    event CreditLineRequested(uint256 indexed id, address indexed lender, address indexed borrower);

    /**
     * @notice emitted when a credit line is liquidated
     * @param id id of the credit line which is liquidated
     * @param liquidator address of the liquidator
     */
    event CreditLineLiquidated(uint256 indexed id, address indexed liquidator);

    /**
     * @notice emitted when tokens are borrowed from credit line
     * @param id id of the credit line from which tokens are borrowed
     * @param borrowAmount amount of tokens borrowed
     */
    event BorrowedFromCreditLine(uint256 indexed id, uint256 borrowAmount);

    /**
     * @notice emitted when credit line is accepted
     * @param id id of the credit line that was accepted
     */
    event CreditLineAccepted(uint256 indexed id);

    /**
     * @notice emitted when credit line is completely repaid and reset
     * @param id id of the credit line that is reset
     */
    event CreditLineReset(uint256 indexed id);

    /**
     * @notice emitted when the credit line is partially repaid
     * @param id id of the credit line
     * @param repayAmount amount repaid
     */
    event PartialCreditLineRepaid(uint256 indexed id, uint256 repayAmount);

    /**
     * @notice emitted when the credit line is completely repaid
     * @param id id of the credit line
     * @param repayAmount amount repaid
     */
    event CompleteCreditLineRepaid(uint256 indexed id, uint256 repayAmount);

    /**
     * @notice emitted when the credit line is closed by one of the parties of credit line
     * @param id id of the credit line
     */
    event CreditLineClosed(uint256 indexed id);

    /**
     * @notice emitted when default strategy for the credit line is updated
     * @param defaultStrategy address of the strategy contract that is used as default by credit lines
     */
    event DefaultStrategyUpdated(address indexed defaultStrategy);

    /**
     * @notice emitted when the price oracle is updated
     * @param priceOracle address of the updated price oracle
     */
    event PriceOracleUpdated(address indexed priceOracle);

    /**
     * @notice emitted when the savings account address is updated
     * @param savingsAccount address of the updated savingsAccount
     */
    event SavingsAccountUpdated(address indexed savingsAccount);

    /**
     * @notice emitted when strategy registry address is updated
     * @param strategyRegistry address of the updated strategy registry
     */
    event StrategyRegistryUpdated(address indexed strategyRegistry);

    /**
     * @notice emitted when fee that protocol charges for credit line is updated
     * @param updatedProtocolFee updated value of protocolFeeFraction
     */
    event ProtocolFeeFractionUpdated(uint256 updatedProtocolFee);

    /**
     * @notice emitted when address which receives fee that protocol changes for pools is updated
     * @param updatedProtocolFeeCollector updated value of protocolFeeCollector
     */
    event ProtocolFeeCollectorUpdated(address indexed updatedProtocolFeeCollector);

    /**
     * @notice emitted when liquidatorRewardFraction is updated
     * @param liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator
     */
    event LiquidationRewardFractionUpdated(uint256 liquidatorRewardFraction);

    /**
     * @notice used to initialize the contract
     * @dev can only be called once during the life cycle of the contract
     * @param _defaultStrategy default strategy used in credit lines
     * @param _priceOracle address of the priceOracle
     * @param _savingsAccount address of  the savings account contract
     * @param _strategyRegistry address of the strategy registry contract
     * @param _owner address of owner who can change global variables
     * @param _protocolFeeFraction fraction of the fee charged by protocol
     * @param _protocolFeeCollector address to which protocol fee is charged to
     * @param _liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator
     */
    function initialize(
        address _defaultStrategy,
        address _priceOracle,
        address _savingsAccount,
        address _strategyRegistry,
        address _owner,
        uint256 _protocolFeeFraction,
        address _protocolFeeCollector,
        uint256 _liquidatorRewardFraction
    ) external initializer {
        OwnableUpgradeable.__Ownable_init();
        OwnableUpgradeable.transferOwnership(_owner);

        _updateDefaultStrategy(_defaultStrategy);
        _updatePriceOracle(_priceOracle);
        _updateSavingsAccount(_savingsAccount);
        _updateStrategyRegistry(_strategyRegistry);
        _updateProtocolFeeFraction(_protocolFeeFraction);
        _updateProtocolFeeCollector(_protocolFeeCollector);
        _updateLiquidatorRewardFraction(_liquidatorRewardFraction);
    }

    /**
     * @notice used to update the default strategy
     * @dev can only be updated by owner
     * @param _defaultStrategy address of the updated default strategy
     */
    function updateDefaultStrategy(address _defaultStrategy) external onlyOwner {
        _updateDefaultStrategy(_defaultStrategy);
    }

    function _updateDefaultStrategy(address _defaultStrategy) internal {
        defaultStrategy = _defaultStrategy;
        emit DefaultStrategyUpdated(_defaultStrategy);
    }

    /**
     * @notice used to update the price oracle
     * @dev can only be updated by owner
     * @param _priceOracle address of the updated price oracle
     */
    function updatePriceOracle(address _priceOracle) external onlyOwner {
        _updatePriceOracle(_priceOracle);
    }

    function _updatePriceOracle(address _priceOracle) internal {
        priceOracle = _priceOracle;
        emit PriceOracleUpdated(_priceOracle);
    }

    /**
     * @notice used to update the savings account address
     * @dev can only be updated by owner
     * @param _savingsAccount address of the updated savings account
     */
    function updateSavingsAccount(address _savingsAccount) external onlyOwner {
        _updateSavingsAccount(_savingsAccount);
    }

    function _updateSavingsAccount(address _savingsAccount) internal {
        savingsAccount = _savingsAccount;
        emit SavingsAccountUpdated(_savingsAccount);
    }

    /**
     * @notice used to update the protocol fee fraction
     * @dev can only be updated by owner
     * @param _protocolFee fraction of the borrower amount collected as protocol fee
     */
    function updateProtocolFeeFraction(uint256 _protocolFee) external onlyOwner {
        _updateProtocolFeeFraction(_protocolFee);
    }

    function _updateProtocolFeeFraction(uint256 _protocolFee) internal {
        protocolFeeFraction = _protocolFee;
        emit ProtocolFeeFractionUpdated(_protocolFee);
    }

    /**
     * @notice used to update the protocol fee collector
     * @dev can only be updated by owner
     * @param _protocolFeeCollector address in which protocol fee is collected
     */
    function updateProtocolFeeCollector(address _protocolFeeCollector) external onlyOwner {
        _updateProtocolFeeCollector(_protocolFeeCollector);
    }

    function _updateProtocolFeeCollector(address _protocolFeeCollector) internal {
        require(_protocolFeeCollector != address(0), 'cant be 0 address');
        protocolFeeCollector = _protocolFeeCollector;
        emit ProtocolFeeCollectorUpdated(_protocolFeeCollector);
    }

    /**
     * @notice used to update the strategy registry address
     * @dev can only be updated by owner
     * @param _strategyRegistry address of the updated strategy registry
     */
    function updateStrategyRegistry(address _strategyRegistry) external onlyOwner {
        _updateStrategyRegistry(_strategyRegistry);
    }

    function _updateStrategyRegistry(address _strategyRegistry) internal {
        require(_strategyRegistry != address(0), 'CL::I zero address');
        strategyRegistry = _strategyRegistry;
        emit StrategyRegistryUpdated(_strategyRegistry);
    }

    /**
     * @notice used to update the liquidatorRewardFraction
     * @dev can only be updated by owner
     * @param _rewardFraction fraction of liquidated amount given to liquidator as reward
     */
    function updateLiquidatorRewardFraction(uint256 _rewardFraction) external onlyOwner {
        _updateLiquidatorRewardFraction(_rewardFraction);
    }

    function _updateLiquidatorRewardFraction(uint256 _rewardFraction) internal {
        require(_rewardFraction <= 10**30, 'Fraction has to be less than 1');
        liquidatorRewardFraction = _rewardFraction;
        emit LiquidationRewardFractionUpdated(_rewardFraction);
    }

    /**
     * @dev Used to Calculate Interest Per second on given principal and Interest rate
     * @param _principal principal Amount for which interest has to be calculated.
     * @param _borrowRate It is the Interest Rate at which Credit Line is approved
     * @return interest per second for the given parameters
     */
    function calculateInterest(
        uint256 _principal,
        uint256 _borrowRate,
        uint256 _timeElapsed
    ) public pure returns (uint256) {
        uint256 _interest = _principal.mul(_borrowRate).mul(_timeElapsed).div(10**30).div(YEAR_IN_SECONDS);

        return _interest;
    }

    /**
     * @dev Used to calculate interest accrued since last repayment
     * @param _id identifier for the credit line
     * @return interest accrued over current borrowed amount since last repayment
     */

    function calculateInterestAccrued(uint256 _id) public view returns (uint256) {
        uint256 _lastPrincipalUpdateTime = creditLineVariables[_id].lastPrincipalUpdateTime;
        if (_lastPrincipalUpdateTime == 0) return 0;
        uint256 _timeElapsed = (block.timestamp).sub(_lastPrincipalUpdateTime);
        uint256 _interestAccrued = calculateInterest(creditLineVariables[_id].principal, creditLineConstants[_id].borrowRate, _timeElapsed);
        return _interestAccrued;
    }

    /**
     * @dev Used to calculate current debt of borrower against a credit line.
     * @param _id identifier for the credit line
     * @return current debt of borrower
     */
    function calculateCurrentDebt(uint256 _id) public view returns (uint256) {
        uint256 _interestAccrued = calculateInterestAccrued(_id);
        uint256 _currentDebt = (creditLineVariables[_id].principal)
            .add(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate)
            .add(_interestAccrued)
            .sub(creditLineVariables[_id].totalInterestRepaid);
        return _currentDebt;
    }

    /**
     * @notice used to calculate amount that can be borrowed by the borrower
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view.
            borrowableAmount changes per block as interest changes per block.
     * @param _id identifier for the credit line
     * @return amount that can be borrowed from the credit line
     */
    function calculateBorrowableAmount(uint256 _id) public returns (uint256) {
        CreditLineStatus _status = creditLineVariables[_id].status;
        require(
            _status == CreditLineStatus.ACTIVE || _status == CreditLineStatus.REQUESTED,
            'CreditLine: Cannot only if credit line ACTIVE or REQUESTED'
        );
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(
            creditLineConstants[_id].collateralAsset,
            creditLineConstants[_id].borrowAsset
        );

        uint256 _totalCollateralToken = calculateTotalCollateralTokens(_id);

        uint256 _currentDebt = calculateCurrentDebt(_id);

        uint256 _maxPossible = _totalCollateralToken.mul(_ratioOfPrices).div(creditLineConstants[_id].idealCollateralRatio).mul(10**30).div(
            10**_decimals
        );

        uint256 _borrowLimit = creditLineConstants[_id].borrowLimit;

        if (_maxPossible > _borrowLimit) {
            _maxPossible = _borrowLimit;
        }
        if (_maxPossible > _currentDebt) {
            return _maxPossible.sub(_currentDebt);
        }
        return 0;
    }

    function updateinterestAccruedTillLastPrincipalUpdate(uint256 _id) internal {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');

        uint256 _interestAccrued = calculateInterestAccrued(_id);
        uint256 _newInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(_interestAccrued);
        creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _newInterestAccrued;
    }

    function _depositCollateralFromSavingsAccount(
        uint256 _id,
        uint256 _amount,
        address _sender
    ) internal {
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        uint256 _activeAmount;

        for (uint256 _index = 0; _index < _strategyList.length; _index++) {
            address _strategy = _strategyList[_index];
            uint256 _liquidityShares = _savingsAccount.balanceInShares(_sender, _collateralAsset, _strategy);
            if (_liquidityShares == 0 || _strategyList[_index] == address(0)) {
                continue;
            }
            uint256 _tokenInStrategy = _liquidityShares;
            _tokenInStrategy = IYield(_strategy).getTokensForShares(_liquidityShares, _collateralAsset);

            uint256 _tokensToTransfer = _tokenInStrategy;
            if (_activeAmount.add(_tokenInStrategy) >= _amount) {
                _tokensToTransfer = (_amount.sub(_activeAmount));
            }
            _activeAmount = _activeAmount.add(_tokensToTransfer);
            _savingsAccount.transferFrom(_tokensToTransfer, _collateralAsset, _strategy, _sender, address(this));

            collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(
                _liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy)
            );

            if (_amount == _activeAmount) {
                return;
            }
        }
        revert('CreditLine::_depositCollateralFromSavingsAccount - Insufficient balance');
    }

    /**
     * @notice used to request a credit line either by borrower or lender
     * @param _requestTo Address to which creditLine is requested, 
                        if borrower creates request then lender address and 
                        if lender creates then borrower address
     * @param _borrowLimit maximum borrow amount in a credit line
     * @param _borrowRate Interest Rate at which credit Line is requested
     * @param _autoLiquidation if true, anyone can liquidate loan, otherwise only lender
     * @param _collateralRatio ratio of the collateral to the debt below which credit line can be liquidated
     * @param _borrowAsset address of the token to be borrowed
     * @param _collateralAsset address of the token provided as collateral
     * @param _requestAsLender if true, lender is placing request, otherwise borrower
     * @return identifier for the credit line
     */

    function request(
        address _requestTo,
        uint256 _borrowLimit,
        uint256 _borrowRate,
        bool _autoLiquidation,
        uint256 _collateralRatio,
        address _borrowAsset,
        address _collateralAsset,
        bool _requestAsLender
    ) external returns (uint256) {
        require(_borrowAsset != _collateralAsset, 'R: cant borrow lent token');
        require(IPriceOracle(priceOracle).doesFeedExist(_borrowAsset, _collateralAsset), 'R: No price feed');

        address _lender = _requestTo;
        address _borrower = msg.sender;
        if (_requestAsLender) {
            _lender = msg.sender;
            _borrower = _requestTo;
        }

        uint256 _id = _createRequest(
            _lender,
            _borrower,
            _borrowLimit,
            _borrowRate,
            _autoLiquidation,
            _collateralRatio,
            _borrowAsset,
            _collateralAsset,
            _requestAsLender
        );

        emit CreditLineRequested(_id, _lender, _borrower);
        return _id;
    }

    function _createRequest(
        address _lender,
        address _borrower,
        uint256 _borrowLimit,
        uint256 _borrowRate,
        bool _autoLiquidation,
        uint256 _collateralRatio,
        address _borrowAsset,
        address _collateralAsset,
        bool _requestByLender
    ) internal returns (uint256) {
        require(_lender != _borrower, 'Lender and Borrower cannot be same addresses');
        uint256 _id = creditLineCounter + 1;
        creditLineCounter = _id;
        creditLineVariables[_id].status = CreditLineStatus.REQUESTED;
        creditLineConstants[_id].borrower = _borrower;
        creditLineConstants[_id].lender = _lender;
        creditLineConstants[_id].borrowLimit = _borrowLimit;
        creditLineConstants[_id].autoLiquidation = _autoLiquidation;
        creditLineConstants[_id].idealCollateralRatio = _collateralRatio;
        creditLineConstants[_id].borrowRate = _borrowRate;
        creditLineConstants[_id].borrowAsset = _borrowAsset;
        creditLineConstants[_id].collateralAsset = _collateralAsset;
        creditLineConstants[_id].requestByLender = _requestByLender;
        return _id;
    }

    /**
     * @notice used to accept a credit line
     * @dev if borrower places request, lender can accept and vice versa
     * @param _id identifier for the credit line
     */
    function accept(uint256 _id) external {
        require(
            creditLineVariables[_id].status == CreditLineStatus.REQUESTED,
            'CreditLine::acceptCreditLineLender - CreditLine is already accepted'
        );
        bool _requestByLender = creditLineConstants[_id].requestByLender;
        require(
            (msg.sender == creditLineConstants[_id].borrower && _requestByLender) ||
                (msg.sender == creditLineConstants[_id].lender && !_requestByLender),
            "Only Borrower or Lender who hasn't requested can accept"
        );
        creditLineVariables[_id].status = CreditLineStatus.ACTIVE;
        emit CreditLineAccepted(_id);
    }

    /**
     * @notice used to deposit collateral into the credit line
     * @dev collateral tokens have to be approved in savingsAccount or token contract(unless ether).
            If transferred from savings account, the tokens are transferred from strategies in the 
            order prespecified in strategy registry
     * @param _id identifier for the credit line
     * @param _amount amount of collateral being deposited
     * @param _strategy strategy to which collateral is to be deposited in case transfer is not from savings account
     * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount 
                                otherwise direct from collateral token contract
     */
    function depositCollateral(
        uint256 _id,
        uint256 _amount,
        address _strategy,
        bool _fromSavingsAccount
    ) external payable nonReentrant ifCreditLineExists(_id) {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine not active');
        _depositCollateral(_id, _amount, _strategy, _fromSavingsAccount);
        emit CollateralDeposited(_id, _amount, _strategy);
    }

    function _depositCollateral(
        uint256 _id,
        uint256 _amount,
        address _strategy,
        bool _fromSavingsAccount
    ) internal {
        require(creditLineConstants[_id].lender != msg.sender, 'lender cant deposit collateral');
        if (_fromSavingsAccount) {
            _depositCollateralFromSavingsAccount(_id, _amount, msg.sender);
        } else {
            address _collateralAsset = creditLineConstants[_id].collateralAsset;
            ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
            if (_collateralAsset == address(0)) {
                require(msg.value == _amount, "CreditLine::_depositCollateral - value to transfer doesn't match argument");
            } else {
                IERC20(_collateralAsset).safeTransferFrom(msg.sender, address(this), _amount);
                IERC20(_collateralAsset).approve(_strategy, _amount);
            }
            uint256 _sharesReceived = _savingsAccount.deposit{value: msg.value}(_amount, _collateralAsset, _strategy, address(this));
            collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(_sharesReceived);
        }
    }

    function _withdrawBorrowAmount(
        address _asset,
        uint256 _amountInTokens,
        address _lender
    ) internal {
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        uint256 _activeAmount;
        for (uint256 _index = 0; _index < _strategyList.length; _index++) {
            if (_strategyList[_index] == address(0)) {
                continue;
            }
            uint256 _liquidityShares = _savingsAccount.balanceInShares(_lender, _asset, _strategyList[_index]);
            if (_liquidityShares != 0) {
                uint256 tokenInStrategy = _liquidityShares;
                tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);
                uint256 _tokensToTransfer = tokenInStrategy;
                if (_activeAmount.add(tokenInStrategy) >= _amountInTokens) {
                    _tokensToTransfer = (_amountInTokens.sub(_activeAmount));
                }
                _activeAmount = _activeAmount.add(_tokensToTransfer);
                _savingsAccount.withdrawFrom(_tokensToTransfer, _asset, _strategyList[_index], _lender, address(this), false);
                if (_activeAmount == _amountInTokens) {
                    return;
                }
            }
        }
        require(_activeAmount == _amountInTokens, 'insufficient balance');
    }

    /**
     * @notice used to borrow tokens from credit line by borrower
     * @dev only borrower can call this function. Amount that can actually be borrowed is 
            min(amount based on borrowLimit, allowance to creditLine contract, balance of lender)
     * @param _id identifier for the credit line
     * @param _amount amount of tokens to borrow
     */
    function borrow(uint256 _id, uint256 _amount) external payable nonReentrant onlyCreditLineBorrower(_id) {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');
        uint256 _borrowableAmount = calculateBorrowableAmount(_id);
        require(_amount <= _borrowableAmount, "CreditLine::borrow - The current collateral ratio doesn't allow to withdraw the amount");
        address _borrowAsset = creditLineConstants[_id].borrowAsset;
        address _lender = creditLineConstants[_id].lender;

        updateinterestAccruedTillLastPrincipalUpdate(_id);
        creditLineVariables[_id].principal = creditLineVariables[_id].principal.add(_amount);
        creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;

        uint256 _tokenDiffBalance;
        if (_borrowAsset != address(0)) {
            uint256 _balanceBefore = IERC20(_borrowAsset).balanceOf(address(this));
            _withdrawBorrowAmount(_borrowAsset, _amount, _lender);
            uint256 _balanceAfter = IERC20(_borrowAsset).balanceOf(address(this));
            _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);
        } else {
            uint256 _balanceBefore = address(this).balance;
            _withdrawBorrowAmount(_borrowAsset, _amount, _lender);
            uint256 _balanceAfter = address(this).balance;
            _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);
        }
        uint256 _protocolFee = _tokenDiffBalance.mul(protocolFeeFraction).div(10**30);
        _tokenDiffBalance = _tokenDiffBalance.sub(_protocolFee);

        if (_borrowAsset == address(0)) {
            (bool feeSuccess, ) = protocolFeeCollector.call{value: _protocolFee}('');
            require(feeSuccess, 'Transfer fail');
            (bool success, ) = msg.sender.call{value: _tokenDiffBalance}('');
            require(success, 'Transfer fail');
        } else {
            IERC20(_borrowAsset).safeTransfer(protocolFeeCollector, _protocolFee);
            IERC20(_borrowAsset).safeTransfer(msg.sender, _tokenDiffBalance);
        }
        emit BorrowedFromCreditLine(_id, _tokenDiffBalance);
    }

    function _repayFromSavingsAccount(
        uint256 _amount,
        address _asset,
        address _lender
    ) internal {
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        uint256 _activeAmount;

        for (uint256 _index = 0; _index < _strategyList.length; _index++) {
            if (_strategyList[_index] == address(0)) {
                continue;
            }
            uint256 _liquidityShares = _savingsAccount.balanceInShares(msg.sender, _asset, _strategyList[_index]);
            if (_liquidityShares == 0) {
                continue;
            }
            uint256 _tokenInStrategy = _liquidityShares;
            _tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);

            uint256 _tokensToTransfer = _tokenInStrategy;
            if (_activeAmount.add(_tokenInStrategy) >= _amount) {
                _tokensToTransfer = (_amount.sub(_activeAmount));
            }
            _activeAmount = _activeAmount.add(_tokensToTransfer);
            _savingsAccount.transferFrom(_tokensToTransfer, _asset, _strategyList[_index], msg.sender, _lender);

            if (_amount == _activeAmount) {
                return;
            }
        }
        revert('CreditLine::_repayFromSavingsAccount - Insufficient balance');
    }

    function _repay(
        uint256 _id,
        uint256 _amount,
        bool _fromSavingsAccount,
        uint256 _principalPaid
    ) internal {
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        address _defaultStrategy = defaultStrategy;
        address _borrowAsset = creditLineConstants[_id].borrowAsset;
        address _lender = creditLineConstants[_id].lender;
        if (!_fromSavingsAccount) {
            if (_borrowAsset == address(0)) {
                require(msg.value == _amount, 'creditLine::repay - Ether sent not equal to repay amount');
                _savingsAccount.deposit{value: _amount}(_amount, _borrowAsset, _defaultStrategy, _lender);
            } else {
                IERC20(_borrowAsset).safeTransferFrom(msg.sender, address(this), _amount);
                IERC20(_borrowAsset).approve(_defaultStrategy, _amount);
                _savingsAccount.deposit(_amount, _borrowAsset, _defaultStrategy, _lender);
            }
        } else {
            _repayFromSavingsAccount(_amount, _borrowAsset, _lender);
        }
        if (_principalPaid != 0) {
            _savingsAccount.increaseAllowanceToCreditLine(_principalPaid, _borrowAsset, _lender);
        }
    }

    /**
     * @notice used to repay interest and principal to credit line. Interest has to be repaid before repaying principal
     * @dev partial repayments possible
     * @param _id identifier for the credit line
     * @param _amount amount being repaid
     * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount 
                                otherwise direct from collateral token contract
     */
    function repay(
        uint256 _id,
        uint256 _amount,
        bool _fromSavingsAccount
    ) external payable nonReentrant {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');
        require(creditLineConstants[_id].lender != msg.sender, 'Lender cant repay');

        uint256 _interestSincePrincipalUpdate = calculateInterestAccrued(_id);
        uint256 _totalInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(
            _interestSincePrincipalUpdate
        );
        uint256 _interestToPay = _totalInterestAccrued.sub(creditLineVariables[_id].totalInterestRepaid);
        uint256 _totalCurrentDebt = _interestToPay.add(creditLineVariables[_id].principal);
        uint256 _principalPaid = 0;

        if (_amount >= _totalCurrentDebt) {
            _amount = _totalCurrentDebt;
            emit CompleteCreditLineRepaid(_id, _amount);
        } else {
            emit PartialCreditLineRepaid(_id, _amount);
        }

        if (_amount > _interestToPay) {
            creditLineVariables[_id].principal = _totalCurrentDebt.sub(_amount);
            creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _totalInterestAccrued;
            creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;
            creditLineVariables[_id].totalInterestRepaid = _totalInterestAccrued;
            _principalPaid = _amount.sub(_interestToPay);
        } else {
            creditLineVariables[_id].totalInterestRepaid = creditLineVariables[_id].totalInterestRepaid.add(_amount);
        }

        _repay(_id, _amount, _fromSavingsAccount, _principalPaid);

        if (creditLineVariables[_id].principal == 0) {
            _resetCreditLine(_id);
        }
    }

    function _resetCreditLine(uint256 _id) internal {
        creditLineVariables[_id].lastPrincipalUpdateTime = 0;
        creditLineVariables[_id].totalInterestRepaid = 0;
        creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = 0;
        emit CreditLineReset(_id);
    }

    /**
     * @dev used to close credit line by borrower or lender
     * @param _id identifier for the credit line
     */
    function close(uint256 _id) external ifCreditLineExists(_id) {
        require(
            msg.sender == creditLineConstants[_id].borrower || msg.sender == creditLineConstants[_id].lender,
            'CreditLine: Permission denied while closing Line of credit'
        );
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: Credit line should be active.');
        require(creditLineVariables[_id].principal == 0, 'CreditLine: Cannot be closed since not repaid.');
        require(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate == 0, 'CreditLine: Cannot be closed since not repaid.');
        creditLineVariables[_id].status = CreditLineStatus.CLOSED;
        emit CreditLineClosed(_id);
    }

    /**
     * @notice used to calculate the current collateral ratio
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view.
            Interest is also considered while calculating debt
     * @param _id identifier for the credit line
     * @return collateral ratio multiplied by 10**30 to retain precision
     */
    function calculateCurrentCollateralRatio(uint256 _id) public ifCreditLineExists(_id) returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(
            creditLineConstants[_id].collateralAsset,
            creditLineConstants[_id].borrowAsset
        );

        uint256 currentDebt = calculateCurrentDebt(_id);
        uint256 currentCollateralRatio = calculateTotalCollateralTokens(_id).mul(_ratioOfPrices).div(currentDebt).mul(10**30).div(
            10**_decimals
        );

        return currentCollateralRatio;
    }

    /**
     * @notice used to calculate the total collateral tokens
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @param _id identifier for the credit line
     * @return _amount total collateral tokens deposited into the credit line
     */
    function calculateTotalCollateralTokens(uint256 _id) public returns (uint256 _amount) {
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        uint256 _liquidityShares;
        for (uint256 index = 0; index < _strategyList.length; index++) {
            if (_strategyList[index] == address(0)) {
                continue;
            }
            _liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];
            uint256 _tokenInStrategy = _liquidityShares;
            _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(_liquidityShares, _collateralAsset);

            _amount = _amount.add(_tokenInStrategy);
        }
    }

    /**
     * @notice used to withdraw any excess collateral
     * @dev collateral can't be withdraw if collateralRatio goes below the ideal value. Only borrower can withdraw
     * @param _id identifier for the credit line
     * @param _amount amount of collateral to withdraw
     * @param _toSavingsAccount if true, tokens are transferred from savingsAccount 
                                otherwise direct from collateral token contract
     */
    function withdrawCollateral(
        uint256 _id,
        uint256 _amount,
        bool _toSavingsAccount
    ) external nonReentrant onlyCreditLineBorrower(_id) {
        uint256 _withdrawableCollateral = withdrawableCollateral(_id);
        require(_amount <= _withdrawableCollateral, 'Collateral ratio cant go below ideal');
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        _transferCollateral(_id, _collateralAsset, _amount, _toSavingsAccount);
        emit CollateralWithdrawn(_id, _amount);
    }

    /**
     * @notice used to calculate the collateral that can be withdrawn
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @param _id identifier for the credit line
     * @return total collateral withdrawable by borrower
     */
    function withdrawableCollateral(uint256 _id) public returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(
            creditLineConstants[_id].collateralAsset,
            creditLineConstants[_id].borrowAsset
        );

        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);
        uint256 _currentDebt = calculateCurrentDebt(_id);

        uint256 _collateralNeeded = _currentDebt
            .mul(creditLineConstants[_id].idealCollateralRatio)
            .div(_ratioOfPrices)
            .mul(10**_decimals)
            .div(10**30);

        if (_collateralNeeded >= _totalCollateralTokens) {
            return 0;
        }
        return _totalCollateralTokens.sub(_collateralNeeded);
    }

    function _transferCollateral(
        uint256 _id,
        address _asset,
        uint256 _amountInTokens,
        bool _toSavingsAccount
    ) internal {
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        uint256 _activeAmount;
        for (uint256 index = 0; index < _strategyList.length; index++) {
            uint256 liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];
            if (liquidityShares == 0 || _strategyList[index] == address(0)) {
                continue;
            }
            uint256 _tokenInStrategy = liquidityShares;
            _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(liquidityShares, _asset);
            uint256 _tokensToTransfer = _tokenInStrategy;
            if (_activeAmount.add(_tokenInStrategy) > _amountInTokens) {
                _tokensToTransfer = _amountInTokens.sub(_activeAmount);
                liquidityShares = liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy);
            }
            _activeAmount = _activeAmount.add(_tokensToTransfer);
            collateralShareInStrategy[_id][_strategyList[index]] = collateralShareInStrategy[_id][_strategyList[index]].sub(
                liquidityShares
            );
            if (_toSavingsAccount) {
                ISavingsAccount(savingsAccount).transfer(_tokensToTransfer, _asset, _strategyList[index], msg.sender);
            } else {
                ISavingsAccount(savingsAccount).withdraw(_tokensToTransfer, _asset, _strategyList[index], msg.sender, false);
            }

            if (_activeAmount == _amountInTokens) {
                return;
            }
        }
        revert('insufficient collateral');
    }

    /**
     * @notice used to liquidate credit line in case collateral ratio goes below the threshold
     * @dev if lender liquidates, then collateral is directly transferred. 
            If autoLiquidation is true, anyone can liquidate by providing enough borrow tokens
     * @param _id identifier for the credit line
     * @param _toSavingsAccount if true, tokens are transferred from savingsAccount 
                                otherwise direct from collateral token contract
     */
    function liquidate(uint256 _id, bool _toSavingsAccount) external payable nonReentrant {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: Credit line should be active.');
        require(creditLineVariables[_id].principal != 0, 'CreditLine: cannot liquidate if principal is 0');

        uint256 currentCollateralRatio = calculateCurrentCollateralRatio(_id);
        require(
            currentCollateralRatio < creditLineConstants[_id].idealCollateralRatio,
            'CreditLine: Collateral ratio is higher than ideal value'
        );

        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        address _lender = creditLineConstants[_id].lender;
        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);
        address _borrowAsset = creditLineConstants[_id].borrowAsset;

        creditLineVariables[_id].status = CreditLineStatus.LIQUIDATED;

        if (creditLineConstants[_id].autoLiquidation && _lender != msg.sender) {
            uint256 _borrowTokens = _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens);
            if (_borrowAsset == address(0)) {
                uint256 _returnETH = msg.value.sub(_borrowTokens, 'Insufficient ETH to liquidate');
                if (_returnETH != 0) {
                    (bool success, ) = msg.sender.call{value: _returnETH}('');
                    require(success, 'Transfer fail');
                }
            } else {
                IERC20(_borrowAsset).safeTransferFrom(msg.sender, _lender, _borrowTokens);
            }
        }

        _transferCollateral(_id, _collateralAsset, _totalCollateralTokens, _toSavingsAccount);

        emit CreditLineLiquidated(_id, msg.sender);
    }

    /**
     * @notice used to calculate the borrow tokens necessary for liquidator to liquidate
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @param _id identifier for the credit line
     * @return borrow tokens necessary for liquidator to liquidate
     */
    function borrowTokensToLiquidate(uint256 _id) external returns (uint256) {
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);
        address _borrowAsset = creditLineConstants[_id].borrowAsset;

        return _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens);
    }

    function _borrowTokensToLiquidate(
        address _borrowAsset,
        address _collateralAsset,
        uint256 _totalCollateralTokens
    ) internal view returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(_borrowAsset, _collateralAsset);
        uint256 _borrowTokens = (
            _totalCollateralTokens.mul(uint256(10**30).sub(liquidatorRewardFraction)).div(10**30).mul(_ratioOfPrices).div(10**_decimals)
        );

        return _borrowTokens;
    }

    receive() external payable {
        require(msg.sender == savingsAccount, 'CreditLine::receive invalid transaction');
    }
}
.]

Below are the details of our smart contract codes and their corresponding analysis reports:
Task: "".
As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report.

[2024-22-08 11:43:25 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-22-08 11:43:25 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 10083
completion_tokens: 877
total_tokens: 10960
cost: $-1.000000


[2024-22-08 11:43:25 INFO] Solidity Programming Expert: **Solidity Programming Expert<->Security Analyst on : BugsSummary, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/utils/ReentrancyGuard.sol';
import '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';
import '../interfaces/IPriceOracle.sol';
import '../interfaces/IYield.sol';
import '../interfaces/ISavingsAccount.sol';
import '../SavingsAccount/SavingsAccountUtil.sol';
import '../interfaces/IStrategyRegistry.sol';

/**
 * @title Credit Line contract with Methods related to credit Line
 * @notice Implements the functions related to Credit Line
 * @author Sublime
 **/

contract CreditLine is ReentrancyGuard, OwnableUpgradeable {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    enum CreditLineStatus {
        NOT_CREATED,
        REQUESTED,
        ACTIVE,
        CLOSED,
        CANCELLED,
        LIQUIDATED
    }

    /**
     * @notice counter that tracks the number of credit lines created
     * @dev used to create unique identifier for credit lines
     **/
    uint256 public creditLineCounter;

    uint256 constant YEAR_IN_SECONDS = 365 days;

    struct CreditLineVariables {
        CreditLineStatus status;
        uint256 principal;
        uint256 totalInterestRepaid;
        uint256 lastPrincipalUpdateTime;
        uint256 interestAccruedTillLastPrincipalUpdate;
    }

    struct CreditLineConstants {
        address lender;
        address borrower;
        uint256 borrowLimit;
        uint256 idealCollateralRatio;
        uint256 borrowRate;
        address borrowAsset;
        address collateralAsset;
        bool autoLiquidation;
        bool requestByLender;
    }
    /**
     * @notice stores the collateral shares in a credit line per strategy
     * @dev creditLineId => Strategy => collateralShares
     **/
    mapping(uint256 => mapping(address => uint256)) public collateralShareInStrategy;

    /**
     * @notice stores the variables to maintain a credit line
     **/
    mapping(uint256 => CreditLineVariables) public creditLineVariables;

    /**
     * @notice stores the constants related to a credit line
     **/
    mapping(uint256 => CreditLineConstants) public creditLineConstants;

    /**
     * @notice stores the address of savings account contract
     **/
    address public savingsAccount;

    /**
     * @notice stores the address of price oracle contract
     **/
    address public priceOracle;

    /**
     * @notice stores the address of strategy registry contract
     **/
    address public strategyRegistry;

    /**
     * @notice stores the address of default strategy
     **/
    address public defaultStrategy;

    /**
     * @notice stores the fraction of borrowed amount charged as fee by protocol
     * @dev it is multiplied by 10**30
     **/
    uint256 public protocolFeeFraction;

    /**
     * @notice address where protocol fee is collected
     **/
    address public protocolFeeCollector;

    /**
     * @notice stores the fraction of amount liquidated given as reward to liquidator
     * @dev it is multiplied by 10**30
     **/
    uint256 public liquidatorRewardFraction;
    /**
     * @dev checks if Credit Line exists
     * @param _id identifier for the credit line
     **/
    modifier ifCreditLineExists(uint256 _id) {
        require(creditLineVariables[_id].status != CreditLineStatus.NOT_CREATED, 'Credit line does not exist');
        _;
    }

    /**
     * @dev checks if called by credit Line Borrower
     * @param _id creditLine identifier
     **/
    modifier onlyCreditLineBorrower(uint256 _id) {
        require(creditLineConstants[_id].borrower == msg.sender, 'Only credit line Borrower can access');
        _;
    }

    /**
     * @dev checks if called by credit Line Lender
     * @param _id creditLine identifier
     **/
    modifier onlyCreditLineLender(uint256 _id) {
        require(creditLineConstants[_id].lender == msg.sender, 'Only credit line Lender can access');
        _;
    }

    /**
     * @notice emitted when a collateral is deposited into credit line
     * @param id id of the credit line
     * @param amount amount of collateral deposited
     * @param strategy address of the strategy into which collateral is deposited
     */
    event CollateralDeposited(uint256 indexed id, uint256 amount, address indexed strategy);

    /**
     * @notice emitted when collateral is withdrawn from credit line
     * @param id id of the credit line
     * @param amount amount of collateral withdrawn
     */
    event CollateralWithdrawn(uint256 indexed id, uint256 amount);

    /**
     * @notice emitted when a request for new credit line is placed
     * @param id id of the credit line for which request was made
     * @param lender address of the lender for credit line
     * @param borrower address of the borrower for credit line
     */
    event CreditLineRequested(uint256 indexed id, address indexed lender, address indexed borrower);

    /**
     * @notice emitted when a credit line is liquidated
     * @param id id of the credit line which is liquidated
     * @param liquidator address of the liquidator
     */
    event CreditLineLiquidated(uint256 indexed id, address indexed liquidator);

    /**
     * @notice emitted when tokens are borrowed from credit line
     * @param id id of the credit line from which tokens are borrowed
     * @param borrowAmount amount of tokens borrowed
     */
    event BorrowedFromCreditLine(uint256 indexed id, uint256 borrowAmount);

    /**
     * @notice emitted when credit line is accepted
     * @param id id of the credit line that was accepted
     */
    event CreditLineAccepted(uint256 indexed id);

    /**
     * @notice emitted when credit line is completely repaid and reset
     * @param id id of the credit line that is reset
     */
    event CreditLineReset(uint256 indexed id);

    /**
     * @notice emitted when the credit line is partially repaid
     * @param id id of the credit line
     * @param repayAmount amount repaid
     */
    event PartialCreditLineRepaid(uint256 indexed id, uint256 repayAmount);

    /**
     * @notice emitted when the credit line is completely repaid
     * @param id id of the credit line
     * @param repayAmount amount repaid
     */
    event CompleteCreditLineRepaid(uint256 indexed id, uint256 repayAmount);

    /**
     * @notice emitted when the credit line is closed by one of the parties of credit line
     * @param id id of the credit line
     */
    event CreditLineClosed(uint256 indexed id);

    /**
     * @notice emitted when default strategy for the credit line is updated
     * @param defaultStrategy address of the strategy contract that is used as default by credit lines
     */
    event DefaultStrategyUpdated(address indexed defaultStrategy);

    /**
     * @notice emitted when the price oracle is updated
     * @param priceOracle address of the updated price oracle
     */
    event PriceOracleUpdated(address indexed priceOracle);

    /**
     * @notice emitted when the savings account address is updated
     * @param savingsAccount address of the updated savingsAccount
     */
    event SavingsAccountUpdated(address indexed savingsAccount);

    /**
     * @notice emitted when strategy registry address is updated
     * @param strategyRegistry address of the updated strategy registry
     */
    event StrategyRegistryUpdated(address indexed strategyRegistry);

    /**
     * @notice emitted when fee that protocol charges for credit line is updated
     * @param updatedProtocolFee updated value of protocolFeeFraction
     */
    event ProtocolFeeFractionUpdated(uint256 updatedProtocolFee);

    /**
     * @notice emitted when address which receives fee that protocol changes for pools is updated
     * @param updatedProtocolFeeCollector updated value of protocolFeeCollector
     */
    event ProtocolFeeCollectorUpdated(address indexed updatedProtocolFeeCollector);

    /**
     * @notice emitted when liquidatorRewardFraction is updated
     * @param liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator
     */
    event LiquidationRewardFractionUpdated(uint256 liquidatorRewardFraction);

    /**
     * @notice used to initialize the contract
     * @dev can only be called once during the life cycle of the contract
     * @param _defaultStrategy default strategy used in credit lines
     * @param _priceOracle address of the priceOracle
     * @param _savingsAccount address of  the savings account contract
     * @param _strategyRegistry address of the strategy registry contract
     * @param _owner address of owner who can change global variables
     * @param _protocolFeeFraction fraction of the fee charged by protocol
     * @param _protocolFeeCollector address to which protocol fee is charged to
     * @param _liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator
     */
    function initialize(
        address _defaultStrategy,
        address _priceOracle,
        address _savingsAccount,
        address _strategyRegistry,
        address _owner,
        uint256 _protocolFeeFraction,
        address _protocolFeeCollector,
        uint256 _liquidatorRewardFraction
    ) external initializer {
        OwnableUpgradeable.__Ownable_init();
        OwnableUpgradeable.transferOwnership(_owner);

        _updateDefaultStrategy(_defaultStrategy);
        _updatePriceOracle(_priceOracle);
        _updateSavingsAccount(_savingsAccount);
        _updateStrategyRegistry(_strategyRegistry);
        _updateProtocolFeeFraction(_protocolFeeFraction);
        _updateProtocolFeeCollector(_protocolFeeCollector);
        _updateLiquidatorRewardFraction(_liquidatorRewardFraction);
    }

    /**
     * @notice used to update the default strategy
     * @dev can only be updated by owner
     * @param _defaultStrategy address of the updated default strategy
     */
    function updateDefaultStrategy(address _defaultStrategy) external onlyOwner {
        _updateDefaultStrategy(_defaultStrategy);
    }

    function _updateDefaultStrategy(address _defaultStrategy) internal {
        defaultStrategy = _defaultStrategy;
        emit DefaultStrategyUpdated(_defaultStrategy);
    }

    /**
     * @notice used to update the price oracle
     * @dev can only be updated by owner
     * @param _priceOracle address of the updated price oracle
     */
    function updatePriceOracle(address _priceOracle) external onlyOwner {
        _updatePriceOracle(_priceOracle);
    }

    function _updatePriceOracle(address _priceOracle) internal {
        priceOracle = _priceOracle;
        emit PriceOracleUpdated(_priceOracle);
    }

    /**
     * @notice used to update the savings account address
     * @dev can only be updated by owner
     * @param _savingsAccount address of the updated savings account
     */
    function updateSavingsAccount(address _savingsAccount) external onlyOwner {
        _updateSavingsAccount(_savingsAccount);
    }

    function _updateSavingsAccount(address _savingsAccount) internal {
        savingsAccount = _savingsAccount;
        emit SavingsAccountUpdated(_savingsAccount);
    }

    /**
     * @notice used to update the protocol fee fraction
     * @dev can only be updated by owner
     * @param _protocolFee fraction of the borrower amount collected as protocol fee
     */
    function updateProtocolFeeFraction(uint256 _protocolFee) external onlyOwner {
        _updateProtocolFeeFraction(_protocolFee);
    }

    function _updateProtocolFeeFraction(uint256 _protocolFee) internal {
        protocolFeeFraction = _protocolFee;
        emit ProtocolFeeFractionUpdated(_protocolFee);
    }

    /**
     * @notice used to update the protocol fee collector
     * @dev can only be updated by owner
     * @param _protocolFeeCollector address in which protocol fee is collected
     */
    function updateProtocolFeeCollector(address _protocolFeeCollector) external onlyOwner {
        _updateProtocolFeeCollector(_protocolFeeCollector);
    }

    function _updateProtocolFeeCollector(address _protocolFeeCollector) internal {
        require(_protocolFeeCollector != address(0), 'cant be 0 address');
        protocolFeeCollector = _protocolFeeCollector;
        emit ProtocolFeeCollectorUpdated(_protocolFeeCollector);
    }

    /**
     * @notice used to update the strategy registry address
     * @dev can only be updated by owner
     * @param _strategyRegistry address of the updated strategy registry
     */
    function updateStrategyRegistry(address _strategyRegistry) external onlyOwner {
        _updateStrategyRegistry(_strategyRegistry);
    }

    function _updateStrategyRegistry(address _strategyRegistry) internal {
        require(_strategyRegistry != address(0), 'CL::I zero address');
        strategyRegistry = _strategyRegistry;
        emit StrategyRegistryUpdated(_strategyRegistry);
    }

    /**
     * @notice used to update the liquidatorRewardFraction
     * @dev can only be updated by owner
     * @param _rewardFraction fraction of liquidated amount given to liquidator as reward
     */
    function updateLiquidatorRewardFraction(uint256 _rewardFraction) external onlyOwner {
        _updateLiquidatorRewardFraction(_rewardFraction);
    }

    function _updateLiquidatorRewardFraction(uint256 _rewardFraction) internal {
        require(_rewardFraction <= 10**30, 'Fraction has to be less than 1');
        liquidatorRewardFraction = _rewardFraction;
        emit LiquidationRewardFractionUpdated(_rewardFraction);
    }

    /**
     * @dev Used to Calculate Interest Per second on given principal and Interest rate
     * @param _principal principal Amount for which interest has to be calculated.
     * @param _borrowRate It is the Interest Rate at which Credit Line is approved
     * @return interest per second for the given parameters
     */
    function calculateInterest(
        uint256 _principal,
        uint256 _borrowRate,
        uint256 _timeElapsed
    ) public pure returns (uint256) {
        uint256 _interest = _principal.mul(_borrowRate).mul(_timeElapsed).div(10**30).div(YEAR_IN_SECONDS);

        return _interest;
    }

    /**
     * @dev Used to calculate interest accrued since last repayment
     * @param _id identifier for the credit line
     * @return interest accrued over current borrowed amount since last repayment
     */

    function calculateInterestAccrued(uint256 _id) public view returns (uint256) {
        uint256 _lastPrincipalUpdateTime = creditLineVariables[_id].lastPrincipalUpdateTime;
        if (_lastPrincipalUpdateTime == 0) return 0;
        uint256 _timeElapsed = (block.timestamp).sub(_lastPrincipalUpdateTime);
        uint256 _interestAccrued = calculateInterest(creditLineVariables[_id].principal, creditLineConstants[_id].borrowRate, _timeElapsed);
        return _interestAccrued;
    }

    /**
     * @dev Used to calculate current debt of borrower against a credit line.
     * @param _id identifier for the credit line
     * @return current debt of borrower
     */
    function calculateCurrentDebt(uint256 _id) public view returns (uint256) {
        uint256 _interestAccrued = calculateInterestAccrued(_id);
        uint256 _currentDebt = (creditLineVariables[_id].principal)
            .add(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate)
            .add(_interestAccrued)
            .sub(creditLineVariables[_id].totalInterestRepaid);
        return _currentDebt;
    }

    /**
     * @notice used to calculate amount that can be borrowed by the borrower
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view.
            borrowableAmount changes per block as interest changes per block.
     * @param _id identifier for the credit line
     * @return amount that can be borrowed from the credit line
     */
    function calculateBorrowableAmount(uint256 _id) public returns (uint256) {
        CreditLineStatus _status = creditLineVariables[_id].status;
        require(
            _status == CreditLineStatus.ACTIVE || _status == CreditLineStatus.REQUESTED,
            'CreditLine: Cannot only if credit line ACTIVE or REQUESTED'
        );
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(
            creditLineConstants[_id].collateralAsset,
            creditLineConstants[_id].borrowAsset
        );

        uint256 _totalCollateralToken = calculateTotalCollateralTokens(_id);

        uint256 _currentDebt = calculateCurrentDebt(_id);

        uint256 _maxPossible = _totalCollateralToken.mul(_ratioOfPrices).div(creditLineConstants[_id].idealCollateralRatio).mul(10**30).div(
            10**_decimals
        );

        uint256 _borrowLimit = creditLineConstants[_id].borrowLimit;

        if (_maxPossible > _borrowLimit) {
            _maxPossible = _borrowLimit;
        }
        if (_maxPossible > _currentDebt) {
            return _maxPossible.sub(_currentDebt);
        }
        return 0;
    }

    function updateinterestAccruedTillLastPrincipalUpdate(uint256 _id) internal {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');

        uint256 _interestAccrued = calculateInterestAccrued(_id);
        uint256 _newInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(_interestAccrued);
        creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _newInterestAccrued;
    }

    function _depositCollateralFromSavingsAccount(
        uint256 _id,
        uint256 _amount,
        address _sender
    ) internal {
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        uint256 _activeAmount;

        for (uint256 _index = 0; _index < _strategyList.length; _index++) {
            address _strategy = _strategyList[_index];
            uint256 _liquidityShares = _savingsAccount.balanceInShares(_sender, _collateralAsset, _strategy);
            if (_liquidityShares == 0 || _strategyList[_index] == address(0)) {
                continue;
            }
            uint256 _tokenInStrategy = _liquidityShares;
            _tokenInStrategy = IYield(_strategy).getTokensForShares(_liquidityShares, _collateralAsset);

            uint256 _tokensToTransfer = _tokenInStrategy;
            if (_activeAmount.add(_tokenInStrategy) >= _amount) {
                _tokensToTransfer = (_amount.sub(_activeAmount));
            }
            _activeAmount = _activeAmount.add(_tokensToTransfer);
            _savingsAccount.transferFrom(_tokensToTransfer, _collateralAsset, _strategy, _sender, address(this));

            collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(
                _liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy)
            );

            if (_amount == _activeAmount) {
                return;
            }
        }
        revert('CreditLine::_depositCollateralFromSavingsAccount - Insufficient balance');
    }

    /**
     * @notice used to request a credit line either by borrower or lender
     * @param _requestTo Address to which creditLine is requested, 
                        if borrower creates request then lender address and 
                        if lender creates then borrower address
     * @param _borrowLimit maximum borrow amount in a credit line
     * @param _borrowRate Interest Rate at which credit Line is requested
     * @param _autoLiquidation if true, anyone can liquidate loan, otherwise only lender
     * @param _collateralRatio ratio of the collateral to the debt below which credit line can be liquidated
     * @param _borrowAsset address of the token to be borrowed
     * @param _collateralAsset address of the token provided as collateral
     * @param _requestAsLender if true, lender is placing request, otherwise borrower
     * @return identifier for the credit line
     */

    function request(
        address _requestTo,
        uint256 _borrowLimit,
        uint256 _borrowRate,
        bool _autoLiquidation,
        uint256 _collateralRatio,
        address _borrowAsset,
        address _collateralAsset,
        bool _requestAsLender
    ) external returns (uint256) {
        require(_borrowAsset != _collateralAsset, 'R: cant borrow lent token');
        require(IPriceOracle(priceOracle).doesFeedExist(_borrowAsset, _collateralAsset), 'R: No price feed');

        address _lender = _requestTo;
        address _borrower = msg.sender;
        if (_requestAsLender) {
            _lender = msg.sender;
            _borrower = _requestTo;
        }

        uint256 _id = _createRequest(
            _lender,
            _borrower,
            _borrowLimit,
            _borrowRate,
            _autoLiquidation,
            _collateralRatio,
            _borrowAsset,
            _collateralAsset,
            _requestAsLender
        );

        emit CreditLineRequested(_id, _lender, _borrower);
        return _id;
    }

    function _createRequest(
        address _lender,
        address _borrower,
        uint256 _borrowLimit,
        uint256 _borrowRate,
        bool _autoLiquidation,
        uint256 _collateralRatio,
        address _borrowAsset,
        address _collateralAsset,
        bool _requestByLender
    ) internal returns (uint256) {
        require(_lender != _borrower, 'Lender and Borrower cannot be same addresses');
        uint256 _id = creditLineCounter + 1;
        creditLineCounter = _id;
        creditLineVariables[_id].status = CreditLineStatus.REQUESTED;
        creditLineConstants[_id].borrower = _borrower;
        creditLineConstants[_id].lender = _lender;
        creditLineConstants[_id].borrowLimit = _borrowLimit;
        creditLineConstants[_id].autoLiquidation = _autoLiquidation;
        creditLineConstants[_id].idealCollateralRatio = _collateralRatio;
        creditLineConstants[_id].borrowRate = _borrowRate;
        creditLineConstants[_id].borrowAsset = _borrowAsset;
        creditLineConstants[_id].collateralAsset = _collateralAsset;
        creditLineConstants[_id].requestByLender = _requestByLender;
        return _id;
    }

    /**
     * @notice used to accept a credit line
     * @dev if borrower places request, lender can accept and vice versa
     * @param _id identifier for the credit line
     */
    function accept(uint256 _id) external {
        require(
            creditLineVariables[_id].status == CreditLineStatus.REQUESTED,
            'CreditLine::acceptCreditLineLender - CreditLine is already accepted'
        );
        bool _requestByLender = creditLineConstants[_id].requestByLender;
        require(
            (msg.sender == creditLineConstants[_id].borrower && _requestByLender) ||
                (msg.sender == creditLineConstants[_id].lender && !_requestByLender),
            "Only Borrower or Lender who hasn't requested can accept"
        );
        creditLineVariables[_id].status = CreditLineStatus.ACTIVE;
        emit CreditLineAccepted(_id);
    }

    /**
     * @notice used to deposit collateral into the credit line
     * @dev collateral tokens have to be approved in savingsAccount or token contract(unless ether).
            If transferred from savings account, the tokens are transferred from strategies in the 
            order prespecified in strategy registry
     * @param _id identifier for the credit line
     * @param _amount amount of collateral being deposited
     * @param _strategy strategy to which collateral is to be deposited in case transfer is not from savings account
     * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount 
                                otherwise direct from collateral token contract
     */
    function depositCollateral(
        uint256 _id,
        uint256 _amount,
        address _strategy,
        bool _fromSavingsAccount
    ) external payable nonReentrant ifCreditLineExists(_id) {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine not active');
        _depositCollateral(_id, _amount, _strategy, _fromSavingsAccount);
        emit CollateralDeposited(_id, _amount, _strategy);
    }

    function _depositCollateral(
        uint256 _id,
        uint256 _amount,
        address _strategy,
        bool _fromSavingsAccount
    ) internal {
        require(creditLineConstants[_id].lender != msg.sender, 'lender cant deposit collateral');
        if (_fromSavingsAccount) {
            _depositCollateralFromSavingsAccount(_id, _amount, msg.sender);
        } else {
            address _collateralAsset = creditLineConstants[_id].collateralAsset;
            ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
            if (_collateralAsset == address(0)) {
                require(msg.value == _amount, "CreditLine::_depositCollateral - value to transfer doesn't match argument");
            } else {
                IERC20(_collateralAsset).safeTransferFrom(msg.sender, address(this), _amount);
                IERC20(_collateralAsset).approve(_strategy, _amount);
            }
            uint256 _sharesReceived = _savingsAccount.deposit{value: msg.value}(_amount, _collateralAsset, _strategy, address(this));
            collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(_sharesReceived);
        }
    }

    function _withdrawBorrowAmount(
        address _asset,
        uint256 _amountInTokens,
        address _lender
    ) internal {
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        uint256 _activeAmount;
        for (uint256 _index = 0; _index < _strategyList.length; _index++) {
            if (_strategyList[_index] == address(0)) {
                continue;
            }
            uint256 _liquidityShares = _savingsAccount.balanceInShares(_lender, _asset, _strategyList[_index]);
            if (_liquidityShares != 0) {
                uint256 tokenInStrategy = _liquidityShares;
                tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);
                uint256 _tokensToTransfer = tokenInStrategy;
                if (_activeAmount.add(tokenInStrategy) >= _amountInTokens) {
                    _tokensToTransfer = (_amountInTokens.sub(_activeAmount));
                }
                _activeAmount = _activeAmount.add(_tokensToTransfer);
                _savingsAccount.withdrawFrom(_tokensToTransfer, _asset, _strategyList[_index], _lender, address(this), false);
                if (_activeAmount == _amountInTokens) {
                    return;
                }
            }
        }
        require(_activeAmount == _amountInTokens, 'insufficient balance');
    }

    /**
     * @notice used to borrow tokens from credit line by borrower
     * @dev only borrower can call this function. Amount that can actually be borrowed is 
            min(amount based on borrowLimit, allowance to creditLine contract, balance of lender)
     * @param _id identifier for the credit line
     * @param _amount amount of tokens to borrow
     */
    function borrow(uint256 _id, uint256 _amount) external payable nonReentrant onlyCreditLineBorrower(_id) {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');
        uint256 _borrowableAmount = calculateBorrowableAmount(_id);
        require(_amount <= _borrowableAmount, "CreditLine::borrow - The current collateral ratio doesn't allow to withdraw the amount");
        address _borrowAsset = creditLineConstants[_id].borrowAsset;
        address _lender = creditLineConstants[_id].lender;

        updateinterestAccruedTillLastPrincipalUpdate(_id);
        creditLineVariables[_id].principal = creditLineVariables[_id].principal.add(_amount);
        creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;

        uint256 _tokenDiffBalance;
        if (_borrowAsset != address(0)) {
            uint256 _balanceBefore = IERC20(_borrowAsset).balanceOf(address(this));
            _withdrawBorrowAmount(_borrowAsset, _amount, _lender);
            uint256 _balanceAfter = IERC20(_borrowAsset).balanceOf(address(this));
            _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);
        } else {
            uint256 _balanceBefore = address(this).balance;
            _withdrawBorrowAmount(_borrowAsset, _amount, _lender);
            uint256 _balanceAfter = address(this).balance;
            _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);
        }
        uint256 _protocolFee = _tokenDiffBalance.mul(protocolFeeFraction).div(10**30);
        _tokenDiffBalance = _tokenDiffBalance.sub(_protocolFee);

        if (_borrowAsset == address(0)) {
            (bool feeSuccess, ) = protocolFeeCollector.call{value: _protocolFee}('');
            require(feeSuccess, 'Transfer fail');
            (bool success, ) = msg.sender.call{value: _tokenDiffBalance}('');
            require(success, 'Transfer fail');
        } else {
            IERC20(_borrowAsset).safeTransfer(protocolFeeCollector, _protocolFee);
            IERC20(_borrowAsset).safeTransfer(msg.sender, _tokenDiffBalance);
        }
        emit BorrowedFromCreditLine(_id, _tokenDiffBalance);
    }

    function _repayFromSavingsAccount(
        uint256 _amount,
        address _asset,
        address _lender
    ) internal {
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        uint256 _activeAmount;

        for (uint256 _index = 0; _index < _strategyList.length; _index++) {
            if (_strategyList[_index] == address(0)) {
                continue;
            }
            uint256 _liquidityShares = _savingsAccount.balanceInShares(msg.sender, _asset, _strategyList[_index]);
            if (_liquidityShares == 0) {
                continue;
            }
            uint256 _tokenInStrategy = _liquidityShares;
            _tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);

            uint256 _tokensToTransfer = _tokenInStrategy;
            if (_activeAmount.add(_tokenInStrategy) >= _amount) {
                _tokensToTransfer = (_amount.sub(_activeAmount));
            }
            _activeAmount = _activeAmount.add(_tokensToTransfer);
            _savingsAccount.transferFrom(_tokensToTransfer, _asset, _strategyList[_index], msg.sender, _lender);

            if (_amount == _activeAmount) {
                return;
            }
        }
        revert('CreditLine::_repayFromSavingsAccount - Insufficient balance');
    }

    function _repay(
        uint256 _id,
        uint256 _amount,
        bool _fromSavingsAccount,
        uint256 _principalPaid
    ) internal {
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        address _defaultStrategy = defaultStrategy;
        address _borrowAsset = creditLineConstants[_id].borrowAsset;
        address _lender = creditLineConstants[_id].lender;
        if (!_fromSavingsAccount) {
            if (_borrowAsset == address(0)) {
                require(msg.value == _amount, 'creditLine::repay - Ether sent not equal to repay amount');
                _savingsAccount.deposit{value: _amount}(_amount, _borrowAsset, _defaultStrategy, _lender);
            } else {
                IERC20(_borrowAsset).safeTransferFrom(msg.sender, address(this), _amount);
                IERC20(_borrowAsset).approve(_defaultStrategy, _amount);
                _savingsAccount.deposit(_amount, _borrowAsset, _defaultStrategy, _lender);
            }
        } else {
            _repayFromSavingsAccount(_amount, _borrowAsset, _lender);
        }
        if (_principalPaid != 0) {
            _savingsAccount.increaseAllowanceToCreditLine(_principalPaid, _borrowAsset, _lender);
        }
    }

    /**
     * @notice used to repay interest and principal to credit line. Interest has to be repaid before repaying principal
     * @dev partial repayments possible
     * @param _id identifier for the credit line
     * @param _amount amount being repaid
     * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount 
                                otherwise direct from collateral token contract
     */
    function repay(
        uint256 _id,
        uint256 _amount,
        bool _fromSavingsAccount
    ) external payable nonReentrant {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');
        require(creditLineConstants[_id].lender != msg.sender, 'Lender cant repay');

        uint256 _interestSincePrincipalUpdate = calculateInterestAccrued(_id);
        uint256 _totalInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(
            _interestSincePrincipalUpdate
        );
        uint256 _interestToPay = _totalInterestAccrued.sub(creditLineVariables[_id].totalInterestRepaid);
        uint256 _totalCurrentDebt = _interestToPay.add(creditLineVariables[_id].principal);
        uint256 _principalPaid = 0;

        if (_amount >= _totalCurrentDebt) {
            _amount = _totalCurrentDebt;
            emit CompleteCreditLineRepaid(_id, _amount);
        } else {
            emit PartialCreditLineRepaid(_id, _amount);
        }

        if (_amount > _interestToPay) {
            creditLineVariables[_id].principal = _totalCurrentDebt.sub(_amount);
            creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _totalInterestAccrued;
            creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;
            creditLineVariables[_id].totalInterestRepaid = _totalInterestAccrued;
            _principalPaid = _amount.sub(_interestToPay);
        } else {
            creditLineVariables[_id].totalInterestRepaid = creditLineVariables[_id].totalInterestRepaid.add(_amount);
        }

        _repay(_id, _amount, _fromSavingsAccount, _principalPaid);

        if (creditLineVariables[_id].principal == 0) {
            _resetCreditLine(_id);
        }
    }

    function _resetCreditLine(uint256 _id) internal {
        creditLineVariables[_id].lastPrincipalUpdateTime = 0;
        creditLineVariables[_id].totalInterestRepaid = 0;
        creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = 0;
        emit CreditLineReset(_id);
    }

    /**
     * @dev used to close credit line by borrower or lender
     * @param _id identifier for the credit line
     */
    function close(uint256 _id) external ifCreditLineExists(_id) {
        require(
            msg.sender == creditLineConstants[_id].borrower || msg.sender == creditLineConstants[_id].lender,
            'CreditLine: Permission denied while closing Line of credit'
        );
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: Credit line should be active.');
        require(creditLineVariables[_id].principal == 0, 'CreditLine: Cannot be closed since not repaid.');
        require(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate == 0, 'CreditLine: Cannot be closed since not repaid.');
        creditLineVariables[_id].status = CreditLineStatus.CLOSED;
        emit CreditLineClosed(_id);
    }

    /**
     * @notice used to calculate the current collateral ratio
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view.
            Interest is also considered while calculating debt
     * @param _id identifier for the credit line
     * @return collateral ratio multiplied by 10**30 to retain precision
     */
    function calculateCurrentCollateralRatio(uint256 _id) public ifCreditLineExists(_id) returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(
            creditLineConstants[_id].collateralAsset,
            creditLineConstants[_id].borrowAsset
        );

        uint256 currentDebt = calculateCurrentDebt(_id);
        uint256 currentCollateralRatio = calculateTotalCollateralTokens(_id).mul(_ratioOfPrices).div(currentDebt).mul(10**30).div(
            10**_decimals
        );

        return currentCollateralRatio;
    }

    /**
     * @notice used to calculate the total collateral tokens
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @param _id identifier for the credit line
     * @return _amount total collateral tokens deposited into the credit line
     */
    function calculateTotalCollateralTokens(uint256 _id) public returns (uint256 _amount) {
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        uint256 _liquidityShares;
        for (uint256 index = 0; index < _strategyList.length; index++) {
            if (_strategyList[index] == address(0)) {
                continue;
            }
            _liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];
            uint256 _tokenInStrategy = _liquidityShares;
            _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(_liquidityShares, _collateralAsset);

            _amount = _amount.add(_tokenInStrategy);
        }
    }

    /**
     * @notice used to withdraw any excess collateral
     * @dev collateral can't be withdraw if collateralRatio goes below the ideal value. Only borrower can withdraw
     * @param _id identifier for the credit line
     * @param _amount amount of collateral to withdraw
     * @param _toSavingsAccount if true, tokens are transferred from savingsAccount 
                                otherwise direct from collateral token contract
     */
    function withdrawCollateral(
        uint256 _id,
        uint256 _amount,
        bool _toSavingsAccount
    ) external nonReentrant onlyCreditLineBorrower(_id) {
        uint256 _withdrawableCollateral = withdrawableCollateral(_id);
        require(_amount <= _withdrawableCollateral, 'Collateral ratio cant go below ideal');
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        _transferCollateral(_id, _collateralAsset, _amount, _toSavingsAccount);
        emit CollateralWithdrawn(_id, _amount);
    }

    /**
     * @notice used to calculate the collateral that can be withdrawn
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @param _id identifier for the credit line
     * @return total collateral withdrawable by borrower
     */
    function withdrawableCollateral(uint256 _id) public returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(
            creditLineConstants[_id].collateralAsset,
            creditLineConstants[_id].borrowAsset
        );

        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);
        uint256 _currentDebt = calculateCurrentDebt(_id);

        uint256 _collateralNeeded = _currentDebt
            .mul(creditLineConstants[_id].idealCollateralRatio)
            .div(_ratioOfPrices)
            .mul(10**_decimals)
            .div(10**30);

        if (_collateralNeeded >= _totalCollateralTokens) {
            return 0;
        }
        return _totalCollateralTokens.sub(_collateralNeeded);
    }

    function _transferCollateral(
        uint256 _id,
        address _asset,
        uint256 _amountInTokens,
        bool _toSavingsAccount
    ) internal {
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        uint256 _activeAmount;
        for (uint256 index = 0; index < _strategyList.length; index++) {
            uint256 liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];
            if (liquidityShares == 0 || _strategyList[index] == address(0)) {
                continue;
            }
            uint256 _tokenInStrategy = liquidityShares;
            _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(liquidityShares, _asset);
            uint256 _tokensToTransfer = _tokenInStrategy;
            if (_activeAmount.add(_tokenInStrategy) > _amountInTokens) {
                _tokensToTransfer = _amountInTokens.sub(_activeAmount);
                liquidityShares = liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy);
            }
            _activeAmount = _activeAmount.add(_tokensToTransfer);
            collateralShareInStrategy[_id][_strategyList[index]] = collateralShareInStrategy[_id][_strategyList[index]].sub(
                liquidityShares
            );
            if (_toSavingsAccount) {
                ISavingsAccount(savingsAccount).transfer(_tokensToTransfer, _asset, _strategyList[index], msg.sender);
            } else {
                ISavingsAccount(savingsAccount).withdraw(_tokensToTransfer, _asset, _strategyList[index], msg.sender, false);
            }

            if (_activeAmount == _amountInTokens) {
                return;
            }
        }
        revert('insufficient collateral');
    }

    /**
     * @notice used to liquidate credit line in case collateral ratio goes below the threshold
     * @dev if lender liquidates, then collateral is directly transferred. 
            If autoLiquidation is true, anyone can liquidate by providing enough borrow tokens
     * @param _id identifier for the credit line
     * @param _toSavingsAccount if true, tokens are transferred from savingsAccount 
                                otherwise direct from collateral token contract
     */
    function liquidate(uint256 _id, bool _toSavingsAccount) external payable nonReentrant {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: Credit line should be active.');
        require(creditLineVariables[_id].principal != 0, 'CreditLine: cannot liquidate if principal is 0');

        uint256 currentCollateralRatio = calculateCurrentCollateralRatio(_id);
        require(
            currentCollateralRatio < creditLineConstants[_id].idealCollateralRatio,
            'CreditLine: Collateral ratio is higher than ideal value'
        );

        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        address _lender = creditLineConstants[_id].lender;
        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);
        address _borrowAsset = creditLineConstants[_id].borrowAsset;

        creditLineVariables[_id].status = CreditLineStatus.LIQUIDATED;

        if (creditLineConstants[_id].autoLiquidation && _lender != msg.sender) {
            uint256 _borrowTokens = _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens);
            if (_borrowAsset == address(0)) {
                uint256 _returnETH = msg.value.sub(_borrowTokens, 'Insufficient ETH to liquidate');
                if (_returnETH != 0) {
                    (bool success, ) = msg.sender.call{value: _returnETH}('');
                    require(success, 'Transfer fail');
                }
            } else {
                IERC20(_borrowAsset).safeTransferFrom(msg.sender, _lender, _borrowTokens);
            }
        }

        _transferCollateral(_id, _collateralAsset, _totalCollateralTokens, _toSavingsAccount);

        emit CreditLineLiquidated(_id, msg.sender);
    }

    /**
     * @notice used to calculate the borrow tokens necessary for liquidator to liquidate
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @param _id identifier for the credit line
     * @return borrow tokens necessary for liquidator to liquidate
     */
    function borrowTokensToLiquidate(uint256 _id) external returns (uint256) {
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);
        address _borrowAsset = creditLineConstants[_id].borrowAsset;

        return _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens);
    }

    function _borrowTokensToLiquidate(
        address _borrowAsset,
        address _collateralAsset,
        uint256 _totalCollateralTokens
    ) internal view returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(_borrowAsset, _collateralAsset);
        uint256 _borrowTokens = (
            _totalCollateralTokens.mul(uint256(10**30).sub(liquidatorRewardFraction)).div(10**30).mul(_ratioOfPrices).div(10**_decimals)
        );

        return _borrowTokens;
    }

    receive() external payable {
        require(msg.sender == savingsAccount, 'CreditLine::receive invalid transaction');
    }
}
.]

Based on the provided smart contract code for the Credit Line contract, here is a summary of the potential security vulnerabilities identified:

### Summary of Security Vulnerabilities:

1. **Reentrancy Vulnerability**:
   - The contract uses external calls to transfer tokens and Ether, which can lead to reentrancy attacks if not properly guarded. Although the contract employs `ReentrancyGuard`, it is crucial to ensure that all external calls are made after state changes to prevent reentrancy.

2. **Arithmetic Overflow/Underflow**:
   - While the contract uses `SafeMath`, which protects against overflow and underflow, it is essential to ensure that all arithmetic operations are consistently using `SafeMath` to avoid any potential vulnerabilities.

3. **Access Control Issues**:
   - The contract relies on the `onlyOwner` modifier for critical functions. If the owner’s private key is compromised, an attacker could manipulate the contract. Implementing a multi-signature wallet or a time-lock mechanism could enhance security.

4. **Price Oracle Dependency**:
   - The contract depends on an external price oracle for collateral valuation. If the oracle is compromised or provides incorrect data, it could lead to significant financial losses. Implementing a fallback mechanism or using multiple oracles for price feeds could mitigate this risk.

5. **Insufficient Input Validation**:
   - Some functions do not adequately validate inputs, such as checking for zero addresses or ensuring that amounts are positive. This could lead to unexpected behavior or vulnerabilities.

6. **Lack of Emergency Stop Mechanism**:
   - The contract does not have a circuit breaker or emergency stop mechanism to pause operations in case of a detected vulnerability or attack. Implementing a pause function could help mitigate risks during emergencies.

7. **Token Transfer Failures**:
   - The contract does not handle potential failures in token transfers adequately. If a transfer fails, it could lead to inconsistent states. Implementing checks after token transfers and reverting on failure is essential.

8. **Gas Limit Issues**:
   - Functions that iterate over arrays or mappings (e.g., `_depositCollateralFromSavingsAccount`, `_withdrawBorrowAmount`) may run into gas limit issues if the number of strategies or collateral assets grows significantly. This could lead to denial of service.

9. **Potential for Front-Running**:
   - The contract does not implement measures to prevent front-running attacks, where an attacker could observe a transaction and submit their own transaction with higher gas fees to exploit the situation.

### Comprehensive Analysis Report:

The Credit Line contract is a complex financial instrument that facilitates borrowing and lending through collateralized loans. While it employs several best practices, such as using OpenZeppelin's libraries for security and implementing a structured approach to credit lines, there are notable vulnerabilities that need addressing.

1. **Reentrancy Protection**: Although the contract uses `ReentrancyGuard`, it is critical to ensure that all state changes occur before any external calls to prevent reentrancy attacks effectively.

2. **Access Control**: The reliance on a single owner for critical functions poses a risk. Implementing a multi-signature approach or a governance mechanism could enhance security.

3. **External Dependencies**: The contract's reliance on external price oracles introduces risks. A robust mechanism to validate oracle data or fallback options should be considered.

4. **Input Validation**: Strengthening input validation across functions will help prevent unexpected behaviors and potential exploits.

5. **Emergency Mechanisms**: The absence of an emergency stop function is concerning. Implementing a pause mechanism would allow the contract to halt operations in case of detected vulnerabilities.

6. **Token Transfer Handling**: Ensuring that all token transfers are checked for success and reverting on failure is essential to maintain contract integrity.

7. **Gas Limit Considerations**: Functions that iterate over potentially large datasets should be optimized to prevent gas limit issues, which could lead to denial of service.

8. **Front-Running Mitigation**: Implementing measures to prevent front-running attacks will help secure the contract against potential exploits.

In conclusion, while the Credit Line contract demonstrates a solid foundation for a decentralized lending platform, addressing the identified vulnerabilities is crucial for ensuring the security and reliability of the contract. A thorough audit and testing phase, along with the implementation of suggested improvements, will significantly enhance the contract's resilience against potential attacks.

[2024-22-08 11:43:25 INFO] **[Seminar Conclusion]**:

 Based on the provided smart contract code for the Credit Line contract, here is a summary of the potential security vulnerabilities identified:

### Summary of Security Vulnerabilities:

1. **Reentrancy Vulnerability**:
   - The contract uses external calls to transfer tokens and Ether, which can lead to reentrancy attacks if not properly guarded. Although the contract employs `ReentrancyGuard`, it is crucial to ensure that all external calls are made after state changes to prevent reentrancy.

2. **Arithmetic Overflow/Underflow**:
   - While the contract uses `SafeMath`, which protects against overflow and underflow, it is essential to ensure that all arithmetic operations are consistently using `SafeMath` to avoid any potential vulnerabilities.

3. **Access Control Issues**:
   - The contract relies on the `onlyOwner` modifier for critical functions. If the owner’s private key is compromised, an attacker could manipulate the contract. Implementing a multi-signature wallet or a time-lock mechanism could enhance security.

4. **Price Oracle Dependency**:
   - The contract depends on an external price oracle for collateral valuation. If the oracle is compromised or provides incorrect data, it could lead to significant financial losses. Implementing a fallback mechanism or using multiple oracles for price feeds could mitigate this risk.

5. **Insufficient Input Validation**:
   - Some functions do not adequately validate inputs, such as checking for zero addresses or ensuring that amounts are positive. This could lead to unexpected behavior or vulnerabilities.

6. **Lack of Emergency Stop Mechanism**:
   - The contract does not have a circuit breaker or emergency stop mechanism to pause operations in case of a detected vulnerability or attack. Implementing a pause function could help mitigate risks during emergencies.

7. **Token Transfer Failures**:
   - The contract does not handle potential failures in token transfers adequately. If a transfer fails, it could lead to inconsistent states. Implementing checks after token transfers and reverting on failure is essential.

8. **Gas Limit Issues**:
   - Functions that iterate over arrays or mappings (e.g., `_depositCollateralFromSavingsAccount`, `_withdrawBorrowAmount`) may run into gas limit issues if the number of strategies or collateral assets grows significantly. This could lead to denial of service.

9. **Potential for Front-Running**:
   - The contract does not implement measures to prevent front-running attacks, where an attacker could observe a transaction and submit their own transaction with higher gas fees to exploit the situation.

### Comprehensive Analysis Report:

The Credit Line contract is a complex financial instrument that facilitates borrowing and lending through collateralized loans. While it employs several best practices, such as using OpenZeppelin's libraries for security and implementing a structured approach to credit lines, there are notable vulnerabilities that need addressing.

1. **Reentrancy Protection**: Although the contract uses `ReentrancyGuard`, it is critical to ensure that all state changes occur before any external calls to prevent reentrancy attacks effectively.

2. **Access Control**: The reliance on a single owner for critical functions poses a risk. Implementing a multi-signature approach or a governance mechanism could enhance security.

3. **External Dependencies**: The contract's reliance on external price oracles introduces risks. A robust mechanism to validate oracle data or fallback options should be considered.

4. **Input Validation**: Strengthening input validation across functions will help prevent unexpected behaviors and potential exploits.

5. **Emergency Mechanisms**: The absence of an emergency stop function is concerning. Implementing a pause mechanism would allow the contract to halt operations in case of detected vulnerabilities.

6. **Token Transfer Handling**: Ensuring that all token transfers are checked for success and reverting on failure is essential to maintain contract integrity.

7. **Gas Limit Considerations**: Functions that iterate over potentially large datasets should be optimized to prevent gas limit issues, which could lead to denial of service.

8. **Front-Running Mitigation**: Implementing measures to prevent front-running attacks will help secure the contract against potential exploits.

In conclusion, while the Credit Line contract demonstrates a solid foundation for a decentralized lending platform, addressing the identified vulnerabilities is crucial for ensuring the security and reliability of the contract. A thorough audit and testing phase, along with the implementation of suggested improvements, will significantly enhance the contract's resilience against potential attacks.

[2024-22-08 11:43:25 INFO] **[Execute Detail]**

execute SimplePhase:[ContractReviewComment] in ComposedPhase:[CodeReview], cycle 2

[2024-22-08 11:43:25 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol'; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/utils/ReentrancyGuard.sol'; import '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol'; import '../interfaces/IPriceOracle.sol'; import '../interfaces/IYield.sol'; import '../interfaces/ISavingsAccount.sol'; import '../SavingsAccount/SavingsAccountUtil.sol'; import '../interfaces/IStrategyRegistry.sol'; /  * @title Credit Line contract with Methods related to credit Line  * @notice Implements the functions related to Credit Line  * @author Sublime  / contract CreditLine is ReentrancyGuard, OwnableUpgradeable {     using SafeERC20 for IERC20;     using SafeMath for uint256; enum CreditLineStatus {     NOT_CREATED,     REQUESTED,     ACTIVE,     CLOSED,     CANCELLED,     LIQUIDATED }  /**  * @notice counter that tracks the number of credit lines created  * @dev used to create unique identifier for credit lines  **/ uint256 public creditLineCounter;  uint256 constant YEAR_IN_SECONDS = 365 days;  struct CreditLineVariables {     CreditLineStatus status;     uint256 principal;     uint256 totalInterestRepaid;     uint256 lastPrincipalUpdateTime;     uint256 interestAccruedTillLastPrincipalUpdate; }  struct CreditLineConstants {     address lender;     address borrower;     uint256 borrowLimit;     uint256 idealCollateralRatio;     uint256 borrowRate;     address borrowAsset;     address collateralAsset;     bool autoLiquidation;     bool requestByLender; } /**  * @notice stores the collateral shares in a credit line per strategy  * @dev creditLineId =&gt; Strategy =&gt; collateralShares  **/ mapping(uint256 =&gt; mapping(address =&gt; uint256)) public collateralShareInStrategy;  /**  * @notice stores the variables to maintain a credit line  **/ mapping(uint256 =&gt; CreditLineVariables) public creditLineVariables;  /**  * @notice stores the constants related to a credit line  **/ mapping(uint256 =&gt; CreditLineConstants) public creditLineConstants;  /**  * @notice stores the address of savings account contract  **/ address public savingsAccount;  /**  * @notice stores the address of price oracle contract  **/ address public priceOracle;  /**  * @notice stores the address of strategy registry contract  **/ address public strategyRegistry;  /**  * @notice stores the address of default strategy  **/ address public defaultStrategy;  /**  * @notice stores the fraction of borrowed amount charged as fee by protocol  * @dev it is multiplied by 10**30  **/ uint256 public protocolFeeFraction;  /**  * @notice address where protocol fee is collected  **/ address public protocolFeeCollector;  /**  * @notice stores the fraction of amount liquidated given as reward to liquidator  * @dev it is multiplied by 10**30  **/ uint256 public liquidatorRewardFraction; /**  * @dev checks if Credit Line exists  * @param _id identifier for the credit line  **/ modifier ifCreditLineExists(uint256 _id) {     require(creditLineVariables[_id].status != CreditLineStatus.NOT_CREATED, 'Credit line does not exist');     _; }  /**  * @dev checks if called by credit Line Borrower  * @param _id creditLine identifier  **/ modifier onlyCreditLineBorrower(uint256 _id) {     require(creditLineConstants[_id].borrower == msg.sender, 'Only credit line Borrower can access');     _; }  /**  * @dev checks if called by credit Line Lender  * @param _id creditLine identifier  **/ modifier onlyCreditLineLender(uint256 _id) {     require(creditLineConstants[_id].lender == msg.sender, 'Only credit line Lender can access');     _; }  /**  * @notice emitted when a collateral is deposited into credit line  * @param id id of the credit line  * @param amount amount of collateral deposited  * @param strategy address of the strategy into which collateral is deposited  */ event CollateralDeposited(uint256 indexed id, uint256 amount, address indexed strategy);  /**  * @notice emitted when collateral is withdrawn from credit line  * @param id id of the credit line  * @param amount amount of collateral withdrawn  */ event CollateralWithdrawn(uint256 indexed id, uint256 amount);  /**  * @notice emitted when a request for new credit line is placed  * @param id id of the credit line for which request was made  * @param lender address of the lender for credit line  * @param borrower address of the borrower for credit line  */ event CreditLineRequested(uint256 indexed id, address indexed lender, address indexed borrower);  /**  * @notice emitted when a credit line is liquidated  * @param id id of the credit line which is liquidated  * @param liquidator address of the liquidator  */ event CreditLineLiquidated(uint256 indexed id, address indexed liquidator);  /**  * @notice emitted when tokens are borrowed from credit line  * @param id id of the credit line from which tokens are borrowed  * @param borrowAmount amount of tokens borrowed  */ event BorrowedFromCreditLine(uint256 indexed id, uint256 borrowAmount);  /**  * @notice emitted when credit line is accepted  * @param id id of the credit line that was accepted  */ event CreditLineAccepted(uint256 indexed id);  /**  * @notice emitted when credit line is completely repaid and reset  * @param id id of the credit line that is reset  */ event CreditLineReset(uint256 indexed id);  /**  * @notice emitted when the credit line is partially repaid  * @param id id of the credit line  * @param repayAmount amount repaid  */ event PartialCreditLineRepaid(uint256 indexed id, uint256 repayAmount);  /**  * @notice emitted when the credit line is completely repaid  * @param id id of the credit line  * @param repayAmount amount repaid  */ event CompleteCreditLineRepaid(uint256 indexed id, uint256 repayAmount);  /**  * @notice emitted when the credit line is closed by one of the parties of credit line  * @param id id of the credit line  */ event CreditLineClosed(uint256 indexed id);  /**  * @notice emitted when default strategy for the credit line is updated  * @param defaultStrategy address of the strategy contract that is used as default by credit lines  */ event DefaultStrategyUpdated(address indexed defaultStrategy);  /**  * @notice emitted when the price oracle is updated  * @param priceOracle address of the updated price oracle  */ event PriceOracleUpdated(address indexed priceOracle);  /**  * @notice emitted when the savings account address is updated  * @param savingsAccount address of the updated savingsAccount  */ event SavingsAccountUpdated(address indexed savingsAccount);  /**  * @notice emitted when strategy registry address is updated  * @param strategyRegistry address of the updated strategy registry  */ event StrategyRegistryUpdated(address indexed strategyRegistry);  /**  * @notice emitted when fee that protocol charges for credit line is updated  * @param updatedProtocolFee updated value of protocolFeeFraction  */ event ProtocolFeeFractionUpdated(uint256 updatedProtocolFee);  /**  * @notice emitted when address which receives fee that protocol changes for pools is updated  * @param updatedProtocolFeeCollector updated value of protocolFeeCollector  */ event ProtocolFeeCollectorUpdated(address indexed updatedProtocolFeeCollector);  /**  * @notice emitted when liquidatorRewardFraction is updated  * @param liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator  */ event LiquidationRewardFractionUpdated(uint256 liquidatorRewardFraction);  /**  * @notice used to initialize the contract  * @dev can only be called once during the life cycle of the contract  * @param _defaultStrategy default strategy used in credit lines  * @param _priceOracle address of the priceOracle  * @param _savingsAccount address of  the savings account contract  * @param _strategyRegistry address of the strategy registry contract  * @param _owner address of owner who can change global variables  * @param _protocolFeeFraction fraction of the fee charged by protocol  * @param _protocolFeeCollector address to which protocol fee is charged to  * @param _liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator  */ function initialize(     address _defaultStrategy,     address _priceOracle,     address _savingsAccount,     address _strategyRegistry,     address _owner,     uint256 _protocolFeeFraction,     address _protocolFeeCollector,     uint256 _liquidatorRewardFraction ) external initializer {     OwnableUpgradeable.__Ownable_init();     OwnableUpgradeable.transferOwnership(_owner);      _updateDefaultStrategy(_defaultStrategy);     _updatePriceOracle(_priceOracle);     _updateSavingsAccount(_savingsAccount);     _updateStrategyRegistry(_strategyRegistry);     _updateProtocolFeeFraction(_protocolFeeFraction);     _updateProtocolFeeCollector(_protocolFeeCollector);     _updateLiquidatorRewardFraction(_liquidatorRewardFraction); }  /**  * @notice used to update the default strategy  * @dev can only be updated by owner  * @param _defaultStrategy address of the updated default strategy  */ function updateDefaultStrategy(address _defaultStrategy) external onlyOwner {     _updateDefaultStrategy(_defaultStrategy); }  function _updateDefaultStrategy(address _defaultStrategy) internal {     defaultStrategy = _defaultStrategy;     emit DefaultStrategyUpdated(_defaultStrategy); }  /**  * @notice used to update the price oracle  * @dev can only be updated by owner  * @param _priceOracle address of the updated price oracle  */ function updatePriceOracle(address _priceOracle) external onlyOwner {     _updatePriceOracle(_priceOracle); }  function _updatePriceOracle(address _priceOracle) internal {     priceOracle = _priceOracle;     emit PriceOracleUpdated(_priceOracle); }  /**  * @notice used to update the savings account address  * @dev can only be updated by owner  * @param _savingsAccount address of the updated savings account  */ function updateSavingsAccount(address _savingsAccount) external onlyOwner {     _updateSavingsAccount(_savingsAccount); }  function _updateSavingsAccount(address _savingsAccount) internal {     savingsAccount = _savingsAccount;     emit SavingsAccountUpdated(_savingsAccount); }  /**  * @notice used to update the protocol fee fraction  * @dev can only be updated by owner  * @param _protocolFee fraction of the borrower amount collected as protocol fee  */ function updateProtocolFeeFraction(uint256 _protocolFee) external onlyOwner {     _updateProtocolFeeFraction(_protocolFee); }  function _updateProtocolFeeFraction(uint256 _protocolFee) internal {     protocolFeeFraction = _protocolFee;     emit ProtocolFeeFractionUpdated(_protocolFee); }  /**  * @notice used to update the protocol fee collector  * @dev can only be updated by owner  * @param _protocolFeeCollector address in which protocol fee is collected  */ function updateProtocolFeeCollector(address _protocolFeeCollector) external onlyOwner {     _updateProtocolFeeCollector(_protocolFeeCollector); }  function _updateProtocolFeeCollector(address _protocolFeeCollector) internal {     require(_protocolFeeCollector != address(0), 'cant be 0 address');     protocolFeeCollector = _protocolFeeCollector;     emit ProtocolFeeCollectorUpdated(_protocolFeeCollector); }  /**  * @notice used to update the strategy registry address  * @dev can only be updated by owner  * @param _strategyRegistry address of the updated strategy registry  */ function updateStrategyRegistry(address _strategyRegistry) external onlyOwner {     _updateStrategyRegistry(_strategyRegistry); }  function _updateStrategyRegistry(address _strategyRegistry) internal {     require(_strategyRegistry != address(0), 'CL::I zero address');     strategyRegistry = _strategyRegistry;     emit StrategyRegistryUpdated(_strategyRegistry); }  /**  * @notice used to update the liquidatorRewardFraction  * @dev can only be updated by owner  * @param _rewardFraction fraction of liquidated amount given to liquidator as reward  */ function updateLiquidatorRewardFraction(uint256 _rewardFraction) external onlyOwner {     _updateLiquidatorRewardFraction(_rewardFraction); }  function _updateLiquidatorRewardFraction(uint256 _rewardFraction) internal {     require(_rewardFraction &lt;= 10**30, 'Fraction has to be less than 1');     liquidatorRewardFraction = _rewardFraction;     emit LiquidationRewardFractionUpdated(_rewardFraction); }  /**  * @dev Used to Calculate Interest Per second on given principal and Interest rate  * @param _principal principal Amount for which interest has to be calculated.  * @param _borrowRate It is the Interest Rate at which Credit Line is approved  * @return interest per second for the given parameters  */ function calculateInterest(     uint256 _principal,     uint256 _borrowRate,     uint256 _timeElapsed ) public pure returns (uint256) {     uint256 _interest = _principal.mul(_borrowRate).mul(_timeElapsed).div(10**30).div(YEAR_IN_SECONDS);      return _interest; }  /**  * @dev Used to calculate interest accrued since last repayment  * @param _id identifier for the credit line  * @return interest accrued over current borrowed amount since last repayment  */  function calculateInterestAccrued(uint256 _id) public view returns (uint256) {     uint256 _lastPrincipalUpdateTime = creditLineVariables[_id].lastPrincipalUpdateTime;     if (_lastPrincipalUpdateTime == 0) return 0;     uint256 _timeElapsed = (block.timestamp).sub(_lastPrincipalUpdateTime);     uint256 _interestAccrued = calculateInterest(creditLineVariables[_id].principal, creditLineConstants[_id].borrowRate, _timeElapsed);     return _interestAccrued; }  /**  * @dev Used to calculate current debt of borrower against a credit line.  * @param _id identifier for the credit line  * @return current debt of borrower  */ function calculateCurrentDebt(uint256 _id) public view returns (uint256) {     uint256 _interestAccrued = calculateInterestAccrued(_id);     uint256 _currentDebt = (creditLineVariables[_id].principal)         .add(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate)         .add(_interestAccrued)         .sub(creditLineVariables[_id].totalInterestRepaid);     return _currentDebt; }  /**  * @notice used to calculate amount that can be borrowed by the borrower  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view.         borrowableAmount changes per block as interest changes per block.  * @param _id identifier for the credit line  * @return amount that can be borrowed from the credit line  */ function calculateBorrowableAmount(uint256 _id) public returns (uint256) {     CreditLineStatus _status = creditLineVariables[_id].status;     require(         _status == CreditLineStatus.ACTIVE || _status == CreditLineStatus.REQUESTED,         'CreditLine: Cannot only if credit line ACTIVE or REQUESTED'     );     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(         creditLineConstants[_id].collateralAsset,         creditLineConstants[_id].borrowAsset     );      uint256 _totalCollateralToken = calculateTotalCollateralTokens(_id);      uint256 _currentDebt = calculateCurrentDebt(_id);      uint256 _maxPossible = _totalCollateralToken.mul(_ratioOfPrices).div(creditLineConstants[_id].idealCollateralRatio).mul(10**30).div(         10**_decimals     );      uint256 _borrowLimit = creditLineConstants[_id].borrowLimit;      if (_maxPossible &gt; _borrowLimit) {         _maxPossible = _borrowLimit;     }     if (_maxPossible &gt; _currentDebt) {         return _maxPossible.sub(_currentDebt);     }     return 0; }  function updateinterestAccruedTillLastPrincipalUpdate(uint256 _id) internal {     require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');      uint256 _interestAccrued = calculateInterestAccrued(_id);     uint256 _newInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(_interestAccrued);     creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _newInterestAccrued; }  function _depositCollateralFromSavingsAccount(     uint256 _id,     uint256 _amount,     address _sender ) internal {     address _collateralAsset = creditLineConstants[_id].collateralAsset;     address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();     ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);     uint256 _activeAmount;      for (uint256 _index = 0; _index &lt; _strategyList.length; _index++) {         address _strategy = _strategyList[_index];         uint256 _liquidityShares = _savingsAccount.balanceInShares(_sender, _collateralAsset, _strategy);         if (_liquidityShares == 0 || _strategyList[_index] == address(0)) {             continue;         }         uint256 _tokenInStrategy = _liquidityShares;         _tokenInStrategy = IYield(_strategy).getTokensForShares(_liquidityShares, _collateralAsset);          uint256 _tokensToTransfer = _tokenInStrategy;         if (_activeAmount.add(_tokenInStrategy) &gt;= _amount) {             _tokensToTransfer = (_amount.sub(_activeAmount));         }         _activeAmount = _activeAmount.add(_tokensToTransfer);         _savingsAccount.transferFrom(_tokensToTransfer, _collateralAsset, _strategy, _sender, address(this));          collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(             _liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy)         );          if (_amount == _activeAmount) {             return;         }     }     revert('CreditLine::_depositCollateralFromSavingsAccount - Insufficient balance'); }  /**  * @notice used to request a credit line either by borrower or lender  * @param _requestTo Address to which creditLine is requested,                      if borrower creates request then lender address and                      if lender creates then borrower address  * @param _borrowLimit maximum borrow amount in a credit line  * @param _borrowRate Interest Rate at which credit Line is requested  * @param _autoLiquidation if true, anyone can liquidate loan, otherwise only lender  * @param _collateralRatio ratio of the collateral to the debt below which credit line can be liquidated  * @param _borrowAsset address of the token to be borrowed  * @param _collateralAsset address of the token provided as collateral  * @param _requestAsLender if true, lender is placing request, otherwise borrower  * @return identifier for the credit line  */  function request(     address _requestTo,     uint256 _borrowLimit,     uint256 _borrowRate,     bool _autoLiquidation,     uint256 _collateralRatio,     address _borrowAsset,     address _collateralAsset,     bool _requestAsLender ) external returns (uint256) {     require(_borrowAsset != _collateralAsset, 'R: cant borrow lent token');     require(IPriceOracle(priceOracle).doesFeedExist(_borrowAsset, _collateralAsset), 'R: No price feed');      address _lender = _requestTo;     address _borrower = msg.sender;     if (_requestAsLender) {         _lender = msg.sender;         _borrower = _requestTo;     }      uint256 _id = _createRequest(         _lender,         _borrower,         _borrowLimit,         _borrowRate,         _autoLiquidation,         _collateralRatio,         _borrowAsset,         _collateralAsset,         _requestAsLender     );      emit CreditLineRequested(_id, _lender, _borrower);     return _id; }  function _createRequest(     address _lender,     address _borrower,     uint256 _borrowLimit,     uint256 _borrowRate,     bool _autoLiquidation,     uint256 _collateralRatio,     address _borrowAsset,     address _collateralAsset,     bool _requestByLender ) internal returns (uint256) {     require(_lender != _borrower, 'Lender and Borrower cannot be same addresses');     uint256 _id = creditLineCounter + 1;     creditLineCounter = _id;     creditLineVariables[_id].status = CreditLineStatus.REQUESTED;     creditLineConstants[_id].borrower = _borrower;     creditLineConstants[_id].lender = _lender;     creditLineConstants[_id].borrowLimit = _borrowLimit;     creditLineConstants[_id].autoLiquidation = _autoLiquidation;     creditLineConstants[_id].idealCollateralRatio = _collateralRatio;     creditLineConstants[_id].borrowRate = _borrowRate;     creditLineConstants[_id].borrowAsset = _borrowAsset;     creditLineConstants[_id].collateralAsset = _collateralAsset;     creditLineConstants[_id].requestByLender = _requestByLender;     return _id; }  /**  * @notice used to accept a credit line  * @dev if borrower places request, lender can accept and vice versa  * @param _id identifier for the credit line  */ function accept(uint256 _id) external {     require(         creditLineVariables[_id].status == CreditLineStatus.REQUESTED,         'CreditLine::acceptCreditLineLender - CreditLine is already accepted'     );     bool _requestByLender = creditLineConstants[_id].requestByLender;     require(         (msg.sender == creditLineConstants[_id].borrower &amp;&amp; _requestByLender) ||             (msg.sender == creditLineConstants[_id].lender &amp;&amp; !_requestByLender),         "Only Borrower or Lender who hasn't requested can accept"     );     creditLineVariables[_id].status = CreditLineStatus.ACTIVE;     emit CreditLineAccepted(_id); }  /**  * @notice used to deposit collateral into the credit line  * @dev collateral tokens have to be approved in savingsAccount or token contract(unless ether).         If transferred from savings account, the tokens are transferred from strategies in the          order prespecified in strategy registry  * @param _id identifier for the credit line  * @param _amount amount of collateral being deposited  * @param _strategy strategy to which collateral is to be deposited in case transfer is not from savings account  * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount                              otherwise direct from collateral token contract  */ function depositCollateral(     uint256 _id,     uint256 _amount,     address _strategy,     bool _fromSavingsAccount ) external payable nonReentrant ifCreditLineExists(_id) {     require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine not active');     _depositCollateral(_id, _amount, _strategy, _fromSavingsAccount);     emit CollateralDeposited(_id, _amount, _strategy); }  function _depositCollateral(     uint256 _id,     uint256 _amount,     address _strategy,     bool _fromSavingsAccount ) internal {     require(creditLineConstants[_id].lender != msg.sender, 'lender cant deposit collateral');     if (_fromSavingsAccount) {         _depositCollateralFromSavingsAccount(_id, _amount, msg.sender);     } else {         address _collateralAsset = creditLineConstants[_id].collateralAsset;         ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);         if (_collateralAsset == address(0)) {             require(msg.value == _amount, "CreditLine::_depositCollateral - value to transfer doesn't match argument");         } else {             IERC20(_collateralAsset).safeTransferFrom(msg.sender, address(this), _amount);             IERC20(_collateralAsset).approve(_strategy, _amount);         }         uint256 _sharesReceived = _savingsAccount.deposit{value: msg.value}(_amount, _collateralAsset, _strategy, address(this));         collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(_sharesReceived);     } }  function _withdrawBorrowAmount(     address _asset,     uint256 _amountInTokens,     address _lender ) internal {     address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();     ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);     uint256 _activeAmount;     for (uint256 _index = 0; _index &lt; _strategyList.length; _index++) {         if (_strategyList[_index] == address(0)) {             continue;         }         uint256 _liquidityShares = _savingsAccount.balanceInShares(_lender, _asset, _strategyList[_index]);         if (_liquidityShares != 0) {             uint256 tokenInStrategy = _liquidityShares;             tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);             uint256 _tokensToTransfer = tokenInStrategy;             if (_activeAmount.add(tokenInStrategy) &gt;= _amountInTokens) {                 _tokensToTransfer = (_amountInTokens.sub(_activeAmount));             }             _activeAmount = _activeAmount.add(_tokensToTransfer);             _savingsAccount.withdrawFrom(_tokensToTransfer, _asset, _strategyList[_index], _lender, address(this), false);             if (_activeAmount == _amountInTokens) {                 return;             }         }     }     require(_activeAmount == _amountInTokens, 'insufficient balance'); }  /**  * @notice used to borrow tokens from credit line by borrower  * @dev only borrower can call this function. Amount that can actually be borrowed is          min(amount based on borrowLimit, allowance to creditLine contract, balance of lender)  * @param _id identifier for the credit line  * @param _amount amount of tokens to borrow  */ function borrow(uint256 _id, uint256 _amount) external payable nonReentrant onlyCreditLineBorrower(_id) {     require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');     uint256 _borrowableAmount = calculateBorrowableAmount(_id);     require(_amount &lt;= _borrowableAmount, "CreditLine::borrow - The current collateral ratio doesn't allow to withdraw the amount");     address _borrowAsset = creditLineConstants[_id].borrowAsset;     address _lender = creditLineConstants[_id].lender;      updateinterestAccruedTillLastPrincipalUpdate(_id);     creditLineVariables[_id].principal = creditLineVariables[_id].principal.add(_amount);     creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;      uint256 _tokenDiffBalance;     if (_borrowAsset != address(0)) {         uint256 _balanceBefore = IERC20(_borrowAsset).balanceOf(address(this));         _withdrawBorrowAmount(_borrowAsset, _amount, _lender);         uint256 _balanceAfter = IERC20(_borrowAsset).balanceOf(address(this));         _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);     } else {         uint256 _balanceBefore = address(this).balance;         _withdrawBorrowAmount(_borrowAsset, _amount, _lender);         uint256 _balanceAfter = address(this).balance;         _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);     }     uint256 _protocolFee = _tokenDiffBalance.mul(protocolFeeFraction).div(10**30);     _tokenDiffBalance = _tokenDiffBalance.sub(_protocolFee);      if (_borrowAsset == address(0)) {         (bool feeSuccess, ) = protocolFeeCollector.call{value: _protocolFee}('');         require(feeSuccess, 'Transfer fail');         (bool success, ) = msg.sender.call{value: _tokenDiffBalance}('');         require(success, 'Transfer fail');     } else {         IERC20(_borrowAsset).safeTransfer(protocolFeeCollector, _protocolFee);         IERC20(_borrowAsset).safeTransfer(msg.sender, _tokenDiffBalance);     }     emit BorrowedFromCreditLine(_id, _tokenDiffBalance); }  function _repayFromSavingsAccount(     uint256 _amount,     address _asset,     address _lender ) internal {     address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();     ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);     uint256 _activeAmount;      for (uint256 _index = 0; _index &lt; _strategyList.length; _index++) {         if (_strategyList[_index] == address(0)) {             continue;         }         uint256 _liquidityShares = _savingsAccount.balanceInShares(msg.sender, _asset, _strategyList[_index]);         if (_liquidityShares == 0) {             continue;         }         uint256 _tokenInStrategy = _liquidityShares;         _tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);          uint256 _tokensToTransfer = _tokenInStrategy;         if (_activeAmount.add(_tokenInStrategy) &gt;= _amount) {             _tokensToTransfer = (_amount.sub(_activeAmount));         }         _activeAmount = _activeAmount.add(_tokensToTransfer);         _savingsAccount.transferFrom(_tokensToTransfer, _asset, _strategyList[_index], msg.sender, _lender);          if (_amount == _activeAmount) {             return;         }     }     revert('CreditLine::_repayFromSavingsAccount - Insufficient balance'); }  function _repay(     uint256 _id,     uint256 _amount,     bool _fromSavingsAccount,     uint256 _principalPaid ) internal {     ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);     address _defaultStrategy = defaultStrategy;     address _borrowAsset = creditLineConstants[_id].borrowAsset;     address _lender = creditLineConstants[_id].lender;     if (!_fromSavingsAccount) {         if (_borrowAsset == address(0)) {             require(msg.value == _amount, 'creditLine::repay - Ether sent not equal to repay amount');             _savingsAccount.deposit{value: _amount}(_amount, _borrowAsset, _defaultStrategy, _lender);         } else {             IERC20(_borrowAsset).safeTransferFrom(msg.sender, address(this), _amount);             IERC20(_borrowAsset).approve(_defaultStrategy, _amount);             _savingsAccount.deposit(_amount, _borrowAsset, _defaultStrategy, _lender);         }     } else {         _repayFromSavingsAccount(_amount, _borrowAsset, _lender);     }     if (_principalPaid != 0) {         _savingsAccount.increaseAllowanceToCreditLine(_principalPaid, _borrowAsset, _lender);     } }  /**  * @notice used to repay interest and principal to credit line. Interest has to be repaid before repaying principal  * @dev partial repayments possible  * @param _id identifier for the credit line  * @param _amount amount being repaid  * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount                              otherwise direct from collateral token contract  */ function repay(     uint256 _id,     uint256 _amount,     bool _fromSavingsAccount ) external payable nonReentrant {     require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');     require(creditLineConstants[_id].lender != msg.sender, 'Lender cant repay');      uint256 _interestSincePrincipalUpdate = calculateInterestAccrued(_id);     uint256 _totalInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(         _interestSincePrincipalUpdate     );     uint256 _interestToPay = _totalInterestAccrued.sub(creditLineVariables[_id].totalInterestRepaid);     uint256 _totalCurrentDebt = _interestToPay.add(creditLineVariables[_id].principal);     uint256 _principalPaid = 0;      if (_amount &gt;= _totalCurrentDebt) {         _amount = _totalCurrentDebt;         emit CompleteCreditLineRepaid(_id, _amount);     } else {         emit PartialCreditLineRepaid(_id, _amount);     }      if (_amount &gt; _interestToPay) {         creditLineVariables[_id].principal = _totalCurrentDebt.sub(_amount);         creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _totalInterestAccrued;         creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;         creditLineVariables[_id].totalInterestRepaid = _totalInterestAccrued;         _principalPaid = _amount.sub(_interestToPay);     } else {         creditLineVariables[_id].totalInterestRepaid = creditLineVariables[_id].totalInterestRepaid.add(_amount);     }      _repay(_id, _amount, _fromSavingsAccount, _principalPaid);      if (creditLineVariables[_id].principal == 0) {         _resetCreditLine(_id);     } }  function _resetCreditLine(uint256 _id) internal {     creditLineVariables[_id].lastPrincipalUpdateTime = 0;     creditLineVariables[_id].totalInterestRepaid = 0;     creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = 0;     emit CreditLineReset(_id); }  /**  * @dev used to close credit line by borrower or lender  * @param _id identifier for the credit line  */ function close(uint256 _id) external ifCreditLineExists(_id) {     require(         msg.sender == creditLineConstants[_id].borrower || msg.sender == creditLineConstants[_id].lender,         'CreditLine: Permission denied while closing Line of credit'     );     require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: Credit line should be active.');     require(creditLineVariables[_id].principal == 0, 'CreditLine: Cannot be closed since not repaid.');     require(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate == 0, 'CreditLine: Cannot be closed since not repaid.');     creditLineVariables[_id].status = CreditLineStatus.CLOSED;     emit CreditLineClosed(_id); }  /**  * @notice used to calculate the current collateral ratio  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view.         Interest is also considered while calculating debt  * @param _id identifier for the credit line  * @return collateral ratio multiplied by 10**30 to retain precision  */ function calculateCurrentCollateralRatio(uint256 _id) public ifCreditLineExists(_id) returns (uint256) {     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(         creditLineConstants[_id].collateralAsset,         creditLineConstants[_id].borrowAsset     );      uint256 currentDebt = calculateCurrentDebt(_id);     uint256 currentCollateralRatio = calculateTotalCollateralTokens(_id).mul(_ratioOfPrices).div(currentDebt).mul(10**30).div(         10**_decimals     );      return currentCollateralRatio; }  /**  * @notice used to calculate the total collateral tokens  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view  * @param _id identifier for the credit line  * @return _amount total collateral tokens deposited into the credit line  */ function calculateTotalCollateralTokens(uint256 _id) public returns (uint256 _amount) {     address _collateralAsset = creditLineConstants[_id].collateralAsset;     address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();     uint256 _liquidityShares;     for (uint256 index = 0; index &lt; _strategyList.length; index++) {         if (_strategyList[index] == address(0)) {             continue;         }         _liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];         uint256 _tokenInStrategy = _liquidityShares;         _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(_liquidityShares, _collateralAsset);          _amount = _amount.add(_tokenInStrategy);     } }  /**  * @notice used to withdraw any excess collateral  * @dev collateral can't be withdraw if collateralRatio goes below the ideal value. Only borrower can withdraw  * @param _id identifier for the credit line  * @param _amount amount of collateral to withdraw  * @param _toSavingsAccount if true, tokens are transferred from savingsAccount                              otherwise direct from collateral token contract  */ function withdrawCollateral(     uint256 _id,     uint256 _amount,     bool _toSavingsAccount ) external nonReentrant onlyCreditLineBorrower(_id) {     uint256 _withdrawableCollateral = withdrawableCollateral(_id);     require(_amount &lt;= _withdrawableCollateral, 'Collateral ratio cant go below ideal');     address _collateralAsset = creditLineConstants[_id].collateralAsset;     _transferCollateral(_id, _collateralAsset, _amount, _toSavingsAccount);     emit CollateralWithdrawn(_id, _amount); }  /**  * @notice used to calculate the collateral that can be withdrawn  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view  * @param _id identifier for the credit line  * @return total collateral withdrawable by borrower  */ function withdrawableCollateral(uint256 _id) public returns (uint256) {     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(         creditLineConstants[_id].collateralAsset,         creditLineConstants[_id].borrowAsset     );      uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);     uint256 _currentDebt = calculateCurrentDebt(_id);      uint256 _collateralNeeded = _currentDebt         .mul(creditLineConstants[_id].idealCollateralRatio)         .div(_ratioOfPrices)         .mul(10**_decimals)         .div(10**30);      if (_collateralNeeded &gt;= _totalCollateralTokens) {         return 0;     }     return _totalCollateralTokens.sub(_collateralNeeded); }  function _transferCollateral(     uint256 _id,     address _asset,     uint256 _amountInTokens,     bool _toSavingsAccount ) internal {     address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();     uint256 _activeAmount;     for (uint256 index = 0; index &lt; _strategyList.length; index++) {         uint256 liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];         if (liquidityShares == 0 || _strategyList[index] == address(0)) {             continue;         }         uint256 _tokenInStrategy = liquidityShares;         _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(liquidityShares, _asset);         uint256 _tokensToTransfer = _tokenInStrategy;         if (_activeAmount.add(_tokenInStrategy) &gt; _amountInTokens) {             _tokensToTransfer = _amountInTokens.sub(_activeAmount);             liquidityShares = liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy);         }         _activeAmount = _activeAmount.add(_tokensToTransfer);         collateralShareInStrategy[_id][_strategyList[index]] = collateralShareInStrategy[_id][_strategyList[index]].sub(             liquidityShares         );         if (_toSavingsAccount) {             ISavingsAccount(savingsAccount).transfer(_tokensToTransfer, _asset, _strategyList[index], msg.sender);         } else {             ISavingsAccount(savingsAccount).withdraw(_tokensToTransfer, _asset, _strategyList[index], msg.sender, false);         }          if (_activeAmount == _amountInTokens) {             return;         }     }     revert('insufficient collateral'); }  /**  * @notice used to liquidate credit line in case collateral ratio goes below the threshold  * @dev if lender liquidates, then collateral is directly transferred.          If autoLiquidation is true, anyone can liquidate by providing enough borrow tokens  * @param _id identifier for the credit line  * @param _toSavingsAccount if true, tokens are transferred from savingsAccount                              otherwise direct from collateral token contract  */ function liquidate(uint256 _id, bool _toSavingsAccount) external payable nonReentrant {     require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: Credit line should be active.');     require(creditLineVariables[_id].principal != 0, 'CreditLine: cannot liquidate if principal is 0');      uint256 currentCollateralRatio = calculateCurrentCollateralRatio(_id);     require(         currentCollateralRatio &lt; creditLineConstants[_id].idealCollateralRatio,         'CreditLine: Collateral ratio is higher than ideal value'     );      address _collateralAsset = creditLineConstants[_id].collateralAsset;     address _lender = creditLineConstants[_id].lender;     uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);     address _borrowAsset = creditLineConstants[_id].borrowAsset;      creditLineVariables[_id].status = CreditLineStatus.LIQUIDATED;      if (creditLineConstants[_id].autoLiquidation &amp;&amp; _lender != msg.sender) {         uint256 _borrowTokens = _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens);         if (_borrowAsset == address(0)) {             uint256 _returnETH = msg.value.sub(_borrowTokens, 'Insufficient ETH to liquidate');             if (_returnETH != 0) {                 (bool success, ) = msg.sender.call{value: _returnETH}('');                 require(success, 'Transfer fail');             }         } else {             IERC20(_borrowAsset).safeTransferFrom(msg.sender, _lender, _borrowTokens);         }     }      _transferCollateral(_id, _collateralAsset, _totalCollateralTokens, _toSavingsAccount);      emit CreditLineLiquidated(_id, msg.sender); }  /**  * @notice used to calculate the borrow tokens necessary for liquidator to liquidate  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view  * @param _id identifier for the credit line  * @return borrow tokens necessary for liquidator to liquidate  */ function borrowTokensToLiquidate(uint256 _id) external returns (uint256) {     address _collateralAsset = creditLineConstants[_id].collateralAsset;     uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);     address _borrowAsset = creditLineConstants[_id].borrowAsset;      return _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens); }  function _borrowTokensToLiquidate(     address _borrowAsset,     address _collateralAsset,     uint256 _totalCollateralTokens ) internal view returns (uint256) {     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(_borrowAsset, _collateralAsset);     uint256 _borrowTokens = (         _totalCollateralTokens.mul(uint256(10**30).sub(liquidatorRewardFraction)).div(10**30).mul(_ratioOfPrices).div(10**_decimals)     );      return _borrowTokens; }  receive() external payable {     require(msg.sender == savingsAccount, 'CreditLine::receive invalid transaction'); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: "{task}". Ideas: "{ideas}". As the {assistant_role}, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability. For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix. Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: " Analysis Complete." |
| **phase_name** | ContractReviewComment |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 2, 'task': '// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\n\nimport \'@openzeppelin/contracts/token/ERC20/SafeERC20.sol\';\nimport \'@openzeppelin/contracts/math/SafeMath.sol\';\nimport \'@openzeppelin/contracts/utils/ReentrancyGuard.sol\';\nimport \'@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\';\nimport \'../interfaces/IPriceOracle.sol\';\nimport \'../interfaces/IYield.sol\';\nimport \'../interfaces/ISavingsAccount.sol\';\nimport \'../SavingsAccount/SavingsAccountUtil.sol\';\nimport \'../interfaces/IStrategyRegistry.sol\';\n\n/\n * @title Credit Line contract with Methods related to credit Line\n * @notice Implements the functions related to Credit Line\n * @author Sublime\n /\n\ncontract CreditLine is ReentrancyGuard, OwnableUpgradeable {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    enum CreditLineStatus {\n        NOT_CREATED,\n        REQUESTED,\n        ACTIVE,\n        CLOSED,\n        CANCELLED,\n        LIQUIDATED\n    }\n\n    /\n     * @notice counter that tracks the number of credit lines created\n     * @dev used to create unique identifier for credit lines\n     /\n    uint256 public creditLineCounter;\n\n    uint256 constant YEAR_IN_SECONDS = 365 days;\n\n    struct CreditLineVariables {\n        CreditLineStatus status;\n        uint256 principal;\n        uint256 totalInterestRepaid;\n        uint256 lastPrincipalUpdateTime;\n        uint256 interestAccruedTillLastPrincipalUpdate;\n    }\n\n    struct CreditLineConstants {\n        address lender;\n        address borrower;\n        uint256 borrowLimit;\n        uint256 idealCollateralRatio;\n        uint256 borrowRate;\n        address borrowAsset;\n        address collateralAsset;\n        bool autoLiquidation;\n        bool requestByLender;\n    }\n    /\n     * @notice stores the collateral shares in a credit line per strategy\n     * @dev creditLineId =&gt; Strategy =&gt; collateralShares\n     /\n    mapping(uint256 =&gt; mapping(address =&gt; uint256)) public collateralShareInStrategy;\n\n    /\n     * @notice stores the variables to maintain a credit line\n     /\n    mapping(uint256 =&gt; CreditLineVariables) public creditLineVariables;\n\n    /\n     * @notice stores the constants related to a credit line\n     /\n    mapping(uint256 =&gt; CreditLineConstants) public creditLineConstants;\n\n    /\n     * @notice stores the address of savings account contract\n     /\n    address public savingsAccount;\n\n    /\n     * @notice stores the address of price oracle contract\n     /\n    address public priceOracle;\n\n    /\n     * @notice stores the address of strategy registry contract\n     /\n    address public strategyRegistry;\n\n    /\n     * @notice stores the address of default strategy\n     /\n    address public defaultStrategy;\n\n    /\n     * @notice stores the fraction of borrowed amount charged as fee by protocol\n     * @dev it is multiplied by 1030\n     /\n    uint256 public protocolFeeFraction;\n\n    /\n     * @notice address where protocol fee is collected\n     /\n    address public protocolFeeCollector;\n\n    /\n     * @notice stores the fraction of amount liquidated given as reward to liquidator\n     * @dev it is multiplied by 1030\n     /\n    uint256 public liquidatorRewardFraction;\n    /\n     * @dev checks if Credit Line exists\n     * @param _id identifier for the credit line\n     /\n    modifier ifCreditLineExists(uint256 id) {\n        require(creditLineVariables[_id].status != CreditLineStatus.NOT_CREATED, \'Credit line does not exist\');\n        ;\n    }\n\n    /\n     * @dev checks if called by credit Line Borrower\n     * @param _id creditLine identifier\n     /\n    modifier onlyCreditLineBorrower(uint256 id) {\n        require(creditLineConstants[_id].borrower == msg.sender, \'Only credit line Borrower can access\');\n        ;\n    }\n\n    /\n     * @dev checks if called by credit Line Lender\n     * @param _id creditLine identifier\n     /\n    modifier onlyCreditLineLender(uint256 id) {\n        require(creditLineConstants[_id].lender == msg.sender, \'Only credit line Lender can access\');\n        ;\n    }\n\n    /\n     * @notice emitted when a collateral is deposited into credit line\n     * @param id id of the credit line\n     * @param amount amount of collateral deposited\n     * @param strategy address of the strategy into which collateral is deposited\n     */\n    event CollateralDeposited(uint256 indexed id, uint256 amount, address indexed strategy);\n\n    /\n     * @notice emitted when collateral is withdrawn from credit line\n     * @param id id of the credit line\n     * @param amount amount of collateral withdrawn\n     /\n    event CollateralWithdrawn(uint256 indexed id, uint256 amount);\n\n    /\n     * @notice emitted when a request for new credit line is placed\n     * @param id id of the credit line for which request was made\n     * @param lender address of the lender for credit line\n     * @param borrower address of the borrower for credit line\n     /\n    event CreditLineRequested(uint256 indexed id, address indexed lender, address indexed borrower);\n\n    /\n     * @notice emitted when a credit line is liquidated\n     * @param id id of the credit line which is liquidated\n     * @param liquidator address of the liquidator\n     */\n    event CreditLineLiquidated(uint256 indexed id, address indexed liquidator);\n\n    /\n     * @notice emitted when tokens are borrowed from credit line\n     * @param id id of the credit line from which tokens are borrowed\n     * @param borrowAmount amount of tokens borrowed\n     /\n    event BorrowedFromCreditLine(uint256 indexed id, uint256 borrowAmount);\n\n    /\n     * @notice emitted when credit line is accepted\n     * @param id id of the credit line that was accepted\n     /\n    event CreditLineAccepted(uint256 indexed id);\n\n    /\n     * @notice emitted when credit line is completely repaid and reset\n     * @param id id of the credit line that is reset\n     */\n    event CreditLineReset(uint256 indexed id);\n\n    /\n     * @notice emitted when the credit line is partially repaid\n     * @param id id of the credit line\n     * @param repayAmount amount repaid\n     /\n    event PartialCreditLineRepaid(uint256 indexed id, uint256 repayAmount);\n\n    /\n     * @notice emitted when the credit line is completely repaid\n     * @param id id of the credit line\n     * @param repayAmount amount repaid\n     /\n    event CompleteCreditLineRepaid(uint256 indexed id, uint256 repayAmount);\n\n    /\n     * @notice emitted when the credit line is closed by one of the parties of credit line\n     * @param id id of the credit line\n     */\n    event CreditLineClosed(uint256 indexed id);\n\n    /\n     * @notice emitted when default strategy for the credit line is updated\n     * @param defaultStrategy address of the strategy contract that is used as default by credit lines\n     /\n    event DefaultStrategyUpdated(address indexed defaultStrategy);\n\n    /\n     * @notice emitted when the price oracle is updated\n     * @param priceOracle address of the updated price oracle\n     /\n    event PriceOracleUpdated(address indexed priceOracle);\n\n    /\n     * @notice emitted when the savings account address is updated\n     * @param savingsAccount address of the updated savingsAccount\n     */\n    event SavingsAccountUpdated(address indexed savingsAccount);\n\n    /\n     * @notice emitted when strategy registry address is updated\n     * @param strategyRegistry address of the updated strategy registry\n     /\n    event StrategyRegistryUpdated(address indexed strategyRegistry);\n\n    /\n     * @notice emitted when fee that protocol charges for credit line is updated\n     * @param updatedProtocolFee updated value of protocolFeeFraction\n     /\n    event ProtocolFeeFractionUpdated(uint256 updatedProtocolFee);\n\n    /\n     * @notice emitted when address which receives fee that protocol changes for pools is updated\n     * @param updatedProtocolFeeCollector updated value of protocolFeeCollector\n     */\n    event ProtocolFeeCollectorUpdated(address indexed updatedProtocolFeeCollector);\n\n    /\n     * @notice emitted when liquidatorRewardFraction is updated\n     * @param liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator\n     /\n    event LiquidationRewardFractionUpdated(uint256 liquidatorRewardFraction);\n\n    /\n     * @notice used to initialize the contract\n     * @dev can only be called once during the life cycle of the contract\n     * @param _defaultStrategy default strategy used in credit lines\n     * @param _priceOracle address of the priceOracle\n     * @param _savingsAccount address of  the savings account contract\n     * @param _strategyRegistry address of the strategy registry contract\n     * @param _owner address of owner who can change global variables\n     * @param _protocolFeeFraction fraction of the fee charged by protocol\n     * @param _protocolFeeCollector address to which protocol fee is charged to\n     * @param _liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator\n     /\n    function initialize(\n        address _defaultStrategy,\n        address _priceOracle,\n        address _savingsAccount,\n        address _strategyRegistry,\n        address _owner,\n        uint256 _protocolFeeFraction,\n        address _protocolFeeCollector,\n        uint256 _liquidatorRewardFraction\n    ) external initializer {\n        OwnableUpgradeable.__Ownable_init();\n        OwnableUpgradeable.transferOwnership(_owner);\n\n        _updateDefaultStrategy(_defaultStrategy);\n        _updatePriceOracle(_priceOracle);\n        _updateSavingsAccount(_savingsAccount);\n        _updateStrategyRegistry(_strategyRegistry);\n        _updateProtocolFeeFraction(_protocolFeeFraction);\n        _updateProtocolFeeCollector(_protocolFeeCollector);\n        _updateLiquidatorRewardFraction(_liquidatorRewardFraction);\n    }\n\n    /\n     * @notice used to update the default strategy\n     * @dev can only be updated by owner\n     * @param _defaultStrategy address of the updated default strategy\n     */\n    function updateDefaultStrategy(address _defaultStrategy) external onlyOwner {\n        _updateDefaultStrategy(_defaultStrategy);\n    }\n\n    function _updateDefaultStrategy(address _defaultStrategy) internal {\n        defaultStrategy = _defaultStrategy;\n        emit DefaultStrategyUpdated(_defaultStrategy);\n    }\n\n    /\n     * @notice used to update the price oracle\n     * @dev can only be updated by owner\n     * @param _priceOracle address of the updated price oracle\n     /\n    function updatePriceOracle(address _priceOracle) external onlyOwner {\n        _updatePriceOracle(_priceOracle);\n    }\n\n    function _updatePriceOracle(address _priceOracle) internal {\n        priceOracle = _priceOracle;\n        emit PriceOracleUpdated(_priceOracle);\n    }\n\n    /\n     * @notice used to update the savings account address\n     * @dev can only be updated by owner\n     * @param _savingsAccount address of the updated savings account\n     /\n    function updateSavingsAccount(address _savingsAccount) external onlyOwner {\n        _updateSavingsAccount(_savingsAccount);\n    }\n\n    function _updateSavingsAccount(address _savingsAccount) internal {\n        savingsAccount = _savingsAccount;\n        emit SavingsAccountUpdated(_savingsAccount);\n    }\n\n    /\n     * @notice used to update the protocol fee fraction\n     * @dev can only be updated by owner\n     * @param _protocolFee fraction of the borrower amount collected as protocol fee\n     */\n    function updateProtocolFeeFraction(uint256 _protocolFee) external onlyOwner {\n        _updateProtocolFeeFraction(_protocolFee);\n    }\n\n    function _updateProtocolFeeFraction(uint256 _protocolFee) internal {\n        protocolFeeFraction = _protocolFee;\n        emit ProtocolFeeFractionUpdated(_protocolFee);\n    }\n\n    /\n     * @notice used to update the protocol fee collector\n     * @dev can only be updated by owner\n     * @param _protocolFeeCollector address in which protocol fee is collected\n     /\n    function updateProtocolFeeCollector(address _protocolFeeCollector) external onlyOwner {\n        _updateProtocolFeeCollector(_protocolFeeCollector);\n    }\n\n    function _updateProtocolFeeCollector(address _protocolFeeCollector) internal {\n        require(_protocolFeeCollector != address(0), \'cant be 0 address\');\n        protocolFeeCollector = _protocolFeeCollector;\n        emit ProtocolFeeCollectorUpdated(_protocolFeeCollector);\n    }\n\n    /\n     * @notice used to update the strategy registry address\n     * @dev can only be updated by owner\n     * @param _strategyRegistry address of the updated strategy registry\n     /\n    function updateStrategyRegistry(address _strategyRegistry) external onlyOwner {\n        _updateStrategyRegistry(_strategyRegistry);\n    }\n\n    function _updateStrategyRegistry(address _strategyRegistry) internal {\n        require(_strategyRegistry != address(0), \'CL::I zero address\');\n        strategyRegistry = _strategyRegistry;\n        emit StrategyRegistryUpdated(_strategyRegistry);\n    }\n\n    /\n     * @notice used to update the liquidatorRewardFraction\n     * @dev can only be updated by owner\n     * @param _rewardFraction fraction of liquidated amount given to liquidator as reward\n     */\n    function updateLiquidatorRewardFraction(uint256 _rewardFraction) external onlyOwner {\n        _updateLiquidatorRewardFraction(_rewardFraction);\n    }\n\n    function _updateLiquidatorRewardFraction(uint256 _rewardFraction) internal {\n        require(_rewardFraction &lt;= 1030, \'Fraction has to be less than 1\');\n        liquidatorRewardFraction = _rewardFraction;\n        emit LiquidationRewardFractionUpdated(_rewardFraction);\n    }\n\n    /\n     * @dev Used to Calculate Interest Per second on given principal and Interest rate\n     * @param _principal principal Amount for which interest has to be calculated.\n     * @param _borrowRate It is the Interest Rate at which Credit Line is approved\n     * @return interest per second for the given parameters\n     */\n    function calculateInterest(\n        uint256 _principal,\n        uint256 _borrowRate,\n        uint256 _timeElapsed\n    ) public pure returns (uint256) {\n        uint256 _interest = _principal.mul(_borrowRate).mul(_timeElapsed).div(1030).div(YEAR_IN_SECONDS);\n\n        return _interest;\n    }\n\n    /\n     * @dev Used to calculate interest accrued since last repayment\n     * @param _id identifier for the credit line\n     * @return interest accrued over current borrowed amount since last repayment\n     */\n\n    function calculateInterestAccrued(uint256 _id) public view returns (uint256) {\n        uint256 _lastPrincipalUpdateTime = creditLineVariables[_id].lastPrincipalUpdateTime;\n        if (_lastPrincipalUpdateTime == 0) return 0;\n        uint256 _timeElapsed = (block.timestamp).sub(_lastPrincipalUpdateTime);\n        uint256 _interestAccrued = calculateInterest(creditLineVariables[_id].principal, creditLineConstants[_id].borrowRate, _timeElapsed);\n        return _interestAccrued;\n    }\n\n    /\n     * @dev Used to calculate current debt of borrower against a credit line.\n     * @param _id identifier for the credit line\n     * @return current debt of borrower\n     /\n    function calculateCurrentDebt(uint256 _id) public view returns (uint256) {\n        uint256 _interestAccrued = calculateInterestAccrued(_id);\n        uint256 _currentDebt = (creditLineVariables[_id].principal)\n            .add(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate)\n            .add(_interestAccrued)\n            .sub(creditLineVariables[_id].totalInterestRepaid);\n        return _currentDebt;\n    }\n\n    /\n     * @notice used to calculate amount that can be borrowed by the borrower\n     * @dev is a view function for the protocol itself, but isn\'t view because of getTokensForShares which is not view.\n            borrowableAmount changes per block as interest changes per block.\n     * @param _id identifier for the credit line\n     * @return amount that can be borrowed from the credit line\n     /\n    function calculateBorrowableAmount(uint256 _id) public returns (uint256) {\n        CreditLineStatus _status = creditLineVariables[_id].status;\n        require(\n            _status == CreditLineStatus.ACTIVE || _status == CreditLineStatus.REQUESTED,\n            \'CreditLine: Cannot only if credit line ACTIVE or REQUESTED\'\n        );\n        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(\n            creditLineConstants[_id].collateralAsset,\n            creditLineConstants[_id].borrowAsset\n        );\n\n        uint256 _totalCollateralToken = calculateTotalCollateralTokens(_id);\n\n        uint256 _currentDebt = calculateCurrentDebt(_id);\n\n        uint256 _maxPossible = _totalCollateralToken.mul(_ratioOfPrices).div(creditLineConstants[_id].idealCollateralRatio).mul(1030).div(\n            10_decimals\n        );\n\n        uint256 _borrowLimit = creditLineConstants[_id].borrowLimit;\n\n        if (_maxPossible &gt; _borrowLimit) {\n            _maxPossible = _borrowLimit;\n        }\n        if (_maxPossible &gt; _currentDebt) {\n            return _maxPossible.sub(_currentDebt);\n        }\n        return 0;\n    }\n\n    function updateinterestAccruedTillLastPrincipalUpdate(uint256 _id) internal {\n        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, \'CreditLine: The credit line is not yet active.\');\n\n        uint256 _interestAccrued = calculateInterestAccrued(_id);\n        uint256 _newInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(_interestAccrued);\n        creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _newInterestAccrued;\n    }\n\n    function _depositCollateralFromSavingsAccount(\n        uint256 _id,\n        uint256 _amount,\n        address _sender\n    ) internal {\n        address _collateralAsset = creditLineConstants[_id].collateralAsset;\n        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();\n        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);\n        uint256 _activeAmount;\n\n        for (uint256 _index = 0; _index &lt; _strategyList.length; _index++) {\n            address _strategy = _strategyList[_index];\n            uint256 _liquidityShares = _savingsAccount.balanceInShares(_sender, _collateralAsset, _strategy);\n            if (_liquidityShares == 0 || _strategyList[_index] == address(0)) {\n                continue;\n            }\n            uint256 _tokenInStrategy = _liquidityShares;\n            _tokenInStrategy = IYield(_strategy).getTokensForShares(_liquidityShares, _collateralAsset);\n\n            uint256 _tokensToTransfer = _tokenInStrategy;\n            if (_activeAmount.add(_tokenInStrategy) &gt;= _amount) {\n                _tokensToTransfer = (_amount.sub(_activeAmount));\n            }\n            _activeAmount = _activeAmount.add(_tokensToTransfer);\n            _savingsAccount.transferFrom(_tokensToTransfer, _collateralAsset, _strategy, _sender, address(this));\n\n            collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(\n                _liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy)\n            );\n\n            if (_amount == _activeAmount) {\n                return;\n            }\n        }\n        revert(\'CreditLine::_depositCollateralFromSavingsAccount - Insufficient balance\');\n    }\n\n    /\n     * @notice used to request a credit line either by borrower or lender\n     * @param _requestTo Address to which creditLine is requested, \n                        if borrower creates request then lender address and \n                        if lender creates then borrower address\n     * @param _borrowLimit maximum borrow amount in a credit line\n     * @param _borrowRate Interest Rate at which credit Line is requested\n     * @param _autoLiquidation if true, anyone can liquidate loan, otherwise only lender\n     * @param _collateralRatio ratio of the collateral to the debt below which credit line can be liquidated\n     * @param _borrowAsset address of the token to be borrowed\n     * @param _collateralAsset address of the token provided as collateral\n     * @param _requestAsLender if true, lender is placing request, otherwise borrower\n     * @return identifier for the credit line\n     */\n\n    function request(\n        address _requestTo,\n        uint256 _borrowLimit,\n        uint256 _borrowRate,\n        bool _autoLiquidation,\n        uint256 _collateralRatio,\n        address _borrowAsset,\n        address _collateralAsset,\n        bool _requestAsLender\n    ) external returns (uint256) {\n        require(_borrowAsset != _collateralAsset, \'R: cant borrow lent token\');\n        require(IPriceOracle(priceOracle).doesFeedExist(_borrowAsset, _collateralAsset), \'R: No price feed\');\n\n        address _lender = _requestTo;\n        address _borrower = msg.sender;\n        if (_requestAsLender) {\n            _lender = msg.sender;\n            _borrower = _requestTo;\n        }\n\n        uint256 _id = _createRequest(\n            _lender,\n            _borrower,\n            _borrowLimit,\n            _borrowRate,\n            _autoLiquidation,\n            _collateralRatio,\n            _borrowAsset,\n            _collateralAsset,\n            _requestAsLender\n        );\n\n        emit CreditLineRequested(_id, _lender, _borrower);\n        return _id;\n    }\n\n    function _createRequest(\n        address _lender,\n        address _borrower,\n        uint256 _borrowLimit,\n        uint256 _borrowRate,\n        bool _autoLiquidation,\n        uint256 _collateralRatio,\n        address _borrowAsset,\n        address _collateralAsset,\n        bool _requestByLender\n    ) internal returns (uint256) {\n        require(_lender != _borrower, \'Lender and Borrower cannot be same addresses\');\n        uint256 _id = creditLineCounter + 1;\n        creditLineCounter = _id;\n        creditLineVariables[_id].status = CreditLineStatus.REQUESTED;\n        creditLineConstants[_id].borrower = _borrower;\n        creditLineConstants[_id].lender = _lender;\n        creditLineConstants[_id].borrowLimit = _borrowLimit;\n        creditLineConstants[_id].autoLiquidation = _autoLiquidation;\n        creditLineConstants[_id].idealCollateralRatio = _collateralRatio;\n        creditLineConstants[_id].borrowRate = _borrowRate;\n        creditLineConstants[_id].borrowAsset = _borrowAsset;\n        creditLineConstants[_id].collateralAsset = _collateralAsset;\n        creditLineConstants[_id].requestByLender = _requestByLender;\n        return _id;\n    }\n\n    /\n     * @notice used to accept a credit line\n     * @dev if borrower places request, lender can accept and vice versa\n     * @param _id identifier for the credit line\n     /\n    function accept(uint256 _id) external {\n        require(\n            creditLineVariables[_id].status == CreditLineStatus.REQUESTED,\n            \'CreditLine::acceptCreditLineLender - CreditLine is already accepted\'\n        );\n        bool _requestByLender = creditLineConstants[_id].requestByLender;\n        require(\n            (msg.sender == creditLineConstants[_id].borrower &amp;&amp; _requestByLender) ||\n                (msg.sender == creditLineConstants[_id].lender &amp;&amp; !_requestByLender),\n            "Only Borrower or Lender who hasn\'t requested can accept"\n        );\n        creditLineVariables[_id].status = CreditLineStatus.ACTIVE;\n        emit CreditLineAccepted(_id);\n    }\n\n    /\n     * @notice used to deposit collateral into the credit line\n     * @dev collateral tokens have to be approved in savingsAccount or token contract(unless ether).\n            If transferred from savings account, the tokens are transferred from strategies in the \n            order prespecified in strategy registry\n     * @param _id identifier for the credit line\n     * @param _amount amount of collateral being deposited\n     * @param _strategy strategy to which collateral is to be deposited in case transfer is not from savings account\n     * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount \n                                otherwise direct from collateral token contract\n     /\n    function depositCollateral(\n        uint256 _id,\n        uint256 _amount,\n        address _strategy,\n        bool _fromSavingsAccount\n    ) external payable nonReentrant ifCreditLineExists(_id) {\n        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, \'CreditLine not active\');\n        _depositCollateral(_id, _amount, _strategy, _fromSavingsAccount);\n        emit CollateralDeposited(_id, _amount, _strategy);\n    }\n\n    function _depositCollateral(\n        uint256 _id,\n        uint256 _amount,\n        address _strategy,\n        bool _fromSavingsAccount\n    ) internal {\n        require(creditLineConstants[_id].lender != msg.sender, \'lender cant deposit collateral\');\n        if (_fromSavingsAccount) {\n            _depositCollateralFromSavingsAccount(_id, _amount, msg.sender);\n        } else {\n            address _collateralAsset = creditLineConstants[_id].collateralAsset;\n            ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);\n            if (_collateralAsset == address(0)) {\n                require(msg.value == _amount, "CreditLine::_depositCollateral - value to transfer doesn\'t match argument");\n            } else {\n                IERC20(_collateralAsset).safeTransferFrom(msg.sender, address(this), _amount);\n                IERC20(_collateralAsset).approve(_strategy, _amount);\n            }\n            uint256 _sharesReceived = _savingsAccount.deposit{value: msg.value}(_amount, _collateralAsset, _strategy, address(this));\n            collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(_sharesReceived);\n        }\n    }\n\n    function _withdrawBorrowAmount(\n        address _asset,\n        uint256 _amountInTokens,\n        address _lender\n    ) internal {\n        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();\n        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);\n        uint256 _activeAmount;\n        for (uint256 _index = 0; _index &lt; _strategyList.length; _index++) {\n            if (_strategyList[_index] == address(0)) {\n                continue;\n            }\n            uint256 _liquidityShares = _savingsAccount.balanceInShares(_lender, _asset, _strategyList[_index]);\n            if (_liquidityShares != 0) {\n                uint256 tokenInStrategy = _liquidityShares;\n                tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);\n                uint256 _tokensToTransfer = tokenInStrategy;\n                if (_activeAmount.add(tokenInStrategy) &gt;= _amountInTokens) {\n                    _tokensToTransfer = (_amountInTokens.sub(_activeAmount));\n                }\n                _activeAmount = _activeAmount.add(_tokensToTransfer);\n                _savingsAccount.withdrawFrom(_tokensToTransfer, _asset, _strategyList[_index], _lender, address(this), false);\n                if (_activeAmount == _amountInTokens) {\n                    return;\n                }\n            }\n        }\n        require(_activeAmount == _amountInTokens, \'insufficient balance\');\n    }\n\n    /\n     * @notice used to borrow tokens from credit line by borrower\n     * @dev only borrower can call this function. Amount that can actually be borrowed is \n            min(amount based on borrowLimit, allowance to creditLine contract, balance of lender)\n     * @param _id identifier for the credit line\n     * @param _amount amount of tokens to borrow\n     */\n    function borrow(uint256 _id, uint256 _amount) external payable nonReentrant onlyCreditLineBorrower(_id) {\n        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, \'CreditLine: The credit line is not yet active.\');\n        uint256 _borrowableAmount = calculateBorrowableAmount(_id);\n        require(_amount &lt;= _borrowableAmount, "CreditLine::borrow - The current collateral ratio doesn\'t allow to withdraw the amount");\n        address _borrowAsset = creditLineConstants[_id].borrowAsset;\n        address _lender = creditLineConstants[_id].lender;\n\n        updateinterestAccruedTillLastPrincipalUpdate(_id);\n        creditLineVariables[_id].principal = creditLineVariables[_id].principal.add(_amount);\n        creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;\n\n        uint256 _tokenDiffBalance;\n        if (_borrowAsset != address(0)) {\n            uint256 _balanceBefore = IERC20(_borrowAsset).balanceOf(address(this));\n            _withdrawBorrowAmount(_borrowAsset, _amount, _lender);\n            uint256 _balanceAfter = IERC20(_borrowAsset).balanceOf(address(this));\n            _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);\n        } else {\n            uint256 _balanceBefore = address(this).balance;\n            _withdrawBorrowAmount(_borrowAsset, _amount, _lender);\n            uint256 _balanceAfter = address(this).balance;\n            _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);\n        }\n        uint256 _protocolFee = _tokenDiffBalance.mul(protocolFeeFraction).div(1030);\n        _tokenDiffBalance = _tokenDiffBalance.sub(_protocolFee);\n\n        if (_borrowAsset == address(0)) {\n            (bool feeSuccess, ) = protocolFeeCollector.call{value: _protocolFee}(\'\');\n            require(feeSuccess, \'Transfer fail\');\n            (bool success, ) = msg.sender.call{value: _tokenDiffBalance}(\'\');\n            require(success, \'Transfer fail\');\n        } else {\n            IERC20(_borrowAsset).safeTransfer(protocolFeeCollector, _protocolFee);\n            IERC20(_borrowAsset).safeTransfer(msg.sender, _tokenDiffBalance);\n        }\n        emit BorrowedFromCreditLine(_id, _tokenDiffBalance);\n    }\n\n    function _repayFromSavingsAccount(\n        uint256 _amount,\n        address _asset,\n        address _lender\n    ) internal {\n        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();\n        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);\n        uint256 _activeAmount;\n\n        for (uint256 _index = 0; _index &lt; _strategyList.length; _index++) {\n            if (_strategyList[_index] == address(0)) {\n                continue;\n            }\n            uint256 _liquidityShares = _savingsAccount.balanceInShares(msg.sender, _asset, _strategyList[_index]);\n            if (_liquidityShares == 0) {\n                continue;\n            }\n            uint256 _tokenInStrategy = _liquidityShares;\n            _tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);\n\n            uint256 _tokensToTransfer = _tokenInStrategy;\n            if (_activeAmount.add(_tokenInStrategy) &gt;= _amount) {\n                _tokensToTransfer = (_amount.sub(_activeAmount));\n            }\n            _activeAmount = _activeAmount.add(_tokensToTransfer);\n            _savingsAccount.transferFrom(_tokensToTransfer, _asset, _strategyList[_index], msg.sender, _lender);\n\n            if (_amount == _activeAmount) {\n                return;\n            }\n        }\n        revert(\'CreditLine::_repayFromSavingsAccount - Insufficient balance\');\n    }\n\n    function _repay(\n        uint256 _id,\n        uint256 _amount,\n        bool _fromSavingsAccount,\n        uint256 _principalPaid\n    ) internal {\n        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);\n        address _defaultStrategy = defaultStrategy;\n        address _borrowAsset = creditLineConstants[_id].borrowAsset;\n        address _lender = creditLineConstants[_id].lender;\n        if (!_fromSavingsAccount) {\n            if (_borrowAsset == address(0)) {\n                require(msg.value == _amount, \'creditLine::repay - Ether sent not equal to repay amount\');\n                _savingsAccount.deposit{value: _amount}(_amount, _borrowAsset, _defaultStrategy, _lender);\n            } else {\n                IERC20(_borrowAsset).safeTransferFrom(msg.sender, address(this), _amount);\n                IERC20(_borrowAsset).approve(_defaultStrategy, _amount);\n                _savingsAccount.deposit(_amount, _borrowAsset, _defaultStrategy, _lender);\n            }\n        } else {\n            _repayFromSavingsAccount(_amount, _borrowAsset, _lender);\n        }\n        if (_principalPaid != 0) {\n            _savingsAccount.increaseAllowanceToCreditLine(_principalPaid, _borrowAsset, _lender);\n        }\n    }\n\n    /\n     * @notice used to repay interest and principal to credit line. Interest has to be repaid before repaying principal\n     * @dev partial repayments possible\n     * @param _id identifier for the credit line\n     * @param _amount amount being repaid\n     * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount \n                                otherwise direct from collateral token contract\n     */\n    function repay(\n        uint256 _id,\n        uint256 _amount,\n        bool _fromSavingsAccount\n    ) external payable nonReentrant {\n        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, \'CreditLine: The credit line is not yet active.\');\n        require(creditLineConstants[_id].lender != msg.sender, \'Lender cant repay\');\n\n        uint256 _interestSincePrincipalUpdate = calculateInterestAccrued(_id);\n        uint256 _totalInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(\n            _interestSincePrincipalUpdate\n        );\n        uint256 _interestToPay = _totalInterestAccrued.sub(creditLineVariables[_id].totalInterestRepaid);\n        uint256 _totalCurrentDebt = _interestToPay.add(creditLineVariables[_id].principal);\n        uint256 _principalPaid = 0;\n\n        if (_amount &gt;= _totalCurrentDebt) {\n            _amount = _totalCurrentDebt;\n            emit CompleteCreditLineRepaid(_id, _amount);\n        } else {\n            emit PartialCreditLineRepaid(_id, _amount);\n        }\n\n        if (_amount &gt; _interestToPay) {\n            creditLineVariables[_id].principal = _totalCurrentDebt.sub(_amount);\n            creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _totalInterestAccrued;\n            creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;\n            creditLineVariables[_id].totalInterestRepaid = _totalInterestAccrued;\n            _principalPaid = _amount.sub(_interestToPay);\n        } else {\n            creditLineVariables[_id].totalInterestRepaid = creditLineVariables[_id].totalInterestRepaid.add(_amount);\n        }\n\n        _repay(_id, _amount, _fromSavingsAccount, _principalPaid);\n\n        if (creditLineVariables[_id].principal == 0) {\n            _resetCreditLine(_id);\n        }\n    }\n\n    function _resetCreditLine(uint256 _id) internal {\n        creditLineVariables[_id].lastPrincipalUpdateTime = 0;\n        creditLineVariables[_id].totalInterestRepaid = 0;\n        creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = 0;\n        emit CreditLineReset(_id);\n    }\n\n    /\n     * @dev used to close credit line by borrower or lender\n     * @param _id identifier for the credit line\n     /\n    function close(uint256 _id) external ifCreditLineExists(_id) {\n        require(\n            msg.sender == creditLineConstants[_id].borrower || msg.sender == creditLineConstants[_id].lender,\n            \'CreditLine: Permission denied while closing Line of credit\'\n        );\n        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, \'CreditLine: Credit line should be active.\');\n        require(creditLineVariables[_id].principal == 0, \'CreditLine: Cannot be closed since not repaid.\');\n        require(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate == 0, \'CreditLine: Cannot be closed since not repaid.\');\n        creditLineVariables[_id].status = CreditLineStatus.CLOSED;\n        emit CreditLineClosed(_id);\n    }\n\n    /\n     * @notice used to calculate the current collateral ratio\n     * @dev is a view function for the protocol itself, but isn\'t view because of getTokensForShares which is not view.\n            Interest is also considered while calculating debt\n     * @param _id identifier for the credit line\n     * @return collateral ratio multiplied by 1030 to retain precision\n     /\n    function calculateCurrentCollateralRatio(uint256 _id) public ifCreditLineExists(_id) returns (uint256) {\n        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(\n            creditLineConstants[_id].collateralAsset,\n            creditLineConstants[_id].borrowAsset\n        );\n\n        uint256 currentDebt = calculateCurrentDebt(_id);\n        uint256 currentCollateralRatio = calculateTotalCollateralTokens(_id).mul(_ratioOfPrices).div(currentDebt).mul(1030).div(\n            10_decimals\n        );\n\n        return currentCollateralRatio;\n    }\n\n    /\n     * @notice used to calculate the total collateral tokens\n     * @dev is a view function for the protocol itself, but isn\'t view because of getTokensForShares which is not view\n     * @param _id identifier for the credit line\n     * @return _amount total collateral tokens deposited into the credit line\n     */\n    function calculateTotalCollateralTokens(uint256 _id) public returns (uint256 _amount) {\n        address _collateralAsset = creditLineConstants[_id].collateralAsset;\n        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();\n        uint256 _liquidityShares;\n        for (uint256 index = 0; index &lt; _strategyList.length; index++) {\n            if (_strategyList[index] == address(0)) {\n                continue;\n            }\n            _liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];\n            uint256 _tokenInStrategy = _liquidityShares;\n            _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(_liquidityShares, _collateralAsset);\n\n            _amount = _amount.add(_tokenInStrategy);\n        }\n    }\n\n    /\n     * @notice used to withdraw any excess collateral\n     * @dev collateral can\'t be withdraw if collateralRatio goes below the ideal value. Only borrower can withdraw\n     * @param _id identifier for the credit line\n     * @param _amount amount of collateral to withdraw\n     * @param _toSavingsAccount if true, tokens are transferred from savingsAccount \n                                otherwise direct from collateral token contract\n     /\n    function withdrawCollateral(\n        uint256 _id,\n        uint256 _amount,\n        bool _toSavingsAccount\n    ) external nonReentrant onlyCreditLineBorrower(_id) {\n        uint256 _withdrawableCollateral = withdrawableCollateral(_id);\n        require(_amount &lt;= _withdrawableCollateral, \'Collateral ratio cant go below ideal\');\n        address _collateralAsset = creditLineConstants[_id].collateralAsset;\n        _transferCollateral(_id, _collateralAsset, _amount, _toSavingsAccount);\n        emit CollateralWithdrawn(_id, _amount);\n    }\n\n    /\n     * @notice used to calculate the collateral that can be withdrawn\n     * @dev is a view function for the protocol itself, but isn\'t view because of getTokensForShares which is not view\n     * @param _id identifier for the credit line\n     * @return total collateral withdrawable by borrower\n     /\n    function withdrawableCollateral(uint256 _id) public returns (uint256) {\n        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(\n            creditLineConstants[_id].collateralAsset,\n            creditLineConstants[_id].borrowAsset\n        );\n\n        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);\n        uint256 _currentDebt = calculateCurrentDebt(_id);\n\n        uint256 _collateralNeeded = _currentDebt\n            .mul(creditLineConstants[_id].idealCollateralRatio)\n            .div(_ratioOfPrices)\n            .mul(10_decimals)\n            .div(1030);\n\n        if (_collateralNeeded &gt;= _totalCollateralTokens) {\n            return 0;\n        }\n        return _totalCollateralTokens.sub(_collateralNeeded);\n    }\n\n    function _transferCollateral(\n        uint256 _id,\n        address _asset,\n        uint256 _amountInTokens,\n        bool _toSavingsAccount\n    ) internal {\n        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();\n        uint256 _activeAmount;\n        for (uint256 index = 0; index &lt; _strategyList.length; index++) {\n            uint256 liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];\n            if (liquidityShares == 0 || _strategyList[index] == address(0)) {\n                continue;\n            }\n            uint256 _tokenInStrategy = liquidityShares;\n            _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(liquidityShares, _asset);\n            uint256 _tokensToTransfer = _tokenInStrategy;\n            if (_activeAmount.add(_tokenInStrategy) &gt; _amountInTokens) {\n                _tokensToTransfer = _amountInTokens.sub(_activeAmount);\n                liquidityShares = liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy);\n            }\n            _activeAmount = _activeAmount.add(_tokensToTransfer);\n            collateralShareInStrategy[_id][_strategyList[index]] = collateralShareInStrategy[_id][_strategyList[index]].sub(\n                liquidityShares\n            );\n            if (_toSavingsAccount) {\n                ISavingsAccount(savingsAccount).transfer(_tokensToTransfer, _asset, _strategyList[index], msg.sender);\n            } else {\n                ISavingsAccount(savingsAccount).withdraw(_tokensToTransfer, _asset, _strategyList[index], msg.sender, false);\n            }\n\n            if (_activeAmount == _amountInTokens) {\n                return;\n            }\n        }\n        revert(\'insufficient collateral\');\n    }\n\n    /\n     * @notice used to liquidate credit line in case collateral ratio goes below the threshold\n     * @dev if lender liquidates, then collateral is directly transferred. \n            If autoLiquidation is true, anyone can liquidate by providing enough borrow tokens\n     * @param _id identifier for the credit line\n     * @param _toSavingsAccount if true, tokens are transferred from savingsAccount \n                                otherwise direct from collateral token contract\n     */\n    function liquidate(uint256 _id, bool _toSavingsAccount) external payable nonReentrant {\n        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, \'CreditLine: Credit line should be active.\');\n        require(creditLineVariables[_id].principal != 0, \'CreditLine: cannot liquidate if principal is 0\');\n\n        uint256 currentCollateralRatio = calculateCurrentCollateralRatio(_id);\n        require(\n            currentCollateralRatio &lt; creditLineConstants[_id].idealCollateralRatio,\n            \'CreditLine: Collateral ratio is higher than ideal value\'\n        );\n\n        address _collateralAsset = creditLineConstants[_id].collateralAsset;\n        address _lender = creditLineConstants[_id].lender;\n        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);\n        address _borrowAsset = creditLineConstants[_id].borrowAsset;\n\n        creditLineVariables[_id].status = CreditLineStatus.LIQUIDATED;\n\n        if (creditLineConstants[_id].autoLiquidation &amp;&amp; _lender != msg.sender) {\n            uint256 _borrowTokens = _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens);\n            if (_borrowAsset == address(0)) {\n                uint256 _returnETH = msg.value.sub(_borrowTokens, \'Insufficient ETH to liquidate\');\n                if (_returnETH != 0) {\n                    (bool success, ) = msg.sender.call{value: _returnETH}(\'\');\n                    require(success, \'Transfer fail\');\n                }\n            } else {\n                IERC20(_borrowAsset).safeTransferFrom(msg.sender, _lender, _borrowTokens);\n            }\n        }\n\n        _transferCollateral(_id, _collateralAsset, _totalCollateralTokens, _toSavingsAccount);\n\n        emit CreditLineLiquidated(_id, msg.sender);\n    }\n\n    /\n     * @notice used to calculate the borrow tokens necessary for liquidator to liquidate\n     * @dev is a view function for the protocol itself, but isn\'t view because of getTokensForShares which is not view\n     * @param _id identifier for the credit line\n     * @return borrow tokens necessary for liquidator to liquidate\n     /\n    function borrowTokensToLiquidate(uint256 _id) external returns (uint256) {\n        address _collateralAsset = creditLineConstants[_id].collateralAsset;\n        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);\n        address _borrowAsset = creditLineConstants[_id].borrowAsset;\n\n        return _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens);\n    }\n\n    function _borrowTokensToLiquidate(\n        address _borrowAsset,\n        address _collateralAsset,\n        uint256 _totalCollateralTokens\n    ) internal view returns (uint256) {\n        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(_borrowAsset, _collateralAsset);\n        uint256 _borrowTokens = (\n            _totalCollateralTokens.mul(uint256(1030).sub(liquidatorRewardFraction)).div(1030).mul(_ratioOfPrices).div(10*_decimals)\n        );\n\n        return _borrowTokens;\n    }\n\n    receive() external payable {\n        require(msg.sender == savingsAccount, \'CreditLine::receive invalid transaction\');\n    }\n}\n', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-22-08 11:43:25 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol'; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/utils/ReentrancyGuard.sol'; import '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol'; import '../interfaces/IPriceOracle.sol'; import '../interfaces/IYield.sol'; import '../interfaces/ISavingsAccount.sol'; import '../SavingsAccount/SavingsAccountUtil.sol'; import '../interfaces/IStrategyRegistry.sol'; /  * @title Credit Line contract with Methods related to credit Line  * @notice Implements the functions related to Credit Line  * @author Sublime  / contract CreditLine is ReentrancyGuard, OwnableUpgradeable {     using SafeERC20 for IERC20;     using SafeMath for uint256; enum CreditLineStatus {     NOT_CREATED,     REQUESTED,     ACTIVE,     CLOSED,     CANCELLED,     LIQUIDATED }  /**  * @notice counter that tracks the number of credit lines created  * @dev used to create unique identifier for credit lines  **/ uint256 public creditLineCounter;  uint256 constant YEAR_IN_SECONDS = 365 days;  struct CreditLineVariables {     CreditLineStatus status;     uint256 principal;     uint256 totalInterestRepaid;     uint256 lastPrincipalUpdateTime;     uint256 interestAccruedTillLastPrincipalUpdate; }  struct CreditLineConstants {     address lender;     address borrower;     uint256 borrowLimit;     uint256 idealCollateralRatio;     uint256 borrowRate;     address borrowAsset;     address collateralAsset;     bool autoLiquidation;     bool requestByLender; } /**  * @notice stores the collateral shares in a credit line per strategy  * @dev creditLineId =&gt; Strategy =&gt; collateralShares  **/ mapping(uint256 =&gt; mapping(address =&gt; uint256)) public collateralShareInStrategy;  /**  * @notice stores the variables to maintain a credit line  **/ mapping(uint256 =&gt; CreditLineVariables) public creditLineVariables;  /**  * @notice stores the constants related to a credit line  **/ mapping(uint256 =&gt; CreditLineConstants) public creditLineConstants;  /**  * @notice stores the address of savings account contract  **/ address public savingsAccount;  /**  * @notice stores the address of price oracle contract  **/ address public priceOracle;  /**  * @notice stores the address of strategy registry contract  **/ address public strategyRegistry;  /**  * @notice stores the address of default strategy  **/ address public defaultStrategy;  /**  * @notice stores the fraction of borrowed amount charged as fee by protocol  * @dev it is multiplied by 10**30  **/ uint256 public protocolFeeFraction;  /**  * @notice address where protocol fee is collected  **/ address public protocolFeeCollector;  /**  * @notice stores the fraction of amount liquidated given as reward to liquidator  * @dev it is multiplied by 10**30  **/ uint256 public liquidatorRewardFraction; /**  * @dev checks if Credit Line exists  * @param _id identifier for the credit line  **/ modifier ifCreditLineExists(uint256 _id) {     require(creditLineVariables[_id].status != CreditLineStatus.NOT_CREATED, 'Credit line does not exist');     _; }  /**  * @dev checks if called by credit Line Borrower  * @param _id creditLine identifier  **/ modifier onlyCreditLineBorrower(uint256 _id) {     require(creditLineConstants[_id].borrower == msg.sender, 'Only credit line Borrower can access');     _; }  /**  * @dev checks if called by credit Line Lender  * @param _id creditLine identifier  **/ modifier onlyCreditLineLender(uint256 _id) {     require(creditLineConstants[_id].lender == msg.sender, 'Only credit line Lender can access');     _; }  /**  * @notice emitted when a collateral is deposited into credit line  * @param id id of the credit line  * @param amount amount of collateral deposited  * @param strategy address of the strategy into which collateral is deposited  */ event CollateralDeposited(uint256 indexed id, uint256 amount, address indexed strategy);  /**  * @notice emitted when collateral is withdrawn from credit line  * @param id id of the credit line  * @param amount amount of collateral withdrawn  */ event CollateralWithdrawn(uint256 indexed id, uint256 amount);  /**  * @notice emitted when a request for new credit line is placed  * @param id id of the credit line for which request was made  * @param lender address of the lender for credit line  * @param borrower address of the borrower for credit line  */ event CreditLineRequested(uint256 indexed id, address indexed lender, address indexed borrower);  /**  * @notice emitted when a credit line is liquidated  * @param id id of the credit line which is liquidated  * @param liquidator address of the liquidator  */ event CreditLineLiquidated(uint256 indexed id, address indexed liquidator);  /**  * @notice emitted when tokens are borrowed from credit line  * @param id id of the credit line from which tokens are borrowed  * @param borrowAmount amount of tokens borrowed  */ event BorrowedFromCreditLine(uint256 indexed id, uint256 borrowAmount);  /**  * @notice emitted when credit line is accepted  * @param id id of the credit line that was accepted  */ event CreditLineAccepted(uint256 indexed id);  /**  * @notice emitted when credit line is completely repaid and reset  * @param id id of the credit line that is reset  */ event CreditLineReset(uint256 indexed id);  /**  * @notice emitted when the credit line is partially repaid  * @param id id of the credit line  * @param repayAmount amount repaid  */ event PartialCreditLineRepaid(uint256 indexed id, uint256 repayAmount);  /**  * @notice emitted when the credit line is completely repaid  * @param id id of the credit line  * @param repayAmount amount repaid  */ event CompleteCreditLineRepaid(uint256 indexed id, uint256 repayAmount);  /**  * @notice emitted when the credit line is closed by one of the parties of credit line  * @param id id of the credit line  */ event CreditLineClosed(uint256 indexed id);  /**  * @notice emitted when default strategy for the credit line is updated  * @param defaultStrategy address of the strategy contract that is used as default by credit lines  */ event DefaultStrategyUpdated(address indexed defaultStrategy);  /**  * @notice emitted when the price oracle is updated  * @param priceOracle address of the updated price oracle  */ event PriceOracleUpdated(address indexed priceOracle);  /**  * @notice emitted when the savings account address is updated  * @param savingsAccount address of the updated savingsAccount  */ event SavingsAccountUpdated(address indexed savingsAccount);  /**  * @notice emitted when strategy registry address is updated  * @param strategyRegistry address of the updated strategy registry  */ event StrategyRegistryUpdated(address indexed strategyRegistry);  /**  * @notice emitted when fee that protocol charges for credit line is updated  * @param updatedProtocolFee updated value of protocolFeeFraction  */ event ProtocolFeeFractionUpdated(uint256 updatedProtocolFee);  /**  * @notice emitted when address which receives fee that protocol changes for pools is updated  * @param updatedProtocolFeeCollector updated value of protocolFeeCollector  */ event ProtocolFeeCollectorUpdated(address indexed updatedProtocolFeeCollector);  /**  * @notice emitted when liquidatorRewardFraction is updated  * @param liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator  */ event LiquidationRewardFractionUpdated(uint256 liquidatorRewardFraction);  /**  * @notice used to initialize the contract  * @dev can only be called once during the life cycle of the contract  * @param _defaultStrategy default strategy used in credit lines  * @param _priceOracle address of the priceOracle  * @param _savingsAccount address of  the savings account contract  * @param _strategyRegistry address of the strategy registry contract  * @param _owner address of owner who can change global variables  * @param _protocolFeeFraction fraction of the fee charged by protocol  * @param _protocolFeeCollector address to which protocol fee is charged to  * @param _liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator  */ function initialize(     address _defaultStrategy,     address _priceOracle,     address _savingsAccount,     address _strategyRegistry,     address _owner,     uint256 _protocolFeeFraction,     address _protocolFeeCollector,     uint256 _liquidatorRewardFraction ) external initializer {     OwnableUpgradeable.__Ownable_init();     OwnableUpgradeable.transferOwnership(_owner);      _updateDefaultStrategy(_defaultStrategy);     _updatePriceOracle(_priceOracle);     _updateSavingsAccount(_savingsAccount);     _updateStrategyRegistry(_strategyRegistry);     _updateProtocolFeeFraction(_protocolFeeFraction);     _updateProtocolFeeCollector(_protocolFeeCollector);     _updateLiquidatorRewardFraction(_liquidatorRewardFraction); }  /**  * @notice used to update the default strategy  * @dev can only be updated by owner  * @param _defaultStrategy address of the updated default strategy  */ function updateDefaultStrategy(address _defaultStrategy) external onlyOwner {     _updateDefaultStrategy(_defaultStrategy); }  function _updateDefaultStrategy(address _defaultStrategy) internal {     defaultStrategy = _defaultStrategy;     emit DefaultStrategyUpdated(_defaultStrategy); }  /**  * @notice used to update the price oracle  * @dev can only be updated by owner  * @param _priceOracle address of the updated price oracle  */ function updatePriceOracle(address _priceOracle) external onlyOwner {     _updatePriceOracle(_priceOracle); }  function _updatePriceOracle(address _priceOracle) internal {     priceOracle = _priceOracle;     emit PriceOracleUpdated(_priceOracle); }  /**  * @notice used to update the savings account address  * @dev can only be updated by owner  * @param _savingsAccount address of the updated savings account  */ function updateSavingsAccount(address _savingsAccount) external onlyOwner {     _updateSavingsAccount(_savingsAccount); }  function _updateSavingsAccount(address _savingsAccount) internal {     savingsAccount = _savingsAccount;     emit SavingsAccountUpdated(_savingsAccount); }  /**  * @notice used to update the protocol fee fraction  * @dev can only be updated by owner  * @param _protocolFee fraction of the borrower amount collected as protocol fee  */ function updateProtocolFeeFraction(uint256 _protocolFee) external onlyOwner {     _updateProtocolFeeFraction(_protocolFee); }  function _updateProtocolFeeFraction(uint256 _protocolFee) internal {     protocolFeeFraction = _protocolFee;     emit ProtocolFeeFractionUpdated(_protocolFee); }  /**  * @notice used to update the protocol fee collector  * @dev can only be updated by owner  * @param _protocolFeeCollector address in which protocol fee is collected  */ function updateProtocolFeeCollector(address _protocolFeeCollector) external onlyOwner {     _updateProtocolFeeCollector(_protocolFeeCollector); }  function _updateProtocolFeeCollector(address _protocolFeeCollector) internal {     require(_protocolFeeCollector != address(0), 'cant be 0 address');     protocolFeeCollector = _protocolFeeCollector;     emit ProtocolFeeCollectorUpdated(_protocolFeeCollector); }  /**  * @notice used to update the strategy registry address  * @dev can only be updated by owner  * @param _strategyRegistry address of the updated strategy registry  */ function updateStrategyRegistry(address _strategyRegistry) external onlyOwner {     _updateStrategyRegistry(_strategyRegistry); }  function _updateStrategyRegistry(address _strategyRegistry) internal {     require(_strategyRegistry != address(0), 'CL::I zero address');     strategyRegistry = _strategyRegistry;     emit StrategyRegistryUpdated(_strategyRegistry); }  /**  * @notice used to update the liquidatorRewardFraction  * @dev can only be updated by owner  * @param _rewardFraction fraction of liquidated amount given to liquidator as reward  */ function updateLiquidatorRewardFraction(uint256 _rewardFraction) external onlyOwner {     _updateLiquidatorRewardFraction(_rewardFraction); }  function _updateLiquidatorRewardFraction(uint256 _rewardFraction) internal {     require(_rewardFraction &lt;= 10**30, 'Fraction has to be less than 1');     liquidatorRewardFraction = _rewardFraction;     emit LiquidationRewardFractionUpdated(_rewardFraction); }  /**  * @dev Used to Calculate Interest Per second on given principal and Interest rate  * @param _principal principal Amount for which interest has to be calculated.  * @param _borrowRate It is the Interest Rate at which Credit Line is approved  * @return interest per second for the given parameters  */ function calculateInterest(     uint256 _principal,     uint256 _borrowRate,     uint256 _timeElapsed ) public pure returns (uint256) {     uint256 _interest = _principal.mul(_borrowRate).mul(_timeElapsed).div(10**30).div(YEAR_IN_SECONDS);      return _interest; }  /**  * @dev Used to calculate interest accrued since last repayment  * @param _id identifier for the credit line  * @return interest accrued over current borrowed amount since last repayment  */  function calculateInterestAccrued(uint256 _id) public view returns (uint256) {     uint256 _lastPrincipalUpdateTime = creditLineVariables[_id].lastPrincipalUpdateTime;     if (_lastPrincipalUpdateTime == 0) return 0;     uint256 _timeElapsed = (block.timestamp).sub(_lastPrincipalUpdateTime);     uint256 _interestAccrued = calculateInterest(creditLineVariables[_id].principal, creditLineConstants[_id].borrowRate, _timeElapsed);     return _interestAccrued; }  /**  * @dev Used to calculate current debt of borrower against a credit line.  * @param _id identifier for the credit line  * @return current debt of borrower  */ function calculateCurrentDebt(uint256 _id) public view returns (uint256) {     uint256 _interestAccrued = calculateInterestAccrued(_id);     uint256 _currentDebt = (creditLineVariables[_id].principal)         .add(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate)         .add(_interestAccrued)         .sub(creditLineVariables[_id].totalInterestRepaid);     return _currentDebt; }  /**  * @notice used to calculate amount that can be borrowed by the borrower  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view.         borrowableAmount changes per block as interest changes per block.  * @param _id identifier for the credit line  * @return amount that can be borrowed from the credit line  */ function calculateBorrowableAmount(uint256 _id) public returns (uint256) {     CreditLineStatus _status = creditLineVariables[_id].status;     require(         _status == CreditLineStatus.ACTIVE || _status == CreditLineStatus.REQUESTED,         'CreditLine: Cannot only if credit line ACTIVE or REQUESTED'     );     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(         creditLineConstants[_id].collateralAsset,         creditLineConstants[_id].borrowAsset     );      uint256 _totalCollateralToken = calculateTotalCollateralTokens(_id);      uint256 _currentDebt = calculateCurrentDebt(_id);      uint256 _maxPossible = _totalCollateralToken.mul(_ratioOfPrices).div(creditLineConstants[_id].idealCollateralRatio).mul(10**30).div(         10**_decimals     );      uint256 _borrowLimit = creditLineConstants[_id].borrowLimit;      if (_maxPossible &gt; _borrowLimit) {         _maxPossible = _borrowLimit;     }     if (_maxPossible &gt; _currentDebt) {         return _maxPossible.sub(_currentDebt);     }     return 0; }  function updateinterestAccruedTillLastPrincipalUpdate(uint256 _id) internal {     require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');      uint256 _interestAccrued = calculateInterestAccrued(_id);     uint256 _newInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(_interestAccrued);     creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _newInterestAccrued; }  function _depositCollateralFromSavingsAccount(     uint256 _id,     uint256 _amount,     address _sender ) internal {     address _collateralAsset = creditLineConstants[_id].collateralAsset;     address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();     ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);     uint256 _activeAmount;      for (uint256 _index = 0; _index &lt; _strategyList.length; _index++) {         address _strategy = _strategyList[_index];         uint256 _liquidityShares = _savingsAccount.balanceInShares(_sender, _collateralAsset, _strategy);         if (_liquidityShares == 0 || _strategyList[_index] == address(0)) {             continue;         }         uint256 _tokenInStrategy = _liquidityShares;         _tokenInStrategy = IYield(_strategy).getTokensForShares(_liquidityShares, _collateralAsset);          uint256 _tokensToTransfer = _tokenInStrategy;         if (_activeAmount.add(_tokenInStrategy) &gt;= _amount) {             _tokensToTransfer = (_amount.sub(_activeAmount));         }         _activeAmount = _activeAmount.add(_tokensToTransfer);         _savingsAccount.transferFrom(_tokensToTransfer, _collateralAsset, _strategy, _sender, address(this));          collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(             _liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy)         );          if (_amount == _activeAmount) {             return;         }     }     revert('CreditLine::_depositCollateralFromSavingsAccount - Insufficient balance'); }  /**  * @notice used to request a credit line either by borrower or lender  * @param _requestTo Address to which creditLine is requested,                      if borrower creates request then lender address and                      if lender creates then borrower address  * @param _borrowLimit maximum borrow amount in a credit line  * @param _borrowRate Interest Rate at which credit Line is requested  * @param _autoLiquidation if true, anyone can liquidate loan, otherwise only lender  * @param _collateralRatio ratio of the collateral to the debt below which credit line can be liquidated  * @param _borrowAsset address of the token to be borrowed  * @param _collateralAsset address of the token provided as collateral  * @param _requestAsLender if true, lender is placing request, otherwise borrower  * @return identifier for the credit line  */  function request(     address _requestTo,     uint256 _borrowLimit,     uint256 _borrowRate,     bool _autoLiquidation,     uint256 _collateralRatio,     address _borrowAsset,     address _collateralAsset,     bool _requestAsLender ) external returns (uint256) {     require(_borrowAsset != _collateralAsset, 'R: cant borrow lent token');     require(IPriceOracle(priceOracle).doesFeedExist(_borrowAsset, _collateralAsset), 'R: No price feed');      address _lender = _requestTo;     address _borrower = msg.sender;     if (_requestAsLender) {         _lender = msg.sender;         _borrower = _requestTo;     }      uint256 _id = _createRequest(         _lender,         _borrower,         _borrowLimit,         _borrowRate,         _autoLiquidation,         _collateralRatio,         _borrowAsset,         _collateralAsset,         _requestAsLender     );      emit CreditLineRequested(_id, _lender, _borrower);     return _id; }  function _createRequest(     address _lender,     address _borrower,     uint256 _borrowLimit,     uint256 _borrowRate,     bool _autoLiquidation,     uint256 _collateralRatio,     address _borrowAsset,     address _collateralAsset,     bool _requestByLender ) internal returns (uint256) {     require(_lender != _borrower, 'Lender and Borrower cannot be same addresses');     uint256 _id = creditLineCounter + 1;     creditLineCounter = _id;     creditLineVariables[_id].status = CreditLineStatus.REQUESTED;     creditLineConstants[_id].borrower = _borrower;     creditLineConstants[_id].lender = _lender;     creditLineConstants[_id].borrowLimit = _borrowLimit;     creditLineConstants[_id].autoLiquidation = _autoLiquidation;     creditLineConstants[_id].idealCollateralRatio = _collateralRatio;     creditLineConstants[_id].borrowRate = _borrowRate;     creditLineConstants[_id].borrowAsset = _borrowAsset;     creditLineConstants[_id].collateralAsset = _collateralAsset;     creditLineConstants[_id].requestByLender = _requestByLender;     return _id; }  /**  * @notice used to accept a credit line  * @dev if borrower places request, lender can accept and vice versa  * @param _id identifier for the credit line  */ function accept(uint256 _id) external {     require(         creditLineVariables[_id].status == CreditLineStatus.REQUESTED,         'CreditLine::acceptCreditLineLender - CreditLine is already accepted'     );     bool _requestByLender = creditLineConstants[_id].requestByLender;     require(         (msg.sender == creditLineConstants[_id].borrower &amp;&amp; _requestByLender) ||             (msg.sender == creditLineConstants[_id].lender &amp;&amp; !_requestByLender),         "Only Borrower or Lender who hasn't requested can accept"     );     creditLineVariables[_id].status = CreditLineStatus.ACTIVE;     emit CreditLineAccepted(_id); }  /**  * @notice used to deposit collateral into the credit line  * @dev collateral tokens have to be approved in savingsAccount or token contract(unless ether).         If transferred from savings account, the tokens are transferred from strategies in the          order prespecified in strategy registry  * @param _id identifier for the credit line  * @param _amount amount of collateral being deposited  * @param _strategy strategy to which collateral is to be deposited in case transfer is not from savings account  * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount                              otherwise direct from collateral token contract  */ function depositCollateral(     uint256 _id,     uint256 _amount,     address _strategy,     bool _fromSavingsAccount ) external payable nonReentrant ifCreditLineExists(_id) {     require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine not active');     _depositCollateral(_id, _amount, _strategy, _fromSavingsAccount);     emit CollateralDeposited(_id, _amount, _strategy); }  function _depositCollateral(     uint256 _id,     uint256 _amount,     address _strategy,     bool _fromSavingsAccount ) internal {     require(creditLineConstants[_id].lender != msg.sender, 'lender cant deposit collateral');     if (_fromSavingsAccount) {         _depositCollateralFromSavingsAccount(_id, _amount, msg.sender);     } else {         address _collateralAsset = creditLineConstants[_id].collateralAsset;         ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);         if (_collateralAsset == address(0)) {             require(msg.value == _amount, "CreditLine::_depositCollateral - value to transfer doesn't match argument");         } else {             IERC20(_collateralAsset).safeTransferFrom(msg.sender, address(this), _amount);             IERC20(_collateralAsset).approve(_strategy, _amount);         }         uint256 _sharesReceived = _savingsAccount.deposit{value: msg.value}(_amount, _collateralAsset, _strategy, address(this));         collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(_sharesReceived);     } }  function _withdrawBorrowAmount(     address _asset,     uint256 _amountInTokens,     address _lender ) internal {     address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();     ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);     uint256 _activeAmount;     for (uint256 _index = 0; _index &lt; _strategyList.length; _index++) {         if (_strategyList[_index] == address(0)) {             continue;         }         uint256 _liquidityShares = _savingsAccount.balanceInShares(_lender, _asset, _strategyList[_index]);         if (_liquidityShares != 0) {             uint256 tokenInStrategy = _liquidityShares;             tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);             uint256 _tokensToTransfer = tokenInStrategy;             if (_activeAmount.add(tokenInStrategy) &gt;= _amountInTokens) {                 _tokensToTransfer = (_amountInTokens.sub(_activeAmount));             }             _activeAmount = _activeAmount.add(_tokensToTransfer);             _savingsAccount.withdrawFrom(_tokensToTransfer, _asset, _strategyList[_index], _lender, address(this), false);             if (_activeAmount == _amountInTokens) {                 return;             }         }     }     require(_activeAmount == _amountInTokens, 'insufficient balance'); }  /**  * @notice used to borrow tokens from credit line by borrower  * @dev only borrower can call this function. Amount that can actually be borrowed is          min(amount based on borrowLimit, allowance to creditLine contract, balance of lender)  * @param _id identifier for the credit line  * @param _amount amount of tokens to borrow  */ function borrow(uint256 _id, uint256 _amount) external payable nonReentrant onlyCreditLineBorrower(_id) {     require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');     uint256 _borrowableAmount = calculateBorrowableAmount(_id);     require(_amount &lt;= _borrowableAmount, "CreditLine::borrow - The current collateral ratio doesn't allow to withdraw the amount");     address _borrowAsset = creditLineConstants[_id].borrowAsset;     address _lender = creditLineConstants[_id].lender;      updateinterestAccruedTillLastPrincipalUpdate(_id);     creditLineVariables[_id].principal = creditLineVariables[_id].principal.add(_amount);     creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;      uint256 _tokenDiffBalance;     if (_borrowAsset != address(0)) {         uint256 _balanceBefore = IERC20(_borrowAsset).balanceOf(address(this));         _withdrawBorrowAmount(_borrowAsset, _amount, _lender);         uint256 _balanceAfter = IERC20(_borrowAsset).balanceOf(address(this));         _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);     } else {         uint256 _balanceBefore = address(this).balance;         _withdrawBorrowAmount(_borrowAsset, _amount, _lender);         uint256 _balanceAfter = address(this).balance;         _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);     }     uint256 _protocolFee = _tokenDiffBalance.mul(protocolFeeFraction).div(10**30);     _tokenDiffBalance = _tokenDiffBalance.sub(_protocolFee);      if (_borrowAsset == address(0)) {         (bool feeSuccess, ) = protocolFeeCollector.call{value: _protocolFee}('');         require(feeSuccess, 'Transfer fail');         (bool success, ) = msg.sender.call{value: _tokenDiffBalance}('');         require(success, 'Transfer fail');     } else {         IERC20(_borrowAsset).safeTransfer(protocolFeeCollector, _protocolFee);         IERC20(_borrowAsset).safeTransfer(msg.sender, _tokenDiffBalance);     }     emit BorrowedFromCreditLine(_id, _tokenDiffBalance); }  function _repayFromSavingsAccount(     uint256 _amount,     address _asset,     address _lender ) internal {     address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();     ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);     uint256 _activeAmount;      for (uint256 _index = 0; _index &lt; _strategyList.length; _index++) {         if (_strategyList[_index] == address(0)) {             continue;         }         uint256 _liquidityShares = _savingsAccount.balanceInShares(msg.sender, _asset, _strategyList[_index]);         if (_liquidityShares == 0) {             continue;         }         uint256 _tokenInStrategy = _liquidityShares;         _tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);          uint256 _tokensToTransfer = _tokenInStrategy;         if (_activeAmount.add(_tokenInStrategy) &gt;= _amount) {             _tokensToTransfer = (_amount.sub(_activeAmount));         }         _activeAmount = _activeAmount.add(_tokensToTransfer);         _savingsAccount.transferFrom(_tokensToTransfer, _asset, _strategyList[_index], msg.sender, _lender);          if (_amount == _activeAmount) {             return;         }     }     revert('CreditLine::_repayFromSavingsAccount - Insufficient balance'); }  function _repay(     uint256 _id,     uint256 _amount,     bool _fromSavingsAccount,     uint256 _principalPaid ) internal {     ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);     address _defaultStrategy = defaultStrategy;     address _borrowAsset = creditLineConstants[_id].borrowAsset;     address _lender = creditLineConstants[_id].lender;     if (!_fromSavingsAccount) {         if (_borrowAsset == address(0)) {             require(msg.value == _amount, 'creditLine::repay - Ether sent not equal to repay amount');             _savingsAccount.deposit{value: _amount}(_amount, _borrowAsset, _defaultStrategy, _lender);         } else {             IERC20(_borrowAsset).safeTransferFrom(msg.sender, address(this), _amount);             IERC20(_borrowAsset).approve(_defaultStrategy, _amount);             _savingsAccount.deposit(_amount, _borrowAsset, _defaultStrategy, _lender);         }     } else {         _repayFromSavingsAccount(_amount, _borrowAsset, _lender);     }     if (_principalPaid != 0) {         _savingsAccount.increaseAllowanceToCreditLine(_principalPaid, _borrowAsset, _lender);     } }  /**  * @notice used to repay interest and principal to credit line. Interest has to be repaid before repaying principal  * @dev partial repayments possible  * @param _id identifier for the credit line  * @param _amount amount being repaid  * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount                              otherwise direct from collateral token contract  */ function repay(     uint256 _id,     uint256 _amount,     bool _fromSavingsAccount ) external payable nonReentrant {     require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');     require(creditLineConstants[_id].lender != msg.sender, 'Lender cant repay');      uint256 _interestSincePrincipalUpdate = calculateInterestAccrued(_id);     uint256 _totalInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(         _interestSincePrincipalUpdate     );     uint256 _interestToPay = _totalInterestAccrued.sub(creditLineVariables[_id].totalInterestRepaid);     uint256 _totalCurrentDebt = _interestToPay.add(creditLineVariables[_id].principal);     uint256 _principalPaid = 0;      if (_amount &gt;= _totalCurrentDebt) {         _amount = _totalCurrentDebt;         emit CompleteCreditLineRepaid(_id, _amount);     } else {         emit PartialCreditLineRepaid(_id, _amount);     }      if (_amount &gt; _interestToPay) {         creditLineVariables[_id].principal = _totalCurrentDebt.sub(_amount);         creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _totalInterestAccrued;         creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;         creditLineVariables[_id].totalInterestRepaid = _totalInterestAccrued;         _principalPaid = _amount.sub(_interestToPay);     } else {         creditLineVariables[_id].totalInterestRepaid = creditLineVariables[_id].totalInterestRepaid.add(_amount);     }      _repay(_id, _amount, _fromSavingsAccount, _principalPaid);      if (creditLineVariables[_id].principal == 0) {         _resetCreditLine(_id);     } }  function _resetCreditLine(uint256 _id) internal {     creditLineVariables[_id].lastPrincipalUpdateTime = 0;     creditLineVariables[_id].totalInterestRepaid = 0;     creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = 0;     emit CreditLineReset(_id); }  /**  * @dev used to close credit line by borrower or lender  * @param _id identifier for the credit line  */ function close(uint256 _id) external ifCreditLineExists(_id) {     require(         msg.sender == creditLineConstants[_id].borrower || msg.sender == creditLineConstants[_id].lender,         'CreditLine: Permission denied while closing Line of credit'     );     require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: Credit line should be active.');     require(creditLineVariables[_id].principal == 0, 'CreditLine: Cannot be closed since not repaid.');     require(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate == 0, 'CreditLine: Cannot be closed since not repaid.');     creditLineVariables[_id].status = CreditLineStatus.CLOSED;     emit CreditLineClosed(_id); }  /**  * @notice used to calculate the current collateral ratio  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view.         Interest is also considered while calculating debt  * @param _id identifier for the credit line  * @return collateral ratio multiplied by 10**30 to retain precision  */ function calculateCurrentCollateralRatio(uint256 _id) public ifCreditLineExists(_id) returns (uint256) {     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(         creditLineConstants[_id].collateralAsset,         creditLineConstants[_id].borrowAsset     );      uint256 currentDebt = calculateCurrentDebt(_id);     uint256 currentCollateralRatio = calculateTotalCollateralTokens(_id).mul(_ratioOfPrices).div(currentDebt).mul(10**30).div(         10**_decimals     );      return currentCollateralRatio; }  /**  * @notice used to calculate the total collateral tokens  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view  * @param _id identifier for the credit line  * @return _amount total collateral tokens deposited into the credit line  */ function calculateTotalCollateralTokens(uint256 _id) public returns (uint256 _amount) {     address _collateralAsset = creditLineConstants[_id].collateralAsset;     address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();     uint256 _liquidityShares;     for (uint256 index = 0; index &lt; _strategyList.length; index++) {         if (_strategyList[index] == address(0)) {             continue;         }         _liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];         uint256 _tokenInStrategy = _liquidityShares;         _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(_liquidityShares, _collateralAsset);          _amount = _amount.add(_tokenInStrategy);     } }  /**  * @notice used to withdraw any excess collateral  * @dev collateral can't be withdraw if collateralRatio goes below the ideal value. Only borrower can withdraw  * @param _id identifier for the credit line  * @param _amount amount of collateral to withdraw  * @param _toSavingsAccount if true, tokens are transferred from savingsAccount                              otherwise direct from collateral token contract  */ function withdrawCollateral(     uint256 _id,     uint256 _amount,     bool _toSavingsAccount ) external nonReentrant onlyCreditLineBorrower(_id) {     uint256 _withdrawableCollateral = withdrawableCollateral(_id);     require(_amount &lt;= _withdrawableCollateral, 'Collateral ratio cant go below ideal');     address _collateralAsset = creditLineConstants[_id].collateralAsset;     _transferCollateral(_id, _collateralAsset, _amount, _toSavingsAccount);     emit CollateralWithdrawn(_id, _amount); }  /**  * @notice used to calculate the collateral that can be withdrawn  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view  * @param _id identifier for the credit line  * @return total collateral withdrawable by borrower  */ function withdrawableCollateral(uint256 _id) public returns (uint256) {     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(         creditLineConstants[_id].collateralAsset,         creditLineConstants[_id].borrowAsset     );      uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);     uint256 _currentDebt = calculateCurrentDebt(_id);      uint256 _collateralNeeded = _currentDebt         .mul(creditLineConstants[_id].idealCollateralRatio)         .div(_ratioOfPrices)         .mul(10**_decimals)         .div(10**30);      if (_collateralNeeded &gt;= _totalCollateralTokens) {         return 0;     }     return _totalCollateralTokens.sub(_collateralNeeded); }  function _transferCollateral(     uint256 _id,     address _asset,     uint256 _amountInTokens,     bool _toSavingsAccount ) internal {     address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();     uint256 _activeAmount;     for (uint256 index = 0; index &lt; _strategyList.length; index++) {         uint256 liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];         if (liquidityShares == 0 || _strategyList[index] == address(0)) {             continue;         }         uint256 _tokenInStrategy = liquidityShares;         _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(liquidityShares, _asset);         uint256 _tokensToTransfer = _tokenInStrategy;         if (_activeAmount.add(_tokenInStrategy) &gt; _amountInTokens) {             _tokensToTransfer = _amountInTokens.sub(_activeAmount);             liquidityShares = liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy);         }         _activeAmount = _activeAmount.add(_tokensToTransfer);         collateralShareInStrategy[_id][_strategyList[index]] = collateralShareInStrategy[_id][_strategyList[index]].sub(             liquidityShares         );         if (_toSavingsAccount) {             ISavingsAccount(savingsAccount).transfer(_tokensToTransfer, _asset, _strategyList[index], msg.sender);         } else {             ISavingsAccount(savingsAccount).withdraw(_tokensToTransfer, _asset, _strategyList[index], msg.sender, false);         }          if (_activeAmount == _amountInTokens) {             return;         }     }     revert('insufficient collateral'); }  /**  * @notice used to liquidate credit line in case collateral ratio goes below the threshold  * @dev if lender liquidates, then collateral is directly transferred.          If autoLiquidation is true, anyone can liquidate by providing enough borrow tokens  * @param _id identifier for the credit line  * @param _toSavingsAccount if true, tokens are transferred from savingsAccount                              otherwise direct from collateral token contract  */ function liquidate(uint256 _id, bool _toSavingsAccount) external payable nonReentrant {     require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: Credit line should be active.');     require(creditLineVariables[_id].principal != 0, 'CreditLine: cannot liquidate if principal is 0');      uint256 currentCollateralRatio = calculateCurrentCollateralRatio(_id);     require(         currentCollateralRatio &lt; creditLineConstants[_id].idealCollateralRatio,         'CreditLine: Collateral ratio is higher than ideal value'     );      address _collateralAsset = creditLineConstants[_id].collateralAsset;     address _lender = creditLineConstants[_id].lender;     uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);     address _borrowAsset = creditLineConstants[_id].borrowAsset;      creditLineVariables[_id].status = CreditLineStatus.LIQUIDATED;      if (creditLineConstants[_id].autoLiquidation &amp;&amp; _lender != msg.sender) {         uint256 _borrowTokens = _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens);         if (_borrowAsset == address(0)) {             uint256 _returnETH = msg.value.sub(_borrowTokens, 'Insufficient ETH to liquidate');             if (_returnETH != 0) {                 (bool success, ) = msg.sender.call{value: _returnETH}('');                 require(success, 'Transfer fail');             }         } else {             IERC20(_borrowAsset).safeTransferFrom(msg.sender, _lender, _borrowTokens);         }     }      _transferCollateral(_id, _collateralAsset, _totalCollateralTokens, _toSavingsAccount);      emit CreditLineLiquidated(_id, msg.sender); }  /**  * @notice used to calculate the borrow tokens necessary for liquidator to liquidate  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view  * @param _id identifier for the credit line  * @return borrow tokens necessary for liquidator to liquidate  */ function borrowTokensToLiquidate(uint256 _id) external returns (uint256) {     address _collateralAsset = creditLineConstants[_id].collateralAsset;     uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);     address _borrowAsset = creditLineConstants[_id].borrowAsset;      return _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens); }  function _borrowTokensToLiquidate(     address _borrowAsset,     address _collateralAsset,     uint256 _totalCollateralTokens ) internal view returns (uint256) {     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(_borrowAsset, _collateralAsset);     uint256 _borrowTokens = (         _totalCollateralTokens.mul(uint256(10**30).sub(liquidatorRewardFraction)).div(10**30).mul(_ratioOfPrices).div(10**_decimals)     );      return _borrowTokens; }  receive() external payable {     require(msg.sender == savingsAccount, 'CreditLine::receive invalid transaction'); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-22-08 11:43:25 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/utils/ReentrancyGuard.sol';
import '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';
import '../interfaces/IPriceOracle.sol';
import '../interfaces/IYield.sol';
import '../interfaces/ISavingsAccount.sol';
import '../SavingsAccount/SavingsAccountUtil.sol';
import '../interfaces/IStrategyRegistry.sol';

/**
 * @title Credit Line contract with Methods related to credit Line
 * @notice Implements the functions related to Credit Line
 * @author Sublime
 **/

contract CreditLine is ReentrancyGuard, OwnableUpgradeable {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    enum CreditLineStatus {
        NOT_CREATED,
        REQUESTED,
        ACTIVE,
        CLOSED,
        CANCELLED,
        LIQUIDATED
    }

    /**
     * @notice counter that tracks the number of credit lines created
     * @dev used to create unique identifier for credit lines
     **/
    uint256 public creditLineCounter;

    uint256 constant YEAR_IN_SECONDS = 365 days;

    struct CreditLineVariables {
        CreditLineStatus status;
        uint256 principal;
        uint256 totalInterestRepaid;
        uint256 lastPrincipalUpdateTime;
        uint256 interestAccruedTillLastPrincipalUpdate;
    }

    struct CreditLineConstants {
        address lender;
        address borrower;
        uint256 borrowLimit;
        uint256 idealCollateralRatio;
        uint256 borrowRate;
        address borrowAsset;
        address collateralAsset;
        bool autoLiquidation;
        bool requestByLender;
    }
    /**
     * @notice stores the collateral shares in a credit line per strategy
     * @dev creditLineId => Strategy => collateralShares
     **/
    mapping(uint256 => mapping(address => uint256)) public collateralShareInStrategy;

    /**
     * @notice stores the variables to maintain a credit line
     **/
    mapping(uint256 => CreditLineVariables) public creditLineVariables;

    /**
     * @notice stores the constants related to a credit line
     **/
    mapping(uint256 => CreditLineConstants) public creditLineConstants;

    /**
     * @notice stores the address of savings account contract
     **/
    address public savingsAccount;

    /**
     * @notice stores the address of price oracle contract
     **/
    address public priceOracle;

    /**
     * @notice stores the address of strategy registry contract
     **/
    address public strategyRegistry;

    /**
     * @notice stores the address of default strategy
     **/
    address public defaultStrategy;

    /**
     * @notice stores the fraction of borrowed amount charged as fee by protocol
     * @dev it is multiplied by 10**30
     **/
    uint256 public protocolFeeFraction;

    /**
     * @notice address where protocol fee is collected
     **/
    address public protocolFeeCollector;

    /**
     * @notice stores the fraction of amount liquidated given as reward to liquidator
     * @dev it is multiplied by 10**30
     **/
    uint256 public liquidatorRewardFraction;
    /**
     * @dev checks if Credit Line exists
     * @param _id identifier for the credit line
     **/
    modifier ifCreditLineExists(uint256 _id) {
        require(creditLineVariables[_id].status != CreditLineStatus.NOT_CREATED, 'Credit line does not exist');
        _;
    }

    /**
     * @dev checks if called by credit Line Borrower
     * @param _id creditLine identifier
     **/
    modifier onlyCreditLineBorrower(uint256 _id) {
        require(creditLineConstants[_id].borrower == msg.sender, 'Only credit line Borrower can access');
        _;
    }

    /**
     * @dev checks if called by credit Line Lender
     * @param _id creditLine identifier
     **/
    modifier onlyCreditLineLender(uint256 _id) {
        require(creditLineConstants[_id].lender == msg.sender, 'Only credit line Lender can access');
        _;
    }

    /**
     * @notice emitted when a collateral is deposited into credit line
     * @param id id of the credit line
     * @param amount amount of collateral deposited
     * @param strategy address of the strategy into which collateral is deposited
     */
    event CollateralDeposited(uint256 indexed id, uint256 amount, address indexed strategy);

    /**
     * @notice emitted when collateral is withdrawn from credit line
     * @param id id of the credit line
     * @param amount amount of collateral withdrawn
     */
    event CollateralWithdrawn(uint256 indexed id, uint256 amount);

    /**
     * @notice emitted when a request for new credit line is placed
     * @param id id of the credit line for which request was made
     * @param lender address of the lender for credit line
     * @param borrower address of the borrower for credit line
     */
    event CreditLineRequested(uint256 indexed id, address indexed lender, address indexed borrower);

    /**
     * @notice emitted when a credit line is liquidated
     * @param id id of the credit line which is liquidated
     * @param liquidator address of the liquidator
     */
    event CreditLineLiquidated(uint256 indexed id, address indexed liquidator);

    /**
     * @notice emitted when tokens are borrowed from credit line
     * @param id id of the credit line from which tokens are borrowed
     * @param borrowAmount amount of tokens borrowed
     */
    event BorrowedFromCreditLine(uint256 indexed id, uint256 borrowAmount);

    /**
     * @notice emitted when credit line is accepted
     * @param id id of the credit line that was accepted
     */
    event CreditLineAccepted(uint256 indexed id);

    /**
     * @notice emitted when credit line is completely repaid and reset
     * @param id id of the credit line that is reset
     */
    event CreditLineReset(uint256 indexed id);

    /**
     * @notice emitted when the credit line is partially repaid
     * @param id id of the credit line
     * @param repayAmount amount repaid
     */
    event PartialCreditLineRepaid(uint256 indexed id, uint256 repayAmount);

    /**
     * @notice emitted when the credit line is completely repaid
     * @param id id of the credit line
     * @param repayAmount amount repaid
     */
    event CompleteCreditLineRepaid(uint256 indexed id, uint256 repayAmount);

    /**
     * @notice emitted when the credit line is closed by one of the parties of credit line
     * @param id id of the credit line
     */
    event CreditLineClosed(uint256 indexed id);

    /**
     * @notice emitted when default strategy for the credit line is updated
     * @param defaultStrategy address of the strategy contract that is used as default by credit lines
     */
    event DefaultStrategyUpdated(address indexed defaultStrategy);

    /**
     * @notice emitted when the price oracle is updated
     * @param priceOracle address of the updated price oracle
     */
    event PriceOracleUpdated(address indexed priceOracle);

    /**
     * @notice emitted when the savings account address is updated
     * @param savingsAccount address of the updated savingsAccount
     */
    event SavingsAccountUpdated(address indexed savingsAccount);

    /**
     * @notice emitted when strategy registry address is updated
     * @param strategyRegistry address of the updated strategy registry
     */
    event StrategyRegistryUpdated(address indexed strategyRegistry);

    /**
     * @notice emitted when fee that protocol charges for credit line is updated
     * @param updatedProtocolFee updated value of protocolFeeFraction
     */
    event ProtocolFeeFractionUpdated(uint256 updatedProtocolFee);

    /**
     * @notice emitted when address which receives fee that protocol changes for pools is updated
     * @param updatedProtocolFeeCollector updated value of protocolFeeCollector
     */
    event ProtocolFeeCollectorUpdated(address indexed updatedProtocolFeeCollector);

    /**
     * @notice emitted when liquidatorRewardFraction is updated
     * @param liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator
     */
    event LiquidationRewardFractionUpdated(uint256 liquidatorRewardFraction);

    /**
     * @notice used to initialize the contract
     * @dev can only be called once during the life cycle of the contract
     * @param _defaultStrategy default strategy used in credit lines
     * @param _priceOracle address of the priceOracle
     * @param _savingsAccount address of  the savings account contract
     * @param _strategyRegistry address of the strategy registry contract
     * @param _owner address of owner who can change global variables
     * @param _protocolFeeFraction fraction of the fee charged by protocol
     * @param _protocolFeeCollector address to which protocol fee is charged to
     * @param _liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator
     */
    function initialize(
        address _defaultStrategy,
        address _priceOracle,
        address _savingsAccount,
        address _strategyRegistry,
        address _owner,
        uint256 _protocolFeeFraction,
        address _protocolFeeCollector,
        uint256 _liquidatorRewardFraction
    ) external initializer {
        OwnableUpgradeable.__Ownable_init();
        OwnableUpgradeable.transferOwnership(_owner);

        _updateDefaultStrategy(_defaultStrategy);
        _updatePriceOracle(_priceOracle);
        _updateSavingsAccount(_savingsAccount);
        _updateStrategyRegistry(_strategyRegistry);
        _updateProtocolFeeFraction(_protocolFeeFraction);
        _updateProtocolFeeCollector(_protocolFeeCollector);
        _updateLiquidatorRewardFraction(_liquidatorRewardFraction);
    }

    /**
     * @notice used to update the default strategy
     * @dev can only be updated by owner
     * @param _defaultStrategy address of the updated default strategy
     */
    function updateDefaultStrategy(address _defaultStrategy) external onlyOwner {
        _updateDefaultStrategy(_defaultStrategy);
    }

    function _updateDefaultStrategy(address _defaultStrategy) internal {
        defaultStrategy = _defaultStrategy;
        emit DefaultStrategyUpdated(_defaultStrategy);
    }

    /**
     * @notice used to update the price oracle
     * @dev can only be updated by owner
     * @param _priceOracle address of the updated price oracle
     */
    function updatePriceOracle(address _priceOracle) external onlyOwner {
        _updatePriceOracle(_priceOracle);
    }

    function _updatePriceOracle(address _priceOracle) internal {
        priceOracle = _priceOracle;
        emit PriceOracleUpdated(_priceOracle);
    }

    /**
     * @notice used to update the savings account address
     * @dev can only be updated by owner
     * @param _savingsAccount address of the updated savings account
     */
    function updateSavingsAccount(address _savingsAccount) external onlyOwner {
        _updateSavingsAccount(_savingsAccount);
    }

    function _updateSavingsAccount(address _savingsAccount) internal {
        savingsAccount = _savingsAccount;
        emit SavingsAccountUpdated(_savingsAccount);
    }

    /**
     * @notice used to update the protocol fee fraction
     * @dev can only be updated by owner
     * @param _protocolFee fraction of the borrower amount collected as protocol fee
     */
    function updateProtocolFeeFraction(uint256 _protocolFee) external onlyOwner {
        _updateProtocolFeeFraction(_protocolFee);
    }

    function _updateProtocolFeeFraction(uint256 _protocolFee) internal {
        protocolFeeFraction = _protocolFee;
        emit ProtocolFeeFractionUpdated(_protocolFee);
    }

    /**
     * @notice used to update the protocol fee collector
     * @dev can only be updated by owner
     * @param _protocolFeeCollector address in which protocol fee is collected
     */
    function updateProtocolFeeCollector(address _protocolFeeCollector) external onlyOwner {
        _updateProtocolFeeCollector(_protocolFeeCollector);
    }

    function _updateProtocolFeeCollector(address _protocolFeeCollector) internal {
        require(_protocolFeeCollector != address(0), 'cant be 0 address');
        protocolFeeCollector = _protocolFeeCollector;
        emit ProtocolFeeCollectorUpdated(_protocolFeeCollector);
    }

    /**
     * @notice used to update the strategy registry address
     * @dev can only be updated by owner
     * @param _strategyRegistry address of the updated strategy registry
     */
    function updateStrategyRegistry(address _strategyRegistry) external onlyOwner {
        _updateStrategyRegistry(_strategyRegistry);
    }

    function _updateStrategyRegistry(address _strategyRegistry) internal {
        require(_strategyRegistry != address(0), 'CL::I zero address');
        strategyRegistry = _strategyRegistry;
        emit StrategyRegistryUpdated(_strategyRegistry);
    }

    /**
     * @notice used to update the liquidatorRewardFraction
     * @dev can only be updated by owner
     * @param _rewardFraction fraction of liquidated amount given to liquidator as reward
     */
    function updateLiquidatorRewardFraction(uint256 _rewardFraction) external onlyOwner {
        _updateLiquidatorRewardFraction(_rewardFraction);
    }

    function _updateLiquidatorRewardFraction(uint256 _rewardFraction) internal {
        require(_rewardFraction <= 10**30, 'Fraction has to be less than 1');
        liquidatorRewardFraction = _rewardFraction;
        emit LiquidationRewardFractionUpdated(_rewardFraction);
    }

    /**
     * @dev Used to Calculate Interest Per second on given principal and Interest rate
     * @param _principal principal Amount for which interest has to be calculated.
     * @param _borrowRate It is the Interest Rate at which Credit Line is approved
     * @return interest per second for the given parameters
     */
    function calculateInterest(
        uint256 _principal,
        uint256 _borrowRate,
        uint256 _timeElapsed
    ) public pure returns (uint256) {
        uint256 _interest = _principal.mul(_borrowRate).mul(_timeElapsed).div(10**30).div(YEAR_IN_SECONDS);

        return _interest;
    }

    /**
     * @dev Used to calculate interest accrued since last repayment
     * @param _id identifier for the credit line
     * @return interest accrued over current borrowed amount since last repayment
     */

    function calculateInterestAccrued(uint256 _id) public view returns (uint256) {
        uint256 _lastPrincipalUpdateTime = creditLineVariables[_id].lastPrincipalUpdateTime;
        if (_lastPrincipalUpdateTime == 0) return 0;
        uint256 _timeElapsed = (block.timestamp).sub(_lastPrincipalUpdateTime);
        uint256 _interestAccrued = calculateInterest(creditLineVariables[_id].principal, creditLineConstants[_id].borrowRate, _timeElapsed);
        return _interestAccrued;
    }

    /**
     * @dev Used to calculate current debt of borrower against a credit line.
     * @param _id identifier for the credit line
     * @return current debt of borrower
     */
    function calculateCurrentDebt(uint256 _id) public view returns (uint256) {
        uint256 _interestAccrued = calculateInterestAccrued(_id);
        uint256 _currentDebt = (creditLineVariables[_id].principal)
            .add(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate)
            .add(_interestAccrued)
            .sub(creditLineVariables[_id].totalInterestRepaid);
        return _currentDebt;
    }

    /**
     * @notice used to calculate amount that can be borrowed by the borrower
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view.
            borrowableAmount changes per block as interest changes per block.
     * @param _id identifier for the credit line
     * @return amount that can be borrowed from the credit line
     */
    function calculateBorrowableAmount(uint256 _id) public returns (uint256) {
        CreditLineStatus _status = creditLineVariables[_id].status;
        require(
            _status == CreditLineStatus.ACTIVE || _status == CreditLineStatus.REQUESTED,
            'CreditLine: Cannot only if credit line ACTIVE or REQUESTED'
        );
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(
            creditLineConstants[_id].collateralAsset,
            creditLineConstants[_id].borrowAsset
        );

        uint256 _totalCollateralToken = calculateTotalCollateralTokens(_id);

        uint256 _currentDebt = calculateCurrentDebt(_id);

        uint256 _maxPossible = _totalCollateralToken.mul(_ratioOfPrices).div(creditLineConstants[_id].idealCollateralRatio).mul(10**30).div(
            10**_decimals
        );

        uint256 _borrowLimit = creditLineConstants[_id].borrowLimit;

        if (_maxPossible > _borrowLimit) {
            _maxPossible = _borrowLimit;
        }
        if (_maxPossible > _currentDebt) {
            return _maxPossible.sub(_currentDebt);
        }
        return 0;
    }

    function updateinterestAccruedTillLastPrincipalUpdate(uint256 _id) internal {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');

        uint256 _interestAccrued = calculateInterestAccrued(_id);
        uint256 _newInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(_interestAccrued);
        creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _newInterestAccrued;
    }

    function _depositCollateralFromSavingsAccount(
        uint256 _id,
        uint256 _amount,
        address _sender
    ) internal {
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        uint256 _activeAmount;

        for (uint256 _index = 0; _index < _strategyList.length; _index++) {
            address _strategy = _strategyList[_index];
            uint256 _liquidityShares = _savingsAccount.balanceInShares(_sender, _collateralAsset, _strategy);
            if (_liquidityShares == 0 || _strategyList[_index] == address(0)) {
                continue;
            }
            uint256 _tokenInStrategy = _liquidityShares;
            _tokenInStrategy = IYield(_strategy).getTokensForShares(_liquidityShares, _collateralAsset);

            uint256 _tokensToTransfer = _tokenInStrategy;
            if (_activeAmount.add(_tokenInStrategy) >= _amount) {
                _tokensToTransfer = (_amount.sub(_activeAmount));
            }
            _activeAmount = _activeAmount.add(_tokensToTransfer);
            _savingsAccount.transferFrom(_tokensToTransfer, _collateralAsset, _strategy, _sender, address(this));

            collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(
                _liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy)
            );

            if (_amount == _activeAmount) {
                return;
            }
        }
        revert('CreditLine::_depositCollateralFromSavingsAccount - Insufficient balance');
    }

    /**
     * @notice used to request a credit line either by borrower or lender
     * @param _requestTo Address to which creditLine is requested, 
                        if borrower creates request then lender address and 
                        if lender creates then borrower address
     * @param _borrowLimit maximum borrow amount in a credit line
     * @param _borrowRate Interest Rate at which credit Line is requested
     * @param _autoLiquidation if true, anyone can liquidate loan, otherwise only lender
     * @param _collateralRatio ratio of the collateral to the debt below which credit line can be liquidated
     * @param _borrowAsset address of the token to be borrowed
     * @param _collateralAsset address of the token provided as collateral
     * @param _requestAsLender if true, lender is placing request, otherwise borrower
     * @return identifier for the credit line
     */

    function request(
        address _requestTo,
        uint256 _borrowLimit,
        uint256 _borrowRate,
        bool _autoLiquidation,
        uint256 _collateralRatio,
        address _borrowAsset,
        address _collateralAsset,
        bool _requestAsLender
    ) external returns (uint256) {
        require(_borrowAsset != _collateralAsset, 'R: cant borrow lent token');
        require(IPriceOracle(priceOracle).doesFeedExist(_borrowAsset, _collateralAsset), 'R: No price feed');

        address _lender = _requestTo;
        address _borrower = msg.sender;
        if (_requestAsLender) {
            _lender = msg.sender;
            _borrower = _requestTo;
        }

        uint256 _id = _createRequest(
            _lender,
            _borrower,
            _borrowLimit,
            _borrowRate,
            _autoLiquidation,
            _collateralRatio,
            _borrowAsset,
            _collateralAsset,
            _requestAsLender
        );

        emit CreditLineRequested(_id, _lender, _borrower);
        return _id;
    }

    function _createRequest(
        address _lender,
        address _borrower,
        uint256 _borrowLimit,
        uint256 _borrowRate,
        bool _autoLiquidation,
        uint256 _collateralRatio,
        address _borrowAsset,
        address _collateralAsset,
        bool _requestByLender
    ) internal returns (uint256) {
        require(_lender != _borrower, 'Lender and Borrower cannot be same addresses');
        uint256 _id = creditLineCounter + 1;
        creditLineCounter = _id;
        creditLineVariables[_id].status = CreditLineStatus.REQUESTED;
        creditLineConstants[_id].borrower = _borrower;
        creditLineConstants[_id].lender = _lender;
        creditLineConstants[_id].borrowLimit = _borrowLimit;
        creditLineConstants[_id].autoLiquidation = _autoLiquidation;
        creditLineConstants[_id].idealCollateralRatio = _collateralRatio;
        creditLineConstants[_id].borrowRate = _borrowRate;
        creditLineConstants[_id].borrowAsset = _borrowAsset;
        creditLineConstants[_id].collateralAsset = _collateralAsset;
        creditLineConstants[_id].requestByLender = _requestByLender;
        return _id;
    }

    /**
     * @notice used to accept a credit line
     * @dev if borrower places request, lender can accept and vice versa
     * @param _id identifier for the credit line
     */
    function accept(uint256 _id) external {
        require(
            creditLineVariables[_id].status == CreditLineStatus.REQUESTED,
            'CreditLine::acceptCreditLineLender - CreditLine is already accepted'
        );
        bool _requestByLender = creditLineConstants[_id].requestByLender;
        require(
            (msg.sender == creditLineConstants[_id].borrower && _requestByLender) ||
                (msg.sender == creditLineConstants[_id].lender && !_requestByLender),
            "Only Borrower or Lender who hasn't requested can accept"
        );
        creditLineVariables[_id].status = CreditLineStatus.ACTIVE;
        emit CreditLineAccepted(_id);
    }

    /**
     * @notice used to deposit collateral into the credit line
     * @dev collateral tokens have to be approved in savingsAccount or token contract(unless ether).
            If transferred from savings account, the tokens are transferred from strategies in the 
            order prespecified in strategy registry
     * @param _id identifier for the credit line
     * @param _amount amount of collateral being deposited
     * @param _strategy strategy to which collateral is to be deposited in case transfer is not from savings account
     * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount 
                                otherwise direct from collateral token contract
     */
    function depositCollateral(
        uint256 _id,
        uint256 _amount,
        address _strategy,
        bool _fromSavingsAccount
    ) external payable nonReentrant ifCreditLineExists(_id) {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine not active');
        _depositCollateral(_id, _amount, _strategy, _fromSavingsAccount);
        emit CollateralDeposited(_id, _amount, _strategy);
    }

    function _depositCollateral(
        uint256 _id,
        uint256 _amount,
        address _strategy,
        bool _fromSavingsAccount
    ) internal {
        require(creditLineConstants[_id].lender != msg.sender, 'lender cant deposit collateral');
        if (_fromSavingsAccount) {
            _depositCollateralFromSavingsAccount(_id, _amount, msg.sender);
        } else {
            address _collateralAsset = creditLineConstants[_id].collateralAsset;
            ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
            if (_collateralAsset == address(0)) {
                require(msg.value == _amount, "CreditLine::_depositCollateral - value to transfer doesn't match argument");
            } else {
                IERC20(_collateralAsset).safeTransferFrom(msg.sender, address(this), _amount);
                IERC20(_collateralAsset).approve(_strategy, _amount);
            }
            uint256 _sharesReceived = _savingsAccount.deposit{value: msg.value}(_amount, _collateralAsset, _strategy, address(this));
            collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(_sharesReceived);
        }
    }

    function _withdrawBorrowAmount(
        address _asset,
        uint256 _amountInTokens,
        address _lender
    ) internal {
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        uint256 _activeAmount;
        for (uint256 _index = 0; _index < _strategyList.length; _index++) {
            if (_strategyList[_index] == address(0)) {
                continue;
            }
            uint256 _liquidityShares = _savingsAccount.balanceInShares(_lender, _asset, _strategyList[_index]);
            if (_liquidityShares != 0) {
                uint256 tokenInStrategy = _liquidityShares;
                tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);
                uint256 _tokensToTransfer = tokenInStrategy;
                if (_activeAmount.add(tokenInStrategy) >= _amountInTokens) {
                    _tokensToTransfer = (_amountInTokens.sub(_activeAmount));
                }
                _activeAmount = _activeAmount.add(_tokensToTransfer);
                _savingsAccount.withdrawFrom(_tokensToTransfer, _asset, _strategyList[_index], _lender, address(this), false);
                if (_activeAmount == _amountInTokens) {
                    return;
                }
            }
        }
        require(_activeAmount == _amountInTokens, 'insufficient balance');
    }

    /**
     * @notice used to borrow tokens from credit line by borrower
     * @dev only borrower can call this function. Amount that can actually be borrowed is 
            min(amount based on borrowLimit, allowance to creditLine contract, balance of lender)
     * @param _id identifier for the credit line
     * @param _amount amount of tokens to borrow
     */
    function borrow(uint256 _id, uint256 _amount) external payable nonReentrant onlyCreditLineBorrower(_id) {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');
        uint256 _borrowableAmount = calculateBorrowableAmount(_id);
        require(_amount <= _borrowableAmount, "CreditLine::borrow - The current collateral ratio doesn't allow to withdraw the amount");
        address _borrowAsset = creditLineConstants[_id].borrowAsset;
        address _lender = creditLineConstants[_id].lender;

        updateinterestAccruedTillLastPrincipalUpdate(_id);
        creditLineVariables[_id].principal = creditLineVariables[_id].principal.add(_amount);
        creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;

        uint256 _tokenDiffBalance;
        if (_borrowAsset != address(0)) {
            uint256 _balanceBefore = IERC20(_borrowAsset).balanceOf(address(this));
            _withdrawBorrowAmount(_borrowAsset, _amount, _lender);
            uint256 _balanceAfter = IERC20(_borrowAsset).balanceOf(address(this));
            _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);
        } else {
            uint256 _balanceBefore = address(this).balance;
            _withdrawBorrowAmount(_borrowAsset, _amount, _lender);
            uint256 _balanceAfter = address(this).balance;
            _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);
        }
        uint256 _protocolFee = _tokenDiffBalance.mul(protocolFeeFraction).div(10**30);
        _tokenDiffBalance = _tokenDiffBalance.sub(_protocolFee);

        if (_borrowAsset == address(0)) {
            (bool feeSuccess, ) = protocolFeeCollector.call{value: _protocolFee}('');
            require(feeSuccess, 'Transfer fail');
            (bool success, ) = msg.sender.call{value: _tokenDiffBalance}('');
            require(success, 'Transfer fail');
        } else {
            IERC20(_borrowAsset).safeTransfer(protocolFeeCollector, _protocolFee);
            IERC20(_borrowAsset).safeTransfer(msg.sender, _tokenDiffBalance);
        }
        emit BorrowedFromCreditLine(_id, _tokenDiffBalance);
    }

    function _repayFromSavingsAccount(
        uint256 _amount,
        address _asset,
        address _lender
    ) internal {
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        uint256 _activeAmount;

        for (uint256 _index = 0; _index < _strategyList.length; _index++) {
            if (_strategyList[_index] == address(0)) {
                continue;
            }
            uint256 _liquidityShares = _savingsAccount.balanceInShares(msg.sender, _asset, _strategyList[_index]);
            if (_liquidityShares == 0) {
                continue;
            }
            uint256 _tokenInStrategy = _liquidityShares;
            _tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);

            uint256 _tokensToTransfer = _tokenInStrategy;
            if (_activeAmount.add(_tokenInStrategy) >= _amount) {
                _tokensToTransfer = (_amount.sub(_activeAmount));
            }
            _activeAmount = _activeAmount.add(_tokensToTransfer);
            _savingsAccount.transferFrom(_tokensToTransfer, _asset, _strategyList[_index], msg.sender, _lender);

            if (_amount == _activeAmount) {
                return;
            }
        }
        revert('CreditLine::_repayFromSavingsAccount - Insufficient balance');
    }

    function _repay(
        uint256 _id,
        uint256 _amount,
        bool _fromSavingsAccount,
        uint256 _principalPaid
    ) internal {
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        address _defaultStrategy = defaultStrategy;
        address _borrowAsset = creditLineConstants[_id].borrowAsset;
        address _lender = creditLineConstants[_id].lender;
        if (!_fromSavingsAccount) {
            if (_borrowAsset == address(0)) {
                require(msg.value == _amount, 'creditLine::repay - Ether sent not equal to repay amount');
                _savingsAccount.deposit{value: _amount}(_amount, _borrowAsset, _defaultStrategy, _lender);
            } else {
                IERC20(_borrowAsset).safeTransferFrom(msg.sender, address(this), _amount);
                IERC20(_borrowAsset).approve(_defaultStrategy, _amount);
                _savingsAccount.deposit(_amount, _borrowAsset, _defaultStrategy, _lender);
            }
        } else {
            _repayFromSavingsAccount(_amount, _borrowAsset, _lender);
        }
        if (_principalPaid != 0) {
            _savingsAccount.increaseAllowanceToCreditLine(_principalPaid, _borrowAsset, _lender);
        }
    }

    /**
     * @notice used to repay interest and principal to credit line. Interest has to be repaid before repaying principal
     * @dev partial repayments possible
     * @param _id identifier for the credit line
     * @param _amount amount being repaid
     * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount 
                                otherwise direct from collateral token contract
     */
    function repay(
        uint256 _id,
        uint256 _amount,
        bool _fromSavingsAccount
    ) external payable nonReentrant {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');
        require(creditLineConstants[_id].lender != msg.sender, 'Lender cant repay');

        uint256 _interestSincePrincipalUpdate = calculateInterestAccrued(_id);
        uint256 _totalInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(
            _interestSincePrincipalUpdate
        );
        uint256 _interestToPay = _totalInterestAccrued.sub(creditLineVariables[_id].totalInterestRepaid);
        uint256 _totalCurrentDebt = _interestToPay.add(creditLineVariables[_id].principal);
        uint256 _principalPaid = 0;

        if (_amount >= _totalCurrentDebt) {
            _amount = _totalCurrentDebt;
            emit CompleteCreditLineRepaid(_id, _amount);
        } else {
            emit PartialCreditLineRepaid(_id, _amount);
        }

        if (_amount > _interestToPay) {
            creditLineVariables[_id].principal = _totalCurrentDebt.sub(_amount);
            creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _totalInterestAccrued;
            creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;
            creditLineVariables[_id].totalInterestRepaid = _totalInterestAccrued;
            _principalPaid = _amount.sub(_interestToPay);
        } else {
            creditLineVariables[_id].totalInterestRepaid = creditLineVariables[_id].totalInterestRepaid.add(_amount);
        }

        _repay(_id, _amount, _fromSavingsAccount, _principalPaid);

        if (creditLineVariables[_id].principal == 0) {
            _resetCreditLine(_id);
        }
    }

    function _resetCreditLine(uint256 _id) internal {
        creditLineVariables[_id].lastPrincipalUpdateTime = 0;
        creditLineVariables[_id].totalInterestRepaid = 0;
        creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = 0;
        emit CreditLineReset(_id);
    }

    /**
     * @dev used to close credit line by borrower or lender
     * @param _id identifier for the credit line
     */
    function close(uint256 _id) external ifCreditLineExists(_id) {
        require(
            msg.sender == creditLineConstants[_id].borrower || msg.sender == creditLineConstants[_id].lender,
            'CreditLine: Permission denied while closing Line of credit'
        );
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: Credit line should be active.');
        require(creditLineVariables[_id].principal == 0, 'CreditLine: Cannot be closed since not repaid.');
        require(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate == 0, 'CreditLine: Cannot be closed since not repaid.');
        creditLineVariables[_id].status = CreditLineStatus.CLOSED;
        emit CreditLineClosed(_id);
    }

    /**
     * @notice used to calculate the current collateral ratio
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view.
            Interest is also considered while calculating debt
     * @param _id identifier for the credit line
     * @return collateral ratio multiplied by 10**30 to retain precision
     */
    function calculateCurrentCollateralRatio(uint256 _id) public ifCreditLineExists(_id) returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(
            creditLineConstants[_id].collateralAsset,
            creditLineConstants[_id].borrowAsset
        );

        uint256 currentDebt = calculateCurrentDebt(_id);
        uint256 currentCollateralRatio = calculateTotalCollateralTokens(_id).mul(_ratioOfPrices).div(currentDebt).mul(10**30).div(
            10**_decimals
        );

        return currentCollateralRatio;
    }

    /**
     * @notice used to calculate the total collateral tokens
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @param _id identifier for the credit line
     * @return _amount total collateral tokens deposited into the credit line
     */
    function calculateTotalCollateralTokens(uint256 _id) public returns (uint256 _amount) {
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        uint256 _liquidityShares;
        for (uint256 index = 0; index < _strategyList.length; index++) {
            if (_strategyList[index] == address(0)) {
                continue;
            }
            _liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];
            uint256 _tokenInStrategy = _liquidityShares;
            _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(_liquidityShares, _collateralAsset);

            _amount = _amount.add(_tokenInStrategy);
        }
    }

    /**
     * @notice used to withdraw any excess collateral
     * @dev collateral can't be withdraw if collateralRatio goes below the ideal value. Only borrower can withdraw
     * @param _id identifier for the credit line
     * @param _amount amount of collateral to withdraw
     * @param _toSavingsAccount if true, tokens are transferred from savingsAccount 
                                otherwise direct from collateral token contract
     */
    function withdrawCollateral(
        uint256 _id,
        uint256 _amount,
        bool _toSavingsAccount
    ) external nonReentrant onlyCreditLineBorrower(_id) {
        uint256 _withdrawableCollateral = withdrawableCollateral(_id);
        require(_amount <= _withdrawableCollateral, 'Collateral ratio cant go below ideal');
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        _transferCollateral(_id, _collateralAsset, _amount, _toSavingsAccount);
        emit CollateralWithdrawn(_id, _amount);
    }

    /**
     * @notice used to calculate the collateral that can be withdrawn
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @param _id identifier for the credit line
     * @return total collateral withdrawable by borrower
     */
    function withdrawableCollateral(uint256 _id) public returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(
            creditLineConstants[_id].collateralAsset,
            creditLineConstants[_id].borrowAsset
        );

        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);
        uint256 _currentDebt = calculateCurrentDebt(_id);

        uint256 _collateralNeeded = _currentDebt
            .mul(creditLineConstants[_id].idealCollateralRatio)
            .div(_ratioOfPrices)
            .mul(10**_decimals)
            .div(10**30);

        if (_collateralNeeded >= _totalCollateralTokens) {
            return 0;
        }
        return _totalCollateralTokens.sub(_collateralNeeded);
    }

    function _transferCollateral(
        uint256 _id,
        address _asset,
        uint256 _amountInTokens,
        bool _toSavingsAccount
    ) internal {
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        uint256 _activeAmount;
        for (uint256 index = 0; index < _strategyList.length; index++) {
            uint256 liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];
            if (liquidityShares == 0 || _strategyList[index] == address(0)) {
                continue;
            }
            uint256 _tokenInStrategy = liquidityShares;
            _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(liquidityShares, _asset);
            uint256 _tokensToTransfer = _tokenInStrategy;
            if (_activeAmount.add(_tokenInStrategy) > _amountInTokens) {
                _tokensToTransfer = _amountInTokens.sub(_activeAmount);
                liquidityShares = liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy);
            }
            _activeAmount = _activeAmount.add(_tokensToTransfer);
            collateralShareInStrategy[_id][_strategyList[index]] = collateralShareInStrategy[_id][_strategyList[index]].sub(
                liquidityShares
            );
            if (_toSavingsAccount) {
                ISavingsAccount(savingsAccount).transfer(_tokensToTransfer, _asset, _strategyList[index], msg.sender);
            } else {
                ISavingsAccount(savingsAccount).withdraw(_tokensToTransfer, _asset, _strategyList[index], msg.sender, false);
            }

            if (_activeAmount == _amountInTokens) {
                return;
            }
        }
        revert('insufficient collateral');
    }

    /**
     * @notice used to liquidate credit line in case collateral ratio goes below the threshold
     * @dev if lender liquidates, then collateral is directly transferred. 
            If autoLiquidation is true, anyone can liquidate by providing enough borrow tokens
     * @param _id identifier for the credit line
     * @param _toSavingsAccount if true, tokens are transferred from savingsAccount 
                                otherwise direct from collateral token contract
     */
    function liquidate(uint256 _id, bool _toSavingsAccount) external payable nonReentrant {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: Credit line should be active.');
        require(creditLineVariables[_id].principal != 0, 'CreditLine: cannot liquidate if principal is 0');

        uint256 currentCollateralRatio = calculateCurrentCollateralRatio(_id);
        require(
            currentCollateralRatio < creditLineConstants[_id].idealCollateralRatio,
            'CreditLine: Collateral ratio is higher than ideal value'
        );

        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        address _lender = creditLineConstants[_id].lender;
        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);
        address _borrowAsset = creditLineConstants[_id].borrowAsset;

        creditLineVariables[_id].status = CreditLineStatus.LIQUIDATED;

        if (creditLineConstants[_id].autoLiquidation && _lender != msg.sender) {
            uint256 _borrowTokens = _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens);
            if (_borrowAsset == address(0)) {
                uint256 _returnETH = msg.value.sub(_borrowTokens, 'Insufficient ETH to liquidate');
                if (_returnETH != 0) {
                    (bool success, ) = msg.sender.call{value: _returnETH}('');
                    require(success, 'Transfer fail');
                }
            } else {
                IERC20(_borrowAsset).safeTransferFrom(msg.sender, _lender, _borrowTokens);
            }
        }

        _transferCollateral(_id, _collateralAsset, _totalCollateralTokens, _toSavingsAccount);

        emit CreditLineLiquidated(_id, msg.sender);
    }

    /**
     * @notice used to calculate the borrow tokens necessary for liquidator to liquidate
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @param _id identifier for the credit line
     * @return borrow tokens necessary for liquidator to liquidate
     */
    function borrowTokensToLiquidate(uint256 _id) external returns (uint256) {
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);
        address _borrowAsset = creditLineConstants[_id].borrowAsset;

        return _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens);
    }

    function _borrowTokensToLiquidate(
        address _borrowAsset,
        address _collateralAsset,
        uint256 _totalCollateralTokens
    ) internal view returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(_borrowAsset, _collateralAsset);
        uint256 _borrowTokens = (
            _totalCollateralTokens.mul(uint256(10**30).sub(liquidatorRewardFraction)).div(10**30).mul(_ratioOfPrices).div(10**_decimals)
        );

        return _borrowTokens;
    }

    receive() external payable {
        require(msg.sender == savingsAccount, 'CreditLine::receive invalid transaction');
    }
}
.]

Given the user's task and the brainstorming ideas provided:
Task: "// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/utils/ReentrancyGuard.sol';
import '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';
import '../interfaces/IPriceOracle.sol';
import '../interfaces/IYield.sol';
import '../interfaces/ISavingsAccount.sol';
import '../SavingsAccount/SavingsAccountUtil.sol';
import '../interfaces/IStrategyRegistry.sol';

/**
 * @title Credit Line contract with Methods related to credit Line
 * @notice Implements the functions related to Credit Line
 * @author Sublime
 **/

contract CreditLine is ReentrancyGuard, OwnableUpgradeable {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    enum CreditLineStatus {
        NOT_CREATED,
        REQUESTED,
        ACTIVE,
        CLOSED,
        CANCELLED,
        LIQUIDATED
    }

    /**
     * @notice counter that tracks the number of credit lines created
     * @dev used to create unique identifier for credit lines
     **/
    uint256 public creditLineCounter;

    uint256 constant YEAR_IN_SECONDS = 365 days;

    struct CreditLineVariables {
        CreditLineStatus status;
        uint256 principal;
        uint256 totalInterestRepaid;
        uint256 lastPrincipalUpdateTime;
        uint256 interestAccruedTillLastPrincipalUpdate;
    }

    struct CreditLineConstants {
        address lender;
        address borrower;
        uint256 borrowLimit;
        uint256 idealCollateralRatio;
        uint256 borrowRate;
        address borrowAsset;
        address collateralAsset;
        bool autoLiquidation;
        bool requestByLender;
    }
    /**
     * @notice stores the collateral shares in a credit line per strategy
     * @dev creditLineId => Strategy => collateralShares
     **/
    mapping(uint256 => mapping(address => uint256)) public collateralShareInStrategy;

    /**
     * @notice stores the variables to maintain a credit line
     **/
    mapping(uint256 => CreditLineVariables) public creditLineVariables;

    /**
     * @notice stores the constants related to a credit line
     **/
    mapping(uint256 => CreditLineConstants) public creditLineConstants;

    /**
     * @notice stores the address of savings account contract
     **/
    address public savingsAccount;

    /**
     * @notice stores the address of price oracle contract
     **/
    address public priceOracle;

    /**
     * @notice stores the address of strategy registry contract
     **/
    address public strategyRegistry;

    /**
     * @notice stores the address of default strategy
     **/
    address public defaultStrategy;

    /**
     * @notice stores the fraction of borrowed amount charged as fee by protocol
     * @dev it is multiplied by 10**30
     **/
    uint256 public protocolFeeFraction;

    /**
     * @notice address where protocol fee is collected
     **/
    address public protocolFeeCollector;

    /**
     * @notice stores the fraction of amount liquidated given as reward to liquidator
     * @dev it is multiplied by 10**30
     **/
    uint256 public liquidatorRewardFraction;
    /**
     * @dev checks if Credit Line exists
     * @param _id identifier for the credit line
     **/
    modifier ifCreditLineExists(uint256 _id) {
        require(creditLineVariables[_id].status != CreditLineStatus.NOT_CREATED, 'Credit line does not exist');
        _;
    }

    /**
     * @dev checks if called by credit Line Borrower
     * @param _id creditLine identifier
     **/
    modifier onlyCreditLineBorrower(uint256 _id) {
        require(creditLineConstants[_id].borrower == msg.sender, 'Only credit line Borrower can access');
        _;
    }

    /**
     * @dev checks if called by credit Line Lender
     * @param _id creditLine identifier
     **/
    modifier onlyCreditLineLender(uint256 _id) {
        require(creditLineConstants[_id].lender == msg.sender, 'Only credit line Lender can access');
        _;
    }

    /**
     * @notice emitted when a collateral is deposited into credit line
     * @param id id of the credit line
     * @param amount amount of collateral deposited
     * @param strategy address of the strategy into which collateral is deposited
     */
    event CollateralDeposited(uint256 indexed id, uint256 amount, address indexed strategy);

    /**
     * @notice emitted when collateral is withdrawn from credit line
     * @param id id of the credit line
     * @param amount amount of collateral withdrawn
     */
    event CollateralWithdrawn(uint256 indexed id, uint256 amount);

    /**
     * @notice emitted when a request for new credit line is placed
     * @param id id of the credit line for which request was made
     * @param lender address of the lender for credit line
     * @param borrower address of the borrower for credit line
     */
    event CreditLineRequested(uint256 indexed id, address indexed lender, address indexed borrower);

    /**
     * @notice emitted when a credit line is liquidated
     * @param id id of the credit line which is liquidated
     * @param liquidator address of the liquidator
     */
    event CreditLineLiquidated(uint256 indexed id, address indexed liquidator);

    /**
     * @notice emitted when tokens are borrowed from credit line
     * @param id id of the credit line from which tokens are borrowed
     * @param borrowAmount amount of tokens borrowed
     */
    event BorrowedFromCreditLine(uint256 indexed id, uint256 borrowAmount);

    /**
     * @notice emitted when credit line is accepted
     * @param id id of the credit line that was accepted
     */
    event CreditLineAccepted(uint256 indexed id);

    /**
     * @notice emitted when credit line is completely repaid and reset
     * @param id id of the credit line that is reset
     */
    event CreditLineReset(uint256 indexed id);

    /**
     * @notice emitted when the credit line is partially repaid
     * @param id id of the credit line
     * @param repayAmount amount repaid
     */
    event PartialCreditLineRepaid(uint256 indexed id, uint256 repayAmount);

    /**
     * @notice emitted when the credit line is completely repaid
     * @param id id of the credit line
     * @param repayAmount amount repaid
     */
    event CompleteCreditLineRepaid(uint256 indexed id, uint256 repayAmount);

    /**
     * @notice emitted when the credit line is closed by one of the parties of credit line
     * @param id id of the credit line
     */
    event CreditLineClosed(uint256 indexed id);

    /**
     * @notice emitted when default strategy for the credit line is updated
     * @param defaultStrategy address of the strategy contract that is used as default by credit lines
     */
    event DefaultStrategyUpdated(address indexed defaultStrategy);

    /**
     * @notice emitted when the price oracle is updated
     * @param priceOracle address of the updated price oracle
     */
    event PriceOracleUpdated(address indexed priceOracle);

    /**
     * @notice emitted when the savings account address is updated
     * @param savingsAccount address of the updated savingsAccount
     */
    event SavingsAccountUpdated(address indexed savingsAccount);

    /**
     * @notice emitted when strategy registry address is updated
     * @param strategyRegistry address of the updated strategy registry
     */
    event StrategyRegistryUpdated(address indexed strategyRegistry);

    /**
     * @notice emitted when fee that protocol charges for credit line is updated
     * @param updatedProtocolFee updated value of protocolFeeFraction
     */
    event ProtocolFeeFractionUpdated(uint256 updatedProtocolFee);

    /**
     * @notice emitted when address which receives fee that protocol changes for pools is updated
     * @param updatedProtocolFeeCollector updated value of protocolFeeCollector
     */
    event ProtocolFeeCollectorUpdated(address indexed updatedProtocolFeeCollector);

    /**
     * @notice emitted when liquidatorRewardFraction is updated
     * @param liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator
     */
    event LiquidationRewardFractionUpdated(uint256 liquidatorRewardFraction);

    /**
     * @notice used to initialize the contract
     * @dev can only be called once during the life cycle of the contract
     * @param _defaultStrategy default strategy used in credit lines
     * @param _priceOracle address of the priceOracle
     * @param _savingsAccount address of  the savings account contract
     * @param _strategyRegistry address of the strategy registry contract
     * @param _owner address of owner who can change global variables
     * @param _protocolFeeFraction fraction of the fee charged by protocol
     * @param _protocolFeeCollector address to which protocol fee is charged to
     * @param _liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator
     */
    function initialize(
        address _defaultStrategy,
        address _priceOracle,
        address _savingsAccount,
        address _strategyRegistry,
        address _owner,
        uint256 _protocolFeeFraction,
        address _protocolFeeCollector,
        uint256 _liquidatorRewardFraction
    ) external initializer {
        OwnableUpgradeable.__Ownable_init();
        OwnableUpgradeable.transferOwnership(_owner);

        _updateDefaultStrategy(_defaultStrategy);
        _updatePriceOracle(_priceOracle);
        _updateSavingsAccount(_savingsAccount);
        _updateStrategyRegistry(_strategyRegistry);
        _updateProtocolFeeFraction(_protocolFeeFraction);
        _updateProtocolFeeCollector(_protocolFeeCollector);
        _updateLiquidatorRewardFraction(_liquidatorRewardFraction);
    }

    /**
     * @notice used to update the default strategy
     * @dev can only be updated by owner
     * @param _defaultStrategy address of the updated default strategy
     */
    function updateDefaultStrategy(address _defaultStrategy) external onlyOwner {
        _updateDefaultStrategy(_defaultStrategy);
    }

    function _updateDefaultStrategy(address _defaultStrategy) internal {
        defaultStrategy = _defaultStrategy;
        emit DefaultStrategyUpdated(_defaultStrategy);
    }

    /**
     * @notice used to update the price oracle
     * @dev can only be updated by owner
     * @param _priceOracle address of the updated price oracle
     */
    function updatePriceOracle(address _priceOracle) external onlyOwner {
        _updatePriceOracle(_priceOracle);
    }

    function _updatePriceOracle(address _priceOracle) internal {
        priceOracle = _priceOracle;
        emit PriceOracleUpdated(_priceOracle);
    }

    /**
     * @notice used to update the savings account address
     * @dev can only be updated by owner
     * @param _savingsAccount address of the updated savings account
     */
    function updateSavingsAccount(address _savingsAccount) external onlyOwner {
        _updateSavingsAccount(_savingsAccount);
    }

    function _updateSavingsAccount(address _savingsAccount) internal {
        savingsAccount = _savingsAccount;
        emit SavingsAccountUpdated(_savingsAccount);
    }

    /**
     * @notice used to update the protocol fee fraction
     * @dev can only be updated by owner
     * @param _protocolFee fraction of the borrower amount collected as protocol fee
     */
    function updateProtocolFeeFraction(uint256 _protocolFee) external onlyOwner {
        _updateProtocolFeeFraction(_protocolFee);
    }

    function _updateProtocolFeeFraction(uint256 _protocolFee) internal {
        protocolFeeFraction = _protocolFee;
        emit ProtocolFeeFractionUpdated(_protocolFee);
    }

    /**
     * @notice used to update the protocol fee collector
     * @dev can only be updated by owner
     * @param _protocolFeeCollector address in which protocol fee is collected
     */
    function updateProtocolFeeCollector(address _protocolFeeCollector) external onlyOwner {
        _updateProtocolFeeCollector(_protocolFeeCollector);
    }

    function _updateProtocolFeeCollector(address _protocolFeeCollector) internal {
        require(_protocolFeeCollector != address(0), 'cant be 0 address');
        protocolFeeCollector = _protocolFeeCollector;
        emit ProtocolFeeCollectorUpdated(_protocolFeeCollector);
    }

    /**
     * @notice used to update the strategy registry address
     * @dev can only be updated by owner
     * @param _strategyRegistry address of the updated strategy registry
     */
    function updateStrategyRegistry(address _strategyRegistry) external onlyOwner {
        _updateStrategyRegistry(_strategyRegistry);
    }

    function _updateStrategyRegistry(address _strategyRegistry) internal {
        require(_strategyRegistry != address(0), 'CL::I zero address');
        strategyRegistry = _strategyRegistry;
        emit StrategyRegistryUpdated(_strategyRegistry);
    }

    /**
     * @notice used to update the liquidatorRewardFraction
     * @dev can only be updated by owner
     * @param _rewardFraction fraction of liquidated amount given to liquidator as reward
     */
    function updateLiquidatorRewardFraction(uint256 _rewardFraction) external onlyOwner {
        _updateLiquidatorRewardFraction(_rewardFraction);
    }

    function _updateLiquidatorRewardFraction(uint256 _rewardFraction) internal {
        require(_rewardFraction <= 10**30, 'Fraction has to be less than 1');
        liquidatorRewardFraction = _rewardFraction;
        emit LiquidationRewardFractionUpdated(_rewardFraction);
    }

    /**
     * @dev Used to Calculate Interest Per second on given principal and Interest rate
     * @param _principal principal Amount for which interest has to be calculated.
     * @param _borrowRate It is the Interest Rate at which Credit Line is approved
     * @return interest per second for the given parameters
     */
    function calculateInterest(
        uint256 _principal,
        uint256 _borrowRate,
        uint256 _timeElapsed
    ) public pure returns (uint256) {
        uint256 _interest = _principal.mul(_borrowRate).mul(_timeElapsed).div(10**30).div(YEAR_IN_SECONDS);

        return _interest;
    }

    /**
     * @dev Used to calculate interest accrued since last repayment
     * @param _id identifier for the credit line
     * @return interest accrued over current borrowed amount since last repayment
     */

    function calculateInterestAccrued(uint256 _id) public view returns (uint256) {
        uint256 _lastPrincipalUpdateTime = creditLineVariables[_id].lastPrincipalUpdateTime;
        if (_lastPrincipalUpdateTime == 0) return 0;
        uint256 _timeElapsed = (block.timestamp).sub(_lastPrincipalUpdateTime);
        uint256 _interestAccrued = calculateInterest(creditLineVariables[_id].principal, creditLineConstants[_id].borrowRate, _timeElapsed);
        return _interestAccrued;
    }

    /**
     * @dev Used to calculate current debt of borrower against a credit line.
     * @param _id identifier for the credit line
     * @return current debt of borrower
     */
    function calculateCurrentDebt(uint256 _id) public view returns (uint256) {
        uint256 _interestAccrued = calculateInterestAccrued(_id);
        uint256 _currentDebt = (creditLineVariables[_id].principal)
            .add(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate)
            .add(_interestAccrued)
            .sub(creditLineVariables[_id].totalInterestRepaid);
        return _currentDebt;
    }

    /**
     * @notice used to calculate amount that can be borrowed by the borrower
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view.
            borrowableAmount changes per block as interest changes per block.
     * @param _id identifier for the credit line
     * @return amount that can be borrowed from the credit line
     */
    function calculateBorrowableAmount(uint256 _id) public returns (uint256) {
        CreditLineStatus _status = creditLineVariables[_id].status;
        require(
            _status == CreditLineStatus.ACTIVE || _status == CreditLineStatus.REQUESTED,
            'CreditLine: Cannot only if credit line ACTIVE or REQUESTED'
        );
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(
            creditLineConstants[_id].collateralAsset,
            creditLineConstants[_id].borrowAsset
        );

        uint256 _totalCollateralToken = calculateTotalCollateralTokens(_id);

        uint256 _currentDebt = calculateCurrentDebt(_id);

        uint256 _maxPossible = _totalCollateralToken.mul(_ratioOfPrices).div(creditLineConstants[_id].idealCollateralRatio).mul(10**30).div(
            10**_decimals
        );

        uint256 _borrowLimit = creditLineConstants[_id].borrowLimit;

        if (_maxPossible > _borrowLimit) {
            _maxPossible = _borrowLimit;
        }
        if (_maxPossible > _currentDebt) {
            return _maxPossible.sub(_currentDebt);
        }
        return 0;
    }

    function updateinterestAccruedTillLastPrincipalUpdate(uint256 _id) internal {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');

        uint256 _interestAccrued = calculateInterestAccrued(_id);
        uint256 _newInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(_interestAccrued);
        creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _newInterestAccrued;
    }

    function _depositCollateralFromSavingsAccount(
        uint256 _id,
        uint256 _amount,
        address _sender
    ) internal {
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        uint256 _activeAmount;

        for (uint256 _index = 0; _index < _strategyList.length; _index++) {
            address _strategy = _strategyList[_index];
            uint256 _liquidityShares = _savingsAccount.balanceInShares(_sender, _collateralAsset, _strategy);
            if (_liquidityShares == 0 || _strategyList[_index] == address(0)) {
                continue;
            }
            uint256 _tokenInStrategy = _liquidityShares;
            _tokenInStrategy = IYield(_strategy).getTokensForShares(_liquidityShares, _collateralAsset);

            uint256 _tokensToTransfer = _tokenInStrategy;
            if (_activeAmount.add(_tokenInStrategy) >= _amount) {
                _tokensToTransfer = (_amount.sub(_activeAmount));
            }
            _activeAmount = _activeAmount.add(_tokensToTransfer);
            _savingsAccount.transferFrom(_tokensToTransfer, _collateralAsset, _strategy, _sender, address(this));

            collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(
                _liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy)
            );

            if (_amount == _activeAmount) {
                return;
            }
        }
        revert('CreditLine::_depositCollateralFromSavingsAccount - Insufficient balance');
    }

    /**
     * @notice used to request a credit line either by borrower or lender
     * @param _requestTo Address to which creditLine is requested, 
                        if borrower creates request then lender address and 
                        if lender creates then borrower address
     * @param _borrowLimit maximum borrow amount in a credit line
     * @param _borrowRate Interest Rate at which credit Line is requested
     * @param _autoLiquidation if true, anyone can liquidate loan, otherwise only lender
     * @param _collateralRatio ratio of the collateral to the debt below which credit line can be liquidated
     * @param _borrowAsset address of the token to be borrowed
     * @param _collateralAsset address of the token provided as collateral
     * @param _requestAsLender if true, lender is placing request, otherwise borrower
     * @return identifier for the credit line
     */

    function request(
        address _requestTo,
        uint256 _borrowLimit,
        uint256 _borrowRate,
        bool _autoLiquidation,
        uint256 _collateralRatio,
        address _borrowAsset,
        address _collateralAsset,
        bool _requestAsLender
    ) external returns (uint256) {
        require(_borrowAsset != _collateralAsset, 'R: cant borrow lent token');
        require(IPriceOracle(priceOracle).doesFeedExist(_borrowAsset, _collateralAsset), 'R: No price feed');

        address _lender = _requestTo;
        address _borrower = msg.sender;
        if (_requestAsLender) {
            _lender = msg.sender;
            _borrower = _requestTo;
        }

        uint256 _id = _createRequest(
            _lender,
            _borrower,
            _borrowLimit,
            _borrowRate,
            _autoLiquidation,
            _collateralRatio,
            _borrowAsset,
            _collateralAsset,
            _requestAsLender
        );

        emit CreditLineRequested(_id, _lender, _borrower);
        return _id;
    }

    function _createRequest(
        address _lender,
        address _borrower,
        uint256 _borrowLimit,
        uint256 _borrowRate,
        bool _autoLiquidation,
        uint256 _collateralRatio,
        address _borrowAsset,
        address _collateralAsset,
        bool _requestByLender
    ) internal returns (uint256) {
        require(_lender != _borrower, 'Lender and Borrower cannot be same addresses');
        uint256 _id = creditLineCounter + 1;
        creditLineCounter = _id;
        creditLineVariables[_id].status = CreditLineStatus.REQUESTED;
        creditLineConstants[_id].borrower = _borrower;
        creditLineConstants[_id].lender = _lender;
        creditLineConstants[_id].borrowLimit = _borrowLimit;
        creditLineConstants[_id].autoLiquidation = _autoLiquidation;
        creditLineConstants[_id].idealCollateralRatio = _collateralRatio;
        creditLineConstants[_id].borrowRate = _borrowRate;
        creditLineConstants[_id].borrowAsset = _borrowAsset;
        creditLineConstants[_id].collateralAsset = _collateralAsset;
        creditLineConstants[_id].requestByLender = _requestByLender;
        return _id;
    }

    /**
     * @notice used to accept a credit line
     * @dev if borrower places request, lender can accept and vice versa
     * @param _id identifier for the credit line
     */
    function accept(uint256 _id) external {
        require(
            creditLineVariables[_id].status == CreditLineStatus.REQUESTED,
            'CreditLine::acceptCreditLineLender - CreditLine is already accepted'
        );
        bool _requestByLender = creditLineConstants[_id].requestByLender;
        require(
            (msg.sender == creditLineConstants[_id].borrower && _requestByLender) ||
                (msg.sender == creditLineConstants[_id].lender && !_requestByLender),
            "Only Borrower or Lender who hasn't requested can accept"
        );
        creditLineVariables[_id].status = CreditLineStatus.ACTIVE;
        emit CreditLineAccepted(_id);
    }

    /**
     * @notice used to deposit collateral into the credit line
     * @dev collateral tokens have to be approved in savingsAccount or token contract(unless ether).
            If transferred from savings account, the tokens are transferred from strategies in the 
            order prespecified in strategy registry
     * @param _id identifier for the credit line
     * @param _amount amount of collateral being deposited
     * @param _strategy strategy to which collateral is to be deposited in case transfer is not from savings account
     * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount 
                                otherwise direct from collateral token contract
     */
    function depositCollateral(
        uint256 _id,
        uint256 _amount,
        address _strategy,
        bool _fromSavingsAccount
    ) external payable nonReentrant ifCreditLineExists(_id) {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine not active');
        _depositCollateral(_id, _amount, _strategy, _fromSavingsAccount);
        emit CollateralDeposited(_id, _amount, _strategy);
    }

    function _depositCollateral(
        uint256 _id,
        uint256 _amount,
        address _strategy,
        bool _fromSavingsAccount
    ) internal {
        require(creditLineConstants[_id].lender != msg.sender, 'lender cant deposit collateral');
        if (_fromSavingsAccount) {
            _depositCollateralFromSavingsAccount(_id, _amount, msg.sender);
        } else {
            address _collateralAsset = creditLineConstants[_id].collateralAsset;
            ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
            if (_collateralAsset == address(0)) {
                require(msg.value == _amount, "CreditLine::_depositCollateral - value to transfer doesn't match argument");
            } else {
                IERC20(_collateralAsset).safeTransferFrom(msg.sender, address(this), _amount);
                IERC20(_collateralAsset).approve(_strategy, _amount);
            }
            uint256 _sharesReceived = _savingsAccount.deposit{value: msg.value}(_amount, _collateralAsset, _strategy, address(this));
            collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(_sharesReceived);
        }
    }

    function _withdrawBorrowAmount(
        address _asset,
        uint256 _amountInTokens,
        address _lender
    ) internal {
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        uint256 _activeAmount;
        for (uint256 _index = 0; _index < _strategyList.length; _index++) {
            if (_strategyList[_index] == address(0)) {
                continue;
            }
            uint256 _liquidityShares = _savingsAccount.balanceInShares(_lender, _asset, _strategyList[_index]);
            if (_liquidityShares != 0) {
                uint256 tokenInStrategy = _liquidityShares;
                tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);
                uint256 _tokensToTransfer = tokenInStrategy;
                if (_activeAmount.add(tokenInStrategy) >= _amountInTokens) {
                    _tokensToTransfer = (_amountInTokens.sub(_activeAmount));
                }
                _activeAmount = _activeAmount.add(_tokensToTransfer);
                _savingsAccount.withdrawFrom(_tokensToTransfer, _asset, _strategyList[_index], _lender, address(this), false);
                if (_activeAmount == _amountInTokens) {
                    return;
                }
            }
        }
        require(_activeAmount == _amountInTokens, 'insufficient balance');
    }

    /**
     * @notice used to borrow tokens from credit line by borrower
     * @dev only borrower can call this function. Amount that can actually be borrowed is 
            min(amount based on borrowLimit, allowance to creditLine contract, balance of lender)
     * @param _id identifier for the credit line
     * @param _amount amount of tokens to borrow
     */
    function borrow(uint256 _id, uint256 _amount) external payable nonReentrant onlyCreditLineBorrower(_id) {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');
        uint256 _borrowableAmount = calculateBorrowableAmount(_id);
        require(_amount <= _borrowableAmount, "CreditLine::borrow - The current collateral ratio doesn't allow to withdraw the amount");
        address _borrowAsset = creditLineConstants[_id].borrowAsset;
        address _lender = creditLineConstants[_id].lender;

        updateinterestAccruedTillLastPrincipalUpdate(_id);
        creditLineVariables[_id].principal = creditLineVariables[_id].principal.add(_amount);
        creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;

        uint256 _tokenDiffBalance;
        if (_borrowAsset != address(0)) {
            uint256 _balanceBefore = IERC20(_borrowAsset).balanceOf(address(this));
            _withdrawBorrowAmount(_borrowAsset, _amount, _lender);
            uint256 _balanceAfter = IERC20(_borrowAsset).balanceOf(address(this));
            _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);
        } else {
            uint256 _balanceBefore = address(this).balance;
            _withdrawBorrowAmount(_borrowAsset, _amount, _lender);
            uint256 _balanceAfter = address(this).balance;
            _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);
        }
        uint256 _protocolFee = _tokenDiffBalance.mul(protocolFeeFraction).div(10**30);
        _tokenDiffBalance = _tokenDiffBalance.sub(_protocolFee);

        if (_borrowAsset == address(0)) {
            (bool feeSuccess, ) = protocolFeeCollector.call{value: _protocolFee}('');
            require(feeSuccess, 'Transfer fail');
            (bool success, ) = msg.sender.call{value: _tokenDiffBalance}('');
            require(success, 'Transfer fail');
        } else {
            IERC20(_borrowAsset).safeTransfer(protocolFeeCollector, _protocolFee);
            IERC20(_borrowAsset).safeTransfer(msg.sender, _tokenDiffBalance);
        }
        emit BorrowedFromCreditLine(_id, _tokenDiffBalance);
    }

    function _repayFromSavingsAccount(
        uint256 _amount,
        address _asset,
        address _lender
    ) internal {
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        uint256 _activeAmount;

        for (uint256 _index = 0; _index < _strategyList.length; _index++) {
            if (_strategyList[_index] == address(0)) {
                continue;
            }
            uint256 _liquidityShares = _savingsAccount.balanceInShares(msg.sender, _asset, _strategyList[_index]);
            if (_liquidityShares == 0) {
                continue;
            }
            uint256 _tokenInStrategy = _liquidityShares;
            _tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);

            uint256 _tokensToTransfer = _tokenInStrategy;
            if (_activeAmount.add(_tokenInStrategy) >= _amount) {
                _tokensToTransfer = (_amount.sub(_activeAmount));
            }
            _activeAmount = _activeAmount.add(_tokensToTransfer);
            _savingsAccount.transferFrom(_tokensToTransfer, _asset, _strategyList[_index], msg.sender, _lender);

            if (_amount == _activeAmount) {
                return;
            }
        }
        revert('CreditLine::_repayFromSavingsAccount - Insufficient balance');
    }

    function _repay(
        uint256 _id,
        uint256 _amount,
        bool _fromSavingsAccount,
        uint256 _principalPaid
    ) internal {
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        address _defaultStrategy = defaultStrategy;
        address _borrowAsset = creditLineConstants[_id].borrowAsset;
        address _lender = creditLineConstants[_id].lender;
        if (!_fromSavingsAccount) {
            if (_borrowAsset == address(0)) {
                require(msg.value == _amount, 'creditLine::repay - Ether sent not equal to repay amount');
                _savingsAccount.deposit{value: _amount}(_amount, _borrowAsset, _defaultStrategy, _lender);
            } else {
                IERC20(_borrowAsset).safeTransferFrom(msg.sender, address(this), _amount);
                IERC20(_borrowAsset).approve(_defaultStrategy, _amount);
                _savingsAccount.deposit(_amount, _borrowAsset, _defaultStrategy, _lender);
            }
        } else {
            _repayFromSavingsAccount(_amount, _borrowAsset, _lender);
        }
        if (_principalPaid != 0) {
            _savingsAccount.increaseAllowanceToCreditLine(_principalPaid, _borrowAsset, _lender);
        }
    }

    /**
     * @notice used to repay interest and principal to credit line. Interest has to be repaid before repaying principal
     * @dev partial repayments possible
     * @param _id identifier for the credit line
     * @param _amount amount being repaid
     * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount 
                                otherwise direct from collateral token contract
     */
    function repay(
        uint256 _id,
        uint256 _amount,
        bool _fromSavingsAccount
    ) external payable nonReentrant {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');
        require(creditLineConstants[_id].lender != msg.sender, 'Lender cant repay');

        uint256 _interestSincePrincipalUpdate = calculateInterestAccrued(_id);
        uint256 _totalInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(
            _interestSincePrincipalUpdate
        );
        uint256 _interestToPay = _totalInterestAccrued.sub(creditLineVariables[_id].totalInterestRepaid);
        uint256 _totalCurrentDebt = _interestToPay.add(creditLineVariables[_id].principal);
        uint256 _principalPaid = 0;

        if (_amount >= _totalCurrentDebt) {
            _amount = _totalCurrentDebt;
            emit CompleteCreditLineRepaid(_id, _amount);
        } else {
            emit PartialCreditLineRepaid(_id, _amount);
        }

        if (_amount > _interestToPay) {
            creditLineVariables[_id].principal = _totalCurrentDebt.sub(_amount);
            creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _totalInterestAccrued;
            creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;
            creditLineVariables[_id].totalInterestRepaid = _totalInterestAccrued;
            _principalPaid = _amount.sub(_interestToPay);
        } else {
            creditLineVariables[_id].totalInterestRepaid = creditLineVariables[_id].totalInterestRepaid.add(_amount);
        }

        _repay(_id, _amount, _fromSavingsAccount, _principalPaid);

        if (creditLineVariables[_id].principal == 0) {
            _resetCreditLine(_id);
        }
    }

    function _resetCreditLine(uint256 _id) internal {
        creditLineVariables[_id].lastPrincipalUpdateTime = 0;
        creditLineVariables[_id].totalInterestRepaid = 0;
        creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = 0;
        emit CreditLineReset(_id);
    }

    /**
     * @dev used to close credit line by borrower or lender
     * @param _id identifier for the credit line
     */
    function close(uint256 _id) external ifCreditLineExists(_id) {
        require(
            msg.sender == creditLineConstants[_id].borrower || msg.sender == creditLineConstants[_id].lender,
            'CreditLine: Permission denied while closing Line of credit'
        );
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: Credit line should be active.');
        require(creditLineVariables[_id].principal == 0, 'CreditLine: Cannot be closed since not repaid.');
        require(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate == 0, 'CreditLine: Cannot be closed since not repaid.');
        creditLineVariables[_id].status = CreditLineStatus.CLOSED;
        emit CreditLineClosed(_id);
    }

    /**
     * @notice used to calculate the current collateral ratio
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view.
            Interest is also considered while calculating debt
     * @param _id identifier for the credit line
     * @return collateral ratio multiplied by 10**30 to retain precision
     */
    function calculateCurrentCollateralRatio(uint256 _id) public ifCreditLineExists(_id) returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(
            creditLineConstants[_id].collateralAsset,
            creditLineConstants[_id].borrowAsset
        );

        uint256 currentDebt = calculateCurrentDebt(_id);
        uint256 currentCollateralRatio = calculateTotalCollateralTokens(_id).mul(_ratioOfPrices).div(currentDebt).mul(10**30).div(
            10**_decimals
        );

        return currentCollateralRatio;
    }

    /**
     * @notice used to calculate the total collateral tokens
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @param _id identifier for the credit line
     * @return _amount total collateral tokens deposited into the credit line
     */
    function calculateTotalCollateralTokens(uint256 _id) public returns (uint256 _amount) {
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        uint256 _liquidityShares;
        for (uint256 index = 0; index < _strategyList.length; index++) {
            if (_strategyList[index] == address(0)) {
                continue;
            }
            _liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];
            uint256 _tokenInStrategy = _liquidityShares;
            _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(_liquidityShares, _collateralAsset);

            _amount = _amount.add(_tokenInStrategy);
        }
    }

    /**
     * @notice used to withdraw any excess collateral
     * @dev collateral can't be withdraw if collateralRatio goes below the ideal value. Only borrower can withdraw
     * @param _id identifier for the credit line
     * @param _amount amount of collateral to withdraw
     * @param _toSavingsAccount if true, tokens are transferred from savingsAccount 
                                otherwise direct from collateral token contract
     */
    function withdrawCollateral(
        uint256 _id,
        uint256 _amount,
        bool _toSavingsAccount
    ) external nonReentrant onlyCreditLineBorrower(_id) {
        uint256 _withdrawableCollateral = withdrawableCollateral(_id);
        require(_amount <= _withdrawableCollateral, 'Collateral ratio cant go below ideal');
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        _transferCollateral(_id, _collateralAsset, _amount, _toSavingsAccount);
        emit CollateralWithdrawn(_id, _amount);
    }

    /**
     * @notice used to calculate the collateral that can be withdrawn
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @param _id identifier for the credit line
     * @return total collateral withdrawable by borrower
     */
    function withdrawableCollateral(uint256 _id) public returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(
            creditLineConstants[_id].collateralAsset,
            creditLineConstants[_id].borrowAsset
        );

        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);
        uint256 _currentDebt = calculateCurrentDebt(_id);

        uint256 _collateralNeeded = _currentDebt
            .mul(creditLineConstants[_id].idealCollateralRatio)
            .div(_ratioOfPrices)
            .mul(10**_decimals)
            .div(10**30);

        if (_collateralNeeded >= _totalCollateralTokens) {
            return 0;
        }
        return _totalCollateralTokens.sub(_collateralNeeded);
    }

    function _transferCollateral(
        uint256 _id,
        address _asset,
        uint256 _amountInTokens,
        bool _toSavingsAccount
    ) internal {
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        uint256 _activeAmount;
        for (uint256 index = 0; index < _strategyList.length; index++) {
            uint256 liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];
            if (liquidityShares == 0 || _strategyList[index] == address(0)) {
                continue;
            }
            uint256 _tokenInStrategy = liquidityShares;
            _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(liquidityShares, _asset);
            uint256 _tokensToTransfer = _tokenInStrategy;
            if (_activeAmount.add(_tokenInStrategy) > _amountInTokens) {
                _tokensToTransfer = _amountInTokens.sub(_activeAmount);
                liquidityShares = liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy);
            }
            _activeAmount = _activeAmount.add(_tokensToTransfer);
            collateralShareInStrategy[_id][_strategyList[index]] = collateralShareInStrategy[_id][_strategyList[index]].sub(
                liquidityShares
            );
            if (_toSavingsAccount) {
                ISavingsAccount(savingsAccount).transfer(_tokensToTransfer, _asset, _strategyList[index], msg.sender);
            } else {
                ISavingsAccount(savingsAccount).withdraw(_tokensToTransfer, _asset, _strategyList[index], msg.sender, false);
            }

            if (_activeAmount == _amountInTokens) {
                return;
            }
        }
        revert('insufficient collateral');
    }

    /**
     * @notice used to liquidate credit line in case collateral ratio goes below the threshold
     * @dev if lender liquidates, then collateral is directly transferred. 
            If autoLiquidation is true, anyone can liquidate by providing enough borrow tokens
     * @param _id identifier for the credit line
     * @param _toSavingsAccount if true, tokens are transferred from savingsAccount 
                                otherwise direct from collateral token contract
     */
    function liquidate(uint256 _id, bool _toSavingsAccount) external payable nonReentrant {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: Credit line should be active.');
        require(creditLineVariables[_id].principal != 0, 'CreditLine: cannot liquidate if principal is 0');

        uint256 currentCollateralRatio = calculateCurrentCollateralRatio(_id);
        require(
            currentCollateralRatio < creditLineConstants[_id].idealCollateralRatio,
            'CreditLine: Collateral ratio is higher than ideal value'
        );

        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        address _lender = creditLineConstants[_id].lender;
        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);
        address _borrowAsset = creditLineConstants[_id].borrowAsset;

        creditLineVariables[_id].status = CreditLineStatus.LIQUIDATED;

        if (creditLineConstants[_id].autoLiquidation && _lender != msg.sender) {
            uint256 _borrowTokens = _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens);
            if (_borrowAsset == address(0)) {
                uint256 _returnETH = msg.value.sub(_borrowTokens, 'Insufficient ETH to liquidate');
                if (_returnETH != 0) {
                    (bool success, ) = msg.sender.call{value: _returnETH}('');
                    require(success, 'Transfer fail');
                }
            } else {
                IERC20(_borrowAsset).safeTransferFrom(msg.sender, _lender, _borrowTokens);
            }
        }

        _transferCollateral(_id, _collateralAsset, _totalCollateralTokens, _toSavingsAccount);

        emit CreditLineLiquidated(_id, msg.sender);
    }

    /**
     * @notice used to calculate the borrow tokens necessary for liquidator to liquidate
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @param _id identifier for the credit line
     * @return borrow tokens necessary for liquidator to liquidate
     */
    function borrowTokensToLiquidate(uint256 _id) external returns (uint256) {
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);
        address _borrowAsset = creditLineConstants[_id].borrowAsset;

        return _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens);
    }

    function _borrowTokensToLiquidate(
        address _borrowAsset,
        address _collateralAsset,
        uint256 _totalCollateralTokens
    ) internal view returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(_borrowAsset, _collateralAsset);
        uint256 _borrowTokens = (
            _totalCollateralTokens.mul(uint256(10**30).sub(liquidatorRewardFraction)).div(10**30).mul(_ratioOfPrices).div(10**_decimals)
        );

        return _borrowTokens;
    }

    receive() external payable {
        require(msg.sender == savingsAccount, 'CreditLine::receive invalid transaction');
    }
}
".
Ideas: " Security".
As the Security Analyst, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability.
For each vulnerability identified, use the following format:
VULNERABILITY NAME or TYPE
```
DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix.
```
Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: "<INFO> Analysis Complete."

[2024-22-08 11:43:28 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-22-08 11:43:28 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 20047
completion_tokens: 1
total_tokens: 20048
cost: $-1.000000


[2024-22-08 11:43:28 INFO] Security Analyst: **Security Analyst<->Solidity Programming Expert on : ContractReviewComment, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/utils/ReentrancyGuard.sol';
import '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';
import '../interfaces/IPriceOracle.sol';
import '../interfaces/IYield.sol';
import '../interfaces/ISavingsAccount.sol';
import '../SavingsAccount/SavingsAccountUtil.sol';
import '../interfaces/IStrategyRegistry.sol';

/**
 * @title Credit Line contract with Methods related to credit Line
 * @notice Implements the functions related to Credit Line
 * @author Sublime
 **/

contract CreditLine is ReentrancyGuard, OwnableUpgradeable {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    enum CreditLineStatus {
        NOT_CREATED,
        REQUESTED,
        ACTIVE,
        CLOSED,
        CANCELLED,
        LIQUIDATED
    }

    /**
     * @notice counter that tracks the number of credit lines created
     * @dev used to create unique identifier for credit lines
     **/
    uint256 public creditLineCounter;

    uint256 constant YEAR_IN_SECONDS = 365 days;

    struct CreditLineVariables {
        CreditLineStatus status;
        uint256 principal;
        uint256 totalInterestRepaid;
        uint256 lastPrincipalUpdateTime;
        uint256 interestAccruedTillLastPrincipalUpdate;
    }

    struct CreditLineConstants {
        address lender;
        address borrower;
        uint256 borrowLimit;
        uint256 idealCollateralRatio;
        uint256 borrowRate;
        address borrowAsset;
        address collateralAsset;
        bool autoLiquidation;
        bool requestByLender;
    }
    /**
     * @notice stores the collateral shares in a credit line per strategy
     * @dev creditLineId => Strategy => collateralShares
     **/
    mapping(uint256 => mapping(address => uint256)) public collateralShareInStrategy;

    /**
     * @notice stores the variables to maintain a credit line
     **/
    mapping(uint256 => CreditLineVariables) public creditLineVariables;

    /**
     * @notice stores the constants related to a credit line
     **/
    mapping(uint256 => CreditLineConstants) public creditLineConstants;

    /**
     * @notice stores the address of savings account contract
     **/
    address public savingsAccount;

    /**
     * @notice stores the address of price oracle contract
     **/
    address public priceOracle;

    /**
     * @notice stores the address of strategy registry contract
     **/
    address public strategyRegistry;

    /**
     * @notice stores the address of default strategy
     **/
    address public defaultStrategy;

    /**
     * @notice stores the fraction of borrowed amount charged as fee by protocol
     * @dev it is multiplied by 10**30
     **/
    uint256 public protocolFeeFraction;

    /**
     * @notice address where protocol fee is collected
     **/
    address public protocolFeeCollector;

    /**
     * @notice stores the fraction of amount liquidated given as reward to liquidator
     * @dev it is multiplied by 10**30
     **/
    uint256 public liquidatorRewardFraction;
    /**
     * @dev checks if Credit Line exists
     * @param _id identifier for the credit line
     **/
    modifier ifCreditLineExists(uint256 _id) {
        require(creditLineVariables[_id].status != CreditLineStatus.NOT_CREATED, 'Credit line does not exist');
        _;
    }

    /**
     * @dev checks if called by credit Line Borrower
     * @param _id creditLine identifier
     **/
    modifier onlyCreditLineBorrower(uint256 _id) {
        require(creditLineConstants[_id].borrower == msg.sender, 'Only credit line Borrower can access');
        _;
    }

    /**
     * @dev checks if called by credit Line Lender
     * @param _id creditLine identifier
     **/
    modifier onlyCreditLineLender(uint256 _id) {
        require(creditLineConstants[_id].lender == msg.sender, 'Only credit line Lender can access');
        _;
    }

    /**
     * @notice emitted when a collateral is deposited into credit line
     * @param id id of the credit line
     * @param amount amount of collateral deposited
     * @param strategy address of the strategy into which collateral is deposited
     */
    event CollateralDeposited(uint256 indexed id, uint256 amount, address indexed strategy);

    /**
     * @notice emitted when collateral is withdrawn from credit line
     * @param id id of the credit line
     * @param amount amount of collateral withdrawn
     */
    event CollateralWithdrawn(uint256 indexed id, uint256 amount);

    /**
     * @notice emitted when a request for new credit line is placed
     * @param id id of the credit line for which request was made
     * @param lender address of the lender for credit line
     * @param borrower address of the borrower for credit line
     */
    event CreditLineRequested(uint256 indexed id, address indexed lender, address indexed borrower);

    /**
     * @notice emitted when a credit line is liquidated
     * @param id id of the credit line which is liquidated
     * @param liquidator address of the liquidator
     */
    event CreditLineLiquidated(uint256 indexed id, address indexed liquidator);

    /**
     * @notice emitted when tokens are borrowed from credit line
     * @param id id of the credit line from which tokens are borrowed
     * @param borrowAmount amount of tokens borrowed
     */
    event BorrowedFromCreditLine(uint256 indexed id, uint256 borrowAmount);

    /**
     * @notice emitted when credit line is accepted
     * @param id id of the credit line that was accepted
     */
    event CreditLineAccepted(uint256 indexed id);

    /**
     * @notice emitted when credit line is completely repaid and reset
     * @param id id of the credit line that is reset
     */
    event CreditLineReset(uint256 indexed id);

    /**
     * @notice emitted when the credit line is partially repaid
     * @param id id of the credit line
     * @param repayAmount amount repaid
     */
    event PartialCreditLineRepaid(uint256 indexed id, uint256 repayAmount);

    /**
     * @notice emitted when the credit line is completely repaid
     * @param id id of the credit line
     * @param repayAmount amount repaid
     */
    event CompleteCreditLineRepaid(uint256 indexed id, uint256 repayAmount);

    /**
     * @notice emitted when the credit line is closed by one of the parties of credit line
     * @param id id of the credit line
     */
    event CreditLineClosed(uint256 indexed id);

    /**
     * @notice emitted when default strategy for the credit line is updated
     * @param defaultStrategy address of the strategy contract that is used as default by credit lines
     */
    event DefaultStrategyUpdated(address indexed defaultStrategy);

    /**
     * @notice emitted when the price oracle is updated
     * @param priceOracle address of the updated price oracle
     */
    event PriceOracleUpdated(address indexed priceOracle);

    /**
     * @notice emitted when the savings account address is updated
     * @param savingsAccount address of the updated savingsAccount
     */
    event SavingsAccountUpdated(address indexed savingsAccount);

    /**
     * @notice emitted when strategy registry address is updated
     * @param strategyRegistry address of the updated strategy registry
     */
    event StrategyRegistryUpdated(address indexed strategyRegistry);

    /**
     * @notice emitted when fee that protocol charges for credit line is updated
     * @param updatedProtocolFee updated value of protocolFeeFraction
     */
    event ProtocolFeeFractionUpdated(uint256 updatedProtocolFee);

    /**
     * @notice emitted when address which receives fee that protocol changes for pools is updated
     * @param updatedProtocolFeeCollector updated value of protocolFeeCollector
     */
    event ProtocolFeeCollectorUpdated(address indexed updatedProtocolFeeCollector);

    /**
     * @notice emitted when liquidatorRewardFraction is updated
     * @param liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator
     */
    event LiquidationRewardFractionUpdated(uint256 liquidatorRewardFraction);

    /**
     * @notice used to initialize the contract
     * @dev can only be called once during the life cycle of the contract
     * @param _defaultStrategy default strategy used in credit lines
     * @param _priceOracle address of the priceOracle
     * @param _savingsAccount address of  the savings account contract
     * @param _strategyRegistry address of the strategy registry contract
     * @param _owner address of owner who can change global variables
     * @param _protocolFeeFraction fraction of the fee charged by protocol
     * @param _protocolFeeCollector address to which protocol fee is charged to
     * @param _liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator
     */
    function initialize(
        address _defaultStrategy,
        address _priceOracle,
        address _savingsAccount,
        address _strategyRegistry,
        address _owner,
        uint256 _protocolFeeFraction,
        address _protocolFeeCollector,
        uint256 _liquidatorRewardFraction
    ) external initializer {
        OwnableUpgradeable.__Ownable_init();
        OwnableUpgradeable.transferOwnership(_owner);

        _updateDefaultStrategy(_defaultStrategy);
        _updatePriceOracle(_priceOracle);
        _updateSavingsAccount(_savingsAccount);
        _updateStrategyRegistry(_strategyRegistry);
        _updateProtocolFeeFraction(_protocolFeeFraction);
        _updateProtocolFeeCollector(_protocolFeeCollector);
        _updateLiquidatorRewardFraction(_liquidatorRewardFraction);
    }

    /**
     * @notice used to update the default strategy
     * @dev can only be updated by owner
     * @param _defaultStrategy address of the updated default strategy
     */
    function updateDefaultStrategy(address _defaultStrategy) external onlyOwner {
        _updateDefaultStrategy(_defaultStrategy);
    }

    function _updateDefaultStrategy(address _defaultStrategy) internal {
        defaultStrategy = _defaultStrategy;
        emit DefaultStrategyUpdated(_defaultStrategy);
    }

    /**
     * @notice used to update the price oracle
     * @dev can only be updated by owner
     * @param _priceOracle address of the updated price oracle
     */
    function updatePriceOracle(address _priceOracle) external onlyOwner {
        _updatePriceOracle(_priceOracle);
    }

    function _updatePriceOracle(address _priceOracle) internal {
        priceOracle = _priceOracle;
        emit PriceOracleUpdated(_priceOracle);
    }

    /**
     * @notice used to update the savings account address
     * @dev can only be updated by owner
     * @param _savingsAccount address of the updated savings account
     */
    function updateSavingsAccount(address _savingsAccount) external onlyOwner {
        _updateSavingsAccount(_savingsAccount);
    }

    function _updateSavingsAccount(address _savingsAccount) internal {
        savingsAccount = _savingsAccount;
        emit SavingsAccountUpdated(_savingsAccount);
    }

    /**
     * @notice used to update the protocol fee fraction
     * @dev can only be updated by owner
     * @param _protocolFee fraction of the borrower amount collected as protocol fee
     */
    function updateProtocolFeeFraction(uint256 _protocolFee) external onlyOwner {
        _updateProtocolFeeFraction(_protocolFee);
    }

    function _updateProtocolFeeFraction(uint256 _protocolFee) internal {
        protocolFeeFraction = _protocolFee;
        emit ProtocolFeeFractionUpdated(_protocolFee);
    }

    /**
     * @notice used to update the protocol fee collector
     * @dev can only be updated by owner
     * @param _protocolFeeCollector address in which protocol fee is collected
     */
    function updateProtocolFeeCollector(address _protocolFeeCollector) external onlyOwner {
        _updateProtocolFeeCollector(_protocolFeeCollector);
    }

    function _updateProtocolFeeCollector(address _protocolFeeCollector) internal {
        require(_protocolFeeCollector != address(0), 'cant be 0 address');
        protocolFeeCollector = _protocolFeeCollector;
        emit ProtocolFeeCollectorUpdated(_protocolFeeCollector);
    }

    /**
     * @notice used to update the strategy registry address
     * @dev can only be updated by owner
     * @param _strategyRegistry address of the updated strategy registry
     */
    function updateStrategyRegistry(address _strategyRegistry) external onlyOwner {
        _updateStrategyRegistry(_strategyRegistry);
    }

    function _updateStrategyRegistry(address _strategyRegistry) internal {
        require(_strategyRegistry != address(0), 'CL::I zero address');
        strategyRegistry = _strategyRegistry;
        emit StrategyRegistryUpdated(_strategyRegistry);
    }

    /**
     * @notice used to update the liquidatorRewardFraction
     * @dev can only be updated by owner
     * @param _rewardFraction fraction of liquidated amount given to liquidator as reward
     */
    function updateLiquidatorRewardFraction(uint256 _rewardFraction) external onlyOwner {
        _updateLiquidatorRewardFraction(_rewardFraction);
    }

    function _updateLiquidatorRewardFraction(uint256 _rewardFraction) internal {
        require(_rewardFraction <= 10**30, 'Fraction has to be less than 1');
        liquidatorRewardFraction = _rewardFraction;
        emit LiquidationRewardFractionUpdated(_rewardFraction);
    }

    /**
     * @dev Used to Calculate Interest Per second on given principal and Interest rate
     * @param _principal principal Amount for which interest has to be calculated.
     * @param _borrowRate It is the Interest Rate at which Credit Line is approved
     * @return interest per second for the given parameters
     */
    function calculateInterest(
        uint256 _principal,
        uint256 _borrowRate,
        uint256 _timeElapsed
    ) public pure returns (uint256) {
        uint256 _interest = _principal.mul(_borrowRate).mul(_timeElapsed).div(10**30).div(YEAR_IN_SECONDS);

        return _interest;
    }

    /**
     * @dev Used to calculate interest accrued since last repayment
     * @param _id identifier for the credit line
     * @return interest accrued over current borrowed amount since last repayment
     */

    function calculateInterestAccrued(uint256 _id) public view returns (uint256) {
        uint256 _lastPrincipalUpdateTime = creditLineVariables[_id].lastPrincipalUpdateTime;
        if (_lastPrincipalUpdateTime == 0) return 0;
        uint256 _timeElapsed = (block.timestamp).sub(_lastPrincipalUpdateTime);
        uint256 _interestAccrued = calculateInterest(creditLineVariables[_id].principal, creditLineConstants[_id].borrowRate, _timeElapsed);
        return _interestAccrued;
    }

    /**
     * @dev Used to calculate current debt of borrower against a credit line.
     * @param _id identifier for the credit line
     * @return current debt of borrower
     */
    function calculateCurrentDebt(uint256 _id) public view returns (uint256) {
        uint256 _interestAccrued = calculateInterestAccrued(_id);
        uint256 _currentDebt = (creditLineVariables[_id].principal)
            .add(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate)
            .add(_interestAccrued)
            .sub(creditLineVariables[_id].totalInterestRepaid);
        return _currentDebt;
    }

    /**
     * @notice used to calculate amount that can be borrowed by the borrower
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view.
            borrowableAmount changes per block as interest changes per block.
     * @param _id identifier for the credit line
     * @return amount that can be borrowed from the credit line
     */
    function calculateBorrowableAmount(uint256 _id) public returns (uint256) {
        CreditLineStatus _status = creditLineVariables[_id].status;
        require(
            _status == CreditLineStatus.ACTIVE || _status == CreditLineStatus.REQUESTED,
            'CreditLine: Cannot only if credit line ACTIVE or REQUESTED'
        );
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(
            creditLineConstants[_id].collateralAsset,
            creditLineConstants[_id].borrowAsset
        );

        uint256 _totalCollateralToken = calculateTotalCollateralTokens(_id);

        uint256 _currentDebt = calculateCurrentDebt(_id);

        uint256 _maxPossible = _totalCollateralToken.mul(_ratioOfPrices).div(creditLineConstants[_id].idealCollateralRatio).mul(10**30).div(
            10**_decimals
        );

        uint256 _borrowLimit = creditLineConstants[_id].borrowLimit;

        if (_maxPossible > _borrowLimit) {
            _maxPossible = _borrowLimit;
        }
        if (_maxPossible > _currentDebt) {
            return _maxPossible.sub(_currentDebt);
        }
        return 0;
    }

    function updateinterestAccruedTillLastPrincipalUpdate(uint256 _id) internal {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');

        uint256 _interestAccrued = calculateInterestAccrued(_id);
        uint256 _newInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(_interestAccrued);
        creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _newInterestAccrued;
    }

    function _depositCollateralFromSavingsAccount(
        uint256 _id,
        uint256 _amount,
        address _sender
    ) internal {
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        uint256 _activeAmount;

        for (uint256 _index = 0; _index < _strategyList.length; _index++) {
            address _strategy = _strategyList[_index];
            uint256 _liquidityShares = _savingsAccount.balanceInShares(_sender, _collateralAsset, _strategy);
            if (_liquidityShares == 0 || _strategyList[_index] == address(0)) {
                continue;
            }
            uint256 _tokenInStrategy = _liquidityShares;
            _tokenInStrategy = IYield(_strategy).getTokensForShares(_liquidityShares, _collateralAsset);

            uint256 _tokensToTransfer = _tokenInStrategy;
            if (_activeAmount.add(_tokenInStrategy) >= _amount) {
                _tokensToTransfer = (_amount.sub(_activeAmount));
            }
            _activeAmount = _activeAmount.add(_tokensToTransfer);
            _savingsAccount.transferFrom(_tokensToTransfer, _collateralAsset, _strategy, _sender, address(this));

            collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(
                _liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy)
            );

            if (_amount == _activeAmount) {
                return;
            }
        }
        revert('CreditLine::_depositCollateralFromSavingsAccount - Insufficient balance');
    }

    /**
     * @notice used to request a credit line either by borrower or lender
     * @param _requestTo Address to which creditLine is requested, 
                        if borrower creates request then lender address and 
                        if lender creates then borrower address
     * @param _borrowLimit maximum borrow amount in a credit line
     * @param _borrowRate Interest Rate at which credit Line is requested
     * @param _autoLiquidation if true, anyone can liquidate loan, otherwise only lender
     * @param _collateralRatio ratio of the collateral to the debt below which credit line can be liquidated
     * @param _borrowAsset address of the token to be borrowed
     * @param _collateralAsset address of the token provided as collateral
     * @param _requestAsLender if true, lender is placing request, otherwise borrower
     * @return identifier for the credit line
     */

    function request(
        address _requestTo,
        uint256 _borrowLimit,
        uint256 _borrowRate,
        bool _autoLiquidation,
        uint256 _collateralRatio,
        address _borrowAsset,
        address _collateralAsset,
        bool _requestAsLender
    ) external returns (uint256) {
        require(_borrowAsset != _collateralAsset, 'R: cant borrow lent token');
        require(IPriceOracle(priceOracle).doesFeedExist(_borrowAsset, _collateralAsset), 'R: No price feed');

        address _lender = _requestTo;
        address _borrower = msg.sender;
        if (_requestAsLender) {
            _lender = msg.sender;
            _borrower = _requestTo;
        }

        uint256 _id = _createRequest(
            _lender,
            _borrower,
            _borrowLimit,
            _borrowRate,
            _autoLiquidation,
            _collateralRatio,
            _borrowAsset,
            _collateralAsset,
            _requestAsLender
        );

        emit CreditLineRequested(_id, _lender, _borrower);
        return _id;
    }

    function _createRequest(
        address _lender,
        address _borrower,
        uint256 _borrowLimit,
        uint256 _borrowRate,
        bool _autoLiquidation,
        uint256 _collateralRatio,
        address _borrowAsset,
        address _collateralAsset,
        bool _requestByLender
    ) internal returns (uint256) {
        require(_lender != _borrower, 'Lender and Borrower cannot be same addresses');
        uint256 _id = creditLineCounter + 1;
        creditLineCounter = _id;
        creditLineVariables[_id].status = CreditLineStatus.REQUESTED;
        creditLineConstants[_id].borrower = _borrower;
        creditLineConstants[_id].lender = _lender;
        creditLineConstants[_id].borrowLimit = _borrowLimit;
        creditLineConstants[_id].autoLiquidation = _autoLiquidation;
        creditLineConstants[_id].idealCollateralRatio = _collateralRatio;
        creditLineConstants[_id].borrowRate = _borrowRate;
        creditLineConstants[_id].borrowAsset = _borrowAsset;
        creditLineConstants[_id].collateralAsset = _collateralAsset;
        creditLineConstants[_id].requestByLender = _requestByLender;
        return _id;
    }

    /**
     * @notice used to accept a credit line
     * @dev if borrower places request, lender can accept and vice versa
     * @param _id identifier for the credit line
     */
    function accept(uint256 _id) external {
        require(
            creditLineVariables[_id].status == CreditLineStatus.REQUESTED,
            'CreditLine::acceptCreditLineLender - CreditLine is already accepted'
        );
        bool _requestByLender = creditLineConstants[_id].requestByLender;
        require(
            (msg.sender == creditLineConstants[_id].borrower && _requestByLender) ||
                (msg.sender == creditLineConstants[_id].lender && !_requestByLender),
            "Only Borrower or Lender who hasn't requested can accept"
        );
        creditLineVariables[_id].status = CreditLineStatus.ACTIVE;
        emit CreditLineAccepted(_id);
    }

    /**
     * @notice used to deposit collateral into the credit line
     * @dev collateral tokens have to be approved in savingsAccount or token contract(unless ether).
            If transferred from savings account, the tokens are transferred from strategies in the 
            order prespecified in strategy registry
     * @param _id identifier for the credit line
     * @param _amount amount of collateral being deposited
     * @param _strategy strategy to which collateral is to be deposited in case transfer is not from savings account
     * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount 
                                otherwise direct from collateral token contract
     */
    function depositCollateral(
        uint256 _id,
        uint256 _amount,
        address _strategy,
        bool _fromSavingsAccount
    ) external payable nonReentrant ifCreditLineExists(_id) {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine not active');
        _depositCollateral(_id, _amount, _strategy, _fromSavingsAccount);
        emit CollateralDeposited(_id, _amount, _strategy);
    }

    function _depositCollateral(
        uint256 _id,
        uint256 _amount,
        address _strategy,
        bool _fromSavingsAccount
    ) internal {
        require(creditLineConstants[_id].lender != msg.sender, 'lender cant deposit collateral');
        if (_fromSavingsAccount) {
            _depositCollateralFromSavingsAccount(_id, _amount, msg.sender);
        } else {
            address _collateralAsset = creditLineConstants[_id].collateralAsset;
            ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
            if (_collateralAsset == address(0)) {
                require(msg.value == _amount, "CreditLine::_depositCollateral - value to transfer doesn't match argument");
            } else {
                IERC20(_collateralAsset).safeTransferFrom(msg.sender, address(this), _amount);
                IERC20(_collateralAsset).approve(_strategy, _amount);
            }
            uint256 _sharesReceived = _savingsAccount.deposit{value: msg.value}(_amount, _collateralAsset, _strategy, address(this));
            collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(_sharesReceived);
        }
    }

    function _withdrawBorrowAmount(
        address _asset,
        uint256 _amountInTokens,
        address _lender
    ) internal {
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        uint256 _activeAmount;
        for (uint256 _index = 0; _index < _strategyList.length; _index++) {
            if (_strategyList[_index] == address(0)) {
                continue;
            }
            uint256 _liquidityShares = _savingsAccount.balanceInShares(_lender, _asset, _strategyList[_index]);
            if (_liquidityShares != 0) {
                uint256 tokenInStrategy = _liquidityShares;
                tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);
                uint256 _tokensToTransfer = tokenInStrategy;
                if (_activeAmount.add(tokenInStrategy) >= _amountInTokens) {
                    _tokensToTransfer = (_amountInTokens.sub(_activeAmount));
                }
                _activeAmount = _activeAmount.add(_tokensToTransfer);
                _savingsAccount.withdrawFrom(_tokensToTransfer, _asset, _strategyList[_index], _lender, address(this), false);
                if (_activeAmount == _amountInTokens) {
                    return;
                }
            }
        }
        require(_activeAmount == _amountInTokens, 'insufficient balance');
    }

    /**
     * @notice used to borrow tokens from credit line by borrower
     * @dev only borrower can call this function. Amount that can actually be borrowed is 
            min(amount based on borrowLimit, allowance to creditLine contract, balance of lender)
     * @param _id identifier for the credit line
     * @param _amount amount of tokens to borrow
     */
    function borrow(uint256 _id, uint256 _amount) external payable nonReentrant onlyCreditLineBorrower(_id) {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');
        uint256 _borrowableAmount = calculateBorrowableAmount(_id);
        require(_amount <= _borrowableAmount, "CreditLine::borrow - The current collateral ratio doesn't allow to withdraw the amount");
        address _borrowAsset = creditLineConstants[_id].borrowAsset;
        address _lender = creditLineConstants[_id].lender;

        updateinterestAccruedTillLastPrincipalUpdate(_id);
        creditLineVariables[_id].principal = creditLineVariables[_id].principal.add(_amount);
        creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;

        uint256 _tokenDiffBalance;
        if (_borrowAsset != address(0)) {
            uint256 _balanceBefore = IERC20(_borrowAsset).balanceOf(address(this));
            _withdrawBorrowAmount(_borrowAsset, _amount, _lender);
            uint256 _balanceAfter = IERC20(_borrowAsset).balanceOf(address(this));
            _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);
        } else {
            uint256 _balanceBefore = address(this).balance;
            _withdrawBorrowAmount(_borrowAsset, _amount, _lender);
            uint256 _balanceAfter = address(this).balance;
            _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);
        }
        uint256 _protocolFee = _tokenDiffBalance.mul(protocolFeeFraction).div(10**30);
        _tokenDiffBalance = _tokenDiffBalance.sub(_protocolFee);

        if (_borrowAsset == address(0)) {
            (bool feeSuccess, ) = protocolFeeCollector.call{value: _protocolFee}('');
            require(feeSuccess, 'Transfer fail');
            (bool success, ) = msg.sender.call{value: _tokenDiffBalance}('');
            require(success, 'Transfer fail');
        } else {
            IERC20(_borrowAsset).safeTransfer(protocolFeeCollector, _protocolFee);
            IERC20(_borrowAsset).safeTransfer(msg.sender, _tokenDiffBalance);
        }
        emit BorrowedFromCreditLine(_id, _tokenDiffBalance);
    }

    function _repayFromSavingsAccount(
        uint256 _amount,
        address _asset,
        address _lender
    ) internal {
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        uint256 _activeAmount;

        for (uint256 _index = 0; _index < _strategyList.length; _index++) {
            if (_strategyList[_index] == address(0)) {
                continue;
            }
            uint256 _liquidityShares = _savingsAccount.balanceInShares(msg.sender, _asset, _strategyList[_index]);
            if (_liquidityShares == 0) {
                continue;
            }
            uint256 _tokenInStrategy = _liquidityShares;
            _tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);

            uint256 _tokensToTransfer = _tokenInStrategy;
            if (_activeAmount.add(_tokenInStrategy) >= _amount) {
                _tokensToTransfer = (_amount.sub(_activeAmount));
            }
            _activeAmount = _activeAmount.add(_tokensToTransfer);
            _savingsAccount.transferFrom(_tokensToTransfer, _asset, _strategyList[_index], msg.sender, _lender);

            if (_amount == _activeAmount) {
                return;
            }
        }
        revert('CreditLine::_repayFromSavingsAccount - Insufficient balance');
    }

    function _repay(
        uint256 _id,
        uint256 _amount,
        bool _fromSavingsAccount,
        uint256 _principalPaid
    ) internal {
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        address _defaultStrategy = defaultStrategy;
        address _borrowAsset = creditLineConstants[_id].borrowAsset;
        address _lender = creditLineConstants[_id].lender;
        if (!_fromSavingsAccount) {
            if (_borrowAsset == address(0)) {
                require(msg.value == _amount, 'creditLine::repay - Ether sent not equal to repay amount');
                _savingsAccount.deposit{value: _amount}(_amount, _borrowAsset, _defaultStrategy, _lender);
            } else {
                IERC20(_borrowAsset).safeTransferFrom(msg.sender, address(this), _amount);
                IERC20(_borrowAsset).approve(_defaultStrategy, _amount);
                _savingsAccount.deposit(_amount, _borrowAsset, _defaultStrategy, _lender);
            }
        } else {
            _repayFromSavingsAccount(_amount, _borrowAsset, _lender);
        }
        if (_principalPaid != 0) {
            _savingsAccount.increaseAllowanceToCreditLine(_principalPaid, _borrowAsset, _lender);
        }
    }

    /**
     * @notice used to repay interest and principal to credit line. Interest has to be repaid before repaying principal
     * @dev partial repayments possible
     * @param _id identifier for the credit line
     * @param _amount amount being repaid
     * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount 
                                otherwise direct from collateral token contract
     */
    function repay(
        uint256 _id,
        uint256 _amount,
        bool _fromSavingsAccount
    ) external payable nonReentrant {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');
        require(creditLineConstants[_id].lender != msg.sender, 'Lender cant repay');

        uint256 _interestSincePrincipalUpdate = calculateInterestAccrued(_id);
        uint256 _totalInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(
            _interestSincePrincipalUpdate
        );
        uint256 _interestToPay = _totalInterestAccrued.sub(creditLineVariables[_id].totalInterestRepaid);
        uint256 _totalCurrentDebt = _interestToPay.add(creditLineVariables[_id].principal);
        uint256 _principalPaid = 0;

        if (_amount >= _totalCurrentDebt) {
            _amount = _totalCurrentDebt;
            emit CompleteCreditLineRepaid(_id, _amount);
        } else {
            emit PartialCreditLineRepaid(_id, _amount);
        }

        if (_amount > _interestToPay) {
            creditLineVariables[_id].principal = _totalCurrentDebt.sub(_amount);
            creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _totalInterestAccrued;
            creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;
            creditLineVariables[_id].totalInterestRepaid = _totalInterestAccrued;
            _principalPaid = _amount.sub(_interestToPay);
        } else {
            creditLineVariables[_id].totalInterestRepaid = creditLineVariables[_id].totalInterestRepaid.add(_amount);
        }

        _repay(_id, _amount, _fromSavingsAccount, _principalPaid);

        if (creditLineVariables[_id].principal == 0) {
            _resetCreditLine(_id);
        }
    }

    function _resetCreditLine(uint256 _id) internal {
        creditLineVariables[_id].lastPrincipalUpdateTime = 0;
        creditLineVariables[_id].totalInterestRepaid = 0;
        creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = 0;
        emit CreditLineReset(_id);
    }

    /**
     * @dev used to close credit line by borrower or lender
     * @param _id identifier for the credit line
     */
    function close(uint256 _id) external ifCreditLineExists(_id) {
        require(
            msg.sender == creditLineConstants[_id].borrower || msg.sender == creditLineConstants[_id].lender,
            'CreditLine: Permission denied while closing Line of credit'
        );
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: Credit line should be active.');
        require(creditLineVariables[_id].principal == 0, 'CreditLine: Cannot be closed since not repaid.');
        require(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate == 0, 'CreditLine: Cannot be closed since not repaid.');
        creditLineVariables[_id].status = CreditLineStatus.CLOSED;
        emit CreditLineClosed(_id);
    }

    /**
     * @notice used to calculate the current collateral ratio
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view.
            Interest is also considered while calculating debt
     * @param _id identifier for the credit line
     * @return collateral ratio multiplied by 10**30 to retain precision
     */
    function calculateCurrentCollateralRatio(uint256 _id) public ifCreditLineExists(_id) returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(
            creditLineConstants[_id].collateralAsset,
            creditLineConstants[_id].borrowAsset
        );

        uint256 currentDebt = calculateCurrentDebt(_id);
        uint256 currentCollateralRatio = calculateTotalCollateralTokens(_id).mul(_ratioOfPrices).div(currentDebt).mul(10**30).div(
            10**_decimals
        );

        return currentCollateralRatio;
    }

    /**
     * @notice used to calculate the total collateral tokens
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @param _id identifier for the credit line
     * @return _amount total collateral tokens deposited into the credit line
     */
    function calculateTotalCollateralTokens(uint256 _id) public returns (uint256 _amount) {
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        uint256 _liquidityShares;
        for (uint256 index = 0; index < _strategyList.length; index++) {
            if (_strategyList[index] == address(0)) {
                continue;
            }
            _liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];
            uint256 _tokenInStrategy = _liquidityShares;
            _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(_liquidityShares, _collateralAsset);

            _amount = _amount.add(_tokenInStrategy);
        }
    }

    /**
     * @notice used to withdraw any excess collateral
     * @dev collateral can't be withdraw if collateralRatio goes below the ideal value. Only borrower can withdraw
     * @param _id identifier for the credit line
     * @param _amount amount of collateral to withdraw
     * @param _toSavingsAccount if true, tokens are transferred from savingsAccount 
                                otherwise direct from collateral token contract
     */
    function withdrawCollateral(
        uint256 _id,
        uint256 _amount,
        bool _toSavingsAccount
    ) external nonReentrant onlyCreditLineBorrower(_id) {
        uint256 _withdrawableCollateral = withdrawableCollateral(_id);
        require(_amount <= _withdrawableCollateral, 'Collateral ratio cant go below ideal');
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        _transferCollateral(_id, _collateralAsset, _amount, _toSavingsAccount);
        emit CollateralWithdrawn(_id, _amount);
    }

    /**
     * @notice used to calculate the collateral that can be withdrawn
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @param _id identifier for the credit line
     * @return total collateral withdrawable by borrower
     */
    function withdrawableCollateral(uint256 _id) public returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(
            creditLineConstants[_id].collateralAsset,
            creditLineConstants[_id].borrowAsset
        );

        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);
        uint256 _currentDebt = calculateCurrentDebt(_id);

        uint256 _collateralNeeded = _currentDebt
            .mul(creditLineConstants[_id].idealCollateralRatio)
            .div(_ratioOfPrices)
            .mul(10**_decimals)
            .div(10**30);

        if (_collateralNeeded >= _totalCollateralTokens) {
            return 0;
        }
        return _totalCollateralTokens.sub(_collateralNeeded);
    }

    function _transferCollateral(
        uint256 _id,
        address _asset,
        uint256 _amountInTokens,
        bool _toSavingsAccount
    ) internal {
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        uint256 _activeAmount;
        for (uint256 index = 0; index < _strategyList.length; index++) {
            uint256 liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];
            if (liquidityShares == 0 || _strategyList[index] == address(0)) {
                continue;
            }
            uint256 _tokenInStrategy = liquidityShares;
            _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(liquidityShares, _asset);
            uint256 _tokensToTransfer = _tokenInStrategy;
            if (_activeAmount.add(_tokenInStrategy) > _amountInTokens) {
                _tokensToTransfer = _amountInTokens.sub(_activeAmount);
                liquidityShares = liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy);
            }
            _activeAmount = _activeAmount.add(_tokensToTransfer);
            collateralShareInStrategy[_id][_strategyList[index]] = collateralShareInStrategy[_id][_strategyList[index]].sub(
                liquidityShares
            );
            if (_toSavingsAccount) {
                ISavingsAccount(savingsAccount).transfer(_tokensToTransfer, _asset, _strategyList[index], msg.sender);
            } else {
                ISavingsAccount(savingsAccount).withdraw(_tokensToTransfer, _asset, _strategyList[index], msg.sender, false);
            }

            if (_activeAmount == _amountInTokens) {
                return;
            }
        }
        revert('insufficient collateral');
    }

    /**
     * @notice used to liquidate credit line in case collateral ratio goes below the threshold
     * @dev if lender liquidates, then collateral is directly transferred. 
            If autoLiquidation is true, anyone can liquidate by providing enough borrow tokens
     * @param _id identifier for the credit line
     * @param _toSavingsAccount if true, tokens are transferred from savingsAccount 
                                otherwise direct from collateral token contract
     */
    function liquidate(uint256 _id, bool _toSavingsAccount) external payable nonReentrant {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: Credit line should be active.');
        require(creditLineVariables[_id].principal != 0, 'CreditLine: cannot liquidate if principal is 0');

        uint256 currentCollateralRatio = calculateCurrentCollateralRatio(_id);
        require(
            currentCollateralRatio < creditLineConstants[_id].idealCollateralRatio,
            'CreditLine: Collateral ratio is higher than ideal value'
        );

        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        address _lender = creditLineConstants[_id].lender;
        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);
        address _borrowAsset = creditLineConstants[_id].borrowAsset;

        creditLineVariables[_id].status = CreditLineStatus.LIQUIDATED;

        if (creditLineConstants[_id].autoLiquidation && _lender != msg.sender) {
            uint256 _borrowTokens = _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens);
            if (_borrowAsset == address(0)) {
                uint256 _returnETH = msg.value.sub(_borrowTokens, 'Insufficient ETH to liquidate');
                if (_returnETH != 0) {
                    (bool success, ) = msg.sender.call{value: _returnETH}('');
                    require(success, 'Transfer fail');
                }
            } else {
                IERC20(_borrowAsset).safeTransferFrom(msg.sender, _lender, _borrowTokens);
            }
        }

        _transferCollateral(_id, _collateralAsset, _totalCollateralTokens, _toSavingsAccount);

        emit CreditLineLiquidated(_id, msg.sender);
    }

    /**
     * @notice used to calculate the borrow tokens necessary for liquidator to liquidate
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @param _id identifier for the credit line
     * @return borrow tokens necessary for liquidator to liquidate
     */
    function borrowTokensToLiquidate(uint256 _id) external returns (uint256) {
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);
        address _borrowAsset = creditLineConstants[_id].borrowAsset;

        return _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens);
    }

    function _borrowTokensToLiquidate(
        address _borrowAsset,
        address _collateralAsset,
        uint256 _totalCollateralTokens
    ) internal view returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(_borrowAsset, _collateralAsset);
        uint256 _borrowTokens = (
            _totalCollateralTokens.mul(uint256(10**30).sub(liquidatorRewardFraction)).div(10**30).mul(_ratioOfPrices).div(10**_decimals)
        );

        return _borrowTokens;
    }

    receive() external payable {
        require(msg.sender == savingsAccount, 'CreditLine::receive invalid transaction');
    }
}
.]

###

[2024-22-08 11:43:28 INFO] **[Seminar Conclusion]**:

 ###

[2024-22-08 11:43:28 INFO] **[Execute Detail]**

execute SimplePhase:[BugsSummary] in ComposedPhase:[CodeReview], cycle 2

[2024-22-08 11:43:28 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol'; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/utils/ReentrancyGuard.sol'; import '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol'; import '../interfaces/IPriceOracle.sol'; import '../interfaces/IYield.sol'; import '../interfaces/ISavingsAccount.sol'; import '../SavingsAccount/SavingsAccountUtil.sol'; import '../interfaces/IStrategyRegistry.sol'; /  * @title Credit Line contract with Methods related to credit Line  * @notice Implements the functions related to Credit Line  * @author Sublime  / contract CreditLine is ReentrancyGuard, OwnableUpgradeable {     using SafeERC20 for IERC20;     using SafeMath for uint256; enum CreditLineStatus {     NOT_CREATED,     REQUESTED,     ACTIVE,     CLOSED,     CANCELLED,     LIQUIDATED }  /**  * @notice counter that tracks the number of credit lines created  * @dev used to create unique identifier for credit lines  **/ uint256 public creditLineCounter;  uint256 constant YEAR_IN_SECONDS = 365 days;  struct CreditLineVariables {     CreditLineStatus status;     uint256 principal;     uint256 totalInterestRepaid;     uint256 lastPrincipalUpdateTime;     uint256 interestAccruedTillLastPrincipalUpdate; }  struct CreditLineConstants {     address lender;     address borrower;     uint256 borrowLimit;     uint256 idealCollateralRatio;     uint256 borrowRate;     address borrowAsset;     address collateralAsset;     bool autoLiquidation;     bool requestByLender; } /**  * @notice stores the collateral shares in a credit line per strategy  * @dev creditLineId =&gt; Strategy =&gt; collateralShares  **/ mapping(uint256 =&gt; mapping(address =&gt; uint256)) public collateralShareInStrategy;  /**  * @notice stores the variables to maintain a credit line  **/ mapping(uint256 =&gt; CreditLineVariables) public creditLineVariables;  /**  * @notice stores the constants related to a credit line  **/ mapping(uint256 =&gt; CreditLineConstants) public creditLineConstants;  /**  * @notice stores the address of savings account contract  **/ address public savingsAccount;  /**  * @notice stores the address of price oracle contract  **/ address public priceOracle;  /**  * @notice stores the address of strategy registry contract  **/ address public strategyRegistry;  /**  * @notice stores the address of default strategy  **/ address public defaultStrategy;  /**  * @notice stores the fraction of borrowed amount charged as fee by protocol  * @dev it is multiplied by 10**30  **/ uint256 public protocolFeeFraction;  /**  * @notice address where protocol fee is collected  **/ address public protocolFeeCollector;  /**  * @notice stores the fraction of amount liquidated given as reward to liquidator  * @dev it is multiplied by 10**30  **/ uint256 public liquidatorRewardFraction; /**  * @dev checks if Credit Line exists  * @param _id identifier for the credit line  **/ modifier ifCreditLineExists(uint256 _id) {     require(creditLineVariables[_id].status != CreditLineStatus.NOT_CREATED, 'Credit line does not exist');     _; }  /**  * @dev checks if called by credit Line Borrower  * @param _id creditLine identifier  **/ modifier onlyCreditLineBorrower(uint256 _id) {     require(creditLineConstants[_id].borrower == msg.sender, 'Only credit line Borrower can access');     _; }  /**  * @dev checks if called by credit Line Lender  * @param _id creditLine identifier  **/ modifier onlyCreditLineLender(uint256 _id) {     require(creditLineConstants[_id].lender == msg.sender, 'Only credit line Lender can access');     _; }  /**  * @notice emitted when a collateral is deposited into credit line  * @param id id of the credit line  * @param amount amount of collateral deposited  * @param strategy address of the strategy into which collateral is deposited  */ event CollateralDeposited(uint256 indexed id, uint256 amount, address indexed strategy);  /**  * @notice emitted when collateral is withdrawn from credit line  * @param id id of the credit line  * @param amount amount of collateral withdrawn  */ event CollateralWithdrawn(uint256 indexed id, uint256 amount);  /**  * @notice emitted when a request for new credit line is placed  * @param id id of the credit line for which request was made  * @param lender address of the lender for credit line  * @param borrower address of the borrower for credit line  */ event CreditLineRequested(uint256 indexed id, address indexed lender, address indexed borrower);  /**  * @notice emitted when a credit line is liquidated  * @param id id of the credit line which is liquidated  * @param liquidator address of the liquidator  */ event CreditLineLiquidated(uint256 indexed id, address indexed liquidator);  /**  * @notice emitted when tokens are borrowed from credit line  * @param id id of the credit line from which tokens are borrowed  * @param borrowAmount amount of tokens borrowed  */ event BorrowedFromCreditLine(uint256 indexed id, uint256 borrowAmount);  /**  * @notice emitted when credit line is accepted  * @param id id of the credit line that was accepted  */ event CreditLineAccepted(uint256 indexed id);  /**  * @notice emitted when credit line is completely repaid and reset  * @param id id of the credit line that is reset  */ event CreditLineReset(uint256 indexed id);  /**  * @notice emitted when the credit line is partially repaid  * @param id id of the credit line  * @param repayAmount amount repaid  */ event PartialCreditLineRepaid(uint256 indexed id, uint256 repayAmount);  /**  * @notice emitted when the credit line is completely repaid  * @param id id of the credit line  * @param repayAmount amount repaid  */ event CompleteCreditLineRepaid(uint256 indexed id, uint256 repayAmount);  /**  * @notice emitted when the credit line is closed by one of the parties of credit line  * @param id id of the credit line  */ event CreditLineClosed(uint256 indexed id);  /**  * @notice emitted when default strategy for the credit line is updated  * @param defaultStrategy address of the strategy contract that is used as default by credit lines  */ event DefaultStrategyUpdated(address indexed defaultStrategy);  /**  * @notice emitted when the price oracle is updated  * @param priceOracle address of the updated price oracle  */ event PriceOracleUpdated(address indexed priceOracle);  /**  * @notice emitted when the savings account address is updated  * @param savingsAccount address of the updated savingsAccount  */ event SavingsAccountUpdated(address indexed savingsAccount);  /**  * @notice emitted when strategy registry address is updated  * @param strategyRegistry address of the updated strategy registry  */ event StrategyRegistryUpdated(address indexed strategyRegistry);  /**  * @notice emitted when fee that protocol charges for credit line is updated  * @param updatedProtocolFee updated value of protocolFeeFraction  */ event ProtocolFeeFractionUpdated(uint256 updatedProtocolFee);  /**  * @notice emitted when address which receives fee that protocol changes for pools is updated  * @param updatedProtocolFeeCollector updated value of protocolFeeCollector  */ event ProtocolFeeCollectorUpdated(address indexed updatedProtocolFeeCollector);  /**  * @notice emitted when liquidatorRewardFraction is updated  * @param liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator  */ event LiquidationRewardFractionUpdated(uint256 liquidatorRewardFraction);  /**  * @notice used to initialize the contract  * @dev can only be called once during the life cycle of the contract  * @param _defaultStrategy default strategy used in credit lines  * @param _priceOracle address of the priceOracle  * @param _savingsAccount address of  the savings account contract  * @param _strategyRegistry address of the strategy registry contract  * @param _owner address of owner who can change global variables  * @param _protocolFeeFraction fraction of the fee charged by protocol  * @param _protocolFeeCollector address to which protocol fee is charged to  * @param _liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator  */ function initialize(     address _defaultStrategy,     address _priceOracle,     address _savingsAccount,     address _strategyRegistry,     address _owner,     uint256 _protocolFeeFraction,     address _protocolFeeCollector,     uint256 _liquidatorRewardFraction ) external initializer {     OwnableUpgradeable.__Ownable_init();     OwnableUpgradeable.transferOwnership(_owner);      _updateDefaultStrategy(_defaultStrategy);     _updatePriceOracle(_priceOracle);     _updateSavingsAccount(_savingsAccount);     _updateStrategyRegistry(_strategyRegistry);     _updateProtocolFeeFraction(_protocolFeeFraction);     _updateProtocolFeeCollector(_protocolFeeCollector);     _updateLiquidatorRewardFraction(_liquidatorRewardFraction); }  /**  * @notice used to update the default strategy  * @dev can only be updated by owner  * @param _defaultStrategy address of the updated default strategy  */ function updateDefaultStrategy(address _defaultStrategy) external onlyOwner {     _updateDefaultStrategy(_defaultStrategy); }  function _updateDefaultStrategy(address _defaultStrategy) internal {     defaultStrategy = _defaultStrategy;     emit DefaultStrategyUpdated(_defaultStrategy); }  /**  * @notice used to update the price oracle  * @dev can only be updated by owner  * @param _priceOracle address of the updated price oracle  */ function updatePriceOracle(address _priceOracle) external onlyOwner {     _updatePriceOracle(_priceOracle); }  function _updatePriceOracle(address _priceOracle) internal {     priceOracle = _priceOracle;     emit PriceOracleUpdated(_priceOracle); }  /**  * @notice used to update the savings account address  * @dev can only be updated by owner  * @param _savingsAccount address of the updated savings account  */ function updateSavingsAccount(address _savingsAccount) external onlyOwner {     _updateSavingsAccount(_savingsAccount); }  function _updateSavingsAccount(address _savingsAccount) internal {     savingsAccount = _savingsAccount;     emit SavingsAccountUpdated(_savingsAccount); }  /**  * @notice used to update the protocol fee fraction  * @dev can only be updated by owner  * @param _protocolFee fraction of the borrower amount collected as protocol fee  */ function updateProtocolFeeFraction(uint256 _protocolFee) external onlyOwner {     _updateProtocolFeeFraction(_protocolFee); }  function _updateProtocolFeeFraction(uint256 _protocolFee) internal {     protocolFeeFraction = _protocolFee;     emit ProtocolFeeFractionUpdated(_protocolFee); }  /**  * @notice used to update the protocol fee collector  * @dev can only be updated by owner  * @param _protocolFeeCollector address in which protocol fee is collected  */ function updateProtocolFeeCollector(address _protocolFeeCollector) external onlyOwner {     _updateProtocolFeeCollector(_protocolFeeCollector); }  function _updateProtocolFeeCollector(address _protocolFeeCollector) internal {     require(_protocolFeeCollector != address(0), 'cant be 0 address');     protocolFeeCollector = _protocolFeeCollector;     emit ProtocolFeeCollectorUpdated(_protocolFeeCollector); }  /**  * @notice used to update the strategy registry address  * @dev can only be updated by owner  * @param _strategyRegistry address of the updated strategy registry  */ function updateStrategyRegistry(address _strategyRegistry) external onlyOwner {     _updateStrategyRegistry(_strategyRegistry); }  function _updateStrategyRegistry(address _strategyRegistry) internal {     require(_strategyRegistry != address(0), 'CL::I zero address');     strategyRegistry = _strategyRegistry;     emit StrategyRegistryUpdated(_strategyRegistry); }  /**  * @notice used to update the liquidatorRewardFraction  * @dev can only be updated by owner  * @param _rewardFraction fraction of liquidated amount given to liquidator as reward  */ function updateLiquidatorRewardFraction(uint256 _rewardFraction) external onlyOwner {     _updateLiquidatorRewardFraction(_rewardFraction); }  function _updateLiquidatorRewardFraction(uint256 _rewardFraction) internal {     require(_rewardFraction &lt;= 10**30, 'Fraction has to be less than 1');     liquidatorRewardFraction = _rewardFraction;     emit LiquidationRewardFractionUpdated(_rewardFraction); }  /**  * @dev Used to Calculate Interest Per second on given principal and Interest rate  * @param _principal principal Amount for which interest has to be calculated.  * @param _borrowRate It is the Interest Rate at which Credit Line is approved  * @return interest per second for the given parameters  */ function calculateInterest(     uint256 _principal,     uint256 _borrowRate,     uint256 _timeElapsed ) public pure returns (uint256) {     uint256 _interest = _principal.mul(_borrowRate).mul(_timeElapsed).div(10**30).div(YEAR_IN_SECONDS);      return _interest; }  /**  * @dev Used to calculate interest accrued since last repayment  * @param _id identifier for the credit line  * @return interest accrued over current borrowed amount since last repayment  */  function calculateInterestAccrued(uint256 _id) public view returns (uint256) {     uint256 _lastPrincipalUpdateTime = creditLineVariables[_id].lastPrincipalUpdateTime;     if (_lastPrincipalUpdateTime == 0) return 0;     uint256 _timeElapsed = (block.timestamp).sub(_lastPrincipalUpdateTime);     uint256 _interestAccrued = calculateInterest(creditLineVariables[_id].principal, creditLineConstants[_id].borrowRate, _timeElapsed);     return _interestAccrued; }  /**  * @dev Used to calculate current debt of borrower against a credit line.  * @param _id identifier for the credit line  * @return current debt of borrower  */ function calculateCurrentDebt(uint256 _id) public view returns (uint256) {     uint256 _interestAccrued = calculateInterestAccrued(_id);     uint256 _currentDebt = (creditLineVariables[_id].principal)         .add(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate)         .add(_interestAccrued)         .sub(creditLineVariables[_id].totalInterestRepaid);     return _currentDebt; }  /**  * @notice used to calculate amount that can be borrowed by the borrower  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view.         borrowableAmount changes per block as interest changes per block.  * @param _id identifier for the credit line  * @return amount that can be borrowed from the credit line  */ function calculateBorrowableAmount(uint256 _id) public returns (uint256) {     CreditLineStatus _status = creditLineVariables[_id].status;     require(         _status == CreditLineStatus.ACTIVE || _status == CreditLineStatus.REQUESTED,         'CreditLine: Cannot only if credit line ACTIVE or REQUESTED'     );     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(         creditLineConstants[_id].collateralAsset,         creditLineConstants[_id].borrowAsset     );      uint256 _totalCollateralToken = calculateTotalCollateralTokens(_id);      uint256 _currentDebt = calculateCurrentDebt(_id);      uint256 _maxPossible = _totalCollateralToken.mul(_ratioOfPrices).div(creditLineConstants[_id].idealCollateralRatio).mul(10**30).div(         10**_decimals     );      uint256 _borrowLimit = creditLineConstants[_id].borrowLimit;      if (_maxPossible &gt; _borrowLimit) {         _maxPossible = _borrowLimit;     }     if (_maxPossible &gt; _currentDebt) {         return _maxPossible.sub(_currentDebt);     }     return 0; }  function updateinterestAccruedTillLastPrincipalUpdate(uint256 _id) internal {     require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');      uint256 _interestAccrued = calculateInterestAccrued(_id);     uint256 _newInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(_interestAccrued);     creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _newInterestAccrued; }  function _depositCollateralFromSavingsAccount(     uint256 _id,     uint256 _amount,     address _sender ) internal {     address _collateralAsset = creditLineConstants[_id].collateralAsset;     address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();     ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);     uint256 _activeAmount;      for (uint256 _index = 0; _index &lt; _strategyList.length; _index++) {         address _strategy = _strategyList[_index];         uint256 _liquidityShares = _savingsAccount.balanceInShares(_sender, _collateralAsset, _strategy);         if (_liquidityShares == 0 || _strategyList[_index] == address(0)) {             continue;         }         uint256 _tokenInStrategy = _liquidityShares;         _tokenInStrategy = IYield(_strategy).getTokensForShares(_liquidityShares, _collateralAsset);          uint256 _tokensToTransfer = _tokenInStrategy;         if (_activeAmount.add(_tokenInStrategy) &gt;= _amount) {             _tokensToTransfer = (_amount.sub(_activeAmount));         }         _activeAmount = _activeAmount.add(_tokensToTransfer);         _savingsAccount.transferFrom(_tokensToTransfer, _collateralAsset, _strategy, _sender, address(this));          collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(             _liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy)         );          if (_amount == _activeAmount) {             return;         }     }     revert('CreditLine::_depositCollateralFromSavingsAccount - Insufficient balance'); }  /**  * @notice used to request a credit line either by borrower or lender  * @param _requestTo Address to which creditLine is requested,                      if borrower creates request then lender address and                      if lender creates then borrower address  * @param _borrowLimit maximum borrow amount in a credit line  * @param _borrowRate Interest Rate at which credit Line is requested  * @param _autoLiquidation if true, anyone can liquidate loan, otherwise only lender  * @param _collateralRatio ratio of the collateral to the debt below which credit line can be liquidated  * @param _borrowAsset address of the token to be borrowed  * @param _collateralAsset address of the token provided as collateral  * @param _requestAsLender if true, lender is placing request, otherwise borrower  * @return identifier for the credit line  */  function request(     address _requestTo,     uint256 _borrowLimit,     uint256 _borrowRate,     bool _autoLiquidation,     uint256 _collateralRatio,     address _borrowAsset,     address _collateralAsset,     bool _requestAsLender ) external returns (uint256) {     require(_borrowAsset != _collateralAsset, 'R: cant borrow lent token');     require(IPriceOracle(priceOracle).doesFeedExist(_borrowAsset, _collateralAsset), 'R: No price feed');      address _lender = _requestTo;     address _borrower = msg.sender;     if (_requestAsLender) {         _lender = msg.sender;         _borrower = _requestTo;     }      uint256 _id = _createRequest(         _lender,         _borrower,         _borrowLimit,         _borrowRate,         _autoLiquidation,         _collateralRatio,         _borrowAsset,         _collateralAsset,         _requestAsLender     );      emit CreditLineRequested(_id, _lender, _borrower);     return _id; }  function _createRequest(     address _lender,     address _borrower,     uint256 _borrowLimit,     uint256 _borrowRate,     bool _autoLiquidation,     uint256 _collateralRatio,     address _borrowAsset,     address _collateralAsset,     bool _requestByLender ) internal returns (uint256) {     require(_lender != _borrower, 'Lender and Borrower cannot be same addresses');     uint256 _id = creditLineCounter + 1;     creditLineCounter = _id;     creditLineVariables[_id].status = CreditLineStatus.REQUESTED;     creditLineConstants[_id].borrower = _borrower;     creditLineConstants[_id].lender = _lender;     creditLineConstants[_id].borrowLimit = _borrowLimit;     creditLineConstants[_id].autoLiquidation = _autoLiquidation;     creditLineConstants[_id].idealCollateralRatio = _collateralRatio;     creditLineConstants[_id].borrowRate = _borrowRate;     creditLineConstants[_id].borrowAsset = _borrowAsset;     creditLineConstants[_id].collateralAsset = _collateralAsset;     creditLineConstants[_id].requestByLender = _requestByLender;     return _id; }  /**  * @notice used to accept a credit line  * @dev if borrower places request, lender can accept and vice versa  * @param _id identifier for the credit line  */ function accept(uint256 _id) external {     require(         creditLineVariables[_id].status == CreditLineStatus.REQUESTED,         'CreditLine::acceptCreditLineLender - CreditLine is already accepted'     );     bool _requestByLender = creditLineConstants[_id].requestByLender;     require(         (msg.sender == creditLineConstants[_id].borrower &amp;&amp; _requestByLender) ||             (msg.sender == creditLineConstants[_id].lender &amp;&amp; !_requestByLender),         "Only Borrower or Lender who hasn't requested can accept"     );     creditLineVariables[_id].status = CreditLineStatus.ACTIVE;     emit CreditLineAccepted(_id); }  /**  * @notice used to deposit collateral into the credit line  * @dev collateral tokens have to be approved in savingsAccount or token contract(unless ether).         If transferred from savings account, the tokens are transferred from strategies in the          order prespecified in strategy registry  * @param _id identifier for the credit line  * @param _amount amount of collateral being deposited  * @param _strategy strategy to which collateral is to be deposited in case transfer is not from savings account  * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount                              otherwise direct from collateral token contract  */ function depositCollateral(     uint256 _id,     uint256 _amount,     address _strategy,     bool _fromSavingsAccount ) external payable nonReentrant ifCreditLineExists(_id) {     require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine not active');     _depositCollateral(_id, _amount, _strategy, _fromSavingsAccount);     emit CollateralDeposited(_id, _amount, _strategy); }  function _depositCollateral(     uint256 _id,     uint256 _amount,     address _strategy,     bool _fromSavingsAccount ) internal {     require(creditLineConstants[_id].lender != msg.sender, 'lender cant deposit collateral');     if (_fromSavingsAccount) {         _depositCollateralFromSavingsAccount(_id, _amount, msg.sender);     } else {         address _collateralAsset = creditLineConstants[_id].collateralAsset;         ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);         if (_collateralAsset == address(0)) {             require(msg.value == _amount, "CreditLine::_depositCollateral - value to transfer doesn't match argument");         } else {             IERC20(_collateralAsset).safeTransferFrom(msg.sender, address(this), _amount);             IERC20(_collateralAsset).approve(_strategy, _amount);         }         uint256 _sharesReceived = _savingsAccount.deposit{value: msg.value}(_amount, _collateralAsset, _strategy, address(this));         collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(_sharesReceived);     } }  function _withdrawBorrowAmount(     address _asset,     uint256 _amountInTokens,     address _lender ) internal {     address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();     ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);     uint256 _activeAmount;     for (uint256 _index = 0; _index &lt; _strategyList.length; _index++) {         if (_strategyList[_index] == address(0)) {             continue;         }         uint256 _liquidityShares = _savingsAccount.balanceInShares(_lender, _asset, _strategyList[_index]);         if (_liquidityShares != 0) {             uint256 tokenInStrategy = _liquidityShares;             tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);             uint256 _tokensToTransfer = tokenInStrategy;             if (_activeAmount.add(tokenInStrategy) &gt;= _amountInTokens) {                 _tokensToTransfer = (_amountInTokens.sub(_activeAmount));             }             _activeAmount = _activeAmount.add(_tokensToTransfer);             _savingsAccount.withdrawFrom(_tokensToTransfer, _asset, _strategyList[_index], _lender, address(this), false);             if (_activeAmount == _amountInTokens) {                 return;             }         }     }     require(_activeAmount == _amountInTokens, 'insufficient balance'); }  /**  * @notice used to borrow tokens from credit line by borrower  * @dev only borrower can call this function. Amount that can actually be borrowed is          min(amount based on borrowLimit, allowance to creditLine contract, balance of lender)  * @param _id identifier for the credit line  * @param _amount amount of tokens to borrow  */ function borrow(uint256 _id, uint256 _amount) external payable nonReentrant onlyCreditLineBorrower(_id) {     require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');     uint256 _borrowableAmount = calculateBorrowableAmount(_id);     require(_amount &lt;= _borrowableAmount, "CreditLine::borrow - The current collateral ratio doesn't allow to withdraw the amount");     address _borrowAsset = creditLineConstants[_id].borrowAsset;     address _lender = creditLineConstants[_id].lender;      updateinterestAccruedTillLastPrincipalUpdate(_id);     creditLineVariables[_id].principal = creditLineVariables[_id].principal.add(_amount);     creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;      uint256 _tokenDiffBalance;     if (_borrowAsset != address(0)) {         uint256 _balanceBefore = IERC20(_borrowAsset).balanceOf(address(this));         _withdrawBorrowAmount(_borrowAsset, _amount, _lender);         uint256 _balanceAfter = IERC20(_borrowAsset).balanceOf(address(this));         _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);     } else {         uint256 _balanceBefore = address(this).balance;         _withdrawBorrowAmount(_borrowAsset, _amount, _lender);         uint256 _balanceAfter = address(this).balance;         _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);     }     uint256 _protocolFee = _tokenDiffBalance.mul(protocolFeeFraction).div(10**30);     _tokenDiffBalance = _tokenDiffBalance.sub(_protocolFee);      if (_borrowAsset == address(0)) {         (bool feeSuccess, ) = protocolFeeCollector.call{value: _protocolFee}('');         require(feeSuccess, 'Transfer fail');         (bool success, ) = msg.sender.call{value: _tokenDiffBalance}('');         require(success, 'Transfer fail');     } else {         IERC20(_borrowAsset).safeTransfer(protocolFeeCollector, _protocolFee);         IERC20(_borrowAsset).safeTransfer(msg.sender, _tokenDiffBalance);     }     emit BorrowedFromCreditLine(_id, _tokenDiffBalance); }  function _repayFromSavingsAccount(     uint256 _amount,     address _asset,     address _lender ) internal {     address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();     ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);     uint256 _activeAmount;      for (uint256 _index = 0; _index &lt; _strategyList.length; _index++) {         if (_strategyList[_index] == address(0)) {             continue;         }         uint256 _liquidityShares = _savingsAccount.balanceInShares(msg.sender, _asset, _strategyList[_index]);         if (_liquidityShares == 0) {             continue;         }         uint256 _tokenInStrategy = _liquidityShares;         _tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);          uint256 _tokensToTransfer = _tokenInStrategy;         if (_activeAmount.add(_tokenInStrategy) &gt;= _amount) {             _tokensToTransfer = (_amount.sub(_activeAmount));         }         _activeAmount = _activeAmount.add(_tokensToTransfer);         _savingsAccount.transferFrom(_tokensToTransfer, _asset, _strategyList[_index], msg.sender, _lender);          if (_amount == _activeAmount) {             return;         }     }     revert('CreditLine::_repayFromSavingsAccount - Insufficient balance'); }  function _repay(     uint256 _id,     uint256 _amount,     bool _fromSavingsAccount,     uint256 _principalPaid ) internal {     ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);     address _defaultStrategy = defaultStrategy;     address _borrowAsset = creditLineConstants[_id].borrowAsset;     address _lender = creditLineConstants[_id].lender;     if (!_fromSavingsAccount) {         if (_borrowAsset == address(0)) {             require(msg.value == _amount, 'creditLine::repay - Ether sent not equal to repay amount');             _savingsAccount.deposit{value: _amount}(_amount, _borrowAsset, _defaultStrategy, _lender);         } else {             IERC20(_borrowAsset).safeTransferFrom(msg.sender, address(this), _amount);             IERC20(_borrowAsset).approve(_defaultStrategy, _amount);             _savingsAccount.deposit(_amount, _borrowAsset, _defaultStrategy, _lender);         }     } else {         _repayFromSavingsAccount(_amount, _borrowAsset, _lender);     }     if (_principalPaid != 0) {         _savingsAccount.increaseAllowanceToCreditLine(_principalPaid, _borrowAsset, _lender);     } }  /**  * @notice used to repay interest and principal to credit line. Interest has to be repaid before repaying principal  * @dev partial repayments possible  * @param _id identifier for the credit line  * @param _amount amount being repaid  * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount                              otherwise direct from collateral token contract  */ function repay(     uint256 _id,     uint256 _amount,     bool _fromSavingsAccount ) external payable nonReentrant {     require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');     require(creditLineConstants[_id].lender != msg.sender, 'Lender cant repay');      uint256 _interestSincePrincipalUpdate = calculateInterestAccrued(_id);     uint256 _totalInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(         _interestSincePrincipalUpdate     );     uint256 _interestToPay = _totalInterestAccrued.sub(creditLineVariables[_id].totalInterestRepaid);     uint256 _totalCurrentDebt = _interestToPay.add(creditLineVariables[_id].principal);     uint256 _principalPaid = 0;      if (_amount &gt;= _totalCurrentDebt) {         _amount = _totalCurrentDebt;         emit CompleteCreditLineRepaid(_id, _amount);     } else {         emit PartialCreditLineRepaid(_id, _amount);     }      if (_amount &gt; _interestToPay) {         creditLineVariables[_id].principal = _totalCurrentDebt.sub(_amount);         creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _totalInterestAccrued;         creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;         creditLineVariables[_id].totalInterestRepaid = _totalInterestAccrued;         _principalPaid = _amount.sub(_interestToPay);     } else {         creditLineVariables[_id].totalInterestRepaid = creditLineVariables[_id].totalInterestRepaid.add(_amount);     }      _repay(_id, _amount, _fromSavingsAccount, _principalPaid);      if (creditLineVariables[_id].principal == 0) {         _resetCreditLine(_id);     } }  function _resetCreditLine(uint256 _id) internal {     creditLineVariables[_id].lastPrincipalUpdateTime = 0;     creditLineVariables[_id].totalInterestRepaid = 0;     creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = 0;     emit CreditLineReset(_id); }  /**  * @dev used to close credit line by borrower or lender  * @param _id identifier for the credit line  */ function close(uint256 _id) external ifCreditLineExists(_id) {     require(         msg.sender == creditLineConstants[_id].borrower || msg.sender == creditLineConstants[_id].lender,         'CreditLine: Permission denied while closing Line of credit'     );     require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: Credit line should be active.');     require(creditLineVariables[_id].principal == 0, 'CreditLine: Cannot be closed since not repaid.');     require(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate == 0, 'CreditLine: Cannot be closed since not repaid.');     creditLineVariables[_id].status = CreditLineStatus.CLOSED;     emit CreditLineClosed(_id); }  /**  * @notice used to calculate the current collateral ratio  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view.         Interest is also considered while calculating debt  * @param _id identifier for the credit line  * @return collateral ratio multiplied by 10**30 to retain precision  */ function calculateCurrentCollateralRatio(uint256 _id) public ifCreditLineExists(_id) returns (uint256) {     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(         creditLineConstants[_id].collateralAsset,         creditLineConstants[_id].borrowAsset     );      uint256 currentDebt = calculateCurrentDebt(_id);     uint256 currentCollateralRatio = calculateTotalCollateralTokens(_id).mul(_ratioOfPrices).div(currentDebt).mul(10**30).div(         10**_decimals     );      return currentCollateralRatio; }  /**  * @notice used to calculate the total collateral tokens  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view  * @param _id identifier for the credit line  * @return _amount total collateral tokens deposited into the credit line  */ function calculateTotalCollateralTokens(uint256 _id) public returns (uint256 _amount) {     address _collateralAsset = creditLineConstants[_id].collateralAsset;     address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();     uint256 _liquidityShares;     for (uint256 index = 0; index &lt; _strategyList.length; index++) {         if (_strategyList[index] == address(0)) {             continue;         }         _liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];         uint256 _tokenInStrategy = _liquidityShares;         _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(_liquidityShares, _collateralAsset);          _amount = _amount.add(_tokenInStrategy);     } }  /**  * @notice used to withdraw any excess collateral  * @dev collateral can't be withdraw if collateralRatio goes below the ideal value. Only borrower can withdraw  * @param _id identifier for the credit line  * @param _amount amount of collateral to withdraw  * @param _toSavingsAccount if true, tokens are transferred from savingsAccount                              otherwise direct from collateral token contract  */ function withdrawCollateral(     uint256 _id,     uint256 _amount,     bool _toSavingsAccount ) external nonReentrant onlyCreditLineBorrower(_id) {     uint256 _withdrawableCollateral = withdrawableCollateral(_id);     require(_amount &lt;= _withdrawableCollateral, 'Collateral ratio cant go below ideal');     address _collateralAsset = creditLineConstants[_id].collateralAsset;     _transferCollateral(_id, _collateralAsset, _amount, _toSavingsAccount);     emit CollateralWithdrawn(_id, _amount); }  /**  * @notice used to calculate the collateral that can be withdrawn  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view  * @param _id identifier for the credit line  * @return total collateral withdrawable by borrower  */ function withdrawableCollateral(uint256 _id) public returns (uint256) {     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(         creditLineConstants[_id].collateralAsset,         creditLineConstants[_id].borrowAsset     );      uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);     uint256 _currentDebt = calculateCurrentDebt(_id);      uint256 _collateralNeeded = _currentDebt         .mul(creditLineConstants[_id].idealCollateralRatio)         .div(_ratioOfPrices)         .mul(10**_decimals)         .div(10**30);      if (_collateralNeeded &gt;= _totalCollateralTokens) {         return 0;     }     return _totalCollateralTokens.sub(_collateralNeeded); }  function _transferCollateral(     uint256 _id,     address _asset,     uint256 _amountInTokens,     bool _toSavingsAccount ) internal {     address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();     uint256 _activeAmount;     for (uint256 index = 0; index &lt; _strategyList.length; index++) {         uint256 liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];         if (liquidityShares == 0 || _strategyList[index] == address(0)) {             continue;         }         uint256 _tokenInStrategy = liquidityShares;         _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(liquidityShares, _asset);         uint256 _tokensToTransfer = _tokenInStrategy;         if (_activeAmount.add(_tokenInStrategy) &gt; _amountInTokens) {             _tokensToTransfer = _amountInTokens.sub(_activeAmount);             liquidityShares = liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy);         }         _activeAmount = _activeAmount.add(_tokensToTransfer);         collateralShareInStrategy[_id][_strategyList[index]] = collateralShareInStrategy[_id][_strategyList[index]].sub(             liquidityShares         );         if (_toSavingsAccount) {             ISavingsAccount(savingsAccount).transfer(_tokensToTransfer, _asset, _strategyList[index], msg.sender);         } else {             ISavingsAccount(savingsAccount).withdraw(_tokensToTransfer, _asset, _strategyList[index], msg.sender, false);         }          if (_activeAmount == _amountInTokens) {             return;         }     }     revert('insufficient collateral'); }  /**  * @notice used to liquidate credit line in case collateral ratio goes below the threshold  * @dev if lender liquidates, then collateral is directly transferred.          If autoLiquidation is true, anyone can liquidate by providing enough borrow tokens  * @param _id identifier for the credit line  * @param _toSavingsAccount if true, tokens are transferred from savingsAccount                              otherwise direct from collateral token contract  */ function liquidate(uint256 _id, bool _toSavingsAccount) external payable nonReentrant {     require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: Credit line should be active.');     require(creditLineVariables[_id].principal != 0, 'CreditLine: cannot liquidate if principal is 0');      uint256 currentCollateralRatio = calculateCurrentCollateralRatio(_id);     require(         currentCollateralRatio &lt; creditLineConstants[_id].idealCollateralRatio,         'CreditLine: Collateral ratio is higher than ideal value'     );      address _collateralAsset = creditLineConstants[_id].collateralAsset;     address _lender = creditLineConstants[_id].lender;     uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);     address _borrowAsset = creditLineConstants[_id].borrowAsset;      creditLineVariables[_id].status = CreditLineStatus.LIQUIDATED;      if (creditLineConstants[_id].autoLiquidation &amp;&amp; _lender != msg.sender) {         uint256 _borrowTokens = _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens);         if (_borrowAsset == address(0)) {             uint256 _returnETH = msg.value.sub(_borrowTokens, 'Insufficient ETH to liquidate');             if (_returnETH != 0) {                 (bool success, ) = msg.sender.call{value: _returnETH}('');                 require(success, 'Transfer fail');             }         } else {             IERC20(_borrowAsset).safeTransferFrom(msg.sender, _lender, _borrowTokens);         }     }      _transferCollateral(_id, _collateralAsset, _totalCollateralTokens, _toSavingsAccount);      emit CreditLineLiquidated(_id, msg.sender); }  /**  * @notice used to calculate the borrow tokens necessary for liquidator to liquidate  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view  * @param _id identifier for the credit line  * @return borrow tokens necessary for liquidator to liquidate  */ function borrowTokensToLiquidate(uint256 _id) external returns (uint256) {     address _collateralAsset = creditLineConstants[_id].collateralAsset;     uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);     address _borrowAsset = creditLineConstants[_id].borrowAsset;      return _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens); }  function _borrowTokensToLiquidate(     address _borrowAsset,     address _collateralAsset,     uint256 _totalCollateralTokens ) internal view returns (uint256) {     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(_borrowAsset, _collateralAsset);     uint256 _borrowTokens = (         _totalCollateralTokens.mul(uint256(10**30).sub(liquidatorRewardFraction)).div(10**30).mul(_ratioOfPrices).div(10**_decimals)     );      return _borrowTokens; }  receive() external payable {     require(msg.sender == savingsAccount, 'CreditLine::receive invalid transaction'); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **phase_prompt** | Below are the details of our smart contract codes and their corresponding analysis reports: Task: "{task}". As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report. |
| **phase_name** | BugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 2, 'task': '', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-22-08 11:43:28 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol'; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/utils/ReentrancyGuard.sol'; import '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol'; import '../interfaces/IPriceOracle.sol'; import '../interfaces/IYield.sol'; import '../interfaces/ISavingsAccount.sol'; import '../SavingsAccount/SavingsAccountUtil.sol'; import '../interfaces/IStrategyRegistry.sol'; /  * @title Credit Line contract with Methods related to credit Line  * @notice Implements the functions related to Credit Line  * @author Sublime  / contract CreditLine is ReentrancyGuard, OwnableUpgradeable {     using SafeERC20 for IERC20;     using SafeMath for uint256; enum CreditLineStatus {     NOT_CREATED,     REQUESTED,     ACTIVE,     CLOSED,     CANCELLED,     LIQUIDATED }  /**  * @notice counter that tracks the number of credit lines created  * @dev used to create unique identifier for credit lines  **/ uint256 public creditLineCounter;  uint256 constant YEAR_IN_SECONDS = 365 days;  struct CreditLineVariables {     CreditLineStatus status;     uint256 principal;     uint256 totalInterestRepaid;     uint256 lastPrincipalUpdateTime;     uint256 interestAccruedTillLastPrincipalUpdate; }  struct CreditLineConstants {     address lender;     address borrower;     uint256 borrowLimit;     uint256 idealCollateralRatio;     uint256 borrowRate;     address borrowAsset;     address collateralAsset;     bool autoLiquidation;     bool requestByLender; } /**  * @notice stores the collateral shares in a credit line per strategy  * @dev creditLineId =&gt; Strategy =&gt; collateralShares  **/ mapping(uint256 =&gt; mapping(address =&gt; uint256)) public collateralShareInStrategy;  /**  * @notice stores the variables to maintain a credit line  **/ mapping(uint256 =&gt; CreditLineVariables) public creditLineVariables;  /**  * @notice stores the constants related to a credit line  **/ mapping(uint256 =&gt; CreditLineConstants) public creditLineConstants;  /**  * @notice stores the address of savings account contract  **/ address public savingsAccount;  /**  * @notice stores the address of price oracle contract  **/ address public priceOracle;  /**  * @notice stores the address of strategy registry contract  **/ address public strategyRegistry;  /**  * @notice stores the address of default strategy  **/ address public defaultStrategy;  /**  * @notice stores the fraction of borrowed amount charged as fee by protocol  * @dev it is multiplied by 10**30  **/ uint256 public protocolFeeFraction;  /**  * @notice address where protocol fee is collected  **/ address public protocolFeeCollector;  /**  * @notice stores the fraction of amount liquidated given as reward to liquidator  * @dev it is multiplied by 10**30  **/ uint256 public liquidatorRewardFraction; /**  * @dev checks if Credit Line exists  * @param _id identifier for the credit line  **/ modifier ifCreditLineExists(uint256 _id) {     require(creditLineVariables[_id].status != CreditLineStatus.NOT_CREATED, 'Credit line does not exist');     _; }  /**  * @dev checks if called by credit Line Borrower  * @param _id creditLine identifier  **/ modifier onlyCreditLineBorrower(uint256 _id) {     require(creditLineConstants[_id].borrower == msg.sender, 'Only credit line Borrower can access');     _; }  /**  * @dev checks if called by credit Line Lender  * @param _id creditLine identifier  **/ modifier onlyCreditLineLender(uint256 _id) {     require(creditLineConstants[_id].lender == msg.sender, 'Only credit line Lender can access');     _; }  /**  * @notice emitted when a collateral is deposited into credit line  * @param id id of the credit line  * @param amount amount of collateral deposited  * @param strategy address of the strategy into which collateral is deposited  */ event CollateralDeposited(uint256 indexed id, uint256 amount, address indexed strategy);  /**  * @notice emitted when collateral is withdrawn from credit line  * @param id id of the credit line  * @param amount amount of collateral withdrawn  */ event CollateralWithdrawn(uint256 indexed id, uint256 amount);  /**  * @notice emitted when a request for new credit line is placed  * @param id id of the credit line for which request was made  * @param lender address of the lender for credit line  * @param borrower address of the borrower for credit line  */ event CreditLineRequested(uint256 indexed id, address indexed lender, address indexed borrower);  /**  * @notice emitted when a credit line is liquidated  * @param id id of the credit line which is liquidated  * @param liquidator address of the liquidator  */ event CreditLineLiquidated(uint256 indexed id, address indexed liquidator);  /**  * @notice emitted when tokens are borrowed from credit line  * @param id id of the credit line from which tokens are borrowed  * @param borrowAmount amount of tokens borrowed  */ event BorrowedFromCreditLine(uint256 indexed id, uint256 borrowAmount);  /**  * @notice emitted when credit line is accepted  * @param id id of the credit line that was accepted  */ event CreditLineAccepted(uint256 indexed id);  /**  * @notice emitted when credit line is completely repaid and reset  * @param id id of the credit line that is reset  */ event CreditLineReset(uint256 indexed id);  /**  * @notice emitted when the credit line is partially repaid  * @param id id of the credit line  * @param repayAmount amount repaid  */ event PartialCreditLineRepaid(uint256 indexed id, uint256 repayAmount);  /**  * @notice emitted when the credit line is completely repaid  * @param id id of the credit line  * @param repayAmount amount repaid  */ event CompleteCreditLineRepaid(uint256 indexed id, uint256 repayAmount);  /**  * @notice emitted when the credit line is closed by one of the parties of credit line  * @param id id of the credit line  */ event CreditLineClosed(uint256 indexed id);  /**  * @notice emitted when default strategy for the credit line is updated  * @param defaultStrategy address of the strategy contract that is used as default by credit lines  */ event DefaultStrategyUpdated(address indexed defaultStrategy);  /**  * @notice emitted when the price oracle is updated  * @param priceOracle address of the updated price oracle  */ event PriceOracleUpdated(address indexed priceOracle);  /**  * @notice emitted when the savings account address is updated  * @param savingsAccount address of the updated savingsAccount  */ event SavingsAccountUpdated(address indexed savingsAccount);  /**  * @notice emitted when strategy registry address is updated  * @param strategyRegistry address of the updated strategy registry  */ event StrategyRegistryUpdated(address indexed strategyRegistry);  /**  * @notice emitted when fee that protocol charges for credit line is updated  * @param updatedProtocolFee updated value of protocolFeeFraction  */ event ProtocolFeeFractionUpdated(uint256 updatedProtocolFee);  /**  * @notice emitted when address which receives fee that protocol changes for pools is updated  * @param updatedProtocolFeeCollector updated value of protocolFeeCollector  */ event ProtocolFeeCollectorUpdated(address indexed updatedProtocolFeeCollector);  /**  * @notice emitted when liquidatorRewardFraction is updated  * @param liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator  */ event LiquidationRewardFractionUpdated(uint256 liquidatorRewardFraction);  /**  * @notice used to initialize the contract  * @dev can only be called once during the life cycle of the contract  * @param _defaultStrategy default strategy used in credit lines  * @param _priceOracle address of the priceOracle  * @param _savingsAccount address of  the savings account contract  * @param _strategyRegistry address of the strategy registry contract  * @param _owner address of owner who can change global variables  * @param _protocolFeeFraction fraction of the fee charged by protocol  * @param _protocolFeeCollector address to which protocol fee is charged to  * @param _liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator  */ function initialize(     address _defaultStrategy,     address _priceOracle,     address _savingsAccount,     address _strategyRegistry,     address _owner,     uint256 _protocolFeeFraction,     address _protocolFeeCollector,     uint256 _liquidatorRewardFraction ) external initializer {     OwnableUpgradeable.__Ownable_init();     OwnableUpgradeable.transferOwnership(_owner);      _updateDefaultStrategy(_defaultStrategy);     _updatePriceOracle(_priceOracle);     _updateSavingsAccount(_savingsAccount);     _updateStrategyRegistry(_strategyRegistry);     _updateProtocolFeeFraction(_protocolFeeFraction);     _updateProtocolFeeCollector(_protocolFeeCollector);     _updateLiquidatorRewardFraction(_liquidatorRewardFraction); }  /**  * @notice used to update the default strategy  * @dev can only be updated by owner  * @param _defaultStrategy address of the updated default strategy  */ function updateDefaultStrategy(address _defaultStrategy) external onlyOwner {     _updateDefaultStrategy(_defaultStrategy); }  function _updateDefaultStrategy(address _defaultStrategy) internal {     defaultStrategy = _defaultStrategy;     emit DefaultStrategyUpdated(_defaultStrategy); }  /**  * @notice used to update the price oracle  * @dev can only be updated by owner  * @param _priceOracle address of the updated price oracle  */ function updatePriceOracle(address _priceOracle) external onlyOwner {     _updatePriceOracle(_priceOracle); }  function _updatePriceOracle(address _priceOracle) internal {     priceOracle = _priceOracle;     emit PriceOracleUpdated(_priceOracle); }  /**  * @notice used to update the savings account address  * @dev can only be updated by owner  * @param _savingsAccount address of the updated savings account  */ function updateSavingsAccount(address _savingsAccount) external onlyOwner {     _updateSavingsAccount(_savingsAccount); }  function _updateSavingsAccount(address _savingsAccount) internal {     savingsAccount = _savingsAccount;     emit SavingsAccountUpdated(_savingsAccount); }  /**  * @notice used to update the protocol fee fraction  * @dev can only be updated by owner  * @param _protocolFee fraction of the borrower amount collected as protocol fee  */ function updateProtocolFeeFraction(uint256 _protocolFee) external onlyOwner {     _updateProtocolFeeFraction(_protocolFee); }  function _updateProtocolFeeFraction(uint256 _protocolFee) internal {     protocolFeeFraction = _protocolFee;     emit ProtocolFeeFractionUpdated(_protocolFee); }  /**  * @notice used to update the protocol fee collector  * @dev can only be updated by owner  * @param _protocolFeeCollector address in which protocol fee is collected  */ function updateProtocolFeeCollector(address _protocolFeeCollector) external onlyOwner {     _updateProtocolFeeCollector(_protocolFeeCollector); }  function _updateProtocolFeeCollector(address _protocolFeeCollector) internal {     require(_protocolFeeCollector != address(0), 'cant be 0 address');     protocolFeeCollector = _protocolFeeCollector;     emit ProtocolFeeCollectorUpdated(_protocolFeeCollector); }  /**  * @notice used to update the strategy registry address  * @dev can only be updated by owner  * @param _strategyRegistry address of the updated strategy registry  */ function updateStrategyRegistry(address _strategyRegistry) external onlyOwner {     _updateStrategyRegistry(_strategyRegistry); }  function _updateStrategyRegistry(address _strategyRegistry) internal {     require(_strategyRegistry != address(0), 'CL::I zero address');     strategyRegistry = _strategyRegistry;     emit StrategyRegistryUpdated(_strategyRegistry); }  /**  * @notice used to update the liquidatorRewardFraction  * @dev can only be updated by owner  * @param _rewardFraction fraction of liquidated amount given to liquidator as reward  */ function updateLiquidatorRewardFraction(uint256 _rewardFraction) external onlyOwner {     _updateLiquidatorRewardFraction(_rewardFraction); }  function _updateLiquidatorRewardFraction(uint256 _rewardFraction) internal {     require(_rewardFraction &lt;= 10**30, 'Fraction has to be less than 1');     liquidatorRewardFraction = _rewardFraction;     emit LiquidationRewardFractionUpdated(_rewardFraction); }  /**  * @dev Used to Calculate Interest Per second on given principal and Interest rate  * @param _principal principal Amount for which interest has to be calculated.  * @param _borrowRate It is the Interest Rate at which Credit Line is approved  * @return interest per second for the given parameters  */ function calculateInterest(     uint256 _principal,     uint256 _borrowRate,     uint256 _timeElapsed ) public pure returns (uint256) {     uint256 _interest = _principal.mul(_borrowRate).mul(_timeElapsed).div(10**30).div(YEAR_IN_SECONDS);      return _interest; }  /**  * @dev Used to calculate interest accrued since last repayment  * @param _id identifier for the credit line  * @return interest accrued over current borrowed amount since last repayment  */  function calculateInterestAccrued(uint256 _id) public view returns (uint256) {     uint256 _lastPrincipalUpdateTime = creditLineVariables[_id].lastPrincipalUpdateTime;     if (_lastPrincipalUpdateTime == 0) return 0;     uint256 _timeElapsed = (block.timestamp).sub(_lastPrincipalUpdateTime);     uint256 _interestAccrued = calculateInterest(creditLineVariables[_id].principal, creditLineConstants[_id].borrowRate, _timeElapsed);     return _interestAccrued; }  /**  * @dev Used to calculate current debt of borrower against a credit line.  * @param _id identifier for the credit line  * @return current debt of borrower  */ function calculateCurrentDebt(uint256 _id) public view returns (uint256) {     uint256 _interestAccrued = calculateInterestAccrued(_id);     uint256 _currentDebt = (creditLineVariables[_id].principal)         .add(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate)         .add(_interestAccrued)         .sub(creditLineVariables[_id].totalInterestRepaid);     return _currentDebt; }  /**  * @notice used to calculate amount that can be borrowed by the borrower  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view.         borrowableAmount changes per block as interest changes per block.  * @param _id identifier for the credit line  * @return amount that can be borrowed from the credit line  */ function calculateBorrowableAmount(uint256 _id) public returns (uint256) {     CreditLineStatus _status = creditLineVariables[_id].status;     require(         _status == CreditLineStatus.ACTIVE || _status == CreditLineStatus.REQUESTED,         'CreditLine: Cannot only if credit line ACTIVE or REQUESTED'     );     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(         creditLineConstants[_id].collateralAsset,         creditLineConstants[_id].borrowAsset     );      uint256 _totalCollateralToken = calculateTotalCollateralTokens(_id);      uint256 _currentDebt = calculateCurrentDebt(_id);      uint256 _maxPossible = _totalCollateralToken.mul(_ratioOfPrices).div(creditLineConstants[_id].idealCollateralRatio).mul(10**30).div(         10**_decimals     );      uint256 _borrowLimit = creditLineConstants[_id].borrowLimit;      if (_maxPossible &gt; _borrowLimit) {         _maxPossible = _borrowLimit;     }     if (_maxPossible &gt; _currentDebt) {         return _maxPossible.sub(_currentDebt);     }     return 0; }  function updateinterestAccruedTillLastPrincipalUpdate(uint256 _id) internal {     require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');      uint256 _interestAccrued = calculateInterestAccrued(_id);     uint256 _newInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(_interestAccrued);     creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _newInterestAccrued; }  function _depositCollateralFromSavingsAccount(     uint256 _id,     uint256 _amount,     address _sender ) internal {     address _collateralAsset = creditLineConstants[_id].collateralAsset;     address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();     ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);     uint256 _activeAmount;      for (uint256 _index = 0; _index &lt; _strategyList.length; _index++) {         address _strategy = _strategyList[_index];         uint256 _liquidityShares = _savingsAccount.balanceInShares(_sender, _collateralAsset, _strategy);         if (_liquidityShares == 0 || _strategyList[_index] == address(0)) {             continue;         }         uint256 _tokenInStrategy = _liquidityShares;         _tokenInStrategy = IYield(_strategy).getTokensForShares(_liquidityShares, _collateralAsset);          uint256 _tokensToTransfer = _tokenInStrategy;         if (_activeAmount.add(_tokenInStrategy) &gt;= _amount) {             _tokensToTransfer = (_amount.sub(_activeAmount));         }         _activeAmount = _activeAmount.add(_tokensToTransfer);         _savingsAccount.transferFrom(_tokensToTransfer, _collateralAsset, _strategy, _sender, address(this));          collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(             _liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy)         );          if (_amount == _activeAmount) {             return;         }     }     revert('CreditLine::_depositCollateralFromSavingsAccount - Insufficient balance'); }  /**  * @notice used to request a credit line either by borrower or lender  * @param _requestTo Address to which creditLine is requested,                      if borrower creates request then lender address and                      if lender creates then borrower address  * @param _borrowLimit maximum borrow amount in a credit line  * @param _borrowRate Interest Rate at which credit Line is requested  * @param _autoLiquidation if true, anyone can liquidate loan, otherwise only lender  * @param _collateralRatio ratio of the collateral to the debt below which credit line can be liquidated  * @param _borrowAsset address of the token to be borrowed  * @param _collateralAsset address of the token provided as collateral  * @param _requestAsLender if true, lender is placing request, otherwise borrower  * @return identifier for the credit line  */  function request(     address _requestTo,     uint256 _borrowLimit,     uint256 _borrowRate,     bool _autoLiquidation,     uint256 _collateralRatio,     address _borrowAsset,     address _collateralAsset,     bool _requestAsLender ) external returns (uint256) {     require(_borrowAsset != _collateralAsset, 'R: cant borrow lent token');     require(IPriceOracle(priceOracle).doesFeedExist(_borrowAsset, _collateralAsset), 'R: No price feed');      address _lender = _requestTo;     address _borrower = msg.sender;     if (_requestAsLender) {         _lender = msg.sender;         _borrower = _requestTo;     }      uint256 _id = _createRequest(         _lender,         _borrower,         _borrowLimit,         _borrowRate,         _autoLiquidation,         _collateralRatio,         _borrowAsset,         _collateralAsset,         _requestAsLender     );      emit CreditLineRequested(_id, _lender, _borrower);     return _id; }  function _createRequest(     address _lender,     address _borrower,     uint256 _borrowLimit,     uint256 _borrowRate,     bool _autoLiquidation,     uint256 _collateralRatio,     address _borrowAsset,     address _collateralAsset,     bool _requestByLender ) internal returns (uint256) {     require(_lender != _borrower, 'Lender and Borrower cannot be same addresses');     uint256 _id = creditLineCounter + 1;     creditLineCounter = _id;     creditLineVariables[_id].status = CreditLineStatus.REQUESTED;     creditLineConstants[_id].borrower = _borrower;     creditLineConstants[_id].lender = _lender;     creditLineConstants[_id].borrowLimit = _borrowLimit;     creditLineConstants[_id].autoLiquidation = _autoLiquidation;     creditLineConstants[_id].idealCollateralRatio = _collateralRatio;     creditLineConstants[_id].borrowRate = _borrowRate;     creditLineConstants[_id].borrowAsset = _borrowAsset;     creditLineConstants[_id].collateralAsset = _collateralAsset;     creditLineConstants[_id].requestByLender = _requestByLender;     return _id; }  /**  * @notice used to accept a credit line  * @dev if borrower places request, lender can accept and vice versa  * @param _id identifier for the credit line  */ function accept(uint256 _id) external {     require(         creditLineVariables[_id].status == CreditLineStatus.REQUESTED,         'CreditLine::acceptCreditLineLender - CreditLine is already accepted'     );     bool _requestByLender = creditLineConstants[_id].requestByLender;     require(         (msg.sender == creditLineConstants[_id].borrower &amp;&amp; _requestByLender) ||             (msg.sender == creditLineConstants[_id].lender &amp;&amp; !_requestByLender),         "Only Borrower or Lender who hasn't requested can accept"     );     creditLineVariables[_id].status = CreditLineStatus.ACTIVE;     emit CreditLineAccepted(_id); }  /**  * @notice used to deposit collateral into the credit line  * @dev collateral tokens have to be approved in savingsAccount or token contract(unless ether).         If transferred from savings account, the tokens are transferred from strategies in the          order prespecified in strategy registry  * @param _id identifier for the credit line  * @param _amount amount of collateral being deposited  * @param _strategy strategy to which collateral is to be deposited in case transfer is not from savings account  * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount                              otherwise direct from collateral token contract  */ function depositCollateral(     uint256 _id,     uint256 _amount,     address _strategy,     bool _fromSavingsAccount ) external payable nonReentrant ifCreditLineExists(_id) {     require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine not active');     _depositCollateral(_id, _amount, _strategy, _fromSavingsAccount);     emit CollateralDeposited(_id, _amount, _strategy); }  function _depositCollateral(     uint256 _id,     uint256 _amount,     address _strategy,     bool _fromSavingsAccount ) internal {     require(creditLineConstants[_id].lender != msg.sender, 'lender cant deposit collateral');     if (_fromSavingsAccount) {         _depositCollateralFromSavingsAccount(_id, _amount, msg.sender);     } else {         address _collateralAsset = creditLineConstants[_id].collateralAsset;         ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);         if (_collateralAsset == address(0)) {             require(msg.value == _amount, "CreditLine::_depositCollateral - value to transfer doesn't match argument");         } else {             IERC20(_collateralAsset).safeTransferFrom(msg.sender, address(this), _amount);             IERC20(_collateralAsset).approve(_strategy, _amount);         }         uint256 _sharesReceived = _savingsAccount.deposit{value: msg.value}(_amount, _collateralAsset, _strategy, address(this));         collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(_sharesReceived);     } }  function _withdrawBorrowAmount(     address _asset,     uint256 _amountInTokens,     address _lender ) internal {     address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();     ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);     uint256 _activeAmount;     for (uint256 _index = 0; _index &lt; _strategyList.length; _index++) {         if (_strategyList[_index] == address(0)) {             continue;         }         uint256 _liquidityShares = _savingsAccount.balanceInShares(_lender, _asset, _strategyList[_index]);         if (_liquidityShares != 0) {             uint256 tokenInStrategy = _liquidityShares;             tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);             uint256 _tokensToTransfer = tokenInStrategy;             if (_activeAmount.add(tokenInStrategy) &gt;= _amountInTokens) {                 _tokensToTransfer = (_amountInTokens.sub(_activeAmount));             }             _activeAmount = _activeAmount.add(_tokensToTransfer);             _savingsAccount.withdrawFrom(_tokensToTransfer, _asset, _strategyList[_index], _lender, address(this), false);             if (_activeAmount == _amountInTokens) {                 return;             }         }     }     require(_activeAmount == _amountInTokens, 'insufficient balance'); }  /**  * @notice used to borrow tokens from credit line by borrower  * @dev only borrower can call this function. Amount that can actually be borrowed is          min(amount based on borrowLimit, allowance to creditLine contract, balance of lender)  * @param _id identifier for the credit line  * @param _amount amount of tokens to borrow  */ function borrow(uint256 _id, uint256 _amount) external payable nonReentrant onlyCreditLineBorrower(_id) {     require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');     uint256 _borrowableAmount = calculateBorrowableAmount(_id);     require(_amount &lt;= _borrowableAmount, "CreditLine::borrow - The current collateral ratio doesn't allow to withdraw the amount");     address _borrowAsset = creditLineConstants[_id].borrowAsset;     address _lender = creditLineConstants[_id].lender;      updateinterestAccruedTillLastPrincipalUpdate(_id);     creditLineVariables[_id].principal = creditLineVariables[_id].principal.add(_amount);     creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;      uint256 _tokenDiffBalance;     if (_borrowAsset != address(0)) {         uint256 _balanceBefore = IERC20(_borrowAsset).balanceOf(address(this));         _withdrawBorrowAmount(_borrowAsset, _amount, _lender);         uint256 _balanceAfter = IERC20(_borrowAsset).balanceOf(address(this));         _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);     } else {         uint256 _balanceBefore = address(this).balance;         _withdrawBorrowAmount(_borrowAsset, _amount, _lender);         uint256 _balanceAfter = address(this).balance;         _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);     }     uint256 _protocolFee = _tokenDiffBalance.mul(protocolFeeFraction).div(10**30);     _tokenDiffBalance = _tokenDiffBalance.sub(_protocolFee);      if (_borrowAsset == address(0)) {         (bool feeSuccess, ) = protocolFeeCollector.call{value: _protocolFee}('');         require(feeSuccess, 'Transfer fail');         (bool success, ) = msg.sender.call{value: _tokenDiffBalance}('');         require(success, 'Transfer fail');     } else {         IERC20(_borrowAsset).safeTransfer(protocolFeeCollector, _protocolFee);         IERC20(_borrowAsset).safeTransfer(msg.sender, _tokenDiffBalance);     }     emit BorrowedFromCreditLine(_id, _tokenDiffBalance); }  function _repayFromSavingsAccount(     uint256 _amount,     address _asset,     address _lender ) internal {     address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();     ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);     uint256 _activeAmount;      for (uint256 _index = 0; _index &lt; _strategyList.length; _index++) {         if (_strategyList[_index] == address(0)) {             continue;         }         uint256 _liquidityShares = _savingsAccount.balanceInShares(msg.sender, _asset, _strategyList[_index]);         if (_liquidityShares == 0) {             continue;         }         uint256 _tokenInStrategy = _liquidityShares;         _tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);          uint256 _tokensToTransfer = _tokenInStrategy;         if (_activeAmount.add(_tokenInStrategy) &gt;= _amount) {             _tokensToTransfer = (_amount.sub(_activeAmount));         }         _activeAmount = _activeAmount.add(_tokensToTransfer);         _savingsAccount.transferFrom(_tokensToTransfer, _asset, _strategyList[_index], msg.sender, _lender);          if (_amount == _activeAmount) {             return;         }     }     revert('CreditLine::_repayFromSavingsAccount - Insufficient balance'); }  function _repay(     uint256 _id,     uint256 _amount,     bool _fromSavingsAccount,     uint256 _principalPaid ) internal {     ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);     address _defaultStrategy = defaultStrategy;     address _borrowAsset = creditLineConstants[_id].borrowAsset;     address _lender = creditLineConstants[_id].lender;     if (!_fromSavingsAccount) {         if (_borrowAsset == address(0)) {             require(msg.value == _amount, 'creditLine::repay - Ether sent not equal to repay amount');             _savingsAccount.deposit{value: _amount}(_amount, _borrowAsset, _defaultStrategy, _lender);         } else {             IERC20(_borrowAsset).safeTransferFrom(msg.sender, address(this), _amount);             IERC20(_borrowAsset).approve(_defaultStrategy, _amount);             _savingsAccount.deposit(_amount, _borrowAsset, _defaultStrategy, _lender);         }     } else {         _repayFromSavingsAccount(_amount, _borrowAsset, _lender);     }     if (_principalPaid != 0) {         _savingsAccount.increaseAllowanceToCreditLine(_principalPaid, _borrowAsset, _lender);     } }  /**  * @notice used to repay interest and principal to credit line. Interest has to be repaid before repaying principal  * @dev partial repayments possible  * @param _id identifier for the credit line  * @param _amount amount being repaid  * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount                              otherwise direct from collateral token contract  */ function repay(     uint256 _id,     uint256 _amount,     bool _fromSavingsAccount ) external payable nonReentrant {     require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');     require(creditLineConstants[_id].lender != msg.sender, 'Lender cant repay');      uint256 _interestSincePrincipalUpdate = calculateInterestAccrued(_id);     uint256 _totalInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(         _interestSincePrincipalUpdate     );     uint256 _interestToPay = _totalInterestAccrued.sub(creditLineVariables[_id].totalInterestRepaid);     uint256 _totalCurrentDebt = _interestToPay.add(creditLineVariables[_id].principal);     uint256 _principalPaid = 0;      if (_amount &gt;= _totalCurrentDebt) {         _amount = _totalCurrentDebt;         emit CompleteCreditLineRepaid(_id, _amount);     } else {         emit PartialCreditLineRepaid(_id, _amount);     }      if (_amount &gt; _interestToPay) {         creditLineVariables[_id].principal = _totalCurrentDebt.sub(_amount);         creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _totalInterestAccrued;         creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;         creditLineVariables[_id].totalInterestRepaid = _totalInterestAccrued;         _principalPaid = _amount.sub(_interestToPay);     } else {         creditLineVariables[_id].totalInterestRepaid = creditLineVariables[_id].totalInterestRepaid.add(_amount);     }      _repay(_id, _amount, _fromSavingsAccount, _principalPaid);      if (creditLineVariables[_id].principal == 0) {         _resetCreditLine(_id);     } }  function _resetCreditLine(uint256 _id) internal {     creditLineVariables[_id].lastPrincipalUpdateTime = 0;     creditLineVariables[_id].totalInterestRepaid = 0;     creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = 0;     emit CreditLineReset(_id); }  /**  * @dev used to close credit line by borrower or lender  * @param _id identifier for the credit line  */ function close(uint256 _id) external ifCreditLineExists(_id) {     require(         msg.sender == creditLineConstants[_id].borrower || msg.sender == creditLineConstants[_id].lender,         'CreditLine: Permission denied while closing Line of credit'     );     require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: Credit line should be active.');     require(creditLineVariables[_id].principal == 0, 'CreditLine: Cannot be closed since not repaid.');     require(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate == 0, 'CreditLine: Cannot be closed since not repaid.');     creditLineVariables[_id].status = CreditLineStatus.CLOSED;     emit CreditLineClosed(_id); }  /**  * @notice used to calculate the current collateral ratio  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view.         Interest is also considered while calculating debt  * @param _id identifier for the credit line  * @return collateral ratio multiplied by 10**30 to retain precision  */ function calculateCurrentCollateralRatio(uint256 _id) public ifCreditLineExists(_id) returns (uint256) {     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(         creditLineConstants[_id].collateralAsset,         creditLineConstants[_id].borrowAsset     );      uint256 currentDebt = calculateCurrentDebt(_id);     uint256 currentCollateralRatio = calculateTotalCollateralTokens(_id).mul(_ratioOfPrices).div(currentDebt).mul(10**30).div(         10**_decimals     );      return currentCollateralRatio; }  /**  * @notice used to calculate the total collateral tokens  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view  * @param _id identifier for the credit line  * @return _amount total collateral tokens deposited into the credit line  */ function calculateTotalCollateralTokens(uint256 _id) public returns (uint256 _amount) {     address _collateralAsset = creditLineConstants[_id].collateralAsset;     address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();     uint256 _liquidityShares;     for (uint256 index = 0; index &lt; _strategyList.length; index++) {         if (_strategyList[index] == address(0)) {             continue;         }         _liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];         uint256 _tokenInStrategy = _liquidityShares;         _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(_liquidityShares, _collateralAsset);          _amount = _amount.add(_tokenInStrategy);     } }  /**  * @notice used to withdraw any excess collateral  * @dev collateral can't be withdraw if collateralRatio goes below the ideal value. Only borrower can withdraw  * @param _id identifier for the credit line  * @param _amount amount of collateral to withdraw  * @param _toSavingsAccount if true, tokens are transferred from savingsAccount                              otherwise direct from collateral token contract  */ function withdrawCollateral(     uint256 _id,     uint256 _amount,     bool _toSavingsAccount ) external nonReentrant onlyCreditLineBorrower(_id) {     uint256 _withdrawableCollateral = withdrawableCollateral(_id);     require(_amount &lt;= _withdrawableCollateral, 'Collateral ratio cant go below ideal');     address _collateralAsset = creditLineConstants[_id].collateralAsset;     _transferCollateral(_id, _collateralAsset, _amount, _toSavingsAccount);     emit CollateralWithdrawn(_id, _amount); }  /**  * @notice used to calculate the collateral that can be withdrawn  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view  * @param _id identifier for the credit line  * @return total collateral withdrawable by borrower  */ function withdrawableCollateral(uint256 _id) public returns (uint256) {     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(         creditLineConstants[_id].collateralAsset,         creditLineConstants[_id].borrowAsset     );      uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);     uint256 _currentDebt = calculateCurrentDebt(_id);      uint256 _collateralNeeded = _currentDebt         .mul(creditLineConstants[_id].idealCollateralRatio)         .div(_ratioOfPrices)         .mul(10**_decimals)         .div(10**30);      if (_collateralNeeded &gt;= _totalCollateralTokens) {         return 0;     }     return _totalCollateralTokens.sub(_collateralNeeded); }  function _transferCollateral(     uint256 _id,     address _asset,     uint256 _amountInTokens,     bool _toSavingsAccount ) internal {     address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();     uint256 _activeAmount;     for (uint256 index = 0; index &lt; _strategyList.length; index++) {         uint256 liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];         if (liquidityShares == 0 || _strategyList[index] == address(0)) {             continue;         }         uint256 _tokenInStrategy = liquidityShares;         _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(liquidityShares, _asset);         uint256 _tokensToTransfer = _tokenInStrategy;         if (_activeAmount.add(_tokenInStrategy) &gt; _amountInTokens) {             _tokensToTransfer = _amountInTokens.sub(_activeAmount);             liquidityShares = liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy);         }         _activeAmount = _activeAmount.add(_tokensToTransfer);         collateralShareInStrategy[_id][_strategyList[index]] = collateralShareInStrategy[_id][_strategyList[index]].sub(             liquidityShares         );         if (_toSavingsAccount) {             ISavingsAccount(savingsAccount).transfer(_tokensToTransfer, _asset, _strategyList[index], msg.sender);         } else {             ISavingsAccount(savingsAccount).withdraw(_tokensToTransfer, _asset, _strategyList[index], msg.sender, false);         }          if (_activeAmount == _amountInTokens) {             return;         }     }     revert('insufficient collateral'); }  /**  * @notice used to liquidate credit line in case collateral ratio goes below the threshold  * @dev if lender liquidates, then collateral is directly transferred.          If autoLiquidation is true, anyone can liquidate by providing enough borrow tokens  * @param _id identifier for the credit line  * @param _toSavingsAccount if true, tokens are transferred from savingsAccount                              otherwise direct from collateral token contract  */ function liquidate(uint256 _id, bool _toSavingsAccount) external payable nonReentrant {     require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: Credit line should be active.');     require(creditLineVariables[_id].principal != 0, 'CreditLine: cannot liquidate if principal is 0');      uint256 currentCollateralRatio = calculateCurrentCollateralRatio(_id);     require(         currentCollateralRatio &lt; creditLineConstants[_id].idealCollateralRatio,         'CreditLine: Collateral ratio is higher than ideal value'     );      address _collateralAsset = creditLineConstants[_id].collateralAsset;     address _lender = creditLineConstants[_id].lender;     uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);     address _borrowAsset = creditLineConstants[_id].borrowAsset;      creditLineVariables[_id].status = CreditLineStatus.LIQUIDATED;      if (creditLineConstants[_id].autoLiquidation &amp;&amp; _lender != msg.sender) {         uint256 _borrowTokens = _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens);         if (_borrowAsset == address(0)) {             uint256 _returnETH = msg.value.sub(_borrowTokens, 'Insufficient ETH to liquidate');             if (_returnETH != 0) {                 (bool success, ) = msg.sender.call{value: _returnETH}('');                 require(success, 'Transfer fail');             }         } else {             IERC20(_borrowAsset).safeTransferFrom(msg.sender, _lender, _borrowTokens);         }     }      _transferCollateral(_id, _collateralAsset, _totalCollateralTokens, _toSavingsAccount);      emit CreditLineLiquidated(_id, msg.sender); }  /**  * @notice used to calculate the borrow tokens necessary for liquidator to liquidate  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view  * @param _id identifier for the credit line  * @return borrow tokens necessary for liquidator to liquidate  */ function borrowTokensToLiquidate(uint256 _id) external returns (uint256) {     address _collateralAsset = creditLineConstants[_id].collateralAsset;     uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);     address _borrowAsset = creditLineConstants[_id].borrowAsset;      return _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens); }  function _borrowTokensToLiquidate(     address _borrowAsset,     address _collateralAsset,     uint256 _totalCollateralTokens ) internal view returns (uint256) {     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(_borrowAsset, _collateralAsset);     uint256 _borrowTokens = (         _totalCollateralTokens.mul(uint256(10**30).sub(liquidatorRewardFraction)).div(10**30).mul(_ratioOfPrices).div(10**_decimals)     );      return _borrowTokens; }  receive() external payable {     require(msg.sender == savingsAccount, 'CreditLine::receive invalid transaction'); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-22-08 11:43:28 INFO] Security Analyst: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/utils/ReentrancyGuard.sol';
import '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';
import '../interfaces/IPriceOracle.sol';
import '../interfaces/IYield.sol';
import '../interfaces/ISavingsAccount.sol';
import '../SavingsAccount/SavingsAccountUtil.sol';
import '../interfaces/IStrategyRegistry.sol';

/**
 * @title Credit Line contract with Methods related to credit Line
 * @notice Implements the functions related to Credit Line
 * @author Sublime
 **/

contract CreditLine is ReentrancyGuard, OwnableUpgradeable {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    enum CreditLineStatus {
        NOT_CREATED,
        REQUESTED,
        ACTIVE,
        CLOSED,
        CANCELLED,
        LIQUIDATED
    }

    /**
     * @notice counter that tracks the number of credit lines created
     * @dev used to create unique identifier for credit lines
     **/
    uint256 public creditLineCounter;

    uint256 constant YEAR_IN_SECONDS = 365 days;

    struct CreditLineVariables {
        CreditLineStatus status;
        uint256 principal;
        uint256 totalInterestRepaid;
        uint256 lastPrincipalUpdateTime;
        uint256 interestAccruedTillLastPrincipalUpdate;
    }

    struct CreditLineConstants {
        address lender;
        address borrower;
        uint256 borrowLimit;
        uint256 idealCollateralRatio;
        uint256 borrowRate;
        address borrowAsset;
        address collateralAsset;
        bool autoLiquidation;
        bool requestByLender;
    }
    /**
     * @notice stores the collateral shares in a credit line per strategy
     * @dev creditLineId => Strategy => collateralShares
     **/
    mapping(uint256 => mapping(address => uint256)) public collateralShareInStrategy;

    /**
     * @notice stores the variables to maintain a credit line
     **/
    mapping(uint256 => CreditLineVariables) public creditLineVariables;

    /**
     * @notice stores the constants related to a credit line
     **/
    mapping(uint256 => CreditLineConstants) public creditLineConstants;

    /**
     * @notice stores the address of savings account contract
     **/
    address public savingsAccount;

    /**
     * @notice stores the address of price oracle contract
     **/
    address public priceOracle;

    /**
     * @notice stores the address of strategy registry contract
     **/
    address public strategyRegistry;

    /**
     * @notice stores the address of default strategy
     **/
    address public defaultStrategy;

    /**
     * @notice stores the fraction of borrowed amount charged as fee by protocol
     * @dev it is multiplied by 10**30
     **/
    uint256 public protocolFeeFraction;

    /**
     * @notice address where protocol fee is collected
     **/
    address public protocolFeeCollector;

    /**
     * @notice stores the fraction of amount liquidated given as reward to liquidator
     * @dev it is multiplied by 10**30
     **/
    uint256 public liquidatorRewardFraction;
    /**
     * @dev checks if Credit Line exists
     * @param _id identifier for the credit line
     **/
    modifier ifCreditLineExists(uint256 _id) {
        require(creditLineVariables[_id].status != CreditLineStatus.NOT_CREATED, 'Credit line does not exist');
        _;
    }

    /**
     * @dev checks if called by credit Line Borrower
     * @param _id creditLine identifier
     **/
    modifier onlyCreditLineBorrower(uint256 _id) {
        require(creditLineConstants[_id].borrower == msg.sender, 'Only credit line Borrower can access');
        _;
    }

    /**
     * @dev checks if called by credit Line Lender
     * @param _id creditLine identifier
     **/
    modifier onlyCreditLineLender(uint256 _id) {
        require(creditLineConstants[_id].lender == msg.sender, 'Only credit line Lender can access');
        _;
    }

    /**
     * @notice emitted when a collateral is deposited into credit line
     * @param id id of the credit line
     * @param amount amount of collateral deposited
     * @param strategy address of the strategy into which collateral is deposited
     */
    event CollateralDeposited(uint256 indexed id, uint256 amount, address indexed strategy);

    /**
     * @notice emitted when collateral is withdrawn from credit line
     * @param id id of the credit line
     * @param amount amount of collateral withdrawn
     */
    event CollateralWithdrawn(uint256 indexed id, uint256 amount);

    /**
     * @notice emitted when a request for new credit line is placed
     * @param id id of the credit line for which request was made
     * @param lender address of the lender for credit line
     * @param borrower address of the borrower for credit line
     */
    event CreditLineRequested(uint256 indexed id, address indexed lender, address indexed borrower);

    /**
     * @notice emitted when a credit line is liquidated
     * @param id id of the credit line which is liquidated
     * @param liquidator address of the liquidator
     */
    event CreditLineLiquidated(uint256 indexed id, address indexed liquidator);

    /**
     * @notice emitted when tokens are borrowed from credit line
     * @param id id of the credit line from which tokens are borrowed
     * @param borrowAmount amount of tokens borrowed
     */
    event BorrowedFromCreditLine(uint256 indexed id, uint256 borrowAmount);

    /**
     * @notice emitted when credit line is accepted
     * @param id id of the credit line that was accepted
     */
    event CreditLineAccepted(uint256 indexed id);

    /**
     * @notice emitted when credit line is completely repaid and reset
     * @param id id of the credit line that is reset
     */
    event CreditLineReset(uint256 indexed id);

    /**
     * @notice emitted when the credit line is partially repaid
     * @param id id of the credit line
     * @param repayAmount amount repaid
     */
    event PartialCreditLineRepaid(uint256 indexed id, uint256 repayAmount);

    /**
     * @notice emitted when the credit line is completely repaid
     * @param id id of the credit line
     * @param repayAmount amount repaid
     */
    event CompleteCreditLineRepaid(uint256 indexed id, uint256 repayAmount);

    /**
     * @notice emitted when the credit line is closed by one of the parties of credit line
     * @param id id of the credit line
     */
    event CreditLineClosed(uint256 indexed id);

    /**
     * @notice emitted when default strategy for the credit line is updated
     * @param defaultStrategy address of the strategy contract that is used as default by credit lines
     */
    event DefaultStrategyUpdated(address indexed defaultStrategy);

    /**
     * @notice emitted when the price oracle is updated
     * @param priceOracle address of the updated price oracle
     */
    event PriceOracleUpdated(address indexed priceOracle);

    /**
     * @notice emitted when the savings account address is updated
     * @param savingsAccount address of the updated savingsAccount
     */
    event SavingsAccountUpdated(address indexed savingsAccount);

    /**
     * @notice emitted when strategy registry address is updated
     * @param strategyRegistry address of the updated strategy registry
     */
    event StrategyRegistryUpdated(address indexed strategyRegistry);

    /**
     * @notice emitted when fee that protocol charges for credit line is updated
     * @param updatedProtocolFee updated value of protocolFeeFraction
     */
    event ProtocolFeeFractionUpdated(uint256 updatedProtocolFee);

    /**
     * @notice emitted when address which receives fee that protocol changes for pools is updated
     * @param updatedProtocolFeeCollector updated value of protocolFeeCollector
     */
    event ProtocolFeeCollectorUpdated(address indexed updatedProtocolFeeCollector);

    /**
     * @notice emitted when liquidatorRewardFraction is updated
     * @param liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator
     */
    event LiquidationRewardFractionUpdated(uint256 liquidatorRewardFraction);

    /**
     * @notice used to initialize the contract
     * @dev can only be called once during the life cycle of the contract
     * @param _defaultStrategy default strategy used in credit lines
     * @param _priceOracle address of the priceOracle
     * @param _savingsAccount address of  the savings account contract
     * @param _strategyRegistry address of the strategy registry contract
     * @param _owner address of owner who can change global variables
     * @param _protocolFeeFraction fraction of the fee charged by protocol
     * @param _protocolFeeCollector address to which protocol fee is charged to
     * @param _liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator
     */
    function initialize(
        address _defaultStrategy,
        address _priceOracle,
        address _savingsAccount,
        address _strategyRegistry,
        address _owner,
        uint256 _protocolFeeFraction,
        address _protocolFeeCollector,
        uint256 _liquidatorRewardFraction
    ) external initializer {
        OwnableUpgradeable.__Ownable_init();
        OwnableUpgradeable.transferOwnership(_owner);

        _updateDefaultStrategy(_defaultStrategy);
        _updatePriceOracle(_priceOracle);
        _updateSavingsAccount(_savingsAccount);
        _updateStrategyRegistry(_strategyRegistry);
        _updateProtocolFeeFraction(_protocolFeeFraction);
        _updateProtocolFeeCollector(_protocolFeeCollector);
        _updateLiquidatorRewardFraction(_liquidatorRewardFraction);
    }

    /**
     * @notice used to update the default strategy
     * @dev can only be updated by owner
     * @param _defaultStrategy address of the updated default strategy
     */
    function updateDefaultStrategy(address _defaultStrategy) external onlyOwner {
        _updateDefaultStrategy(_defaultStrategy);
    }

    function _updateDefaultStrategy(address _defaultStrategy) internal {
        defaultStrategy = _defaultStrategy;
        emit DefaultStrategyUpdated(_defaultStrategy);
    }

    /**
     * @notice used to update the price oracle
     * @dev can only be updated by owner
     * @param _priceOracle address of the updated price oracle
     */
    function updatePriceOracle(address _priceOracle) external onlyOwner {
        _updatePriceOracle(_priceOracle);
    }

    function _updatePriceOracle(address _priceOracle) internal {
        priceOracle = _priceOracle;
        emit PriceOracleUpdated(_priceOracle);
    }

    /**
     * @notice used to update the savings account address
     * @dev can only be updated by owner
     * @param _savingsAccount address of the updated savings account
     */
    function updateSavingsAccount(address _savingsAccount) external onlyOwner {
        _updateSavingsAccount(_savingsAccount);
    }

    function _updateSavingsAccount(address _savingsAccount) internal {
        savingsAccount = _savingsAccount;
        emit SavingsAccountUpdated(_savingsAccount);
    }

    /**
     * @notice used to update the protocol fee fraction
     * @dev can only be updated by owner
     * @param _protocolFee fraction of the borrower amount collected as protocol fee
     */
    function updateProtocolFeeFraction(uint256 _protocolFee) external onlyOwner {
        _updateProtocolFeeFraction(_protocolFee);
    }

    function _updateProtocolFeeFraction(uint256 _protocolFee) internal {
        protocolFeeFraction = _protocolFee;
        emit ProtocolFeeFractionUpdated(_protocolFee);
    }

    /**
     * @notice used to update the protocol fee collector
     * @dev can only be updated by owner
     * @param _protocolFeeCollector address in which protocol fee is collected
     */
    function updateProtocolFeeCollector(address _protocolFeeCollector) external onlyOwner {
        _updateProtocolFeeCollector(_protocolFeeCollector);
    }

    function _updateProtocolFeeCollector(address _protocolFeeCollector) internal {
        require(_protocolFeeCollector != address(0), 'cant be 0 address');
        protocolFeeCollector = _protocolFeeCollector;
        emit ProtocolFeeCollectorUpdated(_protocolFeeCollector);
    }

    /**
     * @notice used to update the strategy registry address
     * @dev can only be updated by owner
     * @param _strategyRegistry address of the updated strategy registry
     */
    function updateStrategyRegistry(address _strategyRegistry) external onlyOwner {
        _updateStrategyRegistry(_strategyRegistry);
    }

    function _updateStrategyRegistry(address _strategyRegistry) internal {
        require(_strategyRegistry != address(0), 'CL::I zero address');
        strategyRegistry = _strategyRegistry;
        emit StrategyRegistryUpdated(_strategyRegistry);
    }

    /**
     * @notice used to update the liquidatorRewardFraction
     * @dev can only be updated by owner
     * @param _rewardFraction fraction of liquidated amount given to liquidator as reward
     */
    function updateLiquidatorRewardFraction(uint256 _rewardFraction) external onlyOwner {
        _updateLiquidatorRewardFraction(_rewardFraction);
    }

    function _updateLiquidatorRewardFraction(uint256 _rewardFraction) internal {
        require(_rewardFraction <= 10**30, 'Fraction has to be less than 1');
        liquidatorRewardFraction = _rewardFraction;
        emit LiquidationRewardFractionUpdated(_rewardFraction);
    }

    /**
     * @dev Used to Calculate Interest Per second on given principal and Interest rate
     * @param _principal principal Amount for which interest has to be calculated.
     * @param _borrowRate It is the Interest Rate at which Credit Line is approved
     * @return interest per second for the given parameters
     */
    function calculateInterest(
        uint256 _principal,
        uint256 _borrowRate,
        uint256 _timeElapsed
    ) public pure returns (uint256) {
        uint256 _interest = _principal.mul(_borrowRate).mul(_timeElapsed).div(10**30).div(YEAR_IN_SECONDS);

        return _interest;
    }

    /**
     * @dev Used to calculate interest accrued since last repayment
     * @param _id identifier for the credit line
     * @return interest accrued over current borrowed amount since last repayment
     */

    function calculateInterestAccrued(uint256 _id) public view returns (uint256) {
        uint256 _lastPrincipalUpdateTime = creditLineVariables[_id].lastPrincipalUpdateTime;
        if (_lastPrincipalUpdateTime == 0) return 0;
        uint256 _timeElapsed = (block.timestamp).sub(_lastPrincipalUpdateTime);
        uint256 _interestAccrued = calculateInterest(creditLineVariables[_id].principal, creditLineConstants[_id].borrowRate, _timeElapsed);
        return _interestAccrued;
    }

    /**
     * @dev Used to calculate current debt of borrower against a credit line.
     * @param _id identifier for the credit line
     * @return current debt of borrower
     */
    function calculateCurrentDebt(uint256 _id) public view returns (uint256) {
        uint256 _interestAccrued = calculateInterestAccrued(_id);
        uint256 _currentDebt = (creditLineVariables[_id].principal)
            .add(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate)
            .add(_interestAccrued)
            .sub(creditLineVariables[_id].totalInterestRepaid);
        return _currentDebt;
    }

    /**
     * @notice used to calculate amount that can be borrowed by the borrower
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view.
            borrowableAmount changes per block as interest changes per block.
     * @param _id identifier for the credit line
     * @return amount that can be borrowed from the credit line
     */
    function calculateBorrowableAmount(uint256 _id) public returns (uint256) {
        CreditLineStatus _status = creditLineVariables[_id].status;
        require(
            _status == CreditLineStatus.ACTIVE || _status == CreditLineStatus.REQUESTED,
            'CreditLine: Cannot only if credit line ACTIVE or REQUESTED'
        );
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(
            creditLineConstants[_id].collateralAsset,
            creditLineConstants[_id].borrowAsset
        );

        uint256 _totalCollateralToken = calculateTotalCollateralTokens(_id);

        uint256 _currentDebt = calculateCurrentDebt(_id);

        uint256 _maxPossible = _totalCollateralToken.mul(_ratioOfPrices).div(creditLineConstants[_id].idealCollateralRatio).mul(10**30).div(
            10**_decimals
        );

        uint256 _borrowLimit = creditLineConstants[_id].borrowLimit;

        if (_maxPossible > _borrowLimit) {
            _maxPossible = _borrowLimit;
        }
        if (_maxPossible > _currentDebt) {
            return _maxPossible.sub(_currentDebt);
        }
        return 0;
    }

    function updateinterestAccruedTillLastPrincipalUpdate(uint256 _id) internal {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');

        uint256 _interestAccrued = calculateInterestAccrued(_id);
        uint256 _newInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(_interestAccrued);
        creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _newInterestAccrued;
    }

    function _depositCollateralFromSavingsAccount(
        uint256 _id,
        uint256 _amount,
        address _sender
    ) internal {
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        uint256 _activeAmount;

        for (uint256 _index = 0; _index < _strategyList.length; _index++) {
            address _strategy = _strategyList[_index];
            uint256 _liquidityShares = _savingsAccount.balanceInShares(_sender, _collateralAsset, _strategy);
            if (_liquidityShares == 0 || _strategyList[_index] == address(0)) {
                continue;
            }
            uint256 _tokenInStrategy = _liquidityShares;
            _tokenInStrategy = IYield(_strategy).getTokensForShares(_liquidityShares, _collateralAsset);

            uint256 _tokensToTransfer = _tokenInStrategy;
            if (_activeAmount.add(_tokenInStrategy) >= _amount) {
                _tokensToTransfer = (_amount.sub(_activeAmount));
            }
            _activeAmount = _activeAmount.add(_tokensToTransfer);
            _savingsAccount.transferFrom(_tokensToTransfer, _collateralAsset, _strategy, _sender, address(this));

            collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(
                _liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy)
            );

            if (_amount == _activeAmount) {
                return;
            }
        }
        revert('CreditLine::_depositCollateralFromSavingsAccount - Insufficient balance');
    }

    /**
     * @notice used to request a credit line either by borrower or lender
     * @param _requestTo Address to which creditLine is requested, 
                        if borrower creates request then lender address and 
                        if lender creates then borrower address
     * @param _borrowLimit maximum borrow amount in a credit line
     * @param _borrowRate Interest Rate at which credit Line is requested
     * @param _autoLiquidation if true, anyone can liquidate loan, otherwise only lender
     * @param _collateralRatio ratio of the collateral to the debt below which credit line can be liquidated
     * @param _borrowAsset address of the token to be borrowed
     * @param _collateralAsset address of the token provided as collateral
     * @param _requestAsLender if true, lender is placing request, otherwise borrower
     * @return identifier for the credit line
     */

    function request(
        address _requestTo,
        uint256 _borrowLimit,
        uint256 _borrowRate,
        bool _autoLiquidation,
        uint256 _collateralRatio,
        address _borrowAsset,
        address _collateralAsset,
        bool _requestAsLender
    ) external returns (uint256) {
        require(_borrowAsset != _collateralAsset, 'R: cant borrow lent token');
        require(IPriceOracle(priceOracle).doesFeedExist(_borrowAsset, _collateralAsset), 'R: No price feed');

        address _lender = _requestTo;
        address _borrower = msg.sender;
        if (_requestAsLender) {
            _lender = msg.sender;
            _borrower = _requestTo;
        }

        uint256 _id = _createRequest(
            _lender,
            _borrower,
            _borrowLimit,
            _borrowRate,
            _autoLiquidation,
            _collateralRatio,
            _borrowAsset,
            _collateralAsset,
            _requestAsLender
        );

        emit CreditLineRequested(_id, _lender, _borrower);
        return _id;
    }

    function _createRequest(
        address _lender,
        address _borrower,
        uint256 _borrowLimit,
        uint256 _borrowRate,
        bool _autoLiquidation,
        uint256 _collateralRatio,
        address _borrowAsset,
        address _collateralAsset,
        bool _requestByLender
    ) internal returns (uint256) {
        require(_lender != _borrower, 'Lender and Borrower cannot be same addresses');
        uint256 _id = creditLineCounter + 1;
        creditLineCounter = _id;
        creditLineVariables[_id].status = CreditLineStatus.REQUESTED;
        creditLineConstants[_id].borrower = _borrower;
        creditLineConstants[_id].lender = _lender;
        creditLineConstants[_id].borrowLimit = _borrowLimit;
        creditLineConstants[_id].autoLiquidation = _autoLiquidation;
        creditLineConstants[_id].idealCollateralRatio = _collateralRatio;
        creditLineConstants[_id].borrowRate = _borrowRate;
        creditLineConstants[_id].borrowAsset = _borrowAsset;
        creditLineConstants[_id].collateralAsset = _collateralAsset;
        creditLineConstants[_id].requestByLender = _requestByLender;
        return _id;
    }

    /**
     * @notice used to accept a credit line
     * @dev if borrower places request, lender can accept and vice versa
     * @param _id identifier for the credit line
     */
    function accept(uint256 _id) external {
        require(
            creditLineVariables[_id].status == CreditLineStatus.REQUESTED,
            'CreditLine::acceptCreditLineLender - CreditLine is already accepted'
        );
        bool _requestByLender = creditLineConstants[_id].requestByLender;
        require(
            (msg.sender == creditLineConstants[_id].borrower && _requestByLender) ||
                (msg.sender == creditLineConstants[_id].lender && !_requestByLender),
            "Only Borrower or Lender who hasn't requested can accept"
        );
        creditLineVariables[_id].status = CreditLineStatus.ACTIVE;
        emit CreditLineAccepted(_id);
    }

    /**
     * @notice used to deposit collateral into the credit line
     * @dev collateral tokens have to be approved in savingsAccount or token contract(unless ether).
            If transferred from savings account, the tokens are transferred from strategies in the 
            order prespecified in strategy registry
     * @param _id identifier for the credit line
     * @param _amount amount of collateral being deposited
     * @param _strategy strategy to which collateral is to be deposited in case transfer is not from savings account
     * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount 
                                otherwise direct from collateral token contract
     */
    function depositCollateral(
        uint256 _id,
        uint256 _amount,
        address _strategy,
        bool _fromSavingsAccount
    ) external payable nonReentrant ifCreditLineExists(_id) {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine not active');
        _depositCollateral(_id, _amount, _strategy, _fromSavingsAccount);
        emit CollateralDeposited(_id, _amount, _strategy);
    }

    function _depositCollateral(
        uint256 _id,
        uint256 _amount,
        address _strategy,
        bool _fromSavingsAccount
    ) internal {
        require(creditLineConstants[_id].lender != msg.sender, 'lender cant deposit collateral');
        if (_fromSavingsAccount) {
            _depositCollateralFromSavingsAccount(_id, _amount, msg.sender);
        } else {
            address _collateralAsset = creditLineConstants[_id].collateralAsset;
            ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
            if (_collateralAsset == address(0)) {
                require(msg.value == _amount, "CreditLine::_depositCollateral - value to transfer doesn't match argument");
            } else {
                IERC20(_collateralAsset).safeTransferFrom(msg.sender, address(this), _amount);
                IERC20(_collateralAsset).approve(_strategy, _amount);
            }
            uint256 _sharesReceived = _savingsAccount.deposit{value: msg.value}(_amount, _collateralAsset, _strategy, address(this));
            collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(_sharesReceived);
        }
    }

    function _withdrawBorrowAmount(
        address _asset,
        uint256 _amountInTokens,
        address _lender
    ) internal {
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        uint256 _activeAmount;
        for (uint256 _index = 0; _index < _strategyList.length; _index++) {
            if (_strategyList[_index] == address(0)) {
                continue;
            }
            uint256 _liquidityShares = _savingsAccount.balanceInShares(_lender, _asset, _strategyList[_index]);
            if (_liquidityShares != 0) {
                uint256 tokenInStrategy = _liquidityShares;
                tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);
                uint256 _tokensToTransfer = tokenInStrategy;
                if (_activeAmount.add(tokenInStrategy) >= _amountInTokens) {
                    _tokensToTransfer = (_amountInTokens.sub(_activeAmount));
                }
                _activeAmount = _activeAmount.add(_tokensToTransfer);
                _savingsAccount.withdrawFrom(_tokensToTransfer, _asset, _strategyList[_index], _lender, address(this), false);
                if (_activeAmount == _amountInTokens) {
                    return;
                }
            }
        }
        require(_activeAmount == _amountInTokens, 'insufficient balance');
    }

    /**
     * @notice used to borrow tokens from credit line by borrower
     * @dev only borrower can call this function. Amount that can actually be borrowed is 
            min(amount based on borrowLimit, allowance to creditLine contract, balance of lender)
     * @param _id identifier for the credit line
     * @param _amount amount of tokens to borrow
     */
    function borrow(uint256 _id, uint256 _amount) external payable nonReentrant onlyCreditLineBorrower(_id) {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');
        uint256 _borrowableAmount = calculateBorrowableAmount(_id);
        require(_amount <= _borrowableAmount, "CreditLine::borrow - The current collateral ratio doesn't allow to withdraw the amount");
        address _borrowAsset = creditLineConstants[_id].borrowAsset;
        address _lender = creditLineConstants[_id].lender;

        updateinterestAccruedTillLastPrincipalUpdate(_id);
        creditLineVariables[_id].principal = creditLineVariables[_id].principal.add(_amount);
        creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;

        uint256 _tokenDiffBalance;
        if (_borrowAsset != address(0)) {
            uint256 _balanceBefore = IERC20(_borrowAsset).balanceOf(address(this));
            _withdrawBorrowAmount(_borrowAsset, _amount, _lender);
            uint256 _balanceAfter = IERC20(_borrowAsset).balanceOf(address(this));
            _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);
        } else {
            uint256 _balanceBefore = address(this).balance;
            _withdrawBorrowAmount(_borrowAsset, _amount, _lender);
            uint256 _balanceAfter = address(this).balance;
            _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);
        }
        uint256 _protocolFee = _tokenDiffBalance.mul(protocolFeeFraction).div(10**30);
        _tokenDiffBalance = _tokenDiffBalance.sub(_protocolFee);

        if (_borrowAsset == address(0)) {
            (bool feeSuccess, ) = protocolFeeCollector.call{value: _protocolFee}('');
            require(feeSuccess, 'Transfer fail');
            (bool success, ) = msg.sender.call{value: _tokenDiffBalance}('');
            require(success, 'Transfer fail');
        } else {
            IERC20(_borrowAsset).safeTransfer(protocolFeeCollector, _protocolFee);
            IERC20(_borrowAsset).safeTransfer(msg.sender, _tokenDiffBalance);
        }
        emit BorrowedFromCreditLine(_id, _tokenDiffBalance);
    }

    function _repayFromSavingsAccount(
        uint256 _amount,
        address _asset,
        address _lender
    ) internal {
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        uint256 _activeAmount;

        for (uint256 _index = 0; _index < _strategyList.length; _index++) {
            if (_strategyList[_index] == address(0)) {
                continue;
            }
            uint256 _liquidityShares = _savingsAccount.balanceInShares(msg.sender, _asset, _strategyList[_index]);
            if (_liquidityShares == 0) {
                continue;
            }
            uint256 _tokenInStrategy = _liquidityShares;
            _tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);

            uint256 _tokensToTransfer = _tokenInStrategy;
            if (_activeAmount.add(_tokenInStrategy) >= _amount) {
                _tokensToTransfer = (_amount.sub(_activeAmount));
            }
            _activeAmount = _activeAmount.add(_tokensToTransfer);
            _savingsAccount.transferFrom(_tokensToTransfer, _asset, _strategyList[_index], msg.sender, _lender);

            if (_amount == _activeAmount) {
                return;
            }
        }
        revert('CreditLine::_repayFromSavingsAccount - Insufficient balance');
    }

    function _repay(
        uint256 _id,
        uint256 _amount,
        bool _fromSavingsAccount,
        uint256 _principalPaid
    ) internal {
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        address _defaultStrategy = defaultStrategy;
        address _borrowAsset = creditLineConstants[_id].borrowAsset;
        address _lender = creditLineConstants[_id].lender;
        if (!_fromSavingsAccount) {
            if (_borrowAsset == address(0)) {
                require(msg.value == _amount, 'creditLine::repay - Ether sent not equal to repay amount');
                _savingsAccount.deposit{value: _amount}(_amount, _borrowAsset, _defaultStrategy, _lender);
            } else {
                IERC20(_borrowAsset).safeTransferFrom(msg.sender, address(this), _amount);
                IERC20(_borrowAsset).approve(_defaultStrategy, _amount);
                _savingsAccount.deposit(_amount, _borrowAsset, _defaultStrategy, _lender);
            }
        } else {
            _repayFromSavingsAccount(_amount, _borrowAsset, _lender);
        }
        if (_principalPaid != 0) {
            _savingsAccount.increaseAllowanceToCreditLine(_principalPaid, _borrowAsset, _lender);
        }
    }

    /**
     * @notice used to repay interest and principal to credit line. Interest has to be repaid before repaying principal
     * @dev partial repayments possible
     * @param _id identifier for the credit line
     * @param _amount amount being repaid
     * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount 
                                otherwise direct from collateral token contract
     */
    function repay(
        uint256 _id,
        uint256 _amount,
        bool _fromSavingsAccount
    ) external payable nonReentrant {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');
        require(creditLineConstants[_id].lender != msg.sender, 'Lender cant repay');

        uint256 _interestSincePrincipalUpdate = calculateInterestAccrued(_id);
        uint256 _totalInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(
            _interestSincePrincipalUpdate
        );
        uint256 _interestToPay = _totalInterestAccrued.sub(creditLineVariables[_id].totalInterestRepaid);
        uint256 _totalCurrentDebt = _interestToPay.add(creditLineVariables[_id].principal);
        uint256 _principalPaid = 0;

        if (_amount >= _totalCurrentDebt) {
            _amount = _totalCurrentDebt;
            emit CompleteCreditLineRepaid(_id, _amount);
        } else {
            emit PartialCreditLineRepaid(_id, _amount);
        }

        if (_amount > _interestToPay) {
            creditLineVariables[_id].principal = _totalCurrentDebt.sub(_amount);
            creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _totalInterestAccrued;
            creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;
            creditLineVariables[_id].totalInterestRepaid = _totalInterestAccrued;
            _principalPaid = _amount.sub(_interestToPay);
        } else {
            creditLineVariables[_id].totalInterestRepaid = creditLineVariables[_id].totalInterestRepaid.add(_amount);
        }

        _repay(_id, _amount, _fromSavingsAccount, _principalPaid);

        if (creditLineVariables[_id].principal == 0) {
            _resetCreditLine(_id);
        }
    }

    function _resetCreditLine(uint256 _id) internal {
        creditLineVariables[_id].lastPrincipalUpdateTime = 0;
        creditLineVariables[_id].totalInterestRepaid = 0;
        creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = 0;
        emit CreditLineReset(_id);
    }

    /**
     * @dev used to close credit line by borrower or lender
     * @param _id identifier for the credit line
     */
    function close(uint256 _id) external ifCreditLineExists(_id) {
        require(
            msg.sender == creditLineConstants[_id].borrower || msg.sender == creditLineConstants[_id].lender,
            'CreditLine: Permission denied while closing Line of credit'
        );
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: Credit line should be active.');
        require(creditLineVariables[_id].principal == 0, 'CreditLine: Cannot be closed since not repaid.');
        require(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate == 0, 'CreditLine: Cannot be closed since not repaid.');
        creditLineVariables[_id].status = CreditLineStatus.CLOSED;
        emit CreditLineClosed(_id);
    }

    /**
     * @notice used to calculate the current collateral ratio
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view.
            Interest is also considered while calculating debt
     * @param _id identifier for the credit line
     * @return collateral ratio multiplied by 10**30 to retain precision
     */
    function calculateCurrentCollateralRatio(uint256 _id) public ifCreditLineExists(_id) returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(
            creditLineConstants[_id].collateralAsset,
            creditLineConstants[_id].borrowAsset
        );

        uint256 currentDebt = calculateCurrentDebt(_id);
        uint256 currentCollateralRatio = calculateTotalCollateralTokens(_id).mul(_ratioOfPrices).div(currentDebt).mul(10**30).div(
            10**_decimals
        );

        return currentCollateralRatio;
    }

    /**
     * @notice used to calculate the total collateral tokens
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @param _id identifier for the credit line
     * @return _amount total collateral tokens deposited into the credit line
     */
    function calculateTotalCollateralTokens(uint256 _id) public returns (uint256 _amount) {
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        uint256 _liquidityShares;
        for (uint256 index = 0; index < _strategyList.length; index++) {
            if (_strategyList[index] == address(0)) {
                continue;
            }
            _liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];
            uint256 _tokenInStrategy = _liquidityShares;
            _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(_liquidityShares, _collateralAsset);

            _amount = _amount.add(_tokenInStrategy);
        }
    }

    /**
     * @notice used to withdraw any excess collateral
     * @dev collateral can't be withdraw if collateralRatio goes below the ideal value. Only borrower can withdraw
     * @param _id identifier for the credit line
     * @param _amount amount of collateral to withdraw
     * @param _toSavingsAccount if true, tokens are transferred from savingsAccount 
                                otherwise direct from collateral token contract
     */
    function withdrawCollateral(
        uint256 _id,
        uint256 _amount,
        bool _toSavingsAccount
    ) external nonReentrant onlyCreditLineBorrower(_id) {
        uint256 _withdrawableCollateral = withdrawableCollateral(_id);
        require(_amount <= _withdrawableCollateral, 'Collateral ratio cant go below ideal');
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        _transferCollateral(_id, _collateralAsset, _amount, _toSavingsAccount);
        emit CollateralWithdrawn(_id, _amount);
    }

    /**
     * @notice used to calculate the collateral that can be withdrawn
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @param _id identifier for the credit line
     * @return total collateral withdrawable by borrower
     */
    function withdrawableCollateral(uint256 _id) public returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(
            creditLineConstants[_id].collateralAsset,
            creditLineConstants[_id].borrowAsset
        );

        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);
        uint256 _currentDebt = calculateCurrentDebt(_id);

        uint256 _collateralNeeded = _currentDebt
            .mul(creditLineConstants[_id].idealCollateralRatio)
            .div(_ratioOfPrices)
            .mul(10**_decimals)
            .div(10**30);

        if (_collateralNeeded >= _totalCollateralTokens) {
            return 0;
        }
        return _totalCollateralTokens.sub(_collateralNeeded);
    }

    function _transferCollateral(
        uint256 _id,
        address _asset,
        uint256 _amountInTokens,
        bool _toSavingsAccount
    ) internal {
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        uint256 _activeAmount;
        for (uint256 index = 0; index < _strategyList.length; index++) {
            uint256 liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];
            if (liquidityShares == 0 || _strategyList[index] == address(0)) {
                continue;
            }
            uint256 _tokenInStrategy = liquidityShares;
            _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(liquidityShares, _asset);
            uint256 _tokensToTransfer = _tokenInStrategy;
            if (_activeAmount.add(_tokenInStrategy) > _amountInTokens) {
                _tokensToTransfer = _amountInTokens.sub(_activeAmount);
                liquidityShares = liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy);
            }
            _activeAmount = _activeAmount.add(_tokensToTransfer);
            collateralShareInStrategy[_id][_strategyList[index]] = collateralShareInStrategy[_id][_strategyList[index]].sub(
                liquidityShares
            );
            if (_toSavingsAccount) {
                ISavingsAccount(savingsAccount).transfer(_tokensToTransfer, _asset, _strategyList[index], msg.sender);
            } else {
                ISavingsAccount(savingsAccount).withdraw(_tokensToTransfer, _asset, _strategyList[index], msg.sender, false);
            }

            if (_activeAmount == _amountInTokens) {
                return;
            }
        }
        revert('insufficient collateral');
    }

    /**
     * @notice used to liquidate credit line in case collateral ratio goes below the threshold
     * @dev if lender liquidates, then collateral is directly transferred. 
            If autoLiquidation is true, anyone can liquidate by providing enough borrow tokens
     * @param _id identifier for the credit line
     * @param _toSavingsAccount if true, tokens are transferred from savingsAccount 
                                otherwise direct from collateral token contract
     */
    function liquidate(uint256 _id, bool _toSavingsAccount) external payable nonReentrant {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: Credit line should be active.');
        require(creditLineVariables[_id].principal != 0, 'CreditLine: cannot liquidate if principal is 0');

        uint256 currentCollateralRatio = calculateCurrentCollateralRatio(_id);
        require(
            currentCollateralRatio < creditLineConstants[_id].idealCollateralRatio,
            'CreditLine: Collateral ratio is higher than ideal value'
        );

        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        address _lender = creditLineConstants[_id].lender;
        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);
        address _borrowAsset = creditLineConstants[_id].borrowAsset;

        creditLineVariables[_id].status = CreditLineStatus.LIQUIDATED;

        if (creditLineConstants[_id].autoLiquidation && _lender != msg.sender) {
            uint256 _borrowTokens = _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens);
            if (_borrowAsset == address(0)) {
                uint256 _returnETH = msg.value.sub(_borrowTokens, 'Insufficient ETH to liquidate');
                if (_returnETH != 0) {
                    (bool success, ) = msg.sender.call{value: _returnETH}('');
                    require(success, 'Transfer fail');
                }
            } else {
                IERC20(_borrowAsset).safeTransferFrom(msg.sender, _lender, _borrowTokens);
            }
        }

        _transferCollateral(_id, _collateralAsset, _totalCollateralTokens, _toSavingsAccount);

        emit CreditLineLiquidated(_id, msg.sender);
    }

    /**
     * @notice used to calculate the borrow tokens necessary for liquidator to liquidate
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @param _id identifier for the credit line
     * @return borrow tokens necessary for liquidator to liquidate
     */
    function borrowTokensToLiquidate(uint256 _id) external returns (uint256) {
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);
        address _borrowAsset = creditLineConstants[_id].borrowAsset;

        return _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens);
    }

    function _borrowTokensToLiquidate(
        address _borrowAsset,
        address _collateralAsset,
        uint256 _totalCollateralTokens
    ) internal view returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(_borrowAsset, _collateralAsset);
        uint256 _borrowTokens = (
            _totalCollateralTokens.mul(uint256(10**30).sub(liquidatorRewardFraction)).div(10**30).mul(_ratioOfPrices).div(10**_decimals)
        );

        return _borrowTokens;
    }

    receive() external payable {
        require(msg.sender == savingsAccount, 'CreditLine::receive invalid transaction');
    }
}
.]

Below are the details of our smart contract codes and their corresponding analysis reports:
Task: "".
As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report.

[2024-22-08 11:43:38 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-22-08 11:43:38 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 10083
completion_tokens: 748
total_tokens: 10831
cost: $-1.000000


[2024-22-08 11:43:38 INFO] Solidity Programming Expert: **Solidity Programming Expert<->Security Analyst on : BugsSummary, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/utils/ReentrancyGuard.sol';
import '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';
import '../interfaces/IPriceOracle.sol';
import '../interfaces/IYield.sol';
import '../interfaces/ISavingsAccount.sol';
import '../SavingsAccount/SavingsAccountUtil.sol';
import '../interfaces/IStrategyRegistry.sol';

/**
 * @title Credit Line contract with Methods related to credit Line
 * @notice Implements the functions related to Credit Line
 * @author Sublime
 **/

contract CreditLine is ReentrancyGuard, OwnableUpgradeable {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    enum CreditLineStatus {
        NOT_CREATED,
        REQUESTED,
        ACTIVE,
        CLOSED,
        CANCELLED,
        LIQUIDATED
    }

    /**
     * @notice counter that tracks the number of credit lines created
     * @dev used to create unique identifier for credit lines
     **/
    uint256 public creditLineCounter;

    uint256 constant YEAR_IN_SECONDS = 365 days;

    struct CreditLineVariables {
        CreditLineStatus status;
        uint256 principal;
        uint256 totalInterestRepaid;
        uint256 lastPrincipalUpdateTime;
        uint256 interestAccruedTillLastPrincipalUpdate;
    }

    struct CreditLineConstants {
        address lender;
        address borrower;
        uint256 borrowLimit;
        uint256 idealCollateralRatio;
        uint256 borrowRate;
        address borrowAsset;
        address collateralAsset;
        bool autoLiquidation;
        bool requestByLender;
    }
    /**
     * @notice stores the collateral shares in a credit line per strategy
     * @dev creditLineId => Strategy => collateralShares
     **/
    mapping(uint256 => mapping(address => uint256)) public collateralShareInStrategy;

    /**
     * @notice stores the variables to maintain a credit line
     **/
    mapping(uint256 => CreditLineVariables) public creditLineVariables;

    /**
     * @notice stores the constants related to a credit line
     **/
    mapping(uint256 => CreditLineConstants) public creditLineConstants;

    /**
     * @notice stores the address of savings account contract
     **/
    address public savingsAccount;

    /**
     * @notice stores the address of price oracle contract
     **/
    address public priceOracle;

    /**
     * @notice stores the address of strategy registry contract
     **/
    address public strategyRegistry;

    /**
     * @notice stores the address of default strategy
     **/
    address public defaultStrategy;

    /**
     * @notice stores the fraction of borrowed amount charged as fee by protocol
     * @dev it is multiplied by 10**30
     **/
    uint256 public protocolFeeFraction;

    /**
     * @notice address where protocol fee is collected
     **/
    address public protocolFeeCollector;

    /**
     * @notice stores the fraction of amount liquidated given as reward to liquidator
     * @dev it is multiplied by 10**30
     **/
    uint256 public liquidatorRewardFraction;
    /**
     * @dev checks if Credit Line exists
     * @param _id identifier for the credit line
     **/
    modifier ifCreditLineExists(uint256 _id) {
        require(creditLineVariables[_id].status != CreditLineStatus.NOT_CREATED, 'Credit line does not exist');
        _;
    }

    /**
     * @dev checks if called by credit Line Borrower
     * @param _id creditLine identifier
     **/
    modifier onlyCreditLineBorrower(uint256 _id) {
        require(creditLineConstants[_id].borrower == msg.sender, 'Only credit line Borrower can access');
        _;
    }

    /**
     * @dev checks if called by credit Line Lender
     * @param _id creditLine identifier
     **/
    modifier onlyCreditLineLender(uint256 _id) {
        require(creditLineConstants[_id].lender == msg.sender, 'Only credit line Lender can access');
        _;
    }

    /**
     * @notice emitted when a collateral is deposited into credit line
     * @param id id of the credit line
     * @param amount amount of collateral deposited
     * @param strategy address of the strategy into which collateral is deposited
     */
    event CollateralDeposited(uint256 indexed id, uint256 amount, address indexed strategy);

    /**
     * @notice emitted when collateral is withdrawn from credit line
     * @param id id of the credit line
     * @param amount amount of collateral withdrawn
     */
    event CollateralWithdrawn(uint256 indexed id, uint256 amount);

    /**
     * @notice emitted when a request for new credit line is placed
     * @param id id of the credit line for which request was made
     * @param lender address of the lender for credit line
     * @param borrower address of the borrower for credit line
     */
    event CreditLineRequested(uint256 indexed id, address indexed lender, address indexed borrower);

    /**
     * @notice emitted when a credit line is liquidated
     * @param id id of the credit line which is liquidated
     * @param liquidator address of the liquidator
     */
    event CreditLineLiquidated(uint256 indexed id, address indexed liquidator);

    /**
     * @notice emitted when tokens are borrowed from credit line
     * @param id id of the credit line from which tokens are borrowed
     * @param borrowAmount amount of tokens borrowed
     */
    event BorrowedFromCreditLine(uint256 indexed id, uint256 borrowAmount);

    /**
     * @notice emitted when credit line is accepted
     * @param id id of the credit line that was accepted
     */
    event CreditLineAccepted(uint256 indexed id);

    /**
     * @notice emitted when credit line is completely repaid and reset
     * @param id id of the credit line that is reset
     */
    event CreditLineReset(uint256 indexed id);

    /**
     * @notice emitted when the credit line is partially repaid
     * @param id id of the credit line
     * @param repayAmount amount repaid
     */
    event PartialCreditLineRepaid(uint256 indexed id, uint256 repayAmount);

    /**
     * @notice emitted when the credit line is completely repaid
     * @param id id of the credit line
     * @param repayAmount amount repaid
     */
    event CompleteCreditLineRepaid(uint256 indexed id, uint256 repayAmount);

    /**
     * @notice emitted when the credit line is closed by one of the parties of credit line
     * @param id id of the credit line
     */
    event CreditLineClosed(uint256 indexed id);

    /**
     * @notice emitted when default strategy for the credit line is updated
     * @param defaultStrategy address of the strategy contract that is used as default by credit lines
     */
    event DefaultStrategyUpdated(address indexed defaultStrategy);

    /**
     * @notice emitted when the price oracle is updated
     * @param priceOracle address of the updated price oracle
     */
    event PriceOracleUpdated(address indexed priceOracle);

    /**
     * @notice emitted when the savings account address is updated
     * @param savingsAccount address of the updated savingsAccount
     */
    event SavingsAccountUpdated(address indexed savingsAccount);

    /**
     * @notice emitted when strategy registry address is updated
     * @param strategyRegistry address of the updated strategy registry
     */
    event StrategyRegistryUpdated(address indexed strategyRegistry);

    /**
     * @notice emitted when fee that protocol charges for credit line is updated
     * @param updatedProtocolFee updated value of protocolFeeFraction
     */
    event ProtocolFeeFractionUpdated(uint256 updatedProtocolFee);

    /**
     * @notice emitted when address which receives fee that protocol changes for pools is updated
     * @param updatedProtocolFeeCollector updated value of protocolFeeCollector
     */
    event ProtocolFeeCollectorUpdated(address indexed updatedProtocolFeeCollector);

    /**
     * @notice emitted when liquidatorRewardFraction is updated
     * @param liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator
     */
    event LiquidationRewardFractionUpdated(uint256 liquidatorRewardFraction);

    /**
     * @notice used to initialize the contract
     * @dev can only be called once during the life cycle of the contract
     * @param _defaultStrategy default strategy used in credit lines
     * @param _priceOracle address of the priceOracle
     * @param _savingsAccount address of  the savings account contract
     * @param _strategyRegistry address of the strategy registry contract
     * @param _owner address of owner who can change global variables
     * @param _protocolFeeFraction fraction of the fee charged by protocol
     * @param _protocolFeeCollector address to which protocol fee is charged to
     * @param _liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator
     */
    function initialize(
        address _defaultStrategy,
        address _priceOracle,
        address _savingsAccount,
        address _strategyRegistry,
        address _owner,
        uint256 _protocolFeeFraction,
        address _protocolFeeCollector,
        uint256 _liquidatorRewardFraction
    ) external initializer {
        OwnableUpgradeable.__Ownable_init();
        OwnableUpgradeable.transferOwnership(_owner);

        _updateDefaultStrategy(_defaultStrategy);
        _updatePriceOracle(_priceOracle);
        _updateSavingsAccount(_savingsAccount);
        _updateStrategyRegistry(_strategyRegistry);
        _updateProtocolFeeFraction(_protocolFeeFraction);
        _updateProtocolFeeCollector(_protocolFeeCollector);
        _updateLiquidatorRewardFraction(_liquidatorRewardFraction);
    }

    /**
     * @notice used to update the default strategy
     * @dev can only be updated by owner
     * @param _defaultStrategy address of the updated default strategy
     */
    function updateDefaultStrategy(address _defaultStrategy) external onlyOwner {
        _updateDefaultStrategy(_defaultStrategy);
    }

    function _updateDefaultStrategy(address _defaultStrategy) internal {
        defaultStrategy = _defaultStrategy;
        emit DefaultStrategyUpdated(_defaultStrategy);
    }

    /**
     * @notice used to update the price oracle
     * @dev can only be updated by owner
     * @param _priceOracle address of the updated price oracle
     */
    function updatePriceOracle(address _priceOracle) external onlyOwner {
        _updatePriceOracle(_priceOracle);
    }

    function _updatePriceOracle(address _priceOracle) internal {
        priceOracle = _priceOracle;
        emit PriceOracleUpdated(_priceOracle);
    }

    /**
     * @notice used to update the savings account address
     * @dev can only be updated by owner
     * @param _savingsAccount address of the updated savings account
     */
    function updateSavingsAccount(address _savingsAccount) external onlyOwner {
        _updateSavingsAccount(_savingsAccount);
    }

    function _updateSavingsAccount(address _savingsAccount) internal {
        savingsAccount = _savingsAccount;
        emit SavingsAccountUpdated(_savingsAccount);
    }

    /**
     * @notice used to update the protocol fee fraction
     * @dev can only be updated by owner
     * @param _protocolFee fraction of the borrower amount collected as protocol fee
     */
    function updateProtocolFeeFraction(uint256 _protocolFee) external onlyOwner {
        _updateProtocolFeeFraction(_protocolFee);
    }

    function _updateProtocolFeeFraction(uint256 _protocolFee) internal {
        protocolFeeFraction = _protocolFee;
        emit ProtocolFeeFractionUpdated(_protocolFee);
    }

    /**
     * @notice used to update the protocol fee collector
     * @dev can only be updated by owner
     * @param _protocolFeeCollector address in which protocol fee is collected
     */
    function updateProtocolFeeCollector(address _protocolFeeCollector) external onlyOwner {
        _updateProtocolFeeCollector(_protocolFeeCollector);
    }

    function _updateProtocolFeeCollector(address _protocolFeeCollector) internal {
        require(_protocolFeeCollector != address(0), 'cant be 0 address');
        protocolFeeCollector = _protocolFeeCollector;
        emit ProtocolFeeCollectorUpdated(_protocolFeeCollector);
    }

    /**
     * @notice used to update the strategy registry address
     * @dev can only be updated by owner
     * @param _strategyRegistry address of the updated strategy registry
     */
    function updateStrategyRegistry(address _strategyRegistry) external onlyOwner {
        _updateStrategyRegistry(_strategyRegistry);
    }

    function _updateStrategyRegistry(address _strategyRegistry) internal {
        require(_strategyRegistry != address(0), 'CL::I zero address');
        strategyRegistry = _strategyRegistry;
        emit StrategyRegistryUpdated(_strategyRegistry);
    }

    /**
     * @notice used to update the liquidatorRewardFraction
     * @dev can only be updated by owner
     * @param _rewardFraction fraction of liquidated amount given to liquidator as reward
     */
    function updateLiquidatorRewardFraction(uint256 _rewardFraction) external onlyOwner {
        _updateLiquidatorRewardFraction(_rewardFraction);
    }

    function _updateLiquidatorRewardFraction(uint256 _rewardFraction) internal {
        require(_rewardFraction <= 10**30, 'Fraction has to be less than 1');
        liquidatorRewardFraction = _rewardFraction;
        emit LiquidationRewardFractionUpdated(_rewardFraction);
    }

    /**
     * @dev Used to Calculate Interest Per second on given principal and Interest rate
     * @param _principal principal Amount for which interest has to be calculated.
     * @param _borrowRate It is the Interest Rate at which Credit Line is approved
     * @return interest per second for the given parameters
     */
    function calculateInterest(
        uint256 _principal,
        uint256 _borrowRate,
        uint256 _timeElapsed
    ) public pure returns (uint256) {
        uint256 _interest = _principal.mul(_borrowRate).mul(_timeElapsed).div(10**30).div(YEAR_IN_SECONDS);

        return _interest;
    }

    /**
     * @dev Used to calculate interest accrued since last repayment
     * @param _id identifier for the credit line
     * @return interest accrued over current borrowed amount since last repayment
     */

    function calculateInterestAccrued(uint256 _id) public view returns (uint256) {
        uint256 _lastPrincipalUpdateTime = creditLineVariables[_id].lastPrincipalUpdateTime;
        if (_lastPrincipalUpdateTime == 0) return 0;
        uint256 _timeElapsed = (block.timestamp).sub(_lastPrincipalUpdateTime);
        uint256 _interestAccrued = calculateInterest(creditLineVariables[_id].principal, creditLineConstants[_id].borrowRate, _timeElapsed);
        return _interestAccrued;
    }

    /**
     * @dev Used to calculate current debt of borrower against a credit line.
     * @param _id identifier for the credit line
     * @return current debt of borrower
     */
    function calculateCurrentDebt(uint256 _id) public view returns (uint256) {
        uint256 _interestAccrued = calculateInterestAccrued(_id);
        uint256 _currentDebt = (creditLineVariables[_id].principal)
            .add(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate)
            .add(_interestAccrued)
            .sub(creditLineVariables[_id].totalInterestRepaid);
        return _currentDebt;
    }

    /**
     * @notice used to calculate amount that can be borrowed by the borrower
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view.
            borrowableAmount changes per block as interest changes per block.
     * @param _id identifier for the credit line
     * @return amount that can be borrowed from the credit line
     */
    function calculateBorrowableAmount(uint256 _id) public returns (uint256) {
        CreditLineStatus _status = creditLineVariables[_id].status;
        require(
            _status == CreditLineStatus.ACTIVE || _status == CreditLineStatus.REQUESTED,
            'CreditLine: Cannot only if credit line ACTIVE or REQUESTED'
        );
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(
            creditLineConstants[_id].collateralAsset,
            creditLineConstants[_id].borrowAsset
        );

        uint256 _totalCollateralToken = calculateTotalCollateralTokens(_id);

        uint256 _currentDebt = calculateCurrentDebt(_id);

        uint256 _maxPossible = _totalCollateralToken.mul(_ratioOfPrices).div(creditLineConstants[_id].idealCollateralRatio).mul(10**30).div(
            10**_decimals
        );

        uint256 _borrowLimit = creditLineConstants[_id].borrowLimit;

        if (_maxPossible > _borrowLimit) {
            _maxPossible = _borrowLimit;
        }
        if (_maxPossible > _currentDebt) {
            return _maxPossible.sub(_currentDebt);
        }
        return 0;
    }

    function updateinterestAccruedTillLastPrincipalUpdate(uint256 _id) internal {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');

        uint256 _interestAccrued = calculateInterestAccrued(_id);
        uint256 _newInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(_interestAccrued);
        creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _newInterestAccrued;
    }

    function _depositCollateralFromSavingsAccount(
        uint256 _id,
        uint256 _amount,
        address _sender
    ) internal {
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        uint256 _activeAmount;

        for (uint256 _index = 0; _index < _strategyList.length; _index++) {
            address _strategy = _strategyList[_index];
            uint256 _liquidityShares = _savingsAccount.balanceInShares(_sender, _collateralAsset, _strategy);
            if (_liquidityShares == 0 || _strategyList[_index] == address(0)) {
                continue;
            }
            uint256 _tokenInStrategy = _liquidityShares;
            _tokenInStrategy = IYield(_strategy).getTokensForShares(_liquidityShares, _collateralAsset);

            uint256 _tokensToTransfer = _tokenInStrategy;
            if (_activeAmount.add(_tokenInStrategy) >= _amount) {
                _tokensToTransfer = (_amount.sub(_activeAmount));
            }
            _activeAmount = _activeAmount.add(_tokensToTransfer);
            _savingsAccount.transferFrom(_tokensToTransfer, _collateralAsset, _strategy, _sender, address(this));

            collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(
                _liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy)
            );

            if (_amount == _activeAmount) {
                return;
            }
        }
        revert('CreditLine::_depositCollateralFromSavingsAccount - Insufficient balance');
    }

    /**
     * @notice used to request a credit line either by borrower or lender
     * @param _requestTo Address to which creditLine is requested, 
                        if borrower creates request then lender address and 
                        if lender creates then borrower address
     * @param _borrowLimit maximum borrow amount in a credit line
     * @param _borrowRate Interest Rate at which credit Line is requested
     * @param _autoLiquidation if true, anyone can liquidate loan, otherwise only lender
     * @param _collateralRatio ratio of the collateral to the debt below which credit line can be liquidated
     * @param _borrowAsset address of the token to be borrowed
     * @param _collateralAsset address of the token provided as collateral
     * @param _requestAsLender if true, lender is placing request, otherwise borrower
     * @return identifier for the credit line
     */

    function request(
        address _requestTo,
        uint256 _borrowLimit,
        uint256 _borrowRate,
        bool _autoLiquidation,
        uint256 _collateralRatio,
        address _borrowAsset,
        address _collateralAsset,
        bool _requestAsLender
    ) external returns (uint256) {
        require(_borrowAsset != _collateralAsset, 'R: cant borrow lent token');
        require(IPriceOracle(priceOracle).doesFeedExist(_borrowAsset, _collateralAsset), 'R: No price feed');

        address _lender = _requestTo;
        address _borrower = msg.sender;
        if (_requestAsLender) {
            _lender = msg.sender;
            _borrower = _requestTo;
        }

        uint256 _id = _createRequest(
            _lender,
            _borrower,
            _borrowLimit,
            _borrowRate,
            _autoLiquidation,
            _collateralRatio,
            _borrowAsset,
            _collateralAsset,
            _requestAsLender
        );

        emit CreditLineRequested(_id, _lender, _borrower);
        return _id;
    }

    function _createRequest(
        address _lender,
        address _borrower,
        uint256 _borrowLimit,
        uint256 _borrowRate,
        bool _autoLiquidation,
        uint256 _collateralRatio,
        address _borrowAsset,
        address _collateralAsset,
        bool _requestByLender
    ) internal returns (uint256) {
        require(_lender != _borrower, 'Lender and Borrower cannot be same addresses');
        uint256 _id = creditLineCounter + 1;
        creditLineCounter = _id;
        creditLineVariables[_id].status = CreditLineStatus.REQUESTED;
        creditLineConstants[_id].borrower = _borrower;
        creditLineConstants[_id].lender = _lender;
        creditLineConstants[_id].borrowLimit = _borrowLimit;
        creditLineConstants[_id].autoLiquidation = _autoLiquidation;
        creditLineConstants[_id].idealCollateralRatio = _collateralRatio;
        creditLineConstants[_id].borrowRate = _borrowRate;
        creditLineConstants[_id].borrowAsset = _borrowAsset;
        creditLineConstants[_id].collateralAsset = _collateralAsset;
        creditLineConstants[_id].requestByLender = _requestByLender;
        return _id;
    }

    /**
     * @notice used to accept a credit line
     * @dev if borrower places request, lender can accept and vice versa
     * @param _id identifier for the credit line
     */
    function accept(uint256 _id) external {
        require(
            creditLineVariables[_id].status == CreditLineStatus.REQUESTED,
            'CreditLine::acceptCreditLineLender - CreditLine is already accepted'
        );
        bool _requestByLender = creditLineConstants[_id].requestByLender;
        require(
            (msg.sender == creditLineConstants[_id].borrower && _requestByLender) ||
                (msg.sender == creditLineConstants[_id].lender && !_requestByLender),
            "Only Borrower or Lender who hasn't requested can accept"
        );
        creditLineVariables[_id].status = CreditLineStatus.ACTIVE;
        emit CreditLineAccepted(_id);
    }

    /**
     * @notice used to deposit collateral into the credit line
     * @dev collateral tokens have to be approved in savingsAccount or token contract(unless ether).
            If transferred from savings account, the tokens are transferred from strategies in the 
            order prespecified in strategy registry
     * @param _id identifier for the credit line
     * @param _amount amount of collateral being deposited
     * @param _strategy strategy to which collateral is to be deposited in case transfer is not from savings account
     * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount 
                                otherwise direct from collateral token contract
     */
    function depositCollateral(
        uint256 _id,
        uint256 _amount,
        address _strategy,
        bool _fromSavingsAccount
    ) external payable nonReentrant ifCreditLineExists(_id) {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine not active');
        _depositCollateral(_id, _amount, _strategy, _fromSavingsAccount);
        emit CollateralDeposited(_id, _amount, _strategy);
    }

    function _depositCollateral(
        uint256 _id,
        uint256 _amount,
        address _strategy,
        bool _fromSavingsAccount
    ) internal {
        require(creditLineConstants[_id].lender != msg.sender, 'lender cant deposit collateral');
        if (_fromSavingsAccount) {
            _depositCollateralFromSavingsAccount(_id, _amount, msg.sender);
        } else {
            address _collateralAsset = creditLineConstants[_id].collateralAsset;
            ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
            if (_collateralAsset == address(0)) {
                require(msg.value == _amount, "CreditLine::_depositCollateral - value to transfer doesn't match argument");
            } else {
                IERC20(_collateralAsset).safeTransferFrom(msg.sender, address(this), _amount);
                IERC20(_collateralAsset).approve(_strategy, _amount);
            }
            uint256 _sharesReceived = _savingsAccount.deposit{value: msg.value}(_amount, _collateralAsset, _strategy, address(this));
            collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(_sharesReceived);
        }
    }

    function _withdrawBorrowAmount(
        address _asset,
        uint256 _amountInTokens,
        address _lender
    ) internal {
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        uint256 _activeAmount;
        for (uint256 _index = 0; _index < _strategyList.length; _index++) {
            if (_strategyList[_index] == address(0)) {
                continue;
            }
            uint256 _liquidityShares = _savingsAccount.balanceInShares(_lender, _asset, _strategyList[_index]);
            if (_liquidityShares != 0) {
                uint256 tokenInStrategy = _liquidityShares;
                tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);
                uint256 _tokensToTransfer = tokenInStrategy;
                if (_activeAmount.add(tokenInStrategy) >= _amountInTokens) {
                    _tokensToTransfer = (_amountInTokens.sub(_activeAmount));
                }
                _activeAmount = _activeAmount.add(_tokensToTransfer);
                _savingsAccount.withdrawFrom(_tokensToTransfer, _asset, _strategyList[_index], _lender, address(this), false);
                if (_activeAmount == _amountInTokens) {
                    return;
                }
            }
        }
        require(_activeAmount == _amountInTokens, 'insufficient balance');
    }

    /**
     * @notice used to borrow tokens from credit line by borrower
     * @dev only borrower can call this function. Amount that can actually be borrowed is 
            min(amount based on borrowLimit, allowance to creditLine contract, balance of lender)
     * @param _id identifier for the credit line
     * @param _amount amount of tokens to borrow
     */
    function borrow(uint256 _id, uint256 _amount) external payable nonReentrant onlyCreditLineBorrower(_id) {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');
        uint256 _borrowableAmount = calculateBorrowableAmount(_id);
        require(_amount <= _borrowableAmount, "CreditLine::borrow - The current collateral ratio doesn't allow to withdraw the amount");
        address _borrowAsset = creditLineConstants[_id].borrowAsset;
        address _lender = creditLineConstants[_id].lender;

        updateinterestAccruedTillLastPrincipalUpdate(_id);
        creditLineVariables[_id].principal = creditLineVariables[_id].principal.add(_amount);
        creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;

        uint256 _tokenDiffBalance;
        if (_borrowAsset != address(0)) {
            uint256 _balanceBefore = IERC20(_borrowAsset).balanceOf(address(this));
            _withdrawBorrowAmount(_borrowAsset, _amount, _lender);
            uint256 _balanceAfter = IERC20(_borrowAsset).balanceOf(address(this));
            _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);
        } else {
            uint256 _balanceBefore = address(this).balance;
            _withdrawBorrowAmount(_borrowAsset, _amount, _lender);
            uint256 _balanceAfter = address(this).balance;
            _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);
        }
        uint256 _protocolFee = _tokenDiffBalance.mul(protocolFeeFraction).div(10**30);
        _tokenDiffBalance = _tokenDiffBalance.sub(_protocolFee);

        if (_borrowAsset == address(0)) {
            (bool feeSuccess, ) = protocolFeeCollector.call{value: _protocolFee}('');
            require(feeSuccess, 'Transfer fail');
            (bool success, ) = msg.sender.call{value: _tokenDiffBalance}('');
            require(success, 'Transfer fail');
        } else {
            IERC20(_borrowAsset).safeTransfer(protocolFeeCollector, _protocolFee);
            IERC20(_borrowAsset).safeTransfer(msg.sender, _tokenDiffBalance);
        }
        emit BorrowedFromCreditLine(_id, _tokenDiffBalance);
    }

    function _repayFromSavingsAccount(
        uint256 _amount,
        address _asset,
        address _lender
    ) internal {
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        uint256 _activeAmount;

        for (uint256 _index = 0; _index < _strategyList.length; _index++) {
            if (_strategyList[_index] == address(0)) {
                continue;
            }
            uint256 _liquidityShares = _savingsAccount.balanceInShares(msg.sender, _asset, _strategyList[_index]);
            if (_liquidityShares == 0) {
                continue;
            }
            uint256 _tokenInStrategy = _liquidityShares;
            _tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);

            uint256 _tokensToTransfer = _tokenInStrategy;
            if (_activeAmount.add(_tokenInStrategy) >= _amount) {
                _tokensToTransfer = (_amount.sub(_activeAmount));
            }
            _activeAmount = _activeAmount.add(_tokensToTransfer);
            _savingsAccount.transferFrom(_tokensToTransfer, _asset, _strategyList[_index], msg.sender, _lender);

            if (_amount == _activeAmount) {
                return;
            }
        }
        revert('CreditLine::_repayFromSavingsAccount - Insufficient balance');
    }

    function _repay(
        uint256 _id,
        uint256 _amount,
        bool _fromSavingsAccount,
        uint256 _principalPaid
    ) internal {
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        address _defaultStrategy = defaultStrategy;
        address _borrowAsset = creditLineConstants[_id].borrowAsset;
        address _lender = creditLineConstants[_id].lender;
        if (!_fromSavingsAccount) {
            if (_borrowAsset == address(0)) {
                require(msg.value == _amount, 'creditLine::repay - Ether sent not equal to repay amount');
                _savingsAccount.deposit{value: _amount}(_amount, _borrowAsset, _defaultStrategy, _lender);
            } else {
                IERC20(_borrowAsset).safeTransferFrom(msg.sender, address(this), _amount);
                IERC20(_borrowAsset).approve(_defaultStrategy, _amount);
                _savingsAccount.deposit(_amount, _borrowAsset, _defaultStrategy, _lender);
            }
        } else {
            _repayFromSavingsAccount(_amount, _borrowAsset, _lender);
        }
        if (_principalPaid != 0) {
            _savingsAccount.increaseAllowanceToCreditLine(_principalPaid, _borrowAsset, _lender);
        }
    }

    /**
     * @notice used to repay interest and principal to credit line. Interest has to be repaid before repaying principal
     * @dev partial repayments possible
     * @param _id identifier for the credit line
     * @param _amount amount being repaid
     * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount 
                                otherwise direct from collateral token contract
     */
    function repay(
        uint256 _id,
        uint256 _amount,
        bool _fromSavingsAccount
    ) external payable nonReentrant {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');
        require(creditLineConstants[_id].lender != msg.sender, 'Lender cant repay');

        uint256 _interestSincePrincipalUpdate = calculateInterestAccrued(_id);
        uint256 _totalInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(
            _interestSincePrincipalUpdate
        );
        uint256 _interestToPay = _totalInterestAccrued.sub(creditLineVariables[_id].totalInterestRepaid);
        uint256 _totalCurrentDebt = _interestToPay.add(creditLineVariables[_id].principal);
        uint256 _principalPaid = 0;

        if (_amount >= _totalCurrentDebt) {
            _amount = _totalCurrentDebt;
            emit CompleteCreditLineRepaid(_id, _amount);
        } else {
            emit PartialCreditLineRepaid(_id, _amount);
        }

        if (_amount > _interestToPay) {
            creditLineVariables[_id].principal = _totalCurrentDebt.sub(_amount);
            creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _totalInterestAccrued;
            creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;
            creditLineVariables[_id].totalInterestRepaid = _totalInterestAccrued;
            _principalPaid = _amount.sub(_interestToPay);
        } else {
            creditLineVariables[_id].totalInterestRepaid = creditLineVariables[_id].totalInterestRepaid.add(_amount);
        }

        _repay(_id, _amount, _fromSavingsAccount, _principalPaid);

        if (creditLineVariables[_id].principal == 0) {
            _resetCreditLine(_id);
        }
    }

    function _resetCreditLine(uint256 _id) internal {
        creditLineVariables[_id].lastPrincipalUpdateTime = 0;
        creditLineVariables[_id].totalInterestRepaid = 0;
        creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = 0;
        emit CreditLineReset(_id);
    }

    /**
     * @dev used to close credit line by borrower or lender
     * @param _id identifier for the credit line
     */
    function close(uint256 _id) external ifCreditLineExists(_id) {
        require(
            msg.sender == creditLineConstants[_id].borrower || msg.sender == creditLineConstants[_id].lender,
            'CreditLine: Permission denied while closing Line of credit'
        );
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: Credit line should be active.');
        require(creditLineVariables[_id].principal == 0, 'CreditLine: Cannot be closed since not repaid.');
        require(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate == 0, 'CreditLine: Cannot be closed since not repaid.');
        creditLineVariables[_id].status = CreditLineStatus.CLOSED;
        emit CreditLineClosed(_id);
    }

    /**
     * @notice used to calculate the current collateral ratio
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view.
            Interest is also considered while calculating debt
     * @param _id identifier for the credit line
     * @return collateral ratio multiplied by 10**30 to retain precision
     */
    function calculateCurrentCollateralRatio(uint256 _id) public ifCreditLineExists(_id) returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(
            creditLineConstants[_id].collateralAsset,
            creditLineConstants[_id].borrowAsset
        );

        uint256 currentDebt = calculateCurrentDebt(_id);
        uint256 currentCollateralRatio = calculateTotalCollateralTokens(_id).mul(_ratioOfPrices).div(currentDebt).mul(10**30).div(
            10**_decimals
        );

        return currentCollateralRatio;
    }

    /**
     * @notice used to calculate the total collateral tokens
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @param _id identifier for the credit line
     * @return _amount total collateral tokens deposited into the credit line
     */
    function calculateTotalCollateralTokens(uint256 _id) public returns (uint256 _amount) {
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        uint256 _liquidityShares;
        for (uint256 index = 0; index < _strategyList.length; index++) {
            if (_strategyList[index] == address(0)) {
                continue;
            }
            _liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];
            uint256 _tokenInStrategy = _liquidityShares;
            _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(_liquidityShares, _collateralAsset);

            _amount = _amount.add(_tokenInStrategy);
        }
    }

    /**
     * @notice used to withdraw any excess collateral
     * @dev collateral can't be withdraw if collateralRatio goes below the ideal value. Only borrower can withdraw
     * @param _id identifier for the credit line
     * @param _amount amount of collateral to withdraw
     * @param _toSavingsAccount if true, tokens are transferred from savingsAccount 
                                otherwise direct from collateral token contract
     */
    function withdrawCollateral(
        uint256 _id,
        uint256 _amount,
        bool _toSavingsAccount
    ) external nonReentrant onlyCreditLineBorrower(_id) {
        uint256 _withdrawableCollateral = withdrawableCollateral(_id);
        require(_amount <= _withdrawableCollateral, 'Collateral ratio cant go below ideal');
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        _transferCollateral(_id, _collateralAsset, _amount, _toSavingsAccount);
        emit CollateralWithdrawn(_id, _amount);
    }

    /**
     * @notice used to calculate the collateral that can be withdrawn
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @param _id identifier for the credit line
     * @return total collateral withdrawable by borrower
     */
    function withdrawableCollateral(uint256 _id) public returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(
            creditLineConstants[_id].collateralAsset,
            creditLineConstants[_id].borrowAsset
        );

        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);
        uint256 _currentDebt = calculateCurrentDebt(_id);

        uint256 _collateralNeeded = _currentDebt
            .mul(creditLineConstants[_id].idealCollateralRatio)
            .div(_ratioOfPrices)
            .mul(10**_decimals)
            .div(10**30);

        if (_collateralNeeded >= _totalCollateralTokens) {
            return 0;
        }
        return _totalCollateralTokens.sub(_collateralNeeded);
    }

    function _transferCollateral(
        uint256 _id,
        address _asset,
        uint256 _amountInTokens,
        bool _toSavingsAccount
    ) internal {
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        uint256 _activeAmount;
        for (uint256 index = 0; index < _strategyList.length; index++) {
            uint256 liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];
            if (liquidityShares == 0 || _strategyList[index] == address(0)) {
                continue;
            }
            uint256 _tokenInStrategy = liquidityShares;
            _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(liquidityShares, _asset);
            uint256 _tokensToTransfer = _tokenInStrategy;
            if (_activeAmount.add(_tokenInStrategy) > _amountInTokens) {
                _tokensToTransfer = _amountInTokens.sub(_activeAmount);
                liquidityShares = liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy);
            }
            _activeAmount = _activeAmount.add(_tokensToTransfer);
            collateralShareInStrategy[_id][_strategyList[index]] = collateralShareInStrategy[_id][_strategyList[index]].sub(
                liquidityShares
            );
            if (_toSavingsAccount) {
                ISavingsAccount(savingsAccount).transfer(_tokensToTransfer, _asset, _strategyList[index], msg.sender);
            } else {
                ISavingsAccount(savingsAccount).withdraw(_tokensToTransfer, _asset, _strategyList[index], msg.sender, false);
            }

            if (_activeAmount == _amountInTokens) {
                return;
            }
        }
        revert('insufficient collateral');
    }

    /**
     * @notice used to liquidate credit line in case collateral ratio goes below the threshold
     * @dev if lender liquidates, then collateral is directly transferred. 
            If autoLiquidation is true, anyone can liquidate by providing enough borrow tokens
     * @param _id identifier for the credit line
     * @param _toSavingsAccount if true, tokens are transferred from savingsAccount 
                                otherwise direct from collateral token contract
     */
    function liquidate(uint256 _id, bool _toSavingsAccount) external payable nonReentrant {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: Credit line should be active.');
        require(creditLineVariables[_id].principal != 0, 'CreditLine: cannot liquidate if principal is 0');

        uint256 currentCollateralRatio = calculateCurrentCollateralRatio(_id);
        require(
            currentCollateralRatio < creditLineConstants[_id].idealCollateralRatio,
            'CreditLine: Collateral ratio is higher than ideal value'
        );

        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        address _lender = creditLineConstants[_id].lender;
        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);
        address _borrowAsset = creditLineConstants[_id].borrowAsset;

        creditLineVariables[_id].status = CreditLineStatus.LIQUIDATED;

        if (creditLineConstants[_id].autoLiquidation && _lender != msg.sender) {
            uint256 _borrowTokens = _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens);
            if (_borrowAsset == address(0)) {
                uint256 _returnETH = msg.value.sub(_borrowTokens, 'Insufficient ETH to liquidate');
                if (_returnETH != 0) {
                    (bool success, ) = msg.sender.call{value: _returnETH}('');
                    require(success, 'Transfer fail');
                }
            } else {
                IERC20(_borrowAsset).safeTransferFrom(msg.sender, _lender, _borrowTokens);
            }
        }

        _transferCollateral(_id, _collateralAsset, _totalCollateralTokens, _toSavingsAccount);

        emit CreditLineLiquidated(_id, msg.sender);
    }

    /**
     * @notice used to calculate the borrow tokens necessary for liquidator to liquidate
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @param _id identifier for the credit line
     * @return borrow tokens necessary for liquidator to liquidate
     */
    function borrowTokensToLiquidate(uint256 _id) external returns (uint256) {
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);
        address _borrowAsset = creditLineConstants[_id].borrowAsset;

        return _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens);
    }

    function _borrowTokensToLiquidate(
        address _borrowAsset,
        address _collateralAsset,
        uint256 _totalCollateralTokens
    ) internal view returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(_borrowAsset, _collateralAsset);
        uint256 _borrowTokens = (
            _totalCollateralTokens.mul(uint256(10**30).sub(liquidatorRewardFraction)).div(10**30).mul(_ratioOfPrices).div(10**_decimals)
        );

        return _borrowTokens;
    }

    receive() external payable {
        require(msg.sender == savingsAccount, 'CreditLine::receive invalid transaction');
    }
}
.]

Based on the provided smart contract code for the Credit Line contract, here is a summary of the identified security vulnerabilities and issues:

### Identified Security Vulnerabilities:

1. **Reentrancy Attacks**:
   - Although the contract uses `ReentrancyGuard`, there are several functions that could still be vulnerable to reentrancy if not properly protected, especially those that involve external calls (e.g., `borrow`, `repay`, `liquidate`, etc.).

2. **Lack of Input Validation**:
   - Some functions do not adequately validate inputs, such as ensuring that amounts are greater than zero before proceeding with operations (e.g., `borrow`, `repay`, `withdrawCollateral`).

3. **Potential for Integer Overflow/Underflow**:
   - While the contract uses `SafeMath`, there are still areas where arithmetic operations could lead to unexpected results if not properly handled, particularly in calculations involving interest and collateral ratios.

4. **Access Control Issues**:
   - The contract relies heavily on the `onlyOwner` modifier for critical functions. If the owner’s address is compromised, it could lead to unauthorized access to sensitive functions.

5. **Gas Limit Issues**:
   - Functions that iterate over arrays (e.g., `_depositCollateralFromSavingsAccount`, `_withdrawBorrowAmount`) could run into gas limit issues if the number of strategies grows significantly.

6. **Improper Handling of Ether**:
   - The contract allows for Ether to be sent and received, but there are no checks to ensure that the amount sent matches expected values, which could lead to loss of funds.

7. **Lack of Event Emissions**:
   - Certain state-changing functions do not emit events, which could hinder tracking and auditing of contract activity.

8. **Price Oracle Dependency**:
   - The contract relies on an external price oracle for collateral valuation. If the oracle is compromised or provides inaccurate data, it could lead to incorrect calculations of collateral ratios and borrowing limits.

9. **Potential for Front-Running**:
   - The contract does not implement any mechanisms to prevent front-running, which could allow malicious actors to exploit the timing of transactions for profit.

10. **Insufficient Error Handling**:
    - The contract uses `require` statements for error handling, but there are instances where more informative error messages could be provided to aid in debugging and understanding failures.

### Comprehensive Analysis Report:

The Credit Line contract exhibits several security vulnerabilities that could potentially be exploited by malicious actors. The use of `ReentrancyGuard` is a positive step towards mitigating reentrancy attacks; however, the contract's reliance on external calls and the complexity of certain functions still pose risks. Input validation is insufficient in several areas, which could lead to unexpected behavior or loss of funds.

Access control is primarily managed through the `onlyOwner` modifier, which, while effective, creates a single point of failure if the owner's private key is compromised. Additionally, the contract's reliance on external price oracles introduces a dependency that could be exploited if the oracle is not secure.

The potential for gas limit issues in functions that iterate over arrays is a concern, especially as the number of strategies increases. Furthermore, the handling of Ether transactions lacks sufficient checks, which could lead to unintended consequences.

Overall, while the contract implements several best practices, it requires further enhancements in input validation, error handling, and access control mechanisms to ensure a robust security posture. It is recommended to conduct thorough testing, including unit tests and formal verification, to identify and address these vulnerabilities before deployment. Additionally, implementing mechanisms to prevent front-running and ensuring that all state changes are accompanied by appropriate event emissions will enhance the contract's security and transparency.

[2024-22-08 11:43:38 INFO] **[Seminar Conclusion]**:

 Based on the provided smart contract code for the Credit Line contract, here is a summary of the identified security vulnerabilities and issues:

### Identified Security Vulnerabilities:

1. **Reentrancy Attacks**:
   - Although the contract uses `ReentrancyGuard`, there are several functions that could still be vulnerable to reentrancy if not properly protected, especially those that involve external calls (e.g., `borrow`, `repay`, `liquidate`, etc.).

2. **Lack of Input Validation**:
   - Some functions do not adequately validate inputs, such as ensuring that amounts are greater than zero before proceeding with operations (e.g., `borrow`, `repay`, `withdrawCollateral`).

3. **Potential for Integer Overflow/Underflow**:
   - While the contract uses `SafeMath`, there are still areas where arithmetic operations could lead to unexpected results if not properly handled, particularly in calculations involving interest and collateral ratios.

4. **Access Control Issues**:
   - The contract relies heavily on the `onlyOwner` modifier for critical functions. If the owner’s address is compromised, it could lead to unauthorized access to sensitive functions.

5. **Gas Limit Issues**:
   - Functions that iterate over arrays (e.g., `_depositCollateralFromSavingsAccount`, `_withdrawBorrowAmount`) could run into gas limit issues if the number of strategies grows significantly.

6. **Improper Handling of Ether**:
   - The contract allows for Ether to be sent and received, but there are no checks to ensure that the amount sent matches expected values, which could lead to loss of funds.

7. **Lack of Event Emissions**:
   - Certain state-changing functions do not emit events, which could hinder tracking and auditing of contract activity.

8. **Price Oracle Dependency**:
   - The contract relies on an external price oracle for collateral valuation. If the oracle is compromised or provides inaccurate data, it could lead to incorrect calculations of collateral ratios and borrowing limits.

9. **Potential for Front-Running**:
   - The contract does not implement any mechanisms to prevent front-running, which could allow malicious actors to exploit the timing of transactions for profit.

10. **Insufficient Error Handling**:
    - The contract uses `require` statements for error handling, but there are instances where more informative error messages could be provided to aid in debugging and understanding failures.

### Comprehensive Analysis Report:

The Credit Line contract exhibits several security vulnerabilities that could potentially be exploited by malicious actors. The use of `ReentrancyGuard` is a positive step towards mitigating reentrancy attacks; however, the contract's reliance on external calls and the complexity of certain functions still pose risks. Input validation is insufficient in several areas, which could lead to unexpected behavior or loss of funds.

Access control is primarily managed through the `onlyOwner` modifier, which, while effective, creates a single point of failure if the owner's private key is compromised. Additionally, the contract's reliance on external price oracles introduces a dependency that could be exploited if the oracle is not secure.

The potential for gas limit issues in functions that iterate over arrays is a concern, especially as the number of strategies increases. Furthermore, the handling of Ether transactions lacks sufficient checks, which could lead to unintended consequences.

Overall, while the contract implements several best practices, it requires further enhancements in input validation, error handling, and access control mechanisms to ensure a robust security posture. It is recommended to conduct thorough testing, including unit tests and formal verification, to identify and address these vulnerabilities before deployment. Additionally, implementing mechanisms to prevent front-running and ensuring that all state changes are accompanied by appropriate event emissions will enhance the contract's security and transparency.

[2024-22-08 11:43:38 INFO] **[Execute Detail]**

execute SimplePhase:[ContractReviewComment] in ComposedPhase:[CodeReview], cycle 3

[2024-22-08 11:43:38 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol'; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/utils/ReentrancyGuard.sol'; import '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol'; import '../interfaces/IPriceOracle.sol'; import '../interfaces/IYield.sol'; import '../interfaces/ISavingsAccount.sol'; import '../SavingsAccount/SavingsAccountUtil.sol'; import '../interfaces/IStrategyRegistry.sol'; /  * @title Credit Line contract with Methods related to credit Line  * @notice Implements the functions related to Credit Line  * @author Sublime  / contract CreditLine is ReentrancyGuard, OwnableUpgradeable {     using SafeERC20 for IERC20;     using SafeMath for uint256; enum CreditLineStatus {     NOT_CREATED,     REQUESTED,     ACTIVE,     CLOSED,     CANCELLED,     LIQUIDATED }  /**  * @notice counter that tracks the number of credit lines created  * @dev used to create unique identifier for credit lines  **/ uint256 public creditLineCounter;  uint256 constant YEAR_IN_SECONDS = 365 days;  struct CreditLineVariables {     CreditLineStatus status;     uint256 principal;     uint256 totalInterestRepaid;     uint256 lastPrincipalUpdateTime;     uint256 interestAccruedTillLastPrincipalUpdate; }  struct CreditLineConstants {     address lender;     address borrower;     uint256 borrowLimit;     uint256 idealCollateralRatio;     uint256 borrowRate;     address borrowAsset;     address collateralAsset;     bool autoLiquidation;     bool requestByLender; } /**  * @notice stores the collateral shares in a credit line per strategy  * @dev creditLineId =&gt; Strategy =&gt; collateralShares  **/ mapping(uint256 =&gt; mapping(address =&gt; uint256)) public collateralShareInStrategy;  /**  * @notice stores the variables to maintain a credit line  **/ mapping(uint256 =&gt; CreditLineVariables) public creditLineVariables;  /**  * @notice stores the constants related to a credit line  **/ mapping(uint256 =&gt; CreditLineConstants) public creditLineConstants;  /**  * @notice stores the address of savings account contract  **/ address public savingsAccount;  /**  * @notice stores the address of price oracle contract  **/ address public priceOracle;  /**  * @notice stores the address of strategy registry contract  **/ address public strategyRegistry;  /**  * @notice stores the address of default strategy  **/ address public defaultStrategy;  /**  * @notice stores the fraction of borrowed amount charged as fee by protocol  * @dev it is multiplied by 10**30  **/ uint256 public protocolFeeFraction;  /**  * @notice address where protocol fee is collected  **/ address public protocolFeeCollector;  /**  * @notice stores the fraction of amount liquidated given as reward to liquidator  * @dev it is multiplied by 10**30  **/ uint256 public liquidatorRewardFraction; /**  * @dev checks if Credit Line exists  * @param _id identifier for the credit line  **/ modifier ifCreditLineExists(uint256 _id) {     require(creditLineVariables[_id].status != CreditLineStatus.NOT_CREATED, 'Credit line does not exist');     _; }  /**  * @dev checks if called by credit Line Borrower  * @param _id creditLine identifier  **/ modifier onlyCreditLineBorrower(uint256 _id) {     require(creditLineConstants[_id].borrower == msg.sender, 'Only credit line Borrower can access');     _; }  /**  * @dev checks if called by credit Line Lender  * @param _id creditLine identifier  **/ modifier onlyCreditLineLender(uint256 _id) {     require(creditLineConstants[_id].lender == msg.sender, 'Only credit line Lender can access');     _; }  /**  * @notice emitted when a collateral is deposited into credit line  * @param id id of the credit line  * @param amount amount of collateral deposited  * @param strategy address of the strategy into which collateral is deposited  */ event CollateralDeposited(uint256 indexed id, uint256 amount, address indexed strategy);  /**  * @notice emitted when collateral is withdrawn from credit line  * @param id id of the credit line  * @param amount amount of collateral withdrawn  */ event CollateralWithdrawn(uint256 indexed id, uint256 amount);  /**  * @notice emitted when a request for new credit line is placed  * @param id id of the credit line for which request was made  * @param lender address of the lender for credit line  * @param borrower address of the borrower for credit line  */ event CreditLineRequested(uint256 indexed id, address indexed lender, address indexed borrower);  /**  * @notice emitted when a credit line is liquidated  * @param id id of the credit line which is liquidated  * @param liquidator address of the liquidator  */ event CreditLineLiquidated(uint256 indexed id, address indexed liquidator);  /**  * @notice emitted when tokens are borrowed from credit line  * @param id id of the credit line from which tokens are borrowed  * @param borrowAmount amount of tokens borrowed  */ event BorrowedFromCreditLine(uint256 indexed id, uint256 borrowAmount);  /**  * @notice emitted when credit line is accepted  * @param id id of the credit line that was accepted  */ event CreditLineAccepted(uint256 indexed id);  /**  * @notice emitted when credit line is completely repaid and reset  * @param id id of the credit line that is reset  */ event CreditLineReset(uint256 indexed id);  /**  * @notice emitted when the credit line is partially repaid  * @param id id of the credit line  * @param repayAmount amount repaid  */ event PartialCreditLineRepaid(uint256 indexed id, uint256 repayAmount);  /**  * @notice emitted when the credit line is completely repaid  * @param id id of the credit line  * @param repayAmount amount repaid  */ event CompleteCreditLineRepaid(uint256 indexed id, uint256 repayAmount);  /**  * @notice emitted when the credit line is closed by one of the parties of credit line  * @param id id of the credit line  */ event CreditLineClosed(uint256 indexed id);  /**  * @notice emitted when default strategy for the credit line is updated  * @param defaultStrategy address of the strategy contract that is used as default by credit lines  */ event DefaultStrategyUpdated(address indexed defaultStrategy);  /**  * @notice emitted when the price oracle is updated  * @param priceOracle address of the updated price oracle  */ event PriceOracleUpdated(address indexed priceOracle);  /**  * @notice emitted when the savings account address is updated  * @param savingsAccount address of the updated savingsAccount  */ event SavingsAccountUpdated(address indexed savingsAccount);  /**  * @notice emitted when strategy registry address is updated  * @param strategyRegistry address of the updated strategy registry  */ event StrategyRegistryUpdated(address indexed strategyRegistry);  /**  * @notice emitted when fee that protocol charges for credit line is updated  * @param updatedProtocolFee updated value of protocolFeeFraction  */ event ProtocolFeeFractionUpdated(uint256 updatedProtocolFee);  /**  * @notice emitted when address which receives fee that protocol changes for pools is updated  * @param updatedProtocolFeeCollector updated value of protocolFeeCollector  */ event ProtocolFeeCollectorUpdated(address indexed updatedProtocolFeeCollector);  /**  * @notice emitted when liquidatorRewardFraction is updated  * @param liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator  */ event LiquidationRewardFractionUpdated(uint256 liquidatorRewardFraction);  /**  * @notice used to initialize the contract  * @dev can only be called once during the life cycle of the contract  * @param _defaultStrategy default strategy used in credit lines  * @param _priceOracle address of the priceOracle  * @param _savingsAccount address of  the savings account contract  * @param _strategyRegistry address of the strategy registry contract  * @param _owner address of owner who can change global variables  * @param _protocolFeeFraction fraction of the fee charged by protocol  * @param _protocolFeeCollector address to which protocol fee is charged to  * @param _liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator  */ function initialize(     address _defaultStrategy,     address _priceOracle,     address _savingsAccount,     address _strategyRegistry,     address _owner,     uint256 _protocolFeeFraction,     address _protocolFeeCollector,     uint256 _liquidatorRewardFraction ) external initializer {     OwnableUpgradeable.__Ownable_init();     OwnableUpgradeable.transferOwnership(_owner);      _updateDefaultStrategy(_defaultStrategy);     _updatePriceOracle(_priceOracle);     _updateSavingsAccount(_savingsAccount);     _updateStrategyRegistry(_strategyRegistry);     _updateProtocolFeeFraction(_protocolFeeFraction);     _updateProtocolFeeCollector(_protocolFeeCollector);     _updateLiquidatorRewardFraction(_liquidatorRewardFraction); }  /**  * @notice used to update the default strategy  * @dev can only be updated by owner  * @param _defaultStrategy address of the updated default strategy  */ function updateDefaultStrategy(address _defaultStrategy) external onlyOwner {     _updateDefaultStrategy(_defaultStrategy); }  function _updateDefaultStrategy(address _defaultStrategy) internal {     defaultStrategy = _defaultStrategy;     emit DefaultStrategyUpdated(_defaultStrategy); }  /**  * @notice used to update the price oracle  * @dev can only be updated by owner  * @param _priceOracle address of the updated price oracle  */ function updatePriceOracle(address _priceOracle) external onlyOwner {     _updatePriceOracle(_priceOracle); }  function _updatePriceOracle(address _priceOracle) internal {     priceOracle = _priceOracle;     emit PriceOracleUpdated(_priceOracle); }  /**  * @notice used to update the savings account address  * @dev can only be updated by owner  * @param _savingsAccount address of the updated savings account  */ function updateSavingsAccount(address _savingsAccount) external onlyOwner {     _updateSavingsAccount(_savingsAccount); }  function _updateSavingsAccount(address _savingsAccount) internal {     savingsAccount = _savingsAccount;     emit SavingsAccountUpdated(_savingsAccount); }  /**  * @notice used to update the protocol fee fraction  * @dev can only be updated by owner  * @param _protocolFee fraction of the borrower amount collected as protocol fee  */ function updateProtocolFeeFraction(uint256 _protocolFee) external onlyOwner {     _updateProtocolFeeFraction(_protocolFee); }  function _updateProtocolFeeFraction(uint256 _protocolFee) internal {     protocolFeeFraction = _protocolFee;     emit ProtocolFeeFractionUpdated(_protocolFee); }  /**  * @notice used to update the protocol fee collector  * @dev can only be updated by owner  * @param _protocolFeeCollector address in which protocol fee is collected  */ function updateProtocolFeeCollector(address _protocolFeeCollector) external onlyOwner {     _updateProtocolFeeCollector(_protocolFeeCollector); }  function _updateProtocolFeeCollector(address _protocolFeeCollector) internal {     require(_protocolFeeCollector != address(0), 'cant be 0 address');     protocolFeeCollector = _protocolFeeCollector;     emit ProtocolFeeCollectorUpdated(_protocolFeeCollector); }  /**  * @notice used to update the strategy registry address  * @dev can only be updated by owner  * @param _strategyRegistry address of the updated strategy registry  */ function updateStrategyRegistry(address _strategyRegistry) external onlyOwner {     _updateStrategyRegistry(_strategyRegistry); }  function _updateStrategyRegistry(address _strategyRegistry) internal {     require(_strategyRegistry != address(0), 'CL::I zero address');     strategyRegistry = _strategyRegistry;     emit StrategyRegistryUpdated(_strategyRegistry); }  /**  * @notice used to update the liquidatorRewardFraction  * @dev can only be updated by owner  * @param _rewardFraction fraction of liquidated amount given to liquidator as reward  */ function updateLiquidatorRewardFraction(uint256 _rewardFraction) external onlyOwner {     _updateLiquidatorRewardFraction(_rewardFraction); }  function _updateLiquidatorRewardFraction(uint256 _rewardFraction) internal {     require(_rewardFraction &lt;= 10**30, 'Fraction has to be less than 1');     liquidatorRewardFraction = _rewardFraction;     emit LiquidationRewardFractionUpdated(_rewardFraction); }  /**  * @dev Used to Calculate Interest Per second on given principal and Interest rate  * @param _principal principal Amount for which interest has to be calculated.  * @param _borrowRate It is the Interest Rate at which Credit Line is approved  * @return interest per second for the given parameters  */ function calculateInterest(     uint256 _principal,     uint256 _borrowRate,     uint256 _timeElapsed ) public pure returns (uint256) {     uint256 _interest = _principal.mul(_borrowRate).mul(_timeElapsed).div(10**30).div(YEAR_IN_SECONDS);      return _interest; }  /**  * @dev Used to calculate interest accrued since last repayment  * @param _id identifier for the credit line  * @return interest accrued over current borrowed amount since last repayment  */  function calculateInterestAccrued(uint256 _id) public view returns (uint256) {     uint256 _lastPrincipalUpdateTime = creditLineVariables[_id].lastPrincipalUpdateTime;     if (_lastPrincipalUpdateTime == 0) return 0;     uint256 _timeElapsed = (block.timestamp).sub(_lastPrincipalUpdateTime);     uint256 _interestAccrued = calculateInterest(creditLineVariables[_id].principal, creditLineConstants[_id].borrowRate, _timeElapsed);     return _interestAccrued; }  /**  * @dev Used to calculate current debt of borrower against a credit line.  * @param _id identifier for the credit line  * @return current debt of borrower  */ function calculateCurrentDebt(uint256 _id) public view returns (uint256) {     uint256 _interestAccrued = calculateInterestAccrued(_id);     uint256 _currentDebt = (creditLineVariables[_id].principal)         .add(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate)         .add(_interestAccrued)         .sub(creditLineVariables[_id].totalInterestRepaid);     return _currentDebt; }  /**  * @notice used to calculate amount that can be borrowed by the borrower  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view.         borrowableAmount changes per block as interest changes per block.  * @param _id identifier for the credit line  * @return amount that can be borrowed from the credit line  */ function calculateBorrowableAmount(uint256 _id) public returns (uint256) {     CreditLineStatus _status = creditLineVariables[_id].status;     require(         _status == CreditLineStatus.ACTIVE || _status == CreditLineStatus.REQUESTED,         'CreditLine: Cannot only if credit line ACTIVE or REQUESTED'     );     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(         creditLineConstants[_id].collateralAsset,         creditLineConstants[_id].borrowAsset     );      uint256 _totalCollateralToken = calculateTotalCollateralTokens(_id);      uint256 _currentDebt = calculateCurrentDebt(_id);      uint256 _maxPossible = _totalCollateralToken.mul(_ratioOfPrices).div(creditLineConstants[_id].idealCollateralRatio).mul(10**30).div(         10**_decimals     );      uint256 _borrowLimit = creditLineConstants[_id].borrowLimit;      if (_maxPossible &gt; _borrowLimit) {         _maxPossible = _borrowLimit;     }     if (_maxPossible &gt; _currentDebt) {         return _maxPossible.sub(_currentDebt);     }     return 0; }  function updateinterestAccruedTillLastPrincipalUpdate(uint256 _id) internal {     require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');      uint256 _interestAccrued = calculateInterestAccrued(_id);     uint256 _newInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(_interestAccrued);     creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _newInterestAccrued; }  function _depositCollateralFromSavingsAccount(     uint256 _id,     uint256 _amount,     address _sender ) internal {     address _collateralAsset = creditLineConstants[_id].collateralAsset;     address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();     ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);     uint256 _activeAmount;      for (uint256 _index = 0; _index &lt; _strategyList.length; _index++) {         address _strategy = _strategyList[_index];         uint256 _liquidityShares = _savingsAccount.balanceInShares(_sender, _collateralAsset, _strategy);         if (_liquidityShares == 0 || _strategyList[_index] == address(0)) {             continue;         }         uint256 _tokenInStrategy = _liquidityShares;         _tokenInStrategy = IYield(_strategy).getTokensForShares(_liquidityShares, _collateralAsset);          uint256 _tokensToTransfer = _tokenInStrategy;         if (_activeAmount.add(_tokenInStrategy) &gt;= _amount) {             _tokensToTransfer = (_amount.sub(_activeAmount));         }         _activeAmount = _activeAmount.add(_tokensToTransfer);         _savingsAccount.transferFrom(_tokensToTransfer, _collateralAsset, _strategy, _sender, address(this));          collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(             _liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy)         );          if (_amount == _activeAmount) {             return;         }     }     revert('CreditLine::_depositCollateralFromSavingsAccount - Insufficient balance'); }  /**  * @notice used to request a credit line either by borrower or lender  * @param _requestTo Address to which creditLine is requested,                      if borrower creates request then lender address and                      if lender creates then borrower address  * @param _borrowLimit maximum borrow amount in a credit line  * @param _borrowRate Interest Rate at which credit Line is requested  * @param _autoLiquidation if true, anyone can liquidate loan, otherwise only lender  * @param _collateralRatio ratio of the collateral to the debt below which credit line can be liquidated  * @param _borrowAsset address of the token to be borrowed  * @param _collateralAsset address of the token provided as collateral  * @param _requestAsLender if true, lender is placing request, otherwise borrower  * @return identifier for the credit line  */  function request(     address _requestTo,     uint256 _borrowLimit,     uint256 _borrowRate,     bool _autoLiquidation,     uint256 _collateralRatio,     address _borrowAsset,     address _collateralAsset,     bool _requestAsLender ) external returns (uint256) {     require(_borrowAsset != _collateralAsset, 'R: cant borrow lent token');     require(IPriceOracle(priceOracle).doesFeedExist(_borrowAsset, _collateralAsset), 'R: No price feed');      address _lender = _requestTo;     address _borrower = msg.sender;     if (_requestAsLender) {         _lender = msg.sender;         _borrower = _requestTo;     }      uint256 _id = _createRequest(         _lender,         _borrower,         _borrowLimit,         _borrowRate,         _autoLiquidation,         _collateralRatio,         _borrowAsset,         _collateralAsset,         _requestAsLender     );      emit CreditLineRequested(_id, _lender, _borrower);     return _id; }  function _createRequest(     address _lender,     address _borrower,     uint256 _borrowLimit,     uint256 _borrowRate,     bool _autoLiquidation,     uint256 _collateralRatio,     address _borrowAsset,     address _collateralAsset,     bool _requestByLender ) internal returns (uint256) {     require(_lender != _borrower, 'Lender and Borrower cannot be same addresses');     uint256 _id = creditLineCounter + 1;     creditLineCounter = _id;     creditLineVariables[_id].status = CreditLineStatus.REQUESTED;     creditLineConstants[_id].borrower = _borrower;     creditLineConstants[_id].lender = _lender;     creditLineConstants[_id].borrowLimit = _borrowLimit;     creditLineConstants[_id].autoLiquidation = _autoLiquidation;     creditLineConstants[_id].idealCollateralRatio = _collateralRatio;     creditLineConstants[_id].borrowRate = _borrowRate;     creditLineConstants[_id].borrowAsset = _borrowAsset;     creditLineConstants[_id].collateralAsset = _collateralAsset;     creditLineConstants[_id].requestByLender = _requestByLender;     return _id; }  /**  * @notice used to accept a credit line  * @dev if borrower places request, lender can accept and vice versa  * @param _id identifier for the credit line  */ function accept(uint256 _id) external {     require(         creditLineVariables[_id].status == CreditLineStatus.REQUESTED,         'CreditLine::acceptCreditLineLender - CreditLine is already accepted'     );     bool _requestByLender = creditLineConstants[_id].requestByLender;     require(         (msg.sender == creditLineConstants[_id].borrower &amp;&amp; _requestByLender) ||             (msg.sender == creditLineConstants[_id].lender &amp;&amp; !_requestByLender),         "Only Borrower or Lender who hasn't requested can accept"     );     creditLineVariables[_id].status = CreditLineStatus.ACTIVE;     emit CreditLineAccepted(_id); }  /**  * @notice used to deposit collateral into the credit line  * @dev collateral tokens have to be approved in savingsAccount or token contract(unless ether).         If transferred from savings account, the tokens are transferred from strategies in the          order prespecified in strategy registry  * @param _id identifier for the credit line  * @param _amount amount of collateral being deposited  * @param _strategy strategy to which collateral is to be deposited in case transfer is not from savings account  * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount                              otherwise direct from collateral token contract  */ function depositCollateral(     uint256 _id,     uint256 _amount,     address _strategy,     bool _fromSavingsAccount ) external payable nonReentrant ifCreditLineExists(_id) {     require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine not active');     _depositCollateral(_id, _amount, _strategy, _fromSavingsAccount);     emit CollateralDeposited(_id, _amount, _strategy); }  function _depositCollateral(     uint256 _id,     uint256 _amount,     address _strategy,     bool _fromSavingsAccount ) internal {     require(creditLineConstants[_id].lender != msg.sender, 'lender cant deposit collateral');     if (_fromSavingsAccount) {         _depositCollateralFromSavingsAccount(_id, _amount, msg.sender);     } else {         address _collateralAsset = creditLineConstants[_id].collateralAsset;         ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);         if (_collateralAsset == address(0)) {             require(msg.value == _amount, "CreditLine::_depositCollateral - value to transfer doesn't match argument");         } else {             IERC20(_collateralAsset).safeTransferFrom(msg.sender, address(this), _amount);             IERC20(_collateralAsset).approve(_strategy, _amount);         }         uint256 _sharesReceived = _savingsAccount.deposit{value: msg.value}(_amount, _collateralAsset, _strategy, address(this));         collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(_sharesReceived);     } }  function _withdrawBorrowAmount(     address _asset,     uint256 _amountInTokens,     address _lender ) internal {     address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();     ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);     uint256 _activeAmount;     for (uint256 _index = 0; _index &lt; _strategyList.length; _index++) {         if (_strategyList[_index] == address(0)) {             continue;         }         uint256 _liquidityShares = _savingsAccount.balanceInShares(_lender, _asset, _strategyList[_index]);         if (_liquidityShares != 0) {             uint256 tokenInStrategy = _liquidityShares;             tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);             uint256 _tokensToTransfer = tokenInStrategy;             if (_activeAmount.add(tokenInStrategy) &gt;= _amountInTokens) {                 _tokensToTransfer = (_amountInTokens.sub(_activeAmount));             }             _activeAmount = _activeAmount.add(_tokensToTransfer);             _savingsAccount.withdrawFrom(_tokensToTransfer, _asset, _strategyList[_index], _lender, address(this), false);             if (_activeAmount == _amountInTokens) {                 return;             }         }     }     require(_activeAmount == _amountInTokens, 'insufficient balance'); }  /**  * @notice used to borrow tokens from credit line by borrower  * @dev only borrower can call this function. Amount that can actually be borrowed is          min(amount based on borrowLimit, allowance to creditLine contract, balance of lender)  * @param _id identifier for the credit line  * @param _amount amount of tokens to borrow  */ function borrow(uint256 _id, uint256 _amount) external payable nonReentrant onlyCreditLineBorrower(_id) {     require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');     uint256 _borrowableAmount = calculateBorrowableAmount(_id);     require(_amount &lt;= _borrowableAmount, "CreditLine::borrow - The current collateral ratio doesn't allow to withdraw the amount");     address _borrowAsset = creditLineConstants[_id].borrowAsset;     address _lender = creditLineConstants[_id].lender;      updateinterestAccruedTillLastPrincipalUpdate(_id);     creditLineVariables[_id].principal = creditLineVariables[_id].principal.add(_amount);     creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;      uint256 _tokenDiffBalance;     if (_borrowAsset != address(0)) {         uint256 _balanceBefore = IERC20(_borrowAsset).balanceOf(address(this));         _withdrawBorrowAmount(_borrowAsset, _amount, _lender);         uint256 _balanceAfter = IERC20(_borrowAsset).balanceOf(address(this));         _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);     } else {         uint256 _balanceBefore = address(this).balance;         _withdrawBorrowAmount(_borrowAsset, _amount, _lender);         uint256 _balanceAfter = address(this).balance;         _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);     }     uint256 _protocolFee = _tokenDiffBalance.mul(protocolFeeFraction).div(10**30);     _tokenDiffBalance = _tokenDiffBalance.sub(_protocolFee);      if (_borrowAsset == address(0)) {         (bool feeSuccess, ) = protocolFeeCollector.call{value: _protocolFee}('');         require(feeSuccess, 'Transfer fail');         (bool success, ) = msg.sender.call{value: _tokenDiffBalance}('');         require(success, 'Transfer fail');     } else {         IERC20(_borrowAsset).safeTransfer(protocolFeeCollector, _protocolFee);         IERC20(_borrowAsset).safeTransfer(msg.sender, _tokenDiffBalance);     }     emit BorrowedFromCreditLine(_id, _tokenDiffBalance); }  function _repayFromSavingsAccount(     uint256 _amount,     address _asset,     address _lender ) internal {     address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();     ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);     uint256 _activeAmount;      for (uint256 _index = 0; _index &lt; _strategyList.length; _index++) {         if (_strategyList[_index] == address(0)) {             continue;         }         uint256 _liquidityShares = _savingsAccount.balanceInShares(msg.sender, _asset, _strategyList[_index]);         if (_liquidityShares == 0) {             continue;         }         uint256 _tokenInStrategy = _liquidityShares;         _tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);          uint256 _tokensToTransfer = _tokenInStrategy;         if (_activeAmount.add(_tokenInStrategy) &gt;= _amount) {             _tokensToTransfer = (_amount.sub(_activeAmount));         }         _activeAmount = _activeAmount.add(_tokensToTransfer);         _savingsAccount.transferFrom(_tokensToTransfer, _asset, _strategyList[_index], msg.sender, _lender);          if (_amount == _activeAmount) {             return;         }     }     revert('CreditLine::_repayFromSavingsAccount - Insufficient balance'); }  function _repay(     uint256 _id,     uint256 _amount,     bool _fromSavingsAccount,     uint256 _principalPaid ) internal {     ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);     address _defaultStrategy = defaultStrategy;     address _borrowAsset = creditLineConstants[_id].borrowAsset;     address _lender = creditLineConstants[_id].lender;     if (!_fromSavingsAccount) {         if (_borrowAsset == address(0)) {             require(msg.value == _amount, 'creditLine::repay - Ether sent not equal to repay amount');             _savingsAccount.deposit{value: _amount}(_amount, _borrowAsset, _defaultStrategy, _lender);         } else {             IERC20(_borrowAsset).safeTransferFrom(msg.sender, address(this), _amount);             IERC20(_borrowAsset).approve(_defaultStrategy, _amount);             _savingsAccount.deposit(_amount, _borrowAsset, _defaultStrategy, _lender);         }     } else {         _repayFromSavingsAccount(_amount, _borrowAsset, _lender);     }     if (_principalPaid != 0) {         _savingsAccount.increaseAllowanceToCreditLine(_principalPaid, _borrowAsset, _lender);     } }  /**  * @notice used to repay interest and principal to credit line. Interest has to be repaid before repaying principal  * @dev partial repayments possible  * @param _id identifier for the credit line  * @param _amount amount being repaid  * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount                              otherwise direct from collateral token contract  */ function repay(     uint256 _id,     uint256 _amount,     bool _fromSavingsAccount ) external payable nonReentrant {     require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');     require(creditLineConstants[_id].lender != msg.sender, 'Lender cant repay');      uint256 _interestSincePrincipalUpdate = calculateInterestAccrued(_id);     uint256 _totalInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(         _interestSincePrincipalUpdate     );     uint256 _interestToPay = _totalInterestAccrued.sub(creditLineVariables[_id].totalInterestRepaid);     uint256 _totalCurrentDebt = _interestToPay.add(creditLineVariables[_id].principal);     uint256 _principalPaid = 0;      if (_amount &gt;= _totalCurrentDebt) {         _amount = _totalCurrentDebt;         emit CompleteCreditLineRepaid(_id, _amount);     } else {         emit PartialCreditLineRepaid(_id, _amount);     }      if (_amount &gt; _interestToPay) {         creditLineVariables[_id].principal = _totalCurrentDebt.sub(_amount);         creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _totalInterestAccrued;         creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;         creditLineVariables[_id].totalInterestRepaid = _totalInterestAccrued;         _principalPaid = _amount.sub(_interestToPay);     } else {         creditLineVariables[_id].totalInterestRepaid = creditLineVariables[_id].totalInterestRepaid.add(_amount);     }      _repay(_id, _amount, _fromSavingsAccount, _principalPaid);      if (creditLineVariables[_id].principal == 0) {         _resetCreditLine(_id);     } }  function _resetCreditLine(uint256 _id) internal {     creditLineVariables[_id].lastPrincipalUpdateTime = 0;     creditLineVariables[_id].totalInterestRepaid = 0;     creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = 0;     emit CreditLineReset(_id); }  /**  * @dev used to close credit line by borrower or lender  * @param _id identifier for the credit line  */ function close(uint256 _id) external ifCreditLineExists(_id) {     require(         msg.sender == creditLineConstants[_id].borrower || msg.sender == creditLineConstants[_id].lender,         'CreditLine: Permission denied while closing Line of credit'     );     require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: Credit line should be active.');     require(creditLineVariables[_id].principal == 0, 'CreditLine: Cannot be closed since not repaid.');     require(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate == 0, 'CreditLine: Cannot be closed since not repaid.');     creditLineVariables[_id].status = CreditLineStatus.CLOSED;     emit CreditLineClosed(_id); }  /**  * @notice used to calculate the current collateral ratio  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view.         Interest is also considered while calculating debt  * @param _id identifier for the credit line  * @return collateral ratio multiplied by 10**30 to retain precision  */ function calculateCurrentCollateralRatio(uint256 _id) public ifCreditLineExists(_id) returns (uint256) {     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(         creditLineConstants[_id].collateralAsset,         creditLineConstants[_id].borrowAsset     );      uint256 currentDebt = calculateCurrentDebt(_id);     uint256 currentCollateralRatio = calculateTotalCollateralTokens(_id).mul(_ratioOfPrices).div(currentDebt).mul(10**30).div(         10**_decimals     );      return currentCollateralRatio; }  /**  * @notice used to calculate the total collateral tokens  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view  * @param _id identifier for the credit line  * @return _amount total collateral tokens deposited into the credit line  */ function calculateTotalCollateralTokens(uint256 _id) public returns (uint256 _amount) {     address _collateralAsset = creditLineConstants[_id].collateralAsset;     address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();     uint256 _liquidityShares;     for (uint256 index = 0; index &lt; _strategyList.length; index++) {         if (_strategyList[index] == address(0)) {             continue;         }         _liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];         uint256 _tokenInStrategy = _liquidityShares;         _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(_liquidityShares, _collateralAsset);          _amount = _amount.add(_tokenInStrategy);     } }  /**  * @notice used to withdraw any excess collateral  * @dev collateral can't be withdraw if collateralRatio goes below the ideal value. Only borrower can withdraw  * @param _id identifier for the credit line  * @param _amount amount of collateral to withdraw  * @param _toSavingsAccount if true, tokens are transferred from savingsAccount                              otherwise direct from collateral token contract  */ function withdrawCollateral(     uint256 _id,     uint256 _amount,     bool _toSavingsAccount ) external nonReentrant onlyCreditLineBorrower(_id) {     uint256 _withdrawableCollateral = withdrawableCollateral(_id);     require(_amount &lt;= _withdrawableCollateral, 'Collateral ratio cant go below ideal');     address _collateralAsset = creditLineConstants[_id].collateralAsset;     _transferCollateral(_id, _collateralAsset, _amount, _toSavingsAccount);     emit CollateralWithdrawn(_id, _amount); }  /**  * @notice used to calculate the collateral that can be withdrawn  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view  * @param _id identifier for the credit line  * @return total collateral withdrawable by borrower  */ function withdrawableCollateral(uint256 _id) public returns (uint256) {     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(         creditLineConstants[_id].collateralAsset,         creditLineConstants[_id].borrowAsset     );      uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);     uint256 _currentDebt = calculateCurrentDebt(_id);      uint256 _collateralNeeded = _currentDebt         .mul(creditLineConstants[_id].idealCollateralRatio)         .div(_ratioOfPrices)         .mul(10**_decimals)         .div(10**30);      if (_collateralNeeded &gt;= _totalCollateralTokens) {         return 0;     }     return _totalCollateralTokens.sub(_collateralNeeded); }  function _transferCollateral(     uint256 _id,     address _asset,     uint256 _amountInTokens,     bool _toSavingsAccount ) internal {     address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();     uint256 _activeAmount;     for (uint256 index = 0; index &lt; _strategyList.length; index++) {         uint256 liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];         if (liquidityShares == 0 || _strategyList[index] == address(0)) {             continue;         }         uint256 _tokenInStrategy = liquidityShares;         _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(liquidityShares, _asset);         uint256 _tokensToTransfer = _tokenInStrategy;         if (_activeAmount.add(_tokenInStrategy) &gt; _amountInTokens) {             _tokensToTransfer = _amountInTokens.sub(_activeAmount);             liquidityShares = liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy);         }         _activeAmount = _activeAmount.add(_tokensToTransfer);         collateralShareInStrategy[_id][_strategyList[index]] = collateralShareInStrategy[_id][_strategyList[index]].sub(             liquidityShares         );         if (_toSavingsAccount) {             ISavingsAccount(savingsAccount).transfer(_tokensToTransfer, _asset, _strategyList[index], msg.sender);         } else {             ISavingsAccount(savingsAccount).withdraw(_tokensToTransfer, _asset, _strategyList[index], msg.sender, false);         }          if (_activeAmount == _amountInTokens) {             return;         }     }     revert('insufficient collateral'); }  /**  * @notice used to liquidate credit line in case collateral ratio goes below the threshold  * @dev if lender liquidates, then collateral is directly transferred.          If autoLiquidation is true, anyone can liquidate by providing enough borrow tokens  * @param _id identifier for the credit line  * @param _toSavingsAccount if true, tokens are transferred from savingsAccount                              otherwise direct from collateral token contract  */ function liquidate(uint256 _id, bool _toSavingsAccount) external payable nonReentrant {     require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: Credit line should be active.');     require(creditLineVariables[_id].principal != 0, 'CreditLine: cannot liquidate if principal is 0');      uint256 currentCollateralRatio = calculateCurrentCollateralRatio(_id);     require(         currentCollateralRatio &lt; creditLineConstants[_id].idealCollateralRatio,         'CreditLine: Collateral ratio is higher than ideal value'     );      address _collateralAsset = creditLineConstants[_id].collateralAsset;     address _lender = creditLineConstants[_id].lender;     uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);     address _borrowAsset = creditLineConstants[_id].borrowAsset;      creditLineVariables[_id].status = CreditLineStatus.LIQUIDATED;      if (creditLineConstants[_id].autoLiquidation &amp;&amp; _lender != msg.sender) {         uint256 _borrowTokens = _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens);         if (_borrowAsset == address(0)) {             uint256 _returnETH = msg.value.sub(_borrowTokens, 'Insufficient ETH to liquidate');             if (_returnETH != 0) {                 (bool success, ) = msg.sender.call{value: _returnETH}('');                 require(success, 'Transfer fail');             }         } else {             IERC20(_borrowAsset).safeTransferFrom(msg.sender, _lender, _borrowTokens);         }     }      _transferCollateral(_id, _collateralAsset, _totalCollateralTokens, _toSavingsAccount);      emit CreditLineLiquidated(_id, msg.sender); }  /**  * @notice used to calculate the borrow tokens necessary for liquidator to liquidate  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view  * @param _id identifier for the credit line  * @return borrow tokens necessary for liquidator to liquidate  */ function borrowTokensToLiquidate(uint256 _id) external returns (uint256) {     address _collateralAsset = creditLineConstants[_id].collateralAsset;     uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);     address _borrowAsset = creditLineConstants[_id].borrowAsset;      return _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens); }  function _borrowTokensToLiquidate(     address _borrowAsset,     address _collateralAsset,     uint256 _totalCollateralTokens ) internal view returns (uint256) {     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(_borrowAsset, _collateralAsset);     uint256 _borrowTokens = (         _totalCollateralTokens.mul(uint256(10**30).sub(liquidatorRewardFraction)).div(10**30).mul(_ratioOfPrices).div(10**_decimals)     );      return _borrowTokens; }  receive() external payable {     require(msg.sender == savingsAccount, 'CreditLine::receive invalid transaction'); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: "{task}". Ideas: "{ideas}". As the {assistant_role}, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability. For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix. Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: " Analysis Complete." |
| **phase_name** | ContractReviewComment |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 3, 'task': '// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\n\nimport \'@openzeppelin/contracts/token/ERC20/SafeERC20.sol\';\nimport \'@openzeppelin/contracts/math/SafeMath.sol\';\nimport \'@openzeppelin/contracts/utils/ReentrancyGuard.sol\';\nimport \'@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\';\nimport \'../interfaces/IPriceOracle.sol\';\nimport \'../interfaces/IYield.sol\';\nimport \'../interfaces/ISavingsAccount.sol\';\nimport \'../SavingsAccount/SavingsAccountUtil.sol\';\nimport \'../interfaces/IStrategyRegistry.sol\';\n\n/\n * @title Credit Line contract with Methods related to credit Line\n * @notice Implements the functions related to Credit Line\n * @author Sublime\n /\n\ncontract CreditLine is ReentrancyGuard, OwnableUpgradeable {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    enum CreditLineStatus {\n        NOT_CREATED,\n        REQUESTED,\n        ACTIVE,\n        CLOSED,\n        CANCELLED,\n        LIQUIDATED\n    }\n\n    /\n     * @notice counter that tracks the number of credit lines created\n     * @dev used to create unique identifier for credit lines\n     /\n    uint256 public creditLineCounter;\n\n    uint256 constant YEAR_IN_SECONDS = 365 days;\n\n    struct CreditLineVariables {\n        CreditLineStatus status;\n        uint256 principal;\n        uint256 totalInterestRepaid;\n        uint256 lastPrincipalUpdateTime;\n        uint256 interestAccruedTillLastPrincipalUpdate;\n    }\n\n    struct CreditLineConstants {\n        address lender;\n        address borrower;\n        uint256 borrowLimit;\n        uint256 idealCollateralRatio;\n        uint256 borrowRate;\n        address borrowAsset;\n        address collateralAsset;\n        bool autoLiquidation;\n        bool requestByLender;\n    }\n    /\n     * @notice stores the collateral shares in a credit line per strategy\n     * @dev creditLineId =&gt; Strategy =&gt; collateralShares\n     /\n    mapping(uint256 =&gt; mapping(address =&gt; uint256)) public collateralShareInStrategy;\n\n    /\n     * @notice stores the variables to maintain a credit line\n     /\n    mapping(uint256 =&gt; CreditLineVariables) public creditLineVariables;\n\n    /\n     * @notice stores the constants related to a credit line\n     /\n    mapping(uint256 =&gt; CreditLineConstants) public creditLineConstants;\n\n    /\n     * @notice stores the address of savings account contract\n     /\n    address public savingsAccount;\n\n    /\n     * @notice stores the address of price oracle contract\n     /\n    address public priceOracle;\n\n    /\n     * @notice stores the address of strategy registry contract\n     /\n    address public strategyRegistry;\n\n    /\n     * @notice stores the address of default strategy\n     /\n    address public defaultStrategy;\n\n    /\n     * @notice stores the fraction of borrowed amount charged as fee by protocol\n     * @dev it is multiplied by 1030\n     /\n    uint256 public protocolFeeFraction;\n\n    /\n     * @notice address where protocol fee is collected\n     /\n    address public protocolFeeCollector;\n\n    /\n     * @notice stores the fraction of amount liquidated given as reward to liquidator\n     * @dev it is multiplied by 1030\n     /\n    uint256 public liquidatorRewardFraction;\n    /\n     * @dev checks if Credit Line exists\n     * @param _id identifier for the credit line\n     /\n    modifier ifCreditLineExists(uint256 id) {\n        require(creditLineVariables[_id].status != CreditLineStatus.NOT_CREATED, \'Credit line does not exist\');\n        ;\n    }\n\n    /\n     * @dev checks if called by credit Line Borrower\n     * @param _id creditLine identifier\n     /\n    modifier onlyCreditLineBorrower(uint256 id) {\n        require(creditLineConstants[_id].borrower == msg.sender, \'Only credit line Borrower can access\');\n        ;\n    }\n\n    /\n     * @dev checks if called by credit Line Lender\n     * @param _id creditLine identifier\n     /\n    modifier onlyCreditLineLender(uint256 id) {\n        require(creditLineConstants[_id].lender == msg.sender, \'Only credit line Lender can access\');\n        ;\n    }\n\n    /\n     * @notice emitted when a collateral is deposited into credit line\n     * @param id id of the credit line\n     * @param amount amount of collateral deposited\n     * @param strategy address of the strategy into which collateral is deposited\n     */\n    event CollateralDeposited(uint256 indexed id, uint256 amount, address indexed strategy);\n\n    /\n     * @notice emitted when collateral is withdrawn from credit line\n     * @param id id of the credit line\n     * @param amount amount of collateral withdrawn\n     /\n    event CollateralWithdrawn(uint256 indexed id, uint256 amount);\n\n    /\n     * @notice emitted when a request for new credit line is placed\n     * @param id id of the credit line for which request was made\n     * @param lender address of the lender for credit line\n     * @param borrower address of the borrower for credit line\n     /\n    event CreditLineRequested(uint256 indexed id, address indexed lender, address indexed borrower);\n\n    /\n     * @notice emitted when a credit line is liquidated\n     * @param id id of the credit line which is liquidated\n     * @param liquidator address of the liquidator\n     */\n    event CreditLineLiquidated(uint256 indexed id, address indexed liquidator);\n\n    /\n     * @notice emitted when tokens are borrowed from credit line\n     * @param id id of the credit line from which tokens are borrowed\n     * @param borrowAmount amount of tokens borrowed\n     /\n    event BorrowedFromCreditLine(uint256 indexed id, uint256 borrowAmount);\n\n    /\n     * @notice emitted when credit line is accepted\n     * @param id id of the credit line that was accepted\n     /\n    event CreditLineAccepted(uint256 indexed id);\n\n    /\n     * @notice emitted when credit line is completely repaid and reset\n     * @param id id of the credit line that is reset\n     */\n    event CreditLineReset(uint256 indexed id);\n\n    /\n     * @notice emitted when the credit line is partially repaid\n     * @param id id of the credit line\n     * @param repayAmount amount repaid\n     /\n    event PartialCreditLineRepaid(uint256 indexed id, uint256 repayAmount);\n\n    /\n     * @notice emitted when the credit line is completely repaid\n     * @param id id of the credit line\n     * @param repayAmount amount repaid\n     /\n    event CompleteCreditLineRepaid(uint256 indexed id, uint256 repayAmount);\n\n    /\n     * @notice emitted when the credit line is closed by one of the parties of credit line\n     * @param id id of the credit line\n     */\n    event CreditLineClosed(uint256 indexed id);\n\n    /\n     * @notice emitted when default strategy for the credit line is updated\n     * @param defaultStrategy address of the strategy contract that is used as default by credit lines\n     /\n    event DefaultStrategyUpdated(address indexed defaultStrategy);\n\n    /\n     * @notice emitted when the price oracle is updated\n     * @param priceOracle address of the updated price oracle\n     /\n    event PriceOracleUpdated(address indexed priceOracle);\n\n    /\n     * @notice emitted when the savings account address is updated\n     * @param savingsAccount address of the updated savingsAccount\n     */\n    event SavingsAccountUpdated(address indexed savingsAccount);\n\n    /\n     * @notice emitted when strategy registry address is updated\n     * @param strategyRegistry address of the updated strategy registry\n     /\n    event StrategyRegistryUpdated(address indexed strategyRegistry);\n\n    /\n     * @notice emitted when fee that protocol charges for credit line is updated\n     * @param updatedProtocolFee updated value of protocolFeeFraction\n     /\n    event ProtocolFeeFractionUpdated(uint256 updatedProtocolFee);\n\n    /\n     * @notice emitted when address which receives fee that protocol changes for pools is updated\n     * @param updatedProtocolFeeCollector updated value of protocolFeeCollector\n     */\n    event ProtocolFeeCollectorUpdated(address indexed updatedProtocolFeeCollector);\n\n    /\n     * @notice emitted when liquidatorRewardFraction is updated\n     * @param liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator\n     /\n    event LiquidationRewardFractionUpdated(uint256 liquidatorRewardFraction);\n\n    /\n     * @notice used to initialize the contract\n     * @dev can only be called once during the life cycle of the contract\n     * @param _defaultStrategy default strategy used in credit lines\n     * @param _priceOracle address of the priceOracle\n     * @param _savingsAccount address of  the savings account contract\n     * @param _strategyRegistry address of the strategy registry contract\n     * @param _owner address of owner who can change global variables\n     * @param _protocolFeeFraction fraction of the fee charged by protocol\n     * @param _protocolFeeCollector address to which protocol fee is charged to\n     * @param _liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator\n     /\n    function initialize(\n        address _defaultStrategy,\n        address _priceOracle,\n        address _savingsAccount,\n        address _strategyRegistry,\n        address _owner,\n        uint256 _protocolFeeFraction,\n        address _protocolFeeCollector,\n        uint256 _liquidatorRewardFraction\n    ) external initializer {\n        OwnableUpgradeable.__Ownable_init();\n        OwnableUpgradeable.transferOwnership(_owner);\n\n        _updateDefaultStrategy(_defaultStrategy);\n        _updatePriceOracle(_priceOracle);\n        _updateSavingsAccount(_savingsAccount);\n        _updateStrategyRegistry(_strategyRegistry);\n        _updateProtocolFeeFraction(_protocolFeeFraction);\n        _updateProtocolFeeCollector(_protocolFeeCollector);\n        _updateLiquidatorRewardFraction(_liquidatorRewardFraction);\n    }\n\n    /\n     * @notice used to update the default strategy\n     * @dev can only be updated by owner\n     * @param _defaultStrategy address of the updated default strategy\n     */\n    function updateDefaultStrategy(address _defaultStrategy) external onlyOwner {\n        _updateDefaultStrategy(_defaultStrategy);\n    }\n\n    function _updateDefaultStrategy(address _defaultStrategy) internal {\n        defaultStrategy = _defaultStrategy;\n        emit DefaultStrategyUpdated(_defaultStrategy);\n    }\n\n    /\n     * @notice used to update the price oracle\n     * @dev can only be updated by owner\n     * @param _priceOracle address of the updated price oracle\n     /\n    function updatePriceOracle(address _priceOracle) external onlyOwner {\n        _updatePriceOracle(_priceOracle);\n    }\n\n    function _updatePriceOracle(address _priceOracle) internal {\n        priceOracle = _priceOracle;\n        emit PriceOracleUpdated(_priceOracle);\n    }\n\n    /\n     * @notice used to update the savings account address\n     * @dev can only be updated by owner\n     * @param _savingsAccount address of the updated savings account\n     /\n    function updateSavingsAccount(address _savingsAccount) external onlyOwner {\n        _updateSavingsAccount(_savingsAccount);\n    }\n\n    function _updateSavingsAccount(address _savingsAccount) internal {\n        savingsAccount = _savingsAccount;\n        emit SavingsAccountUpdated(_savingsAccount);\n    }\n\n    /\n     * @notice used to update the protocol fee fraction\n     * @dev can only be updated by owner\n     * @param _protocolFee fraction of the borrower amount collected as protocol fee\n     */\n    function updateProtocolFeeFraction(uint256 _protocolFee) external onlyOwner {\n        _updateProtocolFeeFraction(_protocolFee);\n    }\n\n    function _updateProtocolFeeFraction(uint256 _protocolFee) internal {\n        protocolFeeFraction = _protocolFee;\n        emit ProtocolFeeFractionUpdated(_protocolFee);\n    }\n\n    /\n     * @notice used to update the protocol fee collector\n     * @dev can only be updated by owner\n     * @param _protocolFeeCollector address in which protocol fee is collected\n     /\n    function updateProtocolFeeCollector(address _protocolFeeCollector) external onlyOwner {\n        _updateProtocolFeeCollector(_protocolFeeCollector);\n    }\n\n    function _updateProtocolFeeCollector(address _protocolFeeCollector) internal {\n        require(_protocolFeeCollector != address(0), \'cant be 0 address\');\n        protocolFeeCollector = _protocolFeeCollector;\n        emit ProtocolFeeCollectorUpdated(_protocolFeeCollector);\n    }\n\n    /\n     * @notice used to update the strategy registry address\n     * @dev can only be updated by owner\n     * @param _strategyRegistry address of the updated strategy registry\n     /\n    function updateStrategyRegistry(address _strategyRegistry) external onlyOwner {\n        _updateStrategyRegistry(_strategyRegistry);\n    }\n\n    function _updateStrategyRegistry(address _strategyRegistry) internal {\n        require(_strategyRegistry != address(0), \'CL::I zero address\');\n        strategyRegistry = _strategyRegistry;\n        emit StrategyRegistryUpdated(_strategyRegistry);\n    }\n\n    /\n     * @notice used to update the liquidatorRewardFraction\n     * @dev can only be updated by owner\n     * @param _rewardFraction fraction of liquidated amount given to liquidator as reward\n     */\n    function updateLiquidatorRewardFraction(uint256 _rewardFraction) external onlyOwner {\n        _updateLiquidatorRewardFraction(_rewardFraction);\n    }\n\n    function _updateLiquidatorRewardFraction(uint256 _rewardFraction) internal {\n        require(_rewardFraction &lt;= 1030, \'Fraction has to be less than 1\');\n        liquidatorRewardFraction = _rewardFraction;\n        emit LiquidationRewardFractionUpdated(_rewardFraction);\n    }\n\n    /\n     * @dev Used to Calculate Interest Per second on given principal and Interest rate\n     * @param _principal principal Amount for which interest has to be calculated.\n     * @param _borrowRate It is the Interest Rate at which Credit Line is approved\n     * @return interest per second for the given parameters\n     */\n    function calculateInterest(\n        uint256 _principal,\n        uint256 _borrowRate,\n        uint256 _timeElapsed\n    ) public pure returns (uint256) {\n        uint256 _interest = _principal.mul(_borrowRate).mul(_timeElapsed).div(1030).div(YEAR_IN_SECONDS);\n\n        return _interest;\n    }\n\n    /\n     * @dev Used to calculate interest accrued since last repayment\n     * @param _id identifier for the credit line\n     * @return interest accrued over current borrowed amount since last repayment\n     */\n\n    function calculateInterestAccrued(uint256 _id) public view returns (uint256) {\n        uint256 _lastPrincipalUpdateTime = creditLineVariables[_id].lastPrincipalUpdateTime;\n        if (_lastPrincipalUpdateTime == 0) return 0;\n        uint256 _timeElapsed = (block.timestamp).sub(_lastPrincipalUpdateTime);\n        uint256 _interestAccrued = calculateInterest(creditLineVariables[_id].principal, creditLineConstants[_id].borrowRate, _timeElapsed);\n        return _interestAccrued;\n    }\n\n    /\n     * @dev Used to calculate current debt of borrower against a credit line.\n     * @param _id identifier for the credit line\n     * @return current debt of borrower\n     /\n    function calculateCurrentDebt(uint256 _id) public view returns (uint256) {\n        uint256 _interestAccrued = calculateInterestAccrued(_id);\n        uint256 _currentDebt = (creditLineVariables[_id].principal)\n            .add(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate)\n            .add(_interestAccrued)\n            .sub(creditLineVariables[_id].totalInterestRepaid);\n        return _currentDebt;\n    }\n\n    /\n     * @notice used to calculate amount that can be borrowed by the borrower\n     * @dev is a view function for the protocol itself, but isn\'t view because of getTokensForShares which is not view.\n            borrowableAmount changes per block as interest changes per block.\n     * @param _id identifier for the credit line\n     * @return amount that can be borrowed from the credit line\n     /\n    function calculateBorrowableAmount(uint256 _id) public returns (uint256) {\n        CreditLineStatus _status = creditLineVariables[_id].status;\n        require(\n            _status == CreditLineStatus.ACTIVE || _status == CreditLineStatus.REQUESTED,\n            \'CreditLine: Cannot only if credit line ACTIVE or REQUESTED\'\n        );\n        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(\n            creditLineConstants[_id].collateralAsset,\n            creditLineConstants[_id].borrowAsset\n        );\n\n        uint256 _totalCollateralToken = calculateTotalCollateralTokens(_id);\n\n        uint256 _currentDebt = calculateCurrentDebt(_id);\n\n        uint256 _maxPossible = _totalCollateralToken.mul(_ratioOfPrices).div(creditLineConstants[_id].idealCollateralRatio).mul(1030).div(\n            10_decimals\n        );\n\n        uint256 _borrowLimit = creditLineConstants[_id].borrowLimit;\n\n        if (_maxPossible &gt; _borrowLimit) {\n            _maxPossible = _borrowLimit;\n        }\n        if (_maxPossible &gt; _currentDebt) {\n            return _maxPossible.sub(_currentDebt);\n        }\n        return 0;\n    }\n\n    function updateinterestAccruedTillLastPrincipalUpdate(uint256 _id) internal {\n        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, \'CreditLine: The credit line is not yet active.\');\n\n        uint256 _interestAccrued = calculateInterestAccrued(_id);\n        uint256 _newInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(_interestAccrued);\n        creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _newInterestAccrued;\n    }\n\n    function _depositCollateralFromSavingsAccount(\n        uint256 _id,\n        uint256 _amount,\n        address _sender\n    ) internal {\n        address _collateralAsset = creditLineConstants[_id].collateralAsset;\n        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();\n        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);\n        uint256 _activeAmount;\n\n        for (uint256 _index = 0; _index &lt; _strategyList.length; _index++) {\n            address _strategy = _strategyList[_index];\n            uint256 _liquidityShares = _savingsAccount.balanceInShares(_sender, _collateralAsset, _strategy);\n            if (_liquidityShares == 0 || _strategyList[_index] == address(0)) {\n                continue;\n            }\n            uint256 _tokenInStrategy = _liquidityShares;\n            _tokenInStrategy = IYield(_strategy).getTokensForShares(_liquidityShares, _collateralAsset);\n\n            uint256 _tokensToTransfer = _tokenInStrategy;\n            if (_activeAmount.add(_tokenInStrategy) &gt;= _amount) {\n                _tokensToTransfer = (_amount.sub(_activeAmount));\n            }\n            _activeAmount = _activeAmount.add(_tokensToTransfer);\n            _savingsAccount.transferFrom(_tokensToTransfer, _collateralAsset, _strategy, _sender, address(this));\n\n            collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(\n                _liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy)\n            );\n\n            if (_amount == _activeAmount) {\n                return;\n            }\n        }\n        revert(\'CreditLine::_depositCollateralFromSavingsAccount - Insufficient balance\');\n    }\n\n    /\n     * @notice used to request a credit line either by borrower or lender\n     * @param _requestTo Address to which creditLine is requested, \n                        if borrower creates request then lender address and \n                        if lender creates then borrower address\n     * @param _borrowLimit maximum borrow amount in a credit line\n     * @param _borrowRate Interest Rate at which credit Line is requested\n     * @param _autoLiquidation if true, anyone can liquidate loan, otherwise only lender\n     * @param _collateralRatio ratio of the collateral to the debt below which credit line can be liquidated\n     * @param _borrowAsset address of the token to be borrowed\n     * @param _collateralAsset address of the token provided as collateral\n     * @param _requestAsLender if true, lender is placing request, otherwise borrower\n     * @return identifier for the credit line\n     */\n\n    function request(\n        address _requestTo,\n        uint256 _borrowLimit,\n        uint256 _borrowRate,\n        bool _autoLiquidation,\n        uint256 _collateralRatio,\n        address _borrowAsset,\n        address _collateralAsset,\n        bool _requestAsLender\n    ) external returns (uint256) {\n        require(_borrowAsset != _collateralAsset, \'R: cant borrow lent token\');\n        require(IPriceOracle(priceOracle).doesFeedExist(_borrowAsset, _collateralAsset), \'R: No price feed\');\n\n        address _lender = _requestTo;\n        address _borrower = msg.sender;\n        if (_requestAsLender) {\n            _lender = msg.sender;\n            _borrower = _requestTo;\n        }\n\n        uint256 _id = _createRequest(\n            _lender,\n            _borrower,\n            _borrowLimit,\n            _borrowRate,\n            _autoLiquidation,\n            _collateralRatio,\n            _borrowAsset,\n            _collateralAsset,\n            _requestAsLender\n        );\n\n        emit CreditLineRequested(_id, _lender, _borrower);\n        return _id;\n    }\n\n    function _createRequest(\n        address _lender,\n        address _borrower,\n        uint256 _borrowLimit,\n        uint256 _borrowRate,\n        bool _autoLiquidation,\n        uint256 _collateralRatio,\n        address _borrowAsset,\n        address _collateralAsset,\n        bool _requestByLender\n    ) internal returns (uint256) {\n        require(_lender != _borrower, \'Lender and Borrower cannot be same addresses\');\n        uint256 _id = creditLineCounter + 1;\n        creditLineCounter = _id;\n        creditLineVariables[_id].status = CreditLineStatus.REQUESTED;\n        creditLineConstants[_id].borrower = _borrower;\n        creditLineConstants[_id].lender = _lender;\n        creditLineConstants[_id].borrowLimit = _borrowLimit;\n        creditLineConstants[_id].autoLiquidation = _autoLiquidation;\n        creditLineConstants[_id].idealCollateralRatio = _collateralRatio;\n        creditLineConstants[_id].borrowRate = _borrowRate;\n        creditLineConstants[_id].borrowAsset = _borrowAsset;\n        creditLineConstants[_id].collateralAsset = _collateralAsset;\n        creditLineConstants[_id].requestByLender = _requestByLender;\n        return _id;\n    }\n\n    /\n     * @notice used to accept a credit line\n     * @dev if borrower places request, lender can accept and vice versa\n     * @param _id identifier for the credit line\n     /\n    function accept(uint256 _id) external {\n        require(\n            creditLineVariables[_id].status == CreditLineStatus.REQUESTED,\n            \'CreditLine::acceptCreditLineLender - CreditLine is already accepted\'\n        );\n        bool _requestByLender = creditLineConstants[_id].requestByLender;\n        require(\n            (msg.sender == creditLineConstants[_id].borrower &amp;&amp; _requestByLender) ||\n                (msg.sender == creditLineConstants[_id].lender &amp;&amp; !_requestByLender),\n            "Only Borrower or Lender who hasn\'t requested can accept"\n        );\n        creditLineVariables[_id].status = CreditLineStatus.ACTIVE;\n        emit CreditLineAccepted(_id);\n    }\n\n    /\n     * @notice used to deposit collateral into the credit line\n     * @dev collateral tokens have to be approved in savingsAccount or token contract(unless ether).\n            If transferred from savings account, the tokens are transferred from strategies in the \n            order prespecified in strategy registry\n     * @param _id identifier for the credit line\n     * @param _amount amount of collateral being deposited\n     * @param _strategy strategy to which collateral is to be deposited in case transfer is not from savings account\n     * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount \n                                otherwise direct from collateral token contract\n     /\n    function depositCollateral(\n        uint256 _id,\n        uint256 _amount,\n        address _strategy,\n        bool _fromSavingsAccount\n    ) external payable nonReentrant ifCreditLineExists(_id) {\n        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, \'CreditLine not active\');\n        _depositCollateral(_id, _amount, _strategy, _fromSavingsAccount);\n        emit CollateralDeposited(_id, _amount, _strategy);\n    }\n\n    function _depositCollateral(\n        uint256 _id,\n        uint256 _amount,\n        address _strategy,\n        bool _fromSavingsAccount\n    ) internal {\n        require(creditLineConstants[_id].lender != msg.sender, \'lender cant deposit collateral\');\n        if (_fromSavingsAccount) {\n            _depositCollateralFromSavingsAccount(_id, _amount, msg.sender);\n        } else {\n            address _collateralAsset = creditLineConstants[_id].collateralAsset;\n            ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);\n            if (_collateralAsset == address(0)) {\n                require(msg.value == _amount, "CreditLine::_depositCollateral - value to transfer doesn\'t match argument");\n            } else {\n                IERC20(_collateralAsset).safeTransferFrom(msg.sender, address(this), _amount);\n                IERC20(_collateralAsset).approve(_strategy, _amount);\n            }\n            uint256 _sharesReceived = _savingsAccount.deposit{value: msg.value}(_amount, _collateralAsset, _strategy, address(this));\n            collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(_sharesReceived);\n        }\n    }\n\n    function _withdrawBorrowAmount(\n        address _asset,\n        uint256 _amountInTokens,\n        address _lender\n    ) internal {\n        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();\n        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);\n        uint256 _activeAmount;\n        for (uint256 _index = 0; _index &lt; _strategyList.length; _index++) {\n            if (_strategyList[_index] == address(0)) {\n                continue;\n            }\n            uint256 _liquidityShares = _savingsAccount.balanceInShares(_lender, _asset, _strategyList[_index]);\n            if (_liquidityShares != 0) {\n                uint256 tokenInStrategy = _liquidityShares;\n                tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);\n                uint256 _tokensToTransfer = tokenInStrategy;\n                if (_activeAmount.add(tokenInStrategy) &gt;= _amountInTokens) {\n                    _tokensToTransfer = (_amountInTokens.sub(_activeAmount));\n                }\n                _activeAmount = _activeAmount.add(_tokensToTransfer);\n                _savingsAccount.withdrawFrom(_tokensToTransfer, _asset, _strategyList[_index], _lender, address(this), false);\n                if (_activeAmount == _amountInTokens) {\n                    return;\n                }\n            }\n        }\n        require(_activeAmount == _amountInTokens, \'insufficient balance\');\n    }\n\n    /\n     * @notice used to borrow tokens from credit line by borrower\n     * @dev only borrower can call this function. Amount that can actually be borrowed is \n            min(amount based on borrowLimit, allowance to creditLine contract, balance of lender)\n     * @param _id identifier for the credit line\n     * @param _amount amount of tokens to borrow\n     */\n    function borrow(uint256 _id, uint256 _amount) external payable nonReentrant onlyCreditLineBorrower(_id) {\n        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, \'CreditLine: The credit line is not yet active.\');\n        uint256 _borrowableAmount = calculateBorrowableAmount(_id);\n        require(_amount &lt;= _borrowableAmount, "CreditLine::borrow - The current collateral ratio doesn\'t allow to withdraw the amount");\n        address _borrowAsset = creditLineConstants[_id].borrowAsset;\n        address _lender = creditLineConstants[_id].lender;\n\n        updateinterestAccruedTillLastPrincipalUpdate(_id);\n        creditLineVariables[_id].principal = creditLineVariables[_id].principal.add(_amount);\n        creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;\n\n        uint256 _tokenDiffBalance;\n        if (_borrowAsset != address(0)) {\n            uint256 _balanceBefore = IERC20(_borrowAsset).balanceOf(address(this));\n            _withdrawBorrowAmount(_borrowAsset, _amount, _lender);\n            uint256 _balanceAfter = IERC20(_borrowAsset).balanceOf(address(this));\n            _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);\n        } else {\n            uint256 _balanceBefore = address(this).balance;\n            _withdrawBorrowAmount(_borrowAsset, _amount, _lender);\n            uint256 _balanceAfter = address(this).balance;\n            _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);\n        }\n        uint256 _protocolFee = _tokenDiffBalance.mul(protocolFeeFraction).div(1030);\n        _tokenDiffBalance = _tokenDiffBalance.sub(_protocolFee);\n\n        if (_borrowAsset == address(0)) {\n            (bool feeSuccess, ) = protocolFeeCollector.call{value: _protocolFee}(\'\');\n            require(feeSuccess, \'Transfer fail\');\n            (bool success, ) = msg.sender.call{value: _tokenDiffBalance}(\'\');\n            require(success, \'Transfer fail\');\n        } else {\n            IERC20(_borrowAsset).safeTransfer(protocolFeeCollector, _protocolFee);\n            IERC20(_borrowAsset).safeTransfer(msg.sender, _tokenDiffBalance);\n        }\n        emit BorrowedFromCreditLine(_id, _tokenDiffBalance);\n    }\n\n    function _repayFromSavingsAccount(\n        uint256 _amount,\n        address _asset,\n        address _lender\n    ) internal {\n        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();\n        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);\n        uint256 _activeAmount;\n\n        for (uint256 _index = 0; _index &lt; _strategyList.length; _index++) {\n            if (_strategyList[_index] == address(0)) {\n                continue;\n            }\n            uint256 _liquidityShares = _savingsAccount.balanceInShares(msg.sender, _asset, _strategyList[_index]);\n            if (_liquidityShares == 0) {\n                continue;\n            }\n            uint256 _tokenInStrategy = _liquidityShares;\n            _tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);\n\n            uint256 _tokensToTransfer = _tokenInStrategy;\n            if (_activeAmount.add(_tokenInStrategy) &gt;= _amount) {\n                _tokensToTransfer = (_amount.sub(_activeAmount));\n            }\n            _activeAmount = _activeAmount.add(_tokensToTransfer);\n            _savingsAccount.transferFrom(_tokensToTransfer, _asset, _strategyList[_index], msg.sender, _lender);\n\n            if (_amount == _activeAmount) {\n                return;\n            }\n        }\n        revert(\'CreditLine::_repayFromSavingsAccount - Insufficient balance\');\n    }\n\n    function _repay(\n        uint256 _id,\n        uint256 _amount,\n        bool _fromSavingsAccount,\n        uint256 _principalPaid\n    ) internal {\n        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);\n        address _defaultStrategy = defaultStrategy;\n        address _borrowAsset = creditLineConstants[_id].borrowAsset;\n        address _lender = creditLineConstants[_id].lender;\n        if (!_fromSavingsAccount) {\n            if (_borrowAsset == address(0)) {\n                require(msg.value == _amount, \'creditLine::repay - Ether sent not equal to repay amount\');\n                _savingsAccount.deposit{value: _amount}(_amount, _borrowAsset, _defaultStrategy, _lender);\n            } else {\n                IERC20(_borrowAsset).safeTransferFrom(msg.sender, address(this), _amount);\n                IERC20(_borrowAsset).approve(_defaultStrategy, _amount);\n                _savingsAccount.deposit(_amount, _borrowAsset, _defaultStrategy, _lender);\n            }\n        } else {\n            _repayFromSavingsAccount(_amount, _borrowAsset, _lender);\n        }\n        if (_principalPaid != 0) {\n            _savingsAccount.increaseAllowanceToCreditLine(_principalPaid, _borrowAsset, _lender);\n        }\n    }\n\n    /\n     * @notice used to repay interest and principal to credit line. Interest has to be repaid before repaying principal\n     * @dev partial repayments possible\n     * @param _id identifier for the credit line\n     * @param _amount amount being repaid\n     * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount \n                                otherwise direct from collateral token contract\n     */\n    function repay(\n        uint256 _id,\n        uint256 _amount,\n        bool _fromSavingsAccount\n    ) external payable nonReentrant {\n        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, \'CreditLine: The credit line is not yet active.\');\n        require(creditLineConstants[_id].lender != msg.sender, \'Lender cant repay\');\n\n        uint256 _interestSincePrincipalUpdate = calculateInterestAccrued(_id);\n        uint256 _totalInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(\n            _interestSincePrincipalUpdate\n        );\n        uint256 _interestToPay = _totalInterestAccrued.sub(creditLineVariables[_id].totalInterestRepaid);\n        uint256 _totalCurrentDebt = _interestToPay.add(creditLineVariables[_id].principal);\n        uint256 _principalPaid = 0;\n\n        if (_amount &gt;= _totalCurrentDebt) {\n            _amount = _totalCurrentDebt;\n            emit CompleteCreditLineRepaid(_id, _amount);\n        } else {\n            emit PartialCreditLineRepaid(_id, _amount);\n        }\n\n        if (_amount &gt; _interestToPay) {\n            creditLineVariables[_id].principal = _totalCurrentDebt.sub(_amount);\n            creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _totalInterestAccrued;\n            creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;\n            creditLineVariables[_id].totalInterestRepaid = _totalInterestAccrued;\n            _principalPaid = _amount.sub(_interestToPay);\n        } else {\n            creditLineVariables[_id].totalInterestRepaid = creditLineVariables[_id].totalInterestRepaid.add(_amount);\n        }\n\n        _repay(_id, _amount, _fromSavingsAccount, _principalPaid);\n\n        if (creditLineVariables[_id].principal == 0) {\n            _resetCreditLine(_id);\n        }\n    }\n\n    function _resetCreditLine(uint256 _id) internal {\n        creditLineVariables[_id].lastPrincipalUpdateTime = 0;\n        creditLineVariables[_id].totalInterestRepaid = 0;\n        creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = 0;\n        emit CreditLineReset(_id);\n    }\n\n    /\n     * @dev used to close credit line by borrower or lender\n     * @param _id identifier for the credit line\n     /\n    function close(uint256 _id) external ifCreditLineExists(_id) {\n        require(\n            msg.sender == creditLineConstants[_id].borrower || msg.sender == creditLineConstants[_id].lender,\n            \'CreditLine: Permission denied while closing Line of credit\'\n        );\n        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, \'CreditLine: Credit line should be active.\');\n        require(creditLineVariables[_id].principal == 0, \'CreditLine: Cannot be closed since not repaid.\');\n        require(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate == 0, \'CreditLine: Cannot be closed since not repaid.\');\n        creditLineVariables[_id].status = CreditLineStatus.CLOSED;\n        emit CreditLineClosed(_id);\n    }\n\n    /\n     * @notice used to calculate the current collateral ratio\n     * @dev is a view function for the protocol itself, but isn\'t view because of getTokensForShares which is not view.\n            Interest is also considered while calculating debt\n     * @param _id identifier for the credit line\n     * @return collateral ratio multiplied by 1030 to retain precision\n     /\n    function calculateCurrentCollateralRatio(uint256 _id) public ifCreditLineExists(_id) returns (uint256) {\n        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(\n            creditLineConstants[_id].collateralAsset,\n            creditLineConstants[_id].borrowAsset\n        );\n\n        uint256 currentDebt = calculateCurrentDebt(_id);\n        uint256 currentCollateralRatio = calculateTotalCollateralTokens(_id).mul(_ratioOfPrices).div(currentDebt).mul(1030).div(\n            10_decimals\n        );\n\n        return currentCollateralRatio;\n    }\n\n    /\n     * @notice used to calculate the total collateral tokens\n     * @dev is a view function for the protocol itself, but isn\'t view because of getTokensForShares which is not view\n     * @param _id identifier for the credit line\n     * @return _amount total collateral tokens deposited into the credit line\n     */\n    function calculateTotalCollateralTokens(uint256 _id) public returns (uint256 _amount) {\n        address _collateralAsset = creditLineConstants[_id].collateralAsset;\n        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();\n        uint256 _liquidityShares;\n        for (uint256 index = 0; index &lt; _strategyList.length; index++) {\n            if (_strategyList[index] == address(0)) {\n                continue;\n            }\n            _liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];\n            uint256 _tokenInStrategy = _liquidityShares;\n            _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(_liquidityShares, _collateralAsset);\n\n            _amount = _amount.add(_tokenInStrategy);\n        }\n    }\n\n    /\n     * @notice used to withdraw any excess collateral\n     * @dev collateral can\'t be withdraw if collateralRatio goes below the ideal value. Only borrower can withdraw\n     * @param _id identifier for the credit line\n     * @param _amount amount of collateral to withdraw\n     * @param _toSavingsAccount if true, tokens are transferred from savingsAccount \n                                otherwise direct from collateral token contract\n     /\n    function withdrawCollateral(\n        uint256 _id,\n        uint256 _amount,\n        bool _toSavingsAccount\n    ) external nonReentrant onlyCreditLineBorrower(_id) {\n        uint256 _withdrawableCollateral = withdrawableCollateral(_id);\n        require(_amount &lt;= _withdrawableCollateral, \'Collateral ratio cant go below ideal\');\n        address _collateralAsset = creditLineConstants[_id].collateralAsset;\n        _transferCollateral(_id, _collateralAsset, _amount, _toSavingsAccount);\n        emit CollateralWithdrawn(_id, _amount);\n    }\n\n    /\n     * @notice used to calculate the collateral that can be withdrawn\n     * @dev is a view function for the protocol itself, but isn\'t view because of getTokensForShares which is not view\n     * @param _id identifier for the credit line\n     * @return total collateral withdrawable by borrower\n     /\n    function withdrawableCollateral(uint256 _id) public returns (uint256) {\n        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(\n            creditLineConstants[_id].collateralAsset,\n            creditLineConstants[_id].borrowAsset\n        );\n\n        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);\n        uint256 _currentDebt = calculateCurrentDebt(_id);\n\n        uint256 _collateralNeeded = _currentDebt\n            .mul(creditLineConstants[_id].idealCollateralRatio)\n            .div(_ratioOfPrices)\n            .mul(10_decimals)\n            .div(1030);\n\n        if (_collateralNeeded &gt;= _totalCollateralTokens) {\n            return 0;\n        }\n        return _totalCollateralTokens.sub(_collateralNeeded);\n    }\n\n    function _transferCollateral(\n        uint256 _id,\n        address _asset,\n        uint256 _amountInTokens,\n        bool _toSavingsAccount\n    ) internal {\n        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();\n        uint256 _activeAmount;\n        for (uint256 index = 0; index &lt; _strategyList.length; index++) {\n            uint256 liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];\n            if (liquidityShares == 0 || _strategyList[index] == address(0)) {\n                continue;\n            }\n            uint256 _tokenInStrategy = liquidityShares;\n            _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(liquidityShares, _asset);\n            uint256 _tokensToTransfer = _tokenInStrategy;\n            if (_activeAmount.add(_tokenInStrategy) &gt; _amountInTokens) {\n                _tokensToTransfer = _amountInTokens.sub(_activeAmount);\n                liquidityShares = liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy);\n            }\n            _activeAmount = _activeAmount.add(_tokensToTransfer);\n            collateralShareInStrategy[_id][_strategyList[index]] = collateralShareInStrategy[_id][_strategyList[index]].sub(\n                liquidityShares\n            );\n            if (_toSavingsAccount) {\n                ISavingsAccount(savingsAccount).transfer(_tokensToTransfer, _asset, _strategyList[index], msg.sender);\n            } else {\n                ISavingsAccount(savingsAccount).withdraw(_tokensToTransfer, _asset, _strategyList[index], msg.sender, false);\n            }\n\n            if (_activeAmount == _amountInTokens) {\n                return;\n            }\n        }\n        revert(\'insufficient collateral\');\n    }\n\n    /\n     * @notice used to liquidate credit line in case collateral ratio goes below the threshold\n     * @dev if lender liquidates, then collateral is directly transferred. \n            If autoLiquidation is true, anyone can liquidate by providing enough borrow tokens\n     * @param _id identifier for the credit line\n     * @param _toSavingsAccount if true, tokens are transferred from savingsAccount \n                                otherwise direct from collateral token contract\n     */\n    function liquidate(uint256 _id, bool _toSavingsAccount) external payable nonReentrant {\n        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, \'CreditLine: Credit line should be active.\');\n        require(creditLineVariables[_id].principal != 0, \'CreditLine: cannot liquidate if principal is 0\');\n\n        uint256 currentCollateralRatio = calculateCurrentCollateralRatio(_id);\n        require(\n            currentCollateralRatio &lt; creditLineConstants[_id].idealCollateralRatio,\n            \'CreditLine: Collateral ratio is higher than ideal value\'\n        );\n\n        address _collateralAsset = creditLineConstants[_id].collateralAsset;\n        address _lender = creditLineConstants[_id].lender;\n        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);\n        address _borrowAsset = creditLineConstants[_id].borrowAsset;\n\n        creditLineVariables[_id].status = CreditLineStatus.LIQUIDATED;\n\n        if (creditLineConstants[_id].autoLiquidation &amp;&amp; _lender != msg.sender) {\n            uint256 _borrowTokens = _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens);\n            if (_borrowAsset == address(0)) {\n                uint256 _returnETH = msg.value.sub(_borrowTokens, \'Insufficient ETH to liquidate\');\n                if (_returnETH != 0) {\n                    (bool success, ) = msg.sender.call{value: _returnETH}(\'\');\n                    require(success, \'Transfer fail\');\n                }\n            } else {\n                IERC20(_borrowAsset).safeTransferFrom(msg.sender, _lender, _borrowTokens);\n            }\n        }\n\n        _transferCollateral(_id, _collateralAsset, _totalCollateralTokens, _toSavingsAccount);\n\n        emit CreditLineLiquidated(_id, msg.sender);\n    }\n\n    /\n     * @notice used to calculate the borrow tokens necessary for liquidator to liquidate\n     * @dev is a view function for the protocol itself, but isn\'t view because of getTokensForShares which is not view\n     * @param _id identifier for the credit line\n     * @return borrow tokens necessary for liquidator to liquidate\n     /\n    function borrowTokensToLiquidate(uint256 _id) external returns (uint256) {\n        address _collateralAsset = creditLineConstants[_id].collateralAsset;\n        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);\n        address _borrowAsset = creditLineConstants[_id].borrowAsset;\n\n        return _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens);\n    }\n\n    function _borrowTokensToLiquidate(\n        address _borrowAsset,\n        address _collateralAsset,\n        uint256 _totalCollateralTokens\n    ) internal view returns (uint256) {\n        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(_borrowAsset, _collateralAsset);\n        uint256 _borrowTokens = (\n            _totalCollateralTokens.mul(uint256(1030).sub(liquidatorRewardFraction)).div(1030).mul(_ratioOfPrices).div(10*_decimals)\n        );\n\n        return _borrowTokens;\n    }\n\n    receive() external payable {\n        require(msg.sender == savingsAccount, \'CreditLine::receive invalid transaction\');\n    }\n}\n', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-22-08 11:43:38 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol'; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/utils/ReentrancyGuard.sol'; import '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol'; import '../interfaces/IPriceOracle.sol'; import '../interfaces/IYield.sol'; import '../interfaces/ISavingsAccount.sol'; import '../SavingsAccount/SavingsAccountUtil.sol'; import '../interfaces/IStrategyRegistry.sol'; /  * @title Credit Line contract with Methods related to credit Line  * @notice Implements the functions related to Credit Line  * @author Sublime  / contract CreditLine is ReentrancyGuard, OwnableUpgradeable {     using SafeERC20 for IERC20;     using SafeMath for uint256; enum CreditLineStatus {     NOT_CREATED,     REQUESTED,     ACTIVE,     CLOSED,     CANCELLED,     LIQUIDATED }  /**  * @notice counter that tracks the number of credit lines created  * @dev used to create unique identifier for credit lines  **/ uint256 public creditLineCounter;  uint256 constant YEAR_IN_SECONDS = 365 days;  struct CreditLineVariables {     CreditLineStatus status;     uint256 principal;     uint256 totalInterestRepaid;     uint256 lastPrincipalUpdateTime;     uint256 interestAccruedTillLastPrincipalUpdate; }  struct CreditLineConstants {     address lender;     address borrower;     uint256 borrowLimit;     uint256 idealCollateralRatio;     uint256 borrowRate;     address borrowAsset;     address collateralAsset;     bool autoLiquidation;     bool requestByLender; } /**  * @notice stores the collateral shares in a credit line per strategy  * @dev creditLineId =&gt; Strategy =&gt; collateralShares  **/ mapping(uint256 =&gt; mapping(address =&gt; uint256)) public collateralShareInStrategy;  /**  * @notice stores the variables to maintain a credit line  **/ mapping(uint256 =&gt; CreditLineVariables) public creditLineVariables;  /**  * @notice stores the constants related to a credit line  **/ mapping(uint256 =&gt; CreditLineConstants) public creditLineConstants;  /**  * @notice stores the address of savings account contract  **/ address public savingsAccount;  /**  * @notice stores the address of price oracle contract  **/ address public priceOracle;  /**  * @notice stores the address of strategy registry contract  **/ address public strategyRegistry;  /**  * @notice stores the address of default strategy  **/ address public defaultStrategy;  /**  * @notice stores the fraction of borrowed amount charged as fee by protocol  * @dev it is multiplied by 10**30  **/ uint256 public protocolFeeFraction;  /**  * @notice address where protocol fee is collected  **/ address public protocolFeeCollector;  /**  * @notice stores the fraction of amount liquidated given as reward to liquidator  * @dev it is multiplied by 10**30  **/ uint256 public liquidatorRewardFraction; /**  * @dev checks if Credit Line exists  * @param _id identifier for the credit line  **/ modifier ifCreditLineExists(uint256 _id) {     require(creditLineVariables[_id].status != CreditLineStatus.NOT_CREATED, 'Credit line does not exist');     _; }  /**  * @dev checks if called by credit Line Borrower  * @param _id creditLine identifier  **/ modifier onlyCreditLineBorrower(uint256 _id) {     require(creditLineConstants[_id].borrower == msg.sender, 'Only credit line Borrower can access');     _; }  /**  * @dev checks if called by credit Line Lender  * @param _id creditLine identifier  **/ modifier onlyCreditLineLender(uint256 _id) {     require(creditLineConstants[_id].lender == msg.sender, 'Only credit line Lender can access');     _; }  /**  * @notice emitted when a collateral is deposited into credit line  * @param id id of the credit line  * @param amount amount of collateral deposited  * @param strategy address of the strategy into which collateral is deposited  */ event CollateralDeposited(uint256 indexed id, uint256 amount, address indexed strategy);  /**  * @notice emitted when collateral is withdrawn from credit line  * @param id id of the credit line  * @param amount amount of collateral withdrawn  */ event CollateralWithdrawn(uint256 indexed id, uint256 amount);  /**  * @notice emitted when a request for new credit line is placed  * @param id id of the credit line for which request was made  * @param lender address of the lender for credit line  * @param borrower address of the borrower for credit line  */ event CreditLineRequested(uint256 indexed id, address indexed lender, address indexed borrower);  /**  * @notice emitted when a credit line is liquidated  * @param id id of the credit line which is liquidated  * @param liquidator address of the liquidator  */ event CreditLineLiquidated(uint256 indexed id, address indexed liquidator);  /**  * @notice emitted when tokens are borrowed from credit line  * @param id id of the credit line from which tokens are borrowed  * @param borrowAmount amount of tokens borrowed  */ event BorrowedFromCreditLine(uint256 indexed id, uint256 borrowAmount);  /**  * @notice emitted when credit line is accepted  * @param id id of the credit line that was accepted  */ event CreditLineAccepted(uint256 indexed id);  /**  * @notice emitted when credit line is completely repaid and reset  * @param id id of the credit line that is reset  */ event CreditLineReset(uint256 indexed id);  /**  * @notice emitted when the credit line is partially repaid  * @param id id of the credit line  * @param repayAmount amount repaid  */ event PartialCreditLineRepaid(uint256 indexed id, uint256 repayAmount);  /**  * @notice emitted when the credit line is completely repaid  * @param id id of the credit line  * @param repayAmount amount repaid  */ event CompleteCreditLineRepaid(uint256 indexed id, uint256 repayAmount);  /**  * @notice emitted when the credit line is closed by one of the parties of credit line  * @param id id of the credit line  */ event CreditLineClosed(uint256 indexed id);  /**  * @notice emitted when default strategy for the credit line is updated  * @param defaultStrategy address of the strategy contract that is used as default by credit lines  */ event DefaultStrategyUpdated(address indexed defaultStrategy);  /**  * @notice emitted when the price oracle is updated  * @param priceOracle address of the updated price oracle  */ event PriceOracleUpdated(address indexed priceOracle);  /**  * @notice emitted when the savings account address is updated  * @param savingsAccount address of the updated savingsAccount  */ event SavingsAccountUpdated(address indexed savingsAccount);  /**  * @notice emitted when strategy registry address is updated  * @param strategyRegistry address of the updated strategy registry  */ event StrategyRegistryUpdated(address indexed strategyRegistry);  /**  * @notice emitted when fee that protocol charges for credit line is updated  * @param updatedProtocolFee updated value of protocolFeeFraction  */ event ProtocolFeeFractionUpdated(uint256 updatedProtocolFee);  /**  * @notice emitted when address which receives fee that protocol changes for pools is updated  * @param updatedProtocolFeeCollector updated value of protocolFeeCollector  */ event ProtocolFeeCollectorUpdated(address indexed updatedProtocolFeeCollector);  /**  * @notice emitted when liquidatorRewardFraction is updated  * @param liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator  */ event LiquidationRewardFractionUpdated(uint256 liquidatorRewardFraction);  /**  * @notice used to initialize the contract  * @dev can only be called once during the life cycle of the contract  * @param _defaultStrategy default strategy used in credit lines  * @param _priceOracle address of the priceOracle  * @param _savingsAccount address of  the savings account contract  * @param _strategyRegistry address of the strategy registry contract  * @param _owner address of owner who can change global variables  * @param _protocolFeeFraction fraction of the fee charged by protocol  * @param _protocolFeeCollector address to which protocol fee is charged to  * @param _liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator  */ function initialize(     address _defaultStrategy,     address _priceOracle,     address _savingsAccount,     address _strategyRegistry,     address _owner,     uint256 _protocolFeeFraction,     address _protocolFeeCollector,     uint256 _liquidatorRewardFraction ) external initializer {     OwnableUpgradeable.__Ownable_init();     OwnableUpgradeable.transferOwnership(_owner);      _updateDefaultStrategy(_defaultStrategy);     _updatePriceOracle(_priceOracle);     _updateSavingsAccount(_savingsAccount);     _updateStrategyRegistry(_strategyRegistry);     _updateProtocolFeeFraction(_protocolFeeFraction);     _updateProtocolFeeCollector(_protocolFeeCollector);     _updateLiquidatorRewardFraction(_liquidatorRewardFraction); }  /**  * @notice used to update the default strategy  * @dev can only be updated by owner  * @param _defaultStrategy address of the updated default strategy  */ function updateDefaultStrategy(address _defaultStrategy) external onlyOwner {     _updateDefaultStrategy(_defaultStrategy); }  function _updateDefaultStrategy(address _defaultStrategy) internal {     defaultStrategy = _defaultStrategy;     emit DefaultStrategyUpdated(_defaultStrategy); }  /**  * @notice used to update the price oracle  * @dev can only be updated by owner  * @param _priceOracle address of the updated price oracle  */ function updatePriceOracle(address _priceOracle) external onlyOwner {     _updatePriceOracle(_priceOracle); }  function _updatePriceOracle(address _priceOracle) internal {     priceOracle = _priceOracle;     emit PriceOracleUpdated(_priceOracle); }  /**  * @notice used to update the savings account address  * @dev can only be updated by owner  * @param _savingsAccount address of the updated savings account  */ function updateSavingsAccount(address _savingsAccount) external onlyOwner {     _updateSavingsAccount(_savingsAccount); }  function _updateSavingsAccount(address _savingsAccount) internal {     savingsAccount = _savingsAccount;     emit SavingsAccountUpdated(_savingsAccount); }  /**  * @notice used to update the protocol fee fraction  * @dev can only be updated by owner  * @param _protocolFee fraction of the borrower amount collected as protocol fee  */ function updateProtocolFeeFraction(uint256 _protocolFee) external onlyOwner {     _updateProtocolFeeFraction(_protocolFee); }  function _updateProtocolFeeFraction(uint256 _protocolFee) internal {     protocolFeeFraction = _protocolFee;     emit ProtocolFeeFractionUpdated(_protocolFee); }  /**  * @notice used to update the protocol fee collector  * @dev can only be updated by owner  * @param _protocolFeeCollector address in which protocol fee is collected  */ function updateProtocolFeeCollector(address _protocolFeeCollector) external onlyOwner {     _updateProtocolFeeCollector(_protocolFeeCollector); }  function _updateProtocolFeeCollector(address _protocolFeeCollector) internal {     require(_protocolFeeCollector != address(0), 'cant be 0 address');     protocolFeeCollector = _protocolFeeCollector;     emit ProtocolFeeCollectorUpdated(_protocolFeeCollector); }  /**  * @notice used to update the strategy registry address  * @dev can only be updated by owner  * @param _strategyRegistry address of the updated strategy registry  */ function updateStrategyRegistry(address _strategyRegistry) external onlyOwner {     _updateStrategyRegistry(_strategyRegistry); }  function _updateStrategyRegistry(address _strategyRegistry) internal {     require(_strategyRegistry != address(0), 'CL::I zero address');     strategyRegistry = _strategyRegistry;     emit StrategyRegistryUpdated(_strategyRegistry); }  /**  * @notice used to update the liquidatorRewardFraction  * @dev can only be updated by owner  * @param _rewardFraction fraction of liquidated amount given to liquidator as reward  */ function updateLiquidatorRewardFraction(uint256 _rewardFraction) external onlyOwner {     _updateLiquidatorRewardFraction(_rewardFraction); }  function _updateLiquidatorRewardFraction(uint256 _rewardFraction) internal {     require(_rewardFraction &lt;= 10**30, 'Fraction has to be less than 1');     liquidatorRewardFraction = _rewardFraction;     emit LiquidationRewardFractionUpdated(_rewardFraction); }  /**  * @dev Used to Calculate Interest Per second on given principal and Interest rate  * @param _principal principal Amount for which interest has to be calculated.  * @param _borrowRate It is the Interest Rate at which Credit Line is approved  * @return interest per second for the given parameters  */ function calculateInterest(     uint256 _principal,     uint256 _borrowRate,     uint256 _timeElapsed ) public pure returns (uint256) {     uint256 _interest = _principal.mul(_borrowRate).mul(_timeElapsed).div(10**30).div(YEAR_IN_SECONDS);      return _interest; }  /**  * @dev Used to calculate interest accrued since last repayment  * @param _id identifier for the credit line  * @return interest accrued over current borrowed amount since last repayment  */  function calculateInterestAccrued(uint256 _id) public view returns (uint256) {     uint256 _lastPrincipalUpdateTime = creditLineVariables[_id].lastPrincipalUpdateTime;     if (_lastPrincipalUpdateTime == 0) return 0;     uint256 _timeElapsed = (block.timestamp).sub(_lastPrincipalUpdateTime);     uint256 _interestAccrued = calculateInterest(creditLineVariables[_id].principal, creditLineConstants[_id].borrowRate, _timeElapsed);     return _interestAccrued; }  /**  * @dev Used to calculate current debt of borrower against a credit line.  * @param _id identifier for the credit line  * @return current debt of borrower  */ function calculateCurrentDebt(uint256 _id) public view returns (uint256) {     uint256 _interestAccrued = calculateInterestAccrued(_id);     uint256 _currentDebt = (creditLineVariables[_id].principal)         .add(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate)         .add(_interestAccrued)         .sub(creditLineVariables[_id].totalInterestRepaid);     return _currentDebt; }  /**  * @notice used to calculate amount that can be borrowed by the borrower  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view.         borrowableAmount changes per block as interest changes per block.  * @param _id identifier for the credit line  * @return amount that can be borrowed from the credit line  */ function calculateBorrowableAmount(uint256 _id) public returns (uint256) {     CreditLineStatus _status = creditLineVariables[_id].status;     require(         _status == CreditLineStatus.ACTIVE || _status == CreditLineStatus.REQUESTED,         'CreditLine: Cannot only if credit line ACTIVE or REQUESTED'     );     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(         creditLineConstants[_id].collateralAsset,         creditLineConstants[_id].borrowAsset     );      uint256 _totalCollateralToken = calculateTotalCollateralTokens(_id);      uint256 _currentDebt = calculateCurrentDebt(_id);      uint256 _maxPossible = _totalCollateralToken.mul(_ratioOfPrices).div(creditLineConstants[_id].idealCollateralRatio).mul(10**30).div(         10**_decimals     );      uint256 _borrowLimit = creditLineConstants[_id].borrowLimit;      if (_maxPossible &gt; _borrowLimit) {         _maxPossible = _borrowLimit;     }     if (_maxPossible &gt; _currentDebt) {         return _maxPossible.sub(_currentDebt);     }     return 0; }  function updateinterestAccruedTillLastPrincipalUpdate(uint256 _id) internal {     require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');      uint256 _interestAccrued = calculateInterestAccrued(_id);     uint256 _newInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(_interestAccrued);     creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _newInterestAccrued; }  function _depositCollateralFromSavingsAccount(     uint256 _id,     uint256 _amount,     address _sender ) internal {     address _collateralAsset = creditLineConstants[_id].collateralAsset;     address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();     ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);     uint256 _activeAmount;      for (uint256 _index = 0; _index &lt; _strategyList.length; _index++) {         address _strategy = _strategyList[_index];         uint256 _liquidityShares = _savingsAccount.balanceInShares(_sender, _collateralAsset, _strategy);         if (_liquidityShares == 0 || _strategyList[_index] == address(0)) {             continue;         }         uint256 _tokenInStrategy = _liquidityShares;         _tokenInStrategy = IYield(_strategy).getTokensForShares(_liquidityShares, _collateralAsset);          uint256 _tokensToTransfer = _tokenInStrategy;         if (_activeAmount.add(_tokenInStrategy) &gt;= _amount) {             _tokensToTransfer = (_amount.sub(_activeAmount));         }         _activeAmount = _activeAmount.add(_tokensToTransfer);         _savingsAccount.transferFrom(_tokensToTransfer, _collateralAsset, _strategy, _sender, address(this));          collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(             _liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy)         );          if (_amount == _activeAmount) {             return;         }     }     revert('CreditLine::_depositCollateralFromSavingsAccount - Insufficient balance'); }  /**  * @notice used to request a credit line either by borrower or lender  * @param _requestTo Address to which creditLine is requested,                      if borrower creates request then lender address and                      if lender creates then borrower address  * @param _borrowLimit maximum borrow amount in a credit line  * @param _borrowRate Interest Rate at which credit Line is requested  * @param _autoLiquidation if true, anyone can liquidate loan, otherwise only lender  * @param _collateralRatio ratio of the collateral to the debt below which credit line can be liquidated  * @param _borrowAsset address of the token to be borrowed  * @param _collateralAsset address of the token provided as collateral  * @param _requestAsLender if true, lender is placing request, otherwise borrower  * @return identifier for the credit line  */  function request(     address _requestTo,     uint256 _borrowLimit,     uint256 _borrowRate,     bool _autoLiquidation,     uint256 _collateralRatio,     address _borrowAsset,     address _collateralAsset,     bool _requestAsLender ) external returns (uint256) {     require(_borrowAsset != _collateralAsset, 'R: cant borrow lent token');     require(IPriceOracle(priceOracle).doesFeedExist(_borrowAsset, _collateralAsset), 'R: No price feed');      address _lender = _requestTo;     address _borrower = msg.sender;     if (_requestAsLender) {         _lender = msg.sender;         _borrower = _requestTo;     }      uint256 _id = _createRequest(         _lender,         _borrower,         _borrowLimit,         _borrowRate,         _autoLiquidation,         _collateralRatio,         _borrowAsset,         _collateralAsset,         _requestAsLender     );      emit CreditLineRequested(_id, _lender, _borrower);     return _id; }  function _createRequest(     address _lender,     address _borrower,     uint256 _borrowLimit,     uint256 _borrowRate,     bool _autoLiquidation,     uint256 _collateralRatio,     address _borrowAsset,     address _collateralAsset,     bool _requestByLender ) internal returns (uint256) {     require(_lender != _borrower, 'Lender and Borrower cannot be same addresses');     uint256 _id = creditLineCounter + 1;     creditLineCounter = _id;     creditLineVariables[_id].status = CreditLineStatus.REQUESTED;     creditLineConstants[_id].borrower = _borrower;     creditLineConstants[_id].lender = _lender;     creditLineConstants[_id].borrowLimit = _borrowLimit;     creditLineConstants[_id].autoLiquidation = _autoLiquidation;     creditLineConstants[_id].idealCollateralRatio = _collateralRatio;     creditLineConstants[_id].borrowRate = _borrowRate;     creditLineConstants[_id].borrowAsset = _borrowAsset;     creditLineConstants[_id].collateralAsset = _collateralAsset;     creditLineConstants[_id].requestByLender = _requestByLender;     return _id; }  /**  * @notice used to accept a credit line  * @dev if borrower places request, lender can accept and vice versa  * @param _id identifier for the credit line  */ function accept(uint256 _id) external {     require(         creditLineVariables[_id].status == CreditLineStatus.REQUESTED,         'CreditLine::acceptCreditLineLender - CreditLine is already accepted'     );     bool _requestByLender = creditLineConstants[_id].requestByLender;     require(         (msg.sender == creditLineConstants[_id].borrower &amp;&amp; _requestByLender) ||             (msg.sender == creditLineConstants[_id].lender &amp;&amp; !_requestByLender),         "Only Borrower or Lender who hasn't requested can accept"     );     creditLineVariables[_id].status = CreditLineStatus.ACTIVE;     emit CreditLineAccepted(_id); }  /**  * @notice used to deposit collateral into the credit line  * @dev collateral tokens have to be approved in savingsAccount or token contract(unless ether).         If transferred from savings account, the tokens are transferred from strategies in the          order prespecified in strategy registry  * @param _id identifier for the credit line  * @param _amount amount of collateral being deposited  * @param _strategy strategy to which collateral is to be deposited in case transfer is not from savings account  * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount                              otherwise direct from collateral token contract  */ function depositCollateral(     uint256 _id,     uint256 _amount,     address _strategy,     bool _fromSavingsAccount ) external payable nonReentrant ifCreditLineExists(_id) {     require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine not active');     _depositCollateral(_id, _amount, _strategy, _fromSavingsAccount);     emit CollateralDeposited(_id, _amount, _strategy); }  function _depositCollateral(     uint256 _id,     uint256 _amount,     address _strategy,     bool _fromSavingsAccount ) internal {     require(creditLineConstants[_id].lender != msg.sender, 'lender cant deposit collateral');     if (_fromSavingsAccount) {         _depositCollateralFromSavingsAccount(_id, _amount, msg.sender);     } else {         address _collateralAsset = creditLineConstants[_id].collateralAsset;         ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);         if (_collateralAsset == address(0)) {             require(msg.value == _amount, "CreditLine::_depositCollateral - value to transfer doesn't match argument");         } else {             IERC20(_collateralAsset).safeTransferFrom(msg.sender, address(this), _amount);             IERC20(_collateralAsset).approve(_strategy, _amount);         }         uint256 _sharesReceived = _savingsAccount.deposit{value: msg.value}(_amount, _collateralAsset, _strategy, address(this));         collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(_sharesReceived);     } }  function _withdrawBorrowAmount(     address _asset,     uint256 _amountInTokens,     address _lender ) internal {     address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();     ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);     uint256 _activeAmount;     for (uint256 _index = 0; _index &lt; _strategyList.length; _index++) {         if (_strategyList[_index] == address(0)) {             continue;         }         uint256 _liquidityShares = _savingsAccount.balanceInShares(_lender, _asset, _strategyList[_index]);         if (_liquidityShares != 0) {             uint256 tokenInStrategy = _liquidityShares;             tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);             uint256 _tokensToTransfer = tokenInStrategy;             if (_activeAmount.add(tokenInStrategy) &gt;= _amountInTokens) {                 _tokensToTransfer = (_amountInTokens.sub(_activeAmount));             }             _activeAmount = _activeAmount.add(_tokensToTransfer);             _savingsAccount.withdrawFrom(_tokensToTransfer, _asset, _strategyList[_index], _lender, address(this), false);             if (_activeAmount == _amountInTokens) {                 return;             }         }     }     require(_activeAmount == _amountInTokens, 'insufficient balance'); }  /**  * @notice used to borrow tokens from credit line by borrower  * @dev only borrower can call this function. Amount that can actually be borrowed is          min(amount based on borrowLimit, allowance to creditLine contract, balance of lender)  * @param _id identifier for the credit line  * @param _amount amount of tokens to borrow  */ function borrow(uint256 _id, uint256 _amount) external payable nonReentrant onlyCreditLineBorrower(_id) {     require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');     uint256 _borrowableAmount = calculateBorrowableAmount(_id);     require(_amount &lt;= _borrowableAmount, "CreditLine::borrow - The current collateral ratio doesn't allow to withdraw the amount");     address _borrowAsset = creditLineConstants[_id].borrowAsset;     address _lender = creditLineConstants[_id].lender;      updateinterestAccruedTillLastPrincipalUpdate(_id);     creditLineVariables[_id].principal = creditLineVariables[_id].principal.add(_amount);     creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;      uint256 _tokenDiffBalance;     if (_borrowAsset != address(0)) {         uint256 _balanceBefore = IERC20(_borrowAsset).balanceOf(address(this));         _withdrawBorrowAmount(_borrowAsset, _amount, _lender);         uint256 _balanceAfter = IERC20(_borrowAsset).balanceOf(address(this));         _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);     } else {         uint256 _balanceBefore = address(this).balance;         _withdrawBorrowAmount(_borrowAsset, _amount, _lender);         uint256 _balanceAfter = address(this).balance;         _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);     }     uint256 _protocolFee = _tokenDiffBalance.mul(protocolFeeFraction).div(10**30);     _tokenDiffBalance = _tokenDiffBalance.sub(_protocolFee);      if (_borrowAsset == address(0)) {         (bool feeSuccess, ) = protocolFeeCollector.call{value: _protocolFee}('');         require(feeSuccess, 'Transfer fail');         (bool success, ) = msg.sender.call{value: _tokenDiffBalance}('');         require(success, 'Transfer fail');     } else {         IERC20(_borrowAsset).safeTransfer(protocolFeeCollector, _protocolFee);         IERC20(_borrowAsset).safeTransfer(msg.sender, _tokenDiffBalance);     }     emit BorrowedFromCreditLine(_id, _tokenDiffBalance); }  function _repayFromSavingsAccount(     uint256 _amount,     address _asset,     address _lender ) internal {     address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();     ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);     uint256 _activeAmount;      for (uint256 _index = 0; _index &lt; _strategyList.length; _index++) {         if (_strategyList[_index] == address(0)) {             continue;         }         uint256 _liquidityShares = _savingsAccount.balanceInShares(msg.sender, _asset, _strategyList[_index]);         if (_liquidityShares == 0) {             continue;         }         uint256 _tokenInStrategy = _liquidityShares;         _tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);          uint256 _tokensToTransfer = _tokenInStrategy;         if (_activeAmount.add(_tokenInStrategy) &gt;= _amount) {             _tokensToTransfer = (_amount.sub(_activeAmount));         }         _activeAmount = _activeAmount.add(_tokensToTransfer);         _savingsAccount.transferFrom(_tokensToTransfer, _asset, _strategyList[_index], msg.sender, _lender);          if (_amount == _activeAmount) {             return;         }     }     revert('CreditLine::_repayFromSavingsAccount - Insufficient balance'); }  function _repay(     uint256 _id,     uint256 _amount,     bool _fromSavingsAccount,     uint256 _principalPaid ) internal {     ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);     address _defaultStrategy = defaultStrategy;     address _borrowAsset = creditLineConstants[_id].borrowAsset;     address _lender = creditLineConstants[_id].lender;     if (!_fromSavingsAccount) {         if (_borrowAsset == address(0)) {             require(msg.value == _amount, 'creditLine::repay - Ether sent not equal to repay amount');             _savingsAccount.deposit{value: _amount}(_amount, _borrowAsset, _defaultStrategy, _lender);         } else {             IERC20(_borrowAsset).safeTransferFrom(msg.sender, address(this), _amount);             IERC20(_borrowAsset).approve(_defaultStrategy, _amount);             _savingsAccount.deposit(_amount, _borrowAsset, _defaultStrategy, _lender);         }     } else {         _repayFromSavingsAccount(_amount, _borrowAsset, _lender);     }     if (_principalPaid != 0) {         _savingsAccount.increaseAllowanceToCreditLine(_principalPaid, _borrowAsset, _lender);     } }  /**  * @notice used to repay interest and principal to credit line. Interest has to be repaid before repaying principal  * @dev partial repayments possible  * @param _id identifier for the credit line  * @param _amount amount being repaid  * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount                              otherwise direct from collateral token contract  */ function repay(     uint256 _id,     uint256 _amount,     bool _fromSavingsAccount ) external payable nonReentrant {     require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');     require(creditLineConstants[_id].lender != msg.sender, 'Lender cant repay');      uint256 _interestSincePrincipalUpdate = calculateInterestAccrued(_id);     uint256 _totalInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(         _interestSincePrincipalUpdate     );     uint256 _interestToPay = _totalInterestAccrued.sub(creditLineVariables[_id].totalInterestRepaid);     uint256 _totalCurrentDebt = _interestToPay.add(creditLineVariables[_id].principal);     uint256 _principalPaid = 0;      if (_amount &gt;= _totalCurrentDebt) {         _amount = _totalCurrentDebt;         emit CompleteCreditLineRepaid(_id, _amount);     } else {         emit PartialCreditLineRepaid(_id, _amount);     }      if (_amount &gt; _interestToPay) {         creditLineVariables[_id].principal = _totalCurrentDebt.sub(_amount);         creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _totalInterestAccrued;         creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;         creditLineVariables[_id].totalInterestRepaid = _totalInterestAccrued;         _principalPaid = _amount.sub(_interestToPay);     } else {         creditLineVariables[_id].totalInterestRepaid = creditLineVariables[_id].totalInterestRepaid.add(_amount);     }      _repay(_id, _amount, _fromSavingsAccount, _principalPaid);      if (creditLineVariables[_id].principal == 0) {         _resetCreditLine(_id);     } }  function _resetCreditLine(uint256 _id) internal {     creditLineVariables[_id].lastPrincipalUpdateTime = 0;     creditLineVariables[_id].totalInterestRepaid = 0;     creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = 0;     emit CreditLineReset(_id); }  /**  * @dev used to close credit line by borrower or lender  * @param _id identifier for the credit line  */ function close(uint256 _id) external ifCreditLineExists(_id) {     require(         msg.sender == creditLineConstants[_id].borrower || msg.sender == creditLineConstants[_id].lender,         'CreditLine: Permission denied while closing Line of credit'     );     require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: Credit line should be active.');     require(creditLineVariables[_id].principal == 0, 'CreditLine: Cannot be closed since not repaid.');     require(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate == 0, 'CreditLine: Cannot be closed since not repaid.');     creditLineVariables[_id].status = CreditLineStatus.CLOSED;     emit CreditLineClosed(_id); }  /**  * @notice used to calculate the current collateral ratio  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view.         Interest is also considered while calculating debt  * @param _id identifier for the credit line  * @return collateral ratio multiplied by 10**30 to retain precision  */ function calculateCurrentCollateralRatio(uint256 _id) public ifCreditLineExists(_id) returns (uint256) {     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(         creditLineConstants[_id].collateralAsset,         creditLineConstants[_id].borrowAsset     );      uint256 currentDebt = calculateCurrentDebt(_id);     uint256 currentCollateralRatio = calculateTotalCollateralTokens(_id).mul(_ratioOfPrices).div(currentDebt).mul(10**30).div(         10**_decimals     );      return currentCollateralRatio; }  /**  * @notice used to calculate the total collateral tokens  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view  * @param _id identifier for the credit line  * @return _amount total collateral tokens deposited into the credit line  */ function calculateTotalCollateralTokens(uint256 _id) public returns (uint256 _amount) {     address _collateralAsset = creditLineConstants[_id].collateralAsset;     address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();     uint256 _liquidityShares;     for (uint256 index = 0; index &lt; _strategyList.length; index++) {         if (_strategyList[index] == address(0)) {             continue;         }         _liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];         uint256 _tokenInStrategy = _liquidityShares;         _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(_liquidityShares, _collateralAsset);          _amount = _amount.add(_tokenInStrategy);     } }  /**  * @notice used to withdraw any excess collateral  * @dev collateral can't be withdraw if collateralRatio goes below the ideal value. Only borrower can withdraw  * @param _id identifier for the credit line  * @param _amount amount of collateral to withdraw  * @param _toSavingsAccount if true, tokens are transferred from savingsAccount                              otherwise direct from collateral token contract  */ function withdrawCollateral(     uint256 _id,     uint256 _amount,     bool _toSavingsAccount ) external nonReentrant onlyCreditLineBorrower(_id) {     uint256 _withdrawableCollateral = withdrawableCollateral(_id);     require(_amount &lt;= _withdrawableCollateral, 'Collateral ratio cant go below ideal');     address _collateralAsset = creditLineConstants[_id].collateralAsset;     _transferCollateral(_id, _collateralAsset, _amount, _toSavingsAccount);     emit CollateralWithdrawn(_id, _amount); }  /**  * @notice used to calculate the collateral that can be withdrawn  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view  * @param _id identifier for the credit line  * @return total collateral withdrawable by borrower  */ function withdrawableCollateral(uint256 _id) public returns (uint256) {     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(         creditLineConstants[_id].collateralAsset,         creditLineConstants[_id].borrowAsset     );      uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);     uint256 _currentDebt = calculateCurrentDebt(_id);      uint256 _collateralNeeded = _currentDebt         .mul(creditLineConstants[_id].idealCollateralRatio)         .div(_ratioOfPrices)         .mul(10**_decimals)         .div(10**30);      if (_collateralNeeded &gt;= _totalCollateralTokens) {         return 0;     }     return _totalCollateralTokens.sub(_collateralNeeded); }  function _transferCollateral(     uint256 _id,     address _asset,     uint256 _amountInTokens,     bool _toSavingsAccount ) internal {     address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();     uint256 _activeAmount;     for (uint256 index = 0; index &lt; _strategyList.length; index++) {         uint256 liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];         if (liquidityShares == 0 || _strategyList[index] == address(0)) {             continue;         }         uint256 _tokenInStrategy = liquidityShares;         _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(liquidityShares, _asset);         uint256 _tokensToTransfer = _tokenInStrategy;         if (_activeAmount.add(_tokenInStrategy) &gt; _amountInTokens) {             _tokensToTransfer = _amountInTokens.sub(_activeAmount);             liquidityShares = liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy);         }         _activeAmount = _activeAmount.add(_tokensToTransfer);         collateralShareInStrategy[_id][_strategyList[index]] = collateralShareInStrategy[_id][_strategyList[index]].sub(             liquidityShares         );         if (_toSavingsAccount) {             ISavingsAccount(savingsAccount).transfer(_tokensToTransfer, _asset, _strategyList[index], msg.sender);         } else {             ISavingsAccount(savingsAccount).withdraw(_tokensToTransfer, _asset, _strategyList[index], msg.sender, false);         }          if (_activeAmount == _amountInTokens) {             return;         }     }     revert('insufficient collateral'); }  /**  * @notice used to liquidate credit line in case collateral ratio goes below the threshold  * @dev if lender liquidates, then collateral is directly transferred.          If autoLiquidation is true, anyone can liquidate by providing enough borrow tokens  * @param _id identifier for the credit line  * @param _toSavingsAccount if true, tokens are transferred from savingsAccount                              otherwise direct from collateral token contract  */ function liquidate(uint256 _id, bool _toSavingsAccount) external payable nonReentrant {     require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: Credit line should be active.');     require(creditLineVariables[_id].principal != 0, 'CreditLine: cannot liquidate if principal is 0');      uint256 currentCollateralRatio = calculateCurrentCollateralRatio(_id);     require(         currentCollateralRatio &lt; creditLineConstants[_id].idealCollateralRatio,         'CreditLine: Collateral ratio is higher than ideal value'     );      address _collateralAsset = creditLineConstants[_id].collateralAsset;     address _lender = creditLineConstants[_id].lender;     uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);     address _borrowAsset = creditLineConstants[_id].borrowAsset;      creditLineVariables[_id].status = CreditLineStatus.LIQUIDATED;      if (creditLineConstants[_id].autoLiquidation &amp;&amp; _lender != msg.sender) {         uint256 _borrowTokens = _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens);         if (_borrowAsset == address(0)) {             uint256 _returnETH = msg.value.sub(_borrowTokens, 'Insufficient ETH to liquidate');             if (_returnETH != 0) {                 (bool success, ) = msg.sender.call{value: _returnETH}('');                 require(success, 'Transfer fail');             }         } else {             IERC20(_borrowAsset).safeTransferFrom(msg.sender, _lender, _borrowTokens);         }     }      _transferCollateral(_id, _collateralAsset, _totalCollateralTokens, _toSavingsAccount);      emit CreditLineLiquidated(_id, msg.sender); }  /**  * @notice used to calculate the borrow tokens necessary for liquidator to liquidate  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view  * @param _id identifier for the credit line  * @return borrow tokens necessary for liquidator to liquidate  */ function borrowTokensToLiquidate(uint256 _id) external returns (uint256) {     address _collateralAsset = creditLineConstants[_id].collateralAsset;     uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);     address _borrowAsset = creditLineConstants[_id].borrowAsset;      return _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens); }  function _borrowTokensToLiquidate(     address _borrowAsset,     address _collateralAsset,     uint256 _totalCollateralTokens ) internal view returns (uint256) {     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(_borrowAsset, _collateralAsset);     uint256 _borrowTokens = (         _totalCollateralTokens.mul(uint256(10**30).sub(liquidatorRewardFraction)).div(10**30).mul(_ratioOfPrices).div(10**_decimals)     );      return _borrowTokens; }  receive() external payable {     require(msg.sender == savingsAccount, 'CreditLine::receive invalid transaction'); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-22-08 11:43:38 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/utils/ReentrancyGuard.sol';
import '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';
import '../interfaces/IPriceOracle.sol';
import '../interfaces/IYield.sol';
import '../interfaces/ISavingsAccount.sol';
import '../SavingsAccount/SavingsAccountUtil.sol';
import '../interfaces/IStrategyRegistry.sol';

/**
 * @title Credit Line contract with Methods related to credit Line
 * @notice Implements the functions related to Credit Line
 * @author Sublime
 **/

contract CreditLine is ReentrancyGuard, OwnableUpgradeable {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    enum CreditLineStatus {
        NOT_CREATED,
        REQUESTED,
        ACTIVE,
        CLOSED,
        CANCELLED,
        LIQUIDATED
    }

    /**
     * @notice counter that tracks the number of credit lines created
     * @dev used to create unique identifier for credit lines
     **/
    uint256 public creditLineCounter;

    uint256 constant YEAR_IN_SECONDS = 365 days;

    struct CreditLineVariables {
        CreditLineStatus status;
        uint256 principal;
        uint256 totalInterestRepaid;
        uint256 lastPrincipalUpdateTime;
        uint256 interestAccruedTillLastPrincipalUpdate;
    }

    struct CreditLineConstants {
        address lender;
        address borrower;
        uint256 borrowLimit;
        uint256 idealCollateralRatio;
        uint256 borrowRate;
        address borrowAsset;
        address collateralAsset;
        bool autoLiquidation;
        bool requestByLender;
    }
    /**
     * @notice stores the collateral shares in a credit line per strategy
     * @dev creditLineId => Strategy => collateralShares
     **/
    mapping(uint256 => mapping(address => uint256)) public collateralShareInStrategy;

    /**
     * @notice stores the variables to maintain a credit line
     **/
    mapping(uint256 => CreditLineVariables) public creditLineVariables;

    /**
     * @notice stores the constants related to a credit line
     **/
    mapping(uint256 => CreditLineConstants) public creditLineConstants;

    /**
     * @notice stores the address of savings account contract
     **/
    address public savingsAccount;

    /**
     * @notice stores the address of price oracle contract
     **/
    address public priceOracle;

    /**
     * @notice stores the address of strategy registry contract
     **/
    address public strategyRegistry;

    /**
     * @notice stores the address of default strategy
     **/
    address public defaultStrategy;

    /**
     * @notice stores the fraction of borrowed amount charged as fee by protocol
     * @dev it is multiplied by 10**30
     **/
    uint256 public protocolFeeFraction;

    /**
     * @notice address where protocol fee is collected
     **/
    address public protocolFeeCollector;

    /**
     * @notice stores the fraction of amount liquidated given as reward to liquidator
     * @dev it is multiplied by 10**30
     **/
    uint256 public liquidatorRewardFraction;
    /**
     * @dev checks if Credit Line exists
     * @param _id identifier for the credit line
     **/
    modifier ifCreditLineExists(uint256 _id) {
        require(creditLineVariables[_id].status != CreditLineStatus.NOT_CREATED, 'Credit line does not exist');
        _;
    }

    /**
     * @dev checks if called by credit Line Borrower
     * @param _id creditLine identifier
     **/
    modifier onlyCreditLineBorrower(uint256 _id) {
        require(creditLineConstants[_id].borrower == msg.sender, 'Only credit line Borrower can access');
        _;
    }

    /**
     * @dev checks if called by credit Line Lender
     * @param _id creditLine identifier
     **/
    modifier onlyCreditLineLender(uint256 _id) {
        require(creditLineConstants[_id].lender == msg.sender, 'Only credit line Lender can access');
        _;
    }

    /**
     * @notice emitted when a collateral is deposited into credit line
     * @param id id of the credit line
     * @param amount amount of collateral deposited
     * @param strategy address of the strategy into which collateral is deposited
     */
    event CollateralDeposited(uint256 indexed id, uint256 amount, address indexed strategy);

    /**
     * @notice emitted when collateral is withdrawn from credit line
     * @param id id of the credit line
     * @param amount amount of collateral withdrawn
     */
    event CollateralWithdrawn(uint256 indexed id, uint256 amount);

    /**
     * @notice emitted when a request for new credit line is placed
     * @param id id of the credit line for which request was made
     * @param lender address of the lender for credit line
     * @param borrower address of the borrower for credit line
     */
    event CreditLineRequested(uint256 indexed id, address indexed lender, address indexed borrower);

    /**
     * @notice emitted when a credit line is liquidated
     * @param id id of the credit line which is liquidated
     * @param liquidator address of the liquidator
     */
    event CreditLineLiquidated(uint256 indexed id, address indexed liquidator);

    /**
     * @notice emitted when tokens are borrowed from credit line
     * @param id id of the credit line from which tokens are borrowed
     * @param borrowAmount amount of tokens borrowed
     */
    event BorrowedFromCreditLine(uint256 indexed id, uint256 borrowAmount);

    /**
     * @notice emitted when credit line is accepted
     * @param id id of the credit line that was accepted
     */
    event CreditLineAccepted(uint256 indexed id);

    /**
     * @notice emitted when credit line is completely repaid and reset
     * @param id id of the credit line that is reset
     */
    event CreditLineReset(uint256 indexed id);

    /**
     * @notice emitted when the credit line is partially repaid
     * @param id id of the credit line
     * @param repayAmount amount repaid
     */
    event PartialCreditLineRepaid(uint256 indexed id, uint256 repayAmount);

    /**
     * @notice emitted when the credit line is completely repaid
     * @param id id of the credit line
     * @param repayAmount amount repaid
     */
    event CompleteCreditLineRepaid(uint256 indexed id, uint256 repayAmount);

    /**
     * @notice emitted when the credit line is closed by one of the parties of credit line
     * @param id id of the credit line
     */
    event CreditLineClosed(uint256 indexed id);

    /**
     * @notice emitted when default strategy for the credit line is updated
     * @param defaultStrategy address of the strategy contract that is used as default by credit lines
     */
    event DefaultStrategyUpdated(address indexed defaultStrategy);

    /**
     * @notice emitted when the price oracle is updated
     * @param priceOracle address of the updated price oracle
     */
    event PriceOracleUpdated(address indexed priceOracle);

    /**
     * @notice emitted when the savings account address is updated
     * @param savingsAccount address of the updated savingsAccount
     */
    event SavingsAccountUpdated(address indexed savingsAccount);

    /**
     * @notice emitted when strategy registry address is updated
     * @param strategyRegistry address of the updated strategy registry
     */
    event StrategyRegistryUpdated(address indexed strategyRegistry);

    /**
     * @notice emitted when fee that protocol charges for credit line is updated
     * @param updatedProtocolFee updated value of protocolFeeFraction
     */
    event ProtocolFeeFractionUpdated(uint256 updatedProtocolFee);

    /**
     * @notice emitted when address which receives fee that protocol changes for pools is updated
     * @param updatedProtocolFeeCollector updated value of protocolFeeCollector
     */
    event ProtocolFeeCollectorUpdated(address indexed updatedProtocolFeeCollector);

    /**
     * @notice emitted when liquidatorRewardFraction is updated
     * @param liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator
     */
    event LiquidationRewardFractionUpdated(uint256 liquidatorRewardFraction);

    /**
     * @notice used to initialize the contract
     * @dev can only be called once during the life cycle of the contract
     * @param _defaultStrategy default strategy used in credit lines
     * @param _priceOracle address of the priceOracle
     * @param _savingsAccount address of  the savings account contract
     * @param _strategyRegistry address of the strategy registry contract
     * @param _owner address of owner who can change global variables
     * @param _protocolFeeFraction fraction of the fee charged by protocol
     * @param _protocolFeeCollector address to which protocol fee is charged to
     * @param _liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator
     */
    function initialize(
        address _defaultStrategy,
        address _priceOracle,
        address _savingsAccount,
        address _strategyRegistry,
        address _owner,
        uint256 _protocolFeeFraction,
        address _protocolFeeCollector,
        uint256 _liquidatorRewardFraction
    ) external initializer {
        OwnableUpgradeable.__Ownable_init();
        OwnableUpgradeable.transferOwnership(_owner);

        _updateDefaultStrategy(_defaultStrategy);
        _updatePriceOracle(_priceOracle);
        _updateSavingsAccount(_savingsAccount);
        _updateStrategyRegistry(_strategyRegistry);
        _updateProtocolFeeFraction(_protocolFeeFraction);
        _updateProtocolFeeCollector(_protocolFeeCollector);
        _updateLiquidatorRewardFraction(_liquidatorRewardFraction);
    }

    /**
     * @notice used to update the default strategy
     * @dev can only be updated by owner
     * @param _defaultStrategy address of the updated default strategy
     */
    function updateDefaultStrategy(address _defaultStrategy) external onlyOwner {
        _updateDefaultStrategy(_defaultStrategy);
    }

    function _updateDefaultStrategy(address _defaultStrategy) internal {
        defaultStrategy = _defaultStrategy;
        emit DefaultStrategyUpdated(_defaultStrategy);
    }

    /**
     * @notice used to update the price oracle
     * @dev can only be updated by owner
     * @param _priceOracle address of the updated price oracle
     */
    function updatePriceOracle(address _priceOracle) external onlyOwner {
        _updatePriceOracle(_priceOracle);
    }

    function _updatePriceOracle(address _priceOracle) internal {
        priceOracle = _priceOracle;
        emit PriceOracleUpdated(_priceOracle);
    }

    /**
     * @notice used to update the savings account address
     * @dev can only be updated by owner
     * @param _savingsAccount address of the updated savings account
     */
    function updateSavingsAccount(address _savingsAccount) external onlyOwner {
        _updateSavingsAccount(_savingsAccount);
    }

    function _updateSavingsAccount(address _savingsAccount) internal {
        savingsAccount = _savingsAccount;
        emit SavingsAccountUpdated(_savingsAccount);
    }

    /**
     * @notice used to update the protocol fee fraction
     * @dev can only be updated by owner
     * @param _protocolFee fraction of the borrower amount collected as protocol fee
     */
    function updateProtocolFeeFraction(uint256 _protocolFee) external onlyOwner {
        _updateProtocolFeeFraction(_protocolFee);
    }

    function _updateProtocolFeeFraction(uint256 _protocolFee) internal {
        protocolFeeFraction = _protocolFee;
        emit ProtocolFeeFractionUpdated(_protocolFee);
    }

    /**
     * @notice used to update the protocol fee collector
     * @dev can only be updated by owner
     * @param _protocolFeeCollector address in which protocol fee is collected
     */
    function updateProtocolFeeCollector(address _protocolFeeCollector) external onlyOwner {
        _updateProtocolFeeCollector(_protocolFeeCollector);
    }

    function _updateProtocolFeeCollector(address _protocolFeeCollector) internal {
        require(_protocolFeeCollector != address(0), 'cant be 0 address');
        protocolFeeCollector = _protocolFeeCollector;
        emit ProtocolFeeCollectorUpdated(_protocolFeeCollector);
    }

    /**
     * @notice used to update the strategy registry address
     * @dev can only be updated by owner
     * @param _strategyRegistry address of the updated strategy registry
     */
    function updateStrategyRegistry(address _strategyRegistry) external onlyOwner {
        _updateStrategyRegistry(_strategyRegistry);
    }

    function _updateStrategyRegistry(address _strategyRegistry) internal {
        require(_strategyRegistry != address(0), 'CL::I zero address');
        strategyRegistry = _strategyRegistry;
        emit StrategyRegistryUpdated(_strategyRegistry);
    }

    /**
     * @notice used to update the liquidatorRewardFraction
     * @dev can only be updated by owner
     * @param _rewardFraction fraction of liquidated amount given to liquidator as reward
     */
    function updateLiquidatorRewardFraction(uint256 _rewardFraction) external onlyOwner {
        _updateLiquidatorRewardFraction(_rewardFraction);
    }

    function _updateLiquidatorRewardFraction(uint256 _rewardFraction) internal {
        require(_rewardFraction <= 10**30, 'Fraction has to be less than 1');
        liquidatorRewardFraction = _rewardFraction;
        emit LiquidationRewardFractionUpdated(_rewardFraction);
    }

    /**
     * @dev Used to Calculate Interest Per second on given principal and Interest rate
     * @param _principal principal Amount for which interest has to be calculated.
     * @param _borrowRate It is the Interest Rate at which Credit Line is approved
     * @return interest per second for the given parameters
     */
    function calculateInterest(
        uint256 _principal,
        uint256 _borrowRate,
        uint256 _timeElapsed
    ) public pure returns (uint256) {
        uint256 _interest = _principal.mul(_borrowRate).mul(_timeElapsed).div(10**30).div(YEAR_IN_SECONDS);

        return _interest;
    }

    /**
     * @dev Used to calculate interest accrued since last repayment
     * @param _id identifier for the credit line
     * @return interest accrued over current borrowed amount since last repayment
     */

    function calculateInterestAccrued(uint256 _id) public view returns (uint256) {
        uint256 _lastPrincipalUpdateTime = creditLineVariables[_id].lastPrincipalUpdateTime;
        if (_lastPrincipalUpdateTime == 0) return 0;
        uint256 _timeElapsed = (block.timestamp).sub(_lastPrincipalUpdateTime);
        uint256 _interestAccrued = calculateInterest(creditLineVariables[_id].principal, creditLineConstants[_id].borrowRate, _timeElapsed);
        return _interestAccrued;
    }

    /**
     * @dev Used to calculate current debt of borrower against a credit line.
     * @param _id identifier for the credit line
     * @return current debt of borrower
     */
    function calculateCurrentDebt(uint256 _id) public view returns (uint256) {
        uint256 _interestAccrued = calculateInterestAccrued(_id);
        uint256 _currentDebt = (creditLineVariables[_id].principal)
            .add(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate)
            .add(_interestAccrued)
            .sub(creditLineVariables[_id].totalInterestRepaid);
        return _currentDebt;
    }

    /**
     * @notice used to calculate amount that can be borrowed by the borrower
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view.
            borrowableAmount changes per block as interest changes per block.
     * @param _id identifier for the credit line
     * @return amount that can be borrowed from the credit line
     */
    function calculateBorrowableAmount(uint256 _id) public returns (uint256) {
        CreditLineStatus _status = creditLineVariables[_id].status;
        require(
            _status == CreditLineStatus.ACTIVE || _status == CreditLineStatus.REQUESTED,
            'CreditLine: Cannot only if credit line ACTIVE or REQUESTED'
        );
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(
            creditLineConstants[_id].collateralAsset,
            creditLineConstants[_id].borrowAsset
        );

        uint256 _totalCollateralToken = calculateTotalCollateralTokens(_id);

        uint256 _currentDebt = calculateCurrentDebt(_id);

        uint256 _maxPossible = _totalCollateralToken.mul(_ratioOfPrices).div(creditLineConstants[_id].idealCollateralRatio).mul(10**30).div(
            10**_decimals
        );

        uint256 _borrowLimit = creditLineConstants[_id].borrowLimit;

        if (_maxPossible > _borrowLimit) {
            _maxPossible = _borrowLimit;
        }
        if (_maxPossible > _currentDebt) {
            return _maxPossible.sub(_currentDebt);
        }
        return 0;
    }

    function updateinterestAccruedTillLastPrincipalUpdate(uint256 _id) internal {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');

        uint256 _interestAccrued = calculateInterestAccrued(_id);
        uint256 _newInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(_interestAccrued);
        creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _newInterestAccrued;
    }

    function _depositCollateralFromSavingsAccount(
        uint256 _id,
        uint256 _amount,
        address _sender
    ) internal {
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        uint256 _activeAmount;

        for (uint256 _index = 0; _index < _strategyList.length; _index++) {
            address _strategy = _strategyList[_index];
            uint256 _liquidityShares = _savingsAccount.balanceInShares(_sender, _collateralAsset, _strategy);
            if (_liquidityShares == 0 || _strategyList[_index] == address(0)) {
                continue;
            }
            uint256 _tokenInStrategy = _liquidityShares;
            _tokenInStrategy = IYield(_strategy).getTokensForShares(_liquidityShares, _collateralAsset);

            uint256 _tokensToTransfer = _tokenInStrategy;
            if (_activeAmount.add(_tokenInStrategy) >= _amount) {
                _tokensToTransfer = (_amount.sub(_activeAmount));
            }
            _activeAmount = _activeAmount.add(_tokensToTransfer);
            _savingsAccount.transferFrom(_tokensToTransfer, _collateralAsset, _strategy, _sender, address(this));

            collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(
                _liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy)
            );

            if (_amount == _activeAmount) {
                return;
            }
        }
        revert('CreditLine::_depositCollateralFromSavingsAccount - Insufficient balance');
    }

    /**
     * @notice used to request a credit line either by borrower or lender
     * @param _requestTo Address to which creditLine is requested, 
                        if borrower creates request then lender address and 
                        if lender creates then borrower address
     * @param _borrowLimit maximum borrow amount in a credit line
     * @param _borrowRate Interest Rate at which credit Line is requested
     * @param _autoLiquidation if true, anyone can liquidate loan, otherwise only lender
     * @param _collateralRatio ratio of the collateral to the debt below which credit line can be liquidated
     * @param _borrowAsset address of the token to be borrowed
     * @param _collateralAsset address of the token provided as collateral
     * @param _requestAsLender if true, lender is placing request, otherwise borrower
     * @return identifier for the credit line
     */

    function request(
        address _requestTo,
        uint256 _borrowLimit,
        uint256 _borrowRate,
        bool _autoLiquidation,
        uint256 _collateralRatio,
        address _borrowAsset,
        address _collateralAsset,
        bool _requestAsLender
    ) external returns (uint256) {
        require(_borrowAsset != _collateralAsset, 'R: cant borrow lent token');
        require(IPriceOracle(priceOracle).doesFeedExist(_borrowAsset, _collateralAsset), 'R: No price feed');

        address _lender = _requestTo;
        address _borrower = msg.sender;
        if (_requestAsLender) {
            _lender = msg.sender;
            _borrower = _requestTo;
        }

        uint256 _id = _createRequest(
            _lender,
            _borrower,
            _borrowLimit,
            _borrowRate,
            _autoLiquidation,
            _collateralRatio,
            _borrowAsset,
            _collateralAsset,
            _requestAsLender
        );

        emit CreditLineRequested(_id, _lender, _borrower);
        return _id;
    }

    function _createRequest(
        address _lender,
        address _borrower,
        uint256 _borrowLimit,
        uint256 _borrowRate,
        bool _autoLiquidation,
        uint256 _collateralRatio,
        address _borrowAsset,
        address _collateralAsset,
        bool _requestByLender
    ) internal returns (uint256) {
        require(_lender != _borrower, 'Lender and Borrower cannot be same addresses');
        uint256 _id = creditLineCounter + 1;
        creditLineCounter = _id;
        creditLineVariables[_id].status = CreditLineStatus.REQUESTED;
        creditLineConstants[_id].borrower = _borrower;
        creditLineConstants[_id].lender = _lender;
        creditLineConstants[_id].borrowLimit = _borrowLimit;
        creditLineConstants[_id].autoLiquidation = _autoLiquidation;
        creditLineConstants[_id].idealCollateralRatio = _collateralRatio;
        creditLineConstants[_id].borrowRate = _borrowRate;
        creditLineConstants[_id].borrowAsset = _borrowAsset;
        creditLineConstants[_id].collateralAsset = _collateralAsset;
        creditLineConstants[_id].requestByLender = _requestByLender;
        return _id;
    }

    /**
     * @notice used to accept a credit line
     * @dev if borrower places request, lender can accept and vice versa
     * @param _id identifier for the credit line
     */
    function accept(uint256 _id) external {
        require(
            creditLineVariables[_id].status == CreditLineStatus.REQUESTED,
            'CreditLine::acceptCreditLineLender - CreditLine is already accepted'
        );
        bool _requestByLender = creditLineConstants[_id].requestByLender;
        require(
            (msg.sender == creditLineConstants[_id].borrower && _requestByLender) ||
                (msg.sender == creditLineConstants[_id].lender && !_requestByLender),
            "Only Borrower or Lender who hasn't requested can accept"
        );
        creditLineVariables[_id].status = CreditLineStatus.ACTIVE;
        emit CreditLineAccepted(_id);
    }

    /**
     * @notice used to deposit collateral into the credit line
     * @dev collateral tokens have to be approved in savingsAccount or token contract(unless ether).
            If transferred from savings account, the tokens are transferred from strategies in the 
            order prespecified in strategy registry
     * @param _id identifier for the credit line
     * @param _amount amount of collateral being deposited
     * @param _strategy strategy to which collateral is to be deposited in case transfer is not from savings account
     * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount 
                                otherwise direct from collateral token contract
     */
    function depositCollateral(
        uint256 _id,
        uint256 _amount,
        address _strategy,
        bool _fromSavingsAccount
    ) external payable nonReentrant ifCreditLineExists(_id) {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine not active');
        _depositCollateral(_id, _amount, _strategy, _fromSavingsAccount);
        emit CollateralDeposited(_id, _amount, _strategy);
    }

    function _depositCollateral(
        uint256 _id,
        uint256 _amount,
        address _strategy,
        bool _fromSavingsAccount
    ) internal {
        require(creditLineConstants[_id].lender != msg.sender, 'lender cant deposit collateral');
        if (_fromSavingsAccount) {
            _depositCollateralFromSavingsAccount(_id, _amount, msg.sender);
        } else {
            address _collateralAsset = creditLineConstants[_id].collateralAsset;
            ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
            if (_collateralAsset == address(0)) {
                require(msg.value == _amount, "CreditLine::_depositCollateral - value to transfer doesn't match argument");
            } else {
                IERC20(_collateralAsset).safeTransferFrom(msg.sender, address(this), _amount);
                IERC20(_collateralAsset).approve(_strategy, _amount);
            }
            uint256 _sharesReceived = _savingsAccount.deposit{value: msg.value}(_amount, _collateralAsset, _strategy, address(this));
            collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(_sharesReceived);
        }
    }

    function _withdrawBorrowAmount(
        address _asset,
        uint256 _amountInTokens,
        address _lender
    ) internal {
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        uint256 _activeAmount;
        for (uint256 _index = 0; _index < _strategyList.length; _index++) {
            if (_strategyList[_index] == address(0)) {
                continue;
            }
            uint256 _liquidityShares = _savingsAccount.balanceInShares(_lender, _asset, _strategyList[_index]);
            if (_liquidityShares != 0) {
                uint256 tokenInStrategy = _liquidityShares;
                tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);
                uint256 _tokensToTransfer = tokenInStrategy;
                if (_activeAmount.add(tokenInStrategy) >= _amountInTokens) {
                    _tokensToTransfer = (_amountInTokens.sub(_activeAmount));
                }
                _activeAmount = _activeAmount.add(_tokensToTransfer);
                _savingsAccount.withdrawFrom(_tokensToTransfer, _asset, _strategyList[_index], _lender, address(this), false);
                if (_activeAmount == _amountInTokens) {
                    return;
                }
            }
        }
        require(_activeAmount == _amountInTokens, 'insufficient balance');
    }

    /**
     * @notice used to borrow tokens from credit line by borrower
     * @dev only borrower can call this function. Amount that can actually be borrowed is 
            min(amount based on borrowLimit, allowance to creditLine contract, balance of lender)
     * @param _id identifier for the credit line
     * @param _amount amount of tokens to borrow
     */
    function borrow(uint256 _id, uint256 _amount) external payable nonReentrant onlyCreditLineBorrower(_id) {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');
        uint256 _borrowableAmount = calculateBorrowableAmount(_id);
        require(_amount <= _borrowableAmount, "CreditLine::borrow - The current collateral ratio doesn't allow to withdraw the amount");
        address _borrowAsset = creditLineConstants[_id].borrowAsset;
        address _lender = creditLineConstants[_id].lender;

        updateinterestAccruedTillLastPrincipalUpdate(_id);
        creditLineVariables[_id].principal = creditLineVariables[_id].principal.add(_amount);
        creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;

        uint256 _tokenDiffBalance;
        if (_borrowAsset != address(0)) {
            uint256 _balanceBefore = IERC20(_borrowAsset).balanceOf(address(this));
            _withdrawBorrowAmount(_borrowAsset, _amount, _lender);
            uint256 _balanceAfter = IERC20(_borrowAsset).balanceOf(address(this));
            _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);
        } else {
            uint256 _balanceBefore = address(this).balance;
            _withdrawBorrowAmount(_borrowAsset, _amount, _lender);
            uint256 _balanceAfter = address(this).balance;
            _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);
        }
        uint256 _protocolFee = _tokenDiffBalance.mul(protocolFeeFraction).div(10**30);
        _tokenDiffBalance = _tokenDiffBalance.sub(_protocolFee);

        if (_borrowAsset == address(0)) {
            (bool feeSuccess, ) = protocolFeeCollector.call{value: _protocolFee}('');
            require(feeSuccess, 'Transfer fail');
            (bool success, ) = msg.sender.call{value: _tokenDiffBalance}('');
            require(success, 'Transfer fail');
        } else {
            IERC20(_borrowAsset).safeTransfer(protocolFeeCollector, _protocolFee);
            IERC20(_borrowAsset).safeTransfer(msg.sender, _tokenDiffBalance);
        }
        emit BorrowedFromCreditLine(_id, _tokenDiffBalance);
    }

    function _repayFromSavingsAccount(
        uint256 _amount,
        address _asset,
        address _lender
    ) internal {
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        uint256 _activeAmount;

        for (uint256 _index = 0; _index < _strategyList.length; _index++) {
            if (_strategyList[_index] == address(0)) {
                continue;
            }
            uint256 _liquidityShares = _savingsAccount.balanceInShares(msg.sender, _asset, _strategyList[_index]);
            if (_liquidityShares == 0) {
                continue;
            }
            uint256 _tokenInStrategy = _liquidityShares;
            _tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);

            uint256 _tokensToTransfer = _tokenInStrategy;
            if (_activeAmount.add(_tokenInStrategy) >= _amount) {
                _tokensToTransfer = (_amount.sub(_activeAmount));
            }
            _activeAmount = _activeAmount.add(_tokensToTransfer);
            _savingsAccount.transferFrom(_tokensToTransfer, _asset, _strategyList[_index], msg.sender, _lender);

            if (_amount == _activeAmount) {
                return;
            }
        }
        revert('CreditLine::_repayFromSavingsAccount - Insufficient balance');
    }

    function _repay(
        uint256 _id,
        uint256 _amount,
        bool _fromSavingsAccount,
        uint256 _principalPaid
    ) internal {
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        address _defaultStrategy = defaultStrategy;
        address _borrowAsset = creditLineConstants[_id].borrowAsset;
        address _lender = creditLineConstants[_id].lender;
        if (!_fromSavingsAccount) {
            if (_borrowAsset == address(0)) {
                require(msg.value == _amount, 'creditLine::repay - Ether sent not equal to repay amount');
                _savingsAccount.deposit{value: _amount}(_amount, _borrowAsset, _defaultStrategy, _lender);
            } else {
                IERC20(_borrowAsset).safeTransferFrom(msg.sender, address(this), _amount);
                IERC20(_borrowAsset).approve(_defaultStrategy, _amount);
                _savingsAccount.deposit(_amount, _borrowAsset, _defaultStrategy, _lender);
            }
        } else {
            _repayFromSavingsAccount(_amount, _borrowAsset, _lender);
        }
        if (_principalPaid != 0) {
            _savingsAccount.increaseAllowanceToCreditLine(_principalPaid, _borrowAsset, _lender);
        }
    }

    /**
     * @notice used to repay interest and principal to credit line. Interest has to be repaid before repaying principal
     * @dev partial repayments possible
     * @param _id identifier for the credit line
     * @param _amount amount being repaid
     * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount 
                                otherwise direct from collateral token contract
     */
    function repay(
        uint256 _id,
        uint256 _amount,
        bool _fromSavingsAccount
    ) external payable nonReentrant {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');
        require(creditLineConstants[_id].lender != msg.sender, 'Lender cant repay');

        uint256 _interestSincePrincipalUpdate = calculateInterestAccrued(_id);
        uint256 _totalInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(
            _interestSincePrincipalUpdate
        );
        uint256 _interestToPay = _totalInterestAccrued.sub(creditLineVariables[_id].totalInterestRepaid);
        uint256 _totalCurrentDebt = _interestToPay.add(creditLineVariables[_id].principal);
        uint256 _principalPaid = 0;

        if (_amount >= _totalCurrentDebt) {
            _amount = _totalCurrentDebt;
            emit CompleteCreditLineRepaid(_id, _amount);
        } else {
            emit PartialCreditLineRepaid(_id, _amount);
        }

        if (_amount > _interestToPay) {
            creditLineVariables[_id].principal = _totalCurrentDebt.sub(_amount);
            creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _totalInterestAccrued;
            creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;
            creditLineVariables[_id].totalInterestRepaid = _totalInterestAccrued;
            _principalPaid = _amount.sub(_interestToPay);
        } else {
            creditLineVariables[_id].totalInterestRepaid = creditLineVariables[_id].totalInterestRepaid.add(_amount);
        }

        _repay(_id, _amount, _fromSavingsAccount, _principalPaid);

        if (creditLineVariables[_id].principal == 0) {
            _resetCreditLine(_id);
        }
    }

    function _resetCreditLine(uint256 _id) internal {
        creditLineVariables[_id].lastPrincipalUpdateTime = 0;
        creditLineVariables[_id].totalInterestRepaid = 0;
        creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = 0;
        emit CreditLineReset(_id);
    }

    /**
     * @dev used to close credit line by borrower or lender
     * @param _id identifier for the credit line
     */
    function close(uint256 _id) external ifCreditLineExists(_id) {
        require(
            msg.sender == creditLineConstants[_id].borrower || msg.sender == creditLineConstants[_id].lender,
            'CreditLine: Permission denied while closing Line of credit'
        );
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: Credit line should be active.');
        require(creditLineVariables[_id].principal == 0, 'CreditLine: Cannot be closed since not repaid.');
        require(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate == 0, 'CreditLine: Cannot be closed since not repaid.');
        creditLineVariables[_id].status = CreditLineStatus.CLOSED;
        emit CreditLineClosed(_id);
    }

    /**
     * @notice used to calculate the current collateral ratio
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view.
            Interest is also considered while calculating debt
     * @param _id identifier for the credit line
     * @return collateral ratio multiplied by 10**30 to retain precision
     */
    function calculateCurrentCollateralRatio(uint256 _id) public ifCreditLineExists(_id) returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(
            creditLineConstants[_id].collateralAsset,
            creditLineConstants[_id].borrowAsset
        );

        uint256 currentDebt = calculateCurrentDebt(_id);
        uint256 currentCollateralRatio = calculateTotalCollateralTokens(_id).mul(_ratioOfPrices).div(currentDebt).mul(10**30).div(
            10**_decimals
        );

        return currentCollateralRatio;
    }

    /**
     * @notice used to calculate the total collateral tokens
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @param _id identifier for the credit line
     * @return _amount total collateral tokens deposited into the credit line
     */
    function calculateTotalCollateralTokens(uint256 _id) public returns (uint256 _amount) {
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        uint256 _liquidityShares;
        for (uint256 index = 0; index < _strategyList.length; index++) {
            if (_strategyList[index] == address(0)) {
                continue;
            }
            _liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];
            uint256 _tokenInStrategy = _liquidityShares;
            _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(_liquidityShares, _collateralAsset);

            _amount = _amount.add(_tokenInStrategy);
        }
    }

    /**
     * @notice used to withdraw any excess collateral
     * @dev collateral can't be withdraw if collateralRatio goes below the ideal value. Only borrower can withdraw
     * @param _id identifier for the credit line
     * @param _amount amount of collateral to withdraw
     * @param _toSavingsAccount if true, tokens are transferred from savingsAccount 
                                otherwise direct from collateral token contract
     */
    function withdrawCollateral(
        uint256 _id,
        uint256 _amount,
        bool _toSavingsAccount
    ) external nonReentrant onlyCreditLineBorrower(_id) {
        uint256 _withdrawableCollateral = withdrawableCollateral(_id);
        require(_amount <= _withdrawableCollateral, 'Collateral ratio cant go below ideal');
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        _transferCollateral(_id, _collateralAsset, _amount, _toSavingsAccount);
        emit CollateralWithdrawn(_id, _amount);
    }

    /**
     * @notice used to calculate the collateral that can be withdrawn
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @param _id identifier for the credit line
     * @return total collateral withdrawable by borrower
     */
    function withdrawableCollateral(uint256 _id) public returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(
            creditLineConstants[_id].collateralAsset,
            creditLineConstants[_id].borrowAsset
        );

        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);
        uint256 _currentDebt = calculateCurrentDebt(_id);

        uint256 _collateralNeeded = _currentDebt
            .mul(creditLineConstants[_id].idealCollateralRatio)
            .div(_ratioOfPrices)
            .mul(10**_decimals)
            .div(10**30);

        if (_collateralNeeded >= _totalCollateralTokens) {
            return 0;
        }
        return _totalCollateralTokens.sub(_collateralNeeded);
    }

    function _transferCollateral(
        uint256 _id,
        address _asset,
        uint256 _amountInTokens,
        bool _toSavingsAccount
    ) internal {
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        uint256 _activeAmount;
        for (uint256 index = 0; index < _strategyList.length; index++) {
            uint256 liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];
            if (liquidityShares == 0 || _strategyList[index] == address(0)) {
                continue;
            }
            uint256 _tokenInStrategy = liquidityShares;
            _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(liquidityShares, _asset);
            uint256 _tokensToTransfer = _tokenInStrategy;
            if (_activeAmount.add(_tokenInStrategy) > _amountInTokens) {
                _tokensToTransfer = _amountInTokens.sub(_activeAmount);
                liquidityShares = liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy);
            }
            _activeAmount = _activeAmount.add(_tokensToTransfer);
            collateralShareInStrategy[_id][_strategyList[index]] = collateralShareInStrategy[_id][_strategyList[index]].sub(
                liquidityShares
            );
            if (_toSavingsAccount) {
                ISavingsAccount(savingsAccount).transfer(_tokensToTransfer, _asset, _strategyList[index], msg.sender);
            } else {
                ISavingsAccount(savingsAccount).withdraw(_tokensToTransfer, _asset, _strategyList[index], msg.sender, false);
            }

            if (_activeAmount == _amountInTokens) {
                return;
            }
        }
        revert('insufficient collateral');
    }

    /**
     * @notice used to liquidate credit line in case collateral ratio goes below the threshold
     * @dev if lender liquidates, then collateral is directly transferred. 
            If autoLiquidation is true, anyone can liquidate by providing enough borrow tokens
     * @param _id identifier for the credit line
     * @param _toSavingsAccount if true, tokens are transferred from savingsAccount 
                                otherwise direct from collateral token contract
     */
    function liquidate(uint256 _id, bool _toSavingsAccount) external payable nonReentrant {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: Credit line should be active.');
        require(creditLineVariables[_id].principal != 0, 'CreditLine: cannot liquidate if principal is 0');

        uint256 currentCollateralRatio = calculateCurrentCollateralRatio(_id);
        require(
            currentCollateralRatio < creditLineConstants[_id].idealCollateralRatio,
            'CreditLine: Collateral ratio is higher than ideal value'
        );

        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        address _lender = creditLineConstants[_id].lender;
        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);
        address _borrowAsset = creditLineConstants[_id].borrowAsset;

        creditLineVariables[_id].status = CreditLineStatus.LIQUIDATED;

        if (creditLineConstants[_id].autoLiquidation && _lender != msg.sender) {
            uint256 _borrowTokens = _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens);
            if (_borrowAsset == address(0)) {
                uint256 _returnETH = msg.value.sub(_borrowTokens, 'Insufficient ETH to liquidate');
                if (_returnETH != 0) {
                    (bool success, ) = msg.sender.call{value: _returnETH}('');
                    require(success, 'Transfer fail');
                }
            } else {
                IERC20(_borrowAsset).safeTransferFrom(msg.sender, _lender, _borrowTokens);
            }
        }

        _transferCollateral(_id, _collateralAsset, _totalCollateralTokens, _toSavingsAccount);

        emit CreditLineLiquidated(_id, msg.sender);
    }

    /**
     * @notice used to calculate the borrow tokens necessary for liquidator to liquidate
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @param _id identifier for the credit line
     * @return borrow tokens necessary for liquidator to liquidate
     */
    function borrowTokensToLiquidate(uint256 _id) external returns (uint256) {
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);
        address _borrowAsset = creditLineConstants[_id].borrowAsset;

        return _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens);
    }

    function _borrowTokensToLiquidate(
        address _borrowAsset,
        address _collateralAsset,
        uint256 _totalCollateralTokens
    ) internal view returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(_borrowAsset, _collateralAsset);
        uint256 _borrowTokens = (
            _totalCollateralTokens.mul(uint256(10**30).sub(liquidatorRewardFraction)).div(10**30).mul(_ratioOfPrices).div(10**_decimals)
        );

        return _borrowTokens;
    }

    receive() external payable {
        require(msg.sender == savingsAccount, 'CreditLine::receive invalid transaction');
    }
}
.]

Given the user's task and the brainstorming ideas provided:
Task: "// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/utils/ReentrancyGuard.sol';
import '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';
import '../interfaces/IPriceOracle.sol';
import '../interfaces/IYield.sol';
import '../interfaces/ISavingsAccount.sol';
import '../SavingsAccount/SavingsAccountUtil.sol';
import '../interfaces/IStrategyRegistry.sol';

/**
 * @title Credit Line contract with Methods related to credit Line
 * @notice Implements the functions related to Credit Line
 * @author Sublime
 **/

contract CreditLine is ReentrancyGuard, OwnableUpgradeable {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    enum CreditLineStatus {
        NOT_CREATED,
        REQUESTED,
        ACTIVE,
        CLOSED,
        CANCELLED,
        LIQUIDATED
    }

    /**
     * @notice counter that tracks the number of credit lines created
     * @dev used to create unique identifier for credit lines
     **/
    uint256 public creditLineCounter;

    uint256 constant YEAR_IN_SECONDS = 365 days;

    struct CreditLineVariables {
        CreditLineStatus status;
        uint256 principal;
        uint256 totalInterestRepaid;
        uint256 lastPrincipalUpdateTime;
        uint256 interestAccruedTillLastPrincipalUpdate;
    }

    struct CreditLineConstants {
        address lender;
        address borrower;
        uint256 borrowLimit;
        uint256 idealCollateralRatio;
        uint256 borrowRate;
        address borrowAsset;
        address collateralAsset;
        bool autoLiquidation;
        bool requestByLender;
    }
    /**
     * @notice stores the collateral shares in a credit line per strategy
     * @dev creditLineId => Strategy => collateralShares
     **/
    mapping(uint256 => mapping(address => uint256)) public collateralShareInStrategy;

    /**
     * @notice stores the variables to maintain a credit line
     **/
    mapping(uint256 => CreditLineVariables) public creditLineVariables;

    /**
     * @notice stores the constants related to a credit line
     **/
    mapping(uint256 => CreditLineConstants) public creditLineConstants;

    /**
     * @notice stores the address of savings account contract
     **/
    address public savingsAccount;

    /**
     * @notice stores the address of price oracle contract
     **/
    address public priceOracle;

    /**
     * @notice stores the address of strategy registry contract
     **/
    address public strategyRegistry;

    /**
     * @notice stores the address of default strategy
     **/
    address public defaultStrategy;

    /**
     * @notice stores the fraction of borrowed amount charged as fee by protocol
     * @dev it is multiplied by 10**30
     **/
    uint256 public protocolFeeFraction;

    /**
     * @notice address where protocol fee is collected
     **/
    address public protocolFeeCollector;

    /**
     * @notice stores the fraction of amount liquidated given as reward to liquidator
     * @dev it is multiplied by 10**30
     **/
    uint256 public liquidatorRewardFraction;
    /**
     * @dev checks if Credit Line exists
     * @param _id identifier for the credit line
     **/
    modifier ifCreditLineExists(uint256 _id) {
        require(creditLineVariables[_id].status != CreditLineStatus.NOT_CREATED, 'Credit line does not exist');
        _;
    }

    /**
     * @dev checks if called by credit Line Borrower
     * @param _id creditLine identifier
     **/
    modifier onlyCreditLineBorrower(uint256 _id) {
        require(creditLineConstants[_id].borrower == msg.sender, 'Only credit line Borrower can access');
        _;
    }

    /**
     * @dev checks if called by credit Line Lender
     * @param _id creditLine identifier
     **/
    modifier onlyCreditLineLender(uint256 _id) {
        require(creditLineConstants[_id].lender == msg.sender, 'Only credit line Lender can access');
        _;
    }

    /**
     * @notice emitted when a collateral is deposited into credit line
     * @param id id of the credit line
     * @param amount amount of collateral deposited
     * @param strategy address of the strategy into which collateral is deposited
     */
    event CollateralDeposited(uint256 indexed id, uint256 amount, address indexed strategy);

    /**
     * @notice emitted when collateral is withdrawn from credit line
     * @param id id of the credit line
     * @param amount amount of collateral withdrawn
     */
    event CollateralWithdrawn(uint256 indexed id, uint256 amount);

    /**
     * @notice emitted when a request for new credit line is placed
     * @param id id of the credit line for which request was made
     * @param lender address of the lender for credit line
     * @param borrower address of the borrower for credit line
     */
    event CreditLineRequested(uint256 indexed id, address indexed lender, address indexed borrower);

    /**
     * @notice emitted when a credit line is liquidated
     * @param id id of the credit line which is liquidated
     * @param liquidator address of the liquidator
     */
    event CreditLineLiquidated(uint256 indexed id, address indexed liquidator);

    /**
     * @notice emitted when tokens are borrowed from credit line
     * @param id id of the credit line from which tokens are borrowed
     * @param borrowAmount amount of tokens borrowed
     */
    event BorrowedFromCreditLine(uint256 indexed id, uint256 borrowAmount);

    /**
     * @notice emitted when credit line is accepted
     * @param id id of the credit line that was accepted
     */
    event CreditLineAccepted(uint256 indexed id);

    /**
     * @notice emitted when credit line is completely repaid and reset
     * @param id id of the credit line that is reset
     */
    event CreditLineReset(uint256 indexed id);

    /**
     * @notice emitted when the credit line is partially repaid
     * @param id id of the credit line
     * @param repayAmount amount repaid
     */
    event PartialCreditLineRepaid(uint256 indexed id, uint256 repayAmount);

    /**
     * @notice emitted when the credit line is completely repaid
     * @param id id of the credit line
     * @param repayAmount amount repaid
     */
    event CompleteCreditLineRepaid(uint256 indexed id, uint256 repayAmount);

    /**
     * @notice emitted when the credit line is closed by one of the parties of credit line
     * @param id id of the credit line
     */
    event CreditLineClosed(uint256 indexed id);

    /**
     * @notice emitted when default strategy for the credit line is updated
     * @param defaultStrategy address of the strategy contract that is used as default by credit lines
     */
    event DefaultStrategyUpdated(address indexed defaultStrategy);

    /**
     * @notice emitted when the price oracle is updated
     * @param priceOracle address of the updated price oracle
     */
    event PriceOracleUpdated(address indexed priceOracle);

    /**
     * @notice emitted when the savings account address is updated
     * @param savingsAccount address of the updated savingsAccount
     */
    event SavingsAccountUpdated(address indexed savingsAccount);

    /**
     * @notice emitted when strategy registry address is updated
     * @param strategyRegistry address of the updated strategy registry
     */
    event StrategyRegistryUpdated(address indexed strategyRegistry);

    /**
     * @notice emitted when fee that protocol charges for credit line is updated
     * @param updatedProtocolFee updated value of protocolFeeFraction
     */
    event ProtocolFeeFractionUpdated(uint256 updatedProtocolFee);

    /**
     * @notice emitted when address which receives fee that protocol changes for pools is updated
     * @param updatedProtocolFeeCollector updated value of protocolFeeCollector
     */
    event ProtocolFeeCollectorUpdated(address indexed updatedProtocolFeeCollector);

    /**
     * @notice emitted when liquidatorRewardFraction is updated
     * @param liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator
     */
    event LiquidationRewardFractionUpdated(uint256 liquidatorRewardFraction);

    /**
     * @notice used to initialize the contract
     * @dev can only be called once during the life cycle of the contract
     * @param _defaultStrategy default strategy used in credit lines
     * @param _priceOracle address of the priceOracle
     * @param _savingsAccount address of  the savings account contract
     * @param _strategyRegistry address of the strategy registry contract
     * @param _owner address of owner who can change global variables
     * @param _protocolFeeFraction fraction of the fee charged by protocol
     * @param _protocolFeeCollector address to which protocol fee is charged to
     * @param _liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator
     */
    function initialize(
        address _defaultStrategy,
        address _priceOracle,
        address _savingsAccount,
        address _strategyRegistry,
        address _owner,
        uint256 _protocolFeeFraction,
        address _protocolFeeCollector,
        uint256 _liquidatorRewardFraction
    ) external initializer {
        OwnableUpgradeable.__Ownable_init();
        OwnableUpgradeable.transferOwnership(_owner);

        _updateDefaultStrategy(_defaultStrategy);
        _updatePriceOracle(_priceOracle);
        _updateSavingsAccount(_savingsAccount);
        _updateStrategyRegistry(_strategyRegistry);
        _updateProtocolFeeFraction(_protocolFeeFraction);
        _updateProtocolFeeCollector(_protocolFeeCollector);
        _updateLiquidatorRewardFraction(_liquidatorRewardFraction);
    }

    /**
     * @notice used to update the default strategy
     * @dev can only be updated by owner
     * @param _defaultStrategy address of the updated default strategy
     */
    function updateDefaultStrategy(address _defaultStrategy) external onlyOwner {
        _updateDefaultStrategy(_defaultStrategy);
    }

    function _updateDefaultStrategy(address _defaultStrategy) internal {
        defaultStrategy = _defaultStrategy;
        emit DefaultStrategyUpdated(_defaultStrategy);
    }

    /**
     * @notice used to update the price oracle
     * @dev can only be updated by owner
     * @param _priceOracle address of the updated price oracle
     */
    function updatePriceOracle(address _priceOracle) external onlyOwner {
        _updatePriceOracle(_priceOracle);
    }

    function _updatePriceOracle(address _priceOracle) internal {
        priceOracle = _priceOracle;
        emit PriceOracleUpdated(_priceOracle);
    }

    /**
     * @notice used to update the savings account address
     * @dev can only be updated by owner
     * @param _savingsAccount address of the updated savings account
     */
    function updateSavingsAccount(address _savingsAccount) external onlyOwner {
        _updateSavingsAccount(_savingsAccount);
    }

    function _updateSavingsAccount(address _savingsAccount) internal {
        savingsAccount = _savingsAccount;
        emit SavingsAccountUpdated(_savingsAccount);
    }

    /**
     * @notice used to update the protocol fee fraction
     * @dev can only be updated by owner
     * @param _protocolFee fraction of the borrower amount collected as protocol fee
     */
    function updateProtocolFeeFraction(uint256 _protocolFee) external onlyOwner {
        _updateProtocolFeeFraction(_protocolFee);
    }

    function _updateProtocolFeeFraction(uint256 _protocolFee) internal {
        protocolFeeFraction = _protocolFee;
        emit ProtocolFeeFractionUpdated(_protocolFee);
    }

    /**
     * @notice used to update the protocol fee collector
     * @dev can only be updated by owner
     * @param _protocolFeeCollector address in which protocol fee is collected
     */
    function updateProtocolFeeCollector(address _protocolFeeCollector) external onlyOwner {
        _updateProtocolFeeCollector(_protocolFeeCollector);
    }

    function _updateProtocolFeeCollector(address _protocolFeeCollector) internal {
        require(_protocolFeeCollector != address(0), 'cant be 0 address');
        protocolFeeCollector = _protocolFeeCollector;
        emit ProtocolFeeCollectorUpdated(_protocolFeeCollector);
    }

    /**
     * @notice used to update the strategy registry address
     * @dev can only be updated by owner
     * @param _strategyRegistry address of the updated strategy registry
     */
    function updateStrategyRegistry(address _strategyRegistry) external onlyOwner {
        _updateStrategyRegistry(_strategyRegistry);
    }

    function _updateStrategyRegistry(address _strategyRegistry) internal {
        require(_strategyRegistry != address(0), 'CL::I zero address');
        strategyRegistry = _strategyRegistry;
        emit StrategyRegistryUpdated(_strategyRegistry);
    }

    /**
     * @notice used to update the liquidatorRewardFraction
     * @dev can only be updated by owner
     * @param _rewardFraction fraction of liquidated amount given to liquidator as reward
     */
    function updateLiquidatorRewardFraction(uint256 _rewardFraction) external onlyOwner {
        _updateLiquidatorRewardFraction(_rewardFraction);
    }

    function _updateLiquidatorRewardFraction(uint256 _rewardFraction) internal {
        require(_rewardFraction <= 10**30, 'Fraction has to be less than 1');
        liquidatorRewardFraction = _rewardFraction;
        emit LiquidationRewardFractionUpdated(_rewardFraction);
    }

    /**
     * @dev Used to Calculate Interest Per second on given principal and Interest rate
     * @param _principal principal Amount for which interest has to be calculated.
     * @param _borrowRate It is the Interest Rate at which Credit Line is approved
     * @return interest per second for the given parameters
     */
    function calculateInterest(
        uint256 _principal,
        uint256 _borrowRate,
        uint256 _timeElapsed
    ) public pure returns (uint256) {
        uint256 _interest = _principal.mul(_borrowRate).mul(_timeElapsed).div(10**30).div(YEAR_IN_SECONDS);

        return _interest;
    }

    /**
     * @dev Used to calculate interest accrued since last repayment
     * @param _id identifier for the credit line
     * @return interest accrued over current borrowed amount since last repayment
     */

    function calculateInterestAccrued(uint256 _id) public view returns (uint256) {
        uint256 _lastPrincipalUpdateTime = creditLineVariables[_id].lastPrincipalUpdateTime;
        if (_lastPrincipalUpdateTime == 0) return 0;
        uint256 _timeElapsed = (block.timestamp).sub(_lastPrincipalUpdateTime);
        uint256 _interestAccrued = calculateInterest(creditLineVariables[_id].principal, creditLineConstants[_id].borrowRate, _timeElapsed);
        return _interestAccrued;
    }

    /**
     * @dev Used to calculate current debt of borrower against a credit line.
     * @param _id identifier for the credit line
     * @return current debt of borrower
     */
    function calculateCurrentDebt(uint256 _id) public view returns (uint256) {
        uint256 _interestAccrued = calculateInterestAccrued(_id);
        uint256 _currentDebt = (creditLineVariables[_id].principal)
            .add(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate)
            .add(_interestAccrued)
            .sub(creditLineVariables[_id].totalInterestRepaid);
        return _currentDebt;
    }

    /**
     * @notice used to calculate amount that can be borrowed by the borrower
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view.
            borrowableAmount changes per block as interest changes per block.
     * @param _id identifier for the credit line
     * @return amount that can be borrowed from the credit line
     */
    function calculateBorrowableAmount(uint256 _id) public returns (uint256) {
        CreditLineStatus _status = creditLineVariables[_id].status;
        require(
            _status == CreditLineStatus.ACTIVE || _status == CreditLineStatus.REQUESTED,
            'CreditLine: Cannot only if credit line ACTIVE or REQUESTED'
        );
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(
            creditLineConstants[_id].collateralAsset,
            creditLineConstants[_id].borrowAsset
        );

        uint256 _totalCollateralToken = calculateTotalCollateralTokens(_id);

        uint256 _currentDebt = calculateCurrentDebt(_id);

        uint256 _maxPossible = _totalCollateralToken.mul(_ratioOfPrices).div(creditLineConstants[_id].idealCollateralRatio).mul(10**30).div(
            10**_decimals
        );

        uint256 _borrowLimit = creditLineConstants[_id].borrowLimit;

        if (_maxPossible > _borrowLimit) {
            _maxPossible = _borrowLimit;
        }
        if (_maxPossible > _currentDebt) {
            return _maxPossible.sub(_currentDebt);
        }
        return 0;
    }

    function updateinterestAccruedTillLastPrincipalUpdate(uint256 _id) internal {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');

        uint256 _interestAccrued = calculateInterestAccrued(_id);
        uint256 _newInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(_interestAccrued);
        creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _newInterestAccrued;
    }

    function _depositCollateralFromSavingsAccount(
        uint256 _id,
        uint256 _amount,
        address _sender
    ) internal {
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        uint256 _activeAmount;

        for (uint256 _index = 0; _index < _strategyList.length; _index++) {
            address _strategy = _strategyList[_index];
            uint256 _liquidityShares = _savingsAccount.balanceInShares(_sender, _collateralAsset, _strategy);
            if (_liquidityShares == 0 || _strategyList[_index] == address(0)) {
                continue;
            }
            uint256 _tokenInStrategy = _liquidityShares;
            _tokenInStrategy = IYield(_strategy).getTokensForShares(_liquidityShares, _collateralAsset);

            uint256 _tokensToTransfer = _tokenInStrategy;
            if (_activeAmount.add(_tokenInStrategy) >= _amount) {
                _tokensToTransfer = (_amount.sub(_activeAmount));
            }
            _activeAmount = _activeAmount.add(_tokensToTransfer);
            _savingsAccount.transferFrom(_tokensToTransfer, _collateralAsset, _strategy, _sender, address(this));

            collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(
                _liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy)
            );

            if (_amount == _activeAmount) {
                return;
            }
        }
        revert('CreditLine::_depositCollateralFromSavingsAccount - Insufficient balance');
    }

    /**
     * @notice used to request a credit line either by borrower or lender
     * @param _requestTo Address to which creditLine is requested, 
                        if borrower creates request then lender address and 
                        if lender creates then borrower address
     * @param _borrowLimit maximum borrow amount in a credit line
     * @param _borrowRate Interest Rate at which credit Line is requested
     * @param _autoLiquidation if true, anyone can liquidate loan, otherwise only lender
     * @param _collateralRatio ratio of the collateral to the debt below which credit line can be liquidated
     * @param _borrowAsset address of the token to be borrowed
     * @param _collateralAsset address of the token provided as collateral
     * @param _requestAsLender if true, lender is placing request, otherwise borrower
     * @return identifier for the credit line
     */

    function request(
        address _requestTo,
        uint256 _borrowLimit,
        uint256 _borrowRate,
        bool _autoLiquidation,
        uint256 _collateralRatio,
        address _borrowAsset,
        address _collateralAsset,
        bool _requestAsLender
    ) external returns (uint256) {
        require(_borrowAsset != _collateralAsset, 'R: cant borrow lent token');
        require(IPriceOracle(priceOracle).doesFeedExist(_borrowAsset, _collateralAsset), 'R: No price feed');

        address _lender = _requestTo;
        address _borrower = msg.sender;
        if (_requestAsLender) {
            _lender = msg.sender;
            _borrower = _requestTo;
        }

        uint256 _id = _createRequest(
            _lender,
            _borrower,
            _borrowLimit,
            _borrowRate,
            _autoLiquidation,
            _collateralRatio,
            _borrowAsset,
            _collateralAsset,
            _requestAsLender
        );

        emit CreditLineRequested(_id, _lender, _borrower);
        return _id;
    }

    function _createRequest(
        address _lender,
        address _borrower,
        uint256 _borrowLimit,
        uint256 _borrowRate,
        bool _autoLiquidation,
        uint256 _collateralRatio,
        address _borrowAsset,
        address _collateralAsset,
        bool _requestByLender
    ) internal returns (uint256) {
        require(_lender != _borrower, 'Lender and Borrower cannot be same addresses');
        uint256 _id = creditLineCounter + 1;
        creditLineCounter = _id;
        creditLineVariables[_id].status = CreditLineStatus.REQUESTED;
        creditLineConstants[_id].borrower = _borrower;
        creditLineConstants[_id].lender = _lender;
        creditLineConstants[_id].borrowLimit = _borrowLimit;
        creditLineConstants[_id].autoLiquidation = _autoLiquidation;
        creditLineConstants[_id].idealCollateralRatio = _collateralRatio;
        creditLineConstants[_id].borrowRate = _borrowRate;
        creditLineConstants[_id].borrowAsset = _borrowAsset;
        creditLineConstants[_id].collateralAsset = _collateralAsset;
        creditLineConstants[_id].requestByLender = _requestByLender;
        return _id;
    }

    /**
     * @notice used to accept a credit line
     * @dev if borrower places request, lender can accept and vice versa
     * @param _id identifier for the credit line
     */
    function accept(uint256 _id) external {
        require(
            creditLineVariables[_id].status == CreditLineStatus.REQUESTED,
            'CreditLine::acceptCreditLineLender - CreditLine is already accepted'
        );
        bool _requestByLender = creditLineConstants[_id].requestByLender;
        require(
            (msg.sender == creditLineConstants[_id].borrower && _requestByLender) ||
                (msg.sender == creditLineConstants[_id].lender && !_requestByLender),
            "Only Borrower or Lender who hasn't requested can accept"
        );
        creditLineVariables[_id].status = CreditLineStatus.ACTIVE;
        emit CreditLineAccepted(_id);
    }

    /**
     * @notice used to deposit collateral into the credit line
     * @dev collateral tokens have to be approved in savingsAccount or token contract(unless ether).
            If transferred from savings account, the tokens are transferred from strategies in the 
            order prespecified in strategy registry
     * @param _id identifier for the credit line
     * @param _amount amount of collateral being deposited
     * @param _strategy strategy to which collateral is to be deposited in case transfer is not from savings account
     * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount 
                                otherwise direct from collateral token contract
     */
    function depositCollateral(
        uint256 _id,
        uint256 _amount,
        address _strategy,
        bool _fromSavingsAccount
    ) external payable nonReentrant ifCreditLineExists(_id) {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine not active');
        _depositCollateral(_id, _amount, _strategy, _fromSavingsAccount);
        emit CollateralDeposited(_id, _amount, _strategy);
    }

    function _depositCollateral(
        uint256 _id,
        uint256 _amount,
        address _strategy,
        bool _fromSavingsAccount
    ) internal {
        require(creditLineConstants[_id].lender != msg.sender, 'lender cant deposit collateral');
        if (_fromSavingsAccount) {
            _depositCollateralFromSavingsAccount(_id, _amount, msg.sender);
        } else {
            address _collateralAsset = creditLineConstants[_id].collateralAsset;
            ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
            if (_collateralAsset == address(0)) {
                require(msg.value == _amount, "CreditLine::_depositCollateral - value to transfer doesn't match argument");
            } else {
                IERC20(_collateralAsset).safeTransferFrom(msg.sender, address(this), _amount);
                IERC20(_collateralAsset).approve(_strategy, _amount);
            }
            uint256 _sharesReceived = _savingsAccount.deposit{value: msg.value}(_amount, _collateralAsset, _strategy, address(this));
            collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(_sharesReceived);
        }
    }

    function _withdrawBorrowAmount(
        address _asset,
        uint256 _amountInTokens,
        address _lender
    ) internal {
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        uint256 _activeAmount;
        for (uint256 _index = 0; _index < _strategyList.length; _index++) {
            if (_strategyList[_index] == address(0)) {
                continue;
            }
            uint256 _liquidityShares = _savingsAccount.balanceInShares(_lender, _asset, _strategyList[_index]);
            if (_liquidityShares != 0) {
                uint256 tokenInStrategy = _liquidityShares;
                tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);
                uint256 _tokensToTransfer = tokenInStrategy;
                if (_activeAmount.add(tokenInStrategy) >= _amountInTokens) {
                    _tokensToTransfer = (_amountInTokens.sub(_activeAmount));
                }
                _activeAmount = _activeAmount.add(_tokensToTransfer);
                _savingsAccount.withdrawFrom(_tokensToTransfer, _asset, _strategyList[_index], _lender, address(this), false);
                if (_activeAmount == _amountInTokens) {
                    return;
                }
            }
        }
        require(_activeAmount == _amountInTokens, 'insufficient balance');
    }

    /**
     * @notice used to borrow tokens from credit line by borrower
     * @dev only borrower can call this function. Amount that can actually be borrowed is 
            min(amount based on borrowLimit, allowance to creditLine contract, balance of lender)
     * @param _id identifier for the credit line
     * @param _amount amount of tokens to borrow
     */
    function borrow(uint256 _id, uint256 _amount) external payable nonReentrant onlyCreditLineBorrower(_id) {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');
        uint256 _borrowableAmount = calculateBorrowableAmount(_id);
        require(_amount <= _borrowableAmount, "CreditLine::borrow - The current collateral ratio doesn't allow to withdraw the amount");
        address _borrowAsset = creditLineConstants[_id].borrowAsset;
        address _lender = creditLineConstants[_id].lender;

        updateinterestAccruedTillLastPrincipalUpdate(_id);
        creditLineVariables[_id].principal = creditLineVariables[_id].principal.add(_amount);
        creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;

        uint256 _tokenDiffBalance;
        if (_borrowAsset != address(0)) {
            uint256 _balanceBefore = IERC20(_borrowAsset).balanceOf(address(this));
            _withdrawBorrowAmount(_borrowAsset, _amount, _lender);
            uint256 _balanceAfter = IERC20(_borrowAsset).balanceOf(address(this));
            _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);
        } else {
            uint256 _balanceBefore = address(this).balance;
            _withdrawBorrowAmount(_borrowAsset, _amount, _lender);
            uint256 _balanceAfter = address(this).balance;
            _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);
        }
        uint256 _protocolFee = _tokenDiffBalance.mul(protocolFeeFraction).div(10**30);
        _tokenDiffBalance = _tokenDiffBalance.sub(_protocolFee);

        if (_borrowAsset == address(0)) {
            (bool feeSuccess, ) = protocolFeeCollector.call{value: _protocolFee}('');
            require(feeSuccess, 'Transfer fail');
            (bool success, ) = msg.sender.call{value: _tokenDiffBalance}('');
            require(success, 'Transfer fail');
        } else {
            IERC20(_borrowAsset).safeTransfer(protocolFeeCollector, _protocolFee);
            IERC20(_borrowAsset).safeTransfer(msg.sender, _tokenDiffBalance);
        }
        emit BorrowedFromCreditLine(_id, _tokenDiffBalance);
    }

    function _repayFromSavingsAccount(
        uint256 _amount,
        address _asset,
        address _lender
    ) internal {
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        uint256 _activeAmount;

        for (uint256 _index = 0; _index < _strategyList.length; _index++) {
            if (_strategyList[_index] == address(0)) {
                continue;
            }
            uint256 _liquidityShares = _savingsAccount.balanceInShares(msg.sender, _asset, _strategyList[_index]);
            if (_liquidityShares == 0) {
                continue;
            }
            uint256 _tokenInStrategy = _liquidityShares;
            _tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);

            uint256 _tokensToTransfer = _tokenInStrategy;
            if (_activeAmount.add(_tokenInStrategy) >= _amount) {
                _tokensToTransfer = (_amount.sub(_activeAmount));
            }
            _activeAmount = _activeAmount.add(_tokensToTransfer);
            _savingsAccount.transferFrom(_tokensToTransfer, _asset, _strategyList[_index], msg.sender, _lender);

            if (_amount == _activeAmount) {
                return;
            }
        }
        revert('CreditLine::_repayFromSavingsAccount - Insufficient balance');
    }

    function _repay(
        uint256 _id,
        uint256 _amount,
        bool _fromSavingsAccount,
        uint256 _principalPaid
    ) internal {
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        address _defaultStrategy = defaultStrategy;
        address _borrowAsset = creditLineConstants[_id].borrowAsset;
        address _lender = creditLineConstants[_id].lender;
        if (!_fromSavingsAccount) {
            if (_borrowAsset == address(0)) {
                require(msg.value == _amount, 'creditLine::repay - Ether sent not equal to repay amount');
                _savingsAccount.deposit{value: _amount}(_amount, _borrowAsset, _defaultStrategy, _lender);
            } else {
                IERC20(_borrowAsset).safeTransferFrom(msg.sender, address(this), _amount);
                IERC20(_borrowAsset).approve(_defaultStrategy, _amount);
                _savingsAccount.deposit(_amount, _borrowAsset, _defaultStrategy, _lender);
            }
        } else {
            _repayFromSavingsAccount(_amount, _borrowAsset, _lender);
        }
        if (_principalPaid != 0) {
            _savingsAccount.increaseAllowanceToCreditLine(_principalPaid, _borrowAsset, _lender);
        }
    }

    /**
     * @notice used to repay interest and principal to credit line. Interest has to be repaid before repaying principal
     * @dev partial repayments possible
     * @param _id identifier for the credit line
     * @param _amount amount being repaid
     * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount 
                                otherwise direct from collateral token contract
     */
    function repay(
        uint256 _id,
        uint256 _amount,
        bool _fromSavingsAccount
    ) external payable nonReentrant {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');
        require(creditLineConstants[_id].lender != msg.sender, 'Lender cant repay');

        uint256 _interestSincePrincipalUpdate = calculateInterestAccrued(_id);
        uint256 _totalInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(
            _interestSincePrincipalUpdate
        );
        uint256 _interestToPay = _totalInterestAccrued.sub(creditLineVariables[_id].totalInterestRepaid);
        uint256 _totalCurrentDebt = _interestToPay.add(creditLineVariables[_id].principal);
        uint256 _principalPaid = 0;

        if (_amount >= _totalCurrentDebt) {
            _amount = _totalCurrentDebt;
            emit CompleteCreditLineRepaid(_id, _amount);
        } else {
            emit PartialCreditLineRepaid(_id, _amount);
        }

        if (_amount > _interestToPay) {
            creditLineVariables[_id].principal = _totalCurrentDebt.sub(_amount);
            creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _totalInterestAccrued;
            creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;
            creditLineVariables[_id].totalInterestRepaid = _totalInterestAccrued;
            _principalPaid = _amount.sub(_interestToPay);
        } else {
            creditLineVariables[_id].totalInterestRepaid = creditLineVariables[_id].totalInterestRepaid.add(_amount);
        }

        _repay(_id, _amount, _fromSavingsAccount, _principalPaid);

        if (creditLineVariables[_id].principal == 0) {
            _resetCreditLine(_id);
        }
    }

    function _resetCreditLine(uint256 _id) internal {
        creditLineVariables[_id].lastPrincipalUpdateTime = 0;
        creditLineVariables[_id].totalInterestRepaid = 0;
        creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = 0;
        emit CreditLineReset(_id);
    }

    /**
     * @dev used to close credit line by borrower or lender
     * @param _id identifier for the credit line
     */
    function close(uint256 _id) external ifCreditLineExists(_id) {
        require(
            msg.sender == creditLineConstants[_id].borrower || msg.sender == creditLineConstants[_id].lender,
            'CreditLine: Permission denied while closing Line of credit'
        );
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: Credit line should be active.');
        require(creditLineVariables[_id].principal == 0, 'CreditLine: Cannot be closed since not repaid.');
        require(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate == 0, 'CreditLine: Cannot be closed since not repaid.');
        creditLineVariables[_id].status = CreditLineStatus.CLOSED;
        emit CreditLineClosed(_id);
    }

    /**
     * @notice used to calculate the current collateral ratio
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view.
            Interest is also considered while calculating debt
     * @param _id identifier for the credit line
     * @return collateral ratio multiplied by 10**30 to retain precision
     */
    function calculateCurrentCollateralRatio(uint256 _id) public ifCreditLineExists(_id) returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(
            creditLineConstants[_id].collateralAsset,
            creditLineConstants[_id].borrowAsset
        );

        uint256 currentDebt = calculateCurrentDebt(_id);
        uint256 currentCollateralRatio = calculateTotalCollateralTokens(_id).mul(_ratioOfPrices).div(currentDebt).mul(10**30).div(
            10**_decimals
        );

        return currentCollateralRatio;
    }

    /**
     * @notice used to calculate the total collateral tokens
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @param _id identifier for the credit line
     * @return _amount total collateral tokens deposited into the credit line
     */
    function calculateTotalCollateralTokens(uint256 _id) public returns (uint256 _amount) {
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        uint256 _liquidityShares;
        for (uint256 index = 0; index < _strategyList.length; index++) {
            if (_strategyList[index] == address(0)) {
                continue;
            }
            _liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];
            uint256 _tokenInStrategy = _liquidityShares;
            _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(_liquidityShares, _collateralAsset);

            _amount = _amount.add(_tokenInStrategy);
        }
    }

    /**
     * @notice used to withdraw any excess collateral
     * @dev collateral can't be withdraw if collateralRatio goes below the ideal value. Only borrower can withdraw
     * @param _id identifier for the credit line
     * @param _amount amount of collateral to withdraw
     * @param _toSavingsAccount if true, tokens are transferred from savingsAccount 
                                otherwise direct from collateral token contract
     */
    function withdrawCollateral(
        uint256 _id,
        uint256 _amount,
        bool _toSavingsAccount
    ) external nonReentrant onlyCreditLineBorrower(_id) {
        uint256 _withdrawableCollateral = withdrawableCollateral(_id);
        require(_amount <= _withdrawableCollateral, 'Collateral ratio cant go below ideal');
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        _transferCollateral(_id, _collateralAsset, _amount, _toSavingsAccount);
        emit CollateralWithdrawn(_id, _amount);
    }

    /**
     * @notice used to calculate the collateral that can be withdrawn
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @param _id identifier for the credit line
     * @return total collateral withdrawable by borrower
     */
    function withdrawableCollateral(uint256 _id) public returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(
            creditLineConstants[_id].collateralAsset,
            creditLineConstants[_id].borrowAsset
        );

        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);
        uint256 _currentDebt = calculateCurrentDebt(_id);

        uint256 _collateralNeeded = _currentDebt
            .mul(creditLineConstants[_id].idealCollateralRatio)
            .div(_ratioOfPrices)
            .mul(10**_decimals)
            .div(10**30);

        if (_collateralNeeded >= _totalCollateralTokens) {
            return 0;
        }
        return _totalCollateralTokens.sub(_collateralNeeded);
    }

    function _transferCollateral(
        uint256 _id,
        address _asset,
        uint256 _amountInTokens,
        bool _toSavingsAccount
    ) internal {
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        uint256 _activeAmount;
        for (uint256 index = 0; index < _strategyList.length; index++) {
            uint256 liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];
            if (liquidityShares == 0 || _strategyList[index] == address(0)) {
                continue;
            }
            uint256 _tokenInStrategy = liquidityShares;
            _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(liquidityShares, _asset);
            uint256 _tokensToTransfer = _tokenInStrategy;
            if (_activeAmount.add(_tokenInStrategy) > _amountInTokens) {
                _tokensToTransfer = _amountInTokens.sub(_activeAmount);
                liquidityShares = liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy);
            }
            _activeAmount = _activeAmount.add(_tokensToTransfer);
            collateralShareInStrategy[_id][_strategyList[index]] = collateralShareInStrategy[_id][_strategyList[index]].sub(
                liquidityShares
            );
            if (_toSavingsAccount) {
                ISavingsAccount(savingsAccount).transfer(_tokensToTransfer, _asset, _strategyList[index], msg.sender);
            } else {
                ISavingsAccount(savingsAccount).withdraw(_tokensToTransfer, _asset, _strategyList[index], msg.sender, false);
            }

            if (_activeAmount == _amountInTokens) {
                return;
            }
        }
        revert('insufficient collateral');
    }

    /**
     * @notice used to liquidate credit line in case collateral ratio goes below the threshold
     * @dev if lender liquidates, then collateral is directly transferred. 
            If autoLiquidation is true, anyone can liquidate by providing enough borrow tokens
     * @param _id identifier for the credit line
     * @param _toSavingsAccount if true, tokens are transferred from savingsAccount 
                                otherwise direct from collateral token contract
     */
    function liquidate(uint256 _id, bool _toSavingsAccount) external payable nonReentrant {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: Credit line should be active.');
        require(creditLineVariables[_id].principal != 0, 'CreditLine: cannot liquidate if principal is 0');

        uint256 currentCollateralRatio = calculateCurrentCollateralRatio(_id);
        require(
            currentCollateralRatio < creditLineConstants[_id].idealCollateralRatio,
            'CreditLine: Collateral ratio is higher than ideal value'
        );

        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        address _lender = creditLineConstants[_id].lender;
        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);
        address _borrowAsset = creditLineConstants[_id].borrowAsset;

        creditLineVariables[_id].status = CreditLineStatus.LIQUIDATED;

        if (creditLineConstants[_id].autoLiquidation && _lender != msg.sender) {
            uint256 _borrowTokens = _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens);
            if (_borrowAsset == address(0)) {
                uint256 _returnETH = msg.value.sub(_borrowTokens, 'Insufficient ETH to liquidate');
                if (_returnETH != 0) {
                    (bool success, ) = msg.sender.call{value: _returnETH}('');
                    require(success, 'Transfer fail');
                }
            } else {
                IERC20(_borrowAsset).safeTransferFrom(msg.sender, _lender, _borrowTokens);
            }
        }

        _transferCollateral(_id, _collateralAsset, _totalCollateralTokens, _toSavingsAccount);

        emit CreditLineLiquidated(_id, msg.sender);
    }

    /**
     * @notice used to calculate the borrow tokens necessary for liquidator to liquidate
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @param _id identifier for the credit line
     * @return borrow tokens necessary for liquidator to liquidate
     */
    function borrowTokensToLiquidate(uint256 _id) external returns (uint256) {
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);
        address _borrowAsset = creditLineConstants[_id].borrowAsset;

        return _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens);
    }

    function _borrowTokensToLiquidate(
        address _borrowAsset,
        address _collateralAsset,
        uint256 _totalCollateralTokens
    ) internal view returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(_borrowAsset, _collateralAsset);
        uint256 _borrowTokens = (
            _totalCollateralTokens.mul(uint256(10**30).sub(liquidatorRewardFraction)).div(10**30).mul(_ratioOfPrices).div(10**_decimals)
        );

        return _borrowTokens;
    }

    receive() external payable {
        require(msg.sender == savingsAccount, 'CreditLine::receive invalid transaction');
    }
}
".
Ideas: " Security".
As the Security Analyst, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability.
For each vulnerability identified, use the following format:
VULNERABILITY NAME or TYPE
```
DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix.
```
Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: "<INFO> Analysis Complete."

[2024-22-08 11:43:42 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-22-08 11:43:42 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 20047
completion_tokens: 1
total_tokens: 20048
cost: $-1.000000


[2024-22-08 11:43:42 INFO] Security Analyst: **Security Analyst<->Solidity Programming Expert on : ContractReviewComment, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/utils/ReentrancyGuard.sol';
import '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';
import '../interfaces/IPriceOracle.sol';
import '../interfaces/IYield.sol';
import '../interfaces/ISavingsAccount.sol';
import '../SavingsAccount/SavingsAccountUtil.sol';
import '../interfaces/IStrategyRegistry.sol';

/**
 * @title Credit Line contract with Methods related to credit Line
 * @notice Implements the functions related to Credit Line
 * @author Sublime
 **/

contract CreditLine is ReentrancyGuard, OwnableUpgradeable {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    enum CreditLineStatus {
        NOT_CREATED,
        REQUESTED,
        ACTIVE,
        CLOSED,
        CANCELLED,
        LIQUIDATED
    }

    /**
     * @notice counter that tracks the number of credit lines created
     * @dev used to create unique identifier for credit lines
     **/
    uint256 public creditLineCounter;

    uint256 constant YEAR_IN_SECONDS = 365 days;

    struct CreditLineVariables {
        CreditLineStatus status;
        uint256 principal;
        uint256 totalInterestRepaid;
        uint256 lastPrincipalUpdateTime;
        uint256 interestAccruedTillLastPrincipalUpdate;
    }

    struct CreditLineConstants {
        address lender;
        address borrower;
        uint256 borrowLimit;
        uint256 idealCollateralRatio;
        uint256 borrowRate;
        address borrowAsset;
        address collateralAsset;
        bool autoLiquidation;
        bool requestByLender;
    }
    /**
     * @notice stores the collateral shares in a credit line per strategy
     * @dev creditLineId => Strategy => collateralShares
     **/
    mapping(uint256 => mapping(address => uint256)) public collateralShareInStrategy;

    /**
     * @notice stores the variables to maintain a credit line
     **/
    mapping(uint256 => CreditLineVariables) public creditLineVariables;

    /**
     * @notice stores the constants related to a credit line
     **/
    mapping(uint256 => CreditLineConstants) public creditLineConstants;

    /**
     * @notice stores the address of savings account contract
     **/
    address public savingsAccount;

    /**
     * @notice stores the address of price oracle contract
     **/
    address public priceOracle;

    /**
     * @notice stores the address of strategy registry contract
     **/
    address public strategyRegistry;

    /**
     * @notice stores the address of default strategy
     **/
    address public defaultStrategy;

    /**
     * @notice stores the fraction of borrowed amount charged as fee by protocol
     * @dev it is multiplied by 10**30
     **/
    uint256 public protocolFeeFraction;

    /**
     * @notice address where protocol fee is collected
     **/
    address public protocolFeeCollector;

    /**
     * @notice stores the fraction of amount liquidated given as reward to liquidator
     * @dev it is multiplied by 10**30
     **/
    uint256 public liquidatorRewardFraction;
    /**
     * @dev checks if Credit Line exists
     * @param _id identifier for the credit line
     **/
    modifier ifCreditLineExists(uint256 _id) {
        require(creditLineVariables[_id].status != CreditLineStatus.NOT_CREATED, 'Credit line does not exist');
        _;
    }

    /**
     * @dev checks if called by credit Line Borrower
     * @param _id creditLine identifier
     **/
    modifier onlyCreditLineBorrower(uint256 _id) {
        require(creditLineConstants[_id].borrower == msg.sender, 'Only credit line Borrower can access');
        _;
    }

    /**
     * @dev checks if called by credit Line Lender
     * @param _id creditLine identifier
     **/
    modifier onlyCreditLineLender(uint256 _id) {
        require(creditLineConstants[_id].lender == msg.sender, 'Only credit line Lender can access');
        _;
    }

    /**
     * @notice emitted when a collateral is deposited into credit line
     * @param id id of the credit line
     * @param amount amount of collateral deposited
     * @param strategy address of the strategy into which collateral is deposited
     */
    event CollateralDeposited(uint256 indexed id, uint256 amount, address indexed strategy);

    /**
     * @notice emitted when collateral is withdrawn from credit line
     * @param id id of the credit line
     * @param amount amount of collateral withdrawn
     */
    event CollateralWithdrawn(uint256 indexed id, uint256 amount);

    /**
     * @notice emitted when a request for new credit line is placed
     * @param id id of the credit line for which request was made
     * @param lender address of the lender for credit line
     * @param borrower address of the borrower for credit line
     */
    event CreditLineRequested(uint256 indexed id, address indexed lender, address indexed borrower);

    /**
     * @notice emitted when a credit line is liquidated
     * @param id id of the credit line which is liquidated
     * @param liquidator address of the liquidator
     */
    event CreditLineLiquidated(uint256 indexed id, address indexed liquidator);

    /**
     * @notice emitted when tokens are borrowed from credit line
     * @param id id of the credit line from which tokens are borrowed
     * @param borrowAmount amount of tokens borrowed
     */
    event BorrowedFromCreditLine(uint256 indexed id, uint256 borrowAmount);

    /**
     * @notice emitted when credit line is accepted
     * @param id id of the credit line that was accepted
     */
    event CreditLineAccepted(uint256 indexed id);

    /**
     * @notice emitted when credit line is completely repaid and reset
     * @param id id of the credit line that is reset
     */
    event CreditLineReset(uint256 indexed id);

    /**
     * @notice emitted when the credit line is partially repaid
     * @param id id of the credit line
     * @param repayAmount amount repaid
     */
    event PartialCreditLineRepaid(uint256 indexed id, uint256 repayAmount);

    /**
     * @notice emitted when the credit line is completely repaid
     * @param id id of the credit line
     * @param repayAmount amount repaid
     */
    event CompleteCreditLineRepaid(uint256 indexed id, uint256 repayAmount);

    /**
     * @notice emitted when the credit line is closed by one of the parties of credit line
     * @param id id of the credit line
     */
    event CreditLineClosed(uint256 indexed id);

    /**
     * @notice emitted when default strategy for the credit line is updated
     * @param defaultStrategy address of the strategy contract that is used as default by credit lines
     */
    event DefaultStrategyUpdated(address indexed defaultStrategy);

    /**
     * @notice emitted when the price oracle is updated
     * @param priceOracle address of the updated price oracle
     */
    event PriceOracleUpdated(address indexed priceOracle);

    /**
     * @notice emitted when the savings account address is updated
     * @param savingsAccount address of the updated savingsAccount
     */
    event SavingsAccountUpdated(address indexed savingsAccount);

    /**
     * @notice emitted when strategy registry address is updated
     * @param strategyRegistry address of the updated strategy registry
     */
    event StrategyRegistryUpdated(address indexed strategyRegistry);

    /**
     * @notice emitted when fee that protocol charges for credit line is updated
     * @param updatedProtocolFee updated value of protocolFeeFraction
     */
    event ProtocolFeeFractionUpdated(uint256 updatedProtocolFee);

    /**
     * @notice emitted when address which receives fee that protocol changes for pools is updated
     * @param updatedProtocolFeeCollector updated value of protocolFeeCollector
     */
    event ProtocolFeeCollectorUpdated(address indexed updatedProtocolFeeCollector);

    /**
     * @notice emitted when liquidatorRewardFraction is updated
     * @param liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator
     */
    event LiquidationRewardFractionUpdated(uint256 liquidatorRewardFraction);

    /**
     * @notice used to initialize the contract
     * @dev can only be called once during the life cycle of the contract
     * @param _defaultStrategy default strategy used in credit lines
     * @param _priceOracle address of the priceOracle
     * @param _savingsAccount address of  the savings account contract
     * @param _strategyRegistry address of the strategy registry contract
     * @param _owner address of owner who can change global variables
     * @param _protocolFeeFraction fraction of the fee charged by protocol
     * @param _protocolFeeCollector address to which protocol fee is charged to
     * @param _liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator
     */
    function initialize(
        address _defaultStrategy,
        address _priceOracle,
        address _savingsAccount,
        address _strategyRegistry,
        address _owner,
        uint256 _protocolFeeFraction,
        address _protocolFeeCollector,
        uint256 _liquidatorRewardFraction
    ) external initializer {
        OwnableUpgradeable.__Ownable_init();
        OwnableUpgradeable.transferOwnership(_owner);

        _updateDefaultStrategy(_defaultStrategy);
        _updatePriceOracle(_priceOracle);
        _updateSavingsAccount(_savingsAccount);
        _updateStrategyRegistry(_strategyRegistry);
        _updateProtocolFeeFraction(_protocolFeeFraction);
        _updateProtocolFeeCollector(_protocolFeeCollector);
        _updateLiquidatorRewardFraction(_liquidatorRewardFraction);
    }

    /**
     * @notice used to update the default strategy
     * @dev can only be updated by owner
     * @param _defaultStrategy address of the updated default strategy
     */
    function updateDefaultStrategy(address _defaultStrategy) external onlyOwner {
        _updateDefaultStrategy(_defaultStrategy);
    }

    function _updateDefaultStrategy(address _defaultStrategy) internal {
        defaultStrategy = _defaultStrategy;
        emit DefaultStrategyUpdated(_defaultStrategy);
    }

    /**
     * @notice used to update the price oracle
     * @dev can only be updated by owner
     * @param _priceOracle address of the updated price oracle
     */
    function updatePriceOracle(address _priceOracle) external onlyOwner {
        _updatePriceOracle(_priceOracle);
    }

    function _updatePriceOracle(address _priceOracle) internal {
        priceOracle = _priceOracle;
        emit PriceOracleUpdated(_priceOracle);
    }

    /**
     * @notice used to update the savings account address
     * @dev can only be updated by owner
     * @param _savingsAccount address of the updated savings account
     */
    function updateSavingsAccount(address _savingsAccount) external onlyOwner {
        _updateSavingsAccount(_savingsAccount);
    }

    function _updateSavingsAccount(address _savingsAccount) internal {
        savingsAccount = _savingsAccount;
        emit SavingsAccountUpdated(_savingsAccount);
    }

    /**
     * @notice used to update the protocol fee fraction
     * @dev can only be updated by owner
     * @param _protocolFee fraction of the borrower amount collected as protocol fee
     */
    function updateProtocolFeeFraction(uint256 _protocolFee) external onlyOwner {
        _updateProtocolFeeFraction(_protocolFee);
    }

    function _updateProtocolFeeFraction(uint256 _protocolFee) internal {
        protocolFeeFraction = _protocolFee;
        emit ProtocolFeeFractionUpdated(_protocolFee);
    }

    /**
     * @notice used to update the protocol fee collector
     * @dev can only be updated by owner
     * @param _protocolFeeCollector address in which protocol fee is collected
     */
    function updateProtocolFeeCollector(address _protocolFeeCollector) external onlyOwner {
        _updateProtocolFeeCollector(_protocolFeeCollector);
    }

    function _updateProtocolFeeCollector(address _protocolFeeCollector) internal {
        require(_protocolFeeCollector != address(0), 'cant be 0 address');
        protocolFeeCollector = _protocolFeeCollector;
        emit ProtocolFeeCollectorUpdated(_protocolFeeCollector);
    }

    /**
     * @notice used to update the strategy registry address
     * @dev can only be updated by owner
     * @param _strategyRegistry address of the updated strategy registry
     */
    function updateStrategyRegistry(address _strategyRegistry) external onlyOwner {
        _updateStrategyRegistry(_strategyRegistry);
    }

    function _updateStrategyRegistry(address _strategyRegistry) internal {
        require(_strategyRegistry != address(0), 'CL::I zero address');
        strategyRegistry = _strategyRegistry;
        emit StrategyRegistryUpdated(_strategyRegistry);
    }

    /**
     * @notice used to update the liquidatorRewardFraction
     * @dev can only be updated by owner
     * @param _rewardFraction fraction of liquidated amount given to liquidator as reward
     */
    function updateLiquidatorRewardFraction(uint256 _rewardFraction) external onlyOwner {
        _updateLiquidatorRewardFraction(_rewardFraction);
    }

    function _updateLiquidatorRewardFraction(uint256 _rewardFraction) internal {
        require(_rewardFraction <= 10**30, 'Fraction has to be less than 1');
        liquidatorRewardFraction = _rewardFraction;
        emit LiquidationRewardFractionUpdated(_rewardFraction);
    }

    /**
     * @dev Used to Calculate Interest Per second on given principal and Interest rate
     * @param _principal principal Amount for which interest has to be calculated.
     * @param _borrowRate It is the Interest Rate at which Credit Line is approved
     * @return interest per second for the given parameters
     */
    function calculateInterest(
        uint256 _principal,
        uint256 _borrowRate,
        uint256 _timeElapsed
    ) public pure returns (uint256) {
        uint256 _interest = _principal.mul(_borrowRate).mul(_timeElapsed).div(10**30).div(YEAR_IN_SECONDS);

        return _interest;
    }

    /**
     * @dev Used to calculate interest accrued since last repayment
     * @param _id identifier for the credit line
     * @return interest accrued over current borrowed amount since last repayment
     */

    function calculateInterestAccrued(uint256 _id) public view returns (uint256) {
        uint256 _lastPrincipalUpdateTime = creditLineVariables[_id].lastPrincipalUpdateTime;
        if (_lastPrincipalUpdateTime == 0) return 0;
        uint256 _timeElapsed = (block.timestamp).sub(_lastPrincipalUpdateTime);
        uint256 _interestAccrued = calculateInterest(creditLineVariables[_id].principal, creditLineConstants[_id].borrowRate, _timeElapsed);
        return _interestAccrued;
    }

    /**
     * @dev Used to calculate current debt of borrower against a credit line.
     * @param _id identifier for the credit line
     * @return current debt of borrower
     */
    function calculateCurrentDebt(uint256 _id) public view returns (uint256) {
        uint256 _interestAccrued = calculateInterestAccrued(_id);
        uint256 _currentDebt = (creditLineVariables[_id].principal)
            .add(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate)
            .add(_interestAccrued)
            .sub(creditLineVariables[_id].totalInterestRepaid);
        return _currentDebt;
    }

    /**
     * @notice used to calculate amount that can be borrowed by the borrower
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view.
            borrowableAmount changes per block as interest changes per block.
     * @param _id identifier for the credit line
     * @return amount that can be borrowed from the credit line
     */
    function calculateBorrowableAmount(uint256 _id) public returns (uint256) {
        CreditLineStatus _status = creditLineVariables[_id].status;
        require(
            _status == CreditLineStatus.ACTIVE || _status == CreditLineStatus.REQUESTED,
            'CreditLine: Cannot only if credit line ACTIVE or REQUESTED'
        );
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(
            creditLineConstants[_id].collateralAsset,
            creditLineConstants[_id].borrowAsset
        );

        uint256 _totalCollateralToken = calculateTotalCollateralTokens(_id);

        uint256 _currentDebt = calculateCurrentDebt(_id);

        uint256 _maxPossible = _totalCollateralToken.mul(_ratioOfPrices).div(creditLineConstants[_id].idealCollateralRatio).mul(10**30).div(
            10**_decimals
        );

        uint256 _borrowLimit = creditLineConstants[_id].borrowLimit;

        if (_maxPossible > _borrowLimit) {
            _maxPossible = _borrowLimit;
        }
        if (_maxPossible > _currentDebt) {
            return _maxPossible.sub(_currentDebt);
        }
        return 0;
    }

    function updateinterestAccruedTillLastPrincipalUpdate(uint256 _id) internal {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');

        uint256 _interestAccrued = calculateInterestAccrued(_id);
        uint256 _newInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(_interestAccrued);
        creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _newInterestAccrued;
    }

    function _depositCollateralFromSavingsAccount(
        uint256 _id,
        uint256 _amount,
        address _sender
    ) internal {
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        uint256 _activeAmount;

        for (uint256 _index = 0; _index < _strategyList.length; _index++) {
            address _strategy = _strategyList[_index];
            uint256 _liquidityShares = _savingsAccount.balanceInShares(_sender, _collateralAsset, _strategy);
            if (_liquidityShares == 0 || _strategyList[_index] == address(0)) {
                continue;
            }
            uint256 _tokenInStrategy = _liquidityShares;
            _tokenInStrategy = IYield(_strategy).getTokensForShares(_liquidityShares, _collateralAsset);

            uint256 _tokensToTransfer = _tokenInStrategy;
            if (_activeAmount.add(_tokenInStrategy) >= _amount) {
                _tokensToTransfer = (_amount.sub(_activeAmount));
            }
            _activeAmount = _activeAmount.add(_tokensToTransfer);
            _savingsAccount.transferFrom(_tokensToTransfer, _collateralAsset, _strategy, _sender, address(this));

            collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(
                _liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy)
            );

            if (_amount == _activeAmount) {
                return;
            }
        }
        revert('CreditLine::_depositCollateralFromSavingsAccount - Insufficient balance');
    }

    /**
     * @notice used to request a credit line either by borrower or lender
     * @param _requestTo Address to which creditLine is requested, 
                        if borrower creates request then lender address and 
                        if lender creates then borrower address
     * @param _borrowLimit maximum borrow amount in a credit line
     * @param _borrowRate Interest Rate at which credit Line is requested
     * @param _autoLiquidation if true, anyone can liquidate loan, otherwise only lender
     * @param _collateralRatio ratio of the collateral to the debt below which credit line can be liquidated
     * @param _borrowAsset address of the token to be borrowed
     * @param _collateralAsset address of the token provided as collateral
     * @param _requestAsLender if true, lender is placing request, otherwise borrower
     * @return identifier for the credit line
     */

    function request(
        address _requestTo,
        uint256 _borrowLimit,
        uint256 _borrowRate,
        bool _autoLiquidation,
        uint256 _collateralRatio,
        address _borrowAsset,
        address _collateralAsset,
        bool _requestAsLender
    ) external returns (uint256) {
        require(_borrowAsset != _collateralAsset, 'R: cant borrow lent token');
        require(IPriceOracle(priceOracle).doesFeedExist(_borrowAsset, _collateralAsset), 'R: No price feed');

        address _lender = _requestTo;
        address _borrower = msg.sender;
        if (_requestAsLender) {
            _lender = msg.sender;
            _borrower = _requestTo;
        }

        uint256 _id = _createRequest(
            _lender,
            _borrower,
            _borrowLimit,
            _borrowRate,
            _autoLiquidation,
            _collateralRatio,
            _borrowAsset,
            _collateralAsset,
            _requestAsLender
        );

        emit CreditLineRequested(_id, _lender, _borrower);
        return _id;
    }

    function _createRequest(
        address _lender,
        address _borrower,
        uint256 _borrowLimit,
        uint256 _borrowRate,
        bool _autoLiquidation,
        uint256 _collateralRatio,
        address _borrowAsset,
        address _collateralAsset,
        bool _requestByLender
    ) internal returns (uint256) {
        require(_lender != _borrower, 'Lender and Borrower cannot be same addresses');
        uint256 _id = creditLineCounter + 1;
        creditLineCounter = _id;
        creditLineVariables[_id].status = CreditLineStatus.REQUESTED;
        creditLineConstants[_id].borrower = _borrower;
        creditLineConstants[_id].lender = _lender;
        creditLineConstants[_id].borrowLimit = _borrowLimit;
        creditLineConstants[_id].autoLiquidation = _autoLiquidation;
        creditLineConstants[_id].idealCollateralRatio = _collateralRatio;
        creditLineConstants[_id].borrowRate = _borrowRate;
        creditLineConstants[_id].borrowAsset = _borrowAsset;
        creditLineConstants[_id].collateralAsset = _collateralAsset;
        creditLineConstants[_id].requestByLender = _requestByLender;
        return _id;
    }

    /**
     * @notice used to accept a credit line
     * @dev if borrower places request, lender can accept and vice versa
     * @param _id identifier for the credit line
     */
    function accept(uint256 _id) external {
        require(
            creditLineVariables[_id].status == CreditLineStatus.REQUESTED,
            'CreditLine::acceptCreditLineLender - CreditLine is already accepted'
        );
        bool _requestByLender = creditLineConstants[_id].requestByLender;
        require(
            (msg.sender == creditLineConstants[_id].borrower && _requestByLender) ||
                (msg.sender == creditLineConstants[_id].lender && !_requestByLender),
            "Only Borrower or Lender who hasn't requested can accept"
        );
        creditLineVariables[_id].status = CreditLineStatus.ACTIVE;
        emit CreditLineAccepted(_id);
    }

    /**
     * @notice used to deposit collateral into the credit line
     * @dev collateral tokens have to be approved in savingsAccount or token contract(unless ether).
            If transferred from savings account, the tokens are transferred from strategies in the 
            order prespecified in strategy registry
     * @param _id identifier for the credit line
     * @param _amount amount of collateral being deposited
     * @param _strategy strategy to which collateral is to be deposited in case transfer is not from savings account
     * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount 
                                otherwise direct from collateral token contract
     */
    function depositCollateral(
        uint256 _id,
        uint256 _amount,
        address _strategy,
        bool _fromSavingsAccount
    ) external payable nonReentrant ifCreditLineExists(_id) {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine not active');
        _depositCollateral(_id, _amount, _strategy, _fromSavingsAccount);
        emit CollateralDeposited(_id, _amount, _strategy);
    }

    function _depositCollateral(
        uint256 _id,
        uint256 _amount,
        address _strategy,
        bool _fromSavingsAccount
    ) internal {
        require(creditLineConstants[_id].lender != msg.sender, 'lender cant deposit collateral');
        if (_fromSavingsAccount) {
            _depositCollateralFromSavingsAccount(_id, _amount, msg.sender);
        } else {
            address _collateralAsset = creditLineConstants[_id].collateralAsset;
            ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
            if (_collateralAsset == address(0)) {
                require(msg.value == _amount, "CreditLine::_depositCollateral - value to transfer doesn't match argument");
            } else {
                IERC20(_collateralAsset).safeTransferFrom(msg.sender, address(this), _amount);
                IERC20(_collateralAsset).approve(_strategy, _amount);
            }
            uint256 _sharesReceived = _savingsAccount.deposit{value: msg.value}(_amount, _collateralAsset, _strategy, address(this));
            collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(_sharesReceived);
        }
    }

    function _withdrawBorrowAmount(
        address _asset,
        uint256 _amountInTokens,
        address _lender
    ) internal {
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        uint256 _activeAmount;
        for (uint256 _index = 0; _index < _strategyList.length; _index++) {
            if (_strategyList[_index] == address(0)) {
                continue;
            }
            uint256 _liquidityShares = _savingsAccount.balanceInShares(_lender, _asset, _strategyList[_index]);
            if (_liquidityShares != 0) {
                uint256 tokenInStrategy = _liquidityShares;
                tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);
                uint256 _tokensToTransfer = tokenInStrategy;
                if (_activeAmount.add(tokenInStrategy) >= _amountInTokens) {
                    _tokensToTransfer = (_amountInTokens.sub(_activeAmount));
                }
                _activeAmount = _activeAmount.add(_tokensToTransfer);
                _savingsAccount.withdrawFrom(_tokensToTransfer, _asset, _strategyList[_index], _lender, address(this), false);
                if (_activeAmount == _amountInTokens) {
                    return;
                }
            }
        }
        require(_activeAmount == _amountInTokens, 'insufficient balance');
    }

    /**
     * @notice used to borrow tokens from credit line by borrower
     * @dev only borrower can call this function. Amount that can actually be borrowed is 
            min(amount based on borrowLimit, allowance to creditLine contract, balance of lender)
     * @param _id identifier for the credit line
     * @param _amount amount of tokens to borrow
     */
    function borrow(uint256 _id, uint256 _amount) external payable nonReentrant onlyCreditLineBorrower(_id) {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');
        uint256 _borrowableAmount = calculateBorrowableAmount(_id);
        require(_amount <= _borrowableAmount, "CreditLine::borrow - The current collateral ratio doesn't allow to withdraw the amount");
        address _borrowAsset = creditLineConstants[_id].borrowAsset;
        address _lender = creditLineConstants[_id].lender;

        updateinterestAccruedTillLastPrincipalUpdate(_id);
        creditLineVariables[_id].principal = creditLineVariables[_id].principal.add(_amount);
        creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;

        uint256 _tokenDiffBalance;
        if (_borrowAsset != address(0)) {
            uint256 _balanceBefore = IERC20(_borrowAsset).balanceOf(address(this));
            _withdrawBorrowAmount(_borrowAsset, _amount, _lender);
            uint256 _balanceAfter = IERC20(_borrowAsset).balanceOf(address(this));
            _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);
        } else {
            uint256 _balanceBefore = address(this).balance;
            _withdrawBorrowAmount(_borrowAsset, _amount, _lender);
            uint256 _balanceAfter = address(this).balance;
            _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);
        }
        uint256 _protocolFee = _tokenDiffBalance.mul(protocolFeeFraction).div(10**30);
        _tokenDiffBalance = _tokenDiffBalance.sub(_protocolFee);

        if (_borrowAsset == address(0)) {
            (bool feeSuccess, ) = protocolFeeCollector.call{value: _protocolFee}('');
            require(feeSuccess, 'Transfer fail');
            (bool success, ) = msg.sender.call{value: _tokenDiffBalance}('');
            require(success, 'Transfer fail');
        } else {
            IERC20(_borrowAsset).safeTransfer(protocolFeeCollector, _protocolFee);
            IERC20(_borrowAsset).safeTransfer(msg.sender, _tokenDiffBalance);
        }
        emit BorrowedFromCreditLine(_id, _tokenDiffBalance);
    }

    function _repayFromSavingsAccount(
        uint256 _amount,
        address _asset,
        address _lender
    ) internal {
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        uint256 _activeAmount;

        for (uint256 _index = 0; _index < _strategyList.length; _index++) {
            if (_strategyList[_index] == address(0)) {
                continue;
            }
            uint256 _liquidityShares = _savingsAccount.balanceInShares(msg.sender, _asset, _strategyList[_index]);
            if (_liquidityShares == 0) {
                continue;
            }
            uint256 _tokenInStrategy = _liquidityShares;
            _tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);

            uint256 _tokensToTransfer = _tokenInStrategy;
            if (_activeAmount.add(_tokenInStrategy) >= _amount) {
                _tokensToTransfer = (_amount.sub(_activeAmount));
            }
            _activeAmount = _activeAmount.add(_tokensToTransfer);
            _savingsAccount.transferFrom(_tokensToTransfer, _asset, _strategyList[_index], msg.sender, _lender);

            if (_amount == _activeAmount) {
                return;
            }
        }
        revert('CreditLine::_repayFromSavingsAccount - Insufficient balance');
    }

    function _repay(
        uint256 _id,
        uint256 _amount,
        bool _fromSavingsAccount,
        uint256 _principalPaid
    ) internal {
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        address _defaultStrategy = defaultStrategy;
        address _borrowAsset = creditLineConstants[_id].borrowAsset;
        address _lender = creditLineConstants[_id].lender;
        if (!_fromSavingsAccount) {
            if (_borrowAsset == address(0)) {
                require(msg.value == _amount, 'creditLine::repay - Ether sent not equal to repay amount');
                _savingsAccount.deposit{value: _amount}(_amount, _borrowAsset, _defaultStrategy, _lender);
            } else {
                IERC20(_borrowAsset).safeTransferFrom(msg.sender, address(this), _amount);
                IERC20(_borrowAsset).approve(_defaultStrategy, _amount);
                _savingsAccount.deposit(_amount, _borrowAsset, _defaultStrategy, _lender);
            }
        } else {
            _repayFromSavingsAccount(_amount, _borrowAsset, _lender);
        }
        if (_principalPaid != 0) {
            _savingsAccount.increaseAllowanceToCreditLine(_principalPaid, _borrowAsset, _lender);
        }
    }

    /**
     * @notice used to repay interest and principal to credit line. Interest has to be repaid before repaying principal
     * @dev partial repayments possible
     * @param _id identifier for the credit line
     * @param _amount amount being repaid
     * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount 
                                otherwise direct from collateral token contract
     */
    function repay(
        uint256 _id,
        uint256 _amount,
        bool _fromSavingsAccount
    ) external payable nonReentrant {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');
        require(creditLineConstants[_id].lender != msg.sender, 'Lender cant repay');

        uint256 _interestSincePrincipalUpdate = calculateInterestAccrued(_id);
        uint256 _totalInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(
            _interestSincePrincipalUpdate
        );
        uint256 _interestToPay = _totalInterestAccrued.sub(creditLineVariables[_id].totalInterestRepaid);
        uint256 _totalCurrentDebt = _interestToPay.add(creditLineVariables[_id].principal);
        uint256 _principalPaid = 0;

        if (_amount >= _totalCurrentDebt) {
            _amount = _totalCurrentDebt;
            emit CompleteCreditLineRepaid(_id, _amount);
        } else {
            emit PartialCreditLineRepaid(_id, _amount);
        }

        if (_amount > _interestToPay) {
            creditLineVariables[_id].principal = _totalCurrentDebt.sub(_amount);
            creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _totalInterestAccrued;
            creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;
            creditLineVariables[_id].totalInterestRepaid = _totalInterestAccrued;
            _principalPaid = _amount.sub(_interestToPay);
        } else {
            creditLineVariables[_id].totalInterestRepaid = creditLineVariables[_id].totalInterestRepaid.add(_amount);
        }

        _repay(_id, _amount, _fromSavingsAccount, _principalPaid);

        if (creditLineVariables[_id].principal == 0) {
            _resetCreditLine(_id);
        }
    }

    function _resetCreditLine(uint256 _id) internal {
        creditLineVariables[_id].lastPrincipalUpdateTime = 0;
        creditLineVariables[_id].totalInterestRepaid = 0;
        creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = 0;
        emit CreditLineReset(_id);
    }

    /**
     * @dev used to close credit line by borrower or lender
     * @param _id identifier for the credit line
     */
    function close(uint256 _id) external ifCreditLineExists(_id) {
        require(
            msg.sender == creditLineConstants[_id].borrower || msg.sender == creditLineConstants[_id].lender,
            'CreditLine: Permission denied while closing Line of credit'
        );
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: Credit line should be active.');
        require(creditLineVariables[_id].principal == 0, 'CreditLine: Cannot be closed since not repaid.');
        require(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate == 0, 'CreditLine: Cannot be closed since not repaid.');
        creditLineVariables[_id].status = CreditLineStatus.CLOSED;
        emit CreditLineClosed(_id);
    }

    /**
     * @notice used to calculate the current collateral ratio
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view.
            Interest is also considered while calculating debt
     * @param _id identifier for the credit line
     * @return collateral ratio multiplied by 10**30 to retain precision
     */
    function calculateCurrentCollateralRatio(uint256 _id) public ifCreditLineExists(_id) returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(
            creditLineConstants[_id].collateralAsset,
            creditLineConstants[_id].borrowAsset
        );

        uint256 currentDebt = calculateCurrentDebt(_id);
        uint256 currentCollateralRatio = calculateTotalCollateralTokens(_id).mul(_ratioOfPrices).div(currentDebt).mul(10**30).div(
            10**_decimals
        );

        return currentCollateralRatio;
    }

    /**
     * @notice used to calculate the total collateral tokens
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @param _id identifier for the credit line
     * @return _amount total collateral tokens deposited into the credit line
     */
    function calculateTotalCollateralTokens(uint256 _id) public returns (uint256 _amount) {
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        uint256 _liquidityShares;
        for (uint256 index = 0; index < _strategyList.length; index++) {
            if (_strategyList[index] == address(0)) {
                continue;
            }
            _liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];
            uint256 _tokenInStrategy = _liquidityShares;
            _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(_liquidityShares, _collateralAsset);

            _amount = _amount.add(_tokenInStrategy);
        }
    }

    /**
     * @notice used to withdraw any excess collateral
     * @dev collateral can't be withdraw if collateralRatio goes below the ideal value. Only borrower can withdraw
     * @param _id identifier for the credit line
     * @param _amount amount of collateral to withdraw
     * @param _toSavingsAccount if true, tokens are transferred from savingsAccount 
                                otherwise direct from collateral token contract
     */
    function withdrawCollateral(
        uint256 _id,
        uint256 _amount,
        bool _toSavingsAccount
    ) external nonReentrant onlyCreditLineBorrower(_id) {
        uint256 _withdrawableCollateral = withdrawableCollateral(_id);
        require(_amount <= _withdrawableCollateral, 'Collateral ratio cant go below ideal');
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        _transferCollateral(_id, _collateralAsset, _amount, _toSavingsAccount);
        emit CollateralWithdrawn(_id, _amount);
    }

    /**
     * @notice used to calculate the collateral that can be withdrawn
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @param _id identifier for the credit line
     * @return total collateral withdrawable by borrower
     */
    function withdrawableCollateral(uint256 _id) public returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(
            creditLineConstants[_id].collateralAsset,
            creditLineConstants[_id].borrowAsset
        );

        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);
        uint256 _currentDebt = calculateCurrentDebt(_id);

        uint256 _collateralNeeded = _currentDebt
            .mul(creditLineConstants[_id].idealCollateralRatio)
            .div(_ratioOfPrices)
            .mul(10**_decimals)
            .div(10**30);

        if (_collateralNeeded >= _totalCollateralTokens) {
            return 0;
        }
        return _totalCollateralTokens.sub(_collateralNeeded);
    }

    function _transferCollateral(
        uint256 _id,
        address _asset,
        uint256 _amountInTokens,
        bool _toSavingsAccount
    ) internal {
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        uint256 _activeAmount;
        for (uint256 index = 0; index < _strategyList.length; index++) {
            uint256 liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];
            if (liquidityShares == 0 || _strategyList[index] == address(0)) {
                continue;
            }
            uint256 _tokenInStrategy = liquidityShares;
            _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(liquidityShares, _asset);
            uint256 _tokensToTransfer = _tokenInStrategy;
            if (_activeAmount.add(_tokenInStrategy) > _amountInTokens) {
                _tokensToTransfer = _amountInTokens.sub(_activeAmount);
                liquidityShares = liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy);
            }
            _activeAmount = _activeAmount.add(_tokensToTransfer);
            collateralShareInStrategy[_id][_strategyList[index]] = collateralShareInStrategy[_id][_strategyList[index]].sub(
                liquidityShares
            );
            if (_toSavingsAccount) {
                ISavingsAccount(savingsAccount).transfer(_tokensToTransfer, _asset, _strategyList[index], msg.sender);
            } else {
                ISavingsAccount(savingsAccount).withdraw(_tokensToTransfer, _asset, _strategyList[index], msg.sender, false);
            }

            if (_activeAmount == _amountInTokens) {
                return;
            }
        }
        revert('insufficient collateral');
    }

    /**
     * @notice used to liquidate credit line in case collateral ratio goes below the threshold
     * @dev if lender liquidates, then collateral is directly transferred. 
            If autoLiquidation is true, anyone can liquidate by providing enough borrow tokens
     * @param _id identifier for the credit line
     * @param _toSavingsAccount if true, tokens are transferred from savingsAccount 
                                otherwise direct from collateral token contract
     */
    function liquidate(uint256 _id, bool _toSavingsAccount) external payable nonReentrant {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: Credit line should be active.');
        require(creditLineVariables[_id].principal != 0, 'CreditLine: cannot liquidate if principal is 0');

        uint256 currentCollateralRatio = calculateCurrentCollateralRatio(_id);
        require(
            currentCollateralRatio < creditLineConstants[_id].idealCollateralRatio,
            'CreditLine: Collateral ratio is higher than ideal value'
        );

        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        address _lender = creditLineConstants[_id].lender;
        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);
        address _borrowAsset = creditLineConstants[_id].borrowAsset;

        creditLineVariables[_id].status = CreditLineStatus.LIQUIDATED;

        if (creditLineConstants[_id].autoLiquidation && _lender != msg.sender) {
            uint256 _borrowTokens = _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens);
            if (_borrowAsset == address(0)) {
                uint256 _returnETH = msg.value.sub(_borrowTokens, 'Insufficient ETH to liquidate');
                if (_returnETH != 0) {
                    (bool success, ) = msg.sender.call{value: _returnETH}('');
                    require(success, 'Transfer fail');
                }
            } else {
                IERC20(_borrowAsset).safeTransferFrom(msg.sender, _lender, _borrowTokens);
            }
        }

        _transferCollateral(_id, _collateralAsset, _totalCollateralTokens, _toSavingsAccount);

        emit CreditLineLiquidated(_id, msg.sender);
    }

    /**
     * @notice used to calculate the borrow tokens necessary for liquidator to liquidate
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @param _id identifier for the credit line
     * @return borrow tokens necessary for liquidator to liquidate
     */
    function borrowTokensToLiquidate(uint256 _id) external returns (uint256) {
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);
        address _borrowAsset = creditLineConstants[_id].borrowAsset;

        return _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens);
    }

    function _borrowTokensToLiquidate(
        address _borrowAsset,
        address _collateralAsset,
        uint256 _totalCollateralTokens
    ) internal view returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(_borrowAsset, _collateralAsset);
        uint256 _borrowTokens = (
            _totalCollateralTokens.mul(uint256(10**30).sub(liquidatorRewardFraction)).div(10**30).mul(_ratioOfPrices).div(10**_decimals)
        );

        return _borrowTokens;
    }

    receive() external payable {
        require(msg.sender == savingsAccount, 'CreditLine::receive invalid transaction');
    }
}
.]

###

[2024-22-08 11:43:42 INFO] **[Seminar Conclusion]**:

 ###

[2024-22-08 11:43:42 INFO] **[Execute Detail]**

execute SimplePhase:[BugsSummary] in ComposedPhase:[CodeReview], cycle 3

[2024-22-08 11:43:42 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol'; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/utils/ReentrancyGuard.sol'; import '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol'; import '../interfaces/IPriceOracle.sol'; import '../interfaces/IYield.sol'; import '../interfaces/ISavingsAccount.sol'; import '../SavingsAccount/SavingsAccountUtil.sol'; import '../interfaces/IStrategyRegistry.sol'; /  * @title Credit Line contract with Methods related to credit Line  * @notice Implements the functions related to Credit Line  * @author Sublime  / contract CreditLine is ReentrancyGuard, OwnableUpgradeable {     using SafeERC20 for IERC20;     using SafeMath for uint256; enum CreditLineStatus {     NOT_CREATED,     REQUESTED,     ACTIVE,     CLOSED,     CANCELLED,     LIQUIDATED }  /**  * @notice counter that tracks the number of credit lines created  * @dev used to create unique identifier for credit lines  **/ uint256 public creditLineCounter;  uint256 constant YEAR_IN_SECONDS = 365 days;  struct CreditLineVariables {     CreditLineStatus status;     uint256 principal;     uint256 totalInterestRepaid;     uint256 lastPrincipalUpdateTime;     uint256 interestAccruedTillLastPrincipalUpdate; }  struct CreditLineConstants {     address lender;     address borrower;     uint256 borrowLimit;     uint256 idealCollateralRatio;     uint256 borrowRate;     address borrowAsset;     address collateralAsset;     bool autoLiquidation;     bool requestByLender; } /**  * @notice stores the collateral shares in a credit line per strategy  * @dev creditLineId =&gt; Strategy =&gt; collateralShares  **/ mapping(uint256 =&gt; mapping(address =&gt; uint256)) public collateralShareInStrategy;  /**  * @notice stores the variables to maintain a credit line  **/ mapping(uint256 =&gt; CreditLineVariables) public creditLineVariables;  /**  * @notice stores the constants related to a credit line  **/ mapping(uint256 =&gt; CreditLineConstants) public creditLineConstants;  /**  * @notice stores the address of savings account contract  **/ address public savingsAccount;  /**  * @notice stores the address of price oracle contract  **/ address public priceOracle;  /**  * @notice stores the address of strategy registry contract  **/ address public strategyRegistry;  /**  * @notice stores the address of default strategy  **/ address public defaultStrategy;  /**  * @notice stores the fraction of borrowed amount charged as fee by protocol  * @dev it is multiplied by 10**30  **/ uint256 public protocolFeeFraction;  /**  * @notice address where protocol fee is collected  **/ address public protocolFeeCollector;  /**  * @notice stores the fraction of amount liquidated given as reward to liquidator  * @dev it is multiplied by 10**30  **/ uint256 public liquidatorRewardFraction; /**  * @dev checks if Credit Line exists  * @param _id identifier for the credit line  **/ modifier ifCreditLineExists(uint256 _id) {     require(creditLineVariables[_id].status != CreditLineStatus.NOT_CREATED, 'Credit line does not exist');     _; }  /**  * @dev checks if called by credit Line Borrower  * @param _id creditLine identifier  **/ modifier onlyCreditLineBorrower(uint256 _id) {     require(creditLineConstants[_id].borrower == msg.sender, 'Only credit line Borrower can access');     _; }  /**  * @dev checks if called by credit Line Lender  * @param _id creditLine identifier  **/ modifier onlyCreditLineLender(uint256 _id) {     require(creditLineConstants[_id].lender == msg.sender, 'Only credit line Lender can access');     _; }  /**  * @notice emitted when a collateral is deposited into credit line  * @param id id of the credit line  * @param amount amount of collateral deposited  * @param strategy address of the strategy into which collateral is deposited  */ event CollateralDeposited(uint256 indexed id, uint256 amount, address indexed strategy);  /**  * @notice emitted when collateral is withdrawn from credit line  * @param id id of the credit line  * @param amount amount of collateral withdrawn  */ event CollateralWithdrawn(uint256 indexed id, uint256 amount);  /**  * @notice emitted when a request for new credit line is placed  * @param id id of the credit line for which request was made  * @param lender address of the lender for credit line  * @param borrower address of the borrower for credit line  */ event CreditLineRequested(uint256 indexed id, address indexed lender, address indexed borrower);  /**  * @notice emitted when a credit line is liquidated  * @param id id of the credit line which is liquidated  * @param liquidator address of the liquidator  */ event CreditLineLiquidated(uint256 indexed id, address indexed liquidator);  /**  * @notice emitted when tokens are borrowed from credit line  * @param id id of the credit line from which tokens are borrowed  * @param borrowAmount amount of tokens borrowed  */ event BorrowedFromCreditLine(uint256 indexed id, uint256 borrowAmount);  /**  * @notice emitted when credit line is accepted  * @param id id of the credit line that was accepted  */ event CreditLineAccepted(uint256 indexed id);  /**  * @notice emitted when credit line is completely repaid and reset  * @param id id of the credit line that is reset  */ event CreditLineReset(uint256 indexed id);  /**  * @notice emitted when the credit line is partially repaid  * @param id id of the credit line  * @param repayAmount amount repaid  */ event PartialCreditLineRepaid(uint256 indexed id, uint256 repayAmount);  /**  * @notice emitted when the credit line is completely repaid  * @param id id of the credit line  * @param repayAmount amount repaid  */ event CompleteCreditLineRepaid(uint256 indexed id, uint256 repayAmount);  /**  * @notice emitted when the credit line is closed by one of the parties of credit line  * @param id id of the credit line  */ event CreditLineClosed(uint256 indexed id);  /**  * @notice emitted when default strategy for the credit line is updated  * @param defaultStrategy address of the strategy contract that is used as default by credit lines  */ event DefaultStrategyUpdated(address indexed defaultStrategy);  /**  * @notice emitted when the price oracle is updated  * @param priceOracle address of the updated price oracle  */ event PriceOracleUpdated(address indexed priceOracle);  /**  * @notice emitted when the savings account address is updated  * @param savingsAccount address of the updated savingsAccount  */ event SavingsAccountUpdated(address indexed savingsAccount);  /**  * @notice emitted when strategy registry address is updated  * @param strategyRegistry address of the updated strategy registry  */ event StrategyRegistryUpdated(address indexed strategyRegistry);  /**  * @notice emitted when fee that protocol charges for credit line is updated  * @param updatedProtocolFee updated value of protocolFeeFraction  */ event ProtocolFeeFractionUpdated(uint256 updatedProtocolFee);  /**  * @notice emitted when address which receives fee that protocol changes for pools is updated  * @param updatedProtocolFeeCollector updated value of protocolFeeCollector  */ event ProtocolFeeCollectorUpdated(address indexed updatedProtocolFeeCollector);  /**  * @notice emitted when liquidatorRewardFraction is updated  * @param liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator  */ event LiquidationRewardFractionUpdated(uint256 liquidatorRewardFraction);  /**  * @notice used to initialize the contract  * @dev can only be called once during the life cycle of the contract  * @param _defaultStrategy default strategy used in credit lines  * @param _priceOracle address of the priceOracle  * @param _savingsAccount address of  the savings account contract  * @param _strategyRegistry address of the strategy registry contract  * @param _owner address of owner who can change global variables  * @param _protocolFeeFraction fraction of the fee charged by protocol  * @param _protocolFeeCollector address to which protocol fee is charged to  * @param _liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator  */ function initialize(     address _defaultStrategy,     address _priceOracle,     address _savingsAccount,     address _strategyRegistry,     address _owner,     uint256 _protocolFeeFraction,     address _protocolFeeCollector,     uint256 _liquidatorRewardFraction ) external initializer {     OwnableUpgradeable.__Ownable_init();     OwnableUpgradeable.transferOwnership(_owner);      _updateDefaultStrategy(_defaultStrategy);     _updatePriceOracle(_priceOracle);     _updateSavingsAccount(_savingsAccount);     _updateStrategyRegistry(_strategyRegistry);     _updateProtocolFeeFraction(_protocolFeeFraction);     _updateProtocolFeeCollector(_protocolFeeCollector);     _updateLiquidatorRewardFraction(_liquidatorRewardFraction); }  /**  * @notice used to update the default strategy  * @dev can only be updated by owner  * @param _defaultStrategy address of the updated default strategy  */ function updateDefaultStrategy(address _defaultStrategy) external onlyOwner {     _updateDefaultStrategy(_defaultStrategy); }  function _updateDefaultStrategy(address _defaultStrategy) internal {     defaultStrategy = _defaultStrategy;     emit DefaultStrategyUpdated(_defaultStrategy); }  /**  * @notice used to update the price oracle  * @dev can only be updated by owner  * @param _priceOracle address of the updated price oracle  */ function updatePriceOracle(address _priceOracle) external onlyOwner {     _updatePriceOracle(_priceOracle); }  function _updatePriceOracle(address _priceOracle) internal {     priceOracle = _priceOracle;     emit PriceOracleUpdated(_priceOracle); }  /**  * @notice used to update the savings account address  * @dev can only be updated by owner  * @param _savingsAccount address of the updated savings account  */ function updateSavingsAccount(address _savingsAccount) external onlyOwner {     _updateSavingsAccount(_savingsAccount); }  function _updateSavingsAccount(address _savingsAccount) internal {     savingsAccount = _savingsAccount;     emit SavingsAccountUpdated(_savingsAccount); }  /**  * @notice used to update the protocol fee fraction  * @dev can only be updated by owner  * @param _protocolFee fraction of the borrower amount collected as protocol fee  */ function updateProtocolFeeFraction(uint256 _protocolFee) external onlyOwner {     _updateProtocolFeeFraction(_protocolFee); }  function _updateProtocolFeeFraction(uint256 _protocolFee) internal {     protocolFeeFraction = _protocolFee;     emit ProtocolFeeFractionUpdated(_protocolFee); }  /**  * @notice used to update the protocol fee collector  * @dev can only be updated by owner  * @param _protocolFeeCollector address in which protocol fee is collected  */ function updateProtocolFeeCollector(address _protocolFeeCollector) external onlyOwner {     _updateProtocolFeeCollector(_protocolFeeCollector); }  function _updateProtocolFeeCollector(address _protocolFeeCollector) internal {     require(_protocolFeeCollector != address(0), 'cant be 0 address');     protocolFeeCollector = _protocolFeeCollector;     emit ProtocolFeeCollectorUpdated(_protocolFeeCollector); }  /**  * @notice used to update the strategy registry address  * @dev can only be updated by owner  * @param _strategyRegistry address of the updated strategy registry  */ function updateStrategyRegistry(address _strategyRegistry) external onlyOwner {     _updateStrategyRegistry(_strategyRegistry); }  function _updateStrategyRegistry(address _strategyRegistry) internal {     require(_strategyRegistry != address(0), 'CL::I zero address');     strategyRegistry = _strategyRegistry;     emit StrategyRegistryUpdated(_strategyRegistry); }  /**  * @notice used to update the liquidatorRewardFraction  * @dev can only be updated by owner  * @param _rewardFraction fraction of liquidated amount given to liquidator as reward  */ function updateLiquidatorRewardFraction(uint256 _rewardFraction) external onlyOwner {     _updateLiquidatorRewardFraction(_rewardFraction); }  function _updateLiquidatorRewardFraction(uint256 _rewardFraction) internal {     require(_rewardFraction &lt;= 10**30, 'Fraction has to be less than 1');     liquidatorRewardFraction = _rewardFraction;     emit LiquidationRewardFractionUpdated(_rewardFraction); }  /**  * @dev Used to Calculate Interest Per second on given principal and Interest rate  * @param _principal principal Amount for which interest has to be calculated.  * @param _borrowRate It is the Interest Rate at which Credit Line is approved  * @return interest per second for the given parameters  */ function calculateInterest(     uint256 _principal,     uint256 _borrowRate,     uint256 _timeElapsed ) public pure returns (uint256) {     uint256 _interest = _principal.mul(_borrowRate).mul(_timeElapsed).div(10**30).div(YEAR_IN_SECONDS);      return _interest; }  /**  * @dev Used to calculate interest accrued since last repayment  * @param _id identifier for the credit line  * @return interest accrued over current borrowed amount since last repayment  */  function calculateInterestAccrued(uint256 _id) public view returns (uint256) {     uint256 _lastPrincipalUpdateTime = creditLineVariables[_id].lastPrincipalUpdateTime;     if (_lastPrincipalUpdateTime == 0) return 0;     uint256 _timeElapsed = (block.timestamp).sub(_lastPrincipalUpdateTime);     uint256 _interestAccrued = calculateInterest(creditLineVariables[_id].principal, creditLineConstants[_id].borrowRate, _timeElapsed);     return _interestAccrued; }  /**  * @dev Used to calculate current debt of borrower against a credit line.  * @param _id identifier for the credit line  * @return current debt of borrower  */ function calculateCurrentDebt(uint256 _id) public view returns (uint256) {     uint256 _interestAccrued = calculateInterestAccrued(_id);     uint256 _currentDebt = (creditLineVariables[_id].principal)         .add(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate)         .add(_interestAccrued)         .sub(creditLineVariables[_id].totalInterestRepaid);     return _currentDebt; }  /**  * @notice used to calculate amount that can be borrowed by the borrower  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view.         borrowableAmount changes per block as interest changes per block.  * @param _id identifier for the credit line  * @return amount that can be borrowed from the credit line  */ function calculateBorrowableAmount(uint256 _id) public returns (uint256) {     CreditLineStatus _status = creditLineVariables[_id].status;     require(         _status == CreditLineStatus.ACTIVE || _status == CreditLineStatus.REQUESTED,         'CreditLine: Cannot only if credit line ACTIVE or REQUESTED'     );     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(         creditLineConstants[_id].collateralAsset,         creditLineConstants[_id].borrowAsset     );      uint256 _totalCollateralToken = calculateTotalCollateralTokens(_id);      uint256 _currentDebt = calculateCurrentDebt(_id);      uint256 _maxPossible = _totalCollateralToken.mul(_ratioOfPrices).div(creditLineConstants[_id].idealCollateralRatio).mul(10**30).div(         10**_decimals     );      uint256 _borrowLimit = creditLineConstants[_id].borrowLimit;      if (_maxPossible &gt; _borrowLimit) {         _maxPossible = _borrowLimit;     }     if (_maxPossible &gt; _currentDebt) {         return _maxPossible.sub(_currentDebt);     }     return 0; }  function updateinterestAccruedTillLastPrincipalUpdate(uint256 _id) internal {     require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');      uint256 _interestAccrued = calculateInterestAccrued(_id);     uint256 _newInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(_interestAccrued);     creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _newInterestAccrued; }  function _depositCollateralFromSavingsAccount(     uint256 _id,     uint256 _amount,     address _sender ) internal {     address _collateralAsset = creditLineConstants[_id].collateralAsset;     address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();     ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);     uint256 _activeAmount;      for (uint256 _index = 0; _index &lt; _strategyList.length; _index++) {         address _strategy = _strategyList[_index];         uint256 _liquidityShares = _savingsAccount.balanceInShares(_sender, _collateralAsset, _strategy);         if (_liquidityShares == 0 || _strategyList[_index] == address(0)) {             continue;         }         uint256 _tokenInStrategy = _liquidityShares;         _tokenInStrategy = IYield(_strategy).getTokensForShares(_liquidityShares, _collateralAsset);          uint256 _tokensToTransfer = _tokenInStrategy;         if (_activeAmount.add(_tokenInStrategy) &gt;= _amount) {             _tokensToTransfer = (_amount.sub(_activeAmount));         }         _activeAmount = _activeAmount.add(_tokensToTransfer);         _savingsAccount.transferFrom(_tokensToTransfer, _collateralAsset, _strategy, _sender, address(this));          collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(             _liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy)         );          if (_amount == _activeAmount) {             return;         }     }     revert('CreditLine::_depositCollateralFromSavingsAccount - Insufficient balance'); }  /**  * @notice used to request a credit line either by borrower or lender  * @param _requestTo Address to which creditLine is requested,                      if borrower creates request then lender address and                      if lender creates then borrower address  * @param _borrowLimit maximum borrow amount in a credit line  * @param _borrowRate Interest Rate at which credit Line is requested  * @param _autoLiquidation if true, anyone can liquidate loan, otherwise only lender  * @param _collateralRatio ratio of the collateral to the debt below which credit line can be liquidated  * @param _borrowAsset address of the token to be borrowed  * @param _collateralAsset address of the token provided as collateral  * @param _requestAsLender if true, lender is placing request, otherwise borrower  * @return identifier for the credit line  */  function request(     address _requestTo,     uint256 _borrowLimit,     uint256 _borrowRate,     bool _autoLiquidation,     uint256 _collateralRatio,     address _borrowAsset,     address _collateralAsset,     bool _requestAsLender ) external returns (uint256) {     require(_borrowAsset != _collateralAsset, 'R: cant borrow lent token');     require(IPriceOracle(priceOracle).doesFeedExist(_borrowAsset, _collateralAsset), 'R: No price feed');      address _lender = _requestTo;     address _borrower = msg.sender;     if (_requestAsLender) {         _lender = msg.sender;         _borrower = _requestTo;     }      uint256 _id = _createRequest(         _lender,         _borrower,         _borrowLimit,         _borrowRate,         _autoLiquidation,         _collateralRatio,         _borrowAsset,         _collateralAsset,         _requestAsLender     );      emit CreditLineRequested(_id, _lender, _borrower);     return _id; }  function _createRequest(     address _lender,     address _borrower,     uint256 _borrowLimit,     uint256 _borrowRate,     bool _autoLiquidation,     uint256 _collateralRatio,     address _borrowAsset,     address _collateralAsset,     bool _requestByLender ) internal returns (uint256) {     require(_lender != _borrower, 'Lender and Borrower cannot be same addresses');     uint256 _id = creditLineCounter + 1;     creditLineCounter = _id;     creditLineVariables[_id].status = CreditLineStatus.REQUESTED;     creditLineConstants[_id].borrower = _borrower;     creditLineConstants[_id].lender = _lender;     creditLineConstants[_id].borrowLimit = _borrowLimit;     creditLineConstants[_id].autoLiquidation = _autoLiquidation;     creditLineConstants[_id].idealCollateralRatio = _collateralRatio;     creditLineConstants[_id].borrowRate = _borrowRate;     creditLineConstants[_id].borrowAsset = _borrowAsset;     creditLineConstants[_id].collateralAsset = _collateralAsset;     creditLineConstants[_id].requestByLender = _requestByLender;     return _id; }  /**  * @notice used to accept a credit line  * @dev if borrower places request, lender can accept and vice versa  * @param _id identifier for the credit line  */ function accept(uint256 _id) external {     require(         creditLineVariables[_id].status == CreditLineStatus.REQUESTED,         'CreditLine::acceptCreditLineLender - CreditLine is already accepted'     );     bool _requestByLender = creditLineConstants[_id].requestByLender;     require(         (msg.sender == creditLineConstants[_id].borrower &amp;&amp; _requestByLender) ||             (msg.sender == creditLineConstants[_id].lender &amp;&amp; !_requestByLender),         "Only Borrower or Lender who hasn't requested can accept"     );     creditLineVariables[_id].status = CreditLineStatus.ACTIVE;     emit CreditLineAccepted(_id); }  /**  * @notice used to deposit collateral into the credit line  * @dev collateral tokens have to be approved in savingsAccount or token contract(unless ether).         If transferred from savings account, the tokens are transferred from strategies in the          order prespecified in strategy registry  * @param _id identifier for the credit line  * @param _amount amount of collateral being deposited  * @param _strategy strategy to which collateral is to be deposited in case transfer is not from savings account  * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount                              otherwise direct from collateral token contract  */ function depositCollateral(     uint256 _id,     uint256 _amount,     address _strategy,     bool _fromSavingsAccount ) external payable nonReentrant ifCreditLineExists(_id) {     require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine not active');     _depositCollateral(_id, _amount, _strategy, _fromSavingsAccount);     emit CollateralDeposited(_id, _amount, _strategy); }  function _depositCollateral(     uint256 _id,     uint256 _amount,     address _strategy,     bool _fromSavingsAccount ) internal {     require(creditLineConstants[_id].lender != msg.sender, 'lender cant deposit collateral');     if (_fromSavingsAccount) {         _depositCollateralFromSavingsAccount(_id, _amount, msg.sender);     } else {         address _collateralAsset = creditLineConstants[_id].collateralAsset;         ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);         if (_collateralAsset == address(0)) {             require(msg.value == _amount, "CreditLine::_depositCollateral - value to transfer doesn't match argument");         } else {             IERC20(_collateralAsset).safeTransferFrom(msg.sender, address(this), _amount);             IERC20(_collateralAsset).approve(_strategy, _amount);         }         uint256 _sharesReceived = _savingsAccount.deposit{value: msg.value}(_amount, _collateralAsset, _strategy, address(this));         collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(_sharesReceived);     } }  function _withdrawBorrowAmount(     address _asset,     uint256 _amountInTokens,     address _lender ) internal {     address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();     ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);     uint256 _activeAmount;     for (uint256 _index = 0; _index &lt; _strategyList.length; _index++) {         if (_strategyList[_index] == address(0)) {             continue;         }         uint256 _liquidityShares = _savingsAccount.balanceInShares(_lender, _asset, _strategyList[_index]);         if (_liquidityShares != 0) {             uint256 tokenInStrategy = _liquidityShares;             tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);             uint256 _tokensToTransfer = tokenInStrategy;             if (_activeAmount.add(tokenInStrategy) &gt;= _amountInTokens) {                 _tokensToTransfer = (_amountInTokens.sub(_activeAmount));             }             _activeAmount = _activeAmount.add(_tokensToTransfer);             _savingsAccount.withdrawFrom(_tokensToTransfer, _asset, _strategyList[_index], _lender, address(this), false);             if (_activeAmount == _amountInTokens) {                 return;             }         }     }     require(_activeAmount == _amountInTokens, 'insufficient balance'); }  /**  * @notice used to borrow tokens from credit line by borrower  * @dev only borrower can call this function. Amount that can actually be borrowed is          min(amount based on borrowLimit, allowance to creditLine contract, balance of lender)  * @param _id identifier for the credit line  * @param _amount amount of tokens to borrow  */ function borrow(uint256 _id, uint256 _amount) external payable nonReentrant onlyCreditLineBorrower(_id) {     require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');     uint256 _borrowableAmount = calculateBorrowableAmount(_id);     require(_amount &lt;= _borrowableAmount, "CreditLine::borrow - The current collateral ratio doesn't allow to withdraw the amount");     address _borrowAsset = creditLineConstants[_id].borrowAsset;     address _lender = creditLineConstants[_id].lender;      updateinterestAccruedTillLastPrincipalUpdate(_id);     creditLineVariables[_id].principal = creditLineVariables[_id].principal.add(_amount);     creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;      uint256 _tokenDiffBalance;     if (_borrowAsset != address(0)) {         uint256 _balanceBefore = IERC20(_borrowAsset).balanceOf(address(this));         _withdrawBorrowAmount(_borrowAsset, _amount, _lender);         uint256 _balanceAfter = IERC20(_borrowAsset).balanceOf(address(this));         _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);     } else {         uint256 _balanceBefore = address(this).balance;         _withdrawBorrowAmount(_borrowAsset, _amount, _lender);         uint256 _balanceAfter = address(this).balance;         _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);     }     uint256 _protocolFee = _tokenDiffBalance.mul(protocolFeeFraction).div(10**30);     _tokenDiffBalance = _tokenDiffBalance.sub(_protocolFee);      if (_borrowAsset == address(0)) {         (bool feeSuccess, ) = protocolFeeCollector.call{value: _protocolFee}('');         require(feeSuccess, 'Transfer fail');         (bool success, ) = msg.sender.call{value: _tokenDiffBalance}('');         require(success, 'Transfer fail');     } else {         IERC20(_borrowAsset).safeTransfer(protocolFeeCollector, _protocolFee);         IERC20(_borrowAsset).safeTransfer(msg.sender, _tokenDiffBalance);     }     emit BorrowedFromCreditLine(_id, _tokenDiffBalance); }  function _repayFromSavingsAccount(     uint256 _amount,     address _asset,     address _lender ) internal {     address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();     ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);     uint256 _activeAmount;      for (uint256 _index = 0; _index &lt; _strategyList.length; _index++) {         if (_strategyList[_index] == address(0)) {             continue;         }         uint256 _liquidityShares = _savingsAccount.balanceInShares(msg.sender, _asset, _strategyList[_index]);         if (_liquidityShares == 0) {             continue;         }         uint256 _tokenInStrategy = _liquidityShares;         _tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);          uint256 _tokensToTransfer = _tokenInStrategy;         if (_activeAmount.add(_tokenInStrategy) &gt;= _amount) {             _tokensToTransfer = (_amount.sub(_activeAmount));         }         _activeAmount = _activeAmount.add(_tokensToTransfer);         _savingsAccount.transferFrom(_tokensToTransfer, _asset, _strategyList[_index], msg.sender, _lender);          if (_amount == _activeAmount) {             return;         }     }     revert('CreditLine::_repayFromSavingsAccount - Insufficient balance'); }  function _repay(     uint256 _id,     uint256 _amount,     bool _fromSavingsAccount,     uint256 _principalPaid ) internal {     ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);     address _defaultStrategy = defaultStrategy;     address _borrowAsset = creditLineConstants[_id].borrowAsset;     address _lender = creditLineConstants[_id].lender;     if (!_fromSavingsAccount) {         if (_borrowAsset == address(0)) {             require(msg.value == _amount, 'creditLine::repay - Ether sent not equal to repay amount');             _savingsAccount.deposit{value: _amount}(_amount, _borrowAsset, _defaultStrategy, _lender);         } else {             IERC20(_borrowAsset).safeTransferFrom(msg.sender, address(this), _amount);             IERC20(_borrowAsset).approve(_defaultStrategy, _amount);             _savingsAccount.deposit(_amount, _borrowAsset, _defaultStrategy, _lender);         }     } else {         _repayFromSavingsAccount(_amount, _borrowAsset, _lender);     }     if (_principalPaid != 0) {         _savingsAccount.increaseAllowanceToCreditLine(_principalPaid, _borrowAsset, _lender);     } }  /**  * @notice used to repay interest and principal to credit line. Interest has to be repaid before repaying principal  * @dev partial repayments possible  * @param _id identifier for the credit line  * @param _amount amount being repaid  * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount                              otherwise direct from collateral token contract  */ function repay(     uint256 _id,     uint256 _amount,     bool _fromSavingsAccount ) external payable nonReentrant {     require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');     require(creditLineConstants[_id].lender != msg.sender, 'Lender cant repay');      uint256 _interestSincePrincipalUpdate = calculateInterestAccrued(_id);     uint256 _totalInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(         _interestSincePrincipalUpdate     );     uint256 _interestToPay = _totalInterestAccrued.sub(creditLineVariables[_id].totalInterestRepaid);     uint256 _totalCurrentDebt = _interestToPay.add(creditLineVariables[_id].principal);     uint256 _principalPaid = 0;      if (_amount &gt;= _totalCurrentDebt) {         _amount = _totalCurrentDebt;         emit CompleteCreditLineRepaid(_id, _amount);     } else {         emit PartialCreditLineRepaid(_id, _amount);     }      if (_amount &gt; _interestToPay) {         creditLineVariables[_id].principal = _totalCurrentDebt.sub(_amount);         creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _totalInterestAccrued;         creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;         creditLineVariables[_id].totalInterestRepaid = _totalInterestAccrued;         _principalPaid = _amount.sub(_interestToPay);     } else {         creditLineVariables[_id].totalInterestRepaid = creditLineVariables[_id].totalInterestRepaid.add(_amount);     }      _repay(_id, _amount, _fromSavingsAccount, _principalPaid);      if (creditLineVariables[_id].principal == 0) {         _resetCreditLine(_id);     } }  function _resetCreditLine(uint256 _id) internal {     creditLineVariables[_id].lastPrincipalUpdateTime = 0;     creditLineVariables[_id].totalInterestRepaid = 0;     creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = 0;     emit CreditLineReset(_id); }  /**  * @dev used to close credit line by borrower or lender  * @param _id identifier for the credit line  */ function close(uint256 _id) external ifCreditLineExists(_id) {     require(         msg.sender == creditLineConstants[_id].borrower || msg.sender == creditLineConstants[_id].lender,         'CreditLine: Permission denied while closing Line of credit'     );     require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: Credit line should be active.');     require(creditLineVariables[_id].principal == 0, 'CreditLine: Cannot be closed since not repaid.');     require(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate == 0, 'CreditLine: Cannot be closed since not repaid.');     creditLineVariables[_id].status = CreditLineStatus.CLOSED;     emit CreditLineClosed(_id); }  /**  * @notice used to calculate the current collateral ratio  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view.         Interest is also considered while calculating debt  * @param _id identifier for the credit line  * @return collateral ratio multiplied by 10**30 to retain precision  */ function calculateCurrentCollateralRatio(uint256 _id) public ifCreditLineExists(_id) returns (uint256) {     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(         creditLineConstants[_id].collateralAsset,         creditLineConstants[_id].borrowAsset     );      uint256 currentDebt = calculateCurrentDebt(_id);     uint256 currentCollateralRatio = calculateTotalCollateralTokens(_id).mul(_ratioOfPrices).div(currentDebt).mul(10**30).div(         10**_decimals     );      return currentCollateralRatio; }  /**  * @notice used to calculate the total collateral tokens  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view  * @param _id identifier for the credit line  * @return _amount total collateral tokens deposited into the credit line  */ function calculateTotalCollateralTokens(uint256 _id) public returns (uint256 _amount) {     address _collateralAsset = creditLineConstants[_id].collateralAsset;     address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();     uint256 _liquidityShares;     for (uint256 index = 0; index &lt; _strategyList.length; index++) {         if (_strategyList[index] == address(0)) {             continue;         }         _liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];         uint256 _tokenInStrategy = _liquidityShares;         _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(_liquidityShares, _collateralAsset);          _amount = _amount.add(_tokenInStrategy);     } }  /**  * @notice used to withdraw any excess collateral  * @dev collateral can't be withdraw if collateralRatio goes below the ideal value. Only borrower can withdraw  * @param _id identifier for the credit line  * @param _amount amount of collateral to withdraw  * @param _toSavingsAccount if true, tokens are transferred from savingsAccount                              otherwise direct from collateral token contract  */ function withdrawCollateral(     uint256 _id,     uint256 _amount,     bool _toSavingsAccount ) external nonReentrant onlyCreditLineBorrower(_id) {     uint256 _withdrawableCollateral = withdrawableCollateral(_id);     require(_amount &lt;= _withdrawableCollateral, 'Collateral ratio cant go below ideal');     address _collateralAsset = creditLineConstants[_id].collateralAsset;     _transferCollateral(_id, _collateralAsset, _amount, _toSavingsAccount);     emit CollateralWithdrawn(_id, _amount); }  /**  * @notice used to calculate the collateral that can be withdrawn  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view  * @param _id identifier for the credit line  * @return total collateral withdrawable by borrower  */ function withdrawableCollateral(uint256 _id) public returns (uint256) {     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(         creditLineConstants[_id].collateralAsset,         creditLineConstants[_id].borrowAsset     );      uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);     uint256 _currentDebt = calculateCurrentDebt(_id);      uint256 _collateralNeeded = _currentDebt         .mul(creditLineConstants[_id].idealCollateralRatio)         .div(_ratioOfPrices)         .mul(10**_decimals)         .div(10**30);      if (_collateralNeeded &gt;= _totalCollateralTokens) {         return 0;     }     return _totalCollateralTokens.sub(_collateralNeeded); }  function _transferCollateral(     uint256 _id,     address _asset,     uint256 _amountInTokens,     bool _toSavingsAccount ) internal {     address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();     uint256 _activeAmount;     for (uint256 index = 0; index &lt; _strategyList.length; index++) {         uint256 liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];         if (liquidityShares == 0 || _strategyList[index] == address(0)) {             continue;         }         uint256 _tokenInStrategy = liquidityShares;         _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(liquidityShares, _asset);         uint256 _tokensToTransfer = _tokenInStrategy;         if (_activeAmount.add(_tokenInStrategy) &gt; _amountInTokens) {             _tokensToTransfer = _amountInTokens.sub(_activeAmount);             liquidityShares = liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy);         }         _activeAmount = _activeAmount.add(_tokensToTransfer);         collateralShareInStrategy[_id][_strategyList[index]] = collateralShareInStrategy[_id][_strategyList[index]].sub(             liquidityShares         );         if (_toSavingsAccount) {             ISavingsAccount(savingsAccount).transfer(_tokensToTransfer, _asset, _strategyList[index], msg.sender);         } else {             ISavingsAccount(savingsAccount).withdraw(_tokensToTransfer, _asset, _strategyList[index], msg.sender, false);         }          if (_activeAmount == _amountInTokens) {             return;         }     }     revert('insufficient collateral'); }  /**  * @notice used to liquidate credit line in case collateral ratio goes below the threshold  * @dev if lender liquidates, then collateral is directly transferred.          If autoLiquidation is true, anyone can liquidate by providing enough borrow tokens  * @param _id identifier for the credit line  * @param _toSavingsAccount if true, tokens are transferred from savingsAccount                              otherwise direct from collateral token contract  */ function liquidate(uint256 _id, bool _toSavingsAccount) external payable nonReentrant {     require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: Credit line should be active.');     require(creditLineVariables[_id].principal != 0, 'CreditLine: cannot liquidate if principal is 0');      uint256 currentCollateralRatio = calculateCurrentCollateralRatio(_id);     require(         currentCollateralRatio &lt; creditLineConstants[_id].idealCollateralRatio,         'CreditLine: Collateral ratio is higher than ideal value'     );      address _collateralAsset = creditLineConstants[_id].collateralAsset;     address _lender = creditLineConstants[_id].lender;     uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);     address _borrowAsset = creditLineConstants[_id].borrowAsset;      creditLineVariables[_id].status = CreditLineStatus.LIQUIDATED;      if (creditLineConstants[_id].autoLiquidation &amp;&amp; _lender != msg.sender) {         uint256 _borrowTokens = _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens);         if (_borrowAsset == address(0)) {             uint256 _returnETH = msg.value.sub(_borrowTokens, 'Insufficient ETH to liquidate');             if (_returnETH != 0) {                 (bool success, ) = msg.sender.call{value: _returnETH}('');                 require(success, 'Transfer fail');             }         } else {             IERC20(_borrowAsset).safeTransferFrom(msg.sender, _lender, _borrowTokens);         }     }      _transferCollateral(_id, _collateralAsset, _totalCollateralTokens, _toSavingsAccount);      emit CreditLineLiquidated(_id, msg.sender); }  /**  * @notice used to calculate the borrow tokens necessary for liquidator to liquidate  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view  * @param _id identifier for the credit line  * @return borrow tokens necessary for liquidator to liquidate  */ function borrowTokensToLiquidate(uint256 _id) external returns (uint256) {     address _collateralAsset = creditLineConstants[_id].collateralAsset;     uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);     address _borrowAsset = creditLineConstants[_id].borrowAsset;      return _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens); }  function _borrowTokensToLiquidate(     address _borrowAsset,     address _collateralAsset,     uint256 _totalCollateralTokens ) internal view returns (uint256) {     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(_borrowAsset, _collateralAsset);     uint256 _borrowTokens = (         _totalCollateralTokens.mul(uint256(10**30).sub(liquidatorRewardFraction)).div(10**30).mul(_ratioOfPrices).div(10**_decimals)     );      return _borrowTokens; }  receive() external payable {     require(msg.sender == savingsAccount, 'CreditLine::receive invalid transaction'); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **phase_prompt** | Below are the details of our smart contract codes and their corresponding analysis reports: Task: "{task}". As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report. |
| **phase_name** | BugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 3, 'task': '', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-22-08 11:43:42 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol'; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/utils/ReentrancyGuard.sol'; import '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol'; import '../interfaces/IPriceOracle.sol'; import '../interfaces/IYield.sol'; import '../interfaces/ISavingsAccount.sol'; import '../SavingsAccount/SavingsAccountUtil.sol'; import '../interfaces/IStrategyRegistry.sol'; /  * @title Credit Line contract with Methods related to credit Line  * @notice Implements the functions related to Credit Line  * @author Sublime  / contract CreditLine is ReentrancyGuard, OwnableUpgradeable {     using SafeERC20 for IERC20;     using SafeMath for uint256; enum CreditLineStatus {     NOT_CREATED,     REQUESTED,     ACTIVE,     CLOSED,     CANCELLED,     LIQUIDATED }  /**  * @notice counter that tracks the number of credit lines created  * @dev used to create unique identifier for credit lines  **/ uint256 public creditLineCounter;  uint256 constant YEAR_IN_SECONDS = 365 days;  struct CreditLineVariables {     CreditLineStatus status;     uint256 principal;     uint256 totalInterestRepaid;     uint256 lastPrincipalUpdateTime;     uint256 interestAccruedTillLastPrincipalUpdate; }  struct CreditLineConstants {     address lender;     address borrower;     uint256 borrowLimit;     uint256 idealCollateralRatio;     uint256 borrowRate;     address borrowAsset;     address collateralAsset;     bool autoLiquidation;     bool requestByLender; } /**  * @notice stores the collateral shares in a credit line per strategy  * @dev creditLineId =&gt; Strategy =&gt; collateralShares  **/ mapping(uint256 =&gt; mapping(address =&gt; uint256)) public collateralShareInStrategy;  /**  * @notice stores the variables to maintain a credit line  **/ mapping(uint256 =&gt; CreditLineVariables) public creditLineVariables;  /**  * @notice stores the constants related to a credit line  **/ mapping(uint256 =&gt; CreditLineConstants) public creditLineConstants;  /**  * @notice stores the address of savings account contract  **/ address public savingsAccount;  /**  * @notice stores the address of price oracle contract  **/ address public priceOracle;  /**  * @notice stores the address of strategy registry contract  **/ address public strategyRegistry;  /**  * @notice stores the address of default strategy  **/ address public defaultStrategy;  /**  * @notice stores the fraction of borrowed amount charged as fee by protocol  * @dev it is multiplied by 10**30  **/ uint256 public protocolFeeFraction;  /**  * @notice address where protocol fee is collected  **/ address public protocolFeeCollector;  /**  * @notice stores the fraction of amount liquidated given as reward to liquidator  * @dev it is multiplied by 10**30  **/ uint256 public liquidatorRewardFraction; /**  * @dev checks if Credit Line exists  * @param _id identifier for the credit line  **/ modifier ifCreditLineExists(uint256 _id) {     require(creditLineVariables[_id].status != CreditLineStatus.NOT_CREATED, 'Credit line does not exist');     _; }  /**  * @dev checks if called by credit Line Borrower  * @param _id creditLine identifier  **/ modifier onlyCreditLineBorrower(uint256 _id) {     require(creditLineConstants[_id].borrower == msg.sender, 'Only credit line Borrower can access');     _; }  /**  * @dev checks if called by credit Line Lender  * @param _id creditLine identifier  **/ modifier onlyCreditLineLender(uint256 _id) {     require(creditLineConstants[_id].lender == msg.sender, 'Only credit line Lender can access');     _; }  /**  * @notice emitted when a collateral is deposited into credit line  * @param id id of the credit line  * @param amount amount of collateral deposited  * @param strategy address of the strategy into which collateral is deposited  */ event CollateralDeposited(uint256 indexed id, uint256 amount, address indexed strategy);  /**  * @notice emitted when collateral is withdrawn from credit line  * @param id id of the credit line  * @param amount amount of collateral withdrawn  */ event CollateralWithdrawn(uint256 indexed id, uint256 amount);  /**  * @notice emitted when a request for new credit line is placed  * @param id id of the credit line for which request was made  * @param lender address of the lender for credit line  * @param borrower address of the borrower for credit line  */ event CreditLineRequested(uint256 indexed id, address indexed lender, address indexed borrower);  /**  * @notice emitted when a credit line is liquidated  * @param id id of the credit line which is liquidated  * @param liquidator address of the liquidator  */ event CreditLineLiquidated(uint256 indexed id, address indexed liquidator);  /**  * @notice emitted when tokens are borrowed from credit line  * @param id id of the credit line from which tokens are borrowed  * @param borrowAmount amount of tokens borrowed  */ event BorrowedFromCreditLine(uint256 indexed id, uint256 borrowAmount);  /**  * @notice emitted when credit line is accepted  * @param id id of the credit line that was accepted  */ event CreditLineAccepted(uint256 indexed id);  /**  * @notice emitted when credit line is completely repaid and reset  * @param id id of the credit line that is reset  */ event CreditLineReset(uint256 indexed id);  /**  * @notice emitted when the credit line is partially repaid  * @param id id of the credit line  * @param repayAmount amount repaid  */ event PartialCreditLineRepaid(uint256 indexed id, uint256 repayAmount);  /**  * @notice emitted when the credit line is completely repaid  * @param id id of the credit line  * @param repayAmount amount repaid  */ event CompleteCreditLineRepaid(uint256 indexed id, uint256 repayAmount);  /**  * @notice emitted when the credit line is closed by one of the parties of credit line  * @param id id of the credit line  */ event CreditLineClosed(uint256 indexed id);  /**  * @notice emitted when default strategy for the credit line is updated  * @param defaultStrategy address of the strategy contract that is used as default by credit lines  */ event DefaultStrategyUpdated(address indexed defaultStrategy);  /**  * @notice emitted when the price oracle is updated  * @param priceOracle address of the updated price oracle  */ event PriceOracleUpdated(address indexed priceOracle);  /**  * @notice emitted when the savings account address is updated  * @param savingsAccount address of the updated savingsAccount  */ event SavingsAccountUpdated(address indexed savingsAccount);  /**  * @notice emitted when strategy registry address is updated  * @param strategyRegistry address of the updated strategy registry  */ event StrategyRegistryUpdated(address indexed strategyRegistry);  /**  * @notice emitted when fee that protocol charges for credit line is updated  * @param updatedProtocolFee updated value of protocolFeeFraction  */ event ProtocolFeeFractionUpdated(uint256 updatedProtocolFee);  /**  * @notice emitted when address which receives fee that protocol changes for pools is updated  * @param updatedProtocolFeeCollector updated value of protocolFeeCollector  */ event ProtocolFeeCollectorUpdated(address indexed updatedProtocolFeeCollector);  /**  * @notice emitted when liquidatorRewardFraction is updated  * @param liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator  */ event LiquidationRewardFractionUpdated(uint256 liquidatorRewardFraction);  /**  * @notice used to initialize the contract  * @dev can only be called once during the life cycle of the contract  * @param _defaultStrategy default strategy used in credit lines  * @param _priceOracle address of the priceOracle  * @param _savingsAccount address of  the savings account contract  * @param _strategyRegistry address of the strategy registry contract  * @param _owner address of owner who can change global variables  * @param _protocolFeeFraction fraction of the fee charged by protocol  * @param _protocolFeeCollector address to which protocol fee is charged to  * @param _liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator  */ function initialize(     address _defaultStrategy,     address _priceOracle,     address _savingsAccount,     address _strategyRegistry,     address _owner,     uint256 _protocolFeeFraction,     address _protocolFeeCollector,     uint256 _liquidatorRewardFraction ) external initializer {     OwnableUpgradeable.__Ownable_init();     OwnableUpgradeable.transferOwnership(_owner);      _updateDefaultStrategy(_defaultStrategy);     _updatePriceOracle(_priceOracle);     _updateSavingsAccount(_savingsAccount);     _updateStrategyRegistry(_strategyRegistry);     _updateProtocolFeeFraction(_protocolFeeFraction);     _updateProtocolFeeCollector(_protocolFeeCollector);     _updateLiquidatorRewardFraction(_liquidatorRewardFraction); }  /**  * @notice used to update the default strategy  * @dev can only be updated by owner  * @param _defaultStrategy address of the updated default strategy  */ function updateDefaultStrategy(address _defaultStrategy) external onlyOwner {     _updateDefaultStrategy(_defaultStrategy); }  function _updateDefaultStrategy(address _defaultStrategy) internal {     defaultStrategy = _defaultStrategy;     emit DefaultStrategyUpdated(_defaultStrategy); }  /**  * @notice used to update the price oracle  * @dev can only be updated by owner  * @param _priceOracle address of the updated price oracle  */ function updatePriceOracle(address _priceOracle) external onlyOwner {     _updatePriceOracle(_priceOracle); }  function _updatePriceOracle(address _priceOracle) internal {     priceOracle = _priceOracle;     emit PriceOracleUpdated(_priceOracle); }  /**  * @notice used to update the savings account address  * @dev can only be updated by owner  * @param _savingsAccount address of the updated savings account  */ function updateSavingsAccount(address _savingsAccount) external onlyOwner {     _updateSavingsAccount(_savingsAccount); }  function _updateSavingsAccount(address _savingsAccount) internal {     savingsAccount = _savingsAccount;     emit SavingsAccountUpdated(_savingsAccount); }  /**  * @notice used to update the protocol fee fraction  * @dev can only be updated by owner  * @param _protocolFee fraction of the borrower amount collected as protocol fee  */ function updateProtocolFeeFraction(uint256 _protocolFee) external onlyOwner {     _updateProtocolFeeFraction(_protocolFee); }  function _updateProtocolFeeFraction(uint256 _protocolFee) internal {     protocolFeeFraction = _protocolFee;     emit ProtocolFeeFractionUpdated(_protocolFee); }  /**  * @notice used to update the protocol fee collector  * @dev can only be updated by owner  * @param _protocolFeeCollector address in which protocol fee is collected  */ function updateProtocolFeeCollector(address _protocolFeeCollector) external onlyOwner {     _updateProtocolFeeCollector(_protocolFeeCollector); }  function _updateProtocolFeeCollector(address _protocolFeeCollector) internal {     require(_protocolFeeCollector != address(0), 'cant be 0 address');     protocolFeeCollector = _protocolFeeCollector;     emit ProtocolFeeCollectorUpdated(_protocolFeeCollector); }  /**  * @notice used to update the strategy registry address  * @dev can only be updated by owner  * @param _strategyRegistry address of the updated strategy registry  */ function updateStrategyRegistry(address _strategyRegistry) external onlyOwner {     _updateStrategyRegistry(_strategyRegistry); }  function _updateStrategyRegistry(address _strategyRegistry) internal {     require(_strategyRegistry != address(0), 'CL::I zero address');     strategyRegistry = _strategyRegistry;     emit StrategyRegistryUpdated(_strategyRegistry); }  /**  * @notice used to update the liquidatorRewardFraction  * @dev can only be updated by owner  * @param _rewardFraction fraction of liquidated amount given to liquidator as reward  */ function updateLiquidatorRewardFraction(uint256 _rewardFraction) external onlyOwner {     _updateLiquidatorRewardFraction(_rewardFraction); }  function _updateLiquidatorRewardFraction(uint256 _rewardFraction) internal {     require(_rewardFraction &lt;= 10**30, 'Fraction has to be less than 1');     liquidatorRewardFraction = _rewardFraction;     emit LiquidationRewardFractionUpdated(_rewardFraction); }  /**  * @dev Used to Calculate Interest Per second on given principal and Interest rate  * @param _principal principal Amount for which interest has to be calculated.  * @param _borrowRate It is the Interest Rate at which Credit Line is approved  * @return interest per second for the given parameters  */ function calculateInterest(     uint256 _principal,     uint256 _borrowRate,     uint256 _timeElapsed ) public pure returns (uint256) {     uint256 _interest = _principal.mul(_borrowRate).mul(_timeElapsed).div(10**30).div(YEAR_IN_SECONDS);      return _interest; }  /**  * @dev Used to calculate interest accrued since last repayment  * @param _id identifier for the credit line  * @return interest accrued over current borrowed amount since last repayment  */  function calculateInterestAccrued(uint256 _id) public view returns (uint256) {     uint256 _lastPrincipalUpdateTime = creditLineVariables[_id].lastPrincipalUpdateTime;     if (_lastPrincipalUpdateTime == 0) return 0;     uint256 _timeElapsed = (block.timestamp).sub(_lastPrincipalUpdateTime);     uint256 _interestAccrued = calculateInterest(creditLineVariables[_id].principal, creditLineConstants[_id].borrowRate, _timeElapsed);     return _interestAccrued; }  /**  * @dev Used to calculate current debt of borrower against a credit line.  * @param _id identifier for the credit line  * @return current debt of borrower  */ function calculateCurrentDebt(uint256 _id) public view returns (uint256) {     uint256 _interestAccrued = calculateInterestAccrued(_id);     uint256 _currentDebt = (creditLineVariables[_id].principal)         .add(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate)         .add(_interestAccrued)         .sub(creditLineVariables[_id].totalInterestRepaid);     return _currentDebt; }  /**  * @notice used to calculate amount that can be borrowed by the borrower  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view.         borrowableAmount changes per block as interest changes per block.  * @param _id identifier for the credit line  * @return amount that can be borrowed from the credit line  */ function calculateBorrowableAmount(uint256 _id) public returns (uint256) {     CreditLineStatus _status = creditLineVariables[_id].status;     require(         _status == CreditLineStatus.ACTIVE || _status == CreditLineStatus.REQUESTED,         'CreditLine: Cannot only if credit line ACTIVE or REQUESTED'     );     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(         creditLineConstants[_id].collateralAsset,         creditLineConstants[_id].borrowAsset     );      uint256 _totalCollateralToken = calculateTotalCollateralTokens(_id);      uint256 _currentDebt = calculateCurrentDebt(_id);      uint256 _maxPossible = _totalCollateralToken.mul(_ratioOfPrices).div(creditLineConstants[_id].idealCollateralRatio).mul(10**30).div(         10**_decimals     );      uint256 _borrowLimit = creditLineConstants[_id].borrowLimit;      if (_maxPossible &gt; _borrowLimit) {         _maxPossible = _borrowLimit;     }     if (_maxPossible &gt; _currentDebt) {         return _maxPossible.sub(_currentDebt);     }     return 0; }  function updateinterestAccruedTillLastPrincipalUpdate(uint256 _id) internal {     require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');      uint256 _interestAccrued = calculateInterestAccrued(_id);     uint256 _newInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(_interestAccrued);     creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _newInterestAccrued; }  function _depositCollateralFromSavingsAccount(     uint256 _id,     uint256 _amount,     address _sender ) internal {     address _collateralAsset = creditLineConstants[_id].collateralAsset;     address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();     ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);     uint256 _activeAmount;      for (uint256 _index = 0; _index &lt; _strategyList.length; _index++) {         address _strategy = _strategyList[_index];         uint256 _liquidityShares = _savingsAccount.balanceInShares(_sender, _collateralAsset, _strategy);         if (_liquidityShares == 0 || _strategyList[_index] == address(0)) {             continue;         }         uint256 _tokenInStrategy = _liquidityShares;         _tokenInStrategy = IYield(_strategy).getTokensForShares(_liquidityShares, _collateralAsset);          uint256 _tokensToTransfer = _tokenInStrategy;         if (_activeAmount.add(_tokenInStrategy) &gt;= _amount) {             _tokensToTransfer = (_amount.sub(_activeAmount));         }         _activeAmount = _activeAmount.add(_tokensToTransfer);         _savingsAccount.transferFrom(_tokensToTransfer, _collateralAsset, _strategy, _sender, address(this));          collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(             _liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy)         );          if (_amount == _activeAmount) {             return;         }     }     revert('CreditLine::_depositCollateralFromSavingsAccount - Insufficient balance'); }  /**  * @notice used to request a credit line either by borrower or lender  * @param _requestTo Address to which creditLine is requested,                      if borrower creates request then lender address and                      if lender creates then borrower address  * @param _borrowLimit maximum borrow amount in a credit line  * @param _borrowRate Interest Rate at which credit Line is requested  * @param _autoLiquidation if true, anyone can liquidate loan, otherwise only lender  * @param _collateralRatio ratio of the collateral to the debt below which credit line can be liquidated  * @param _borrowAsset address of the token to be borrowed  * @param _collateralAsset address of the token provided as collateral  * @param _requestAsLender if true, lender is placing request, otherwise borrower  * @return identifier for the credit line  */  function request(     address _requestTo,     uint256 _borrowLimit,     uint256 _borrowRate,     bool _autoLiquidation,     uint256 _collateralRatio,     address _borrowAsset,     address _collateralAsset,     bool _requestAsLender ) external returns (uint256) {     require(_borrowAsset != _collateralAsset, 'R: cant borrow lent token');     require(IPriceOracle(priceOracle).doesFeedExist(_borrowAsset, _collateralAsset), 'R: No price feed');      address _lender = _requestTo;     address _borrower = msg.sender;     if (_requestAsLender) {         _lender = msg.sender;         _borrower = _requestTo;     }      uint256 _id = _createRequest(         _lender,         _borrower,         _borrowLimit,         _borrowRate,         _autoLiquidation,         _collateralRatio,         _borrowAsset,         _collateralAsset,         _requestAsLender     );      emit CreditLineRequested(_id, _lender, _borrower);     return _id; }  function _createRequest(     address _lender,     address _borrower,     uint256 _borrowLimit,     uint256 _borrowRate,     bool _autoLiquidation,     uint256 _collateralRatio,     address _borrowAsset,     address _collateralAsset,     bool _requestByLender ) internal returns (uint256) {     require(_lender != _borrower, 'Lender and Borrower cannot be same addresses');     uint256 _id = creditLineCounter + 1;     creditLineCounter = _id;     creditLineVariables[_id].status = CreditLineStatus.REQUESTED;     creditLineConstants[_id].borrower = _borrower;     creditLineConstants[_id].lender = _lender;     creditLineConstants[_id].borrowLimit = _borrowLimit;     creditLineConstants[_id].autoLiquidation = _autoLiquidation;     creditLineConstants[_id].idealCollateralRatio = _collateralRatio;     creditLineConstants[_id].borrowRate = _borrowRate;     creditLineConstants[_id].borrowAsset = _borrowAsset;     creditLineConstants[_id].collateralAsset = _collateralAsset;     creditLineConstants[_id].requestByLender = _requestByLender;     return _id; }  /**  * @notice used to accept a credit line  * @dev if borrower places request, lender can accept and vice versa  * @param _id identifier for the credit line  */ function accept(uint256 _id) external {     require(         creditLineVariables[_id].status == CreditLineStatus.REQUESTED,         'CreditLine::acceptCreditLineLender - CreditLine is already accepted'     );     bool _requestByLender = creditLineConstants[_id].requestByLender;     require(         (msg.sender == creditLineConstants[_id].borrower &amp;&amp; _requestByLender) ||             (msg.sender == creditLineConstants[_id].lender &amp;&amp; !_requestByLender),         "Only Borrower or Lender who hasn't requested can accept"     );     creditLineVariables[_id].status = CreditLineStatus.ACTIVE;     emit CreditLineAccepted(_id); }  /**  * @notice used to deposit collateral into the credit line  * @dev collateral tokens have to be approved in savingsAccount or token contract(unless ether).         If transferred from savings account, the tokens are transferred from strategies in the          order prespecified in strategy registry  * @param _id identifier for the credit line  * @param _amount amount of collateral being deposited  * @param _strategy strategy to which collateral is to be deposited in case transfer is not from savings account  * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount                              otherwise direct from collateral token contract  */ function depositCollateral(     uint256 _id,     uint256 _amount,     address _strategy,     bool _fromSavingsAccount ) external payable nonReentrant ifCreditLineExists(_id) {     require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine not active');     _depositCollateral(_id, _amount, _strategy, _fromSavingsAccount);     emit CollateralDeposited(_id, _amount, _strategy); }  function _depositCollateral(     uint256 _id,     uint256 _amount,     address _strategy,     bool _fromSavingsAccount ) internal {     require(creditLineConstants[_id].lender != msg.sender, 'lender cant deposit collateral');     if (_fromSavingsAccount) {         _depositCollateralFromSavingsAccount(_id, _amount, msg.sender);     } else {         address _collateralAsset = creditLineConstants[_id].collateralAsset;         ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);         if (_collateralAsset == address(0)) {             require(msg.value == _amount, "CreditLine::_depositCollateral - value to transfer doesn't match argument");         } else {             IERC20(_collateralAsset).safeTransferFrom(msg.sender, address(this), _amount);             IERC20(_collateralAsset).approve(_strategy, _amount);         }         uint256 _sharesReceived = _savingsAccount.deposit{value: msg.value}(_amount, _collateralAsset, _strategy, address(this));         collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(_sharesReceived);     } }  function _withdrawBorrowAmount(     address _asset,     uint256 _amountInTokens,     address _lender ) internal {     address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();     ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);     uint256 _activeAmount;     for (uint256 _index = 0; _index &lt; _strategyList.length; _index++) {         if (_strategyList[_index] == address(0)) {             continue;         }         uint256 _liquidityShares = _savingsAccount.balanceInShares(_lender, _asset, _strategyList[_index]);         if (_liquidityShares != 0) {             uint256 tokenInStrategy = _liquidityShares;             tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);             uint256 _tokensToTransfer = tokenInStrategy;             if (_activeAmount.add(tokenInStrategy) &gt;= _amountInTokens) {                 _tokensToTransfer = (_amountInTokens.sub(_activeAmount));             }             _activeAmount = _activeAmount.add(_tokensToTransfer);             _savingsAccount.withdrawFrom(_tokensToTransfer, _asset, _strategyList[_index], _lender, address(this), false);             if (_activeAmount == _amountInTokens) {                 return;             }         }     }     require(_activeAmount == _amountInTokens, 'insufficient balance'); }  /**  * @notice used to borrow tokens from credit line by borrower  * @dev only borrower can call this function. Amount that can actually be borrowed is          min(amount based on borrowLimit, allowance to creditLine contract, balance of lender)  * @param _id identifier for the credit line  * @param _amount amount of tokens to borrow  */ function borrow(uint256 _id, uint256 _amount) external payable nonReentrant onlyCreditLineBorrower(_id) {     require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');     uint256 _borrowableAmount = calculateBorrowableAmount(_id);     require(_amount &lt;= _borrowableAmount, "CreditLine::borrow - The current collateral ratio doesn't allow to withdraw the amount");     address _borrowAsset = creditLineConstants[_id].borrowAsset;     address _lender = creditLineConstants[_id].lender;      updateinterestAccruedTillLastPrincipalUpdate(_id);     creditLineVariables[_id].principal = creditLineVariables[_id].principal.add(_amount);     creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;      uint256 _tokenDiffBalance;     if (_borrowAsset != address(0)) {         uint256 _balanceBefore = IERC20(_borrowAsset).balanceOf(address(this));         _withdrawBorrowAmount(_borrowAsset, _amount, _lender);         uint256 _balanceAfter = IERC20(_borrowAsset).balanceOf(address(this));         _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);     } else {         uint256 _balanceBefore = address(this).balance;         _withdrawBorrowAmount(_borrowAsset, _amount, _lender);         uint256 _balanceAfter = address(this).balance;         _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);     }     uint256 _protocolFee = _tokenDiffBalance.mul(protocolFeeFraction).div(10**30);     _tokenDiffBalance = _tokenDiffBalance.sub(_protocolFee);      if (_borrowAsset == address(0)) {         (bool feeSuccess, ) = protocolFeeCollector.call{value: _protocolFee}('');         require(feeSuccess, 'Transfer fail');         (bool success, ) = msg.sender.call{value: _tokenDiffBalance}('');         require(success, 'Transfer fail');     } else {         IERC20(_borrowAsset).safeTransfer(protocolFeeCollector, _protocolFee);         IERC20(_borrowAsset).safeTransfer(msg.sender, _tokenDiffBalance);     }     emit BorrowedFromCreditLine(_id, _tokenDiffBalance); }  function _repayFromSavingsAccount(     uint256 _amount,     address _asset,     address _lender ) internal {     address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();     ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);     uint256 _activeAmount;      for (uint256 _index = 0; _index &lt; _strategyList.length; _index++) {         if (_strategyList[_index] == address(0)) {             continue;         }         uint256 _liquidityShares = _savingsAccount.balanceInShares(msg.sender, _asset, _strategyList[_index]);         if (_liquidityShares == 0) {             continue;         }         uint256 _tokenInStrategy = _liquidityShares;         _tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);          uint256 _tokensToTransfer = _tokenInStrategy;         if (_activeAmount.add(_tokenInStrategy) &gt;= _amount) {             _tokensToTransfer = (_amount.sub(_activeAmount));         }         _activeAmount = _activeAmount.add(_tokensToTransfer);         _savingsAccount.transferFrom(_tokensToTransfer, _asset, _strategyList[_index], msg.sender, _lender);          if (_amount == _activeAmount) {             return;         }     }     revert('CreditLine::_repayFromSavingsAccount - Insufficient balance'); }  function _repay(     uint256 _id,     uint256 _amount,     bool _fromSavingsAccount,     uint256 _principalPaid ) internal {     ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);     address _defaultStrategy = defaultStrategy;     address _borrowAsset = creditLineConstants[_id].borrowAsset;     address _lender = creditLineConstants[_id].lender;     if (!_fromSavingsAccount) {         if (_borrowAsset == address(0)) {             require(msg.value == _amount, 'creditLine::repay - Ether sent not equal to repay amount');             _savingsAccount.deposit{value: _amount}(_amount, _borrowAsset, _defaultStrategy, _lender);         } else {             IERC20(_borrowAsset).safeTransferFrom(msg.sender, address(this), _amount);             IERC20(_borrowAsset).approve(_defaultStrategy, _amount);             _savingsAccount.deposit(_amount, _borrowAsset, _defaultStrategy, _lender);         }     } else {         _repayFromSavingsAccount(_amount, _borrowAsset, _lender);     }     if (_principalPaid != 0) {         _savingsAccount.increaseAllowanceToCreditLine(_principalPaid, _borrowAsset, _lender);     } }  /**  * @notice used to repay interest and principal to credit line. Interest has to be repaid before repaying principal  * @dev partial repayments possible  * @param _id identifier for the credit line  * @param _amount amount being repaid  * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount                              otherwise direct from collateral token contract  */ function repay(     uint256 _id,     uint256 _amount,     bool _fromSavingsAccount ) external payable nonReentrant {     require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');     require(creditLineConstants[_id].lender != msg.sender, 'Lender cant repay');      uint256 _interestSincePrincipalUpdate = calculateInterestAccrued(_id);     uint256 _totalInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(         _interestSincePrincipalUpdate     );     uint256 _interestToPay = _totalInterestAccrued.sub(creditLineVariables[_id].totalInterestRepaid);     uint256 _totalCurrentDebt = _interestToPay.add(creditLineVariables[_id].principal);     uint256 _principalPaid = 0;      if (_amount &gt;= _totalCurrentDebt) {         _amount = _totalCurrentDebt;         emit CompleteCreditLineRepaid(_id, _amount);     } else {         emit PartialCreditLineRepaid(_id, _amount);     }      if (_amount &gt; _interestToPay) {         creditLineVariables[_id].principal = _totalCurrentDebt.sub(_amount);         creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _totalInterestAccrued;         creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;         creditLineVariables[_id].totalInterestRepaid = _totalInterestAccrued;         _principalPaid = _amount.sub(_interestToPay);     } else {         creditLineVariables[_id].totalInterestRepaid = creditLineVariables[_id].totalInterestRepaid.add(_amount);     }      _repay(_id, _amount, _fromSavingsAccount, _principalPaid);      if (creditLineVariables[_id].principal == 0) {         _resetCreditLine(_id);     } }  function _resetCreditLine(uint256 _id) internal {     creditLineVariables[_id].lastPrincipalUpdateTime = 0;     creditLineVariables[_id].totalInterestRepaid = 0;     creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = 0;     emit CreditLineReset(_id); }  /**  * @dev used to close credit line by borrower or lender  * @param _id identifier for the credit line  */ function close(uint256 _id) external ifCreditLineExists(_id) {     require(         msg.sender == creditLineConstants[_id].borrower || msg.sender == creditLineConstants[_id].lender,         'CreditLine: Permission denied while closing Line of credit'     );     require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: Credit line should be active.');     require(creditLineVariables[_id].principal == 0, 'CreditLine: Cannot be closed since not repaid.');     require(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate == 0, 'CreditLine: Cannot be closed since not repaid.');     creditLineVariables[_id].status = CreditLineStatus.CLOSED;     emit CreditLineClosed(_id); }  /**  * @notice used to calculate the current collateral ratio  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view.         Interest is also considered while calculating debt  * @param _id identifier for the credit line  * @return collateral ratio multiplied by 10**30 to retain precision  */ function calculateCurrentCollateralRatio(uint256 _id) public ifCreditLineExists(_id) returns (uint256) {     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(         creditLineConstants[_id].collateralAsset,         creditLineConstants[_id].borrowAsset     );      uint256 currentDebt = calculateCurrentDebt(_id);     uint256 currentCollateralRatio = calculateTotalCollateralTokens(_id).mul(_ratioOfPrices).div(currentDebt).mul(10**30).div(         10**_decimals     );      return currentCollateralRatio; }  /**  * @notice used to calculate the total collateral tokens  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view  * @param _id identifier for the credit line  * @return _amount total collateral tokens deposited into the credit line  */ function calculateTotalCollateralTokens(uint256 _id) public returns (uint256 _amount) {     address _collateralAsset = creditLineConstants[_id].collateralAsset;     address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();     uint256 _liquidityShares;     for (uint256 index = 0; index &lt; _strategyList.length; index++) {         if (_strategyList[index] == address(0)) {             continue;         }         _liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];         uint256 _tokenInStrategy = _liquidityShares;         _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(_liquidityShares, _collateralAsset);          _amount = _amount.add(_tokenInStrategy);     } }  /**  * @notice used to withdraw any excess collateral  * @dev collateral can't be withdraw if collateralRatio goes below the ideal value. Only borrower can withdraw  * @param _id identifier for the credit line  * @param _amount amount of collateral to withdraw  * @param _toSavingsAccount if true, tokens are transferred from savingsAccount                              otherwise direct from collateral token contract  */ function withdrawCollateral(     uint256 _id,     uint256 _amount,     bool _toSavingsAccount ) external nonReentrant onlyCreditLineBorrower(_id) {     uint256 _withdrawableCollateral = withdrawableCollateral(_id);     require(_amount &lt;= _withdrawableCollateral, 'Collateral ratio cant go below ideal');     address _collateralAsset = creditLineConstants[_id].collateralAsset;     _transferCollateral(_id, _collateralAsset, _amount, _toSavingsAccount);     emit CollateralWithdrawn(_id, _amount); }  /**  * @notice used to calculate the collateral that can be withdrawn  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view  * @param _id identifier for the credit line  * @return total collateral withdrawable by borrower  */ function withdrawableCollateral(uint256 _id) public returns (uint256) {     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(         creditLineConstants[_id].collateralAsset,         creditLineConstants[_id].borrowAsset     );      uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);     uint256 _currentDebt = calculateCurrentDebt(_id);      uint256 _collateralNeeded = _currentDebt         .mul(creditLineConstants[_id].idealCollateralRatio)         .div(_ratioOfPrices)         .mul(10**_decimals)         .div(10**30);      if (_collateralNeeded &gt;= _totalCollateralTokens) {         return 0;     }     return _totalCollateralTokens.sub(_collateralNeeded); }  function _transferCollateral(     uint256 _id,     address _asset,     uint256 _amountInTokens,     bool _toSavingsAccount ) internal {     address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();     uint256 _activeAmount;     for (uint256 index = 0; index &lt; _strategyList.length; index++) {         uint256 liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];         if (liquidityShares == 0 || _strategyList[index] == address(0)) {             continue;         }         uint256 _tokenInStrategy = liquidityShares;         _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(liquidityShares, _asset);         uint256 _tokensToTransfer = _tokenInStrategy;         if (_activeAmount.add(_tokenInStrategy) &gt; _amountInTokens) {             _tokensToTransfer = _amountInTokens.sub(_activeAmount);             liquidityShares = liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy);         }         _activeAmount = _activeAmount.add(_tokensToTransfer);         collateralShareInStrategy[_id][_strategyList[index]] = collateralShareInStrategy[_id][_strategyList[index]].sub(             liquidityShares         );         if (_toSavingsAccount) {             ISavingsAccount(savingsAccount).transfer(_tokensToTransfer, _asset, _strategyList[index], msg.sender);         } else {             ISavingsAccount(savingsAccount).withdraw(_tokensToTransfer, _asset, _strategyList[index], msg.sender, false);         }          if (_activeAmount == _amountInTokens) {             return;         }     }     revert('insufficient collateral'); }  /**  * @notice used to liquidate credit line in case collateral ratio goes below the threshold  * @dev if lender liquidates, then collateral is directly transferred.          If autoLiquidation is true, anyone can liquidate by providing enough borrow tokens  * @param _id identifier for the credit line  * @param _toSavingsAccount if true, tokens are transferred from savingsAccount                              otherwise direct from collateral token contract  */ function liquidate(uint256 _id, bool _toSavingsAccount) external payable nonReentrant {     require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: Credit line should be active.');     require(creditLineVariables[_id].principal != 0, 'CreditLine: cannot liquidate if principal is 0');      uint256 currentCollateralRatio = calculateCurrentCollateralRatio(_id);     require(         currentCollateralRatio &lt; creditLineConstants[_id].idealCollateralRatio,         'CreditLine: Collateral ratio is higher than ideal value'     );      address _collateralAsset = creditLineConstants[_id].collateralAsset;     address _lender = creditLineConstants[_id].lender;     uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);     address _borrowAsset = creditLineConstants[_id].borrowAsset;      creditLineVariables[_id].status = CreditLineStatus.LIQUIDATED;      if (creditLineConstants[_id].autoLiquidation &amp;&amp; _lender != msg.sender) {         uint256 _borrowTokens = _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens);         if (_borrowAsset == address(0)) {             uint256 _returnETH = msg.value.sub(_borrowTokens, 'Insufficient ETH to liquidate');             if (_returnETH != 0) {                 (bool success, ) = msg.sender.call{value: _returnETH}('');                 require(success, 'Transfer fail');             }         } else {             IERC20(_borrowAsset).safeTransferFrom(msg.sender, _lender, _borrowTokens);         }     }      _transferCollateral(_id, _collateralAsset, _totalCollateralTokens, _toSavingsAccount);      emit CreditLineLiquidated(_id, msg.sender); }  /**  * @notice used to calculate the borrow tokens necessary for liquidator to liquidate  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view  * @param _id identifier for the credit line  * @return borrow tokens necessary for liquidator to liquidate  */ function borrowTokensToLiquidate(uint256 _id) external returns (uint256) {     address _collateralAsset = creditLineConstants[_id].collateralAsset;     uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);     address _borrowAsset = creditLineConstants[_id].borrowAsset;      return _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens); }  function _borrowTokensToLiquidate(     address _borrowAsset,     address _collateralAsset,     uint256 _totalCollateralTokens ) internal view returns (uint256) {     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(_borrowAsset, _collateralAsset);     uint256 _borrowTokens = (         _totalCollateralTokens.mul(uint256(10**30).sub(liquidatorRewardFraction)).div(10**30).mul(_ratioOfPrices).div(10**_decimals)     );      return _borrowTokens; }  receive() external payable {     require(msg.sender == savingsAccount, 'CreditLine::receive invalid transaction'); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-22-08 11:43:42 INFO] Security Analyst: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/utils/ReentrancyGuard.sol';
import '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';
import '../interfaces/IPriceOracle.sol';
import '../interfaces/IYield.sol';
import '../interfaces/ISavingsAccount.sol';
import '../SavingsAccount/SavingsAccountUtil.sol';
import '../interfaces/IStrategyRegistry.sol';

/**
 * @title Credit Line contract with Methods related to credit Line
 * @notice Implements the functions related to Credit Line
 * @author Sublime
 **/

contract CreditLine is ReentrancyGuard, OwnableUpgradeable {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    enum CreditLineStatus {
        NOT_CREATED,
        REQUESTED,
        ACTIVE,
        CLOSED,
        CANCELLED,
        LIQUIDATED
    }

    /**
     * @notice counter that tracks the number of credit lines created
     * @dev used to create unique identifier for credit lines
     **/
    uint256 public creditLineCounter;

    uint256 constant YEAR_IN_SECONDS = 365 days;

    struct CreditLineVariables {
        CreditLineStatus status;
        uint256 principal;
        uint256 totalInterestRepaid;
        uint256 lastPrincipalUpdateTime;
        uint256 interestAccruedTillLastPrincipalUpdate;
    }

    struct CreditLineConstants {
        address lender;
        address borrower;
        uint256 borrowLimit;
        uint256 idealCollateralRatio;
        uint256 borrowRate;
        address borrowAsset;
        address collateralAsset;
        bool autoLiquidation;
        bool requestByLender;
    }
    /**
     * @notice stores the collateral shares in a credit line per strategy
     * @dev creditLineId => Strategy => collateralShares
     **/
    mapping(uint256 => mapping(address => uint256)) public collateralShareInStrategy;

    /**
     * @notice stores the variables to maintain a credit line
     **/
    mapping(uint256 => CreditLineVariables) public creditLineVariables;

    /**
     * @notice stores the constants related to a credit line
     **/
    mapping(uint256 => CreditLineConstants) public creditLineConstants;

    /**
     * @notice stores the address of savings account contract
     **/
    address public savingsAccount;

    /**
     * @notice stores the address of price oracle contract
     **/
    address public priceOracle;

    /**
     * @notice stores the address of strategy registry contract
     **/
    address public strategyRegistry;

    /**
     * @notice stores the address of default strategy
     **/
    address public defaultStrategy;

    /**
     * @notice stores the fraction of borrowed amount charged as fee by protocol
     * @dev it is multiplied by 10**30
     **/
    uint256 public protocolFeeFraction;

    /**
     * @notice address where protocol fee is collected
     **/
    address public protocolFeeCollector;

    /**
     * @notice stores the fraction of amount liquidated given as reward to liquidator
     * @dev it is multiplied by 10**30
     **/
    uint256 public liquidatorRewardFraction;
    /**
     * @dev checks if Credit Line exists
     * @param _id identifier for the credit line
     **/
    modifier ifCreditLineExists(uint256 _id) {
        require(creditLineVariables[_id].status != CreditLineStatus.NOT_CREATED, 'Credit line does not exist');
        _;
    }

    /**
     * @dev checks if called by credit Line Borrower
     * @param _id creditLine identifier
     **/
    modifier onlyCreditLineBorrower(uint256 _id) {
        require(creditLineConstants[_id].borrower == msg.sender, 'Only credit line Borrower can access');
        _;
    }

    /**
     * @dev checks if called by credit Line Lender
     * @param _id creditLine identifier
     **/
    modifier onlyCreditLineLender(uint256 _id) {
        require(creditLineConstants[_id].lender == msg.sender, 'Only credit line Lender can access');
        _;
    }

    /**
     * @notice emitted when a collateral is deposited into credit line
     * @param id id of the credit line
     * @param amount amount of collateral deposited
     * @param strategy address of the strategy into which collateral is deposited
     */
    event CollateralDeposited(uint256 indexed id, uint256 amount, address indexed strategy);

    /**
     * @notice emitted when collateral is withdrawn from credit line
     * @param id id of the credit line
     * @param amount amount of collateral withdrawn
     */
    event CollateralWithdrawn(uint256 indexed id, uint256 amount);

    /**
     * @notice emitted when a request for new credit line is placed
     * @param id id of the credit line for which request was made
     * @param lender address of the lender for credit line
     * @param borrower address of the borrower for credit line
     */
    event CreditLineRequested(uint256 indexed id, address indexed lender, address indexed borrower);

    /**
     * @notice emitted when a credit line is liquidated
     * @param id id of the credit line which is liquidated
     * @param liquidator address of the liquidator
     */
    event CreditLineLiquidated(uint256 indexed id, address indexed liquidator);

    /**
     * @notice emitted when tokens are borrowed from credit line
     * @param id id of the credit line from which tokens are borrowed
     * @param borrowAmount amount of tokens borrowed
     */
    event BorrowedFromCreditLine(uint256 indexed id, uint256 borrowAmount);

    /**
     * @notice emitted when credit line is accepted
     * @param id id of the credit line that was accepted
     */
    event CreditLineAccepted(uint256 indexed id);

    /**
     * @notice emitted when credit line is completely repaid and reset
     * @param id id of the credit line that is reset
     */
    event CreditLineReset(uint256 indexed id);

    /**
     * @notice emitted when the credit line is partially repaid
     * @param id id of the credit line
     * @param repayAmount amount repaid
     */
    event PartialCreditLineRepaid(uint256 indexed id, uint256 repayAmount);

    /**
     * @notice emitted when the credit line is completely repaid
     * @param id id of the credit line
     * @param repayAmount amount repaid
     */
    event CompleteCreditLineRepaid(uint256 indexed id, uint256 repayAmount);

    /**
     * @notice emitted when the credit line is closed by one of the parties of credit line
     * @param id id of the credit line
     */
    event CreditLineClosed(uint256 indexed id);

    /**
     * @notice emitted when default strategy for the credit line is updated
     * @param defaultStrategy address of the strategy contract that is used as default by credit lines
     */
    event DefaultStrategyUpdated(address indexed defaultStrategy);

    /**
     * @notice emitted when the price oracle is updated
     * @param priceOracle address of the updated price oracle
     */
    event PriceOracleUpdated(address indexed priceOracle);

    /**
     * @notice emitted when the savings account address is updated
     * @param savingsAccount address of the updated savingsAccount
     */
    event SavingsAccountUpdated(address indexed savingsAccount);

    /**
     * @notice emitted when strategy registry address is updated
     * @param strategyRegistry address of the updated strategy registry
     */
    event StrategyRegistryUpdated(address indexed strategyRegistry);

    /**
     * @notice emitted when fee that protocol charges for credit line is updated
     * @param updatedProtocolFee updated value of protocolFeeFraction
     */
    event ProtocolFeeFractionUpdated(uint256 updatedProtocolFee);

    /**
     * @notice emitted when address which receives fee that protocol changes for pools is updated
     * @param updatedProtocolFeeCollector updated value of protocolFeeCollector
     */
    event ProtocolFeeCollectorUpdated(address indexed updatedProtocolFeeCollector);

    /**
     * @notice emitted when liquidatorRewardFraction is updated
     * @param liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator
     */
    event LiquidationRewardFractionUpdated(uint256 liquidatorRewardFraction);

    /**
     * @notice used to initialize the contract
     * @dev can only be called once during the life cycle of the contract
     * @param _defaultStrategy default strategy used in credit lines
     * @param _priceOracle address of the priceOracle
     * @param _savingsAccount address of  the savings account contract
     * @param _strategyRegistry address of the strategy registry contract
     * @param _owner address of owner who can change global variables
     * @param _protocolFeeFraction fraction of the fee charged by protocol
     * @param _protocolFeeCollector address to which protocol fee is charged to
     * @param _liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator
     */
    function initialize(
        address _defaultStrategy,
        address _priceOracle,
        address _savingsAccount,
        address _strategyRegistry,
        address _owner,
        uint256 _protocolFeeFraction,
        address _protocolFeeCollector,
        uint256 _liquidatorRewardFraction
    ) external initializer {
        OwnableUpgradeable.__Ownable_init();
        OwnableUpgradeable.transferOwnership(_owner);

        _updateDefaultStrategy(_defaultStrategy);
        _updatePriceOracle(_priceOracle);
        _updateSavingsAccount(_savingsAccount);
        _updateStrategyRegistry(_strategyRegistry);
        _updateProtocolFeeFraction(_protocolFeeFraction);
        _updateProtocolFeeCollector(_protocolFeeCollector);
        _updateLiquidatorRewardFraction(_liquidatorRewardFraction);
    }

    /**
     * @notice used to update the default strategy
     * @dev can only be updated by owner
     * @param _defaultStrategy address of the updated default strategy
     */
    function updateDefaultStrategy(address _defaultStrategy) external onlyOwner {
        _updateDefaultStrategy(_defaultStrategy);
    }

    function _updateDefaultStrategy(address _defaultStrategy) internal {
        defaultStrategy = _defaultStrategy;
        emit DefaultStrategyUpdated(_defaultStrategy);
    }

    /**
     * @notice used to update the price oracle
     * @dev can only be updated by owner
     * @param _priceOracle address of the updated price oracle
     */
    function updatePriceOracle(address _priceOracle) external onlyOwner {
        _updatePriceOracle(_priceOracle);
    }

    function _updatePriceOracle(address _priceOracle) internal {
        priceOracle = _priceOracle;
        emit PriceOracleUpdated(_priceOracle);
    }

    /**
     * @notice used to update the savings account address
     * @dev can only be updated by owner
     * @param _savingsAccount address of the updated savings account
     */
    function updateSavingsAccount(address _savingsAccount) external onlyOwner {
        _updateSavingsAccount(_savingsAccount);
    }

    function _updateSavingsAccount(address _savingsAccount) internal {
        savingsAccount = _savingsAccount;
        emit SavingsAccountUpdated(_savingsAccount);
    }

    /**
     * @notice used to update the protocol fee fraction
     * @dev can only be updated by owner
     * @param _protocolFee fraction of the borrower amount collected as protocol fee
     */
    function updateProtocolFeeFraction(uint256 _protocolFee) external onlyOwner {
        _updateProtocolFeeFraction(_protocolFee);
    }

    function _updateProtocolFeeFraction(uint256 _protocolFee) internal {
        protocolFeeFraction = _protocolFee;
        emit ProtocolFeeFractionUpdated(_protocolFee);
    }

    /**
     * @notice used to update the protocol fee collector
     * @dev can only be updated by owner
     * @param _protocolFeeCollector address in which protocol fee is collected
     */
    function updateProtocolFeeCollector(address _protocolFeeCollector) external onlyOwner {
        _updateProtocolFeeCollector(_protocolFeeCollector);
    }

    function _updateProtocolFeeCollector(address _protocolFeeCollector) internal {
        require(_protocolFeeCollector != address(0), 'cant be 0 address');
        protocolFeeCollector = _protocolFeeCollector;
        emit ProtocolFeeCollectorUpdated(_protocolFeeCollector);
    }

    /**
     * @notice used to update the strategy registry address
     * @dev can only be updated by owner
     * @param _strategyRegistry address of the updated strategy registry
     */
    function updateStrategyRegistry(address _strategyRegistry) external onlyOwner {
        _updateStrategyRegistry(_strategyRegistry);
    }

    function _updateStrategyRegistry(address _strategyRegistry) internal {
        require(_strategyRegistry != address(0), 'CL::I zero address');
        strategyRegistry = _strategyRegistry;
        emit StrategyRegistryUpdated(_strategyRegistry);
    }

    /**
     * @notice used to update the liquidatorRewardFraction
     * @dev can only be updated by owner
     * @param _rewardFraction fraction of liquidated amount given to liquidator as reward
     */
    function updateLiquidatorRewardFraction(uint256 _rewardFraction) external onlyOwner {
        _updateLiquidatorRewardFraction(_rewardFraction);
    }

    function _updateLiquidatorRewardFraction(uint256 _rewardFraction) internal {
        require(_rewardFraction <= 10**30, 'Fraction has to be less than 1');
        liquidatorRewardFraction = _rewardFraction;
        emit LiquidationRewardFractionUpdated(_rewardFraction);
    }

    /**
     * @dev Used to Calculate Interest Per second on given principal and Interest rate
     * @param _principal principal Amount for which interest has to be calculated.
     * @param _borrowRate It is the Interest Rate at which Credit Line is approved
     * @return interest per second for the given parameters
     */
    function calculateInterest(
        uint256 _principal,
        uint256 _borrowRate,
        uint256 _timeElapsed
    ) public pure returns (uint256) {
        uint256 _interest = _principal.mul(_borrowRate).mul(_timeElapsed).div(10**30).div(YEAR_IN_SECONDS);

        return _interest;
    }

    /**
     * @dev Used to calculate interest accrued since last repayment
     * @param _id identifier for the credit line
     * @return interest accrued over current borrowed amount since last repayment
     */

    function calculateInterestAccrued(uint256 _id) public view returns (uint256) {
        uint256 _lastPrincipalUpdateTime = creditLineVariables[_id].lastPrincipalUpdateTime;
        if (_lastPrincipalUpdateTime == 0) return 0;
        uint256 _timeElapsed = (block.timestamp).sub(_lastPrincipalUpdateTime);
        uint256 _interestAccrued = calculateInterest(creditLineVariables[_id].principal, creditLineConstants[_id].borrowRate, _timeElapsed);
        return _interestAccrued;
    }

    /**
     * @dev Used to calculate current debt of borrower against a credit line.
     * @param _id identifier for the credit line
     * @return current debt of borrower
     */
    function calculateCurrentDebt(uint256 _id) public view returns (uint256) {
        uint256 _interestAccrued = calculateInterestAccrued(_id);
        uint256 _currentDebt = (creditLineVariables[_id].principal)
            .add(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate)
            .add(_interestAccrued)
            .sub(creditLineVariables[_id].totalInterestRepaid);
        return _currentDebt;
    }

    /**
     * @notice used to calculate amount that can be borrowed by the borrower
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view.
            borrowableAmount changes per block as interest changes per block.
     * @param _id identifier for the credit line
     * @return amount that can be borrowed from the credit line
     */
    function calculateBorrowableAmount(uint256 _id) public returns (uint256) {
        CreditLineStatus _status = creditLineVariables[_id].status;
        require(
            _status == CreditLineStatus.ACTIVE || _status == CreditLineStatus.REQUESTED,
            'CreditLine: Cannot only if credit line ACTIVE or REQUESTED'
        );
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(
            creditLineConstants[_id].collateralAsset,
            creditLineConstants[_id].borrowAsset
        );

        uint256 _totalCollateralToken = calculateTotalCollateralTokens(_id);

        uint256 _currentDebt = calculateCurrentDebt(_id);

        uint256 _maxPossible = _totalCollateralToken.mul(_ratioOfPrices).div(creditLineConstants[_id].idealCollateralRatio).mul(10**30).div(
            10**_decimals
        );

        uint256 _borrowLimit = creditLineConstants[_id].borrowLimit;

        if (_maxPossible > _borrowLimit) {
            _maxPossible = _borrowLimit;
        }
        if (_maxPossible > _currentDebt) {
            return _maxPossible.sub(_currentDebt);
        }
        return 0;
    }

    function updateinterestAccruedTillLastPrincipalUpdate(uint256 _id) internal {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');

        uint256 _interestAccrued = calculateInterestAccrued(_id);
        uint256 _newInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(_interestAccrued);
        creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _newInterestAccrued;
    }

    function _depositCollateralFromSavingsAccount(
        uint256 _id,
        uint256 _amount,
        address _sender
    ) internal {
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        uint256 _activeAmount;

        for (uint256 _index = 0; _index < _strategyList.length; _index++) {
            address _strategy = _strategyList[_index];
            uint256 _liquidityShares = _savingsAccount.balanceInShares(_sender, _collateralAsset, _strategy);
            if (_liquidityShares == 0 || _strategyList[_index] == address(0)) {
                continue;
            }
            uint256 _tokenInStrategy = _liquidityShares;
            _tokenInStrategy = IYield(_strategy).getTokensForShares(_liquidityShares, _collateralAsset);

            uint256 _tokensToTransfer = _tokenInStrategy;
            if (_activeAmount.add(_tokenInStrategy) >= _amount) {
                _tokensToTransfer = (_amount.sub(_activeAmount));
            }
            _activeAmount = _activeAmount.add(_tokensToTransfer);
            _savingsAccount.transferFrom(_tokensToTransfer, _collateralAsset, _strategy, _sender, address(this));

            collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(
                _liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy)
            );

            if (_amount == _activeAmount) {
                return;
            }
        }
        revert('CreditLine::_depositCollateralFromSavingsAccount - Insufficient balance');
    }

    /**
     * @notice used to request a credit line either by borrower or lender
     * @param _requestTo Address to which creditLine is requested, 
                        if borrower creates request then lender address and 
                        if lender creates then borrower address
     * @param _borrowLimit maximum borrow amount in a credit line
     * @param _borrowRate Interest Rate at which credit Line is requested
     * @param _autoLiquidation if true, anyone can liquidate loan, otherwise only lender
     * @param _collateralRatio ratio of the collateral to the debt below which credit line can be liquidated
     * @param _borrowAsset address of the token to be borrowed
     * @param _collateralAsset address of the token provided as collateral
     * @param _requestAsLender if true, lender is placing request, otherwise borrower
     * @return identifier for the credit line
     */

    function request(
        address _requestTo,
        uint256 _borrowLimit,
        uint256 _borrowRate,
        bool _autoLiquidation,
        uint256 _collateralRatio,
        address _borrowAsset,
        address _collateralAsset,
        bool _requestAsLender
    ) external returns (uint256) {
        require(_borrowAsset != _collateralAsset, 'R: cant borrow lent token');
        require(IPriceOracle(priceOracle).doesFeedExist(_borrowAsset, _collateralAsset), 'R: No price feed');

        address _lender = _requestTo;
        address _borrower = msg.sender;
        if (_requestAsLender) {
            _lender = msg.sender;
            _borrower = _requestTo;
        }

        uint256 _id = _createRequest(
            _lender,
            _borrower,
            _borrowLimit,
            _borrowRate,
            _autoLiquidation,
            _collateralRatio,
            _borrowAsset,
            _collateralAsset,
            _requestAsLender
        );

        emit CreditLineRequested(_id, _lender, _borrower);
        return _id;
    }

    function _createRequest(
        address _lender,
        address _borrower,
        uint256 _borrowLimit,
        uint256 _borrowRate,
        bool _autoLiquidation,
        uint256 _collateralRatio,
        address _borrowAsset,
        address _collateralAsset,
        bool _requestByLender
    ) internal returns (uint256) {
        require(_lender != _borrower, 'Lender and Borrower cannot be same addresses');
        uint256 _id = creditLineCounter + 1;
        creditLineCounter = _id;
        creditLineVariables[_id].status = CreditLineStatus.REQUESTED;
        creditLineConstants[_id].borrower = _borrower;
        creditLineConstants[_id].lender = _lender;
        creditLineConstants[_id].borrowLimit = _borrowLimit;
        creditLineConstants[_id].autoLiquidation = _autoLiquidation;
        creditLineConstants[_id].idealCollateralRatio = _collateralRatio;
        creditLineConstants[_id].borrowRate = _borrowRate;
        creditLineConstants[_id].borrowAsset = _borrowAsset;
        creditLineConstants[_id].collateralAsset = _collateralAsset;
        creditLineConstants[_id].requestByLender = _requestByLender;
        return _id;
    }

    /**
     * @notice used to accept a credit line
     * @dev if borrower places request, lender can accept and vice versa
     * @param _id identifier for the credit line
     */
    function accept(uint256 _id) external {
        require(
            creditLineVariables[_id].status == CreditLineStatus.REQUESTED,
            'CreditLine::acceptCreditLineLender - CreditLine is already accepted'
        );
        bool _requestByLender = creditLineConstants[_id].requestByLender;
        require(
            (msg.sender == creditLineConstants[_id].borrower && _requestByLender) ||
                (msg.sender == creditLineConstants[_id].lender && !_requestByLender),
            "Only Borrower or Lender who hasn't requested can accept"
        );
        creditLineVariables[_id].status = CreditLineStatus.ACTIVE;
        emit CreditLineAccepted(_id);
    }

    /**
     * @notice used to deposit collateral into the credit line
     * @dev collateral tokens have to be approved in savingsAccount or token contract(unless ether).
            If transferred from savings account, the tokens are transferred from strategies in the 
            order prespecified in strategy registry
     * @param _id identifier for the credit line
     * @param _amount amount of collateral being deposited
     * @param _strategy strategy to which collateral is to be deposited in case transfer is not from savings account
     * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount 
                                otherwise direct from collateral token contract
     */
    function depositCollateral(
        uint256 _id,
        uint256 _amount,
        address _strategy,
        bool _fromSavingsAccount
    ) external payable nonReentrant ifCreditLineExists(_id) {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine not active');
        _depositCollateral(_id, _amount, _strategy, _fromSavingsAccount);
        emit CollateralDeposited(_id, _amount, _strategy);
    }

    function _depositCollateral(
        uint256 _id,
        uint256 _amount,
        address _strategy,
        bool _fromSavingsAccount
    ) internal {
        require(creditLineConstants[_id].lender != msg.sender, 'lender cant deposit collateral');
        if (_fromSavingsAccount) {
            _depositCollateralFromSavingsAccount(_id, _amount, msg.sender);
        } else {
            address _collateralAsset = creditLineConstants[_id].collateralAsset;
            ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
            if (_collateralAsset == address(0)) {
                require(msg.value == _amount, "CreditLine::_depositCollateral - value to transfer doesn't match argument");
            } else {
                IERC20(_collateralAsset).safeTransferFrom(msg.sender, address(this), _amount);
                IERC20(_collateralAsset).approve(_strategy, _amount);
            }
            uint256 _sharesReceived = _savingsAccount.deposit{value: msg.value}(_amount, _collateralAsset, _strategy, address(this));
            collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(_sharesReceived);
        }
    }

    function _withdrawBorrowAmount(
        address _asset,
        uint256 _amountInTokens,
        address _lender
    ) internal {
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        uint256 _activeAmount;
        for (uint256 _index = 0; _index < _strategyList.length; _index++) {
            if (_strategyList[_index] == address(0)) {
                continue;
            }
            uint256 _liquidityShares = _savingsAccount.balanceInShares(_lender, _asset, _strategyList[_index]);
            if (_liquidityShares != 0) {
                uint256 tokenInStrategy = _liquidityShares;
                tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);
                uint256 _tokensToTransfer = tokenInStrategy;
                if (_activeAmount.add(tokenInStrategy) >= _amountInTokens) {
                    _tokensToTransfer = (_amountInTokens.sub(_activeAmount));
                }
                _activeAmount = _activeAmount.add(_tokensToTransfer);
                _savingsAccount.withdrawFrom(_tokensToTransfer, _asset, _strategyList[_index], _lender, address(this), false);
                if (_activeAmount == _amountInTokens) {
                    return;
                }
            }
        }
        require(_activeAmount == _amountInTokens, 'insufficient balance');
    }

    /**
     * @notice used to borrow tokens from credit line by borrower
     * @dev only borrower can call this function. Amount that can actually be borrowed is 
            min(amount based on borrowLimit, allowance to creditLine contract, balance of lender)
     * @param _id identifier for the credit line
     * @param _amount amount of tokens to borrow
     */
    function borrow(uint256 _id, uint256 _amount) external payable nonReentrant onlyCreditLineBorrower(_id) {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');
        uint256 _borrowableAmount = calculateBorrowableAmount(_id);
        require(_amount <= _borrowableAmount, "CreditLine::borrow - The current collateral ratio doesn't allow to withdraw the amount");
        address _borrowAsset = creditLineConstants[_id].borrowAsset;
        address _lender = creditLineConstants[_id].lender;

        updateinterestAccruedTillLastPrincipalUpdate(_id);
        creditLineVariables[_id].principal = creditLineVariables[_id].principal.add(_amount);
        creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;

        uint256 _tokenDiffBalance;
        if (_borrowAsset != address(0)) {
            uint256 _balanceBefore = IERC20(_borrowAsset).balanceOf(address(this));
            _withdrawBorrowAmount(_borrowAsset, _amount, _lender);
            uint256 _balanceAfter = IERC20(_borrowAsset).balanceOf(address(this));
            _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);
        } else {
            uint256 _balanceBefore = address(this).balance;
            _withdrawBorrowAmount(_borrowAsset, _amount, _lender);
            uint256 _balanceAfter = address(this).balance;
            _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);
        }
        uint256 _protocolFee = _tokenDiffBalance.mul(protocolFeeFraction).div(10**30);
        _tokenDiffBalance = _tokenDiffBalance.sub(_protocolFee);

        if (_borrowAsset == address(0)) {
            (bool feeSuccess, ) = protocolFeeCollector.call{value: _protocolFee}('');
            require(feeSuccess, 'Transfer fail');
            (bool success, ) = msg.sender.call{value: _tokenDiffBalance}('');
            require(success, 'Transfer fail');
        } else {
            IERC20(_borrowAsset).safeTransfer(protocolFeeCollector, _protocolFee);
            IERC20(_borrowAsset).safeTransfer(msg.sender, _tokenDiffBalance);
        }
        emit BorrowedFromCreditLine(_id, _tokenDiffBalance);
    }

    function _repayFromSavingsAccount(
        uint256 _amount,
        address _asset,
        address _lender
    ) internal {
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        uint256 _activeAmount;

        for (uint256 _index = 0; _index < _strategyList.length; _index++) {
            if (_strategyList[_index] == address(0)) {
                continue;
            }
            uint256 _liquidityShares = _savingsAccount.balanceInShares(msg.sender, _asset, _strategyList[_index]);
            if (_liquidityShares == 0) {
                continue;
            }
            uint256 _tokenInStrategy = _liquidityShares;
            _tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);

            uint256 _tokensToTransfer = _tokenInStrategy;
            if (_activeAmount.add(_tokenInStrategy) >= _amount) {
                _tokensToTransfer = (_amount.sub(_activeAmount));
            }
            _activeAmount = _activeAmount.add(_tokensToTransfer);
            _savingsAccount.transferFrom(_tokensToTransfer, _asset, _strategyList[_index], msg.sender, _lender);

            if (_amount == _activeAmount) {
                return;
            }
        }
        revert('CreditLine::_repayFromSavingsAccount - Insufficient balance');
    }

    function _repay(
        uint256 _id,
        uint256 _amount,
        bool _fromSavingsAccount,
        uint256 _principalPaid
    ) internal {
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        address _defaultStrategy = defaultStrategy;
        address _borrowAsset = creditLineConstants[_id].borrowAsset;
        address _lender = creditLineConstants[_id].lender;
        if (!_fromSavingsAccount) {
            if (_borrowAsset == address(0)) {
                require(msg.value == _amount, 'creditLine::repay - Ether sent not equal to repay amount');
                _savingsAccount.deposit{value: _amount}(_amount, _borrowAsset, _defaultStrategy, _lender);
            } else {
                IERC20(_borrowAsset).safeTransferFrom(msg.sender, address(this), _amount);
                IERC20(_borrowAsset).approve(_defaultStrategy, _amount);
                _savingsAccount.deposit(_amount, _borrowAsset, _defaultStrategy, _lender);
            }
        } else {
            _repayFromSavingsAccount(_amount, _borrowAsset, _lender);
        }
        if (_principalPaid != 0) {
            _savingsAccount.increaseAllowanceToCreditLine(_principalPaid, _borrowAsset, _lender);
        }
    }

    /**
     * @notice used to repay interest and principal to credit line. Interest has to be repaid before repaying principal
     * @dev partial repayments possible
     * @param _id identifier for the credit line
     * @param _amount amount being repaid
     * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount 
                                otherwise direct from collateral token contract
     */
    function repay(
        uint256 _id,
        uint256 _amount,
        bool _fromSavingsAccount
    ) external payable nonReentrant {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');
        require(creditLineConstants[_id].lender != msg.sender, 'Lender cant repay');

        uint256 _interestSincePrincipalUpdate = calculateInterestAccrued(_id);
        uint256 _totalInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(
            _interestSincePrincipalUpdate
        );
        uint256 _interestToPay = _totalInterestAccrued.sub(creditLineVariables[_id].totalInterestRepaid);
        uint256 _totalCurrentDebt = _interestToPay.add(creditLineVariables[_id].principal);
        uint256 _principalPaid = 0;

        if (_amount >= _totalCurrentDebt) {
            _amount = _totalCurrentDebt;
            emit CompleteCreditLineRepaid(_id, _amount);
        } else {
            emit PartialCreditLineRepaid(_id, _amount);
        }

        if (_amount > _interestToPay) {
            creditLineVariables[_id].principal = _totalCurrentDebt.sub(_amount);
            creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _totalInterestAccrued;
            creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;
            creditLineVariables[_id].totalInterestRepaid = _totalInterestAccrued;
            _principalPaid = _amount.sub(_interestToPay);
        } else {
            creditLineVariables[_id].totalInterestRepaid = creditLineVariables[_id].totalInterestRepaid.add(_amount);
        }

        _repay(_id, _amount, _fromSavingsAccount, _principalPaid);

        if (creditLineVariables[_id].principal == 0) {
            _resetCreditLine(_id);
        }
    }

    function _resetCreditLine(uint256 _id) internal {
        creditLineVariables[_id].lastPrincipalUpdateTime = 0;
        creditLineVariables[_id].totalInterestRepaid = 0;
        creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = 0;
        emit CreditLineReset(_id);
    }

    /**
     * @dev used to close credit line by borrower or lender
     * @param _id identifier for the credit line
     */
    function close(uint256 _id) external ifCreditLineExists(_id) {
        require(
            msg.sender == creditLineConstants[_id].borrower || msg.sender == creditLineConstants[_id].lender,
            'CreditLine: Permission denied while closing Line of credit'
        );
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: Credit line should be active.');
        require(creditLineVariables[_id].principal == 0, 'CreditLine: Cannot be closed since not repaid.');
        require(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate == 0, 'CreditLine: Cannot be closed since not repaid.');
        creditLineVariables[_id].status = CreditLineStatus.CLOSED;
        emit CreditLineClosed(_id);
    }

    /**
     * @notice used to calculate the current collateral ratio
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view.
            Interest is also considered while calculating debt
     * @param _id identifier for the credit line
     * @return collateral ratio multiplied by 10**30 to retain precision
     */
    function calculateCurrentCollateralRatio(uint256 _id) public ifCreditLineExists(_id) returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(
            creditLineConstants[_id].collateralAsset,
            creditLineConstants[_id].borrowAsset
        );

        uint256 currentDebt = calculateCurrentDebt(_id);
        uint256 currentCollateralRatio = calculateTotalCollateralTokens(_id).mul(_ratioOfPrices).div(currentDebt).mul(10**30).div(
            10**_decimals
        );

        return currentCollateralRatio;
    }

    /**
     * @notice used to calculate the total collateral tokens
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @param _id identifier for the credit line
     * @return _amount total collateral tokens deposited into the credit line
     */
    function calculateTotalCollateralTokens(uint256 _id) public returns (uint256 _amount) {
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        uint256 _liquidityShares;
        for (uint256 index = 0; index < _strategyList.length; index++) {
            if (_strategyList[index] == address(0)) {
                continue;
            }
            _liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];
            uint256 _tokenInStrategy = _liquidityShares;
            _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(_liquidityShares, _collateralAsset);

            _amount = _amount.add(_tokenInStrategy);
        }
    }

    /**
     * @notice used to withdraw any excess collateral
     * @dev collateral can't be withdraw if collateralRatio goes below the ideal value. Only borrower can withdraw
     * @param _id identifier for the credit line
     * @param _amount amount of collateral to withdraw
     * @param _toSavingsAccount if true, tokens are transferred from savingsAccount 
                                otherwise direct from collateral token contract
     */
    function withdrawCollateral(
        uint256 _id,
        uint256 _amount,
        bool _toSavingsAccount
    ) external nonReentrant onlyCreditLineBorrower(_id) {
        uint256 _withdrawableCollateral = withdrawableCollateral(_id);
        require(_amount <= _withdrawableCollateral, 'Collateral ratio cant go below ideal');
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        _transferCollateral(_id, _collateralAsset, _amount, _toSavingsAccount);
        emit CollateralWithdrawn(_id, _amount);
    }

    /**
     * @notice used to calculate the collateral that can be withdrawn
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @param _id identifier for the credit line
     * @return total collateral withdrawable by borrower
     */
    function withdrawableCollateral(uint256 _id) public returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(
            creditLineConstants[_id].collateralAsset,
            creditLineConstants[_id].borrowAsset
        );

        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);
        uint256 _currentDebt = calculateCurrentDebt(_id);

        uint256 _collateralNeeded = _currentDebt
            .mul(creditLineConstants[_id].idealCollateralRatio)
            .div(_ratioOfPrices)
            .mul(10**_decimals)
            .div(10**30);

        if (_collateralNeeded >= _totalCollateralTokens) {
            return 0;
        }
        return _totalCollateralTokens.sub(_collateralNeeded);
    }

    function _transferCollateral(
        uint256 _id,
        address _asset,
        uint256 _amountInTokens,
        bool _toSavingsAccount
    ) internal {
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        uint256 _activeAmount;
        for (uint256 index = 0; index < _strategyList.length; index++) {
            uint256 liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];
            if (liquidityShares == 0 || _strategyList[index] == address(0)) {
                continue;
            }
            uint256 _tokenInStrategy = liquidityShares;
            _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(liquidityShares, _asset);
            uint256 _tokensToTransfer = _tokenInStrategy;
            if (_activeAmount.add(_tokenInStrategy) > _amountInTokens) {
                _tokensToTransfer = _amountInTokens.sub(_activeAmount);
                liquidityShares = liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy);
            }
            _activeAmount = _activeAmount.add(_tokensToTransfer);
            collateralShareInStrategy[_id][_strategyList[index]] = collateralShareInStrategy[_id][_strategyList[index]].sub(
                liquidityShares
            );
            if (_toSavingsAccount) {
                ISavingsAccount(savingsAccount).transfer(_tokensToTransfer, _asset, _strategyList[index], msg.sender);
            } else {
                ISavingsAccount(savingsAccount).withdraw(_tokensToTransfer, _asset, _strategyList[index], msg.sender, false);
            }

            if (_activeAmount == _amountInTokens) {
                return;
            }
        }
        revert('insufficient collateral');
    }

    /**
     * @notice used to liquidate credit line in case collateral ratio goes below the threshold
     * @dev if lender liquidates, then collateral is directly transferred. 
            If autoLiquidation is true, anyone can liquidate by providing enough borrow tokens
     * @param _id identifier for the credit line
     * @param _toSavingsAccount if true, tokens are transferred from savingsAccount 
                                otherwise direct from collateral token contract
     */
    function liquidate(uint256 _id, bool _toSavingsAccount) external payable nonReentrant {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: Credit line should be active.');
        require(creditLineVariables[_id].principal != 0, 'CreditLine: cannot liquidate if principal is 0');

        uint256 currentCollateralRatio = calculateCurrentCollateralRatio(_id);
        require(
            currentCollateralRatio < creditLineConstants[_id].idealCollateralRatio,
            'CreditLine: Collateral ratio is higher than ideal value'
        );

        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        address _lender = creditLineConstants[_id].lender;
        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);
        address _borrowAsset = creditLineConstants[_id].borrowAsset;

        creditLineVariables[_id].status = CreditLineStatus.LIQUIDATED;

        if (creditLineConstants[_id].autoLiquidation && _lender != msg.sender) {
            uint256 _borrowTokens = _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens);
            if (_borrowAsset == address(0)) {
                uint256 _returnETH = msg.value.sub(_borrowTokens, 'Insufficient ETH to liquidate');
                if (_returnETH != 0) {
                    (bool success, ) = msg.sender.call{value: _returnETH}('');
                    require(success, 'Transfer fail');
                }
            } else {
                IERC20(_borrowAsset).safeTransferFrom(msg.sender, _lender, _borrowTokens);
            }
        }

        _transferCollateral(_id, _collateralAsset, _totalCollateralTokens, _toSavingsAccount);

        emit CreditLineLiquidated(_id, msg.sender);
    }

    /**
     * @notice used to calculate the borrow tokens necessary for liquidator to liquidate
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @param _id identifier for the credit line
     * @return borrow tokens necessary for liquidator to liquidate
     */
    function borrowTokensToLiquidate(uint256 _id) external returns (uint256) {
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);
        address _borrowAsset = creditLineConstants[_id].borrowAsset;

        return _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens);
    }

    function _borrowTokensToLiquidate(
        address _borrowAsset,
        address _collateralAsset,
        uint256 _totalCollateralTokens
    ) internal view returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(_borrowAsset, _collateralAsset);
        uint256 _borrowTokens = (
            _totalCollateralTokens.mul(uint256(10**30).sub(liquidatorRewardFraction)).div(10**30).mul(_ratioOfPrices).div(10**_decimals)
        );

        return _borrowTokens;
    }

    receive() external payable {
        require(msg.sender == savingsAccount, 'CreditLine::receive invalid transaction');
    }
}
.]

Below are the details of our smart contract codes and their corresponding analysis reports:
Task: "".
As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report.

[2024-22-08 11:43:56 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-22-08 11:43:56 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 10083
completion_tokens: 866
total_tokens: 10949
cost: $-1.000000


[2024-22-08 11:43:56 INFO] Solidity Programming Expert: **Solidity Programming Expert<->Security Analyst on : BugsSummary, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/utils/ReentrancyGuard.sol';
import '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';
import '../interfaces/IPriceOracle.sol';
import '../interfaces/IYield.sol';
import '../interfaces/ISavingsAccount.sol';
import '../SavingsAccount/SavingsAccountUtil.sol';
import '../interfaces/IStrategyRegistry.sol';

/**
 * @title Credit Line contract with Methods related to credit Line
 * @notice Implements the functions related to Credit Line
 * @author Sublime
 **/

contract CreditLine is ReentrancyGuard, OwnableUpgradeable {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    enum CreditLineStatus {
        NOT_CREATED,
        REQUESTED,
        ACTIVE,
        CLOSED,
        CANCELLED,
        LIQUIDATED
    }

    /**
     * @notice counter that tracks the number of credit lines created
     * @dev used to create unique identifier for credit lines
     **/
    uint256 public creditLineCounter;

    uint256 constant YEAR_IN_SECONDS = 365 days;

    struct CreditLineVariables {
        CreditLineStatus status;
        uint256 principal;
        uint256 totalInterestRepaid;
        uint256 lastPrincipalUpdateTime;
        uint256 interestAccruedTillLastPrincipalUpdate;
    }

    struct CreditLineConstants {
        address lender;
        address borrower;
        uint256 borrowLimit;
        uint256 idealCollateralRatio;
        uint256 borrowRate;
        address borrowAsset;
        address collateralAsset;
        bool autoLiquidation;
        bool requestByLender;
    }
    /**
     * @notice stores the collateral shares in a credit line per strategy
     * @dev creditLineId => Strategy => collateralShares
     **/
    mapping(uint256 => mapping(address => uint256)) public collateralShareInStrategy;

    /**
     * @notice stores the variables to maintain a credit line
     **/
    mapping(uint256 => CreditLineVariables) public creditLineVariables;

    /**
     * @notice stores the constants related to a credit line
     **/
    mapping(uint256 => CreditLineConstants) public creditLineConstants;

    /**
     * @notice stores the address of savings account contract
     **/
    address public savingsAccount;

    /**
     * @notice stores the address of price oracle contract
     **/
    address public priceOracle;

    /**
     * @notice stores the address of strategy registry contract
     **/
    address public strategyRegistry;

    /**
     * @notice stores the address of default strategy
     **/
    address public defaultStrategy;

    /**
     * @notice stores the fraction of borrowed amount charged as fee by protocol
     * @dev it is multiplied by 10**30
     **/
    uint256 public protocolFeeFraction;

    /**
     * @notice address where protocol fee is collected
     **/
    address public protocolFeeCollector;

    /**
     * @notice stores the fraction of amount liquidated given as reward to liquidator
     * @dev it is multiplied by 10**30
     **/
    uint256 public liquidatorRewardFraction;
    /**
     * @dev checks if Credit Line exists
     * @param _id identifier for the credit line
     **/
    modifier ifCreditLineExists(uint256 _id) {
        require(creditLineVariables[_id].status != CreditLineStatus.NOT_CREATED, 'Credit line does not exist');
        _;
    }

    /**
     * @dev checks if called by credit Line Borrower
     * @param _id creditLine identifier
     **/
    modifier onlyCreditLineBorrower(uint256 _id) {
        require(creditLineConstants[_id].borrower == msg.sender, 'Only credit line Borrower can access');
        _;
    }

    /**
     * @dev checks if called by credit Line Lender
     * @param _id creditLine identifier
     **/
    modifier onlyCreditLineLender(uint256 _id) {
        require(creditLineConstants[_id].lender == msg.sender, 'Only credit line Lender can access');
        _;
    }

    /**
     * @notice emitted when a collateral is deposited into credit line
     * @param id id of the credit line
     * @param amount amount of collateral deposited
     * @param strategy address of the strategy into which collateral is deposited
     */
    event CollateralDeposited(uint256 indexed id, uint256 amount, address indexed strategy);

    /**
     * @notice emitted when collateral is withdrawn from credit line
     * @param id id of the credit line
     * @param amount amount of collateral withdrawn
     */
    event CollateralWithdrawn(uint256 indexed id, uint256 amount);

    /**
     * @notice emitted when a request for new credit line is placed
     * @param id id of the credit line for which request was made
     * @param lender address of the lender for credit line
     * @param borrower address of the borrower for credit line
     */
    event CreditLineRequested(uint256 indexed id, address indexed lender, address indexed borrower);

    /**
     * @notice emitted when a credit line is liquidated
     * @param id id of the credit line which is liquidated
     * @param liquidator address of the liquidator
     */
    event CreditLineLiquidated(uint256 indexed id, address indexed liquidator);

    /**
     * @notice emitted when tokens are borrowed from credit line
     * @param id id of the credit line from which tokens are borrowed
     * @param borrowAmount amount of tokens borrowed
     */
    event BorrowedFromCreditLine(uint256 indexed id, uint256 borrowAmount);

    /**
     * @notice emitted when credit line is accepted
     * @param id id of the credit line that was accepted
     */
    event CreditLineAccepted(uint256 indexed id);

    /**
     * @notice emitted when credit line is completely repaid and reset
     * @param id id of the credit line that is reset
     */
    event CreditLineReset(uint256 indexed id);

    /**
     * @notice emitted when the credit line is partially repaid
     * @param id id of the credit line
     * @param repayAmount amount repaid
     */
    event PartialCreditLineRepaid(uint256 indexed id, uint256 repayAmount);

    /**
     * @notice emitted when the credit line is completely repaid
     * @param id id of the credit line
     * @param repayAmount amount repaid
     */
    event CompleteCreditLineRepaid(uint256 indexed id, uint256 repayAmount);

    /**
     * @notice emitted when the credit line is closed by one of the parties of credit line
     * @param id id of the credit line
     */
    event CreditLineClosed(uint256 indexed id);

    /**
     * @notice emitted when default strategy for the credit line is updated
     * @param defaultStrategy address of the strategy contract that is used as default by credit lines
     */
    event DefaultStrategyUpdated(address indexed defaultStrategy);

    /**
     * @notice emitted when the price oracle is updated
     * @param priceOracle address of the updated price oracle
     */
    event PriceOracleUpdated(address indexed priceOracle);

    /**
     * @notice emitted when the savings account address is updated
     * @param savingsAccount address of the updated savingsAccount
     */
    event SavingsAccountUpdated(address indexed savingsAccount);

    /**
     * @notice emitted when strategy registry address is updated
     * @param strategyRegistry address of the updated strategy registry
     */
    event StrategyRegistryUpdated(address indexed strategyRegistry);

    /**
     * @notice emitted when fee that protocol charges for credit line is updated
     * @param updatedProtocolFee updated value of protocolFeeFraction
     */
    event ProtocolFeeFractionUpdated(uint256 updatedProtocolFee);

    /**
     * @notice emitted when address which receives fee that protocol changes for pools is updated
     * @param updatedProtocolFeeCollector updated value of protocolFeeCollector
     */
    event ProtocolFeeCollectorUpdated(address indexed updatedProtocolFeeCollector);

    /**
     * @notice emitted when liquidatorRewardFraction is updated
     * @param liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator
     */
    event LiquidationRewardFractionUpdated(uint256 liquidatorRewardFraction);

    /**
     * @notice used to initialize the contract
     * @dev can only be called once during the life cycle of the contract
     * @param _defaultStrategy default strategy used in credit lines
     * @param _priceOracle address of the priceOracle
     * @param _savingsAccount address of  the savings account contract
     * @param _strategyRegistry address of the strategy registry contract
     * @param _owner address of owner who can change global variables
     * @param _protocolFeeFraction fraction of the fee charged by protocol
     * @param _protocolFeeCollector address to which protocol fee is charged to
     * @param _liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator
     */
    function initialize(
        address _defaultStrategy,
        address _priceOracle,
        address _savingsAccount,
        address _strategyRegistry,
        address _owner,
        uint256 _protocolFeeFraction,
        address _protocolFeeCollector,
        uint256 _liquidatorRewardFraction
    ) external initializer {
        OwnableUpgradeable.__Ownable_init();
        OwnableUpgradeable.transferOwnership(_owner);

        _updateDefaultStrategy(_defaultStrategy);
        _updatePriceOracle(_priceOracle);
        _updateSavingsAccount(_savingsAccount);
        _updateStrategyRegistry(_strategyRegistry);
        _updateProtocolFeeFraction(_protocolFeeFraction);
        _updateProtocolFeeCollector(_protocolFeeCollector);
        _updateLiquidatorRewardFraction(_liquidatorRewardFraction);
    }

    /**
     * @notice used to update the default strategy
     * @dev can only be updated by owner
     * @param _defaultStrategy address of the updated default strategy
     */
    function updateDefaultStrategy(address _defaultStrategy) external onlyOwner {
        _updateDefaultStrategy(_defaultStrategy);
    }

    function _updateDefaultStrategy(address _defaultStrategy) internal {
        defaultStrategy = _defaultStrategy;
        emit DefaultStrategyUpdated(_defaultStrategy);
    }

    /**
     * @notice used to update the price oracle
     * @dev can only be updated by owner
     * @param _priceOracle address of the updated price oracle
     */
    function updatePriceOracle(address _priceOracle) external onlyOwner {
        _updatePriceOracle(_priceOracle);
    }

    function _updatePriceOracle(address _priceOracle) internal {
        priceOracle = _priceOracle;
        emit PriceOracleUpdated(_priceOracle);
    }

    /**
     * @notice used to update the savings account address
     * @dev can only be updated by owner
     * @param _savingsAccount address of the updated savings account
     */
    function updateSavingsAccount(address _savingsAccount) external onlyOwner {
        _updateSavingsAccount(_savingsAccount);
    }

    function _updateSavingsAccount(address _savingsAccount) internal {
        savingsAccount = _savingsAccount;
        emit SavingsAccountUpdated(_savingsAccount);
    }

    /**
     * @notice used to update the protocol fee fraction
     * @dev can only be updated by owner
     * @param _protocolFee fraction of the borrower amount collected as protocol fee
     */
    function updateProtocolFeeFraction(uint256 _protocolFee) external onlyOwner {
        _updateProtocolFeeFraction(_protocolFee);
    }

    function _updateProtocolFeeFraction(uint256 _protocolFee) internal {
        protocolFeeFraction = _protocolFee;
        emit ProtocolFeeFractionUpdated(_protocolFee);
    }

    /**
     * @notice used to update the protocol fee collector
     * @dev can only be updated by owner
     * @param _protocolFeeCollector address in which protocol fee is collected
     */
    function updateProtocolFeeCollector(address _protocolFeeCollector) external onlyOwner {
        _updateProtocolFeeCollector(_protocolFeeCollector);
    }

    function _updateProtocolFeeCollector(address _protocolFeeCollector) internal {
        require(_protocolFeeCollector != address(0), 'cant be 0 address');
        protocolFeeCollector = _protocolFeeCollector;
        emit ProtocolFeeCollectorUpdated(_protocolFeeCollector);
    }

    /**
     * @notice used to update the strategy registry address
     * @dev can only be updated by owner
     * @param _strategyRegistry address of the updated strategy registry
     */
    function updateStrategyRegistry(address _strategyRegistry) external onlyOwner {
        _updateStrategyRegistry(_strategyRegistry);
    }

    function _updateStrategyRegistry(address _strategyRegistry) internal {
        require(_strategyRegistry != address(0), 'CL::I zero address');
        strategyRegistry = _strategyRegistry;
        emit StrategyRegistryUpdated(_strategyRegistry);
    }

    /**
     * @notice used to update the liquidatorRewardFraction
     * @dev can only be updated by owner
     * @param _rewardFraction fraction of liquidated amount given to liquidator as reward
     */
    function updateLiquidatorRewardFraction(uint256 _rewardFraction) external onlyOwner {
        _updateLiquidatorRewardFraction(_rewardFraction);
    }

    function _updateLiquidatorRewardFraction(uint256 _rewardFraction) internal {
        require(_rewardFraction <= 10**30, 'Fraction has to be less than 1');
        liquidatorRewardFraction = _rewardFraction;
        emit LiquidationRewardFractionUpdated(_rewardFraction);
    }

    /**
     * @dev Used to Calculate Interest Per second on given principal and Interest rate
     * @param _principal principal Amount for which interest has to be calculated.
     * @param _borrowRate It is the Interest Rate at which Credit Line is approved
     * @return interest per second for the given parameters
     */
    function calculateInterest(
        uint256 _principal,
        uint256 _borrowRate,
        uint256 _timeElapsed
    ) public pure returns (uint256) {
        uint256 _interest = _principal.mul(_borrowRate).mul(_timeElapsed).div(10**30).div(YEAR_IN_SECONDS);

        return _interest;
    }

    /**
     * @dev Used to calculate interest accrued since last repayment
     * @param _id identifier for the credit line
     * @return interest accrued over current borrowed amount since last repayment
     */

    function calculateInterestAccrued(uint256 _id) public view returns (uint256) {
        uint256 _lastPrincipalUpdateTime = creditLineVariables[_id].lastPrincipalUpdateTime;
        if (_lastPrincipalUpdateTime == 0) return 0;
        uint256 _timeElapsed = (block.timestamp).sub(_lastPrincipalUpdateTime);
        uint256 _interestAccrued = calculateInterest(creditLineVariables[_id].principal, creditLineConstants[_id].borrowRate, _timeElapsed);
        return _interestAccrued;
    }

    /**
     * @dev Used to calculate current debt of borrower against a credit line.
     * @param _id identifier for the credit line
     * @return current debt of borrower
     */
    function calculateCurrentDebt(uint256 _id) public view returns (uint256) {
        uint256 _interestAccrued = calculateInterestAccrued(_id);
        uint256 _currentDebt = (creditLineVariables[_id].principal)
            .add(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate)
            .add(_interestAccrued)
            .sub(creditLineVariables[_id].totalInterestRepaid);
        return _currentDebt;
    }

    /**
     * @notice used to calculate amount that can be borrowed by the borrower
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view.
            borrowableAmount changes per block as interest changes per block.
     * @param _id identifier for the credit line
     * @return amount that can be borrowed from the credit line
     */
    function calculateBorrowableAmount(uint256 _id) public returns (uint256) {
        CreditLineStatus _status = creditLineVariables[_id].status;
        require(
            _status == CreditLineStatus.ACTIVE || _status == CreditLineStatus.REQUESTED,
            'CreditLine: Cannot only if credit line ACTIVE or REQUESTED'
        );
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(
            creditLineConstants[_id].collateralAsset,
            creditLineConstants[_id].borrowAsset
        );

        uint256 _totalCollateralToken = calculateTotalCollateralTokens(_id);

        uint256 _currentDebt = calculateCurrentDebt(_id);

        uint256 _maxPossible = _totalCollateralToken.mul(_ratioOfPrices).div(creditLineConstants[_id].idealCollateralRatio).mul(10**30).div(
            10**_decimals
        );

        uint256 _borrowLimit = creditLineConstants[_id].borrowLimit;

        if (_maxPossible > _borrowLimit) {
            _maxPossible = _borrowLimit;
        }
        if (_maxPossible > _currentDebt) {
            return _maxPossible.sub(_currentDebt);
        }
        return 0;
    }

    function updateinterestAccruedTillLastPrincipalUpdate(uint256 _id) internal {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');

        uint256 _interestAccrued = calculateInterestAccrued(_id);
        uint256 _newInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(_interestAccrued);
        creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _newInterestAccrued;
    }

    function _depositCollateralFromSavingsAccount(
        uint256 _id,
        uint256 _amount,
        address _sender
    ) internal {
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        uint256 _activeAmount;

        for (uint256 _index = 0; _index < _strategyList.length; _index++) {
            address _strategy = _strategyList[_index];
            uint256 _liquidityShares = _savingsAccount.balanceInShares(_sender, _collateralAsset, _strategy);
            if (_liquidityShares == 0 || _strategyList[_index] == address(0)) {
                continue;
            }
            uint256 _tokenInStrategy = _liquidityShares;
            _tokenInStrategy = IYield(_strategy).getTokensForShares(_liquidityShares, _collateralAsset);

            uint256 _tokensToTransfer = _tokenInStrategy;
            if (_activeAmount.add(_tokenInStrategy) >= _amount) {
                _tokensToTransfer = (_amount.sub(_activeAmount));
            }
            _activeAmount = _activeAmount.add(_tokensToTransfer);
            _savingsAccount.transferFrom(_tokensToTransfer, _collateralAsset, _strategy, _sender, address(this));

            collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(
                _liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy)
            );

            if (_amount == _activeAmount) {
                return;
            }
        }
        revert('CreditLine::_depositCollateralFromSavingsAccount - Insufficient balance');
    }

    /**
     * @notice used to request a credit line either by borrower or lender
     * @param _requestTo Address to which creditLine is requested, 
                        if borrower creates request then lender address and 
                        if lender creates then borrower address
     * @param _borrowLimit maximum borrow amount in a credit line
     * @param _borrowRate Interest Rate at which credit Line is requested
     * @param _autoLiquidation if true, anyone can liquidate loan, otherwise only lender
     * @param _collateralRatio ratio of the collateral to the debt below which credit line can be liquidated
     * @param _borrowAsset address of the token to be borrowed
     * @param _collateralAsset address of the token provided as collateral
     * @param _requestAsLender if true, lender is placing request, otherwise borrower
     * @return identifier for the credit line
     */

    function request(
        address _requestTo,
        uint256 _borrowLimit,
        uint256 _borrowRate,
        bool _autoLiquidation,
        uint256 _collateralRatio,
        address _borrowAsset,
        address _collateralAsset,
        bool _requestAsLender
    ) external returns (uint256) {
        require(_borrowAsset != _collateralAsset, 'R: cant borrow lent token');
        require(IPriceOracle(priceOracle).doesFeedExist(_borrowAsset, _collateralAsset), 'R: No price feed');

        address _lender = _requestTo;
        address _borrower = msg.sender;
        if (_requestAsLender) {
            _lender = msg.sender;
            _borrower = _requestTo;
        }

        uint256 _id = _createRequest(
            _lender,
            _borrower,
            _borrowLimit,
            _borrowRate,
            _autoLiquidation,
            _collateralRatio,
            _borrowAsset,
            _collateralAsset,
            _requestAsLender
        );

        emit CreditLineRequested(_id, _lender, _borrower);
        return _id;
    }

    function _createRequest(
        address _lender,
        address _borrower,
        uint256 _borrowLimit,
        uint256 _borrowRate,
        bool _autoLiquidation,
        uint256 _collateralRatio,
        address _borrowAsset,
        address _collateralAsset,
        bool _requestByLender
    ) internal returns (uint256) {
        require(_lender != _borrower, 'Lender and Borrower cannot be same addresses');
        uint256 _id = creditLineCounter + 1;
        creditLineCounter = _id;
        creditLineVariables[_id].status = CreditLineStatus.REQUESTED;
        creditLineConstants[_id].borrower = _borrower;
        creditLineConstants[_id].lender = _lender;
        creditLineConstants[_id].borrowLimit = _borrowLimit;
        creditLineConstants[_id].autoLiquidation = _autoLiquidation;
        creditLineConstants[_id].idealCollateralRatio = _collateralRatio;
        creditLineConstants[_id].borrowRate = _borrowRate;
        creditLineConstants[_id].borrowAsset = _borrowAsset;
        creditLineConstants[_id].collateralAsset = _collateralAsset;
        creditLineConstants[_id].requestByLender = _requestByLender;
        return _id;
    }

    /**
     * @notice used to accept a credit line
     * @dev if borrower places request, lender can accept and vice versa
     * @param _id identifier for the credit line
     */
    function accept(uint256 _id) external {
        require(
            creditLineVariables[_id].status == CreditLineStatus.REQUESTED,
            'CreditLine::acceptCreditLineLender - CreditLine is already accepted'
        );
        bool _requestByLender = creditLineConstants[_id].requestByLender;
        require(
            (msg.sender == creditLineConstants[_id].borrower && _requestByLender) ||
                (msg.sender == creditLineConstants[_id].lender && !_requestByLender),
            "Only Borrower or Lender who hasn't requested can accept"
        );
        creditLineVariables[_id].status = CreditLineStatus.ACTIVE;
        emit CreditLineAccepted(_id);
    }

    /**
     * @notice used to deposit collateral into the credit line
     * @dev collateral tokens have to be approved in savingsAccount or token contract(unless ether).
            If transferred from savings account, the tokens are transferred from strategies in the 
            order prespecified in strategy registry
     * @param _id identifier for the credit line
     * @param _amount amount of collateral being deposited
     * @param _strategy strategy to which collateral is to be deposited in case transfer is not from savings account
     * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount 
                                otherwise direct from collateral token contract
     */
    function depositCollateral(
        uint256 _id,
        uint256 _amount,
        address _strategy,
        bool _fromSavingsAccount
    ) external payable nonReentrant ifCreditLineExists(_id) {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine not active');
        _depositCollateral(_id, _amount, _strategy, _fromSavingsAccount);
        emit CollateralDeposited(_id, _amount, _strategy);
    }

    function _depositCollateral(
        uint256 _id,
        uint256 _amount,
        address _strategy,
        bool _fromSavingsAccount
    ) internal {
        require(creditLineConstants[_id].lender != msg.sender, 'lender cant deposit collateral');
        if (_fromSavingsAccount) {
            _depositCollateralFromSavingsAccount(_id, _amount, msg.sender);
        } else {
            address _collateralAsset = creditLineConstants[_id].collateralAsset;
            ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
            if (_collateralAsset == address(0)) {
                require(msg.value == _amount, "CreditLine::_depositCollateral - value to transfer doesn't match argument");
            } else {
                IERC20(_collateralAsset).safeTransferFrom(msg.sender, address(this), _amount);
                IERC20(_collateralAsset).approve(_strategy, _amount);
            }
            uint256 _sharesReceived = _savingsAccount.deposit{value: msg.value}(_amount, _collateralAsset, _strategy, address(this));
            collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(_sharesReceived);
        }
    }

    function _withdrawBorrowAmount(
        address _asset,
        uint256 _amountInTokens,
        address _lender
    ) internal {
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        uint256 _activeAmount;
        for (uint256 _index = 0; _index < _strategyList.length; _index++) {
            if (_strategyList[_index] == address(0)) {
                continue;
            }
            uint256 _liquidityShares = _savingsAccount.balanceInShares(_lender, _asset, _strategyList[_index]);
            if (_liquidityShares != 0) {
                uint256 tokenInStrategy = _liquidityShares;
                tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);
                uint256 _tokensToTransfer = tokenInStrategy;
                if (_activeAmount.add(tokenInStrategy) >= _amountInTokens) {
                    _tokensToTransfer = (_amountInTokens.sub(_activeAmount));
                }
                _activeAmount = _activeAmount.add(_tokensToTransfer);
                _savingsAccount.withdrawFrom(_tokensToTransfer, _asset, _strategyList[_index], _lender, address(this), false);
                if (_activeAmount == _amountInTokens) {
                    return;
                }
            }
        }
        require(_activeAmount == _amountInTokens, 'insufficient balance');
    }

    /**
     * @notice used to borrow tokens from credit line by borrower
     * @dev only borrower can call this function. Amount that can actually be borrowed is 
            min(amount based on borrowLimit, allowance to creditLine contract, balance of lender)
     * @param _id identifier for the credit line
     * @param _amount amount of tokens to borrow
     */
    function borrow(uint256 _id, uint256 _amount) external payable nonReentrant onlyCreditLineBorrower(_id) {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');
        uint256 _borrowableAmount = calculateBorrowableAmount(_id);
        require(_amount <= _borrowableAmount, "CreditLine::borrow - The current collateral ratio doesn't allow to withdraw the amount");
        address _borrowAsset = creditLineConstants[_id].borrowAsset;
        address _lender = creditLineConstants[_id].lender;

        updateinterestAccruedTillLastPrincipalUpdate(_id);
        creditLineVariables[_id].principal = creditLineVariables[_id].principal.add(_amount);
        creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;

        uint256 _tokenDiffBalance;
        if (_borrowAsset != address(0)) {
            uint256 _balanceBefore = IERC20(_borrowAsset).balanceOf(address(this));
            _withdrawBorrowAmount(_borrowAsset, _amount, _lender);
            uint256 _balanceAfter = IERC20(_borrowAsset).balanceOf(address(this));
            _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);
        } else {
            uint256 _balanceBefore = address(this).balance;
            _withdrawBorrowAmount(_borrowAsset, _amount, _lender);
            uint256 _balanceAfter = address(this).balance;
            _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);
        }
        uint256 _protocolFee = _tokenDiffBalance.mul(protocolFeeFraction).div(10**30);
        _tokenDiffBalance = _tokenDiffBalance.sub(_protocolFee);

        if (_borrowAsset == address(0)) {
            (bool feeSuccess, ) = protocolFeeCollector.call{value: _protocolFee}('');
            require(feeSuccess, 'Transfer fail');
            (bool success, ) = msg.sender.call{value: _tokenDiffBalance}('');
            require(success, 'Transfer fail');
        } else {
            IERC20(_borrowAsset).safeTransfer(protocolFeeCollector, _protocolFee);
            IERC20(_borrowAsset).safeTransfer(msg.sender, _tokenDiffBalance);
        }
        emit BorrowedFromCreditLine(_id, _tokenDiffBalance);
    }

    function _repayFromSavingsAccount(
        uint256 _amount,
        address _asset,
        address _lender
    ) internal {
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        uint256 _activeAmount;

        for (uint256 _index = 0; _index < _strategyList.length; _index++) {
            if (_strategyList[_index] == address(0)) {
                continue;
            }
            uint256 _liquidityShares = _savingsAccount.balanceInShares(msg.sender, _asset, _strategyList[_index]);
            if (_liquidityShares == 0) {
                continue;
            }
            uint256 _tokenInStrategy = _liquidityShares;
            _tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);

            uint256 _tokensToTransfer = _tokenInStrategy;
            if (_activeAmount.add(_tokenInStrategy) >= _amount) {
                _tokensToTransfer = (_amount.sub(_activeAmount));
            }
            _activeAmount = _activeAmount.add(_tokensToTransfer);
            _savingsAccount.transferFrom(_tokensToTransfer, _asset, _strategyList[_index], msg.sender, _lender);

            if (_amount == _activeAmount) {
                return;
            }
        }
        revert('CreditLine::_repayFromSavingsAccount - Insufficient balance');
    }

    function _repay(
        uint256 _id,
        uint256 _amount,
        bool _fromSavingsAccount,
        uint256 _principalPaid
    ) internal {
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        address _defaultStrategy = defaultStrategy;
        address _borrowAsset = creditLineConstants[_id].borrowAsset;
        address _lender = creditLineConstants[_id].lender;
        if (!_fromSavingsAccount) {
            if (_borrowAsset == address(0)) {
                require(msg.value == _amount, 'creditLine::repay - Ether sent not equal to repay amount');
                _savingsAccount.deposit{value: _amount}(_amount, _borrowAsset, _defaultStrategy, _lender);
            } else {
                IERC20(_borrowAsset).safeTransferFrom(msg.sender, address(this), _amount);
                IERC20(_borrowAsset).approve(_defaultStrategy, _amount);
                _savingsAccount.deposit(_amount, _borrowAsset, _defaultStrategy, _lender);
            }
        } else {
            _repayFromSavingsAccount(_amount, _borrowAsset, _lender);
        }
        if (_principalPaid != 0) {
            _savingsAccount.increaseAllowanceToCreditLine(_principalPaid, _borrowAsset, _lender);
        }
    }

    /**
     * @notice used to repay interest and principal to credit line. Interest has to be repaid before repaying principal
     * @dev partial repayments possible
     * @param _id identifier for the credit line
     * @param _amount amount being repaid
     * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount 
                                otherwise direct from collateral token contract
     */
    function repay(
        uint256 _id,
        uint256 _amount,
        bool _fromSavingsAccount
    ) external payable nonReentrant {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');
        require(creditLineConstants[_id].lender != msg.sender, 'Lender cant repay');

        uint256 _interestSincePrincipalUpdate = calculateInterestAccrued(_id);
        uint256 _totalInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(
            _interestSincePrincipalUpdate
        );
        uint256 _interestToPay = _totalInterestAccrued.sub(creditLineVariables[_id].totalInterestRepaid);
        uint256 _totalCurrentDebt = _interestToPay.add(creditLineVariables[_id].principal);
        uint256 _principalPaid = 0;

        if (_amount >= _totalCurrentDebt) {
            _amount = _totalCurrentDebt;
            emit CompleteCreditLineRepaid(_id, _amount);
        } else {
            emit PartialCreditLineRepaid(_id, _amount);
        }

        if (_amount > _interestToPay) {
            creditLineVariables[_id].principal = _totalCurrentDebt.sub(_amount);
            creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _totalInterestAccrued;
            creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;
            creditLineVariables[_id].totalInterestRepaid = _totalInterestAccrued;
            _principalPaid = _amount.sub(_interestToPay);
        } else {
            creditLineVariables[_id].totalInterestRepaid = creditLineVariables[_id].totalInterestRepaid.add(_amount);
        }

        _repay(_id, _amount, _fromSavingsAccount, _principalPaid);

        if (creditLineVariables[_id].principal == 0) {
            _resetCreditLine(_id);
        }
    }

    function _resetCreditLine(uint256 _id) internal {
        creditLineVariables[_id].lastPrincipalUpdateTime = 0;
        creditLineVariables[_id].totalInterestRepaid = 0;
        creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = 0;
        emit CreditLineReset(_id);
    }

    /**
     * @dev used to close credit line by borrower or lender
     * @param _id identifier for the credit line
     */
    function close(uint256 _id) external ifCreditLineExists(_id) {
        require(
            msg.sender == creditLineConstants[_id].borrower || msg.sender == creditLineConstants[_id].lender,
            'CreditLine: Permission denied while closing Line of credit'
        );
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: Credit line should be active.');
        require(creditLineVariables[_id].principal == 0, 'CreditLine: Cannot be closed since not repaid.');
        require(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate == 0, 'CreditLine: Cannot be closed since not repaid.');
        creditLineVariables[_id].status = CreditLineStatus.CLOSED;
        emit CreditLineClosed(_id);
    }

    /**
     * @notice used to calculate the current collateral ratio
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view.
            Interest is also considered while calculating debt
     * @param _id identifier for the credit line
     * @return collateral ratio multiplied by 10**30 to retain precision
     */
    function calculateCurrentCollateralRatio(uint256 _id) public ifCreditLineExists(_id) returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(
            creditLineConstants[_id].collateralAsset,
            creditLineConstants[_id].borrowAsset
        );

        uint256 currentDebt = calculateCurrentDebt(_id);
        uint256 currentCollateralRatio = calculateTotalCollateralTokens(_id).mul(_ratioOfPrices).div(currentDebt).mul(10**30).div(
            10**_decimals
        );

        return currentCollateralRatio;
    }

    /**
     * @notice used to calculate the total collateral tokens
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @param _id identifier for the credit line
     * @return _amount total collateral tokens deposited into the credit line
     */
    function calculateTotalCollateralTokens(uint256 _id) public returns (uint256 _amount) {
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        uint256 _liquidityShares;
        for (uint256 index = 0; index < _strategyList.length; index++) {
            if (_strategyList[index] == address(0)) {
                continue;
            }
            _liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];
            uint256 _tokenInStrategy = _liquidityShares;
            _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(_liquidityShares, _collateralAsset);

            _amount = _amount.add(_tokenInStrategy);
        }
    }

    /**
     * @notice used to withdraw any excess collateral
     * @dev collateral can't be withdraw if collateralRatio goes below the ideal value. Only borrower can withdraw
     * @param _id identifier for the credit line
     * @param _amount amount of collateral to withdraw
     * @param _toSavingsAccount if true, tokens are transferred from savingsAccount 
                                otherwise direct from collateral token contract
     */
    function withdrawCollateral(
        uint256 _id,
        uint256 _amount,
        bool _toSavingsAccount
    ) external nonReentrant onlyCreditLineBorrower(_id) {
        uint256 _withdrawableCollateral = withdrawableCollateral(_id);
        require(_amount <= _withdrawableCollateral, 'Collateral ratio cant go below ideal');
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        _transferCollateral(_id, _collateralAsset, _amount, _toSavingsAccount);
        emit CollateralWithdrawn(_id, _amount);
    }

    /**
     * @notice used to calculate the collateral that can be withdrawn
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @param _id identifier for the credit line
     * @return total collateral withdrawable by borrower
     */
    function withdrawableCollateral(uint256 _id) public returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(
            creditLineConstants[_id].collateralAsset,
            creditLineConstants[_id].borrowAsset
        );

        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);
        uint256 _currentDebt = calculateCurrentDebt(_id);

        uint256 _collateralNeeded = _currentDebt
            .mul(creditLineConstants[_id].idealCollateralRatio)
            .div(_ratioOfPrices)
            .mul(10**_decimals)
            .div(10**30);

        if (_collateralNeeded >= _totalCollateralTokens) {
            return 0;
        }
        return _totalCollateralTokens.sub(_collateralNeeded);
    }

    function _transferCollateral(
        uint256 _id,
        address _asset,
        uint256 _amountInTokens,
        bool _toSavingsAccount
    ) internal {
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        uint256 _activeAmount;
        for (uint256 index = 0; index < _strategyList.length; index++) {
            uint256 liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];
            if (liquidityShares == 0 || _strategyList[index] == address(0)) {
                continue;
            }
            uint256 _tokenInStrategy = liquidityShares;
            _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(liquidityShares, _asset);
            uint256 _tokensToTransfer = _tokenInStrategy;
            if (_activeAmount.add(_tokenInStrategy) > _amountInTokens) {
                _tokensToTransfer = _amountInTokens.sub(_activeAmount);
                liquidityShares = liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy);
            }
            _activeAmount = _activeAmount.add(_tokensToTransfer);
            collateralShareInStrategy[_id][_strategyList[index]] = collateralShareInStrategy[_id][_strategyList[index]].sub(
                liquidityShares
            );
            if (_toSavingsAccount) {
                ISavingsAccount(savingsAccount).transfer(_tokensToTransfer, _asset, _strategyList[index], msg.sender);
            } else {
                ISavingsAccount(savingsAccount).withdraw(_tokensToTransfer, _asset, _strategyList[index], msg.sender, false);
            }

            if (_activeAmount == _amountInTokens) {
                return;
            }
        }
        revert('insufficient collateral');
    }

    /**
     * @notice used to liquidate credit line in case collateral ratio goes below the threshold
     * @dev if lender liquidates, then collateral is directly transferred. 
            If autoLiquidation is true, anyone can liquidate by providing enough borrow tokens
     * @param _id identifier for the credit line
     * @param _toSavingsAccount if true, tokens are transferred from savingsAccount 
                                otherwise direct from collateral token contract
     */
    function liquidate(uint256 _id, bool _toSavingsAccount) external payable nonReentrant {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: Credit line should be active.');
        require(creditLineVariables[_id].principal != 0, 'CreditLine: cannot liquidate if principal is 0');

        uint256 currentCollateralRatio = calculateCurrentCollateralRatio(_id);
        require(
            currentCollateralRatio < creditLineConstants[_id].idealCollateralRatio,
            'CreditLine: Collateral ratio is higher than ideal value'
        );

        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        address _lender = creditLineConstants[_id].lender;
        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);
        address _borrowAsset = creditLineConstants[_id].borrowAsset;

        creditLineVariables[_id].status = CreditLineStatus.LIQUIDATED;

        if (creditLineConstants[_id].autoLiquidation && _lender != msg.sender) {
            uint256 _borrowTokens = _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens);
            if (_borrowAsset == address(0)) {
                uint256 _returnETH = msg.value.sub(_borrowTokens, 'Insufficient ETH to liquidate');
                if (_returnETH != 0) {
                    (bool success, ) = msg.sender.call{value: _returnETH}('');
                    require(success, 'Transfer fail');
                }
            } else {
                IERC20(_borrowAsset).safeTransferFrom(msg.sender, _lender, _borrowTokens);
            }
        }

        _transferCollateral(_id, _collateralAsset, _totalCollateralTokens, _toSavingsAccount);

        emit CreditLineLiquidated(_id, msg.sender);
    }

    /**
     * @notice used to calculate the borrow tokens necessary for liquidator to liquidate
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @param _id identifier for the credit line
     * @return borrow tokens necessary for liquidator to liquidate
     */
    function borrowTokensToLiquidate(uint256 _id) external returns (uint256) {
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);
        address _borrowAsset = creditLineConstants[_id].borrowAsset;

        return _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens);
    }

    function _borrowTokensToLiquidate(
        address _borrowAsset,
        address _collateralAsset,
        uint256 _totalCollateralTokens
    ) internal view returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(_borrowAsset, _collateralAsset);
        uint256 _borrowTokens = (
            _totalCollateralTokens.mul(uint256(10**30).sub(liquidatorRewardFraction)).div(10**30).mul(_ratioOfPrices).div(10**_decimals)
        );

        return _borrowTokens;
    }

    receive() external payable {
        require(msg.sender == savingsAccount, 'CreditLine::receive invalid transaction');
    }
}
.]

Based on the provided Solidity smart contract code for the Credit Line contract, here are the identified security vulnerabilities and issues:

### Summary of Security Vulnerabilities:

1. **Reentrancy Vulnerability**: 
   - Although the contract uses `ReentrancyGuard`, there are multiple functions that involve external calls (e.g., transferring tokens, withdrawing funds) that could potentially be exploited if not properly guarded. Special attention should be given to functions like `borrow`, `repay`, and `_withdrawBorrowAmount`.

2. **Arithmetic Overflow/Underflow**:
   - The contract uses `SafeMath`, which mitigates overflow and underflow issues. However, it is essential to ensure that all arithmetic operations are consistently using `SafeMath` to prevent any potential vulnerabilities.

3. **Access Control Issues**:
   - The contract relies on the `onlyOwner` modifier for critical functions. If the owner’s private key is compromised, an attacker could manipulate the contract settings (e.g., update the price oracle, protocol fee collector, etc.). Consider implementing a multi-signature wallet for ownership or critical functions.

4. **Gas Limit and Loops**:
   - Functions that iterate over arrays (e.g., `_depositCollateralFromSavingsAccount`, `_withdrawBorrowAmount`) could run into gas limit issues if the number of strategies is large. This could lead to denial of service if the contract cannot execute due to exceeding gas limits.

5. **Lack of Input Validation**:
   - Some functions do not validate inputs thoroughly. For example, in the `request` function, there is a lack of checks on the borrow limit and borrow rate, which could lead to unexpected behavior if invalid values are passed.

6. **Potential for Front-running**:
   - The contract does not implement any mechanisms to prevent front-running attacks, especially in functions that involve financial transactions (e.g., `borrow`, `repay`). This could allow malicious actors to exploit the timing of transactions.

7. **Unrestricted Ether Transfers**:
   - The contract allows Ether to be sent without checks in functions like `borrow`. If the contract is not designed to handle Ether correctly, it could lead to loss of funds.

8. **Improper Handling of Collateral**:
   - The logic for handling collateral withdrawal and liquidation may not adequately protect against scenarios where the collateral ratio drops below the ideal threshold, potentially leading to losses for lenders.

### Comprehensive Analysis Report:

The Credit Line contract implements a complex lending and borrowing mechanism using collateralized loans. While it leverages established libraries like OpenZeppelin's `SafeERC20` and `SafeMath`, there are several areas of concern that need to be addressed to enhance the security and robustness of the contract.

1. **Reentrancy Protection**: Although the use of `ReentrancyGuard` is a good practice, it is crucial to ensure that all external calls are properly guarded. A thorough review of all functions that involve external interactions is necessary to identify any potential reentrancy vulnerabilities.

2. **Access Control**: The reliance on a single owner for critical functions poses a risk. Implementing a multi-signature wallet or a more decentralized governance mechanism could mitigate this risk.

3. **Input Validation**: Strengthening input validation across all functions will help prevent unexpected behaviors and potential exploits. This includes validating borrow limits, rates, and ensuring that addresses are not zero.

4. **Gas Limit Considerations**: Functions that involve loops should be optimized to prevent gas limit issues. Consider implementing pagination or limiting the number of iterations to ensure that the contract remains functional even with a large number of strategies.

5. **Front-running Mitigation**: Implementing mechanisms to prevent front-running, such as commit-reveal schemes or time-locks, could protect users from being exploited by malicious actors.

6. **Collateral Management**: The logic surrounding collateral management should be reviewed to ensure that it adequately protects both borrowers and lenders. This includes ensuring that collateral cannot be withdrawn if it would lead to an unsafe collateral ratio.

In conclusion, while the Credit Line contract has a solid foundation, addressing the identified vulnerabilities and implementing best practices in smart contract development will significantly enhance its security and reliability. A thorough audit and testing phase should be conducted before deployment to ensure that all potential vulnerabilities are mitigated.

[2024-22-08 11:43:56 INFO] **[Seminar Conclusion]**:

 Based on the provided Solidity smart contract code for the Credit Line contract, here are the identified security vulnerabilities and issues:

### Summary of Security Vulnerabilities:

1. **Reentrancy Vulnerability**: 
   - Although the contract uses `ReentrancyGuard`, there are multiple functions that involve external calls (e.g., transferring tokens, withdrawing funds) that could potentially be exploited if not properly guarded. Special attention should be given to functions like `borrow`, `repay`, and `_withdrawBorrowAmount`.

2. **Arithmetic Overflow/Underflow**:
   - The contract uses `SafeMath`, which mitigates overflow and underflow issues. However, it is essential to ensure that all arithmetic operations are consistently using `SafeMath` to prevent any potential vulnerabilities.

3. **Access Control Issues**:
   - The contract relies on the `onlyOwner` modifier for critical functions. If the owner’s private key is compromised, an attacker could manipulate the contract settings (e.g., update the price oracle, protocol fee collector, etc.). Consider implementing a multi-signature wallet for ownership or critical functions.

4. **Gas Limit and Loops**:
   - Functions that iterate over arrays (e.g., `_depositCollateralFromSavingsAccount`, `_withdrawBorrowAmount`) could run into gas limit issues if the number of strategies is large. This could lead to denial of service if the contract cannot execute due to exceeding gas limits.

5. **Lack of Input Validation**:
   - Some functions do not validate inputs thoroughly. For example, in the `request` function, there is a lack of checks on the borrow limit and borrow rate, which could lead to unexpected behavior if invalid values are passed.

6. **Potential for Front-running**:
   - The contract does not implement any mechanisms to prevent front-running attacks, especially in functions that involve financial transactions (e.g., `borrow`, `repay`). This could allow malicious actors to exploit the timing of transactions.

7. **Unrestricted Ether Transfers**:
   - The contract allows Ether to be sent without checks in functions like `borrow`. If the contract is not designed to handle Ether correctly, it could lead to loss of funds.

8. **Improper Handling of Collateral**:
   - The logic for handling collateral withdrawal and liquidation may not adequately protect against scenarios where the collateral ratio drops below the ideal threshold, potentially leading to losses for lenders.

### Comprehensive Analysis Report:

The Credit Line contract implements a complex lending and borrowing mechanism using collateralized loans. While it leverages established libraries like OpenZeppelin's `SafeERC20` and `SafeMath`, there are several areas of concern that need to be addressed to enhance the security and robustness of the contract.

1. **Reentrancy Protection**: Although the use of `ReentrancyGuard` is a good practice, it is crucial to ensure that all external calls are properly guarded. A thorough review of all functions that involve external interactions is necessary to identify any potential reentrancy vulnerabilities.

2. **Access Control**: The reliance on a single owner for critical functions poses a risk. Implementing a multi-signature wallet or a more decentralized governance mechanism could mitigate this risk.

3. **Input Validation**: Strengthening input validation across all functions will help prevent unexpected behaviors and potential exploits. This includes validating borrow limits, rates, and ensuring that addresses are not zero.

4. **Gas Limit Considerations**: Functions that involve loops should be optimized to prevent gas limit issues. Consider implementing pagination or limiting the number of iterations to ensure that the contract remains functional even with a large number of strategies.

5. **Front-running Mitigation**: Implementing mechanisms to prevent front-running, such as commit-reveal schemes or time-locks, could protect users from being exploited by malicious actors.

6. **Collateral Management**: The logic surrounding collateral management should be reviewed to ensure that it adequately protects both borrowers and lenders. This includes ensuring that collateral cannot be withdrawn if it would lead to an unsafe collateral ratio.

In conclusion, while the Credit Line contract has a solid foundation, addressing the identified vulnerabilities and implementing best practices in smart contract development will significantly enhance its security and reliability. A thorough audit and testing phase should be conducted before deployment to ensure that all potential vulnerabilities are mitigated.

[2024-22-08 11:43:59 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol'; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/utils/ReentrancyGuard.sol'; import '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol'; import '../interfaces/IPriceOracle.sol'; import '../interfaces/IYield.sol'; import '../interfaces/ISavingsAccount.sol'; import '../SavingsAccount/SavingsAccountUtil.sol'; import '../interfaces/IStrategyRegistry.sol'; /  * @title Credit Line contract with Methods related to credit Line  * @notice Implements the functions related to Credit Line  * @author Sublime  / contract CreditLine is ReentrancyGuard, OwnableUpgradeable {     using SafeERC20 for IERC20;     using SafeMath for uint256; enum CreditLineStatus {     NOT_CREATED,     REQUESTED,     ACTIVE,     CLOSED,     CANCELLED,     LIQUIDATED }  /**  * @notice counter that tracks the number of credit lines created  * @dev used to create unique identifier for credit lines  **/ uint256 public creditLineCounter;  uint256 constant YEAR_IN_SECONDS = 365 days;  struct CreditLineVariables {     CreditLineStatus status;     uint256 principal;     uint256 totalInterestRepaid;     uint256 lastPrincipalUpdateTime;     uint256 interestAccruedTillLastPrincipalUpdate; }  struct CreditLineConstants {     address lender;     address borrower;     uint256 borrowLimit;     uint256 idealCollateralRatio;     uint256 borrowRate;     address borrowAsset;     address collateralAsset;     bool autoLiquidation;     bool requestByLender; } /**  * @notice stores the collateral shares in a credit line per strategy  * @dev creditLineId =&gt; Strategy =&gt; collateralShares  **/ mapping(uint256 =&gt; mapping(address =&gt; uint256)) public collateralShareInStrategy;  /**  * @notice stores the variables to maintain a credit line  **/ mapping(uint256 =&gt; CreditLineVariables) public creditLineVariables;  /**  * @notice stores the constants related to a credit line  **/ mapping(uint256 =&gt; CreditLineConstants) public creditLineConstants;  /**  * @notice stores the address of savings account contract  **/ address public savingsAccount;  /**  * @notice stores the address of price oracle contract  **/ address public priceOracle;  /**  * @notice stores the address of strategy registry contract  **/ address public strategyRegistry;  /**  * @notice stores the address of default strategy  **/ address public defaultStrategy;  /**  * @notice stores the fraction of borrowed amount charged as fee by protocol  * @dev it is multiplied by 10**30  **/ uint256 public protocolFeeFraction;  /**  * @notice address where protocol fee is collected  **/ address public protocolFeeCollector;  /**  * @notice stores the fraction of amount liquidated given as reward to liquidator  * @dev it is multiplied by 10**30  **/ uint256 public liquidatorRewardFraction; /**  * @dev checks if Credit Line exists  * @param _id identifier for the credit line  **/ modifier ifCreditLineExists(uint256 _id) {     require(creditLineVariables[_id].status != CreditLineStatus.NOT_CREATED, 'Credit line does not exist');     _; }  /**  * @dev checks if called by credit Line Borrower  * @param _id creditLine identifier  **/ modifier onlyCreditLineBorrower(uint256 _id) {     require(creditLineConstants[_id].borrower == msg.sender, 'Only credit line Borrower can access');     _; }  /**  * @dev checks if called by credit Line Lender  * @param _id creditLine identifier  **/ modifier onlyCreditLineLender(uint256 _id) {     require(creditLineConstants[_id].lender == msg.sender, 'Only credit line Lender can access');     _; }  /**  * @notice emitted when a collateral is deposited into credit line  * @param id id of the credit line  * @param amount amount of collateral deposited  * @param strategy address of the strategy into which collateral is deposited  */ event CollateralDeposited(uint256 indexed id, uint256 amount, address indexed strategy);  /**  * @notice emitted when collateral is withdrawn from credit line  * @param id id of the credit line  * @param amount amount of collateral withdrawn  */ event CollateralWithdrawn(uint256 indexed id, uint256 amount);  /**  * @notice emitted when a request for new credit line is placed  * @param id id of the credit line for which request was made  * @param lender address of the lender for credit line  * @param borrower address of the borrower for credit line  */ event CreditLineRequested(uint256 indexed id, address indexed lender, address indexed borrower);  /**  * @notice emitted when a credit line is liquidated  * @param id id of the credit line which is liquidated  * @param liquidator address of the liquidator  */ event CreditLineLiquidated(uint256 indexed id, address indexed liquidator);  /**  * @notice emitted when tokens are borrowed from credit line  * @param id id of the credit line from which tokens are borrowed  * @param borrowAmount amount of tokens borrowed  */ event BorrowedFromCreditLine(uint256 indexed id, uint256 borrowAmount);  /**  * @notice emitted when credit line is accepted  * @param id id of the credit line that was accepted  */ event CreditLineAccepted(uint256 indexed id);  /**  * @notice emitted when credit line is completely repaid and reset  * @param id id of the credit line that is reset  */ event CreditLineReset(uint256 indexed id);  /**  * @notice emitted when the credit line is partially repaid  * @param id id of the credit line  * @param repayAmount amount repaid  */ event PartialCreditLineRepaid(uint256 indexed id, uint256 repayAmount);  /**  * @notice emitted when the credit line is completely repaid  * @param id id of the credit line  * @param repayAmount amount repaid  */ event CompleteCreditLineRepaid(uint256 indexed id, uint256 repayAmount);  /**  * @notice emitted when the credit line is closed by one of the parties of credit line  * @param id id of the credit line  */ event CreditLineClosed(uint256 indexed id);  /**  * @notice emitted when default strategy for the credit line is updated  * @param defaultStrategy address of the strategy contract that is used as default by credit lines  */ event DefaultStrategyUpdated(address indexed defaultStrategy);  /**  * @notice emitted when the price oracle is updated  * @param priceOracle address of the updated price oracle  */ event PriceOracleUpdated(address indexed priceOracle);  /**  * @notice emitted when the savings account address is updated  * @param savingsAccount address of the updated savingsAccount  */ event SavingsAccountUpdated(address indexed savingsAccount);  /**  * @notice emitted when strategy registry address is updated  * @param strategyRegistry address of the updated strategy registry  */ event StrategyRegistryUpdated(address indexed strategyRegistry);  /**  * @notice emitted when fee that protocol charges for credit line is updated  * @param updatedProtocolFee updated value of protocolFeeFraction  */ event ProtocolFeeFractionUpdated(uint256 updatedProtocolFee);  /**  * @notice emitted when address which receives fee that protocol changes for pools is updated  * @param updatedProtocolFeeCollector updated value of protocolFeeCollector  */ event ProtocolFeeCollectorUpdated(address indexed updatedProtocolFeeCollector);  /**  * @notice emitted when liquidatorRewardFraction is updated  * @param liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator  */ event LiquidationRewardFractionUpdated(uint256 liquidatorRewardFraction);  /**  * @notice used to initialize the contract  * @dev can only be called once during the life cycle of the contract  * @param _defaultStrategy default strategy used in credit lines  * @param _priceOracle address of the priceOracle  * @param _savingsAccount address of  the savings account contract  * @param _strategyRegistry address of the strategy registry contract  * @param _owner address of owner who can change global variables  * @param _protocolFeeFraction fraction of the fee charged by protocol  * @param _protocolFeeCollector address to which protocol fee is charged to  * @param _liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator  */ function initialize(     address _defaultStrategy,     address _priceOracle,     address _savingsAccount,     address _strategyRegistry,     address _owner,     uint256 _protocolFeeFraction,     address _protocolFeeCollector,     uint256 _liquidatorRewardFraction ) external initializer {     OwnableUpgradeable.__Ownable_init();     OwnableUpgradeable.transferOwnership(_owner);      _updateDefaultStrategy(_defaultStrategy);     _updatePriceOracle(_priceOracle);     _updateSavingsAccount(_savingsAccount);     _updateStrategyRegistry(_strategyRegistry);     _updateProtocolFeeFraction(_protocolFeeFraction);     _updateProtocolFeeCollector(_protocolFeeCollector);     _updateLiquidatorRewardFraction(_liquidatorRewardFraction); }  /**  * @notice used to update the default strategy  * @dev can only be updated by owner  * @param _defaultStrategy address of the updated default strategy  */ function updateDefaultStrategy(address _defaultStrategy) external onlyOwner {     _updateDefaultStrategy(_defaultStrategy); }  function _updateDefaultStrategy(address _defaultStrategy) internal {     defaultStrategy = _defaultStrategy;     emit DefaultStrategyUpdated(_defaultStrategy); }  /**  * @notice used to update the price oracle  * @dev can only be updated by owner  * @param _priceOracle address of the updated price oracle  */ function updatePriceOracle(address _priceOracle) external onlyOwner {     _updatePriceOracle(_priceOracle); }  function _updatePriceOracle(address _priceOracle) internal {     priceOracle = _priceOracle;     emit PriceOracleUpdated(_priceOracle); }  /**  * @notice used to update the savings account address  * @dev can only be updated by owner  * @param _savingsAccount address of the updated savings account  */ function updateSavingsAccount(address _savingsAccount) external onlyOwner {     _updateSavingsAccount(_savingsAccount); }  function _updateSavingsAccount(address _savingsAccount) internal {     savingsAccount = _savingsAccount;     emit SavingsAccountUpdated(_savingsAccount); }  /**  * @notice used to update the protocol fee fraction  * @dev can only be updated by owner  * @param _protocolFee fraction of the borrower amount collected as protocol fee  */ function updateProtocolFeeFraction(uint256 _protocolFee) external onlyOwner {     _updateProtocolFeeFraction(_protocolFee); }  function _updateProtocolFeeFraction(uint256 _protocolFee) internal {     protocolFeeFraction = _protocolFee;     emit ProtocolFeeFractionUpdated(_protocolFee); }  /**  * @notice used to update the protocol fee collector  * @dev can only be updated by owner  * @param _protocolFeeCollector address in which protocol fee is collected  */ function updateProtocolFeeCollector(address _protocolFeeCollector) external onlyOwner {     _updateProtocolFeeCollector(_protocolFeeCollector); }  function _updateProtocolFeeCollector(address _protocolFeeCollector) internal {     require(_protocolFeeCollector != address(0), 'cant be 0 address');     protocolFeeCollector = _protocolFeeCollector;     emit ProtocolFeeCollectorUpdated(_protocolFeeCollector); }  /**  * @notice used to update the strategy registry address  * @dev can only be updated by owner  * @param _strategyRegistry address of the updated strategy registry  */ function updateStrategyRegistry(address _strategyRegistry) external onlyOwner {     _updateStrategyRegistry(_strategyRegistry); }  function _updateStrategyRegistry(address _strategyRegistry) internal {     require(_strategyRegistry != address(0), 'CL::I zero address');     strategyRegistry = _strategyRegistry;     emit StrategyRegistryUpdated(_strategyRegistry); }  /**  * @notice used to update the liquidatorRewardFraction  * @dev can only be updated by owner  * @param _rewardFraction fraction of liquidated amount given to liquidator as reward  */ function updateLiquidatorRewardFraction(uint256 _rewardFraction) external onlyOwner {     _updateLiquidatorRewardFraction(_rewardFraction); }  function _updateLiquidatorRewardFraction(uint256 _rewardFraction) internal {     require(_rewardFraction &lt;= 10**30, 'Fraction has to be less than 1');     liquidatorRewardFraction = _rewardFraction;     emit LiquidationRewardFractionUpdated(_rewardFraction); }  /**  * @dev Used to Calculate Interest Per second on given principal and Interest rate  * @param _principal principal Amount for which interest has to be calculated.  * @param _borrowRate It is the Interest Rate at which Credit Line is approved  * @return interest per second for the given parameters  */ function calculateInterest(     uint256 _principal,     uint256 _borrowRate,     uint256 _timeElapsed ) public pure returns (uint256) {     uint256 _interest = _principal.mul(_borrowRate).mul(_timeElapsed).div(10**30).div(YEAR_IN_SECONDS);      return _interest; }  /**  * @dev Used to calculate interest accrued since last repayment  * @param _id identifier for the credit line  * @return interest accrued over current borrowed amount since last repayment  */  function calculateInterestAccrued(uint256 _id) public view returns (uint256) {     uint256 _lastPrincipalUpdateTime = creditLineVariables[_id].lastPrincipalUpdateTime;     if (_lastPrincipalUpdateTime == 0) return 0;     uint256 _timeElapsed = (block.timestamp).sub(_lastPrincipalUpdateTime);     uint256 _interestAccrued = calculateInterest(creditLineVariables[_id].principal, creditLineConstants[_id].borrowRate, _timeElapsed);     return _interestAccrued; }  /**  * @dev Used to calculate current debt of borrower against a credit line.  * @param _id identifier for the credit line  * @return current debt of borrower  */ function calculateCurrentDebt(uint256 _id) public view returns (uint256) {     uint256 _interestAccrued = calculateInterestAccrued(_id);     uint256 _currentDebt = (creditLineVariables[_id].principal)         .add(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate)         .add(_interestAccrued)         .sub(creditLineVariables[_id].totalInterestRepaid);     return _currentDebt; }  /**  * @notice used to calculate amount that can be borrowed by the borrower  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view.         borrowableAmount changes per block as interest changes per block.  * @param _id identifier for the credit line  * @return amount that can be borrowed from the credit line  */ function calculateBorrowableAmount(uint256 _id) public returns (uint256) {     CreditLineStatus _status = creditLineVariables[_id].status;     require(         _status == CreditLineStatus.ACTIVE || _status == CreditLineStatus.REQUESTED,         'CreditLine: Cannot only if credit line ACTIVE or REQUESTED'     );     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(         creditLineConstants[_id].collateralAsset,         creditLineConstants[_id].borrowAsset     );      uint256 _totalCollateralToken = calculateTotalCollateralTokens(_id);      uint256 _currentDebt = calculateCurrentDebt(_id);      uint256 _maxPossible = _totalCollateralToken.mul(_ratioOfPrices).div(creditLineConstants[_id].idealCollateralRatio).mul(10**30).div(         10**_decimals     );      uint256 _borrowLimit = creditLineConstants[_id].borrowLimit;      if (_maxPossible &gt; _borrowLimit) {         _maxPossible = _borrowLimit;     }     if (_maxPossible &gt; _currentDebt) {         return _maxPossible.sub(_currentDebt);     }     return 0; }  function updateinterestAccruedTillLastPrincipalUpdate(uint256 _id) internal {     require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');      uint256 _interestAccrued = calculateInterestAccrued(_id);     uint256 _newInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(_interestAccrued);     creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _newInterestAccrued; }  function _depositCollateralFromSavingsAccount(     uint256 _id,     uint256 _amount,     address _sender ) internal {     address _collateralAsset = creditLineConstants[_id].collateralAsset;     address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();     ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);     uint256 _activeAmount;      for (uint256 _index = 0; _index &lt; _strategyList.length; _index++) {         address _strategy = _strategyList[_index];         uint256 _liquidityShares = _savingsAccount.balanceInShares(_sender, _collateralAsset, _strategy);         if (_liquidityShares == 0 || _strategyList[_index] == address(0)) {             continue;         }         uint256 _tokenInStrategy = _liquidityShares;         _tokenInStrategy = IYield(_strategy).getTokensForShares(_liquidityShares, _collateralAsset);          uint256 _tokensToTransfer = _tokenInStrategy;         if (_activeAmount.add(_tokenInStrategy) &gt;= _amount) {             _tokensToTransfer = (_amount.sub(_activeAmount));         }         _activeAmount = _activeAmount.add(_tokensToTransfer);         _savingsAccount.transferFrom(_tokensToTransfer, _collateralAsset, _strategy, _sender, address(this));          collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(             _liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy)         );          if (_amount == _activeAmount) {             return;         }     }     revert('CreditLine::_depositCollateralFromSavingsAccount - Insufficient balance'); }  /**  * @notice used to request a credit line either by borrower or lender  * @param _requestTo Address to which creditLine is requested,                      if borrower creates request then lender address and                      if lender creates then borrower address  * @param _borrowLimit maximum borrow amount in a credit line  * @param _borrowRate Interest Rate at which credit Line is requested  * @param _autoLiquidation if true, anyone can liquidate loan, otherwise only lender  * @param _collateralRatio ratio of the collateral to the debt below which credit line can be liquidated  * @param _borrowAsset address of the token to be borrowed  * @param _collateralAsset address of the token provided as collateral  * @param _requestAsLender if true, lender is placing request, otherwise borrower  * @return identifier for the credit line  */  function request(     address _requestTo,     uint256 _borrowLimit,     uint256 _borrowRate,     bool _autoLiquidation,     uint256 _collateralRatio,     address _borrowAsset,     address _collateralAsset,     bool _requestAsLender ) external returns (uint256) {     require(_borrowAsset != _collateralAsset, 'R: cant borrow lent token');     require(IPriceOracle(priceOracle).doesFeedExist(_borrowAsset, _collateralAsset), 'R: No price feed');      address _lender = _requestTo;     address _borrower = msg.sender;     if (_requestAsLender) {         _lender = msg.sender;         _borrower = _requestTo;     }      uint256 _id = _createRequest(         _lender,         _borrower,         _borrowLimit,         _borrowRate,         _autoLiquidation,         _collateralRatio,         _borrowAsset,         _collateralAsset,         _requestAsLender     );      emit CreditLineRequested(_id, _lender, _borrower);     return _id; }  function _createRequest(     address _lender,     address _borrower,     uint256 _borrowLimit,     uint256 _borrowRate,     bool _autoLiquidation,     uint256 _collateralRatio,     address _borrowAsset,     address _collateralAsset,     bool _requestByLender ) internal returns (uint256) {     require(_lender != _borrower, 'Lender and Borrower cannot be same addresses');     uint256 _id = creditLineCounter + 1;     creditLineCounter = _id;     creditLineVariables[_id].status = CreditLineStatus.REQUESTED;     creditLineConstants[_id].borrower = _borrower;     creditLineConstants[_id].lender = _lender;     creditLineConstants[_id].borrowLimit = _borrowLimit;     creditLineConstants[_id].autoLiquidation = _autoLiquidation;     creditLineConstants[_id].idealCollateralRatio = _collateralRatio;     creditLineConstants[_id].borrowRate = _borrowRate;     creditLineConstants[_id].borrowAsset = _borrowAsset;     creditLineConstants[_id].collateralAsset = _collateralAsset;     creditLineConstants[_id].requestByLender = _requestByLender;     return _id; }  /**  * @notice used to accept a credit line  * @dev if borrower places request, lender can accept and vice versa  * @param _id identifier for the credit line  */ function accept(uint256 _id) external {     require(         creditLineVariables[_id].status == CreditLineStatus.REQUESTED,         'CreditLine::acceptCreditLineLender - CreditLine is already accepted'     );     bool _requestByLender = creditLineConstants[_id].requestByLender;     require(         (msg.sender == creditLineConstants[_id].borrower &amp;&amp; _requestByLender) ||             (msg.sender == creditLineConstants[_id].lender &amp;&amp; !_requestByLender),         "Only Borrower or Lender who hasn't requested can accept"     );     creditLineVariables[_id].status = CreditLineStatus.ACTIVE;     emit CreditLineAccepted(_id); }  /**  * @notice used to deposit collateral into the credit line  * @dev collateral tokens have to be approved in savingsAccount or token contract(unless ether).         If transferred from savings account, the tokens are transferred from strategies in the          order prespecified in strategy registry  * @param _id identifier for the credit line  * @param _amount amount of collateral being deposited  * @param _strategy strategy to which collateral is to be deposited in case transfer is not from savings account  * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount                              otherwise direct from collateral token contract  */ function depositCollateral(     uint256 _id,     uint256 _amount,     address _strategy,     bool _fromSavingsAccount ) external payable nonReentrant ifCreditLineExists(_id) {     require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine not active');     _depositCollateral(_id, _amount, _strategy, _fromSavingsAccount);     emit CollateralDeposited(_id, _amount, _strategy); }  function _depositCollateral(     uint256 _id,     uint256 _amount,     address _strategy,     bool _fromSavingsAccount ) internal {     require(creditLineConstants[_id].lender != msg.sender, 'lender cant deposit collateral');     if (_fromSavingsAccount) {         _depositCollateralFromSavingsAccount(_id, _amount, msg.sender);     } else {         address _collateralAsset = creditLineConstants[_id].collateralAsset;         ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);         if (_collateralAsset == address(0)) {             require(msg.value == _amount, "CreditLine::_depositCollateral - value to transfer doesn't match argument");         } else {             IERC20(_collateralAsset).safeTransferFrom(msg.sender, address(this), _amount);             IERC20(_collateralAsset).approve(_strategy, _amount);         }         uint256 _sharesReceived = _savingsAccount.deposit{value: msg.value}(_amount, _collateralAsset, _strategy, address(this));         collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(_sharesReceived);     } }  function _withdrawBorrowAmount(     address _asset,     uint256 _amountInTokens,     address _lender ) internal {     address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();     ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);     uint256 _activeAmount;     for (uint256 _index = 0; _index &lt; _strategyList.length; _index++) {         if (_strategyList[_index] == address(0)) {             continue;         }         uint256 _liquidityShares = _savingsAccount.balanceInShares(_lender, _asset, _strategyList[_index]);         if (_liquidityShares != 0) {             uint256 tokenInStrategy = _liquidityShares;             tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);             uint256 _tokensToTransfer = tokenInStrategy;             if (_activeAmount.add(tokenInStrategy) &gt;= _amountInTokens) {                 _tokensToTransfer = (_amountInTokens.sub(_activeAmount));             }             _activeAmount = _activeAmount.add(_tokensToTransfer);             _savingsAccount.withdrawFrom(_tokensToTransfer, _asset, _strategyList[_index], _lender, address(this), false);             if (_activeAmount == _amountInTokens) {                 return;             }         }     }     require(_activeAmount == _amountInTokens, 'insufficient balance'); }  /**  * @notice used to borrow tokens from credit line by borrower  * @dev only borrower can call this function. Amount that can actually be borrowed is          min(amount based on borrowLimit, allowance to creditLine contract, balance of lender)  * @param _id identifier for the credit line  * @param _amount amount of tokens to borrow  */ function borrow(uint256 _id, uint256 _amount) external payable nonReentrant onlyCreditLineBorrower(_id) {     require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');     uint256 _borrowableAmount = calculateBorrowableAmount(_id);     require(_amount &lt;= _borrowableAmount, "CreditLine::borrow - The current collateral ratio doesn't allow to withdraw the amount");     address _borrowAsset = creditLineConstants[_id].borrowAsset;     address _lender = creditLineConstants[_id].lender;      updateinterestAccruedTillLastPrincipalUpdate(_id);     creditLineVariables[_id].principal = creditLineVariables[_id].principal.add(_amount);     creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;      uint256 _tokenDiffBalance;     if (_borrowAsset != address(0)) {         uint256 _balanceBefore = IERC20(_borrowAsset).balanceOf(address(this));         _withdrawBorrowAmount(_borrowAsset, _amount, _lender);         uint256 _balanceAfter = IERC20(_borrowAsset).balanceOf(address(this));         _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);     } else {         uint256 _balanceBefore = address(this).balance;         _withdrawBorrowAmount(_borrowAsset, _amount, _lender);         uint256 _balanceAfter = address(this).balance;         _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);     }     uint256 _protocolFee = _tokenDiffBalance.mul(protocolFeeFraction).div(10**30);     _tokenDiffBalance = _tokenDiffBalance.sub(_protocolFee);      if (_borrowAsset == address(0)) {         (bool feeSuccess, ) = protocolFeeCollector.call{value: _protocolFee}('');         require(feeSuccess, 'Transfer fail');         (bool success, ) = msg.sender.call{value: _tokenDiffBalance}('');         require(success, 'Transfer fail');     } else {         IERC20(_borrowAsset).safeTransfer(protocolFeeCollector, _protocolFee);         IERC20(_borrowAsset).safeTransfer(msg.sender, _tokenDiffBalance);     }     emit BorrowedFromCreditLine(_id, _tokenDiffBalance); }  function _repayFromSavingsAccount(     uint256 _amount,     address _asset,     address _lender ) internal {     address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();     ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);     uint256 _activeAmount;      for (uint256 _index = 0; _index &lt; _strategyList.length; _index++) {         if (_strategyList[_index] == address(0)) {             continue;         }         uint256 _liquidityShares = _savingsAccount.balanceInShares(msg.sender, _asset, _strategyList[_index]);         if (_liquidityShares == 0) {             continue;         }         uint256 _tokenInStrategy = _liquidityShares;         _tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);          uint256 _tokensToTransfer = _tokenInStrategy;         if (_activeAmount.add(_tokenInStrategy) &gt;= _amount) {             _tokensToTransfer = (_amount.sub(_activeAmount));         }         _activeAmount = _activeAmount.add(_tokensToTransfer);         _savingsAccount.transferFrom(_tokensToTransfer, _asset, _strategyList[_index], msg.sender, _lender);          if (_amount == _activeAmount) {             return;         }     }     revert('CreditLine::_repayFromSavingsAccount - Insufficient balance'); }  function _repay(     uint256 _id,     uint256 _amount,     bool _fromSavingsAccount,     uint256 _principalPaid ) internal {     ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);     address _defaultStrategy = defaultStrategy;     address _borrowAsset = creditLineConstants[_id].borrowAsset;     address _lender = creditLineConstants[_id].lender;     if (!_fromSavingsAccount) {         if (_borrowAsset == address(0)) {             require(msg.value == _amount, 'creditLine::repay - Ether sent not equal to repay amount');             _savingsAccount.deposit{value: _amount}(_amount, _borrowAsset, _defaultStrategy, _lender);         } else {             IERC20(_borrowAsset).safeTransferFrom(msg.sender, address(this), _amount);             IERC20(_borrowAsset).approve(_defaultStrategy, _amount);             _savingsAccount.deposit(_amount, _borrowAsset, _defaultStrategy, _lender);         }     } else {         _repayFromSavingsAccount(_amount, _borrowAsset, _lender);     }     if (_principalPaid != 0) {         _savingsAccount.increaseAllowanceToCreditLine(_principalPaid, _borrowAsset, _lender);     } }  /**  * @notice used to repay interest and principal to credit line. Interest has to be repaid before repaying principal  * @dev partial repayments possible  * @param _id identifier for the credit line  * @param _amount amount being repaid  * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount                              otherwise direct from collateral token contract  */ function repay(     uint256 _id,     uint256 _amount,     bool _fromSavingsAccount ) external payable nonReentrant {     require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');     require(creditLineConstants[_id].lender != msg.sender, 'Lender cant repay');      uint256 _interestSincePrincipalUpdate = calculateInterestAccrued(_id);     uint256 _totalInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(         _interestSincePrincipalUpdate     );     uint256 _interestToPay = _totalInterestAccrued.sub(creditLineVariables[_id].totalInterestRepaid);     uint256 _totalCurrentDebt = _interestToPay.add(creditLineVariables[_id].principal);     uint256 _principalPaid = 0;      if (_amount &gt;= _totalCurrentDebt) {         _amount = _totalCurrentDebt;         emit CompleteCreditLineRepaid(_id, _amount);     } else {         emit PartialCreditLineRepaid(_id, _amount);     }      if (_amount &gt; _interestToPay) {         creditLineVariables[_id].principal = _totalCurrentDebt.sub(_amount);         creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _totalInterestAccrued;         creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;         creditLineVariables[_id].totalInterestRepaid = _totalInterestAccrued;         _principalPaid = _amount.sub(_interestToPay);     } else {         creditLineVariables[_id].totalInterestRepaid = creditLineVariables[_id].totalInterestRepaid.add(_amount);     }      _repay(_id, _amount, _fromSavingsAccount, _principalPaid);      if (creditLineVariables[_id].principal == 0) {         _resetCreditLine(_id);     } }  function _resetCreditLine(uint256 _id) internal {     creditLineVariables[_id].lastPrincipalUpdateTime = 0;     creditLineVariables[_id].totalInterestRepaid = 0;     creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = 0;     emit CreditLineReset(_id); }  /**  * @dev used to close credit line by borrower or lender  * @param _id identifier for the credit line  */ function close(uint256 _id) external ifCreditLineExists(_id) {     require(         msg.sender == creditLineConstants[_id].borrower || msg.sender == creditLineConstants[_id].lender,         'CreditLine: Permission denied while closing Line of credit'     );     require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: Credit line should be active.');     require(creditLineVariables[_id].principal == 0, 'CreditLine: Cannot be closed since not repaid.');     require(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate == 0, 'CreditLine: Cannot be closed since not repaid.');     creditLineVariables[_id].status = CreditLineStatus.CLOSED;     emit CreditLineClosed(_id); }  /**  * @notice used to calculate the current collateral ratio  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view.         Interest is also considered while calculating debt  * @param _id identifier for the credit line  * @return collateral ratio multiplied by 10**30 to retain precision  */ function calculateCurrentCollateralRatio(uint256 _id) public ifCreditLineExists(_id) returns (uint256) {     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(         creditLineConstants[_id].collateralAsset,         creditLineConstants[_id].borrowAsset     );      uint256 currentDebt = calculateCurrentDebt(_id);     uint256 currentCollateralRatio = calculateTotalCollateralTokens(_id).mul(_ratioOfPrices).div(currentDebt).mul(10**30).div(         10**_decimals     );      return currentCollateralRatio; }  /**  * @notice used to calculate the total collateral tokens  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view  * @param _id identifier for the credit line  * @return _amount total collateral tokens deposited into the credit line  */ function calculateTotalCollateralTokens(uint256 _id) public returns (uint256 _amount) {     address _collateralAsset = creditLineConstants[_id].collateralAsset;     address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();     uint256 _liquidityShares;     for (uint256 index = 0; index &lt; _strategyList.length; index++) {         if (_strategyList[index] == address(0)) {             continue;         }         _liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];         uint256 _tokenInStrategy = _liquidityShares;         _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(_liquidityShares, _collateralAsset);          _amount = _amount.add(_tokenInStrategy);     } }  /**  * @notice used to withdraw any excess collateral  * @dev collateral can't be withdraw if collateralRatio goes below the ideal value. Only borrower can withdraw  * @param _id identifier for the credit line  * @param _amount amount of collateral to withdraw  * @param _toSavingsAccount if true, tokens are transferred from savingsAccount                              otherwise direct from collateral token contract  */ function withdrawCollateral(     uint256 _id,     uint256 _amount,     bool _toSavingsAccount ) external nonReentrant onlyCreditLineBorrower(_id) {     uint256 _withdrawableCollateral = withdrawableCollateral(_id);     require(_amount &lt;= _withdrawableCollateral, 'Collateral ratio cant go below ideal');     address _collateralAsset = creditLineConstants[_id].collateralAsset;     _transferCollateral(_id, _collateralAsset, _amount, _toSavingsAccount);     emit CollateralWithdrawn(_id, _amount); }  /**  * @notice used to calculate the collateral that can be withdrawn  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view  * @param _id identifier for the credit line  * @return total collateral withdrawable by borrower  */ function withdrawableCollateral(uint256 _id) public returns (uint256) {     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(         creditLineConstants[_id].collateralAsset,         creditLineConstants[_id].borrowAsset     );      uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);     uint256 _currentDebt = calculateCurrentDebt(_id);      uint256 _collateralNeeded = _currentDebt         .mul(creditLineConstants[_id].idealCollateralRatio)         .div(_ratioOfPrices)         .mul(10**_decimals)         .div(10**30);      if (_collateralNeeded &gt;= _totalCollateralTokens) {         return 0;     }     return _totalCollateralTokens.sub(_collateralNeeded); }  function _transferCollateral(     uint256 _id,     address _asset,     uint256 _amountInTokens,     bool _toSavingsAccount ) internal {     address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();     uint256 _activeAmount;     for (uint256 index = 0; index &lt; _strategyList.length; index++) {         uint256 liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];         if (liquidityShares == 0 || _strategyList[index] == address(0)) {             continue;         }         uint256 _tokenInStrategy = liquidityShares;         _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(liquidityShares, _asset);         uint256 _tokensToTransfer = _tokenInStrategy;         if (_activeAmount.add(_tokenInStrategy) &gt; _amountInTokens) {             _tokensToTransfer = _amountInTokens.sub(_activeAmount);             liquidityShares = liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy);         }         _activeAmount = _activeAmount.add(_tokensToTransfer);         collateralShareInStrategy[_id][_strategyList[index]] = collateralShareInStrategy[_id][_strategyList[index]].sub(             liquidityShares         );         if (_toSavingsAccount) {             ISavingsAccount(savingsAccount).transfer(_tokensToTransfer, _asset, _strategyList[index], msg.sender);         } else {             ISavingsAccount(savingsAccount).withdraw(_tokensToTransfer, _asset, _strategyList[index], msg.sender, false);         }          if (_activeAmount == _amountInTokens) {             return;         }     }     revert('insufficient collateral'); }  /**  * @notice used to liquidate credit line in case collateral ratio goes below the threshold  * @dev if lender liquidates, then collateral is directly transferred.          If autoLiquidation is true, anyone can liquidate by providing enough borrow tokens  * @param _id identifier for the credit line  * @param _toSavingsAccount if true, tokens are transferred from savingsAccount                              otherwise direct from collateral token contract  */ function liquidate(uint256 _id, bool _toSavingsAccount) external payable nonReentrant {     require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: Credit line should be active.');     require(creditLineVariables[_id].principal != 0, 'CreditLine: cannot liquidate if principal is 0');      uint256 currentCollateralRatio = calculateCurrentCollateralRatio(_id);     require(         currentCollateralRatio &lt; creditLineConstants[_id].idealCollateralRatio,         'CreditLine: Collateral ratio is higher than ideal value'     );      address _collateralAsset = creditLineConstants[_id].collateralAsset;     address _lender = creditLineConstants[_id].lender;     uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);     address _borrowAsset = creditLineConstants[_id].borrowAsset;      creditLineVariables[_id].status = CreditLineStatus.LIQUIDATED;      if (creditLineConstants[_id].autoLiquidation &amp;&amp; _lender != msg.sender) {         uint256 _borrowTokens = _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens);         if (_borrowAsset == address(0)) {             uint256 _returnETH = msg.value.sub(_borrowTokens, 'Insufficient ETH to liquidate');             if (_returnETH != 0) {                 (bool success, ) = msg.sender.call{value: _returnETH}('');                 require(success, 'Transfer fail');             }         } else {             IERC20(_borrowAsset).safeTransferFrom(msg.sender, _lender, _borrowTokens);         }     }      _transferCollateral(_id, _collateralAsset, _totalCollateralTokens, _toSavingsAccount);      emit CreditLineLiquidated(_id, msg.sender); }  /**  * @notice used to calculate the borrow tokens necessary for liquidator to liquidate  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view  * @param _id identifier for the credit line  * @return borrow tokens necessary for liquidator to liquidate  */ function borrowTokensToLiquidate(uint256 _id) external returns (uint256) {     address _collateralAsset = creditLineConstants[_id].collateralAsset;     uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);     address _borrowAsset = creditLineConstants[_id].borrowAsset;      return _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens); }  function _borrowTokensToLiquidate(     address _borrowAsset,     address _collateralAsset,     uint256 _totalCollateralTokens ) internal view returns (uint256) {     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(_borrowAsset, _collateralAsset);     uint256 _borrowTokens = (         _totalCollateralTokens.mul(uint256(10**30).sub(liquidatorRewardFraction)).div(10**30).mul(_ratioOfPrices).div(10**_decimals)     );      return _borrowTokens; }  receive() external payable {     require(msg.sender == savingsAccount, 'CreditLine::receive invalid transaction'); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Testing Engineer |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Below are the details of our target smart contract codes and their associated test reports: Task: "{task}". Existing Test Reports: "{test_reports}" Based on the given test reports, please identify and succinctly summarize all bugs causing issues within the contract codes. The objective is to obtain a clear and consolidated overview of all identified bugs. Conclude with a comprehensive test report summarizing the findings. |
| **phase_name** | TestBugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Testing Engineer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. Your can simulate various attack scenarios, conduct security testing, and perform code audits to identify vulnerablities and weaknesses in the smart contracts. This inculde analyzing potential exploit paths, assessing the resilience of the contract to common attack vectorsm and suggesting remediation measures Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'task': '// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\n\nimport \'@openzeppelin/contracts/token/ERC20/SafeERC20.sol\';\nimport \'@openzeppelin/contracts/math/SafeMath.sol\';\nimport \'@openzeppelin/contracts/utils/ReentrancyGuard.sol\';\nimport \'@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\';\nimport \'../interfaces/IPriceOracle.sol\';\nimport \'../interfaces/IYield.sol\';\nimport \'../interfaces/ISavingsAccount.sol\';\nimport \'../SavingsAccount/SavingsAccountUtil.sol\';\nimport \'../interfaces/IStrategyRegistry.sol\';\n\n/\n * @title Credit Line contract with Methods related to credit Line\n * @notice Implements the functions related to Credit Line\n * @author Sublime\n /\n\ncontract CreditLine is ReentrancyGuard, OwnableUpgradeable {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    enum CreditLineStatus {\n        NOT_CREATED,\n        REQUESTED,\n        ACTIVE,\n        CLOSED,\n        CANCELLED,\n        LIQUIDATED\n    }\n\n    /\n     * @notice counter that tracks the number of credit lines created\n     * @dev used to create unique identifier for credit lines\n     /\n    uint256 public creditLineCounter;\n\n    uint256 constant YEAR_IN_SECONDS = 365 days;\n\n    struct CreditLineVariables {\n        CreditLineStatus status;\n        uint256 principal;\n        uint256 totalInterestRepaid;\n        uint256 lastPrincipalUpdateTime;\n        uint256 interestAccruedTillLastPrincipalUpdate;\n    }\n\n    struct CreditLineConstants {\n        address lender;\n        address borrower;\n        uint256 borrowLimit;\n        uint256 idealCollateralRatio;\n        uint256 borrowRate;\n        address borrowAsset;\n        address collateralAsset;\n        bool autoLiquidation;\n        bool requestByLender;\n    }\n    /\n     * @notice stores the collateral shares in a credit line per strategy\n     * @dev creditLineId =&gt; Strategy =&gt; collateralShares\n     /\n    mapping(uint256 =&gt; mapping(address =&gt; uint256)) public collateralShareInStrategy;\n\n    /\n     * @notice stores the variables to maintain a credit line\n     /\n    mapping(uint256 =&gt; CreditLineVariables) public creditLineVariables;\n\n    /\n     * @notice stores the constants related to a credit line\n     /\n    mapping(uint256 =&gt; CreditLineConstants) public creditLineConstants;\n\n    /\n     * @notice stores the address of savings account contract\n     /\n    address public savingsAccount;\n\n    /\n     * @notice stores the address of price oracle contract\n     /\n    address public priceOracle;\n\n    /\n     * @notice stores the address of strategy registry contract\n     /\n    address public strategyRegistry;\n\n    /\n     * @notice stores the address of default strategy\n     /\n    address public defaultStrategy;\n\n    /\n     * @notice stores the fraction of borrowed amount charged as fee by protocol\n     * @dev it is multiplied by 1030\n     /\n    uint256 public protocolFeeFraction;\n\n    /\n     * @notice address where protocol fee is collected\n     /\n    address public protocolFeeCollector;\n\n    /\n     * @notice stores the fraction of amount liquidated given as reward to liquidator\n     * @dev it is multiplied by 1030\n     /\n    uint256 public liquidatorRewardFraction;\n    /\n     * @dev checks if Credit Line exists\n     * @param _id identifier for the credit line\n     /\n    modifier ifCreditLineExists(uint256 id) {\n        require(creditLineVariables[_id].status != CreditLineStatus.NOT_CREATED, \'Credit line does not exist\');\n        ;\n    }\n\n    /\n     * @dev checks if called by credit Line Borrower\n     * @param _id creditLine identifier\n     /\n    modifier onlyCreditLineBorrower(uint256 id) {\n        require(creditLineConstants[_id].borrower == msg.sender, \'Only credit line Borrower can access\');\n        ;\n    }\n\n    /\n     * @dev checks if called by credit Line Lender\n     * @param _id creditLine identifier\n     /\n    modifier onlyCreditLineLender(uint256 id) {\n        require(creditLineConstants[_id].lender == msg.sender, \'Only credit line Lender can access\');\n        ;\n    }\n\n    /\n     * @notice emitted when a collateral is deposited into credit line\n     * @param id id of the credit line\n     * @param amount amount of collateral deposited\n     * @param strategy address of the strategy into which collateral is deposited\n     */\n    event CollateralDeposited(uint256 indexed id, uint256 amount, address indexed strategy);\n\n    /\n     * @notice emitted when collateral is withdrawn from credit line\n     * @param id id of the credit line\n     * @param amount amount of collateral withdrawn\n     /\n    event CollateralWithdrawn(uint256 indexed id, uint256 amount);\n\n    /\n     * @notice emitted when a request for new credit line is placed\n     * @param id id of the credit line for which request was made\n     * @param lender address of the lender for credit line\n     * @param borrower address of the borrower for credit line\n     /\n    event CreditLineRequested(uint256 indexed id, address indexed lender, address indexed borrower);\n\n    /\n     * @notice emitted when a credit line is liquidated\n     * @param id id of the credit line which is liquidated\n     * @param liquidator address of the liquidator\n     */\n    event CreditLineLiquidated(uint256 indexed id, address indexed liquidator);\n\n    /\n     * @notice emitted when tokens are borrowed from credit line\n     * @param id id of the credit line from which tokens are borrowed\n     * @param borrowAmount amount of tokens borrowed\n     /\n    event BorrowedFromCreditLine(uint256 indexed id, uint256 borrowAmount);\n\n    /\n     * @notice emitted when credit line is accepted\n     * @param id id of the credit line that was accepted\n     /\n    event CreditLineAccepted(uint256 indexed id);\n\n    /\n     * @notice emitted when credit line is completely repaid and reset\n     * @param id id of the credit line that is reset\n     */\n    event CreditLineReset(uint256 indexed id);\n\n    /\n     * @notice emitted when the credit line is partially repaid\n     * @param id id of the credit line\n     * @param repayAmount amount repaid\n     /\n    event PartialCreditLineRepaid(uint256 indexed id, uint256 repayAmount);\n\n    /\n     * @notice emitted when the credit line is completely repaid\n     * @param id id of the credit line\n     * @param repayAmount amount repaid\n     /\n    event CompleteCreditLineRepaid(uint256 indexed id, uint256 repayAmount);\n\n    /\n     * @notice emitted when the credit line is closed by one of the parties of credit line\n     * @param id id of the credit line\n     */\n    event CreditLineClosed(uint256 indexed id);\n\n    /\n     * @notice emitted when default strategy for the credit line is updated\n     * @param defaultStrategy address of the strategy contract that is used as default by credit lines\n     /\n    event DefaultStrategyUpdated(address indexed defaultStrategy);\n\n    /\n     * @notice emitted when the price oracle is updated\n     * @param priceOracle address of the updated price oracle\n     /\n    event PriceOracleUpdated(address indexed priceOracle);\n\n    /\n     * @notice emitted when the savings account address is updated\n     * @param savingsAccount address of the updated savingsAccount\n     */\n    event SavingsAccountUpdated(address indexed savingsAccount);\n\n    /\n     * @notice emitted when strategy registry address is updated\n     * @param strategyRegistry address of the updated strategy registry\n     /\n    event StrategyRegistryUpdated(address indexed strategyRegistry);\n\n    /\n     * @notice emitted when fee that protocol charges for credit line is updated\n     * @param updatedProtocolFee updated value of protocolFeeFraction\n     /\n    event ProtocolFeeFractionUpdated(uint256 updatedProtocolFee);\n\n    /\n     * @notice emitted when address which receives fee that protocol changes for pools is updated\n     * @param updatedProtocolFeeCollector updated value of protocolFeeCollector\n     */\n    event ProtocolFeeCollectorUpdated(address indexed updatedProtocolFeeCollector);\n\n    /\n     * @notice emitted when liquidatorRewardFraction is updated\n     * @param liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator\n     /\n    event LiquidationRewardFractionUpdated(uint256 liquidatorRewardFraction);\n\n    /\n     * @notice used to initialize the contract\n     * @dev can only be called once during the life cycle of the contract\n     * @param _defaultStrategy default strategy used in credit lines\n     * @param _priceOracle address of the priceOracle\n     * @param _savingsAccount address of  the savings account contract\n     * @param _strategyRegistry address of the strategy registry contract\n     * @param _owner address of owner who can change global variables\n     * @param _protocolFeeFraction fraction of the fee charged by protocol\n     * @param _protocolFeeCollector address to which protocol fee is charged to\n     * @param _liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator\n     /\n    function initialize(\n        address _defaultStrategy,\n        address _priceOracle,\n        address _savingsAccount,\n        address _strategyRegistry,\n        address _owner,\n        uint256 _protocolFeeFraction,\n        address _protocolFeeCollector,\n        uint256 _liquidatorRewardFraction\n    ) external initializer {\n        OwnableUpgradeable.__Ownable_init();\n        OwnableUpgradeable.transferOwnership(_owner);\n\n        _updateDefaultStrategy(_defaultStrategy);\n        _updatePriceOracle(_priceOracle);\n        _updateSavingsAccount(_savingsAccount);\n        _updateStrategyRegistry(_strategyRegistry);\n        _updateProtocolFeeFraction(_protocolFeeFraction);\n        _updateProtocolFeeCollector(_protocolFeeCollector);\n        _updateLiquidatorRewardFraction(_liquidatorRewardFraction);\n    }\n\n    /\n     * @notice used to update the default strategy\n     * @dev can only be updated by owner\n     * @param _defaultStrategy address of the updated default strategy\n     */\n    function updateDefaultStrategy(address _defaultStrategy) external onlyOwner {\n        _updateDefaultStrategy(_defaultStrategy);\n    }\n\n    function _updateDefaultStrategy(address _defaultStrategy) internal {\n        defaultStrategy = _defaultStrategy;\n        emit DefaultStrategyUpdated(_defaultStrategy);\n    }\n\n    /\n     * @notice used to update the price oracle\n     * @dev can only be updated by owner\n     * @param _priceOracle address of the updated price oracle\n     /\n    function updatePriceOracle(address _priceOracle) external onlyOwner {\n        _updatePriceOracle(_priceOracle);\n    }\n\n    function _updatePriceOracle(address _priceOracle) internal {\n        priceOracle = _priceOracle;\n        emit PriceOracleUpdated(_priceOracle);\n    }\n\n    /\n     * @notice used to update the savings account address\n     * @dev can only be updated by owner\n     * @param _savingsAccount address of the updated savings account\n     /\n    function updateSavingsAccount(address _savingsAccount) external onlyOwner {\n        _updateSavingsAccount(_savingsAccount);\n    }\n\n    function _updateSavingsAccount(address _savingsAccount) internal {\n        savingsAccount = _savingsAccount;\n        emit SavingsAccountUpdated(_savingsAccount);\n    }\n\n    /\n     * @notice used to update the protocol fee fraction\n     * @dev can only be updated by owner\n     * @param _protocolFee fraction of the borrower amount collected as protocol fee\n     */\n    function updateProtocolFeeFraction(uint256 _protocolFee) external onlyOwner {\n        _updateProtocolFeeFraction(_protocolFee);\n    }\n\n    function _updateProtocolFeeFraction(uint256 _protocolFee) internal {\n        protocolFeeFraction = _protocolFee;\n        emit ProtocolFeeFractionUpdated(_protocolFee);\n    }\n\n    /\n     * @notice used to update the protocol fee collector\n     * @dev can only be updated by owner\n     * @param _protocolFeeCollector address in which protocol fee is collected\n     /\n    function updateProtocolFeeCollector(address _protocolFeeCollector) external onlyOwner {\n        _updateProtocolFeeCollector(_protocolFeeCollector);\n    }\n\n    function _updateProtocolFeeCollector(address _protocolFeeCollector) internal {\n        require(_protocolFeeCollector != address(0), \'cant be 0 address\');\n        protocolFeeCollector = _protocolFeeCollector;\n        emit ProtocolFeeCollectorUpdated(_protocolFeeCollector);\n    }\n\n    /\n     * @notice used to update the strategy registry address\n     * @dev can only be updated by owner\n     * @param _strategyRegistry address of the updated strategy registry\n     /\n    function updateStrategyRegistry(address _strategyRegistry) external onlyOwner {\n        _updateStrategyRegistry(_strategyRegistry);\n    }\n\n    function _updateStrategyRegistry(address _strategyRegistry) internal {\n        require(_strategyRegistry != address(0), \'CL::I zero address\');\n        strategyRegistry = _strategyRegistry;\n        emit StrategyRegistryUpdated(_strategyRegistry);\n    }\n\n    /\n     * @notice used to update the liquidatorRewardFraction\n     * @dev can only be updated by owner\n     * @param _rewardFraction fraction of liquidated amount given to liquidator as reward\n     */\n    function updateLiquidatorRewardFraction(uint256 _rewardFraction) external onlyOwner {\n        _updateLiquidatorRewardFraction(_rewardFraction);\n    }\n\n    function _updateLiquidatorRewardFraction(uint256 _rewardFraction) internal {\n        require(_rewardFraction &lt;= 1030, \'Fraction has to be less than 1\');\n        liquidatorRewardFraction = _rewardFraction;\n        emit LiquidationRewardFractionUpdated(_rewardFraction);\n    }\n\n    /\n     * @dev Used to Calculate Interest Per second on given principal and Interest rate\n     * @param _principal principal Amount for which interest has to be calculated.\n     * @param _borrowRate It is the Interest Rate at which Credit Line is approved\n     * @return interest per second for the given parameters\n     */\n    function calculateInterest(\n        uint256 _principal,\n        uint256 _borrowRate,\n        uint256 _timeElapsed\n    ) public pure returns (uint256) {\n        uint256 _interest = _principal.mul(_borrowRate).mul(_timeElapsed).div(1030).div(YEAR_IN_SECONDS);\n\n        return _interest;\n    }\n\n    /\n     * @dev Used to calculate interest accrued since last repayment\n     * @param _id identifier for the credit line\n     * @return interest accrued over current borrowed amount since last repayment\n     */\n\n    function calculateInterestAccrued(uint256 _id) public view returns (uint256) {\n        uint256 _lastPrincipalUpdateTime = creditLineVariables[_id].lastPrincipalUpdateTime;\n        if (_lastPrincipalUpdateTime == 0) return 0;\n        uint256 _timeElapsed = (block.timestamp).sub(_lastPrincipalUpdateTime);\n        uint256 _interestAccrued = calculateInterest(creditLineVariables[_id].principal, creditLineConstants[_id].borrowRate, _timeElapsed);\n        return _interestAccrued;\n    }\n\n    /\n     * @dev Used to calculate current debt of borrower against a credit line.\n     * @param _id identifier for the credit line\n     * @return current debt of borrower\n     /\n    function calculateCurrentDebt(uint256 _id) public view returns (uint256) {\n        uint256 _interestAccrued = calculateInterestAccrued(_id);\n        uint256 _currentDebt = (creditLineVariables[_id].principal)\n            .add(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate)\n            .add(_interestAccrued)\n            .sub(creditLineVariables[_id].totalInterestRepaid);\n        return _currentDebt;\n    }\n\n    /\n     * @notice used to calculate amount that can be borrowed by the borrower\n     * @dev is a view function for the protocol itself, but isn\'t view because of getTokensForShares which is not view.\n            borrowableAmount changes per block as interest changes per block.\n     * @param _id identifier for the credit line\n     * @return amount that can be borrowed from the credit line\n     /\n    function calculateBorrowableAmount(uint256 _id) public returns (uint256) {\n        CreditLineStatus _status = creditLineVariables[_id].status;\n        require(\n            _status == CreditLineStatus.ACTIVE || _status == CreditLineStatus.REQUESTED,\n            \'CreditLine: Cannot only if credit line ACTIVE or REQUESTED\'\n        );\n        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(\n            creditLineConstants[_id].collateralAsset,\n            creditLineConstants[_id].borrowAsset\n        );\n\n        uint256 _totalCollateralToken = calculateTotalCollateralTokens(_id);\n\n        uint256 _currentDebt = calculateCurrentDebt(_id);\n\n        uint256 _maxPossible = _totalCollateralToken.mul(_ratioOfPrices).div(creditLineConstants[_id].idealCollateralRatio).mul(1030).div(\n            10_decimals\n        );\n\n        uint256 _borrowLimit = creditLineConstants[_id].borrowLimit;\n\n        if (_maxPossible &gt; _borrowLimit) {\n            _maxPossible = _borrowLimit;\n        }\n        if (_maxPossible &gt; _currentDebt) {\n            return _maxPossible.sub(_currentDebt);\n        }\n        return 0;\n    }\n\n    function updateinterestAccruedTillLastPrincipalUpdate(uint256 _id) internal {\n        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, \'CreditLine: The credit line is not yet active.\');\n\n        uint256 _interestAccrued = calculateInterestAccrued(_id);\n        uint256 _newInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(_interestAccrued);\n        creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _newInterestAccrued;\n    }\n\n    function _depositCollateralFromSavingsAccount(\n        uint256 _id,\n        uint256 _amount,\n        address _sender\n    ) internal {\n        address _collateralAsset = creditLineConstants[_id].collateralAsset;\n        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();\n        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);\n        uint256 _activeAmount;\n\n        for (uint256 _index = 0; _index &lt; _strategyList.length; _index++) {\n            address _strategy = _strategyList[_index];\n            uint256 _liquidityShares = _savingsAccount.balanceInShares(_sender, _collateralAsset, _strategy);\n            if (_liquidityShares == 0 || _strategyList[_index] == address(0)) {\n                continue;\n            }\n            uint256 _tokenInStrategy = _liquidityShares;\n            _tokenInStrategy = IYield(_strategy).getTokensForShares(_liquidityShares, _collateralAsset);\n\n            uint256 _tokensToTransfer = _tokenInStrategy;\n            if (_activeAmount.add(_tokenInStrategy) &gt;= _amount) {\n                _tokensToTransfer = (_amount.sub(_activeAmount));\n            }\n            _activeAmount = _activeAmount.add(_tokensToTransfer);\n            _savingsAccount.transferFrom(_tokensToTransfer, _collateralAsset, _strategy, _sender, address(this));\n\n            collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(\n                _liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy)\n            );\n\n            if (_amount == _activeAmount) {\n                return;\n            }\n        }\n        revert(\'CreditLine::_depositCollateralFromSavingsAccount - Insufficient balance\');\n    }\n\n    /\n     * @notice used to request a credit line either by borrower or lender\n     * @param _requestTo Address to which creditLine is requested, \n                        if borrower creates request then lender address and \n                        if lender creates then borrower address\n     * @param _borrowLimit maximum borrow amount in a credit line\n     * @param _borrowRate Interest Rate at which credit Line is requested\n     * @param _autoLiquidation if true, anyone can liquidate loan, otherwise only lender\n     * @param _collateralRatio ratio of the collateral to the debt below which credit line can be liquidated\n     * @param _borrowAsset address of the token to be borrowed\n     * @param _collateralAsset address of the token provided as collateral\n     * @param _requestAsLender if true, lender is placing request, otherwise borrower\n     * @return identifier for the credit line\n     */\n\n    function request(\n        address _requestTo,\n        uint256 _borrowLimit,\n        uint256 _borrowRate,\n        bool _autoLiquidation,\n        uint256 _collateralRatio,\n        address _borrowAsset,\n        address _collateralAsset,\n        bool _requestAsLender\n    ) external returns (uint256) {\n        require(_borrowAsset != _collateralAsset, \'R: cant borrow lent token\');\n        require(IPriceOracle(priceOracle).doesFeedExist(_borrowAsset, _collateralAsset), \'R: No price feed\');\n\n        address _lender = _requestTo;\n        address _borrower = msg.sender;\n        if (_requestAsLender) {\n            _lender = msg.sender;\n            _borrower = _requestTo;\n        }\n\n        uint256 _id = _createRequest(\n            _lender,\n            _borrower,\n            _borrowLimit,\n            _borrowRate,\n            _autoLiquidation,\n            _collateralRatio,\n            _borrowAsset,\n            _collateralAsset,\n            _requestAsLender\n        );\n\n        emit CreditLineRequested(_id, _lender, _borrower);\n        return _id;\n    }\n\n    function _createRequest(\n        address _lender,\n        address _borrower,\n        uint256 _borrowLimit,\n        uint256 _borrowRate,\n        bool _autoLiquidation,\n        uint256 _collateralRatio,\n        address _borrowAsset,\n        address _collateralAsset,\n        bool _requestByLender\n    ) internal returns (uint256) {\n        require(_lender != _borrower, \'Lender and Borrower cannot be same addresses\');\n        uint256 _id = creditLineCounter + 1;\n        creditLineCounter = _id;\n        creditLineVariables[_id].status = CreditLineStatus.REQUESTED;\n        creditLineConstants[_id].borrower = _borrower;\n        creditLineConstants[_id].lender = _lender;\n        creditLineConstants[_id].borrowLimit = _borrowLimit;\n        creditLineConstants[_id].autoLiquidation = _autoLiquidation;\n        creditLineConstants[_id].idealCollateralRatio = _collateralRatio;\n        creditLineConstants[_id].borrowRate = _borrowRate;\n        creditLineConstants[_id].borrowAsset = _borrowAsset;\n        creditLineConstants[_id].collateralAsset = _collateralAsset;\n        creditLineConstants[_id].requestByLender = _requestByLender;\n        return _id;\n    }\n\n    /\n     * @notice used to accept a credit line\n     * @dev if borrower places request, lender can accept and vice versa\n     * @param _id identifier for the credit line\n     /\n    function accept(uint256 _id) external {\n        require(\n            creditLineVariables[_id].status == CreditLineStatus.REQUESTED,\n            \'CreditLine::acceptCreditLineLender - CreditLine is already accepted\'\n        );\n        bool _requestByLender = creditLineConstants[_id].requestByLender;\n        require(\n            (msg.sender == creditLineConstants[_id].borrower &amp;&amp; _requestByLender) ||\n                (msg.sender == creditLineConstants[_id].lender &amp;&amp; !_requestByLender),\n            "Only Borrower or Lender who hasn\'t requested can accept"\n        );\n        creditLineVariables[_id].status = CreditLineStatus.ACTIVE;\n        emit CreditLineAccepted(_id);\n    }\n\n    /\n     * @notice used to deposit collateral into the credit line\n     * @dev collateral tokens have to be approved in savingsAccount or token contract(unless ether).\n            If transferred from savings account, the tokens are transferred from strategies in the \n            order prespecified in strategy registry\n     * @param _id identifier for the credit line\n     * @param _amount amount of collateral being deposited\n     * @param _strategy strategy to which collateral is to be deposited in case transfer is not from savings account\n     * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount \n                                otherwise direct from collateral token contract\n     /\n    function depositCollateral(\n        uint256 _id,\n        uint256 _amount,\n        address _strategy,\n        bool _fromSavingsAccount\n    ) external payable nonReentrant ifCreditLineExists(_id) {\n        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, \'CreditLine not active\');\n        _depositCollateral(_id, _amount, _strategy, _fromSavingsAccount);\n        emit CollateralDeposited(_id, _amount, _strategy);\n    }\n\n    function _depositCollateral(\n        uint256 _id,\n        uint256 _amount,\n        address _strategy,\n        bool _fromSavingsAccount\n    ) internal {\n        require(creditLineConstants[_id].lender != msg.sender, \'lender cant deposit collateral\');\n        if (_fromSavingsAccount) {\n            _depositCollateralFromSavingsAccount(_id, _amount, msg.sender);\n        } else {\n            address _collateralAsset = creditLineConstants[_id].collateralAsset;\n            ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);\n            if (_collateralAsset == address(0)) {\n                require(msg.value == _amount, "CreditLine::_depositCollateral - value to transfer doesn\'t match argument");\n            } else {\n                IERC20(_collateralAsset).safeTransferFrom(msg.sender, address(this), _amount);\n                IERC20(_collateralAsset).approve(_strategy, _amount);\n            }\n            uint256 _sharesReceived = _savingsAccount.deposit{value: msg.value}(_amount, _collateralAsset, _strategy, address(this));\n            collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(_sharesReceived);\n        }\n    }\n\n    function _withdrawBorrowAmount(\n        address _asset,\n        uint256 _amountInTokens,\n        address _lender\n    ) internal {\n        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();\n        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);\n        uint256 _activeAmount;\n        for (uint256 _index = 0; _index &lt; _strategyList.length; _index++) {\n            if (_strategyList[_index] == address(0)) {\n                continue;\n            }\n            uint256 _liquidityShares = _savingsAccount.balanceInShares(_lender, _asset, _strategyList[_index]);\n            if (_liquidityShares != 0) {\n                uint256 tokenInStrategy = _liquidityShares;\n                tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);\n                uint256 _tokensToTransfer = tokenInStrategy;\n                if (_activeAmount.add(tokenInStrategy) &gt;= _amountInTokens) {\n                    _tokensToTransfer = (_amountInTokens.sub(_activeAmount));\n                }\n                _activeAmount = _activeAmount.add(_tokensToTransfer);\n                _savingsAccount.withdrawFrom(_tokensToTransfer, _asset, _strategyList[_index], _lender, address(this), false);\n                if (_activeAmount == _amountInTokens) {\n                    return;\n                }\n            }\n        }\n        require(_activeAmount == _amountInTokens, \'insufficient balance\');\n    }\n\n    /\n     * @notice used to borrow tokens from credit line by borrower\n     * @dev only borrower can call this function. Amount that can actually be borrowed is \n            min(amount based on borrowLimit, allowance to creditLine contract, balance of lender)\n     * @param _id identifier for the credit line\n     * @param _amount amount of tokens to borrow\n     */\n    function borrow(uint256 _id, uint256 _amount) external payable nonReentrant onlyCreditLineBorrower(_id) {\n        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, \'CreditLine: The credit line is not yet active.\');\n        uint256 _borrowableAmount = calculateBorrowableAmount(_id);\n        require(_amount &lt;= _borrowableAmount, "CreditLine::borrow - The current collateral ratio doesn\'t allow to withdraw the amount");\n        address _borrowAsset = creditLineConstants[_id].borrowAsset;\n        address _lender = creditLineConstants[_id].lender;\n\n        updateinterestAccruedTillLastPrincipalUpdate(_id);\n        creditLineVariables[_id].principal = creditLineVariables[_id].principal.add(_amount);\n        creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;\n\n        uint256 _tokenDiffBalance;\n        if (_borrowAsset != address(0)) {\n            uint256 _balanceBefore = IERC20(_borrowAsset).balanceOf(address(this));\n            _withdrawBorrowAmount(_borrowAsset, _amount, _lender);\n            uint256 _balanceAfter = IERC20(_borrowAsset).balanceOf(address(this));\n            _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);\n        } else {\n            uint256 _balanceBefore = address(this).balance;\n            _withdrawBorrowAmount(_borrowAsset, _amount, _lender);\n            uint256 _balanceAfter = address(this).balance;\n            _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);\n        }\n        uint256 _protocolFee = _tokenDiffBalance.mul(protocolFeeFraction).div(1030);\n        _tokenDiffBalance = _tokenDiffBalance.sub(_protocolFee);\n\n        if (_borrowAsset == address(0)) {\n            (bool feeSuccess, ) = protocolFeeCollector.call{value: _protocolFee}(\'\');\n            require(feeSuccess, \'Transfer fail\');\n            (bool success, ) = msg.sender.call{value: _tokenDiffBalance}(\'\');\n            require(success, \'Transfer fail\');\n        } else {\n            IERC20(_borrowAsset).safeTransfer(protocolFeeCollector, _protocolFee);\n            IERC20(_borrowAsset).safeTransfer(msg.sender, _tokenDiffBalance);\n        }\n        emit BorrowedFromCreditLine(_id, _tokenDiffBalance);\n    }\n\n    function _repayFromSavingsAccount(\n        uint256 _amount,\n        address _asset,\n        address _lender\n    ) internal {\n        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();\n        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);\n        uint256 _activeAmount;\n\n        for (uint256 _index = 0; _index &lt; _strategyList.length; _index++) {\n            if (_strategyList[_index] == address(0)) {\n                continue;\n            }\n            uint256 _liquidityShares = _savingsAccount.balanceInShares(msg.sender, _asset, _strategyList[_index]);\n            if (_liquidityShares == 0) {\n                continue;\n            }\n            uint256 _tokenInStrategy = _liquidityShares;\n            _tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);\n\n            uint256 _tokensToTransfer = _tokenInStrategy;\n            if (_activeAmount.add(_tokenInStrategy) &gt;= _amount) {\n                _tokensToTransfer = (_amount.sub(_activeAmount));\n            }\n            _activeAmount = _activeAmount.add(_tokensToTransfer);\n            _savingsAccount.transferFrom(_tokensToTransfer, _asset, _strategyList[_index], msg.sender, _lender);\n\n            if (_amount == _activeAmount) {\n                return;\n            }\n        }\n        revert(\'CreditLine::_repayFromSavingsAccount - Insufficient balance\');\n    }\n\n    function _repay(\n        uint256 _id,\n        uint256 _amount,\n        bool _fromSavingsAccount,\n        uint256 _principalPaid\n    ) internal {\n        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);\n        address _defaultStrategy = defaultStrategy;\n        address _borrowAsset = creditLineConstants[_id].borrowAsset;\n        address _lender = creditLineConstants[_id].lender;\n        if (!_fromSavingsAccount) {\n            if (_borrowAsset == address(0)) {\n                require(msg.value == _amount, \'creditLine::repay - Ether sent not equal to repay amount\');\n                _savingsAccount.deposit{value: _amount}(_amount, _borrowAsset, _defaultStrategy, _lender);\n            } else {\n                IERC20(_borrowAsset).safeTransferFrom(msg.sender, address(this), _amount);\n                IERC20(_borrowAsset).approve(_defaultStrategy, _amount);\n                _savingsAccount.deposit(_amount, _borrowAsset, _defaultStrategy, _lender);\n            }\n        } else {\n            _repayFromSavingsAccount(_amount, _borrowAsset, _lender);\n        }\n        if (_principalPaid != 0) {\n            _savingsAccount.increaseAllowanceToCreditLine(_principalPaid, _borrowAsset, _lender);\n        }\n    }\n\n    /\n     * @notice used to repay interest and principal to credit line. Interest has to be repaid before repaying principal\n     * @dev partial repayments possible\n     * @param _id identifier for the credit line\n     * @param _amount amount being repaid\n     * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount \n                                otherwise direct from collateral token contract\n     */\n    function repay(\n        uint256 _id,\n        uint256 _amount,\n        bool _fromSavingsAccount\n    ) external payable nonReentrant {\n        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, \'CreditLine: The credit line is not yet active.\');\n        require(creditLineConstants[_id].lender != msg.sender, \'Lender cant repay\');\n\n        uint256 _interestSincePrincipalUpdate = calculateInterestAccrued(_id);\n        uint256 _totalInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(\n            _interestSincePrincipalUpdate\n        );\n        uint256 _interestToPay = _totalInterestAccrued.sub(creditLineVariables[_id].totalInterestRepaid);\n        uint256 _totalCurrentDebt = _interestToPay.add(creditLineVariables[_id].principal);\n        uint256 _principalPaid = 0;\n\n        if (_amount &gt;= _totalCurrentDebt) {\n            _amount = _totalCurrentDebt;\n            emit CompleteCreditLineRepaid(_id, _amount);\n        } else {\n            emit PartialCreditLineRepaid(_id, _amount);\n        }\n\n        if (_amount &gt; _interestToPay) {\n            creditLineVariables[_id].principal = _totalCurrentDebt.sub(_amount);\n            creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _totalInterestAccrued;\n            creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;\n            creditLineVariables[_id].totalInterestRepaid = _totalInterestAccrued;\n            _principalPaid = _amount.sub(_interestToPay);\n        } else {\n            creditLineVariables[_id].totalInterestRepaid = creditLineVariables[_id].totalInterestRepaid.add(_amount);\n        }\n\n        _repay(_id, _amount, _fromSavingsAccount, _principalPaid);\n\n        if (creditLineVariables[_id].principal == 0) {\n            _resetCreditLine(_id);\n        }\n    }\n\n    function _resetCreditLine(uint256 _id) internal {\n        creditLineVariables[_id].lastPrincipalUpdateTime = 0;\n        creditLineVariables[_id].totalInterestRepaid = 0;\n        creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = 0;\n        emit CreditLineReset(_id);\n    }\n\n    /\n     * @dev used to close credit line by borrower or lender\n     * @param _id identifier for the credit line\n     /\n    function close(uint256 _id) external ifCreditLineExists(_id) {\n        require(\n            msg.sender == creditLineConstants[_id].borrower || msg.sender == creditLineConstants[_id].lender,\n            \'CreditLine: Permission denied while closing Line of credit\'\n        );\n        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, \'CreditLine: Credit line should be active.\');\n        require(creditLineVariables[_id].principal == 0, \'CreditLine: Cannot be closed since not repaid.\');\n        require(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate == 0, \'CreditLine: Cannot be closed since not repaid.\');\n        creditLineVariables[_id].status = CreditLineStatus.CLOSED;\n        emit CreditLineClosed(_id);\n    }\n\n    /\n     * @notice used to calculate the current collateral ratio\n     * @dev is a view function for the protocol itself, but isn\'t view because of getTokensForShares which is not view.\n            Interest is also considered while calculating debt\n     * @param _id identifier for the credit line\n     * @return collateral ratio multiplied by 1030 to retain precision\n     /\n    function calculateCurrentCollateralRatio(uint256 _id) public ifCreditLineExists(_id) returns (uint256) {\n        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(\n            creditLineConstants[_id].collateralAsset,\n            creditLineConstants[_id].borrowAsset\n        );\n\n        uint256 currentDebt = calculateCurrentDebt(_id);\n        uint256 currentCollateralRatio = calculateTotalCollateralTokens(_id).mul(_ratioOfPrices).div(currentDebt).mul(1030).div(\n            10_decimals\n        );\n\n        return currentCollateralRatio;\n    }\n\n    /\n     * @notice used to calculate the total collateral tokens\n     * @dev is a view function for the protocol itself, but isn\'t view because of getTokensForShares which is not view\n     * @param _id identifier for the credit line\n     * @return _amount total collateral tokens deposited into the credit line\n     */\n    function calculateTotalCollateralTokens(uint256 _id) public returns (uint256 _amount) {\n        address _collateralAsset = creditLineConstants[_id].collateralAsset;\n        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();\n        uint256 _liquidityShares;\n        for (uint256 index = 0; index &lt; _strategyList.length; index++) {\n            if (_strategyList[index] == address(0)) {\n                continue;\n            }\n            _liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];\n            uint256 _tokenInStrategy = _liquidityShares;\n            _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(_liquidityShares, _collateralAsset);\n\n            _amount = _amount.add(_tokenInStrategy);\n        }\n    }\n\n    /\n     * @notice used to withdraw any excess collateral\n     * @dev collateral can\'t be withdraw if collateralRatio goes below the ideal value. Only borrower can withdraw\n     * @param _id identifier for the credit line\n     * @param _amount amount of collateral to withdraw\n     * @param _toSavingsAccount if true, tokens are transferred from savingsAccount \n                                otherwise direct from collateral token contract\n     /\n    function withdrawCollateral(\n        uint256 _id,\n        uint256 _amount,\n        bool _toSavingsAccount\n    ) external nonReentrant onlyCreditLineBorrower(_id) {\n        uint256 _withdrawableCollateral = withdrawableCollateral(_id);\n        require(_amount &lt;= _withdrawableCollateral, \'Collateral ratio cant go below ideal\');\n        address _collateralAsset = creditLineConstants[_id].collateralAsset;\n        _transferCollateral(_id, _collateralAsset, _amount, _toSavingsAccount);\n        emit CollateralWithdrawn(_id, _amount);\n    }\n\n    /\n     * @notice used to calculate the collateral that can be withdrawn\n     * @dev is a view function for the protocol itself, but isn\'t view because of getTokensForShares which is not view\n     * @param _id identifier for the credit line\n     * @return total collateral withdrawable by borrower\n     /\n    function withdrawableCollateral(uint256 _id) public returns (uint256) {\n        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(\n            creditLineConstants[_id].collateralAsset,\n            creditLineConstants[_id].borrowAsset\n        );\n\n        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);\n        uint256 _currentDebt = calculateCurrentDebt(_id);\n\n        uint256 _collateralNeeded = _currentDebt\n            .mul(creditLineConstants[_id].idealCollateralRatio)\n            .div(_ratioOfPrices)\n            .mul(10_decimals)\n            .div(1030);\n\n        if (_collateralNeeded &gt;= _totalCollateralTokens) {\n            return 0;\n        }\n        return _totalCollateralTokens.sub(_collateralNeeded);\n    }\n\n    function _transferCollateral(\n        uint256 _id,\n        address _asset,\n        uint256 _amountInTokens,\n        bool _toSavingsAccount\n    ) internal {\n        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();\n        uint256 _activeAmount;\n        for (uint256 index = 0; index &lt; _strategyList.length; index++) {\n            uint256 liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];\n            if (liquidityShares == 0 || _strategyList[index] == address(0)) {\n                continue;\n            }\n            uint256 _tokenInStrategy = liquidityShares;\n            _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(liquidityShares, _asset);\n            uint256 _tokensToTransfer = _tokenInStrategy;\n            if (_activeAmount.add(_tokenInStrategy) &gt; _amountInTokens) {\n                _tokensToTransfer = _amountInTokens.sub(_activeAmount);\n                liquidityShares = liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy);\n            }\n            _activeAmount = _activeAmount.add(_tokensToTransfer);\n            collateralShareInStrategy[_id][_strategyList[index]] = collateralShareInStrategy[_id][_strategyList[index]].sub(\n                liquidityShares\n            );\n            if (_toSavingsAccount) {\n                ISavingsAccount(savingsAccount).transfer(_tokensToTransfer, _asset, _strategyList[index], msg.sender);\n            } else {\n                ISavingsAccount(savingsAccount).withdraw(_tokensToTransfer, _asset, _strategyList[index], msg.sender, false);\n            }\n\n            if (_activeAmount == _amountInTokens) {\n                return;\n            }\n        }\n        revert(\'insufficient collateral\');\n    }\n\n    /\n     * @notice used to liquidate credit line in case collateral ratio goes below the threshold\n     * @dev if lender liquidates, then collateral is directly transferred. \n            If autoLiquidation is true, anyone can liquidate by providing enough borrow tokens\n     * @param _id identifier for the credit line\n     * @param _toSavingsAccount if true, tokens are transferred from savingsAccount \n                                otherwise direct from collateral token contract\n     */\n    function liquidate(uint256 _id, bool _toSavingsAccount) external payable nonReentrant {\n        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, \'CreditLine: Credit line should be active.\');\n        require(creditLineVariables[_id].principal != 0, \'CreditLine: cannot liquidate if principal is 0\');\n\n        uint256 currentCollateralRatio = calculateCurrentCollateralRatio(_id);\n        require(\n            currentCollateralRatio &lt; creditLineConstants[_id].idealCollateralRatio,\n            \'CreditLine: Collateral ratio is higher than ideal value\'\n        );\n\n        address _collateralAsset = creditLineConstants[_id].collateralAsset;\n        address _lender = creditLineConstants[_id].lender;\n        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);\n        address _borrowAsset = creditLineConstants[_id].borrowAsset;\n\n        creditLineVariables[_id].status = CreditLineStatus.LIQUIDATED;\n\n        if (creditLineConstants[_id].autoLiquidation &amp;&amp; _lender != msg.sender) {\n            uint256 _borrowTokens = _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens);\n            if (_borrowAsset == address(0)) {\n                uint256 _returnETH = msg.value.sub(_borrowTokens, \'Insufficient ETH to liquidate\');\n                if (_returnETH != 0) {\n                    (bool success, ) = msg.sender.call{value: _returnETH}(\'\');\n                    require(success, \'Transfer fail\');\n                }\n            } else {\n                IERC20(_borrowAsset).safeTransferFrom(msg.sender, _lender, _borrowTokens);\n            }\n        }\n\n        _transferCollateral(_id, _collateralAsset, _totalCollateralTokens, _toSavingsAccount);\n\n        emit CreditLineLiquidated(_id, msg.sender);\n    }\n\n    /\n     * @notice used to calculate the borrow tokens necessary for liquidator to liquidate\n     * @dev is a view function for the protocol itself, but isn\'t view because of getTokensForShares which is not view\n     * @param _id identifier for the credit line\n     * @return borrow tokens necessary for liquidator to liquidate\n     /\n    function borrowTokensToLiquidate(uint256 _id) external returns (uint256) {\n        address _collateralAsset = creditLineConstants[_id].collateralAsset;\n        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);\n        address _borrowAsset = creditLineConstants[_id].borrowAsset;\n\n        return _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens);\n    }\n\n    function _borrowTokensToLiquidate(\n        address _borrowAsset,\n        address _collateralAsset,\n        uint256 _totalCollateralTokens\n    ) internal view returns (uint256) {\n        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(_borrowAsset, _collateralAsset);\n        uint256 _borrowTokens = (\n            _totalCollateralTokens.mul(uint256(1030).sub(liquidatorRewardFraction)).div(1030).mul(_ratioOfPrices).div(10*_decimals)\n        );\n\n        return _borrowTokens;\n    }\n\n    receive() external payable {\n        require(msg.sender == savingsAccount, \'CreditLine::receive invalid transaction\');\n    }\n}\n', 'ideas': ' Security', 'test_reports': 'The software run successfully without errors.', 'exist_bugs_flag': False} |

[2024-22-08 11:44:00 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Testing Engineer |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Testing Engineer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. Your can simulate various attack scenarios, conduct security testing, and perform code audits to identify vulnerablities and weaknesses in the smart contracts. This inculde analyzing potential exploit paths, assessing the resilience of the contract to common attack vectorsm and suggesting remediation measures Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol'; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/utils/ReentrancyGuard.sol'; import '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol'; import '../interfaces/IPriceOracle.sol'; import '../interfaces/IYield.sol'; import '../interfaces/ISavingsAccount.sol'; import '../SavingsAccount/SavingsAccountUtil.sol'; import '../interfaces/IStrategyRegistry.sol'; /  * @title Credit Line contract with Methods related to credit Line  * @notice Implements the functions related to Credit Line  * @author Sublime  / contract CreditLine is ReentrancyGuard, OwnableUpgradeable {     using SafeERC20 for IERC20;     using SafeMath for uint256; enum CreditLineStatus {     NOT_CREATED,     REQUESTED,     ACTIVE,     CLOSED,     CANCELLED,     LIQUIDATED }  /**  * @notice counter that tracks the number of credit lines created  * @dev used to create unique identifier for credit lines  **/ uint256 public creditLineCounter;  uint256 constant YEAR_IN_SECONDS = 365 days;  struct CreditLineVariables {     CreditLineStatus status;     uint256 principal;     uint256 totalInterestRepaid;     uint256 lastPrincipalUpdateTime;     uint256 interestAccruedTillLastPrincipalUpdate; }  struct CreditLineConstants {     address lender;     address borrower;     uint256 borrowLimit;     uint256 idealCollateralRatio;     uint256 borrowRate;     address borrowAsset;     address collateralAsset;     bool autoLiquidation;     bool requestByLender; } /**  * @notice stores the collateral shares in a credit line per strategy  * @dev creditLineId =&gt; Strategy =&gt; collateralShares  **/ mapping(uint256 =&gt; mapping(address =&gt; uint256)) public collateralShareInStrategy;  /**  * @notice stores the variables to maintain a credit line  **/ mapping(uint256 =&gt; CreditLineVariables) public creditLineVariables;  /**  * @notice stores the constants related to a credit line  **/ mapping(uint256 =&gt; CreditLineConstants) public creditLineConstants;  /**  * @notice stores the address of savings account contract  **/ address public savingsAccount;  /**  * @notice stores the address of price oracle contract  **/ address public priceOracle;  /**  * @notice stores the address of strategy registry contract  **/ address public strategyRegistry;  /**  * @notice stores the address of default strategy  **/ address public defaultStrategy;  /**  * @notice stores the fraction of borrowed amount charged as fee by protocol  * @dev it is multiplied by 10**30  **/ uint256 public protocolFeeFraction;  /**  * @notice address where protocol fee is collected  **/ address public protocolFeeCollector;  /**  * @notice stores the fraction of amount liquidated given as reward to liquidator  * @dev it is multiplied by 10**30  **/ uint256 public liquidatorRewardFraction; /**  * @dev checks if Credit Line exists  * @param _id identifier for the credit line  **/ modifier ifCreditLineExists(uint256 _id) {     require(creditLineVariables[_id].status != CreditLineStatus.NOT_CREATED, 'Credit line does not exist');     _; }  /**  * @dev checks if called by credit Line Borrower  * @param _id creditLine identifier  **/ modifier onlyCreditLineBorrower(uint256 _id) {     require(creditLineConstants[_id].borrower == msg.sender, 'Only credit line Borrower can access');     _; }  /**  * @dev checks if called by credit Line Lender  * @param _id creditLine identifier  **/ modifier onlyCreditLineLender(uint256 _id) {     require(creditLineConstants[_id].lender == msg.sender, 'Only credit line Lender can access');     _; }  /**  * @notice emitted when a collateral is deposited into credit line  * @param id id of the credit line  * @param amount amount of collateral deposited  * @param strategy address of the strategy into which collateral is deposited  */ event CollateralDeposited(uint256 indexed id, uint256 amount, address indexed strategy);  /**  * @notice emitted when collateral is withdrawn from credit line  * @param id id of the credit line  * @param amount amount of collateral withdrawn  */ event CollateralWithdrawn(uint256 indexed id, uint256 amount);  /**  * @notice emitted when a request for new credit line is placed  * @param id id of the credit line for which request was made  * @param lender address of the lender for credit line  * @param borrower address of the borrower for credit line  */ event CreditLineRequested(uint256 indexed id, address indexed lender, address indexed borrower);  /**  * @notice emitted when a credit line is liquidated  * @param id id of the credit line which is liquidated  * @param liquidator address of the liquidator  */ event CreditLineLiquidated(uint256 indexed id, address indexed liquidator);  /**  * @notice emitted when tokens are borrowed from credit line  * @param id id of the credit line from which tokens are borrowed  * @param borrowAmount amount of tokens borrowed  */ event BorrowedFromCreditLine(uint256 indexed id, uint256 borrowAmount);  /**  * @notice emitted when credit line is accepted  * @param id id of the credit line that was accepted  */ event CreditLineAccepted(uint256 indexed id);  /**  * @notice emitted when credit line is completely repaid and reset  * @param id id of the credit line that is reset  */ event CreditLineReset(uint256 indexed id);  /**  * @notice emitted when the credit line is partially repaid  * @param id id of the credit line  * @param repayAmount amount repaid  */ event PartialCreditLineRepaid(uint256 indexed id, uint256 repayAmount);  /**  * @notice emitted when the credit line is completely repaid  * @param id id of the credit line  * @param repayAmount amount repaid  */ event CompleteCreditLineRepaid(uint256 indexed id, uint256 repayAmount);  /**  * @notice emitted when the credit line is closed by one of the parties of credit line  * @param id id of the credit line  */ event CreditLineClosed(uint256 indexed id);  /**  * @notice emitted when default strategy for the credit line is updated  * @param defaultStrategy address of the strategy contract that is used as default by credit lines  */ event DefaultStrategyUpdated(address indexed defaultStrategy);  /**  * @notice emitted when the price oracle is updated  * @param priceOracle address of the updated price oracle  */ event PriceOracleUpdated(address indexed priceOracle);  /**  * @notice emitted when the savings account address is updated  * @param savingsAccount address of the updated savingsAccount  */ event SavingsAccountUpdated(address indexed savingsAccount);  /**  * @notice emitted when strategy registry address is updated  * @param strategyRegistry address of the updated strategy registry  */ event StrategyRegistryUpdated(address indexed strategyRegistry);  /**  * @notice emitted when fee that protocol charges for credit line is updated  * @param updatedProtocolFee updated value of protocolFeeFraction  */ event ProtocolFeeFractionUpdated(uint256 updatedProtocolFee);  /**  * @notice emitted when address which receives fee that protocol changes for pools is updated  * @param updatedProtocolFeeCollector updated value of protocolFeeCollector  */ event ProtocolFeeCollectorUpdated(address indexed updatedProtocolFeeCollector);  /**  * @notice emitted when liquidatorRewardFraction is updated  * @param liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator  */ event LiquidationRewardFractionUpdated(uint256 liquidatorRewardFraction);  /**  * @notice used to initialize the contract  * @dev can only be called once during the life cycle of the contract  * @param _defaultStrategy default strategy used in credit lines  * @param _priceOracle address of the priceOracle  * @param _savingsAccount address of  the savings account contract  * @param _strategyRegistry address of the strategy registry contract  * @param _owner address of owner who can change global variables  * @param _protocolFeeFraction fraction of the fee charged by protocol  * @param _protocolFeeCollector address to which protocol fee is charged to  * @param _liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator  */ function initialize(     address _defaultStrategy,     address _priceOracle,     address _savingsAccount,     address _strategyRegistry,     address _owner,     uint256 _protocolFeeFraction,     address _protocolFeeCollector,     uint256 _liquidatorRewardFraction ) external initializer {     OwnableUpgradeable.__Ownable_init();     OwnableUpgradeable.transferOwnership(_owner);      _updateDefaultStrategy(_defaultStrategy);     _updatePriceOracle(_priceOracle);     _updateSavingsAccount(_savingsAccount);     _updateStrategyRegistry(_strategyRegistry);     _updateProtocolFeeFraction(_protocolFeeFraction);     _updateProtocolFeeCollector(_protocolFeeCollector);     _updateLiquidatorRewardFraction(_liquidatorRewardFraction); }  /**  * @notice used to update the default strategy  * @dev can only be updated by owner  * @param _defaultStrategy address of the updated default strategy  */ function updateDefaultStrategy(address _defaultStrategy) external onlyOwner {     _updateDefaultStrategy(_defaultStrategy); }  function _updateDefaultStrategy(address _defaultStrategy) internal {     defaultStrategy = _defaultStrategy;     emit DefaultStrategyUpdated(_defaultStrategy); }  /**  * @notice used to update the price oracle  * @dev can only be updated by owner  * @param _priceOracle address of the updated price oracle  */ function updatePriceOracle(address _priceOracle) external onlyOwner {     _updatePriceOracle(_priceOracle); }  function _updatePriceOracle(address _priceOracle) internal {     priceOracle = _priceOracle;     emit PriceOracleUpdated(_priceOracle); }  /**  * @notice used to update the savings account address  * @dev can only be updated by owner  * @param _savingsAccount address of the updated savings account  */ function updateSavingsAccount(address _savingsAccount) external onlyOwner {     _updateSavingsAccount(_savingsAccount); }  function _updateSavingsAccount(address _savingsAccount) internal {     savingsAccount = _savingsAccount;     emit SavingsAccountUpdated(_savingsAccount); }  /**  * @notice used to update the protocol fee fraction  * @dev can only be updated by owner  * @param _protocolFee fraction of the borrower amount collected as protocol fee  */ function updateProtocolFeeFraction(uint256 _protocolFee) external onlyOwner {     _updateProtocolFeeFraction(_protocolFee); }  function _updateProtocolFeeFraction(uint256 _protocolFee) internal {     protocolFeeFraction = _protocolFee;     emit ProtocolFeeFractionUpdated(_protocolFee); }  /**  * @notice used to update the protocol fee collector  * @dev can only be updated by owner  * @param _protocolFeeCollector address in which protocol fee is collected  */ function updateProtocolFeeCollector(address _protocolFeeCollector) external onlyOwner {     _updateProtocolFeeCollector(_protocolFeeCollector); }  function _updateProtocolFeeCollector(address _protocolFeeCollector) internal {     require(_protocolFeeCollector != address(0), 'cant be 0 address');     protocolFeeCollector = _protocolFeeCollector;     emit ProtocolFeeCollectorUpdated(_protocolFeeCollector); }  /**  * @notice used to update the strategy registry address  * @dev can only be updated by owner  * @param _strategyRegistry address of the updated strategy registry  */ function updateStrategyRegistry(address _strategyRegistry) external onlyOwner {     _updateStrategyRegistry(_strategyRegistry); }  function _updateStrategyRegistry(address _strategyRegistry) internal {     require(_strategyRegistry != address(0), 'CL::I zero address');     strategyRegistry = _strategyRegistry;     emit StrategyRegistryUpdated(_strategyRegistry); }  /**  * @notice used to update the liquidatorRewardFraction  * @dev can only be updated by owner  * @param _rewardFraction fraction of liquidated amount given to liquidator as reward  */ function updateLiquidatorRewardFraction(uint256 _rewardFraction) external onlyOwner {     _updateLiquidatorRewardFraction(_rewardFraction); }  function _updateLiquidatorRewardFraction(uint256 _rewardFraction) internal {     require(_rewardFraction &lt;= 10**30, 'Fraction has to be less than 1');     liquidatorRewardFraction = _rewardFraction;     emit LiquidationRewardFractionUpdated(_rewardFraction); }  /**  * @dev Used to Calculate Interest Per second on given principal and Interest rate  * @param _principal principal Amount for which interest has to be calculated.  * @param _borrowRate It is the Interest Rate at which Credit Line is approved  * @return interest per second for the given parameters  */ function calculateInterest(     uint256 _principal,     uint256 _borrowRate,     uint256 _timeElapsed ) public pure returns (uint256) {     uint256 _interest = _principal.mul(_borrowRate).mul(_timeElapsed).div(10**30).div(YEAR_IN_SECONDS);      return _interest; }  /**  * @dev Used to calculate interest accrued since last repayment  * @param _id identifier for the credit line  * @return interest accrued over current borrowed amount since last repayment  */  function calculateInterestAccrued(uint256 _id) public view returns (uint256) {     uint256 _lastPrincipalUpdateTime = creditLineVariables[_id].lastPrincipalUpdateTime;     if (_lastPrincipalUpdateTime == 0) return 0;     uint256 _timeElapsed = (block.timestamp).sub(_lastPrincipalUpdateTime);     uint256 _interestAccrued = calculateInterest(creditLineVariables[_id].principal, creditLineConstants[_id].borrowRate, _timeElapsed);     return _interestAccrued; }  /**  * @dev Used to calculate current debt of borrower against a credit line.  * @param _id identifier for the credit line  * @return current debt of borrower  */ function calculateCurrentDebt(uint256 _id) public view returns (uint256) {     uint256 _interestAccrued = calculateInterestAccrued(_id);     uint256 _currentDebt = (creditLineVariables[_id].principal)         .add(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate)         .add(_interestAccrued)         .sub(creditLineVariables[_id].totalInterestRepaid);     return _currentDebt; }  /**  * @notice used to calculate amount that can be borrowed by the borrower  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view.         borrowableAmount changes per block as interest changes per block.  * @param _id identifier for the credit line  * @return amount that can be borrowed from the credit line  */ function calculateBorrowableAmount(uint256 _id) public returns (uint256) {     CreditLineStatus _status = creditLineVariables[_id].status;     require(         _status == CreditLineStatus.ACTIVE || _status == CreditLineStatus.REQUESTED,         'CreditLine: Cannot only if credit line ACTIVE or REQUESTED'     );     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(         creditLineConstants[_id].collateralAsset,         creditLineConstants[_id].borrowAsset     );      uint256 _totalCollateralToken = calculateTotalCollateralTokens(_id);      uint256 _currentDebt = calculateCurrentDebt(_id);      uint256 _maxPossible = _totalCollateralToken.mul(_ratioOfPrices).div(creditLineConstants[_id].idealCollateralRatio).mul(10**30).div(         10**_decimals     );      uint256 _borrowLimit = creditLineConstants[_id].borrowLimit;      if (_maxPossible &gt; _borrowLimit) {         _maxPossible = _borrowLimit;     }     if (_maxPossible &gt; _currentDebt) {         return _maxPossible.sub(_currentDebt);     }     return 0; }  function updateinterestAccruedTillLastPrincipalUpdate(uint256 _id) internal {     require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');      uint256 _interestAccrued = calculateInterestAccrued(_id);     uint256 _newInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(_interestAccrued);     creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _newInterestAccrued; }  function _depositCollateralFromSavingsAccount(     uint256 _id,     uint256 _amount,     address _sender ) internal {     address _collateralAsset = creditLineConstants[_id].collateralAsset;     address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();     ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);     uint256 _activeAmount;      for (uint256 _index = 0; _index &lt; _strategyList.length; _index++) {         address _strategy = _strategyList[_index];         uint256 _liquidityShares = _savingsAccount.balanceInShares(_sender, _collateralAsset, _strategy);         if (_liquidityShares == 0 || _strategyList[_index] == address(0)) {             continue;         }         uint256 _tokenInStrategy = _liquidityShares;         _tokenInStrategy = IYield(_strategy).getTokensForShares(_liquidityShares, _collateralAsset);          uint256 _tokensToTransfer = _tokenInStrategy;         if (_activeAmount.add(_tokenInStrategy) &gt;= _amount) {             _tokensToTransfer = (_amount.sub(_activeAmount));         }         _activeAmount = _activeAmount.add(_tokensToTransfer);         _savingsAccount.transferFrom(_tokensToTransfer, _collateralAsset, _strategy, _sender, address(this));          collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(             _liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy)         );          if (_amount == _activeAmount) {             return;         }     }     revert('CreditLine::_depositCollateralFromSavingsAccount - Insufficient balance'); }  /**  * @notice used to request a credit line either by borrower or lender  * @param _requestTo Address to which creditLine is requested,                      if borrower creates request then lender address and                      if lender creates then borrower address  * @param _borrowLimit maximum borrow amount in a credit line  * @param _borrowRate Interest Rate at which credit Line is requested  * @param _autoLiquidation if true, anyone can liquidate loan, otherwise only lender  * @param _collateralRatio ratio of the collateral to the debt below which credit line can be liquidated  * @param _borrowAsset address of the token to be borrowed  * @param _collateralAsset address of the token provided as collateral  * @param _requestAsLender if true, lender is placing request, otherwise borrower  * @return identifier for the credit line  */  function request(     address _requestTo,     uint256 _borrowLimit,     uint256 _borrowRate,     bool _autoLiquidation,     uint256 _collateralRatio,     address _borrowAsset,     address _collateralAsset,     bool _requestAsLender ) external returns (uint256) {     require(_borrowAsset != _collateralAsset, 'R: cant borrow lent token');     require(IPriceOracle(priceOracle).doesFeedExist(_borrowAsset, _collateralAsset), 'R: No price feed');      address _lender = _requestTo;     address _borrower = msg.sender;     if (_requestAsLender) {         _lender = msg.sender;         _borrower = _requestTo;     }      uint256 _id = _createRequest(         _lender,         _borrower,         _borrowLimit,         _borrowRate,         _autoLiquidation,         _collateralRatio,         _borrowAsset,         _collateralAsset,         _requestAsLender     );      emit CreditLineRequested(_id, _lender, _borrower);     return _id; }  function _createRequest(     address _lender,     address _borrower,     uint256 _borrowLimit,     uint256 _borrowRate,     bool _autoLiquidation,     uint256 _collateralRatio,     address _borrowAsset,     address _collateralAsset,     bool _requestByLender ) internal returns (uint256) {     require(_lender != _borrower, 'Lender and Borrower cannot be same addresses');     uint256 _id = creditLineCounter + 1;     creditLineCounter = _id;     creditLineVariables[_id].status = CreditLineStatus.REQUESTED;     creditLineConstants[_id].borrower = _borrower;     creditLineConstants[_id].lender = _lender;     creditLineConstants[_id].borrowLimit = _borrowLimit;     creditLineConstants[_id].autoLiquidation = _autoLiquidation;     creditLineConstants[_id].idealCollateralRatio = _collateralRatio;     creditLineConstants[_id].borrowRate = _borrowRate;     creditLineConstants[_id].borrowAsset = _borrowAsset;     creditLineConstants[_id].collateralAsset = _collateralAsset;     creditLineConstants[_id].requestByLender = _requestByLender;     return _id; }  /**  * @notice used to accept a credit line  * @dev if borrower places request, lender can accept and vice versa  * @param _id identifier for the credit line  */ function accept(uint256 _id) external {     require(         creditLineVariables[_id].status == CreditLineStatus.REQUESTED,         'CreditLine::acceptCreditLineLender - CreditLine is already accepted'     );     bool _requestByLender = creditLineConstants[_id].requestByLender;     require(         (msg.sender == creditLineConstants[_id].borrower &amp;&amp; _requestByLender) ||             (msg.sender == creditLineConstants[_id].lender &amp;&amp; !_requestByLender),         "Only Borrower or Lender who hasn't requested can accept"     );     creditLineVariables[_id].status = CreditLineStatus.ACTIVE;     emit CreditLineAccepted(_id); }  /**  * @notice used to deposit collateral into the credit line  * @dev collateral tokens have to be approved in savingsAccount or token contract(unless ether).         If transferred from savings account, the tokens are transferred from strategies in the          order prespecified in strategy registry  * @param _id identifier for the credit line  * @param _amount amount of collateral being deposited  * @param _strategy strategy to which collateral is to be deposited in case transfer is not from savings account  * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount                              otherwise direct from collateral token contract  */ function depositCollateral(     uint256 _id,     uint256 _amount,     address _strategy,     bool _fromSavingsAccount ) external payable nonReentrant ifCreditLineExists(_id) {     require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine not active');     _depositCollateral(_id, _amount, _strategy, _fromSavingsAccount);     emit CollateralDeposited(_id, _amount, _strategy); }  function _depositCollateral(     uint256 _id,     uint256 _amount,     address _strategy,     bool _fromSavingsAccount ) internal {     require(creditLineConstants[_id].lender != msg.sender, 'lender cant deposit collateral');     if (_fromSavingsAccount) {         _depositCollateralFromSavingsAccount(_id, _amount, msg.sender);     } else {         address _collateralAsset = creditLineConstants[_id].collateralAsset;         ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);         if (_collateralAsset == address(0)) {             require(msg.value == _amount, "CreditLine::_depositCollateral - value to transfer doesn't match argument");         } else {             IERC20(_collateralAsset).safeTransferFrom(msg.sender, address(this), _amount);             IERC20(_collateralAsset).approve(_strategy, _amount);         }         uint256 _sharesReceived = _savingsAccount.deposit{value: msg.value}(_amount, _collateralAsset, _strategy, address(this));         collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(_sharesReceived);     } }  function _withdrawBorrowAmount(     address _asset,     uint256 _amountInTokens,     address _lender ) internal {     address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();     ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);     uint256 _activeAmount;     for (uint256 _index = 0; _index &lt; _strategyList.length; _index++) {         if (_strategyList[_index] == address(0)) {             continue;         }         uint256 _liquidityShares = _savingsAccount.balanceInShares(_lender, _asset, _strategyList[_index]);         if (_liquidityShares != 0) {             uint256 tokenInStrategy = _liquidityShares;             tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);             uint256 _tokensToTransfer = tokenInStrategy;             if (_activeAmount.add(tokenInStrategy) &gt;= _amountInTokens) {                 _tokensToTransfer = (_amountInTokens.sub(_activeAmount));             }             _activeAmount = _activeAmount.add(_tokensToTransfer);             _savingsAccount.withdrawFrom(_tokensToTransfer, _asset, _strategyList[_index], _lender, address(this), false);             if (_activeAmount == _amountInTokens) {                 return;             }         }     }     require(_activeAmount == _amountInTokens, 'insufficient balance'); }  /**  * @notice used to borrow tokens from credit line by borrower  * @dev only borrower can call this function. Amount that can actually be borrowed is          min(amount based on borrowLimit, allowance to creditLine contract, balance of lender)  * @param _id identifier for the credit line  * @param _amount amount of tokens to borrow  */ function borrow(uint256 _id, uint256 _amount) external payable nonReentrant onlyCreditLineBorrower(_id) {     require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');     uint256 _borrowableAmount = calculateBorrowableAmount(_id);     require(_amount &lt;= _borrowableAmount, "CreditLine::borrow - The current collateral ratio doesn't allow to withdraw the amount");     address _borrowAsset = creditLineConstants[_id].borrowAsset;     address _lender = creditLineConstants[_id].lender;      updateinterestAccruedTillLastPrincipalUpdate(_id);     creditLineVariables[_id].principal = creditLineVariables[_id].principal.add(_amount);     creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;      uint256 _tokenDiffBalance;     if (_borrowAsset != address(0)) {         uint256 _balanceBefore = IERC20(_borrowAsset).balanceOf(address(this));         _withdrawBorrowAmount(_borrowAsset, _amount, _lender);         uint256 _balanceAfter = IERC20(_borrowAsset).balanceOf(address(this));         _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);     } else {         uint256 _balanceBefore = address(this).balance;         _withdrawBorrowAmount(_borrowAsset, _amount, _lender);         uint256 _balanceAfter = address(this).balance;         _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);     }     uint256 _protocolFee = _tokenDiffBalance.mul(protocolFeeFraction).div(10**30);     _tokenDiffBalance = _tokenDiffBalance.sub(_protocolFee);      if (_borrowAsset == address(0)) {         (bool feeSuccess, ) = protocolFeeCollector.call{value: _protocolFee}('');         require(feeSuccess, 'Transfer fail');         (bool success, ) = msg.sender.call{value: _tokenDiffBalance}('');         require(success, 'Transfer fail');     } else {         IERC20(_borrowAsset).safeTransfer(protocolFeeCollector, _protocolFee);         IERC20(_borrowAsset).safeTransfer(msg.sender, _tokenDiffBalance);     }     emit BorrowedFromCreditLine(_id, _tokenDiffBalance); }  function _repayFromSavingsAccount(     uint256 _amount,     address _asset,     address _lender ) internal {     address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();     ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);     uint256 _activeAmount;      for (uint256 _index = 0; _index &lt; _strategyList.length; _index++) {         if (_strategyList[_index] == address(0)) {             continue;         }         uint256 _liquidityShares = _savingsAccount.balanceInShares(msg.sender, _asset, _strategyList[_index]);         if (_liquidityShares == 0) {             continue;         }         uint256 _tokenInStrategy = _liquidityShares;         _tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);          uint256 _tokensToTransfer = _tokenInStrategy;         if (_activeAmount.add(_tokenInStrategy) &gt;= _amount) {             _tokensToTransfer = (_amount.sub(_activeAmount));         }         _activeAmount = _activeAmount.add(_tokensToTransfer);         _savingsAccount.transferFrom(_tokensToTransfer, _asset, _strategyList[_index], msg.sender, _lender);          if (_amount == _activeAmount) {             return;         }     }     revert('CreditLine::_repayFromSavingsAccount - Insufficient balance'); }  function _repay(     uint256 _id,     uint256 _amount,     bool _fromSavingsAccount,     uint256 _principalPaid ) internal {     ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);     address _defaultStrategy = defaultStrategy;     address _borrowAsset = creditLineConstants[_id].borrowAsset;     address _lender = creditLineConstants[_id].lender;     if (!_fromSavingsAccount) {         if (_borrowAsset == address(0)) {             require(msg.value == _amount, 'creditLine::repay - Ether sent not equal to repay amount');             _savingsAccount.deposit{value: _amount}(_amount, _borrowAsset, _defaultStrategy, _lender);         } else {             IERC20(_borrowAsset).safeTransferFrom(msg.sender, address(this), _amount);             IERC20(_borrowAsset).approve(_defaultStrategy, _amount);             _savingsAccount.deposit(_amount, _borrowAsset, _defaultStrategy, _lender);         }     } else {         _repayFromSavingsAccount(_amount, _borrowAsset, _lender);     }     if (_principalPaid != 0) {         _savingsAccount.increaseAllowanceToCreditLine(_principalPaid, _borrowAsset, _lender);     } }  /**  * @notice used to repay interest and principal to credit line. Interest has to be repaid before repaying principal  * @dev partial repayments possible  * @param _id identifier for the credit line  * @param _amount amount being repaid  * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount                              otherwise direct from collateral token contract  */ function repay(     uint256 _id,     uint256 _amount,     bool _fromSavingsAccount ) external payable nonReentrant {     require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');     require(creditLineConstants[_id].lender != msg.sender, 'Lender cant repay');      uint256 _interestSincePrincipalUpdate = calculateInterestAccrued(_id);     uint256 _totalInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(         _interestSincePrincipalUpdate     );     uint256 _interestToPay = _totalInterestAccrued.sub(creditLineVariables[_id].totalInterestRepaid);     uint256 _totalCurrentDebt = _interestToPay.add(creditLineVariables[_id].principal);     uint256 _principalPaid = 0;      if (_amount &gt;= _totalCurrentDebt) {         _amount = _totalCurrentDebt;         emit CompleteCreditLineRepaid(_id, _amount);     } else {         emit PartialCreditLineRepaid(_id, _amount);     }      if (_amount &gt; _interestToPay) {         creditLineVariables[_id].principal = _totalCurrentDebt.sub(_amount);         creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _totalInterestAccrued;         creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;         creditLineVariables[_id].totalInterestRepaid = _totalInterestAccrued;         _principalPaid = _amount.sub(_interestToPay);     } else {         creditLineVariables[_id].totalInterestRepaid = creditLineVariables[_id].totalInterestRepaid.add(_amount);     }      _repay(_id, _amount, _fromSavingsAccount, _principalPaid);      if (creditLineVariables[_id].principal == 0) {         _resetCreditLine(_id);     } }  function _resetCreditLine(uint256 _id) internal {     creditLineVariables[_id].lastPrincipalUpdateTime = 0;     creditLineVariables[_id].totalInterestRepaid = 0;     creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = 0;     emit CreditLineReset(_id); }  /**  * @dev used to close credit line by borrower or lender  * @param _id identifier for the credit line  */ function close(uint256 _id) external ifCreditLineExists(_id) {     require(         msg.sender == creditLineConstants[_id].borrower || msg.sender == creditLineConstants[_id].lender,         'CreditLine: Permission denied while closing Line of credit'     );     require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: Credit line should be active.');     require(creditLineVariables[_id].principal == 0, 'CreditLine: Cannot be closed since not repaid.');     require(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate == 0, 'CreditLine: Cannot be closed since not repaid.');     creditLineVariables[_id].status = CreditLineStatus.CLOSED;     emit CreditLineClosed(_id); }  /**  * @notice used to calculate the current collateral ratio  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view.         Interest is also considered while calculating debt  * @param _id identifier for the credit line  * @return collateral ratio multiplied by 10**30 to retain precision  */ function calculateCurrentCollateralRatio(uint256 _id) public ifCreditLineExists(_id) returns (uint256) {     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(         creditLineConstants[_id].collateralAsset,         creditLineConstants[_id].borrowAsset     );      uint256 currentDebt = calculateCurrentDebt(_id);     uint256 currentCollateralRatio = calculateTotalCollateralTokens(_id).mul(_ratioOfPrices).div(currentDebt).mul(10**30).div(         10**_decimals     );      return currentCollateralRatio; }  /**  * @notice used to calculate the total collateral tokens  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view  * @param _id identifier for the credit line  * @return _amount total collateral tokens deposited into the credit line  */ function calculateTotalCollateralTokens(uint256 _id) public returns (uint256 _amount) {     address _collateralAsset = creditLineConstants[_id].collateralAsset;     address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();     uint256 _liquidityShares;     for (uint256 index = 0; index &lt; _strategyList.length; index++) {         if (_strategyList[index] == address(0)) {             continue;         }         _liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];         uint256 _tokenInStrategy = _liquidityShares;         _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(_liquidityShares, _collateralAsset);          _amount = _amount.add(_tokenInStrategy);     } }  /**  * @notice used to withdraw any excess collateral  * @dev collateral can't be withdraw if collateralRatio goes below the ideal value. Only borrower can withdraw  * @param _id identifier for the credit line  * @param _amount amount of collateral to withdraw  * @param _toSavingsAccount if true, tokens are transferred from savingsAccount                              otherwise direct from collateral token contract  */ function withdrawCollateral(     uint256 _id,     uint256 _amount,     bool _toSavingsAccount ) external nonReentrant onlyCreditLineBorrower(_id) {     uint256 _withdrawableCollateral = withdrawableCollateral(_id);     require(_amount &lt;= _withdrawableCollateral, 'Collateral ratio cant go below ideal');     address _collateralAsset = creditLineConstants[_id].collateralAsset;     _transferCollateral(_id, _collateralAsset, _amount, _toSavingsAccount);     emit CollateralWithdrawn(_id, _amount); }  /**  * @notice used to calculate the collateral that can be withdrawn  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view  * @param _id identifier for the credit line  * @return total collateral withdrawable by borrower  */ function withdrawableCollateral(uint256 _id) public returns (uint256) {     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(         creditLineConstants[_id].collateralAsset,         creditLineConstants[_id].borrowAsset     );      uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);     uint256 _currentDebt = calculateCurrentDebt(_id);      uint256 _collateralNeeded = _currentDebt         .mul(creditLineConstants[_id].idealCollateralRatio)         .div(_ratioOfPrices)         .mul(10**_decimals)         .div(10**30);      if (_collateralNeeded &gt;= _totalCollateralTokens) {         return 0;     }     return _totalCollateralTokens.sub(_collateralNeeded); }  function _transferCollateral(     uint256 _id,     address _asset,     uint256 _amountInTokens,     bool _toSavingsAccount ) internal {     address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();     uint256 _activeAmount;     for (uint256 index = 0; index &lt; _strategyList.length; index++) {         uint256 liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];         if (liquidityShares == 0 || _strategyList[index] == address(0)) {             continue;         }         uint256 _tokenInStrategy = liquidityShares;         _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(liquidityShares, _asset);         uint256 _tokensToTransfer = _tokenInStrategy;         if (_activeAmount.add(_tokenInStrategy) &gt; _amountInTokens) {             _tokensToTransfer = _amountInTokens.sub(_activeAmount);             liquidityShares = liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy);         }         _activeAmount = _activeAmount.add(_tokensToTransfer);         collateralShareInStrategy[_id][_strategyList[index]] = collateralShareInStrategy[_id][_strategyList[index]].sub(             liquidityShares         );         if (_toSavingsAccount) {             ISavingsAccount(savingsAccount).transfer(_tokensToTransfer, _asset, _strategyList[index], msg.sender);         } else {             ISavingsAccount(savingsAccount).withdraw(_tokensToTransfer, _asset, _strategyList[index], msg.sender, false);         }          if (_activeAmount == _amountInTokens) {             return;         }     }     revert('insufficient collateral'); }  /**  * @notice used to liquidate credit line in case collateral ratio goes below the threshold  * @dev if lender liquidates, then collateral is directly transferred.          If autoLiquidation is true, anyone can liquidate by providing enough borrow tokens  * @param _id identifier for the credit line  * @param _toSavingsAccount if true, tokens are transferred from savingsAccount                              otherwise direct from collateral token contract  */ function liquidate(uint256 _id, bool _toSavingsAccount) external payable nonReentrant {     require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: Credit line should be active.');     require(creditLineVariables[_id].principal != 0, 'CreditLine: cannot liquidate if principal is 0');      uint256 currentCollateralRatio = calculateCurrentCollateralRatio(_id);     require(         currentCollateralRatio &lt; creditLineConstants[_id].idealCollateralRatio,         'CreditLine: Collateral ratio is higher than ideal value'     );      address _collateralAsset = creditLineConstants[_id].collateralAsset;     address _lender = creditLineConstants[_id].lender;     uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);     address _borrowAsset = creditLineConstants[_id].borrowAsset;      creditLineVariables[_id].status = CreditLineStatus.LIQUIDATED;      if (creditLineConstants[_id].autoLiquidation &amp;&amp; _lender != msg.sender) {         uint256 _borrowTokens = _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens);         if (_borrowAsset == address(0)) {             uint256 _returnETH = msg.value.sub(_borrowTokens, 'Insufficient ETH to liquidate');             if (_returnETH != 0) {                 (bool success, ) = msg.sender.call{value: _returnETH}('');                 require(success, 'Transfer fail');             }         } else {             IERC20(_borrowAsset).safeTransferFrom(msg.sender, _lender, _borrowTokens);         }     }      _transferCollateral(_id, _collateralAsset, _totalCollateralTokens, _toSavingsAccount);      emit CreditLineLiquidated(_id, msg.sender); }  /**  * @notice used to calculate the borrow tokens necessary for liquidator to liquidate  * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view  * @param _id identifier for the credit line  * @return borrow tokens necessary for liquidator to liquidate  */ function borrowTokensToLiquidate(uint256 _id) external returns (uint256) {     address _collateralAsset = creditLineConstants[_id].collateralAsset;     uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);     address _borrowAsset = creditLineConstants[_id].borrowAsset;      return _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens); }  function _borrowTokensToLiquidate(     address _borrowAsset,     address _collateralAsset,     uint256 _totalCollateralTokens ) internal view returns (uint256) {     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(_borrowAsset, _collateralAsset);     uint256 _borrowTokens = (         _totalCollateralTokens.mul(uint256(10**30).sub(liquidatorRewardFraction)).div(10**30).mul(_ratioOfPrices).div(10**_decimals)     );      return _borrowTokens; }  receive() external payable {     require(msg.sender == savingsAccount, 'CreditLine::receive invalid transaction'); }  } |
| **with_task_specify** | False |
| **memory** | None |
| **model_type** | ModelType.GPT_3_5_TURBO |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-22-08 11:44:00 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Testing Engineer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer.
Your can simulate various attack scenarios, conduct security testing, and perform code audits to identify vulnerablities and weaknesses in the smart contracts. This inculde analyzing potential exploit paths, assessing the resilience of the contract to common attack vectorsm and suggesting remediation measures
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/utils/ReentrancyGuard.sol';
import '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';
import '../interfaces/IPriceOracle.sol';
import '../interfaces/IYield.sol';
import '../interfaces/ISavingsAccount.sol';
import '../SavingsAccount/SavingsAccountUtil.sol';
import '../interfaces/IStrategyRegistry.sol';

/**
 * @title Credit Line contract with Methods related to credit Line
 * @notice Implements the functions related to Credit Line
 * @author Sublime
 **/

contract CreditLine is ReentrancyGuard, OwnableUpgradeable {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    enum CreditLineStatus {
        NOT_CREATED,
        REQUESTED,
        ACTIVE,
        CLOSED,
        CANCELLED,
        LIQUIDATED
    }

    /**
     * @notice counter that tracks the number of credit lines created
     * @dev used to create unique identifier for credit lines
     **/
    uint256 public creditLineCounter;

    uint256 constant YEAR_IN_SECONDS = 365 days;

    struct CreditLineVariables {
        CreditLineStatus status;
        uint256 principal;
        uint256 totalInterestRepaid;
        uint256 lastPrincipalUpdateTime;
        uint256 interestAccruedTillLastPrincipalUpdate;
    }

    struct CreditLineConstants {
        address lender;
        address borrower;
        uint256 borrowLimit;
        uint256 idealCollateralRatio;
        uint256 borrowRate;
        address borrowAsset;
        address collateralAsset;
        bool autoLiquidation;
        bool requestByLender;
    }
    /**
     * @notice stores the collateral shares in a credit line per strategy
     * @dev creditLineId => Strategy => collateralShares
     **/
    mapping(uint256 => mapping(address => uint256)) public collateralShareInStrategy;

    /**
     * @notice stores the variables to maintain a credit line
     **/
    mapping(uint256 => CreditLineVariables) public creditLineVariables;

    /**
     * @notice stores the constants related to a credit line
     **/
    mapping(uint256 => CreditLineConstants) public creditLineConstants;

    /**
     * @notice stores the address of savings account contract
     **/
    address public savingsAccount;

    /**
     * @notice stores the address of price oracle contract
     **/
    address public priceOracle;

    /**
     * @notice stores the address of strategy registry contract
     **/
    address public strategyRegistry;

    /**
     * @notice stores the address of default strategy
     **/
    address public defaultStrategy;

    /**
     * @notice stores the fraction of borrowed amount charged as fee by protocol
     * @dev it is multiplied by 10**30
     **/
    uint256 public protocolFeeFraction;

    /**
     * @notice address where protocol fee is collected
     **/
    address public protocolFeeCollector;

    /**
     * @notice stores the fraction of amount liquidated given as reward to liquidator
     * @dev it is multiplied by 10**30
     **/
    uint256 public liquidatorRewardFraction;
    /**
     * @dev checks if Credit Line exists
     * @param _id identifier for the credit line
     **/
    modifier ifCreditLineExists(uint256 _id) {
        require(creditLineVariables[_id].status != CreditLineStatus.NOT_CREATED, 'Credit line does not exist');
        _;
    }

    /**
     * @dev checks if called by credit Line Borrower
     * @param _id creditLine identifier
     **/
    modifier onlyCreditLineBorrower(uint256 _id) {
        require(creditLineConstants[_id].borrower == msg.sender, 'Only credit line Borrower can access');
        _;
    }

    /**
     * @dev checks if called by credit Line Lender
     * @param _id creditLine identifier
     **/
    modifier onlyCreditLineLender(uint256 _id) {
        require(creditLineConstants[_id].lender == msg.sender, 'Only credit line Lender can access');
        _;
    }

    /**
     * @notice emitted when a collateral is deposited into credit line
     * @param id id of the credit line
     * @param amount amount of collateral deposited
     * @param strategy address of the strategy into which collateral is deposited
     */
    event CollateralDeposited(uint256 indexed id, uint256 amount, address indexed strategy);

    /**
     * @notice emitted when collateral is withdrawn from credit line
     * @param id id of the credit line
     * @param amount amount of collateral withdrawn
     */
    event CollateralWithdrawn(uint256 indexed id, uint256 amount);

    /**
     * @notice emitted when a request for new credit line is placed
     * @param id id of the credit line for which request was made
     * @param lender address of the lender for credit line
     * @param borrower address of the borrower for credit line
     */
    event CreditLineRequested(uint256 indexed id, address indexed lender, address indexed borrower);

    /**
     * @notice emitted when a credit line is liquidated
     * @param id id of the credit line which is liquidated
     * @param liquidator address of the liquidator
     */
    event CreditLineLiquidated(uint256 indexed id, address indexed liquidator);

    /**
     * @notice emitted when tokens are borrowed from credit line
     * @param id id of the credit line from which tokens are borrowed
     * @param borrowAmount amount of tokens borrowed
     */
    event BorrowedFromCreditLine(uint256 indexed id, uint256 borrowAmount);

    /**
     * @notice emitted when credit line is accepted
     * @param id id of the credit line that was accepted
     */
    event CreditLineAccepted(uint256 indexed id);

    /**
     * @notice emitted when credit line is completely repaid and reset
     * @param id id of the credit line that is reset
     */
    event CreditLineReset(uint256 indexed id);

    /**
     * @notice emitted when the credit line is partially repaid
     * @param id id of the credit line
     * @param repayAmount amount repaid
     */
    event PartialCreditLineRepaid(uint256 indexed id, uint256 repayAmount);

    /**
     * @notice emitted when the credit line is completely repaid
     * @param id id of the credit line
     * @param repayAmount amount repaid
     */
    event CompleteCreditLineRepaid(uint256 indexed id, uint256 repayAmount);

    /**
     * @notice emitted when the credit line is closed by one of the parties of credit line
     * @param id id of the credit line
     */
    event CreditLineClosed(uint256 indexed id);

    /**
     * @notice emitted when default strategy for the credit line is updated
     * @param defaultStrategy address of the strategy contract that is used as default by credit lines
     */
    event DefaultStrategyUpdated(address indexed defaultStrategy);

    /**
     * @notice emitted when the price oracle is updated
     * @param priceOracle address of the updated price oracle
     */
    event PriceOracleUpdated(address indexed priceOracle);

    /**
     * @notice emitted when the savings account address is updated
     * @param savingsAccount address of the updated savingsAccount
     */
    event SavingsAccountUpdated(address indexed savingsAccount);

    /**
     * @notice emitted when strategy registry address is updated
     * @param strategyRegistry address of the updated strategy registry
     */
    event StrategyRegistryUpdated(address indexed strategyRegistry);

    /**
     * @notice emitted when fee that protocol charges for credit line is updated
     * @param updatedProtocolFee updated value of protocolFeeFraction
     */
    event ProtocolFeeFractionUpdated(uint256 updatedProtocolFee);

    /**
     * @notice emitted when address which receives fee that protocol changes for pools is updated
     * @param updatedProtocolFeeCollector updated value of protocolFeeCollector
     */
    event ProtocolFeeCollectorUpdated(address indexed updatedProtocolFeeCollector);

    /**
     * @notice emitted when liquidatorRewardFraction is updated
     * @param liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator
     */
    event LiquidationRewardFractionUpdated(uint256 liquidatorRewardFraction);

    /**
     * @notice used to initialize the contract
     * @dev can only be called once during the life cycle of the contract
     * @param _defaultStrategy default strategy used in credit lines
     * @param _priceOracle address of the priceOracle
     * @param _savingsAccount address of  the savings account contract
     * @param _strategyRegistry address of the strategy registry contract
     * @param _owner address of owner who can change global variables
     * @param _protocolFeeFraction fraction of the fee charged by protocol
     * @param _protocolFeeCollector address to which protocol fee is charged to
     * @param _liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator
     */
    function initialize(
        address _defaultStrategy,
        address _priceOracle,
        address _savingsAccount,
        address _strategyRegistry,
        address _owner,
        uint256 _protocolFeeFraction,
        address _protocolFeeCollector,
        uint256 _liquidatorRewardFraction
    ) external initializer {
        OwnableUpgradeable.__Ownable_init();
        OwnableUpgradeable.transferOwnership(_owner);

        _updateDefaultStrategy(_defaultStrategy);
        _updatePriceOracle(_priceOracle);
        _updateSavingsAccount(_savingsAccount);
        _updateStrategyRegistry(_strategyRegistry);
        _updateProtocolFeeFraction(_protocolFeeFraction);
        _updateProtocolFeeCollector(_protocolFeeCollector);
        _updateLiquidatorRewardFraction(_liquidatorRewardFraction);
    }

    /**
     * @notice used to update the default strategy
     * @dev can only be updated by owner
     * @param _defaultStrategy address of the updated default strategy
     */
    function updateDefaultStrategy(address _defaultStrategy) external onlyOwner {
        _updateDefaultStrategy(_defaultStrategy);
    }

    function _updateDefaultStrategy(address _defaultStrategy) internal {
        defaultStrategy = _defaultStrategy;
        emit DefaultStrategyUpdated(_defaultStrategy);
    }

    /**
     * @notice used to update the price oracle
     * @dev can only be updated by owner
     * @param _priceOracle address of the updated price oracle
     */
    function updatePriceOracle(address _priceOracle) external onlyOwner {
        _updatePriceOracle(_priceOracle);
    }

    function _updatePriceOracle(address _priceOracle) internal {
        priceOracle = _priceOracle;
        emit PriceOracleUpdated(_priceOracle);
    }

    /**
     * @notice used to update the savings account address
     * @dev can only be updated by owner
     * @param _savingsAccount address of the updated savings account
     */
    function updateSavingsAccount(address _savingsAccount) external onlyOwner {
        _updateSavingsAccount(_savingsAccount);
    }

    function _updateSavingsAccount(address _savingsAccount) internal {
        savingsAccount = _savingsAccount;
        emit SavingsAccountUpdated(_savingsAccount);
    }

    /**
     * @notice used to update the protocol fee fraction
     * @dev can only be updated by owner
     * @param _protocolFee fraction of the borrower amount collected as protocol fee
     */
    function updateProtocolFeeFraction(uint256 _protocolFee) external onlyOwner {
        _updateProtocolFeeFraction(_protocolFee);
    }

    function _updateProtocolFeeFraction(uint256 _protocolFee) internal {
        protocolFeeFraction = _protocolFee;
        emit ProtocolFeeFractionUpdated(_protocolFee);
    }

    /**
     * @notice used to update the protocol fee collector
     * @dev can only be updated by owner
     * @param _protocolFeeCollector address in which protocol fee is collected
     */
    function updateProtocolFeeCollector(address _protocolFeeCollector) external onlyOwner {
        _updateProtocolFeeCollector(_protocolFeeCollector);
    }

    function _updateProtocolFeeCollector(address _protocolFeeCollector) internal {
        require(_protocolFeeCollector != address(0), 'cant be 0 address');
        protocolFeeCollector = _protocolFeeCollector;
        emit ProtocolFeeCollectorUpdated(_protocolFeeCollector);
    }

    /**
     * @notice used to update the strategy registry address
     * @dev can only be updated by owner
     * @param _strategyRegistry address of the updated strategy registry
     */
    function updateStrategyRegistry(address _strategyRegistry) external onlyOwner {
        _updateStrategyRegistry(_strategyRegistry);
    }

    function _updateStrategyRegistry(address _strategyRegistry) internal {
        require(_strategyRegistry != address(0), 'CL::I zero address');
        strategyRegistry = _strategyRegistry;
        emit StrategyRegistryUpdated(_strategyRegistry);
    }

    /**
     * @notice used to update the liquidatorRewardFraction
     * @dev can only be updated by owner
     * @param _rewardFraction fraction of liquidated amount given to liquidator as reward
     */
    function updateLiquidatorRewardFraction(uint256 _rewardFraction) external onlyOwner {
        _updateLiquidatorRewardFraction(_rewardFraction);
    }

    function _updateLiquidatorRewardFraction(uint256 _rewardFraction) internal {
        require(_rewardFraction <= 10**30, 'Fraction has to be less than 1');
        liquidatorRewardFraction = _rewardFraction;
        emit LiquidationRewardFractionUpdated(_rewardFraction);
    }

    /**
     * @dev Used to Calculate Interest Per second on given principal and Interest rate
     * @param _principal principal Amount for which interest has to be calculated.
     * @param _borrowRate It is the Interest Rate at which Credit Line is approved
     * @return interest per second for the given parameters
     */
    function calculateInterest(
        uint256 _principal,
        uint256 _borrowRate,
        uint256 _timeElapsed
    ) public pure returns (uint256) {
        uint256 _interest = _principal.mul(_borrowRate).mul(_timeElapsed).div(10**30).div(YEAR_IN_SECONDS);

        return _interest;
    }

    /**
     * @dev Used to calculate interest accrued since last repayment
     * @param _id identifier for the credit line
     * @return interest accrued over current borrowed amount since last repayment
     */

    function calculateInterestAccrued(uint256 _id) public view returns (uint256) {
        uint256 _lastPrincipalUpdateTime = creditLineVariables[_id].lastPrincipalUpdateTime;
        if (_lastPrincipalUpdateTime == 0) return 0;
        uint256 _timeElapsed = (block.timestamp).sub(_lastPrincipalUpdateTime);
        uint256 _interestAccrued = calculateInterest(creditLineVariables[_id].principal, creditLineConstants[_id].borrowRate, _timeElapsed);
        return _interestAccrued;
    }

    /**
     * @dev Used to calculate current debt of borrower against a credit line.
     * @param _id identifier for the credit line
     * @return current debt of borrower
     */
    function calculateCurrentDebt(uint256 _id) public view returns (uint256) {
        uint256 _interestAccrued = calculateInterestAccrued(_id);
        uint256 _currentDebt = (creditLineVariables[_id].principal)
            .add(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate)
            .add(_interestAccrued)
            .sub(creditLineVariables[_id].totalInterestRepaid);
        return _currentDebt;
    }

    /**
     * @notice used to calculate amount that can be borrowed by the borrower
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view.
            borrowableAmount changes per block as interest changes per block.
     * @param _id identifier for the credit line
     * @return amount that can be borrowed from the credit line
     */
    function calculateBorrowableAmount(uint256 _id) public returns (uint256) {
        CreditLineStatus _status = creditLineVariables[_id].status;
        require(
            _status == CreditLineStatus.ACTIVE || _status == CreditLineStatus.REQUESTED,
            'CreditLine: Cannot only if credit line ACTIVE or REQUESTED'
        );
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(
            creditLineConstants[_id].collateralAsset,
            creditLineConstants[_id].borrowAsset
        );

        uint256 _totalCollateralToken = calculateTotalCollateralTokens(_id);

        uint256 _currentDebt = calculateCurrentDebt(_id);

        uint256 _maxPossible = _totalCollateralToken.mul(_ratioOfPrices).div(creditLineConstants[_id].idealCollateralRatio).mul(10**30).div(
            10**_decimals
        );

        uint256 _borrowLimit = creditLineConstants[_id].borrowLimit;

        if (_maxPossible > _borrowLimit) {
            _maxPossible = _borrowLimit;
        }
        if (_maxPossible > _currentDebt) {
            return _maxPossible.sub(_currentDebt);
        }
        return 0;
    }

    function updateinterestAccruedTillLastPrincipalUpdate(uint256 _id) internal {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');

        uint256 _interestAccrued = calculateInterestAccrued(_id);
        uint256 _newInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(_interestAccrued);
        creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _newInterestAccrued;
    }

    function _depositCollateralFromSavingsAccount(
        uint256 _id,
        uint256 _amount,
        address _sender
    ) internal {
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        uint256 _activeAmount;

        for (uint256 _index = 0; _index < _strategyList.length; _index++) {
            address _strategy = _strategyList[_index];
            uint256 _liquidityShares = _savingsAccount.balanceInShares(_sender, _collateralAsset, _strategy);
            if (_liquidityShares == 0 || _strategyList[_index] == address(0)) {
                continue;
            }
            uint256 _tokenInStrategy = _liquidityShares;
            _tokenInStrategy = IYield(_strategy).getTokensForShares(_liquidityShares, _collateralAsset);

            uint256 _tokensToTransfer = _tokenInStrategy;
            if (_activeAmount.add(_tokenInStrategy) >= _amount) {
                _tokensToTransfer = (_amount.sub(_activeAmount));
            }
            _activeAmount = _activeAmount.add(_tokensToTransfer);
            _savingsAccount.transferFrom(_tokensToTransfer, _collateralAsset, _strategy, _sender, address(this));

            collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(
                _liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy)
            );

            if (_amount == _activeAmount) {
                return;
            }
        }
        revert('CreditLine::_depositCollateralFromSavingsAccount - Insufficient balance');
    }

    /**
     * @notice used to request a credit line either by borrower or lender
     * @param _requestTo Address to which creditLine is requested, 
                        if borrower creates request then lender address and 
                        if lender creates then borrower address
     * @param _borrowLimit maximum borrow amount in a credit line
     * @param _borrowRate Interest Rate at which credit Line is requested
     * @param _autoLiquidation if true, anyone can liquidate loan, otherwise only lender
     * @param _collateralRatio ratio of the collateral to the debt below which credit line can be liquidated
     * @param _borrowAsset address of the token to be borrowed
     * @param _collateralAsset address of the token provided as collateral
     * @param _requestAsLender if true, lender is placing request, otherwise borrower
     * @return identifier for the credit line
     */

    function request(
        address _requestTo,
        uint256 _borrowLimit,
        uint256 _borrowRate,
        bool _autoLiquidation,
        uint256 _collateralRatio,
        address _borrowAsset,
        address _collateralAsset,
        bool _requestAsLender
    ) external returns (uint256) {
        require(_borrowAsset != _collateralAsset, 'R: cant borrow lent token');
        require(IPriceOracle(priceOracle).doesFeedExist(_borrowAsset, _collateralAsset), 'R: No price feed');

        address _lender = _requestTo;
        address _borrower = msg.sender;
        if (_requestAsLender) {
            _lender = msg.sender;
            _borrower = _requestTo;
        }

        uint256 _id = _createRequest(
            _lender,
            _borrower,
            _borrowLimit,
            _borrowRate,
            _autoLiquidation,
            _collateralRatio,
            _borrowAsset,
            _collateralAsset,
            _requestAsLender
        );

        emit CreditLineRequested(_id, _lender, _borrower);
        return _id;
    }

    function _createRequest(
        address _lender,
        address _borrower,
        uint256 _borrowLimit,
        uint256 _borrowRate,
        bool _autoLiquidation,
        uint256 _collateralRatio,
        address _borrowAsset,
        address _collateralAsset,
        bool _requestByLender
    ) internal returns (uint256) {
        require(_lender != _borrower, 'Lender and Borrower cannot be same addresses');
        uint256 _id = creditLineCounter + 1;
        creditLineCounter = _id;
        creditLineVariables[_id].status = CreditLineStatus.REQUESTED;
        creditLineConstants[_id].borrower = _borrower;
        creditLineConstants[_id].lender = _lender;
        creditLineConstants[_id].borrowLimit = _borrowLimit;
        creditLineConstants[_id].autoLiquidation = _autoLiquidation;
        creditLineConstants[_id].idealCollateralRatio = _collateralRatio;
        creditLineConstants[_id].borrowRate = _borrowRate;
        creditLineConstants[_id].borrowAsset = _borrowAsset;
        creditLineConstants[_id].collateralAsset = _collateralAsset;
        creditLineConstants[_id].requestByLender = _requestByLender;
        return _id;
    }

    /**
     * @notice used to accept a credit line
     * @dev if borrower places request, lender can accept and vice versa
     * @param _id identifier for the credit line
     */
    function accept(uint256 _id) external {
        require(
            creditLineVariables[_id].status == CreditLineStatus.REQUESTED,
            'CreditLine::acceptCreditLineLender - CreditLine is already accepted'
        );
        bool _requestByLender = creditLineConstants[_id].requestByLender;
        require(
            (msg.sender == creditLineConstants[_id].borrower && _requestByLender) ||
                (msg.sender == creditLineConstants[_id].lender && !_requestByLender),
            "Only Borrower or Lender who hasn't requested can accept"
        );
        creditLineVariables[_id].status = CreditLineStatus.ACTIVE;
        emit CreditLineAccepted(_id);
    }

    /**
     * @notice used to deposit collateral into the credit line
     * @dev collateral tokens have to be approved in savingsAccount or token contract(unless ether).
            If transferred from savings account, the tokens are transferred from strategies in the 
            order prespecified in strategy registry
     * @param _id identifier for the credit line
     * @param _amount amount of collateral being deposited
     * @param _strategy strategy to which collateral is to be deposited in case transfer is not from savings account
     * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount 
                                otherwise direct from collateral token contract
     */
    function depositCollateral(
        uint256 _id,
        uint256 _amount,
        address _strategy,
        bool _fromSavingsAccount
    ) external payable nonReentrant ifCreditLineExists(_id) {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine not active');
        _depositCollateral(_id, _amount, _strategy, _fromSavingsAccount);
        emit CollateralDeposited(_id, _amount, _strategy);
    }

    function _depositCollateral(
        uint256 _id,
        uint256 _amount,
        address _strategy,
        bool _fromSavingsAccount
    ) internal {
        require(creditLineConstants[_id].lender != msg.sender, 'lender cant deposit collateral');
        if (_fromSavingsAccount) {
            _depositCollateralFromSavingsAccount(_id, _amount, msg.sender);
        } else {
            address _collateralAsset = creditLineConstants[_id].collateralAsset;
            ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
            if (_collateralAsset == address(0)) {
                require(msg.value == _amount, "CreditLine::_depositCollateral - value to transfer doesn't match argument");
            } else {
                IERC20(_collateralAsset).safeTransferFrom(msg.sender, address(this), _amount);
                IERC20(_collateralAsset).approve(_strategy, _amount);
            }
            uint256 _sharesReceived = _savingsAccount.deposit{value: msg.value}(_amount, _collateralAsset, _strategy, address(this));
            collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(_sharesReceived);
        }
    }

    function _withdrawBorrowAmount(
        address _asset,
        uint256 _amountInTokens,
        address _lender
    ) internal {
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        uint256 _activeAmount;
        for (uint256 _index = 0; _index < _strategyList.length; _index++) {
            if (_strategyList[_index] == address(0)) {
                continue;
            }
            uint256 _liquidityShares = _savingsAccount.balanceInShares(_lender, _asset, _strategyList[_index]);
            if (_liquidityShares != 0) {
                uint256 tokenInStrategy = _liquidityShares;
                tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);
                uint256 _tokensToTransfer = tokenInStrategy;
                if (_activeAmount.add(tokenInStrategy) >= _amountInTokens) {
                    _tokensToTransfer = (_amountInTokens.sub(_activeAmount));
                }
                _activeAmount = _activeAmount.add(_tokensToTransfer);
                _savingsAccount.withdrawFrom(_tokensToTransfer, _asset, _strategyList[_index], _lender, address(this), false);
                if (_activeAmount == _amountInTokens) {
                    return;
                }
            }
        }
        require(_activeAmount == _amountInTokens, 'insufficient balance');
    }

    /**
     * @notice used to borrow tokens from credit line by borrower
     * @dev only borrower can call this function. Amount that can actually be borrowed is 
            min(amount based on borrowLimit, allowance to creditLine contract, balance of lender)
     * @param _id identifier for the credit line
     * @param _amount amount of tokens to borrow
     */
    function borrow(uint256 _id, uint256 _amount) external payable nonReentrant onlyCreditLineBorrower(_id) {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');
        uint256 _borrowableAmount = calculateBorrowableAmount(_id);
        require(_amount <= _borrowableAmount, "CreditLine::borrow - The current collateral ratio doesn't allow to withdraw the amount");
        address _borrowAsset = creditLineConstants[_id].borrowAsset;
        address _lender = creditLineConstants[_id].lender;

        updateinterestAccruedTillLastPrincipalUpdate(_id);
        creditLineVariables[_id].principal = creditLineVariables[_id].principal.add(_amount);
        creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;

        uint256 _tokenDiffBalance;
        if (_borrowAsset != address(0)) {
            uint256 _balanceBefore = IERC20(_borrowAsset).balanceOf(address(this));
            _withdrawBorrowAmount(_borrowAsset, _amount, _lender);
            uint256 _balanceAfter = IERC20(_borrowAsset).balanceOf(address(this));
            _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);
        } else {
            uint256 _balanceBefore = address(this).balance;
            _withdrawBorrowAmount(_borrowAsset, _amount, _lender);
            uint256 _balanceAfter = address(this).balance;
            _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);
        }
        uint256 _protocolFee = _tokenDiffBalance.mul(protocolFeeFraction).div(10**30);
        _tokenDiffBalance = _tokenDiffBalance.sub(_protocolFee);

        if (_borrowAsset == address(0)) {
            (bool feeSuccess, ) = protocolFeeCollector.call{value: _protocolFee}('');
            require(feeSuccess, 'Transfer fail');
            (bool success, ) = msg.sender.call{value: _tokenDiffBalance}('');
            require(success, 'Transfer fail');
        } else {
            IERC20(_borrowAsset).safeTransfer(protocolFeeCollector, _protocolFee);
            IERC20(_borrowAsset).safeTransfer(msg.sender, _tokenDiffBalance);
        }
        emit BorrowedFromCreditLine(_id, _tokenDiffBalance);
    }

    function _repayFromSavingsAccount(
        uint256 _amount,
        address _asset,
        address _lender
    ) internal {
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        uint256 _activeAmount;

        for (uint256 _index = 0; _index < _strategyList.length; _index++) {
            if (_strategyList[_index] == address(0)) {
                continue;
            }
            uint256 _liquidityShares = _savingsAccount.balanceInShares(msg.sender, _asset, _strategyList[_index]);
            if (_liquidityShares == 0) {
                continue;
            }
            uint256 _tokenInStrategy = _liquidityShares;
            _tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);

            uint256 _tokensToTransfer = _tokenInStrategy;
            if (_activeAmount.add(_tokenInStrategy) >= _amount) {
                _tokensToTransfer = (_amount.sub(_activeAmount));
            }
            _activeAmount = _activeAmount.add(_tokensToTransfer);
            _savingsAccount.transferFrom(_tokensToTransfer, _asset, _strategyList[_index], msg.sender, _lender);

            if (_amount == _activeAmount) {
                return;
            }
        }
        revert('CreditLine::_repayFromSavingsAccount - Insufficient balance');
    }

    function _repay(
        uint256 _id,
        uint256 _amount,
        bool _fromSavingsAccount,
        uint256 _principalPaid
    ) internal {
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        address _defaultStrategy = defaultStrategy;
        address _borrowAsset = creditLineConstants[_id].borrowAsset;
        address _lender = creditLineConstants[_id].lender;
        if (!_fromSavingsAccount) {
            if (_borrowAsset == address(0)) {
                require(msg.value == _amount, 'creditLine::repay - Ether sent not equal to repay amount');
                _savingsAccount.deposit{value: _amount}(_amount, _borrowAsset, _defaultStrategy, _lender);
            } else {
                IERC20(_borrowAsset).safeTransferFrom(msg.sender, address(this), _amount);
                IERC20(_borrowAsset).approve(_defaultStrategy, _amount);
                _savingsAccount.deposit(_amount, _borrowAsset, _defaultStrategy, _lender);
            }
        } else {
            _repayFromSavingsAccount(_amount, _borrowAsset, _lender);
        }
        if (_principalPaid != 0) {
            _savingsAccount.increaseAllowanceToCreditLine(_principalPaid, _borrowAsset, _lender);
        }
    }

    /**
     * @notice used to repay interest and principal to credit line. Interest has to be repaid before repaying principal
     * @dev partial repayments possible
     * @param _id identifier for the credit line
     * @param _amount amount being repaid
     * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount 
                                otherwise direct from collateral token contract
     */
    function repay(
        uint256 _id,
        uint256 _amount,
        bool _fromSavingsAccount
    ) external payable nonReentrant {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');
        require(creditLineConstants[_id].lender != msg.sender, 'Lender cant repay');

        uint256 _interestSincePrincipalUpdate = calculateInterestAccrued(_id);
        uint256 _totalInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(
            _interestSincePrincipalUpdate
        );
        uint256 _interestToPay = _totalInterestAccrued.sub(creditLineVariables[_id].totalInterestRepaid);
        uint256 _totalCurrentDebt = _interestToPay.add(creditLineVariables[_id].principal);
        uint256 _principalPaid = 0;

        if (_amount >= _totalCurrentDebt) {
            _amount = _totalCurrentDebt;
            emit CompleteCreditLineRepaid(_id, _amount);
        } else {
            emit PartialCreditLineRepaid(_id, _amount);
        }

        if (_amount > _interestToPay) {
            creditLineVariables[_id].principal = _totalCurrentDebt.sub(_amount);
            creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _totalInterestAccrued;
            creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;
            creditLineVariables[_id].totalInterestRepaid = _totalInterestAccrued;
            _principalPaid = _amount.sub(_interestToPay);
        } else {
            creditLineVariables[_id].totalInterestRepaid = creditLineVariables[_id].totalInterestRepaid.add(_amount);
        }

        _repay(_id, _amount, _fromSavingsAccount, _principalPaid);

        if (creditLineVariables[_id].principal == 0) {
            _resetCreditLine(_id);
        }
    }

    function _resetCreditLine(uint256 _id) internal {
        creditLineVariables[_id].lastPrincipalUpdateTime = 0;
        creditLineVariables[_id].totalInterestRepaid = 0;
        creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = 0;
        emit CreditLineReset(_id);
    }

    /**
     * @dev used to close credit line by borrower or lender
     * @param _id identifier for the credit line
     */
    function close(uint256 _id) external ifCreditLineExists(_id) {
        require(
            msg.sender == creditLineConstants[_id].borrower || msg.sender == creditLineConstants[_id].lender,
            'CreditLine: Permission denied while closing Line of credit'
        );
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: Credit line should be active.');
        require(creditLineVariables[_id].principal == 0, 'CreditLine: Cannot be closed since not repaid.');
        require(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate == 0, 'CreditLine: Cannot be closed since not repaid.');
        creditLineVariables[_id].status = CreditLineStatus.CLOSED;
        emit CreditLineClosed(_id);
    }

    /**
     * @notice used to calculate the current collateral ratio
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view.
            Interest is also considered while calculating debt
     * @param _id identifier for the credit line
     * @return collateral ratio multiplied by 10**30 to retain precision
     */
    function calculateCurrentCollateralRatio(uint256 _id) public ifCreditLineExists(_id) returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(
            creditLineConstants[_id].collateralAsset,
            creditLineConstants[_id].borrowAsset
        );

        uint256 currentDebt = calculateCurrentDebt(_id);
        uint256 currentCollateralRatio = calculateTotalCollateralTokens(_id).mul(_ratioOfPrices).div(currentDebt).mul(10**30).div(
            10**_decimals
        );

        return currentCollateralRatio;
    }

    /**
     * @notice used to calculate the total collateral tokens
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @param _id identifier for the credit line
     * @return _amount total collateral tokens deposited into the credit line
     */
    function calculateTotalCollateralTokens(uint256 _id) public returns (uint256 _amount) {
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        uint256 _liquidityShares;
        for (uint256 index = 0; index < _strategyList.length; index++) {
            if (_strategyList[index] == address(0)) {
                continue;
            }
            _liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];
            uint256 _tokenInStrategy = _liquidityShares;
            _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(_liquidityShares, _collateralAsset);

            _amount = _amount.add(_tokenInStrategy);
        }
    }

    /**
     * @notice used to withdraw any excess collateral
     * @dev collateral can't be withdraw if collateralRatio goes below the ideal value. Only borrower can withdraw
     * @param _id identifier for the credit line
     * @param _amount amount of collateral to withdraw
     * @param _toSavingsAccount if true, tokens are transferred from savingsAccount 
                                otherwise direct from collateral token contract
     */
    function withdrawCollateral(
        uint256 _id,
        uint256 _amount,
        bool _toSavingsAccount
    ) external nonReentrant onlyCreditLineBorrower(_id) {
        uint256 _withdrawableCollateral = withdrawableCollateral(_id);
        require(_amount <= _withdrawableCollateral, 'Collateral ratio cant go below ideal');
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        _transferCollateral(_id, _collateralAsset, _amount, _toSavingsAccount);
        emit CollateralWithdrawn(_id, _amount);
    }

    /**
     * @notice used to calculate the collateral that can be withdrawn
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @param _id identifier for the credit line
     * @return total collateral withdrawable by borrower
     */
    function withdrawableCollateral(uint256 _id) public returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(
            creditLineConstants[_id].collateralAsset,
            creditLineConstants[_id].borrowAsset
        );

        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);
        uint256 _currentDebt = calculateCurrentDebt(_id);

        uint256 _collateralNeeded = _currentDebt
            .mul(creditLineConstants[_id].idealCollateralRatio)
            .div(_ratioOfPrices)
            .mul(10**_decimals)
            .div(10**30);

        if (_collateralNeeded >= _totalCollateralTokens) {
            return 0;
        }
        return _totalCollateralTokens.sub(_collateralNeeded);
    }

    function _transferCollateral(
        uint256 _id,
        address _asset,
        uint256 _amountInTokens,
        bool _toSavingsAccount
    ) internal {
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        uint256 _activeAmount;
        for (uint256 index = 0; index < _strategyList.length; index++) {
            uint256 liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];
            if (liquidityShares == 0 || _strategyList[index] == address(0)) {
                continue;
            }
            uint256 _tokenInStrategy = liquidityShares;
            _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(liquidityShares, _asset);
            uint256 _tokensToTransfer = _tokenInStrategy;
            if (_activeAmount.add(_tokenInStrategy) > _amountInTokens) {
                _tokensToTransfer = _amountInTokens.sub(_activeAmount);
                liquidityShares = liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy);
            }
            _activeAmount = _activeAmount.add(_tokensToTransfer);
            collateralShareInStrategy[_id][_strategyList[index]] = collateralShareInStrategy[_id][_strategyList[index]].sub(
                liquidityShares
            );
            if (_toSavingsAccount) {
                ISavingsAccount(savingsAccount).transfer(_tokensToTransfer, _asset, _strategyList[index], msg.sender);
            } else {
                ISavingsAccount(savingsAccount).withdraw(_tokensToTransfer, _asset, _strategyList[index], msg.sender, false);
            }

            if (_activeAmount == _amountInTokens) {
                return;
            }
        }
        revert('insufficient collateral');
    }

    /**
     * @notice used to liquidate credit line in case collateral ratio goes below the threshold
     * @dev if lender liquidates, then collateral is directly transferred. 
            If autoLiquidation is true, anyone can liquidate by providing enough borrow tokens
     * @param _id identifier for the credit line
     * @param _toSavingsAccount if true, tokens are transferred from savingsAccount 
                                otherwise direct from collateral token contract
     */
    function liquidate(uint256 _id, bool _toSavingsAccount) external payable nonReentrant {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: Credit line should be active.');
        require(creditLineVariables[_id].principal != 0, 'CreditLine: cannot liquidate if principal is 0');

        uint256 currentCollateralRatio = calculateCurrentCollateralRatio(_id);
        require(
            currentCollateralRatio < creditLineConstants[_id].idealCollateralRatio,
            'CreditLine: Collateral ratio is higher than ideal value'
        );

        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        address _lender = creditLineConstants[_id].lender;
        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);
        address _borrowAsset = creditLineConstants[_id].borrowAsset;

        creditLineVariables[_id].status = CreditLineStatus.LIQUIDATED;

        if (creditLineConstants[_id].autoLiquidation && _lender != msg.sender) {
            uint256 _borrowTokens = _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens);
            if (_borrowAsset == address(0)) {
                uint256 _returnETH = msg.value.sub(_borrowTokens, 'Insufficient ETH to liquidate');
                if (_returnETH != 0) {
                    (bool success, ) = msg.sender.call{value: _returnETH}('');
                    require(success, 'Transfer fail');
                }
            } else {
                IERC20(_borrowAsset).safeTransferFrom(msg.sender, _lender, _borrowTokens);
            }
        }

        _transferCollateral(_id, _collateralAsset, _totalCollateralTokens, _toSavingsAccount);

        emit CreditLineLiquidated(_id, msg.sender);
    }

    /**
     * @notice used to calculate the borrow tokens necessary for liquidator to liquidate
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @param _id identifier for the credit line
     * @return borrow tokens necessary for liquidator to liquidate
     */
    function borrowTokensToLiquidate(uint256 _id) external returns (uint256) {
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);
        address _borrowAsset = creditLineConstants[_id].borrowAsset;

        return _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens);
    }

    function _borrowTokensToLiquidate(
        address _borrowAsset,
        address _collateralAsset,
        uint256 _totalCollateralTokens
    ) internal view returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(_borrowAsset, _collateralAsset);
        uint256 _borrowTokens = (
            _totalCollateralTokens.mul(uint256(10**30).sub(liquidatorRewardFraction)).div(10**30).mul(_ratioOfPrices).div(10**_decimals)
        );

        return _borrowTokens;
    }

    receive() external payable {
        require(msg.sender == savingsAccount, 'CreditLine::receive invalid transaction');
    }
}
.]

Below are the details of our target smart contract codes and their associated test reports:

Task: "// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/utils/ReentrancyGuard.sol';
import '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';
import '../interfaces/IPriceOracle.sol';
import '../interfaces/IYield.sol';
import '../interfaces/ISavingsAccount.sol';
import '../SavingsAccount/SavingsAccountUtil.sol';
import '../interfaces/IStrategyRegistry.sol';

/**
 * @title Credit Line contract with Methods related to credit Line
 * @notice Implements the functions related to Credit Line
 * @author Sublime
 **/

contract CreditLine is ReentrancyGuard, OwnableUpgradeable {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    enum CreditLineStatus {
        NOT_CREATED,
        REQUESTED,
        ACTIVE,
        CLOSED,
        CANCELLED,
        LIQUIDATED
    }

    /**
     * @notice counter that tracks the number of credit lines created
     * @dev used to create unique identifier for credit lines
     **/
    uint256 public creditLineCounter;

    uint256 constant YEAR_IN_SECONDS = 365 days;

    struct CreditLineVariables {
        CreditLineStatus status;
        uint256 principal;
        uint256 totalInterestRepaid;
        uint256 lastPrincipalUpdateTime;
        uint256 interestAccruedTillLastPrincipalUpdate;
    }

    struct CreditLineConstants {
        address lender;
        address borrower;
        uint256 borrowLimit;
        uint256 idealCollateralRatio;
        uint256 borrowRate;
        address borrowAsset;
        address collateralAsset;
        bool autoLiquidation;
        bool requestByLender;
    }
    /**
     * @notice stores the collateral shares in a credit line per strategy
     * @dev creditLineId => Strategy => collateralShares
     **/
    mapping(uint256 => mapping(address => uint256)) public collateralShareInStrategy;

    /**
     * @notice stores the variables to maintain a credit line
     **/
    mapping(uint256 => CreditLineVariables) public creditLineVariables;

    /**
     * @notice stores the constants related to a credit line
     **/
    mapping(uint256 => CreditLineConstants) public creditLineConstants;

    /**
     * @notice stores the address of savings account contract
     **/
    address public savingsAccount;

    /**
     * @notice stores the address of price oracle contract
     **/
    address public priceOracle;

    /**
     * @notice stores the address of strategy registry contract
     **/
    address public strategyRegistry;

    /**
     * @notice stores the address of default strategy
     **/
    address public defaultStrategy;

    /**
     * @notice stores the fraction of borrowed amount charged as fee by protocol
     * @dev it is multiplied by 10**30
     **/
    uint256 public protocolFeeFraction;

    /**
     * @notice address where protocol fee is collected
     **/
    address public protocolFeeCollector;

    /**
     * @notice stores the fraction of amount liquidated given as reward to liquidator
     * @dev it is multiplied by 10**30
     **/
    uint256 public liquidatorRewardFraction;
    /**
     * @dev checks if Credit Line exists
     * @param _id identifier for the credit line
     **/
    modifier ifCreditLineExists(uint256 _id) {
        require(creditLineVariables[_id].status != CreditLineStatus.NOT_CREATED, 'Credit line does not exist');
        _;
    }

    /**
     * @dev checks if called by credit Line Borrower
     * @param _id creditLine identifier
     **/
    modifier onlyCreditLineBorrower(uint256 _id) {
        require(creditLineConstants[_id].borrower == msg.sender, 'Only credit line Borrower can access');
        _;
    }

    /**
     * @dev checks if called by credit Line Lender
     * @param _id creditLine identifier
     **/
    modifier onlyCreditLineLender(uint256 _id) {
        require(creditLineConstants[_id].lender == msg.sender, 'Only credit line Lender can access');
        _;
    }

    /**
     * @notice emitted when a collateral is deposited into credit line
     * @param id id of the credit line
     * @param amount amount of collateral deposited
     * @param strategy address of the strategy into which collateral is deposited
     */
    event CollateralDeposited(uint256 indexed id, uint256 amount, address indexed strategy);

    /**
     * @notice emitted when collateral is withdrawn from credit line
     * @param id id of the credit line
     * @param amount amount of collateral withdrawn
     */
    event CollateralWithdrawn(uint256 indexed id, uint256 amount);

    /**
     * @notice emitted when a request for new credit line is placed
     * @param id id of the credit line for which request was made
     * @param lender address of the lender for credit line
     * @param borrower address of the borrower for credit line
     */
    event CreditLineRequested(uint256 indexed id, address indexed lender, address indexed borrower);

    /**
     * @notice emitted when a credit line is liquidated
     * @param id id of the credit line which is liquidated
     * @param liquidator address of the liquidator
     */
    event CreditLineLiquidated(uint256 indexed id, address indexed liquidator);

    /**
     * @notice emitted when tokens are borrowed from credit line
     * @param id id of the credit line from which tokens are borrowed
     * @param borrowAmount amount of tokens borrowed
     */
    event BorrowedFromCreditLine(uint256 indexed id, uint256 borrowAmount);

    /**
     * @notice emitted when credit line is accepted
     * @param id id of the credit line that was accepted
     */
    event CreditLineAccepted(uint256 indexed id);

    /**
     * @notice emitted when credit line is completely repaid and reset
     * @param id id of the credit line that is reset
     */
    event CreditLineReset(uint256 indexed id);

    /**
     * @notice emitted when the credit line is partially repaid
     * @param id id of the credit line
     * @param repayAmount amount repaid
     */
    event PartialCreditLineRepaid(uint256 indexed id, uint256 repayAmount);

    /**
     * @notice emitted when the credit line is completely repaid
     * @param id id of the credit line
     * @param repayAmount amount repaid
     */
    event CompleteCreditLineRepaid(uint256 indexed id, uint256 repayAmount);

    /**
     * @notice emitted when the credit line is closed by one of the parties of credit line
     * @param id id of the credit line
     */
    event CreditLineClosed(uint256 indexed id);

    /**
     * @notice emitted when default strategy for the credit line is updated
     * @param defaultStrategy address of the strategy contract that is used as default by credit lines
     */
    event DefaultStrategyUpdated(address indexed defaultStrategy);

    /**
     * @notice emitted when the price oracle is updated
     * @param priceOracle address of the updated price oracle
     */
    event PriceOracleUpdated(address indexed priceOracle);

    /**
     * @notice emitted when the savings account address is updated
     * @param savingsAccount address of the updated savingsAccount
     */
    event SavingsAccountUpdated(address indexed savingsAccount);

    /**
     * @notice emitted when strategy registry address is updated
     * @param strategyRegistry address of the updated strategy registry
     */
    event StrategyRegistryUpdated(address indexed strategyRegistry);

    /**
     * @notice emitted when fee that protocol charges for credit line is updated
     * @param updatedProtocolFee updated value of protocolFeeFraction
     */
    event ProtocolFeeFractionUpdated(uint256 updatedProtocolFee);

    /**
     * @notice emitted when address which receives fee that protocol changes for pools is updated
     * @param updatedProtocolFeeCollector updated value of protocolFeeCollector
     */
    event ProtocolFeeCollectorUpdated(address indexed updatedProtocolFeeCollector);

    /**
     * @notice emitted when liquidatorRewardFraction is updated
     * @param liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator
     */
    event LiquidationRewardFractionUpdated(uint256 liquidatorRewardFraction);

    /**
     * @notice used to initialize the contract
     * @dev can only be called once during the life cycle of the contract
     * @param _defaultStrategy default strategy used in credit lines
     * @param _priceOracle address of the priceOracle
     * @param _savingsAccount address of  the savings account contract
     * @param _strategyRegistry address of the strategy registry contract
     * @param _owner address of owner who can change global variables
     * @param _protocolFeeFraction fraction of the fee charged by protocol
     * @param _protocolFeeCollector address to which protocol fee is charged to
     * @param _liquidatorRewardFraction fraction of the liquidated amount given as reward to the liquidator
     */
    function initialize(
        address _defaultStrategy,
        address _priceOracle,
        address _savingsAccount,
        address _strategyRegistry,
        address _owner,
        uint256 _protocolFeeFraction,
        address _protocolFeeCollector,
        uint256 _liquidatorRewardFraction
    ) external initializer {
        OwnableUpgradeable.__Ownable_init();
        OwnableUpgradeable.transferOwnership(_owner);

        _updateDefaultStrategy(_defaultStrategy);
        _updatePriceOracle(_priceOracle);
        _updateSavingsAccount(_savingsAccount);
        _updateStrategyRegistry(_strategyRegistry);
        _updateProtocolFeeFraction(_protocolFeeFraction);
        _updateProtocolFeeCollector(_protocolFeeCollector);
        _updateLiquidatorRewardFraction(_liquidatorRewardFraction);
    }

    /**
     * @notice used to update the default strategy
     * @dev can only be updated by owner
     * @param _defaultStrategy address of the updated default strategy
     */
    function updateDefaultStrategy(address _defaultStrategy) external onlyOwner {
        _updateDefaultStrategy(_defaultStrategy);
    }

    function _updateDefaultStrategy(address _defaultStrategy) internal {
        defaultStrategy = _defaultStrategy;
        emit DefaultStrategyUpdated(_defaultStrategy);
    }

    /**
     * @notice used to update the price oracle
     * @dev can only be updated by owner
     * @param _priceOracle address of the updated price oracle
     */
    function updatePriceOracle(address _priceOracle) external onlyOwner {
        _updatePriceOracle(_priceOracle);
    }

    function _updatePriceOracle(address _priceOracle) internal {
        priceOracle = _priceOracle;
        emit PriceOracleUpdated(_priceOracle);
    }

    /**
     * @notice used to update the savings account address
     * @dev can only be updated by owner
     * @param _savingsAccount address of the updated savings account
     */
    function updateSavingsAccount(address _savingsAccount) external onlyOwner {
        _updateSavingsAccount(_savingsAccount);
    }

    function _updateSavingsAccount(address _savingsAccount) internal {
        savingsAccount = _savingsAccount;
        emit SavingsAccountUpdated(_savingsAccount);
    }

    /**
     * @notice used to update the protocol fee fraction
     * @dev can only be updated by owner
     * @param _protocolFee fraction of the borrower amount collected as protocol fee
     */
    function updateProtocolFeeFraction(uint256 _protocolFee) external onlyOwner {
        _updateProtocolFeeFraction(_protocolFee);
    }

    function _updateProtocolFeeFraction(uint256 _protocolFee) internal {
        protocolFeeFraction = _protocolFee;
        emit ProtocolFeeFractionUpdated(_protocolFee);
    }

    /**
     * @notice used to update the protocol fee collector
     * @dev can only be updated by owner
     * @param _protocolFeeCollector address in which protocol fee is collected
     */
    function updateProtocolFeeCollector(address _protocolFeeCollector) external onlyOwner {
        _updateProtocolFeeCollector(_protocolFeeCollector);
    }

    function _updateProtocolFeeCollector(address _protocolFeeCollector) internal {
        require(_protocolFeeCollector != address(0), 'cant be 0 address');
        protocolFeeCollector = _protocolFeeCollector;
        emit ProtocolFeeCollectorUpdated(_protocolFeeCollector);
    }

    /**
     * @notice used to update the strategy registry address
     * @dev can only be updated by owner
     * @param _strategyRegistry address of the updated strategy registry
     */
    function updateStrategyRegistry(address _strategyRegistry) external onlyOwner {
        _updateStrategyRegistry(_strategyRegistry);
    }

    function _updateStrategyRegistry(address _strategyRegistry) internal {
        require(_strategyRegistry != address(0), 'CL::I zero address');
        strategyRegistry = _strategyRegistry;
        emit StrategyRegistryUpdated(_strategyRegistry);
    }

    /**
     * @notice used to update the liquidatorRewardFraction
     * @dev can only be updated by owner
     * @param _rewardFraction fraction of liquidated amount given to liquidator as reward
     */
    function updateLiquidatorRewardFraction(uint256 _rewardFraction) external onlyOwner {
        _updateLiquidatorRewardFraction(_rewardFraction);
    }

    function _updateLiquidatorRewardFraction(uint256 _rewardFraction) internal {
        require(_rewardFraction <= 10**30, 'Fraction has to be less than 1');
        liquidatorRewardFraction = _rewardFraction;
        emit LiquidationRewardFractionUpdated(_rewardFraction);
    }

    /**
     * @dev Used to Calculate Interest Per second on given principal and Interest rate
     * @param _principal principal Amount for which interest has to be calculated.
     * @param _borrowRate It is the Interest Rate at which Credit Line is approved
     * @return interest per second for the given parameters
     */
    function calculateInterest(
        uint256 _principal,
        uint256 _borrowRate,
        uint256 _timeElapsed
    ) public pure returns (uint256) {
        uint256 _interest = _principal.mul(_borrowRate).mul(_timeElapsed).div(10**30).div(YEAR_IN_SECONDS);

        return _interest;
    }

    /**
     * @dev Used to calculate interest accrued since last repayment
     * @param _id identifier for the credit line
     * @return interest accrued over current borrowed amount since last repayment
     */

    function calculateInterestAccrued(uint256 _id) public view returns (uint256) {
        uint256 _lastPrincipalUpdateTime = creditLineVariables[_id].lastPrincipalUpdateTime;
        if (_lastPrincipalUpdateTime == 0) return 0;
        uint256 _timeElapsed = (block.timestamp).sub(_lastPrincipalUpdateTime);
        uint256 _interestAccrued = calculateInterest(creditLineVariables[_id].principal, creditLineConstants[_id].borrowRate, _timeElapsed);
        return _interestAccrued;
    }

    /**
     * @dev Used to calculate current debt of borrower against a credit line.
     * @param _id identifier for the credit line
     * @return current debt of borrower
     */
    function calculateCurrentDebt(uint256 _id) public view returns (uint256) {
        uint256 _interestAccrued = calculateInterestAccrued(_id);
        uint256 _currentDebt = (creditLineVariables[_id].principal)
            .add(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate)
            .add(_interestAccrued)
            .sub(creditLineVariables[_id].totalInterestRepaid);
        return _currentDebt;
    }

    /**
     * @notice used to calculate amount that can be borrowed by the borrower
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view.
            borrowableAmount changes per block as interest changes per block.
     * @param _id identifier for the credit line
     * @return amount that can be borrowed from the credit line
     */
    function calculateBorrowableAmount(uint256 _id) public returns (uint256) {
        CreditLineStatus _status = creditLineVariables[_id].status;
        require(
            _status == CreditLineStatus.ACTIVE || _status == CreditLineStatus.REQUESTED,
            'CreditLine: Cannot only if credit line ACTIVE or REQUESTED'
        );
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(
            creditLineConstants[_id].collateralAsset,
            creditLineConstants[_id].borrowAsset
        );

        uint256 _totalCollateralToken = calculateTotalCollateralTokens(_id);

        uint256 _currentDebt = calculateCurrentDebt(_id);

        uint256 _maxPossible = _totalCollateralToken.mul(_ratioOfPrices).div(creditLineConstants[_id].idealCollateralRatio).mul(10**30).div(
            10**_decimals
        );

        uint256 _borrowLimit = creditLineConstants[_id].borrowLimit;

        if (_maxPossible > _borrowLimit) {
            _maxPossible = _borrowLimit;
        }
        if (_maxPossible > _currentDebt) {
            return _maxPossible.sub(_currentDebt);
        }
        return 0;
    }

    function updateinterestAccruedTillLastPrincipalUpdate(uint256 _id) internal {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');

        uint256 _interestAccrued = calculateInterestAccrued(_id);
        uint256 _newInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(_interestAccrued);
        creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _newInterestAccrued;
    }

    function _depositCollateralFromSavingsAccount(
        uint256 _id,
        uint256 _amount,
        address _sender
    ) internal {
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        uint256 _activeAmount;

        for (uint256 _index = 0; _index < _strategyList.length; _index++) {
            address _strategy = _strategyList[_index];
            uint256 _liquidityShares = _savingsAccount.balanceInShares(_sender, _collateralAsset, _strategy);
            if (_liquidityShares == 0 || _strategyList[_index] == address(0)) {
                continue;
            }
            uint256 _tokenInStrategy = _liquidityShares;
            _tokenInStrategy = IYield(_strategy).getTokensForShares(_liquidityShares, _collateralAsset);

            uint256 _tokensToTransfer = _tokenInStrategy;
            if (_activeAmount.add(_tokenInStrategy) >= _amount) {
                _tokensToTransfer = (_amount.sub(_activeAmount));
            }
            _activeAmount = _activeAmount.add(_tokensToTransfer);
            _savingsAccount.transferFrom(_tokensToTransfer, _collateralAsset, _strategy, _sender, address(this));

            collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(
                _liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy)
            );

            if (_amount == _activeAmount) {
                return;
            }
        }
        revert('CreditLine::_depositCollateralFromSavingsAccount - Insufficient balance');
    }

    /**
     * @notice used to request a credit line either by borrower or lender
     * @param _requestTo Address to which creditLine is requested, 
                        if borrower creates request then lender address and 
                        if lender creates then borrower address
     * @param _borrowLimit maximum borrow amount in a credit line
     * @param _borrowRate Interest Rate at which credit Line is requested
     * @param _autoLiquidation if true, anyone can liquidate loan, otherwise only lender
     * @param _collateralRatio ratio of the collateral to the debt below which credit line can be liquidated
     * @param _borrowAsset address of the token to be borrowed
     * @param _collateralAsset address of the token provided as collateral
     * @param _requestAsLender if true, lender is placing request, otherwise borrower
     * @return identifier for the credit line
     */

    function request(
        address _requestTo,
        uint256 _borrowLimit,
        uint256 _borrowRate,
        bool _autoLiquidation,
        uint256 _collateralRatio,
        address _borrowAsset,
        address _collateralAsset,
        bool _requestAsLender
    ) external returns (uint256) {
        require(_borrowAsset != _collateralAsset, 'R: cant borrow lent token');
        require(IPriceOracle(priceOracle).doesFeedExist(_borrowAsset, _collateralAsset), 'R: No price feed');

        address _lender = _requestTo;
        address _borrower = msg.sender;
        if (_requestAsLender) {
            _lender = msg.sender;
            _borrower = _requestTo;
        }

        uint256 _id = _createRequest(
            _lender,
            _borrower,
            _borrowLimit,
            _borrowRate,
            _autoLiquidation,
            _collateralRatio,
            _borrowAsset,
            _collateralAsset,
            _requestAsLender
        );

        emit CreditLineRequested(_id, _lender, _borrower);
        return _id;
    }

    function _createRequest(
        address _lender,
        address _borrower,
        uint256 _borrowLimit,
        uint256 _borrowRate,
        bool _autoLiquidation,
        uint256 _collateralRatio,
        address _borrowAsset,
        address _collateralAsset,
        bool _requestByLender
    ) internal returns (uint256) {
        require(_lender != _borrower, 'Lender and Borrower cannot be same addresses');
        uint256 _id = creditLineCounter + 1;
        creditLineCounter = _id;
        creditLineVariables[_id].status = CreditLineStatus.REQUESTED;
        creditLineConstants[_id].borrower = _borrower;
        creditLineConstants[_id].lender = _lender;
        creditLineConstants[_id].borrowLimit = _borrowLimit;
        creditLineConstants[_id].autoLiquidation = _autoLiquidation;
        creditLineConstants[_id].idealCollateralRatio = _collateralRatio;
        creditLineConstants[_id].borrowRate = _borrowRate;
        creditLineConstants[_id].borrowAsset = _borrowAsset;
        creditLineConstants[_id].collateralAsset = _collateralAsset;
        creditLineConstants[_id].requestByLender = _requestByLender;
        return _id;
    }

    /**
     * @notice used to accept a credit line
     * @dev if borrower places request, lender can accept and vice versa
     * @param _id identifier for the credit line
     */
    function accept(uint256 _id) external {
        require(
            creditLineVariables[_id].status == CreditLineStatus.REQUESTED,
            'CreditLine::acceptCreditLineLender - CreditLine is already accepted'
        );
        bool _requestByLender = creditLineConstants[_id].requestByLender;
        require(
            (msg.sender == creditLineConstants[_id].borrower && _requestByLender) ||
                (msg.sender == creditLineConstants[_id].lender && !_requestByLender),
            "Only Borrower or Lender who hasn't requested can accept"
        );
        creditLineVariables[_id].status = CreditLineStatus.ACTIVE;
        emit CreditLineAccepted(_id);
    }

    /**
     * @notice used to deposit collateral into the credit line
     * @dev collateral tokens have to be approved in savingsAccount or token contract(unless ether).
            If transferred from savings account, the tokens are transferred from strategies in the 
            order prespecified in strategy registry
     * @param _id identifier for the credit line
     * @param _amount amount of collateral being deposited
     * @param _strategy strategy to which collateral is to be deposited in case transfer is not from savings account
     * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount 
                                otherwise direct from collateral token contract
     */
    function depositCollateral(
        uint256 _id,
        uint256 _amount,
        address _strategy,
        bool _fromSavingsAccount
    ) external payable nonReentrant ifCreditLineExists(_id) {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine not active');
        _depositCollateral(_id, _amount, _strategy, _fromSavingsAccount);
        emit CollateralDeposited(_id, _amount, _strategy);
    }

    function _depositCollateral(
        uint256 _id,
        uint256 _amount,
        address _strategy,
        bool _fromSavingsAccount
    ) internal {
        require(creditLineConstants[_id].lender != msg.sender, 'lender cant deposit collateral');
        if (_fromSavingsAccount) {
            _depositCollateralFromSavingsAccount(_id, _amount, msg.sender);
        } else {
            address _collateralAsset = creditLineConstants[_id].collateralAsset;
            ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
            if (_collateralAsset == address(0)) {
                require(msg.value == _amount, "CreditLine::_depositCollateral - value to transfer doesn't match argument");
            } else {
                IERC20(_collateralAsset).safeTransferFrom(msg.sender, address(this), _amount);
                IERC20(_collateralAsset).approve(_strategy, _amount);
            }
            uint256 _sharesReceived = _savingsAccount.deposit{value: msg.value}(_amount, _collateralAsset, _strategy, address(this));
            collateralShareInStrategy[_id][_strategy] = collateralShareInStrategy[_id][_strategy].add(_sharesReceived);
        }
    }

    function _withdrawBorrowAmount(
        address _asset,
        uint256 _amountInTokens,
        address _lender
    ) internal {
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        uint256 _activeAmount;
        for (uint256 _index = 0; _index < _strategyList.length; _index++) {
            if (_strategyList[_index] == address(0)) {
                continue;
            }
            uint256 _liquidityShares = _savingsAccount.balanceInShares(_lender, _asset, _strategyList[_index]);
            if (_liquidityShares != 0) {
                uint256 tokenInStrategy = _liquidityShares;
                tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);
                uint256 _tokensToTransfer = tokenInStrategy;
                if (_activeAmount.add(tokenInStrategy) >= _amountInTokens) {
                    _tokensToTransfer = (_amountInTokens.sub(_activeAmount));
                }
                _activeAmount = _activeAmount.add(_tokensToTransfer);
                _savingsAccount.withdrawFrom(_tokensToTransfer, _asset, _strategyList[_index], _lender, address(this), false);
                if (_activeAmount == _amountInTokens) {
                    return;
                }
            }
        }
        require(_activeAmount == _amountInTokens, 'insufficient balance');
    }

    /**
     * @notice used to borrow tokens from credit line by borrower
     * @dev only borrower can call this function. Amount that can actually be borrowed is 
            min(amount based on borrowLimit, allowance to creditLine contract, balance of lender)
     * @param _id identifier for the credit line
     * @param _amount amount of tokens to borrow
     */
    function borrow(uint256 _id, uint256 _amount) external payable nonReentrant onlyCreditLineBorrower(_id) {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');
        uint256 _borrowableAmount = calculateBorrowableAmount(_id);
        require(_amount <= _borrowableAmount, "CreditLine::borrow - The current collateral ratio doesn't allow to withdraw the amount");
        address _borrowAsset = creditLineConstants[_id].borrowAsset;
        address _lender = creditLineConstants[_id].lender;

        updateinterestAccruedTillLastPrincipalUpdate(_id);
        creditLineVariables[_id].principal = creditLineVariables[_id].principal.add(_amount);
        creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;

        uint256 _tokenDiffBalance;
        if (_borrowAsset != address(0)) {
            uint256 _balanceBefore = IERC20(_borrowAsset).balanceOf(address(this));
            _withdrawBorrowAmount(_borrowAsset, _amount, _lender);
            uint256 _balanceAfter = IERC20(_borrowAsset).balanceOf(address(this));
            _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);
        } else {
            uint256 _balanceBefore = address(this).balance;
            _withdrawBorrowAmount(_borrowAsset, _amount, _lender);
            uint256 _balanceAfter = address(this).balance;
            _tokenDiffBalance = _balanceAfter.sub(_balanceBefore);
        }
        uint256 _protocolFee = _tokenDiffBalance.mul(protocolFeeFraction).div(10**30);
        _tokenDiffBalance = _tokenDiffBalance.sub(_protocolFee);

        if (_borrowAsset == address(0)) {
            (bool feeSuccess, ) = protocolFeeCollector.call{value: _protocolFee}('');
            require(feeSuccess, 'Transfer fail');
            (bool success, ) = msg.sender.call{value: _tokenDiffBalance}('');
            require(success, 'Transfer fail');
        } else {
            IERC20(_borrowAsset).safeTransfer(protocolFeeCollector, _protocolFee);
            IERC20(_borrowAsset).safeTransfer(msg.sender, _tokenDiffBalance);
        }
        emit BorrowedFromCreditLine(_id, _tokenDiffBalance);
    }

    function _repayFromSavingsAccount(
        uint256 _amount,
        address _asset,
        address _lender
    ) internal {
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        uint256 _activeAmount;

        for (uint256 _index = 0; _index < _strategyList.length; _index++) {
            if (_strategyList[_index] == address(0)) {
                continue;
            }
            uint256 _liquidityShares = _savingsAccount.balanceInShares(msg.sender, _asset, _strategyList[_index]);
            if (_liquidityShares == 0) {
                continue;
            }
            uint256 _tokenInStrategy = _liquidityShares;
            _tokenInStrategy = IYield(_strategyList[_index]).getTokensForShares(_liquidityShares, _asset);

            uint256 _tokensToTransfer = _tokenInStrategy;
            if (_activeAmount.add(_tokenInStrategy) >= _amount) {
                _tokensToTransfer = (_amount.sub(_activeAmount));
            }
            _activeAmount = _activeAmount.add(_tokensToTransfer);
            _savingsAccount.transferFrom(_tokensToTransfer, _asset, _strategyList[_index], msg.sender, _lender);

            if (_amount == _activeAmount) {
                return;
            }
        }
        revert('CreditLine::_repayFromSavingsAccount - Insufficient balance');
    }

    function _repay(
        uint256 _id,
        uint256 _amount,
        bool _fromSavingsAccount,
        uint256 _principalPaid
    ) internal {
        ISavingsAccount _savingsAccount = ISavingsAccount(savingsAccount);
        address _defaultStrategy = defaultStrategy;
        address _borrowAsset = creditLineConstants[_id].borrowAsset;
        address _lender = creditLineConstants[_id].lender;
        if (!_fromSavingsAccount) {
            if (_borrowAsset == address(0)) {
                require(msg.value == _amount, 'creditLine::repay - Ether sent not equal to repay amount');
                _savingsAccount.deposit{value: _amount}(_amount, _borrowAsset, _defaultStrategy, _lender);
            } else {
                IERC20(_borrowAsset).safeTransferFrom(msg.sender, address(this), _amount);
                IERC20(_borrowAsset).approve(_defaultStrategy, _amount);
                _savingsAccount.deposit(_amount, _borrowAsset, _defaultStrategy, _lender);
            }
        } else {
            _repayFromSavingsAccount(_amount, _borrowAsset, _lender);
        }
        if (_principalPaid != 0) {
            _savingsAccount.increaseAllowanceToCreditLine(_principalPaid, _borrowAsset, _lender);
        }
    }

    /**
     * @notice used to repay interest and principal to credit line. Interest has to be repaid before repaying principal
     * @dev partial repayments possible
     * @param _id identifier for the credit line
     * @param _amount amount being repaid
     * @param _fromSavingsAccount if true, tokens are transferred from savingsAccount 
                                otherwise direct from collateral token contract
     */
    function repay(
        uint256 _id,
        uint256 _amount,
        bool _fromSavingsAccount
    ) external payable nonReentrant {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: The credit line is not yet active.');
        require(creditLineConstants[_id].lender != msg.sender, 'Lender cant repay');

        uint256 _interestSincePrincipalUpdate = calculateInterestAccrued(_id);
        uint256 _totalInterestAccrued = (creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate).add(
            _interestSincePrincipalUpdate
        );
        uint256 _interestToPay = _totalInterestAccrued.sub(creditLineVariables[_id].totalInterestRepaid);
        uint256 _totalCurrentDebt = _interestToPay.add(creditLineVariables[_id].principal);
        uint256 _principalPaid = 0;

        if (_amount >= _totalCurrentDebt) {
            _amount = _totalCurrentDebt;
            emit CompleteCreditLineRepaid(_id, _amount);
        } else {
            emit PartialCreditLineRepaid(_id, _amount);
        }

        if (_amount > _interestToPay) {
            creditLineVariables[_id].principal = _totalCurrentDebt.sub(_amount);
            creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = _totalInterestAccrued;
            creditLineVariables[_id].lastPrincipalUpdateTime = block.timestamp;
            creditLineVariables[_id].totalInterestRepaid = _totalInterestAccrued;
            _principalPaid = _amount.sub(_interestToPay);
        } else {
            creditLineVariables[_id].totalInterestRepaid = creditLineVariables[_id].totalInterestRepaid.add(_amount);
        }

        _repay(_id, _amount, _fromSavingsAccount, _principalPaid);

        if (creditLineVariables[_id].principal == 0) {
            _resetCreditLine(_id);
        }
    }

    function _resetCreditLine(uint256 _id) internal {
        creditLineVariables[_id].lastPrincipalUpdateTime = 0;
        creditLineVariables[_id].totalInterestRepaid = 0;
        creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate = 0;
        emit CreditLineReset(_id);
    }

    /**
     * @dev used to close credit line by borrower or lender
     * @param _id identifier for the credit line
     */
    function close(uint256 _id) external ifCreditLineExists(_id) {
        require(
            msg.sender == creditLineConstants[_id].borrower || msg.sender == creditLineConstants[_id].lender,
            'CreditLine: Permission denied while closing Line of credit'
        );
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: Credit line should be active.');
        require(creditLineVariables[_id].principal == 0, 'CreditLine: Cannot be closed since not repaid.');
        require(creditLineVariables[_id].interestAccruedTillLastPrincipalUpdate == 0, 'CreditLine: Cannot be closed since not repaid.');
        creditLineVariables[_id].status = CreditLineStatus.CLOSED;
        emit CreditLineClosed(_id);
    }

    /**
     * @notice used to calculate the current collateral ratio
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view.
            Interest is also considered while calculating debt
     * @param _id identifier for the credit line
     * @return collateral ratio multiplied by 10**30 to retain precision
     */
    function calculateCurrentCollateralRatio(uint256 _id) public ifCreditLineExists(_id) returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(
            creditLineConstants[_id].collateralAsset,
            creditLineConstants[_id].borrowAsset
        );

        uint256 currentDebt = calculateCurrentDebt(_id);
        uint256 currentCollateralRatio = calculateTotalCollateralTokens(_id).mul(_ratioOfPrices).div(currentDebt).mul(10**30).div(
            10**_decimals
        );

        return currentCollateralRatio;
    }

    /**
     * @notice used to calculate the total collateral tokens
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @param _id identifier for the credit line
     * @return _amount total collateral tokens deposited into the credit line
     */
    function calculateTotalCollateralTokens(uint256 _id) public returns (uint256 _amount) {
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        uint256 _liquidityShares;
        for (uint256 index = 0; index < _strategyList.length; index++) {
            if (_strategyList[index] == address(0)) {
                continue;
            }
            _liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];
            uint256 _tokenInStrategy = _liquidityShares;
            _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(_liquidityShares, _collateralAsset);

            _amount = _amount.add(_tokenInStrategy);
        }
    }

    /**
     * @notice used to withdraw any excess collateral
     * @dev collateral can't be withdraw if collateralRatio goes below the ideal value. Only borrower can withdraw
     * @param _id identifier for the credit line
     * @param _amount amount of collateral to withdraw
     * @param _toSavingsAccount if true, tokens are transferred from savingsAccount 
                                otherwise direct from collateral token contract
     */
    function withdrawCollateral(
        uint256 _id,
        uint256 _amount,
        bool _toSavingsAccount
    ) external nonReentrant onlyCreditLineBorrower(_id) {
        uint256 _withdrawableCollateral = withdrawableCollateral(_id);
        require(_amount <= _withdrawableCollateral, 'Collateral ratio cant go below ideal');
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        _transferCollateral(_id, _collateralAsset, _amount, _toSavingsAccount);
        emit CollateralWithdrawn(_id, _amount);
    }

    /**
     * @notice used to calculate the collateral that can be withdrawn
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @param _id identifier for the credit line
     * @return total collateral withdrawable by borrower
     */
    function withdrawableCollateral(uint256 _id) public returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(
            creditLineConstants[_id].collateralAsset,
            creditLineConstants[_id].borrowAsset
        );

        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);
        uint256 _currentDebt = calculateCurrentDebt(_id);

        uint256 _collateralNeeded = _currentDebt
            .mul(creditLineConstants[_id].idealCollateralRatio)
            .div(_ratioOfPrices)
            .mul(10**_decimals)
            .div(10**30);

        if (_collateralNeeded >= _totalCollateralTokens) {
            return 0;
        }
        return _totalCollateralTokens.sub(_collateralNeeded);
    }

    function _transferCollateral(
        uint256 _id,
        address _asset,
        uint256 _amountInTokens,
        bool _toSavingsAccount
    ) internal {
        address[] memory _strategyList = IStrategyRegistry(strategyRegistry).getStrategies();
        uint256 _activeAmount;
        for (uint256 index = 0; index < _strategyList.length; index++) {
            uint256 liquidityShares = collateralShareInStrategy[_id][_strategyList[index]];
            if (liquidityShares == 0 || _strategyList[index] == address(0)) {
                continue;
            }
            uint256 _tokenInStrategy = liquidityShares;
            _tokenInStrategy = IYield(_strategyList[index]).getTokensForShares(liquidityShares, _asset);
            uint256 _tokensToTransfer = _tokenInStrategy;
            if (_activeAmount.add(_tokenInStrategy) > _amountInTokens) {
                _tokensToTransfer = _amountInTokens.sub(_activeAmount);
                liquidityShares = liquidityShares.mul(_tokensToTransfer).div(_tokenInStrategy);
            }
            _activeAmount = _activeAmount.add(_tokensToTransfer);
            collateralShareInStrategy[_id][_strategyList[index]] = collateralShareInStrategy[_id][_strategyList[index]].sub(
                liquidityShares
            );
            if (_toSavingsAccount) {
                ISavingsAccount(savingsAccount).transfer(_tokensToTransfer, _asset, _strategyList[index], msg.sender);
            } else {
                ISavingsAccount(savingsAccount).withdraw(_tokensToTransfer, _asset, _strategyList[index], msg.sender, false);
            }

            if (_activeAmount == _amountInTokens) {
                return;
            }
        }
        revert('insufficient collateral');
    }

    /**
     * @notice used to liquidate credit line in case collateral ratio goes below the threshold
     * @dev if lender liquidates, then collateral is directly transferred. 
            If autoLiquidation is true, anyone can liquidate by providing enough borrow tokens
     * @param _id identifier for the credit line
     * @param _toSavingsAccount if true, tokens are transferred from savingsAccount 
                                otherwise direct from collateral token contract
     */
    function liquidate(uint256 _id, bool _toSavingsAccount) external payable nonReentrant {
        require(creditLineVariables[_id].status == CreditLineStatus.ACTIVE, 'CreditLine: Credit line should be active.');
        require(creditLineVariables[_id].principal != 0, 'CreditLine: cannot liquidate if principal is 0');

        uint256 currentCollateralRatio = calculateCurrentCollateralRatio(_id);
        require(
            currentCollateralRatio < creditLineConstants[_id].idealCollateralRatio,
            'CreditLine: Collateral ratio is higher than ideal value'
        );

        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        address _lender = creditLineConstants[_id].lender;
        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);
        address _borrowAsset = creditLineConstants[_id].borrowAsset;

        creditLineVariables[_id].status = CreditLineStatus.LIQUIDATED;

        if (creditLineConstants[_id].autoLiquidation && _lender != msg.sender) {
            uint256 _borrowTokens = _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens);
            if (_borrowAsset == address(0)) {
                uint256 _returnETH = msg.value.sub(_borrowTokens, 'Insufficient ETH to liquidate');
                if (_returnETH != 0) {
                    (bool success, ) = msg.sender.call{value: _returnETH}('');
                    require(success, 'Transfer fail');
                }
            } else {
                IERC20(_borrowAsset).safeTransferFrom(msg.sender, _lender, _borrowTokens);
            }
        }

        _transferCollateral(_id, _collateralAsset, _totalCollateralTokens, _toSavingsAccount);

        emit CreditLineLiquidated(_id, msg.sender);
    }

    /**
     * @notice used to calculate the borrow tokens necessary for liquidator to liquidate
     * @dev is a view function for the protocol itself, but isn't view because of getTokensForShares which is not view
     * @param _id identifier for the credit line
     * @return borrow tokens necessary for liquidator to liquidate
     */
    function borrowTokensToLiquidate(uint256 _id) external returns (uint256) {
        address _collateralAsset = creditLineConstants[_id].collateralAsset;
        uint256 _totalCollateralTokens = calculateTotalCollateralTokens(_id);
        address _borrowAsset = creditLineConstants[_id].borrowAsset;

        return _borrowTokensToLiquidate(_borrowAsset, _collateralAsset, _totalCollateralTokens);
    }

    function _borrowTokensToLiquidate(
        address _borrowAsset,
        address _collateralAsset,
        uint256 _totalCollateralTokens
    ) internal view returns (uint256) {
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracle).getLatestPrice(_borrowAsset, _collateralAsset);
        uint256 _borrowTokens = (
            _totalCollateralTokens.mul(uint256(10**30).sub(liquidatorRewardFraction)).div(10**30).mul(_ratioOfPrices).div(10**_decimals)
        );

        return _borrowTokens;
    }

    receive() external payable {
        require(msg.sender == savingsAccount, 'CreditLine::receive invalid transaction');
    }
}
".

Existing Test Reports:

"The software run successfully without errors."

Based on the given test reports, please identify and succinctly summarize all bugs causing issues within the contract codes. The objective is to obtain a clear and consolidated overview of all identified bugs. Conclude with a comprehensive test report summarizing the findings.

