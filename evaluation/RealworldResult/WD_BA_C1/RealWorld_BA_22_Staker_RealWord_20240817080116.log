[2024-17-08 08:01:16 INFO] **[Preprocessing]**

**ChatDev Starts** (20240817080116)

**Timestamp**: 20240817080116

**config_path**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/CompanyConfig/SmartContractBA/ChatChainConfig.json

**config_phase_path**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/CompanyConfig/SmartContractBA/PhaseConfig.json

**config_role_path**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/CompanyConfig/SmartContractBA/RoleConfig.json

**task_prompt**: // SPDX-License-Identifier: BUSL-1.1

pragma solidity 0.8.3;

import "@openzeppelin/contracts-upgradeable/token/ERC20/presets/ERC20PresetMinterPauserUpgradeable.sol";

import "./interfaces/IFloatToken.sol";
import "./interfaces/ILongShort.sol";
import "./interfaces/IStaker.sol";
import "./interfaces/ISyntheticToken.sol";

contract Staker is IStaker, Initializable {
  /*╔═════════════════════════════╗
    ║          VARIABLES          ║
    ╚═════════════════════════════╝*/

  /* ══════ Fixed-precision constants ══════ */
  uint256 public constant FLOAT_ISSUANCE_FIXED_DECIMAL = 1e42;
  // 2^52 ~= 4.5e15
  // With an exponent of 5, the largest total liquidity possible in a market (to avoid integer overflow on exponentiation) is ~10^31 or 10 Trillion (10^13)
  // NOTE: this also means if the total market value is less than 2^52 there will be a division by zero error
  uint256 public constant safeExponentBitShifting = 52;

  /* ══════ Global state ══════ */
  address public admin;
  address public floatCapital;
  address public floatTreasury;
  uint256 public floatPercentage;

  address public longShort;
  address public floatToken;

  /* ══════ Market specific ══════ */
  mapping(uint32 => uint256) public marketLaunchIncentive_period; // seconds
  mapping(uint32 => uint256) public marketLaunchIncentive_multipliers; // e18 scale
  mapping(uint32 => uint256) public marketUnstakeFee_e18;
  mapping(uint32 => uint256) public balanceIncentiveCurve_exponent;
  mapping(uint32 => int256) public balanceIncentiveCurve_equilibriumOffset;

  mapping(uint32 => mapping(bool => address)) public syntheticTokens;

  mapping(address => uint32) public marketIndexOfToken;

  /* ══════ Reward specific ══════ */
  mapping(uint32 => uint256) public latestRewardIndex;
  mapping(uint32 => mapping(uint256 => AccumulativeIssuancePerStakedSynthSnapshot))
    public accumulativeFloatPerSyntheticTokenSnapshots;
  struct AccumulativeIssuancePerStakedSynthSnapshot {
    uint256 timestamp;
    uint256 accumulativeFloatPerSyntheticToken_long;
    uint256 accumulativeFloatPerSyntheticToken_short;
  }

  /* ══════ User specific ══════ */
  mapping(uint32 => mapping(address => uint256)) public userIndexOfLastClaimedReward;
  mapping(address => mapping(address => uint256)) public userAmountStaked;

  /* ══════ Token shift management specific ══════ */
  mapping(uint32 => uint256) public batched_stakerNextTokenShiftIndex;
  /**
  @notice Used to link a token shift to a staker state
  @dev tokenShiftIndex => accumulativeFloatIssuanceSnapshotIndex
    POSSIBLE OPTIMIZATION - could pack stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping and stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping into a struct of two uint128 for storage space optimization.
  */
  mapping(uint256 => uint256) public stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping;
  /// @notice Used to fetch the price from LongShort at that point in time
  /// @dev tokenShiftIndex => longShortMarketPriceSnapshotIndex
  mapping(uint256 => uint256) public stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping;
  /// @dev marketIndex => usersAddress => stakerTokenShiftIndex
  mapping(uint32 => mapping(address => uint256)) public userNextPrice_stakedSyntheticTokenShiftIndex;
  /// @dev marketIndex => usersAddress => amountUserRequestedToShiftAwayFromLongOnNextUpdate
  mapping(uint32 => mapping(address => uint256)) public userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long;
  /// @dev marketIndex => usersAddress => amountUserRequestedToShiftAwayFromShortOnNextUpdate
  mapping(uint32 => mapping(address => uint256)) public userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short;

  /*╔════════════════════════════╗
    ║           EVENTS           ║
    ╚════════════════════════════╝*/

  event StakerV1(
    address admin,
    address floatTreasury,
    address floatCapital,
    address floatToken,
    uint256 floatPercentage
  );

  event MarketAddedToStaker(
    uint32 marketIndex,
    uint256 exitFee_e18,
    uint256 period,
    uint256 multiplier,
    uint256 balanceIncentiveExponent,
    int256 balanceIncentiveEquilibriumOffset
  );

  event AccumulativeIssuancePerStakedSynthSnapshotCreated(
    uint32 marketIndex,
    uint256 accumulativeFloatIssuanceSnapshotIndex,
    uint256 accumulativeLong,
    uint256 accumulativeShort
  );

  event StakeAdded(address user, address token, uint256 amount, uint256 lastMintIndex);

  event StakeWithdrawn(address user, address token, uint256 amount);

  // Note: the `amountFloatMinted` isn't strictly needed by the graph, but it is good to add it to validate calculations are accurate.
  event FloatMinted(address user, uint32 marketIndex, uint256 amountFloatMinted);

  event MarketLaunchIncentiveParametersChanges(uint32 marketIndex, uint256 period, uint256 multiplier);

  event StakeWithdrawalFeeUpdated(uint32 marketIndex, uint256 stakeWithdralFee);

  event BalanceIncentiveExponentUpdated(uint32 marketIndex, uint256 balanceIncentiveExponent);

  event BalanceIncentiveEquilibriumOffsetUpdated(uint32 marketIndex, int256 balanceIncentiveEquilibriumOffset);

  event FloatPercentageUpdated(uint256 floatPercentage);

  event SyntheticTokensShifted();

  event ChangeAdmin(address newAdmin);

  /*╔═════════════════════════════╗
    ║          MODIFIERS          ║
    ╚═════════════════════════════╝*/

  function onlyAdminModifierLogic() internal virtual {
    require(msg.sender == admin, "not admin");
  }

  modifier onlyAdmin() {
    onlyAdminModifierLogic();
    _;
  }

  function onlyValidSyntheticModifierLogic(address _synth) internal virtual {
    require(marketIndexOfToken[_synth] != 0, "not valid synth");
  }

  modifier onlyValidSynthetic(address _synth) {
    onlyValidSyntheticModifierLogic(_synth);
    _;
  }

  function onlyValidMarketModifierLogic(uint32 marketIndex) internal virtual {
    require(address(syntheticTokens[marketIndex][true]) != address(0), "not valid market");
  }

  modifier onlyValidMarket(uint32 marketIndex) {
    onlyValidMarketModifierLogic(marketIndex);
    _;
  }

  function onlyLongShortModifierLogic() internal virtual {
    require(msg.sender == address(longShort), "not long short");
  }

  modifier onlyLongShort() {
    onlyLongShortModifierLogic();
    _;
  }

  /*╔═════════════════════════════╗
    ║       CONTRACT SET-UP       ║
    ╚═════════════════════════════╝*/

  /**
  @notice Initializes the contract.
  @dev Calls OpenZeppelin's initializer modifier.
  @param _admin Address of the admin role.
  @param _longShort Address of the LongShort contract, a deployed LongShort.sol
  @param _floatToken Address of the Float token earned by staking.
  @param _floatTreasury Address of the treasury contract for managing fees.
  @param _floatCapital Address of the contract which earns a fixed percentage of Float.
  @param _floatPercentage Determines the float percentage that gets minted for Float Capital, base 1e18.
  */
  function initialize(
    address _admin,
    address _longShort,
    address _floatToken,
    address _floatTreasury,
    address _floatCapital,
    uint256 _floatPercentage
  ) external virtual initializer {
    admin = _admin;
    floatCapital = _floatCapital;
    floatTreasury = _floatTreasury;
    longShort = _longShort;
    floatToken = _floatToken;

    _changeFloatPercentage(_floatPercentage);

    emit StakerV1(_admin, _floatTreasury, _floatCapital, _floatToken, _floatPercentage);
  }

  /*╔═══════════════════╗
    ║       ADMIN       ║
    ╚═══════════════════╝*/

  /** 
  @notice Changes admin for the contract
  @param _admin The address of the new admin.
  */
  function changeAdmin(address _admin) external onlyAdmin {
    admin = _admin;
    emit ChangeAdmin(_admin);
  }

  /// @dev Logic for changeFloatPercentage
  function _changeFloatPercentage(uint256 newFloatPercentage) internal virtual {
    require(newFloatPercentage <= 1e18 && newFloatPercentage > 0); // less than or equal to 100% and greater than 0%
    floatPercentage = newFloatPercentage;
  }

  /**
  @notice Changes percentage of float that is minted for float capital.
  @param newFloatPercentage The new float percentage in base 1e18.
  */
  function changeFloatPercentage(uint256 newFloatPercentage) external onlyAdmin {
    _changeFloatPercentage(newFloatPercentage);
    emit FloatPercentageUpdated(newFloatPercentage);
  }

  /// @dev Logic for changeUnstakeFee
  function _changeUnstakeFee(uint32 marketIndex, uint256 newMarketUnstakeFee_e18) internal virtual {
    require(newMarketUnstakeFee_e18 <= 5e16); // Explicitely stating 5% fee as the max fee possible.
    marketUnstakeFee_e18[marketIndex] = newMarketUnstakeFee_e18;
  }

  /**
  @notice Changes unstake fee for a market
  @param marketIndex Identifies the market.
  @param newMarketUnstakeFee_e18 The new unstake fee.
  */
  function changeUnstakeFee(uint32 marketIndex, uint256 newMarketUnstakeFee_e18) external onlyAdmin {
    _changeUnstakeFee(marketIndex, newMarketUnstakeFee_e18);
    emit StakeWithdrawalFeeUpdated(marketIndex, newMarketUnstakeFee_e18);
  }

  /// @dev Logic for changeMarketLaunchIncentiveParameters
  function _changeMarketLaunchIncentiveParameters(
    uint32 marketIndex,
    uint256 period,
    uint256 initialMultiplier
  ) internal virtual {
    require(initialMultiplier >= 1e18, "marketLaunchIncentiveMultiplier must be >= 1e18");

    marketLaunchIncentive_period[marketIndex] = period;
    marketLaunchIncentive_multipliers[marketIndex] = initialMultiplier;
  }

  /**
  @notice Changes the market launch incentive parameters for a market
  @param marketIndex Identifies the market.
  @param period The new period for which float token generation should be boosted.
  @param initialMultiplier The new multiplier on Float generation.
  */
  function changeMarketLaunchIncentiveParameters(
    uint32 marketIndex,
    uint256 period,
    uint256 initialMultiplier
  ) external onlyAdmin {
    _changeMarketLaunchIncentiveParameters(marketIndex, period, initialMultiplier);

    emit MarketLaunchIncentiveParametersChanges(marketIndex, period, initialMultiplier);
  }

  /// @dev Logic for changeBalanceIncentiveExponent
  function _changeBalanceIncentiveExponent(uint32 marketIndex, uint256 _balanceIncentiveCurve_exponent)
    internal
    virtual
  {
    require(
      // The exponent has to be less than 5 in these versions of the contracts.
      _balanceIncentiveCurve_exponent > 0 && _balanceIncentiveCurve_exponent < 6,
      "balanceIncentiveCurve_exponent out of bounds"
    );

    balanceIncentiveCurve_exponent[marketIndex] = _balanceIncentiveCurve_exponent;
  }

  /** 
  @notice Changes the balance incentive exponent for a market
  @param marketIndex Identifies the market.
  @param _balanceIncentiveCurve_exponent The new exponent for the curve.
  */
  function changeBalanceIncentiveExponent(uint32 marketIndex, uint256 _balanceIncentiveCurve_exponent)
    external
    onlyAdmin
  {
    _changeBalanceIncentiveExponent(marketIndex, _balanceIncentiveCurve_exponent);

    emit BalanceIncentiveExponentUpdated(marketIndex, _balanceIncentiveCurve_exponent);
  }

  /// @dev Logic for changeBalanceIncentiveEquilibriumOffset
  function _changeBalanceIncentiveEquilibriumOffset(uint32 marketIndex, int256 _balanceIncentiveCurve_equilibriumOffset)
    internal
    virtual
  {
    // Unreasonable that we would ever shift this more than 90% either way
    require(
      _balanceIncentiveCurve_equilibriumOffset > -9e17 && _balanceIncentiveCurve_equilibriumOffset < 9e17,
      "balanceIncentiveCurve_equilibriumOffset out of bounds"
    );

    balanceIncentiveCurve_equilibriumOffset[marketIndex] = _balanceIncentiveCurve_equilibriumOffset;
  }

  /**
  @notice Changes the balance incentive curve equilibrium offset for a market
  @param marketIndex Identifies the market.
  @param _balanceIncentiveCurve_equilibriumOffset The new offset.
  */
  function changeBalanceIncentiveEquilibriumOffset(uint32 marketIndex, int256 _balanceIncentiveCurve_equilibriumOffset)
    external
    onlyAdmin
  {
    _changeBalanceIncentiveEquilibriumOffset(marketIndex, _balanceIncentiveCurve_equilibriumOffset);

    emit BalanceIncentiveEquilibriumOffsetUpdated(marketIndex, _balanceIncentiveCurve_equilibriumOffset);
  }

  /*╔═════════════════════════════╗
    ║        STAKING SETUP        ║
    ╚═════════════════════════════╝*/

  /**
  @notice Sets this contract to track staking for a market in LongShort.sol
  @param marketIndex Identifies the market.
  @param longToken Address of the long token for the market.
  @param shortToken Address of the short token for the market.
  @param kInitialMultiplier Initial boost on float generation for the market.
  @param kPeriod Period which the boost should last.
  @param unstakeFee_e18 Percentage of tokens that are levied on unstaking in base 1e18.
  @param _balanceIncentiveCurve_exponent Exponent for balance curve (see _calculateFloatPerSecond)
  @param _balanceIncentiveCurve_equilibriumOffset Offset for balance curve (see _calculateFloatPerSecond)
  */
  function addNewStakingFund(
    uint32 marketIndex,
    address longToken,
    address shortToken,
    uint256 kInitialMultiplier,
    uint256 kPeriod,
    uint256 unstakeFee_e18,
    uint256 _balanceIncentiveCurve_exponent,
    int256 _balanceIncentiveCurve_equilibriumOffset
  ) external override onlyLongShort {
    marketIndexOfToken[longToken] = marketIndex;
    marketIndexOfToken[shortToken] = marketIndex;

    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].timestamp = block.timestamp;
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].accumulativeFloatPerSyntheticToken_long = 0;
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].accumulativeFloatPerSyntheticToken_short = 0;

    syntheticTokens[marketIndex][true] = longToken;
    syntheticTokens[marketIndex][false] = shortToken;

    _changeBalanceIncentiveExponent(marketIndex, _balanceIncentiveCurve_exponent);
    _changeBalanceIncentiveEquilibriumOffset(marketIndex, _balanceIncentiveCurve_equilibriumOffset);
    _changeMarketLaunchIncentiveParameters(marketIndex, kPeriod, kInitialMultiplier);

    _changeUnstakeFee(marketIndex, unstakeFee_e18);

    // Set this value to one initially - 0 is a null value and thus potentially bug prone.
    batched_stakerNextTokenShiftIndex[marketIndex] = 1;

    emit MarketAddedToStaker(
      marketIndex,
      unstakeFee_e18,
      kPeriod,
      kInitialMultiplier,
      _balanceIncentiveCurve_exponent,
      _balanceIncentiveCurve_equilibriumOffset
    );

    emit AccumulativeIssuancePerStakedSynthSnapshotCreated(marketIndex, 0, 0, 0);
  }

  /*╔═════════════════════════════════════════════════════════════════════════╗
    ║    GLOBAL FLT REWARD ACCUMULATION CALCULATION AND TRACKING FUNCTIONS    ║
    ╚═════════════════════════════════════════════════════════════════════════╝*/

  /**
  @notice Returns the K factor parameters for the given market with sensible
  defaults if they haven't been set yet.
  @param marketIndex The market to change the parameters for.
  @return period The period for which the k factor applies for in seconds.
  @return multiplier The multiplier on Float generation in this period.
  */
  function _getMarketLaunchIncentiveParameters(uint32 marketIndex)
    internal
    view
    virtual
    returns (uint256 period, uint256 multiplier)
  {
    period = marketLaunchIncentive_period[marketIndex];
    multiplier = marketLaunchIncentive_multipliers[marketIndex];

    if (multiplier < 1e18) {
      multiplier = 1e18; // multiplier of 1 by default
    }
  }

  /** 
  @notice Returns the extent to which a markets float generation should be adjusted
  based on the market's launch incentive parameters. Should start at multiplier
  then linearly change to 1e18 over time.
  @param marketIndex Identifies the market.
  @return k The calculated modifier for float generation.
  */
  function _getKValue(uint32 marketIndex) internal view virtual returns (uint256) {
    // Parameters controlling the float issuance multiplier.
    (uint256 kPeriod, uint256 kInitialMultiplier) = _getMarketLaunchIncentiveParameters(marketIndex);

    // Sanity check - under normal circumstances, the multipliers should
    // *never* be set to a value < 1e18, as there are guards against this.
    assert(kInitialMultiplier >= 1e18);

    uint256 initialTimestamp = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].timestamp;

    if (block.timestamp - initialTimestamp <= kPeriod) {
      return kInitialMultiplier - (((kInitialMultiplier - 1e18) * (block.timestamp - initialTimestamp)) / kPeriod);
    } else {
      return 1e18;
    }
  }

  /*
  @notice Computes the number of float tokens a user earns per second for
  every long/short synthetic token they've staked. The returned value has
  a fixed decimal scale of 1e42 (!!!) for numerical stability. The return
  values are float per second per synthetic token (hence the requirement
  to multiply by price)
  @dev to see below math in latex form see TODO add link
  to interact with the equations see https://www.desmos.com/calculator/optkaxyihr
  @param marketIndex The market referred to.
  @param longPrice Price of the synthetic long token in units of payment token
  @param shortPrice Price of the synthetic short token in units of payment token
  @param longValue Amount of payment token in the long side of the market
  @param shortValue Amount of payment token in the short side of the market
  @return longFloatPerSecond Float token per second per long synthetic token
  @return shortFloatPerSecond Float token per second per short synthetic token
   */
  function _calculateFloatPerSecond(
    uint32 marketIndex,
    uint256 longPrice,
    uint256 shortPrice,
    uint256 longValue,
    uint256 shortValue
  ) internal view virtual returns (uint256 longFloatPerSecond, uint256 shortFloatPerSecond) {
    // A float issuance multiplier that starts high and decreases linearly
    // over time to a value of 1. This incentivises users to stake early.
    uint256 k = _getKValue(marketIndex);

    uint256 totalLocked = (longValue + shortValue);

    // we need to scale this number by the totalLocked so that the offset remains consistent accross market size

    int256 equilibriumOffsetMarketScaled = (balanceIncentiveCurve_equilibriumOffset[marketIndex] *
      int256(totalLocked)) / 2e18;

    uint256 denominator = ((totalLocked >> safeExponentBitShifting)**balanceIncentiveCurve_exponent[marketIndex]);

    // Float is scaled by the percentage of the total market value held in
    // the opposite position. This incentivises users to stake on the
    // weaker position.
    if (int256(shortValue) - equilibriumOffsetMarketScaled < int256(longValue)) {
      if (equilibriumOffsetMarketScaled >= int256(shortValue)) {
        // edge case: imbalanced far past the equilibrium offset - full rewards go to short token
        //            extremeley unlikely to happen in practice
        return (0, 1e18 * k * shortPrice);
      }

      uint256 numerator = (uint256(int256(shortValue) - equilibriumOffsetMarketScaled) >>
        (safeExponentBitShifting - 1))**balanceIncentiveCurve_exponent[marketIndex];

      // NOTE: `x * 5e17` == `(x * 10e18) / 2`
      uint256 longRewardUnscaled = (numerator * 5e17) / denominator;
      uint256 shortRewardUnscaled = 1e18 - longRewardUnscaled;

      return ((longRewardUnscaled * k * longPrice) / 1e18, (shortRewardUnscaled * k * shortPrice) / 1e18);
    } else {
      if (-equilibriumOffsetMarketScaled >= int256(longValue)) {
        // edge case: imbalanced far past the equilibrium offset - full rewards go to long token
        //            extremeley unlikely to happen in practice
        return (1e18 * k * longPrice, 0);
      }

      uint256 numerator = (uint256(int256(longValue) + equilibriumOffsetMarketScaled) >>
        (safeExponentBitShifting - 1))**balanceIncentiveCurve_exponent[marketIndex];

      // NOTE: `x * 5e17` == `(x * 10e18) / 2`
      uint256 shortRewardUnscaled = (numerator * 5e17) / denominator;
      uint256 longRewardUnscaled = 1e18 - shortRewardUnscaled;

      return ((longRewardUnscaled * k * longPrice) / 1e18, (shortRewardUnscaled * k * shortPrice) / 1e18);
    }
  }

  /**
  @notice Computes the time since last accumulativeIssuancePerStakedSynthSnapshot for the given market in seconds.
  @param marketIndex The market referred to.
  @return The time difference in seconds
  */
  function _calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(uint32 marketIndex)
    internal
    view
    virtual
    returns (uint256)
  {
    return
      block.timestamp -
      accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]].timestamp;
  }

  /**
  @notice Computes new cumulative sum of 'r' value since last accumulativeIssuancePerStakedSynthSnapshot. We use
  cumulative 'r' value to avoid looping during issuance. Note that the
  cumulative sum is kept in 1e42 scale (!!!) to avoid numerical issues.
  @param shortValue The value locked in the short side of the market.
  @param longValue The value locked in the long side of the market.
  @param shortPrice The price of the short token as defined in LongShort.sol
  @param longPrice The price of the long token as defined in LongShort.sol
  @param marketIndex An identifier for the market.
  @return longCumulativeRates The long cumulative sum.
  @return shortCumulativeRates The short cumulative sum.
  */
  function _calculateNewCumulativeIssuancePerStakedSynth(
    uint32 marketIndex,
    uint256 longPrice,
    uint256 shortPrice,
    uint256 longValue,
    uint256 shortValue
  ) internal view virtual returns (uint256 longCumulativeRates, uint256 shortCumulativeRates) {
    // Compute the current 'r' value for float issuance per second.
    (uint256 longFloatPerSecond, uint256 shortFloatPerSecond) = _calculateFloatPerSecond(
      marketIndex,
      longPrice,
      shortPrice,
      longValue,
      shortValue
    );

    // Compute time since last accumulativeIssuancePerStakedSynthSnapshot for the given token.
    uint256 timeDelta = _calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(marketIndex);

    // Compute new cumulative 'r' value total.
    return (
      accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]]
      .accumulativeFloatPerSyntheticToken_long + (timeDelta * longFloatPerSecond),
      accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]]
      .accumulativeFloatPerSyntheticToken_short + (timeDelta * shortFloatPerSecond)
    );
  }

  /**
  @notice Creates a new accumulativeIssuancePerStakedSynthSnapshot for the given token and updates indexes.
  @param shortValue The value locked in the short side of the market.
  @param longValue The value locked in the long side of the market.
  @param shortPrice The price of the short token as defined in LongShort.sol
  @param longPrice The price of the long token as defined in LongShort.sol
  @param marketIndex An identifier for the market.
  */
  function _setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot(
    uint32 marketIndex,
    uint256 longPrice,
    uint256 shortPrice,
    uint256 longValue,
    uint256 shortValue
  ) internal virtual {
    (
      uint256 newLongAccumulativeValue,
      uint256 newShortAccumulativeValue
    ) = _calculateNewCumulativeIssuancePerStakedSynth(marketIndex, longPrice, shortPrice, longValue, shortValue);

    uint256 newIndex = latestRewardIndex[marketIndex] + 1;

    // Set cumulative 'r' value on new accumulativeIssuancePerStakedSynthSnapshot.
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex]
    .accumulativeFloatPerSyntheticToken_long = newLongAccumulativeValue;
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex]
    .accumulativeFloatPerSyntheticToken_short = newShortAccumulativeValue;

    // Set timestamp on new accumulativeIssuancePerStakedSynthSnapshot.
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex].timestamp = block.timestamp;

    // Update latest index to point to new accumulativeIssuancePerStakedSynthSnapshot.
    latestRewardIndex[marketIndex] = newIndex;

    emit AccumulativeIssuancePerStakedSynthSnapshotCreated(
      marketIndex,
      newIndex,
      newLongAccumulativeValue,
      newShortAccumulativeValue
    );
  }

  /**
  @notice Adds new accumulativeIssuancePerStakedSynthSnapshots for the given long/short tokens. Called by the
  ILongShort contract whenever there is a state change for a market.
  @param stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted Mapping from this contract's shifts to LongShort.sols next price snapshots.
  @param shortValue The value locked in the short side of the market.
  @param longValue The value locked in the long side of the market.
  @param shortPrice The price of the short token as defined in LongShort.sol
  @param longPrice The price of the long token as defined in LongShort.sol
  @param marketIndex An identifier for the market.
  */
  function pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(
    uint32 marketIndex,
    uint256 longPrice,
    uint256 shortPrice,
    uint256 longValue,
    uint256 shortValue,
    uint256 stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted // This value should be ALWAYS be zero if no shift occured
  ) external override onlyLongShort {
    // Only add a new accumulativeIssuancePerStakedSynthSnapshot if some time has passed.

    // the `stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted` value will be 0 if there is no staker related action in an executed batch
    if (stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted > 0) {
      stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[
        batched_stakerNextTokenShiftIndex[marketIndex]
      ] = stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted;
      stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[
        batched_stakerNextTokenShiftIndex[marketIndex]
      ] = latestRewardIndex[marketIndex] + 1;
      batched_stakerNextTokenShiftIndex[marketIndex] += 1;

      emit SyntheticTokensShifted();
    }

    // Time delta is fetched twice in below code, can pass through? Which is less gas?
    if (_calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(marketIndex) > 0) {
      _setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot(
        marketIndex,
        longPrice,
        shortPrice,
        longValue,
        shortValue
      );
    }
  }

  /*╔═══════════════════════════════════╗
    ║    USER REWARD STATE FUNCTIONS    ║
    ╚═══════════════════════════════════╝*/

  /// @dev Calculates the accumulated float in a specific range of staker snapshots
  function _calculateAccumulatedFloatInRange(
    uint32 marketIndex,
    uint256 amountStakedLong,
    uint256 amountStakedShort,
    uint256 rewardIndexFrom,
    uint256 rewardIndexTo
  ) internal view virtual returns (uint256 floatReward) {
    if (amountStakedLong > 0) {
      uint256 accumDeltaLong = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexTo]
      .accumulativeFloatPerSyntheticToken_long -
        accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexFrom]
        .accumulativeFloatPerSyntheticToken_long;
      floatReward += (accumDeltaLong * amountStakedLong) / FLOAT_ISSUANCE_FIXED_DECIMAL;
    }

    if (amountStakedShort > 0) {
      uint256 accumDeltaShort = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexTo]
      .accumulativeFloatPerSyntheticToken_short -
        accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexFrom]
        .accumulativeFloatPerSyntheticToken_short;
      floatReward += (accumDeltaShort * amountStakedShort) / FLOAT_ISSUANCE_FIXED_DECIMAL;
    }
  }

  /** 
  @notice Calculates float owed to the user since the user last minted float for a market.
  @param marketIndex Identifier for the market which the user staked in.
  @param user The address of the user.
  @return floatReward The amount of float owed.
   */
  function _calculateAccumulatedFloat(uint32 marketIndex, address user) internal virtual returns (uint256 floatReward) {
    address longToken = syntheticTokens[marketIndex][true];
    address shortToken = syntheticTokens[marketIndex][false];

    uint256 amountStakedLong = userAmountStaked[longToken][user];
    uint256 amountStakedShort = userAmountStaked[shortToken][user];

    uint256 usersLastRewardIndex = userIndexOfLastClaimedReward[marketIndex][user];

    // Don't do the calculation and return zero immediately if there is no change
    if (usersLastRewardIndex == latestRewardIndex[marketIndex]) {
      return 0;
    }

    uint256 usersShiftIndex = userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][user];
    // if there is a change in the users tokens held due to a token shift (or possibly another action in the future)
    if (usersShiftIndex > 0 && usersShiftIndex < batched_stakerNextTokenShiftIndex[marketIndex]) {
      floatReward = _calculateAccumulatedFloatInRange(
        marketIndex,
        amountStakedLong,
        amountStakedShort,
        usersLastRewardIndex,
        stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[usersShiftIndex]
      );

      // Update the users balances
      if (userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user] > 0) {
        amountStakedShort += ILongShort(longShort).getAmountSyntheticTokenToMintOnTargetSide(
          marketIndex,
          userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user],
          true,
          stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[usersShiftIndex]
        );

        amountStakedLong -= userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user];
        userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user] = 0;
      }

      if (userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user] > 0) {
        amountStakedLong += ILongShort(longShort).getAmountSyntheticTokenToMintOnTargetSide(
          marketIndex,
          userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user],
          false,
          stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[usersShiftIndex]
        );

        amountStakedShort -= userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user];
        userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user] = 0;
      }

      // Save the users updated staked amounts
      userAmountStaked[longToken][user] = amountStakedLong;
      userAmountStaked[shortToken][user] = amountStakedShort;

      floatReward += _calculateAccumulatedFloatInRange(
        marketIndex,
        amountStakedLong,
        amountStakedShort,
        stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[usersShiftIndex],
        latestRewardIndex[marketIndex]
      );

      userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][user] = 0;
    } else {
      floatReward = _calculateAccumulatedFloatInRange(
        marketIndex,
        amountStakedLong,
        amountStakedShort,
        usersLastRewardIndex,
        latestRewardIndex[marketIndex]
      );
    }
  }

  /**
  @notice Mints float for a user.
  @dev Mints a fixed percentage for Float capital.
  @param user The address of the user.
  @param floatToMint The amount of float to mint.
   */
  function _mintFloat(address user, uint256 floatToMint) internal virtual {
    IFloatToken(floatToken).mint(user, floatToMint);
    IFloatToken(floatToken).mint(floatCapital, (floatToMint * floatPercentage) / 1e18);
  }

  /**
  @notice Mints float owed to a user for a market since they last minted.
  @param marketIndex An identifier for the market.
  @param user The address of the user.
   */
  function _mintAccumulatedFloat(uint32 marketIndex, address user) internal virtual {
    uint256 floatToMint = _calculateAccumulatedFloat(marketIndex, user);

    if (floatToMint > 0) {
      // Set the user has claimed up until now, stops them setting this forward
      userIndexOfLastClaimedReward[marketIndex][user] = latestRewardIndex[marketIndex];

      _mintFloat(user, floatToMint);
      emit FloatMinted(user, marketIndex, floatToMint);
    }
  }

  /**
  @notice Mints float owed to a user for multiple markets, since they last minted for those markets.
  @param marketIndexes Identifiers for the markets.
  @param user The address of the user.
   */
  function _mintAccumulatedFloatMulti(uint32[] calldata marketIndexes, address user) internal virtual {
    uint256 floatTotal = 0;
    for (uint256 i = 0; i < marketIndexes.length; i++) {
      uint256 floatToMint = _calculateAccumulatedFloat(marketIndexes[i], user);

      if (floatToMint > 0) {
        // Set the user has claimed up until now, stops them setting this forward
        userIndexOfLastClaimedReward[marketIndexes[i]][user] = latestRewardIndex[marketIndexes[i]];

        floatTotal += floatToMint;

        emit FloatMinted(user, marketIndexes[i], floatToMint);
      }
    }
    if (floatTotal > 0) {
      _mintFloat(user, floatTotal);
    }
  }

  /**
  @notice Mints outstanding float for msg.sender.
  @param marketIndexes Identifiers for the markets for which to mint float.
   */
  function claimFloatCustom(uint32[] calldata marketIndexes) external {
    ILongShort(longShort).updateSystemStateMulti(marketIndexes);
    _mintAccumulatedFloatMulti(marketIndexes, msg.sender);
  }

  /**
  @notice Mints outstanding float on behalf of another user.
  @param marketIndexes Identifiers for the markets for which to mint float.
  @param user The address of the user.
   */
  function claimFloatCustomFor(uint32[] calldata marketIndexes, address user) external {
    // Unbounded loop - users are responsible for paying their own gas costs on these and it doesn't effect the rest of the system.
    // No need to impose limit.
    ILongShort(longShort).updateSystemStateMulti(marketIndexes);
    _mintAccumulatedFloatMulti(marketIndexes, user);
  }

  /*╔═══════════════════════╗
    ║        STAKING        ║
    ╚═══════════════════════╝*/

  /**
  @notice A user with synthetic tokens stakes by calling stake on the token
  contract which calls this function. We need to first update the
  state of the LongShort contract for this market before staking to correctly calculate user rewards.
  @param amount Amount to stake.
  @param from Address to stake for.
  */
  function stakeFromUser(address from, uint256 amount) public virtual override onlyValidSynthetic((msg.sender)) {
    ILongShort(longShort).updateSystemState(marketIndexOfToken[(msg.sender)]);
    _stake((msg.sender), amount, from);
  }

  /**
  @dev Internal logic for staking.
  @param token Address of the token for which to stake.
  @param amount Amount to stake.
  @param user Address to stake for.
  */
  function _stake(
    address token,
    uint256 amount,
    address user
  ) internal virtual {
    uint32 marketIndex = marketIndexOfToken[token];

    // If they already have staked and have rewards due, mint these.
    if (
      userIndexOfLastClaimedReward[marketIndex][user] != 0 &&
      userIndexOfLastClaimedReward[marketIndex][user] < latestRewardIndex[marketIndex]
    ) {
      _mintAccumulatedFloat(marketIndex, user);
    }

    userAmountStaked[token][user] = userAmountStaked[token][user] + amount;

    userIndexOfLastClaimedReward[marketIndex][user] = latestRewardIndex[marketIndex];

    emit StakeAdded(user, address(token), amount, userIndexOfLastClaimedReward[marketIndex][user]);
  }

  /**
  @notice Allows users to shift their staked tokens from one side of the market to 
  the other at the next price.
  @param amountSyntheticTokensToShift Amount of tokens to shift.
  @param marketIndex Identifier for the market.
  @param isShiftFromLong Whether the shift is from long to short or short to long.
  */
  function shiftTokens(
    uint256 amountSyntheticTokensToShift,
    uint32 marketIndex,
    bool isShiftFromLong
  ) external virtual {
    address token = syntheticTokens[marketIndex][isShiftFromLong];
    require(userAmountStaked[token][msg.sender] >= amountSyntheticTokensToShift, "Not enough tokens to shift");

    // If the user has outstanding token shift that have already been confirmed in the LongShort
    // contract, execute them first.
    if (
      userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] != 0 &&
      userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] <
      batched_stakerNextTokenShiftIndex[marketIndex]
    ) {
      _mintAccumulatedFloat(marketIndex, msg.sender);
    }

    if (isShiftFromLong) {
      ILongShort(longShort).shiftPositionFromLongNextPrice(marketIndex, amountSyntheticTokensToShift);
      userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][
        msg.sender
      ] += amountSyntheticTokensToShift;
    } else {
      ILongShort(longShort).shiftPositionFromShortNextPrice(marketIndex, amountSyntheticTokensToShift);
      userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][
        msg.sender
      ] += amountSyntheticTokensToShift;
    }

    userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] = batched_stakerNextTokenShiftIndex[
      marketIndex
    ];
  }

  /*╔════════════════════════════╗
    ║    WITHDRAWAL & MINTING    ║
    ╚════════════════════════════╝*/

  /**
  @notice Internal logic for withdrawing stakes.
  @dev Mint user any outstanding float before withdrawing.
  @param marketIndex Market index of token.
  @param amount Amount to withdraw.
  @param token Synthetic token that was staked.
  */
  function _withdraw(
    uint32 marketIndex,
    address token,
    uint256 amount
  ) internal virtual {
    require(userAmountStaked[token][msg.sender] > 0, "nothing to withdraw");
    _mintAccumulatedFloat(marketIndex, msg.sender);

    userAmountStaked[token][msg.sender] = userAmountStaked[token][msg.sender] - amount;

    uint256 amountFees = (amount * marketUnstakeFee_e18[marketIndex]) / 1e18;

    IERC20(token).transfer(floatTreasury, amountFees);
    IERC20(token).transfer(msg.sender, amount - amountFees);

    emit StakeWithdrawn(msg.sender, token, amount);
  }

  /**
  @notice Withdraw function. Allows users to unstake.
  @param amount Amount to withdraw.
  @param token Address of the token for which to withdraw.
  */
  function withdraw(address token, uint256 amount) external {
    ILongShort(longShort).updateSystemState(marketIndexOfToken[token]);

    uint32 marketIndex = marketIndexOfToken[token];

    _withdraw(marketIndex, token, amount);

    if (userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] > 0) {
      // If they still have outstanding shifts after minting float, then check
      // that they don't withdraw more than their shifts allow.
      uint256 amountToShiftForThisToken = syntheticTokens[marketIndex][true] == token
        ? userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][msg.sender]
        : userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][msg.sender];

      require(
        userAmountStaked[token][msg.sender] >= amountToShiftForThisToken,
        "Outstanding next price stake shifts too great"
      );
    }
  }

  /**
  @notice Allows users to withdraw their entire stake for a token.
  @param token Address of the token for which to withdraw.
  */
  function withdrawAll(address token) external {
    ILongShort(longShort).updateSystemState(marketIndexOfToken[token]);

    uint32 marketIndex = marketIndexOfToken[token];

    uint256 amountToShiftForThisToken = syntheticTokens[marketIndex][true] == token
      ? userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][msg.sender]
      : userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][msg.sender];

    _withdraw(marketIndex, token, userAmountStaked[token][msg.sender] - amountToShiftForThisToken);
  }
}


**project_name**: RealWorld_BA_22_Staker

**Log File**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/WareHouse/RealWorld_BA_22_Staker_RealWord_20240817080116.log

**ChatDevConfig**:
ChatEnvConfig.with_memory: False
ChatEnvConfig.clear_structure: True
ChatEnvConfig.git_management: False
ChatEnvConfig.gui_design: True
ChatEnvConfig.incremental_develop: False
ChatEnvConfig.background_prompt: We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.


**ChatGPTConfig**:
ChatGPTConfig(temperature=0.2, top_p=1.0, n=1, stream=False, stop=None, max_tokens=None, presence_penalty=0.0, frequency_penalty=0.0, logit_bias={}, user='')



[2024-17-08 08:01:17 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: BUSL-1.1 pragma solidity 0.8.3; import "@openzeppelin/contracts-upgradeable/token/ERC20/presets/ERC20PresetMinterPauserUpgradeable.sol"; import "./interfaces/IFloatToken.sol"; import "./interfaces/ILongShort.sol"; import "./interfaces/IStaker.sol"; import "./interfaces/ISyntheticToken.sol"; contract Staker is IStaker, Initializable {   /╔═════════════════════════════╗     ║          VARIABLES          ║     ╚═════════════════════════════╝/ / ══════ Fixed-precision constants ══════ /   uint256 public constant FLOAT_ISSUANCE_FIXED_DECIMAL = 1e42;   // 2^52 ~= 4.5e15   // With an exponent of 5, the largest total liquidity possible in a market (to avoid integer overflow on exponentiation) is ~10^31 or 10 Trillion (10^13)   // NOTE: this also means if the total market value is less than 2^52 there will be a division by zero error   uint256 public constant safeExponentBitShifting = 52; / ══════ Global state ══════ /   address public admin;   address public floatCapital;   address public floatTreasury;   uint256 public floatPercentage; address public longShort;   address public floatToken; / ══════ Market specific ══════ /   mapping(uint32 =&gt; uint256) public marketLaunchIncentive_period; // seconds   mapping(uint32 =&gt; uint256) public marketLaunchIncentive_multipliers; // e18 scale   mapping(uint32 =&gt; uint256) public marketUnstakeFee_e18;   mapping(uint32 =&gt; uint256) public balanceIncentiveCurve_exponent;   mapping(uint32 =&gt; int256) public balanceIncentiveCurve_equilibriumOffset; mapping(uint32 =&gt; mapping(bool =&gt; address)) public syntheticTokens; mapping(address =&gt; uint32) public marketIndexOfToken; / ══════ Reward specific ══════ /   mapping(uint32 =&gt; uint256) public latestRewardIndex;   mapping(uint32 =&gt; mapping(uint256 =&gt; AccumulativeIssuancePerStakedSynthSnapshot))     public accumulativeFloatPerSyntheticTokenSnapshots;   struct AccumulativeIssuancePerStakedSynthSnapshot {     uint256 timestamp;     uint256 accumulativeFloatPerSyntheticToken_long;     uint256 accumulativeFloatPerSyntheticToken_short;   } / ══════ User specific ══════ /   mapping(uint32 =&gt; mapping(address =&gt; uint256)) public userIndexOfLastClaimedReward;   mapping(address =&gt; mapping(address =&gt; uint256)) public userAmountStaked; / ══════ Token shift management specific ══════ /   mapping(uint32 =&gt; uint256) public batched_stakerNextTokenShiftIndex;   /*   @notice Used to link a token shift to a staker state   @dev tokenShiftIndex =&gt; accumulativeFloatIssuanceSnapshotIndex     POSSIBLE OPTIMIZATION - could pack stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping and stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping into a struct of two uint128 for storage space optimization.   /   mapping(uint256 =&gt; uint256) public stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping;   /// @notice Used to fetch the price from LongShort at that point in time   /// @dev tokenShiftIndex =&gt; longShortMarketPriceSnapshotIndex   mapping(uint256 =&gt; uint256) public stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping;   /// @dev marketIndex =&gt; usersAddress =&gt; stakerTokenShiftIndex   mapping(uint32 =&gt; mapping(address =&gt; uint256)) public userNextPrice_stakedSyntheticTokenShiftIndex;   /// @dev marketIndex =&gt; usersAddress =&gt; amountUserRequestedToShiftAwayFromLongOnNextUpdate   mapping(uint32 =&gt; mapping(address =&gt; uint256)) public userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long;   /// @dev marketIndex =&gt; usersAddress =&gt; amountUserRequestedToShiftAwayFromShortOnNextUpdate   mapping(uint32 =&gt; mapping(address =&gt; uint256)) public userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short; /╔════════════════════════════╗     ║           EVENTS           ║     ╚════════════════════════════╝/ event StakerV1(     address admin,     address floatTreasury,     address floatCapital,     address floatToken,     uint256 floatPercentage   ); event MarketAddedToStaker(     uint32 marketIndex,     uint256 exitFee_e18,     uint256 period,     uint256 multiplier,     uint256 balanceIncentiveExponent,     int256 balanceIncentiveEquilibriumOffset   ); event AccumulativeIssuancePerStakedSynthSnapshotCreated(     uint32 marketIndex,     uint256 accumulativeFloatIssuanceSnapshotIndex,     uint256 accumulativeLong,     uint256 accumulativeShort   ); event StakeAdded(address user, address token, uint256 amount, uint256 lastMintIndex); event StakeWithdrawn(address user, address token, uint256 amount); // Note: the amountFloatMinted isn't strictly needed by the graph, but it is good to add it to validate calculations are accurate.   event FloatMinted(address user, uint32 marketIndex, uint256 amountFloatMinted); event MarketLaunchIncentiveParametersChanges(uint32 marketIndex, uint256 period, uint256 multiplier); event StakeWithdrawalFeeUpdated(uint32 marketIndex, uint256 stakeWithdralFee); event BalanceIncentiveExponentUpdated(uint32 marketIndex, uint256 balanceIncentiveExponent); event BalanceIncentiveEquilibriumOffsetUpdated(uint32 marketIndex, int256 balanceIncentiveEquilibriumOffset); event FloatPercentageUpdated(uint256 floatPercentage); event SyntheticTokensShifted(); event ChangeAdmin(address newAdmin); /╔═════════════════════════════╗     ║          MODIFIERS          ║     ╚═════════════════════════════╝/ function onlyAdminModifierLogic() internal virtual {     require(msg.sender == admin, "not admin");   } modifier onlyAdmin() {     onlyAdminModifierLogic();     _;   } function onlyValidSyntheticModifierLogic(address _synth) internal virtual {     require(marketIndexOfToken[_synth] != 0, "not valid synth");   } modifier onlyValidSynthetic(address synth) {     onlyValidSyntheticModifierLogic(_synth);     ;   } function onlyValidMarketModifierLogic(uint32 marketIndex) internal virtual {     require(address(syntheticTokens[marketIndex][true]) != address(0), "not valid market");   } modifier onlyValidMarket(uint32 marketIndex) {     onlyValidMarketModifierLogic(marketIndex);     _;   } function onlyLongShortModifierLogic() internal virtual {     require(msg.sender == address(longShort), "not long short");   } modifier onlyLongShort() {     onlyLongShortModifierLogic();     _;   } /╔═════════════════════════════╗     ║       CONTRACT SET-UP       ║     ╚═════════════════════════════╝/ /*   @notice Initializes the contract.   @dev Calls OpenZeppelin's initializer modifier.   @param _admin Address of the admin role.   @param _longShort Address of the LongShort contract, a deployed LongShort.sol   @param _floatToken Address of the Float token earned by staking.   @param _floatTreasury Address of the treasury contract for managing fees.   @param _floatCapital Address of the contract which earns a fixed percentage of Float.   @param _floatPercentage Determines the float percentage that gets minted for Float Capital, base 1e18.   /   function initialize(     address _admin,     address _longShort,     address _floatToken,     address _floatTreasury,     address _floatCapital,     uint256 _floatPercentage   ) external virtual initializer {     admin = _admin;     floatCapital = _floatCapital;     floatTreasury = _floatTreasury;     longShort = _longShort;     floatToken = _floatToken; _changeFloatPercentage(_floatPercentage);  emit StakerV1(_admin, _floatTreasury, _floatCapital, _floatToken, _floatPercentage);  } /╔═══════════════════╗     ║       ADMIN       ║     ╚═══════════════════╝/ /*    @notice Changes admin for the contract   @param _admin The address of the new admin.   /   function changeAdmin(address _admin) external onlyAdmin {     admin = _admin;     emit ChangeAdmin(_admin);   } /// @dev Logic for changeFloatPercentage   function _changeFloatPercentage(uint256 newFloatPercentage) internal virtual {     require(newFloatPercentage &lt;= 1e18 &amp;&amp; newFloatPercentage &gt; 0); // less than or equal to 100% and greater than 0%     floatPercentage = newFloatPercentage;   } /*   @notice Changes percentage of float that is minted for float capital.   @param newFloatPercentage The new float percentage in base 1e18.   /   function changeFloatPercentage(uint256 newFloatPercentage) external onlyAdmin {     _changeFloatPercentage(newFloatPercentage);     emit FloatPercentageUpdated(newFloatPercentage);   } /// @dev Logic for changeUnstakeFee   function _changeUnstakeFee(uint32 marketIndex, uint256 newMarketUnstakeFee_e18) internal virtual {     require(newMarketUnstakeFee_e18 &lt;= 5e16); // Explicitely stating 5% fee as the max fee possible.     marketUnstakeFee_e18[marketIndex] = newMarketUnstakeFee_e18;   } /*   @notice Changes unstake fee for a market   @param marketIndex Identifies the market.   @param newMarketUnstakeFee_e18 The new unstake fee.   /   function changeUnstakeFee(uint32 marketIndex, uint256 newMarketUnstakeFee_e18) external onlyAdmin {     _changeUnstakeFee(marketIndex, newMarketUnstakeFee_e18);     emit StakeWithdrawalFeeUpdated(marketIndex, newMarketUnstakeFee_e18);   } /// @dev Logic for changeMarketLaunchIncentiveParameters   function _changeMarketLaunchIncentiveParameters(     uint32 marketIndex,     uint256 period,     uint256 initialMultiplier   ) internal virtual {     require(initialMultiplier &gt;= 1e18, "marketLaunchIncentiveMultiplier must be &gt;= 1e18"); marketLaunchIncentive_period[marketIndex] = period; marketLaunchIncentive_multipliers[marketIndex] = initialMultiplier;  } /*   @notice Changes the market launch incentive parameters for a market   @param marketIndex Identifies the market.   @param period The new period for which float token generation should be boosted.   @param initialMultiplier The new multiplier on Float generation.   /   function changeMarketLaunchIncentiveParameters(     uint32 marketIndex,     uint256 period,     uint256 initialMultiplier   ) external onlyAdmin {     _changeMarketLaunchIncentiveParameters(marketIndex, period, initialMultiplier); emit MarketLaunchIncentiveParametersChanges(marketIndex, period, initialMultiplier);  } /// @dev Logic for changeBalanceIncentiveExponent   function _changeBalanceIncentiveExponent(uint32 marketIndex, uint256 _balanceIncentiveCurve_exponent)     internal     virtual   {     require(       // The exponent has to be less than 5 in these versions of the contracts.       _balanceIncentiveCurve_exponent &gt; 0 &amp;&amp; _balanceIncentiveCurve_exponent &lt; 6,       "balanceIncentiveCurve_exponent out of bounds"     ); balanceIncentiveCurve_exponent[marketIndex] = _balanceIncentiveCurve_exponent;  } /*    @notice Changes the balance incentive exponent for a market   @param marketIndex Identifies the market.   @param _balanceIncentiveCurve_exponent The new exponent for the curve.   /   function changeBalanceIncentiveExponent(uint32 marketIndex, uint256 _balanceIncentiveCurve_exponent)     external     onlyAdmin   {     _changeBalanceIncentiveExponent(marketIndex, _balanceIncentiveCurve_exponent); emit BalanceIncentiveExponentUpdated(marketIndex, _balanceIncentiveCurve_exponent);  } /// @dev Logic for changeBalanceIncentiveEquilibriumOffset   function _changeBalanceIncentiveEquilibriumOffset(uint32 marketIndex, int256 _balanceIncentiveCurve_equilibriumOffset)     internal     virtual   {     // Unreasonable that we would ever shift this more than 90% either way     require(       _balanceIncentiveCurve_equilibriumOffset &gt; -9e17 &amp;&amp; _balanceIncentiveCurve_equilibriumOffset &lt; 9e17,       "balanceIncentiveCurve_equilibriumOffset out of bounds"     ); balanceIncentiveCurve_equilibriumOffset[marketIndex] = _balanceIncentiveCurve_equilibriumOffset;  } /*   @notice Changes the balance incentive curve equilibrium offset for a market   @param marketIndex Identifies the market.   @param _balanceIncentiveCurve_equilibriumOffset The new offset.   /   function changeBalanceIncentiveEquilibriumOffset(uint32 marketIndex, int256 _balanceIncentiveCurve_equilibriumOffset)     external     onlyAdmin   {     _changeBalanceIncentiveEquilibriumOffset(marketIndex, _balanceIncentiveCurve_equilibriumOffset); emit BalanceIncentiveEquilibriumOffsetUpdated(marketIndex, _balanceIncentiveCurve_equilibriumOffset);  } /╔═════════════════════════════╗     ║        STAKING SETUP        ║     ╚═════════════════════════════╝/ /*   @notice Sets this contract to track staking for a market in LongShort.sol   @param marketIndex Identifies the market.   @param longToken Address of the long token for the market.   @param shortToken Address of the short token for the market.   @param kInitialMultiplier Initial boost on float generation for the market.   @param kPeriod Period which the boost should last.   @param unstakeFee_e18 Percentage of tokens that are levied on unstaking in base 1e18.   @param _balanceIncentiveCurve_exponent Exponent for balance curve (see _calculateFloatPerSecond)   @param _balanceIncentiveCurve_equilibriumOffset Offset for balance curve (see _calculateFloatPerSecond)   /   function addNewStakingFund(     uint32 marketIndex,     address longToken,     address shortToken,     uint256 kInitialMultiplier,     uint256 kPeriod,     uint256 unstakeFee_e18,     uint256 _balanceIncentiveCurve_exponent,     int256 _balanceIncentiveCurve_equilibriumOffset   ) external override onlyLongShort {     marketIndexOfToken[longToken] = marketIndex;     marketIndexOfToken[shortToken] = marketIndex; accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].timestamp = block.timestamp; accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].accumulativeFloatPerSyntheticToken_long = 0; accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].accumulativeFloatPerSyntheticToken_short = 0;  syntheticTokens[marketIndex][true] = longToken; syntheticTokens[marketIndex][false] = shortToken;  _changeBalanceIncentiveExponent(marketIndex, _balanceIncentiveCurve_exponent); _changeBalanceIncentiveEquilibriumOffset(marketIndex, _balanceIncentiveCurve_equilibriumOffset); _changeMarketLaunchIncentiveParameters(marketIndex, kPeriod, kInitialMultiplier);  _changeUnstakeFee(marketIndex, unstakeFee_e18);  // Set this value to one initially - 0 is a null value and thus potentially bug prone. batched_stakerNextTokenShiftIndex[marketIndex] = 1;  emit MarketAddedToStaker(   marketIndex,   unstakeFee_e18,   kPeriod,   kInitialMultiplier,   _balanceIncentiveCurve_exponent,   _balanceIncentiveCurve_equilibriumOffset );  emit AccumulativeIssuancePerStakedSynthSnapshotCreated(marketIndex, 0, 0, 0);  } /╔═════════════════════════════════════════════════════════════════════════╗     ║    GLOBAL FLT REWARD ACCUMULATION CALCULATION AND TRACKING FUNCTIONS    ║     ╚═════════════════════════════════════════════════════════════════════════╝/ /*   @notice Returns the K factor parameters for the given market with sensible   defaults if they haven't been set yet.   @param marketIndex The market to change the parameters for.   @return period The period for which the k factor applies for in seconds.   @return multiplier The multiplier on Float generation in this period.   /   function _getMarketLaunchIncentiveParameters(uint32 marketIndex)     internal     view     virtual     returns (uint256 period, uint256 multiplier)   {     period = marketLaunchIncentive_period[marketIndex];     multiplier = marketLaunchIncentive_multipliers[marketIndex]; if (multiplier &lt; 1e18) {   multiplier = 1e18; // multiplier of 1 by default }  } /*    @notice Returns the extent to which a markets float generation should be adjusted   based on the market's launch incentive parameters. Should start at multiplier   then linearly change to 1e18 over time.   @param marketIndex Identifies the market.   @return k The calculated modifier for float generation.   /   function _getKValue(uint32 marketIndex) internal view virtual returns (uint256) {     // Parameters controlling the float issuance multiplier.     (uint256 kPeriod, uint256 kInitialMultiplier) = _getMarketLaunchIncentiveParameters(marketIndex); // Sanity check - under normal circumstances, the multipliers should // *never* be set to a value &lt; 1e18, as there are guards against this. assert(kInitialMultiplier &gt;= 1e18);  uint256 initialTimestamp = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].timestamp;  if (block.timestamp - initialTimestamp &lt;= kPeriod) {   return kInitialMultiplier - (((kInitialMultiplier - 1e18) * (block.timestamp - initialTimestamp)) / kPeriod); } else {   return 1e18; }  } /   @notice Computes the number of float tokens a user earns per second for   every long/short synthetic token they've staked. The returned value has   a fixed decimal scale of 1e42 (!!!) for numerical stability. The return   values are float per second per synthetic token (hence the requirement   to multiply by price)   @dev to see below math in latex form see TODO add link   to interact with the equations see https://www.desmos.com/calculator/optkaxyihr   @param marketIndex The market referred to.   @param longPrice Price of the synthetic long token in units of payment token   @param shortPrice Price of the synthetic short token in units of payment token   @param longValue Amount of payment token in the long side of the market   @param shortValue Amount of payment token in the short side of the market   @return longFloatPerSecond Float token per second per long synthetic token   @return shortFloatPerSecond Float token per second per short synthetic token    /   function _calculateFloatPerSecond(     uint32 marketIndex,     uint256 longPrice,     uint256 shortPrice,     uint256 longValue,     uint256 shortValue   ) internal view virtual returns (uint256 longFloatPerSecond, uint256 shortFloatPerSecond) {     // A float issuance multiplier that starts high and decreases linearly     // over time to a value of 1. This incentivises users to stake early.     uint256 k = _getKValue(marketIndex); uint256 totalLocked = (longValue + shortValue);  // we need to scale this number by the totalLocked so that the offset remains consistent accross market size  int256 equilibriumOffsetMarketScaled = (balanceIncentiveCurve_equilibriumOffset[marketIndex] *   int256(totalLocked)) / 2e18;  uint256 denominator = ((totalLocked &gt;&gt; safeExponentBitShifting)**balanceIncentiveCurve_exponent[marketIndex]);  // Float is scaled by the percentage of the total market value held in // the opposite position. This incentivises users to stake on the // weaker position. if (int256(shortValue) - equilibriumOffsetMarketScaled &lt; int256(longValue)) {   if (equilibriumOffsetMarketScaled &gt;= int256(shortValue)) {     // edge case: imbalanced far past the equilibrium offset - full rewards go to short token     //            extremeley unlikely to happen in practice     return (0, 1e18 * k * shortPrice);   }    uint256 numerator = (uint256(int256(shortValue) - equilibriumOffsetMarketScaled) &gt;&gt;     (safeExponentBitShifting - 1))**balanceIncentiveCurve_exponent[marketIndex];    // NOTE: `x * 5e17` == `(x * 10e18) / 2`   uint256 longRewardUnscaled = (numerator * 5e17) / denominator;   uint256 shortRewardUnscaled = 1e18 - longRewardUnscaled;    return ((longRewardUnscaled * k * longPrice) / 1e18, (shortRewardUnscaled * k * shortPrice) / 1e18); } else {   if (-equilibriumOffsetMarketScaled &gt;= int256(longValue)) {     // edge case: imbalanced far past the equilibrium offset - full rewards go to long token     //            extremeley unlikely to happen in practice     return (1e18 * k * longPrice, 0);   }    uint256 numerator = (uint256(int256(longValue) + equilibriumOffsetMarketScaled) &gt;&gt;     (safeExponentBitShifting - 1))**balanceIncentiveCurve_exponent[marketIndex];    // NOTE: `x * 5e17` == `(x * 10e18) / 2`   uint256 shortRewardUnscaled = (numerator * 5e17) / denominator;   uint256 longRewardUnscaled = 1e18 - shortRewardUnscaled;    return ((longRewardUnscaled * k * longPrice) / 1e18, (shortRewardUnscaled * k * shortPrice) / 1e18); }  } /*   @notice Computes the time since last accumulativeIssuancePerStakedSynthSnapshot for the given market in seconds.   @param marketIndex The market referred to.   @return The time difference in seconds   /   function _calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(uint32 marketIndex)     internal     view     virtual     returns (uint256)   {     return       block.timestamp -       accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]].timestamp;   } /*   @notice Computes new cumulative sum of 'r' value since last accumulativeIssuancePerStakedSynthSnapshot. We use   cumulative 'r' value to avoid looping during issuance. Note that the   cumulative sum is kept in 1e42 scale (!!!) to avoid numerical issues.   @param shortValue The value locked in the short side of the market.   @param longValue The value locked in the long side of the market.   @param shortPrice The price of the short token as defined in LongShort.sol   @param longPrice The price of the long token as defined in LongShort.sol   @param marketIndex An identifier for the market.   @return longCumulativeRates The long cumulative sum.   @return shortCumulativeRates The short cumulative sum.   /   function _calculateNewCumulativeIssuancePerStakedSynth(     uint32 marketIndex,     uint256 longPrice,     uint256 shortPrice,     uint256 longValue,     uint256 shortValue   ) internal view virtual returns (uint256 longCumulativeRates, uint256 shortCumulativeRates) {     // Compute the current 'r' value for float issuance per second.     (uint256 longFloatPerSecond, uint256 shortFloatPerSecond) = _calculateFloatPerSecond(       marketIndex,       longPrice,       shortPrice,       longValue,       shortValue     ); // Compute time since last accumulativeIssuancePerStakedSynthSnapshot for the given token. uint256 timeDelta = _calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(marketIndex);  // Compute new cumulative 'r' value total. return (   accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]]   .accumulativeFloatPerSyntheticToken_long + (timeDelta * longFloatPerSecond),   accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]]   .accumulativeFloatPerSyntheticToken_short + (timeDelta * shortFloatPerSecond) );  } /*   @notice Creates a new accumulativeIssuancePerStakedSynthSnapshot for the given token and updates indexes.   @param shortValue The value locked in the short side of the market.   @param longValue The value locked in the long side of the market.   @param shortPrice The price of the short token as defined in LongShort.sol   @param longPrice The price of the long token as defined in LongShort.sol   @param marketIndex An identifier for the market.   /   function _setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot(     uint32 marketIndex,     uint256 longPrice,     uint256 shortPrice,     uint256 longValue,     uint256 shortValue   ) internal virtual {     (       uint256 newLongAccumulativeValue,       uint256 newShortAccumulativeValue     ) = _calculateNewCumulativeIssuancePerStakedSynth(marketIndex, longPrice, shortPrice, longValue, shortValue); uint256 newIndex = latestRewardIndex[marketIndex] + 1;  // Set cumulative 'r' value on new accumulativeIssuancePerStakedSynthSnapshot. accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex] .accumulativeFloatPerSyntheticToken_long = newLongAccumulativeValue; accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex] .accumulativeFloatPerSyntheticToken_short = newShortAccumulativeValue;  // Set timestamp on new accumulativeIssuancePerStakedSynthSnapshot. accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex].timestamp = block.timestamp;  // Update latest index to point to new accumulativeIssuancePerStakedSynthSnapshot. latestRewardIndex[marketIndex] = newIndex;  emit AccumulativeIssuancePerStakedSynthSnapshotCreated(   marketIndex,   newIndex,   newLongAccumulativeValue,   newShortAccumulativeValue );  } /*   @notice Adds new accumulativeIssuancePerStakedSynthSnapshots for the given long/short tokens. Called by the   ILongShort contract whenever there is a state change for a market.   @param stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted Mapping from this contract's shifts to LongShort.sols next price snapshots.   @param shortValue The value locked in the short side of the market.   @param longValue The value locked in the long side of the market.   @param shortPrice The price of the short token as defined in LongShort.sol   @param longPrice The price of the long token as defined in LongShort.sol   @param marketIndex An identifier for the market.   /   function pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(     uint32 marketIndex,     uint256 longPrice,     uint256 shortPrice,     uint256 longValue,     uint256 shortValue,     uint256 stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted // This value should be ALWAYS be zero if no shift occured   ) external override onlyLongShort {     // Only add a new accumulativeIssuancePerStakedSynthSnapshot if some time has passed. // the `stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted` value will be 0 if there is no staker related action in an executed batch if (stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted &gt; 0) {   stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[     batched_stakerNextTokenShiftIndex[marketIndex]   ] = stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted;   stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[     batched_stakerNextTokenShiftIndex[marketIndex]   ] = latestRewardIndex[marketIndex] + 1;   batched_stakerNextTokenShiftIndex[marketIndex] += 1;    emit SyntheticTokensShifted(); }  // Time delta is fetched twice in below code, can pass through? Which is less gas? if (_calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(marketIndex) &gt; 0) {   _setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot(     marketIndex,     longPrice,     shortPrice,     longValue,     shortValue   ); }  } /╔═══════════════════════════════════╗     ║    USER REWARD STATE FUNCTIONS    ║     ╚═══════════════════════════════════╝/ /// @dev Calculates the accumulated float in a specific range of staker snapshots   function _calculateAccumulatedFloatInRange(     uint32 marketIndex,     uint256 amountStakedLong,     uint256 amountStakedShort,     uint256 rewardIndexFrom,     uint256 rewardIndexTo   ) internal view virtual returns (uint256 floatReward) {     if (amountStakedLong &gt; 0) {       uint256 accumDeltaLong = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexTo]       .accumulativeFloatPerSyntheticToken_long -         accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexFrom]         .accumulativeFloatPerSyntheticToken_long;       floatReward += (accumDeltaLong * amountStakedLong) / FLOAT_ISSUANCE_FIXED_DECIMAL;     } if (amountStakedShort &gt; 0) {   uint256 accumDeltaShort = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexTo]   .accumulativeFloatPerSyntheticToken_short -     accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexFrom]     .accumulativeFloatPerSyntheticToken_short;   floatReward += (accumDeltaShort * amountStakedShort) / FLOAT_ISSUANCE_FIXED_DECIMAL; }  } /*    @notice Calculates float owed to the user since the user last minted float for a market.   @param marketIndex Identifier for the market which the user staked in.   @param user The address of the user.   @return floatReward The amount of float owed.    /   function _calculateAccumulatedFloat(uint32 marketIndex, address user) internal virtual returns (uint256 floatReward) {     address longToken = syntheticTokens[marketIndex][true];     address shortToken = syntheticTokens[marketIndex][false]; uint256 amountStakedLong = userAmountStaked[longToken][user]; uint256 amountStakedShort = userAmountStaked[shortToken][user];  uint256 usersLastRewardIndex = userIndexOfLastClaimedReward[marketIndex][user];  // Don't do the calculation and return zero immediately if there is no change if (usersLastRewardIndex == latestRewardIndex[marketIndex]) {   return 0; }  uint256 usersShiftIndex = userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][user]; // if there is a change in the users tokens held due to a token shift (or possibly another action in the future) if (usersShiftIndex &gt; 0 &amp;&amp; usersShiftIndex &lt; batched_stakerNextTokenShiftIndex[marketIndex]) {   floatReward = _calculateAccumulatedFloatInRange(     marketIndex,     amountStakedLong,     amountStakedShort,     usersLastRewardIndex,     stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[usersShiftIndex]   );    // Update the users balances   if (userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user] &gt; 0) {     amountStakedShort += ILongShort(longShort).getAmountSyntheticTokenToMintOnTargetSide(       marketIndex,       userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user],       true,       stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[usersShiftIndex]     );      amountStakedLong -= userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user];     userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user] = 0;   }    if (userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user] &gt; 0) {     amountStakedLong += ILongShort(longShort).getAmountSyntheticTokenToMintOnTargetSide(       marketIndex,       userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user],       false,       stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[usersShiftIndex]     );      amountStakedShort -= userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user];     userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user] = 0;   }    // Save the users updated staked amounts   userAmountStaked[longToken][user] = amountStakedLong;   userAmountStaked[shortToken][user] = amountStakedShort;    floatReward += _calculateAccumulatedFloatInRange(     marketIndex,     amountStakedLong,     amountStakedShort,     stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[usersShiftIndex],     latestRewardIndex[marketIndex]   );    userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][user] = 0; } else {   floatReward = _calculateAccumulatedFloatInRange(     marketIndex,     amountStakedLong,     amountStakedShort,     usersLastRewardIndex,     latestRewardIndex[marketIndex]   ); }  } /*   @notice Mints float for a user.   @dev Mints a fixed percentage for Float capital.   @param user The address of the user.   @param floatToMint The amount of float to mint.    /   function _mintFloat(address user, uint256 floatToMint) internal virtual {     IFloatToken(floatToken).mint(user, floatToMint);     IFloatToken(floatToken).mint(floatCapital, (floatToMint * floatPercentage) / 1e18);   } /*   @notice Mints float owed to a user for a market since they last minted.   @param marketIndex An identifier for the market.   @param user The address of the user.    /   function _mintAccumulatedFloat(uint32 marketIndex, address user) internal virtual {     uint256 floatToMint = _calculateAccumulatedFloat(marketIndex, user); if (floatToMint &gt; 0) {   // Set the user has claimed up until now, stops them setting this forward   userIndexOfLastClaimedReward[marketIndex][user] = latestRewardIndex[marketIndex];    _mintFloat(user, floatToMint);   emit FloatMinted(user, marketIndex, floatToMint); }  } /*   @notice Mints float owed to a user for multiple markets, since they last minted for those markets.   @param marketIndexes Identifiers for the markets.   @param user The address of the user.    /   function _mintAccumulatedFloatMulti(uint32[] calldata marketIndexes, address user) internal virtual {     uint256 floatTotal = 0;     for (uint256 i = 0; i &lt; marketIndexes.length; i++) {       uint256 floatToMint = _calculateAccumulatedFloat(marketIndexes[i], user);   if (floatToMint &gt; 0) {     // Set the user has claimed up until now, stops them setting this forward     userIndexOfLastClaimedReward[marketIndexes[i]][user] = latestRewardIndex[marketIndexes[i]];      floatTotal += floatToMint;      emit FloatMinted(user, marketIndexes[i], floatToMint);   } } if (floatTotal &gt; 0) {   _mintFloat(user, floatTotal); }  } /*   @notice Mints outstanding float for msg.sender.   @param marketIndexes Identifiers for the markets for which to mint float.    /   function claimFloatCustom(uint32[] calldata marketIndexes) external {     ILongShort(longShort).updateSystemStateMulti(marketIndexes);     _mintAccumulatedFloatMulti(marketIndexes, msg.sender);   } /*   @notice Mints outstanding float on behalf of another user.   @param marketIndexes Identifiers for the markets for which to mint float.   @param user The address of the user.    /   function claimFloatCustomFor(uint32[] calldata marketIndexes, address user) external {     // Unbounded loop - users are responsible for paying their own gas costs on these and it doesn't effect the rest of the system.     // No need to impose limit.     ILongShort(longShort).updateSystemStateMulti(marketIndexes);     _mintAccumulatedFloatMulti(marketIndexes, user);   } /╔═══════════════════════╗     ║        STAKING        ║     ╚═══════════════════════╝/ /*   @notice A user with synthetic tokens stakes by calling stake on the token   contract which calls this function. We need to first update the   state of the LongShort contract for this market before staking to correctly calculate user rewards.   @param amount Amount to stake.   @param from Address to stake for.   /   function stakeFromUser(address from, uint256 amount) public virtual override onlyValidSynthetic((msg.sender)) {     ILongShort(longShort).updateSystemState(marketIndexOfToken[(msg.sender)]);     _stake((msg.sender), amount, from);   } /*   @dev Internal logic for staking.   @param token Address of the token for which to stake.   @param amount Amount to stake.   @param user Address to stake for.   /   function _stake(     address token,     uint256 amount,     address user   ) internal virtual {     uint32 marketIndex = marketIndexOfToken[token]; // If they already have staked and have rewards due, mint these. if (   userIndexOfLastClaimedReward[marketIndex][user] != 0 &amp;&amp;   userIndexOfLastClaimedReward[marketIndex][user] &lt; latestRewardIndex[marketIndex] ) {   _mintAccumulatedFloat(marketIndex, user); }  userAmountStaked[token][user] = userAmountStaked[token][user] + amount;  userIndexOfLastClaimedReward[marketIndex][user] = latestRewardIndex[marketIndex];  emit StakeAdded(user, address(token), amount, userIndexOfLastClaimedReward[marketIndex][user]);  } /*   @notice Allows users to shift their staked tokens from one side of the market to    the other at the next price.   @param amountSyntheticTokensToShift Amount of tokens to shift.   @param marketIndex Identifier for the market.   @param isShiftFromLong Whether the shift is from long to short or short to long.   /   function shiftTokens(     uint256 amountSyntheticTokensToShift,     uint32 marketIndex,     bool isShiftFromLong   ) external virtual {     address token = syntheticTokens[marketIndex][isShiftFromLong];     require(userAmountStaked[token][msg.sender] &gt;= amountSyntheticTokensToShift, "Not enough tokens to shift"); // If the user has outstanding token shift that have already been confirmed in the LongShort // contract, execute them first. if (   userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] != 0 &amp;&amp;   userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] &lt;   batched_stakerNextTokenShiftIndex[marketIndex] ) {   _mintAccumulatedFloat(marketIndex, msg.sender); }  if (isShiftFromLong) {   ILongShort(longShort).shiftPositionFromLongNextPrice(marketIndex, amountSyntheticTokensToShift);   userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][     msg.sender   ] += amountSyntheticTokensToShift; } else {   ILongShort(longShort).shiftPositionFromShortNextPrice(marketIndex, amountSyntheticTokensToShift);   userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][     msg.sender   ] += amountSyntheticTokensToShift; }  userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] = batched_stakerNextTokenShiftIndex[   marketIndex ];  } /╔════════════════════════════╗     ║    WITHDRAWAL &amp; MINTING    ║     ╚════════════════════════════╝/ /*   @notice Internal logic for withdrawing stakes.   @dev Mint user any outstanding float before withdrawing.   @param marketIndex Market index of token.   @param amount Amount to withdraw.   @param token Synthetic token that was staked.   /   function _withdraw(     uint32 marketIndex,     address token,     uint256 amount   ) internal virtual {     require(userAmountStaked[token][msg.sender] &gt; 0, "nothing to withdraw");     _mintAccumulatedFloat(marketIndex, msg.sender); userAmountStaked[token][msg.sender] = userAmountStaked[token][msg.sender] - amount;  uint256 amountFees = (amount * marketUnstakeFee_e18[marketIndex]) / 1e18;  IERC20(token).transfer(floatTreasury, amountFees); IERC20(token).transfer(msg.sender, amount - amountFees);  emit StakeWithdrawn(msg.sender, token, amount);  } /*   @notice Withdraw function. Allows users to unstake.   @param amount Amount to withdraw.   @param token Address of the token for which to withdraw.   /   function withdraw(address token, uint256 amount) external {     ILongShort(longShort).updateSystemState(marketIndexOfToken[token]); uint32 marketIndex = marketIndexOfToken[token];  _withdraw(marketIndex, token, amount);  if (userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] &gt; 0) {   // If they still have outstanding shifts after minting float, then check   // that they don't withdraw more than their shifts allow.   uint256 amountToShiftForThisToken = syntheticTokens[marketIndex][true] == token     ? userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][msg.sender]     : userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][msg.sender];    require(     userAmountStaked[token][msg.sender] &gt;= amountToShiftForThisToken,     "Outstanding next price stake shifts too great"   ); }  } /*   @notice Allows users to withdraw their entire stake for a token.   @param token Address of the token for which to withdraw.   /   function withdrawAll(address token) external {     ILongShort(longShort).updateSystemState(marketIndexOfToken[token]); uint32 marketIndex = marketIndexOfToken[token];  uint256 amountToShiftForThisToken = syntheticTokens[marketIndex][true] == token   ? userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][msg.sender]   : userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][msg.sender];  _withdraw(marketIndex, token, userAmountStaked[token][msg.sender] - amountToShiftForThisToken);  } } |
| **need_reflect** | True |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Chief Executive Officer |
| **phase_prompt** | We excel in generating innovative approaches and enhancements for Solidity smart contract code. Here's a Solidity contract provided by the user: "{task}". As the {assistant_role}, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user. Note that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we've collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with , followed directly by the final idea or enhancement suggestion, e.g. " Implementing a multi-sig wallet mechanism for added security in transactions". |
| **phase_name** | ContractAnalysis |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'task': '// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.3;\n\nimport "@openzeppelin/contracts-upgradeable/token/ERC20/presets/ERC20PresetMinterPauserUpgradeable.sol";\n\nimport "./interfaces/IFloatToken.sol";\nimport "./interfaces/ILongShort.sol";\nimport "./interfaces/IStaker.sol";\nimport "./interfaces/ISyntheticToken.sol";\n\ncontract Staker is IStaker, Initializable {\n  /╔═════════════════════════════╗\n    ║          VARIABLES          ║\n    ╚═════════════════════════════╝/\n\n  / ══════ Fixed-precision constants ══════ /\n  uint256 public constant FLOAT_ISSUANCE_FIXED_DECIMAL = 1e42;\n  // 2^52 ~= 4.5e15\n  // With an exponent of 5, the largest total liquidity possible in a market (to avoid integer overflow on exponentiation) is ~10^31 or 10 Trillion (10^13)\n  // NOTE: this also means if the total market value is less than 2^52 there will be a division by zero error\n  uint256 public constant safeExponentBitShifting = 52;\n\n  / ══════ Global state ══════ /\n  address public admin;\n  address public floatCapital;\n  address public floatTreasury;\n  uint256 public floatPercentage;\n\n  address public longShort;\n  address public floatToken;\n\n  / ══════ Market specific ══════ /\n  mapping(uint32 =&gt; uint256) public marketLaunchIncentive_period; // seconds\n  mapping(uint32 =&gt; uint256) public marketLaunchIncentive_multipliers; // e18 scale\n  mapping(uint32 =&gt; uint256) public marketUnstakeFee_e18;\n  mapping(uint32 =&gt; uint256) public balanceIncentiveCurve_exponent;\n  mapping(uint32 =&gt; int256) public balanceIncentiveCurve_equilibriumOffset;\n\n  mapping(uint32 =&gt; mapping(bool =&gt; address)) public syntheticTokens;\n\n  mapping(address =&gt; uint32) public marketIndexOfToken;\n\n  / ══════ Reward specific ══════ /\n  mapping(uint32 =&gt; uint256) public latestRewardIndex;\n  mapping(uint32 =&gt; mapping(uint256 =&gt; AccumulativeIssuancePerStakedSynthSnapshot))\n    public accumulativeFloatPerSyntheticTokenSnapshots;\n  struct AccumulativeIssuancePerStakedSynthSnapshot {\n    uint256 timestamp;\n    uint256 accumulativeFloatPerSyntheticToken_long;\n    uint256 accumulativeFloatPerSyntheticToken_short;\n  }\n\n  / ══════ User specific ══════ /\n  mapping(uint32 =&gt; mapping(address =&gt; uint256)) public userIndexOfLastClaimedReward;\n  mapping(address =&gt; mapping(address =&gt; uint256)) public userAmountStaked;\n\n  / ══════ Token shift management specific ══════ /\n  mapping(uint32 =&gt; uint256) public batched_stakerNextTokenShiftIndex;\n  /\n  @notice Used to link a token shift to a staker state\n  @dev tokenShiftIndex =&gt; accumulativeFloatIssuanceSnapshotIndex\n    POSSIBLE OPTIMIZATION - could pack stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping and stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping into a struct of two uint128 for storage space optimization.\n  /\n  mapping(uint256 =&gt; uint256) public stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping;\n  /// @notice Used to fetch the price from LongShort at that point in time\n  /// @dev tokenShiftIndex =&gt; longShortMarketPriceSnapshotIndex\n  mapping(uint256 =&gt; uint256) public stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping;\n  /// @dev marketIndex =&gt; usersAddress =&gt; stakerTokenShiftIndex\n  mapping(uint32 =&gt; mapping(address =&gt; uint256)) public userNextPrice_stakedSyntheticTokenShiftIndex;\n  /// @dev marketIndex =&gt; usersAddress =&gt; amountUserRequestedToShiftAwayFromLongOnNextUpdate\n  mapping(uint32 =&gt; mapping(address =&gt; uint256)) public userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long;\n  /// @dev marketIndex =&gt; usersAddress =&gt; amountUserRequestedToShiftAwayFromShortOnNextUpdate\n  mapping(uint32 =&gt; mapping(address =&gt; uint256)) public userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short;\n\n  /╔════════════════════════════╗\n    ║           EVENTS           ║\n    ╚════════════════════════════╝/\n\n  event StakerV1(\n    address admin,\n    address floatTreasury,\n    address floatCapital,\n    address floatToken,\n    uint256 floatPercentage\n  );\n\n  event MarketAddedToStaker(\n    uint32 marketIndex,\n    uint256 exitFee_e18,\n    uint256 period,\n    uint256 multiplier,\n    uint256 balanceIncentiveExponent,\n    int256 balanceIncentiveEquilibriumOffset\n  );\n\n  event AccumulativeIssuancePerStakedSynthSnapshotCreated(\n    uint32 marketIndex,\n    uint256 accumulativeFloatIssuanceSnapshotIndex,\n    uint256 accumulativeLong,\n    uint256 accumulativeShort\n  );\n\n  event StakeAdded(address user, address token, uint256 amount, uint256 lastMintIndex);\n\n  event StakeWithdrawn(address user, address token, uint256 amount);\n\n  // Note: the amountFloatMinted isn\'t strictly needed by the graph, but it is good to add it to validate calculations are accurate.\n  event FloatMinted(address user, uint32 marketIndex, uint256 amountFloatMinted);\n\n  event MarketLaunchIncentiveParametersChanges(uint32 marketIndex, uint256 period, uint256 multiplier);\n\n  event StakeWithdrawalFeeUpdated(uint32 marketIndex, uint256 stakeWithdralFee);\n\n  event BalanceIncentiveExponentUpdated(uint32 marketIndex, uint256 balanceIncentiveExponent);\n\n  event BalanceIncentiveEquilibriumOffsetUpdated(uint32 marketIndex, int256 balanceIncentiveEquilibriumOffset);\n\n  event FloatPercentageUpdated(uint256 floatPercentage);\n\n  event SyntheticTokensShifted();\n\n  event ChangeAdmin(address newAdmin);\n\n  /╔═════════════════════════════╗\n    ║          MODIFIERS          ║\n    ╚═════════════════════════════╝/\n\n  function onlyAdminModifierLogic() internal virtual {\n    require(msg.sender == admin, "not admin");\n  }\n\n  modifier onlyAdmin() {\n    onlyAdminModifierLogic();\n    ;\n  }\n\n  function onlyValidSyntheticModifierLogic(address _synth) internal virtual {\n    require(marketIndexOfToken[_synth] != 0, "not valid synth");\n  }\n\n  modifier onlyValidSynthetic(address _synth) {\n    onlyValidSyntheticModifierLogic(_synth);\n    ;\n  }\n\n  function onlyValidMarketModifierLogic(uint32 marketIndex) internal virtual {\n    require(address(syntheticTokens[marketIndex][true]) != address(0), "not valid market");\n  }\n\n  modifier onlyValidMarket(uint32 marketIndex) {\n    onlyValidMarketModifierLogic(marketIndex);\n    ;\n  }\n\n  function onlyLongShortModifierLogic() internal virtual {\n    require(msg.sender == address(longShort), "not long short");\n  }\n\n  modifier onlyLongShort() {\n    onlyLongShortModifierLogic();\n    ;\n  }\n\n  /╔═════════════════════════════╗\n    ║       CONTRACT SET-UP       ║\n    ╚═════════════════════════════╝*/\n\n  /\n  @notice Initializes the contract.\n  @dev Calls OpenZeppelin\'s initializer modifier.\n  @param _admin Address of the admin role.\n  @param _longShort Address of the LongShort contract, a deployed LongShort.sol\n  @param _floatToken Address of the Float token earned by staking.\n  @param _floatTreasury Address of the treasury contract for managing fees.\n  @param _floatCapital Address of the contract which earns a fixed percentage of Float.\n  @param _floatPercentage Determines the float percentage that gets minted for Float Capital, base 1e18.\n  /\n  function initialize(\n    address _admin,\n    address _longShort,\n    address _floatToken,\n    address _floatTreasury,\n    address _floatCapital,\n    uint256 _floatPercentage\n  ) external virtual initializer {\n    admin = _admin;\n    floatCapital = _floatCapital;\n    floatTreasury = _floatTreasury;\n    longShort = _longShort;\n    floatToken = _floatToken;\n\n    _changeFloatPercentage(_floatPercentage);\n\n    emit StakerV1(_admin, _floatTreasury, _floatCapital, _floatToken, _floatPercentage);\n  }\n\n  /╔═══════════════════╗\n    ║       ADMIN       ║\n    ╚═══════════════════╝/\n\n  / \n  @notice Changes admin for the contract\n  @param _admin The address of the new admin.\n  /\n  function changeAdmin(address _admin) external onlyAdmin {\n    admin = _admin;\n    emit ChangeAdmin(_admin);\n  }\n\n  /// @dev Logic for changeFloatPercentage\n  function _changeFloatPercentage(uint256 newFloatPercentage) internal virtual {\n    require(newFloatPercentage &lt;= 1e18 &amp;&amp; newFloatPercentage &gt; 0); // less than or equal to 100% and greater than 0%\n    floatPercentage = newFloatPercentage;\n  }\n\n  /\n  @notice Changes percentage of float that is minted for float capital.\n  @param newFloatPercentage The new float percentage in base 1e18.\n  */\n  function changeFloatPercentage(uint256 newFloatPercentage) external onlyAdmin {\n    _changeFloatPercentage(newFloatPercentage);\n    emit FloatPercentageUpdated(newFloatPercentage);\n  }\n\n  /// @dev Logic for changeUnstakeFee\n  function _changeUnstakeFee(uint32 marketIndex, uint256 newMarketUnstakeFee_e18) internal virtual {\n    require(newMarketUnstakeFee_e18 &lt;= 5e16); // Explicitely stating 5% fee as the max fee possible.\n    marketUnstakeFee_e18[marketIndex] = newMarketUnstakeFee_e18;\n  }\n\n  /\n  @notice Changes unstake fee for a market\n  @param marketIndex Identifies the market.\n  @param newMarketUnstakeFee_e18 The new unstake fee.\n  /\n  function changeUnstakeFee(uint32 marketIndex, uint256 newMarketUnstakeFee_e18) external onlyAdmin {\n    _changeUnstakeFee(marketIndex, newMarketUnstakeFee_e18);\n    emit StakeWithdrawalFeeUpdated(marketIndex, newMarketUnstakeFee_e18);\n  }\n\n  /// @dev Logic for changeMarketLaunchIncentiveParameters\n  function _changeMarketLaunchIncentiveParameters(\n    uint32 marketIndex,\n    uint256 period,\n    uint256 initialMultiplier\n  ) internal virtual {\n    require(initialMultiplier &gt;= 1e18, "marketLaunchIncentiveMultiplier must be &gt;= 1e18");\n\n    marketLaunchIncentive_period[marketIndex] = period;\n    marketLaunchIncentive_multipliers[marketIndex] = initialMultiplier;\n  }\n\n  /\n  @notice Changes the market launch incentive parameters for a market\n  @param marketIndex Identifies the market.\n  @param period The new period for which float token generation should be boosted.\n  @param initialMultiplier The new multiplier on Float generation.\n  /\n  function changeMarketLaunchIncentiveParameters(\n    uint32 marketIndex,\n    uint256 period,\n    uint256 initialMultiplier\n  ) external onlyAdmin {\n    _changeMarketLaunchIncentiveParameters(marketIndex, period, initialMultiplier);\n\n    emit MarketLaunchIncentiveParametersChanges(marketIndex, period, initialMultiplier);\n  }\n\n  /// @dev Logic for changeBalanceIncentiveExponent\n  function _changeBalanceIncentiveExponent(uint32 marketIndex, uint256 _balanceIncentiveCurve_exponent)\n    internal\n    virtual\n  {\n    require(\n      // The exponent has to be less than 5 in these versions of the contracts.\n      _balanceIncentiveCurve_exponent &gt; 0 &amp;&amp; _balanceIncentiveCurve_exponent &lt; 6,\n      "balanceIncentiveCurve_exponent out of bounds"\n    );\n\n    balanceIncentiveCurve_exponent[marketIndex] = _balanceIncentiveCurve_exponent;\n  }\n\n  / \n  @notice Changes the balance incentive exponent for a market\n  @param marketIndex Identifies the market.\n  @param _balanceIncentiveCurve_exponent The new exponent for the curve.\n  */\n  function changeBalanceIncentiveExponent(uint32 marketIndex, uint256 _balanceIncentiveCurve_exponent)\n    external\n    onlyAdmin\n  {\n    _changeBalanceIncentiveExponent(marketIndex, _balanceIncentiveCurve_exponent);\n\n    emit BalanceIncentiveExponentUpdated(marketIndex, _balanceIncentiveCurve_exponent);\n  }\n\n  /// @dev Logic for changeBalanceIncentiveEquilibriumOffset\n  function _changeBalanceIncentiveEquilibriumOffset(uint32 marketIndex, int256 _balanceIncentiveCurve_equilibriumOffset)\n    internal\n    virtual\n  {\n    // Unreasonable that we would ever shift this more than 90% either way\n    require(\n      _balanceIncentiveCurve_equilibriumOffset &gt; -9e17 &amp;&amp; _balanceIncentiveCurve_equilibriumOffset &lt; 9e17,\n      "balanceIncentiveCurve_equilibriumOffset out of bounds"\n    );\n\n    balanceIncentiveCurve_equilibriumOffset[marketIndex] = _balanceIncentiveCurve_equilibriumOffset;\n  }\n\n  /\n  @notice Changes the balance incentive curve equilibrium offset for a market\n  @param marketIndex Identifies the market.\n  @param _balanceIncentiveCurve_equilibriumOffset The new offset.\n  /\n  function changeBalanceIncentiveEquilibriumOffset(uint32 marketIndex, int256 _balanceIncentiveCurve_equilibriumOffset)\n    external\n    onlyAdmin\n  {\n    _changeBalanceIncentiveEquilibriumOffset(marketIndex, _balanceIncentiveCurve_equilibriumOffset);\n\n    emit BalanceIncentiveEquilibriumOffsetUpdated(marketIndex, _balanceIncentiveCurve_equilibriumOffset);\n  }\n\n  /╔═════════════════════════════╗\n    ║        STAKING SETUP        ║\n    ╚═════════════════════════════╝/\n\n  /\n  @notice Sets this contract to track staking for a market in LongShort.sol\n  @param marketIndex Identifies the market.\n  @param longToken Address of the long token for the market.\n  @param shortToken Address of the short token for the market.\n  @param kInitialMultiplier Initial boost on float generation for the market.\n  @param kPeriod Period which the boost should last.\n  @param unstakeFee_e18 Percentage of tokens that are levied on unstaking in base 1e18.\n  @param _balanceIncentiveCurve_exponent Exponent for balance curve (see _calculateFloatPerSecond)\n  @param _balanceIncentiveCurve_equilibriumOffset Offset for balance curve (see _calculateFloatPerSecond)\n  /\n  function addNewStakingFund(\n    uint32 marketIndex,\n    address longToken,\n    address shortToken,\n    uint256 kInitialMultiplier,\n    uint256 kPeriod,\n    uint256 unstakeFee_e18,\n    uint256 _balanceIncentiveCurve_exponent,\n    int256 _balanceIncentiveCurve_equilibriumOffset\n  ) external override onlyLongShort {\n    marketIndexOfToken[longToken] = marketIndex;\n    marketIndexOfToken[shortToken] = marketIndex;\n\n    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].timestamp = block.timestamp;\n    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].accumulativeFloatPerSyntheticToken_long = 0;\n    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].accumulativeFloatPerSyntheticToken_short = 0;\n\n    syntheticTokens[marketIndex][true] = longToken;\n    syntheticTokens[marketIndex][false] = shortToken;\n\n    _changeBalanceIncentiveExponent(marketIndex, _balanceIncentiveCurve_exponent);\n    _changeBalanceIncentiveEquilibriumOffset(marketIndex, _balanceIncentiveCurve_equilibriumOffset);\n    _changeMarketLaunchIncentiveParameters(marketIndex, kPeriod, kInitialMultiplier);\n\n    _changeUnstakeFee(marketIndex, unstakeFee_e18);\n\n    // Set this value to one initially - 0 is a null value and thus potentially bug prone.\n    batched_stakerNextTokenShiftIndex[marketIndex] = 1;\n\n    emit MarketAddedToStaker(\n      marketIndex,\n      unstakeFee_e18,\n      kPeriod,\n      kInitialMultiplier,\n      _balanceIncentiveCurve_exponent,\n      _balanceIncentiveCurve_equilibriumOffset\n    );\n\n    emit AccumulativeIssuancePerStakedSynthSnapshotCreated(marketIndex, 0, 0, 0);\n  }\n\n  /╔═════════════════════════════════════════════════════════════════════════╗\n    ║    GLOBAL FLT REWARD ACCUMULATION CALCULATION AND TRACKING FUNCTIONS    ║\n    ╚═════════════════════════════════════════════════════════════════════════╝/\n\n  /\n  @notice Returns the K factor parameters for the given market with sensible\n  defaults if they haven\'t been set yet.\n  @param marketIndex The market to change the parameters for.\n  @return period The period for which the k factor applies for in seconds.\n  @return multiplier The multiplier on Float generation in this period.\n  */\n  function _getMarketLaunchIncentiveParameters(uint32 marketIndex)\n    internal\n    view\n    virtual\n    returns (uint256 period, uint256 multiplier)\n  {\n    period = marketLaunchIncentive_period[marketIndex];\n    multiplier = marketLaunchIncentive_multipliers[marketIndex];\n\n    if (multiplier &lt; 1e18) {\n      multiplier = 1e18; // multiplier of 1 by default\n    }\n  }\n\n  / \n  @notice Returns the extent to which a markets float generation should be adjusted\n  based on the market\'s launch incentive parameters. Should start at multiplier\n  then linearly change to 1e18 over time.\n  @param marketIndex Identifies the market.\n  @return k The calculated modifier for float generation.\n  /\n  function _getKValue(uint32 marketIndex) internal view virtual returns (uint256) {\n    // Parameters controlling the float issuance multiplier.\n    (uint256 kPeriod, uint256 kInitialMultiplier) = _getMarketLaunchIncentiveParameters(marketIndex);\n\n    // Sanity check - under normal circumstances, the multipliers should\n    // never be set to a value &lt; 1e18, as there are guards against this.\n    assert(kInitialMultiplier &gt;= 1e18);\n\n    uint256 initialTimestamp = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].timestamp;\n\n    if (block.timestamp - initialTimestamp &lt;= kPeriod) {\n      return kInitialMultiplier - (((kInitialMultiplier - 1e18) * (block.timestamp - initialTimestamp)) / kPeriod);\n    } else {\n      return 1e18;\n    }\n  }\n\n  /\n  @notice Computes the number of float tokens a user earns per second for\n  every long/short synthetic token they\'ve staked. The returned value has\n  a fixed decimal scale of 1e42 (!!!) for numerical stability. The return\n  values are float per second per synthetic token (hence the requirement\n  to multiply by price)\n  @dev to see below math in latex form see TODO add link\n  to interact with the equations see https://www.desmos.com/calculator/optkaxyihr\n  @param marketIndex The market referred to.\n  @param longPrice Price of the synthetic long token in units of payment token\n  @param shortPrice Price of the synthetic short token in units of payment token\n  @param longValue Amount of payment token in the long side of the market\n  @param shortValue Amount of payment token in the short side of the market\n  @return longFloatPerSecond Float token per second per long synthetic token\n  @return shortFloatPerSecond Float token per second per short synthetic token\n   /\n  function _calculateFloatPerSecond(\n    uint32 marketIndex,\n    uint256 longPrice,\n    uint256 shortPrice,\n    uint256 longValue,\n    uint256 shortValue\n  ) internal view virtual returns (uint256 longFloatPerSecond, uint256 shortFloatPerSecond) {\n    // A float issuance multiplier that starts high and decreases linearly\n    // over time to a value of 1. This incentivises users to stake early.\n    uint256 k = _getKValue(marketIndex);\n\n    uint256 totalLocked = (longValue + shortValue);\n\n    // we need to scale this number by the totalLocked so that the offset remains consistent accross market size\n\n    int256 equilibriumOffsetMarketScaled = (balanceIncentiveCurve_equilibriumOffset[marketIndex] \n      int256(totalLocked)) / 2e18;\n\n    uint256 denominator = ((totalLocked &gt;&gt; safeExponentBitShifting)balanceIncentiveCurve_exponent[marketIndex]);\n\n    // Float is scaled by the percentage of the total market value held in\n    // the opposite position. This incentivises users to stake on the\n    // weaker position.\n    if (int256(shortValue) - equilibriumOffsetMarketScaled &lt; int256(longValue)) {\n      if (equilibriumOffsetMarketScaled &gt;= int256(shortValue)) {\n        // edge case: imbalanced far past the equilibrium offset - full rewards go to short token\n        //            extremeley unlikely to happen in practice\n        return (0, 1e18 * k * shortPrice);\n      }\n\n      uint256 numerator = (uint256(int256(shortValue) - equilibriumOffsetMarketScaled) &gt;&gt;\n        (safeExponentBitShifting - 1))balanceIncentiveCurve_exponent[marketIndex];\n\n      // NOTE: x * 5e17 == (x * 10e18) / 2\n      uint256 longRewardUnscaled = (numerator * 5e17) / denominator;\n      uint256 shortRewardUnscaled = 1e18 - longRewardUnscaled;\n\n      return ((longRewardUnscaled * k * longPrice) / 1e18, (shortRewardUnscaled * k * shortPrice) / 1e18);\n    } else {\n      if (-equilibriumOffsetMarketScaled &gt;= int256(longValue)) {\n        // edge case: imbalanced far past the equilibrium offset - full rewards go to long token\n        //            extremeley unlikely to happen in practice\n        return (1e18 * k * longPrice, 0);\n      }\n\n      uint256 numerator = (uint256(int256(longValue) + equilibriumOffsetMarketScaled) &gt;&gt;\n        (safeExponentBitShifting - 1))balanceIncentiveCurve_exponent[marketIndex];\n\n      // NOTE: x * 5e17 == (x * 10e18) / 2\n      uint256 shortRewardUnscaled = (numerator * 5e17) / denominator;\n      uint256 longRewardUnscaled = 1e18 - shortRewardUnscaled;\n\n      return ((longRewardUnscaled * k * longPrice) / 1e18, (shortRewardUnscaled * k * shortPrice) / 1e18);\n    }\n  }\n\n  /\n  @notice Computes the time since last accumulativeIssuancePerStakedSynthSnapshot for the given market in seconds.\n  @param marketIndex The market referred to.\n  @return The time difference in seconds\n  /\n  function _calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(uint32 marketIndex)\n    internal\n    view\n    virtual\n    returns (uint256)\n  {\n    return\n      block.timestamp -\n      accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]].timestamp;\n  }\n\n  /\n  @notice Computes new cumulative sum of \'r\' value since last accumulativeIssuancePerStakedSynthSnapshot. We use\n  cumulative \'r\' value to avoid looping during issuance. Note that the\n  cumulative sum is kept in 1e42 scale (!!!) to avoid numerical issues.\n  @param shortValue The value locked in the short side of the market.\n  @param longValue The value locked in the long side of the market.\n  @param shortPrice The price of the short token as defined in LongShort.sol\n  @param longPrice The price of the long token as defined in LongShort.sol\n  @param marketIndex An identifier for the market.\n  @return longCumulativeRates The long cumulative sum.\n  @return shortCumulativeRates The short cumulative sum.\n  /\n  function _calculateNewCumulativeIssuancePerStakedSynth(\n    uint32 marketIndex,\n    uint256 longPrice,\n    uint256 shortPrice,\n    uint256 longValue,\n    uint256 shortValue\n  ) internal view virtual returns (uint256 longCumulativeRates, uint256 shortCumulativeRates) {\n    // Compute the current \'r\' value for float issuance per second.\n    (uint256 longFloatPerSecond, uint256 shortFloatPerSecond) = _calculateFloatPerSecond(\n      marketIndex,\n      longPrice,\n      shortPrice,\n      longValue,\n      shortValue\n    );\n\n    // Compute time since last accumulativeIssuancePerStakedSynthSnapshot for the given token.\n    uint256 timeDelta = _calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(marketIndex);\n\n    // Compute new cumulative \'r\' value total.\n    return (\n      accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]]\n      .accumulativeFloatPerSyntheticToken_long + (timeDelta * longFloatPerSecond),\n      accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]]\n      .accumulativeFloatPerSyntheticToken_short + (timeDelta * shortFloatPerSecond)\n    );\n  }\n\n  /\n  @notice Creates a new accumulativeIssuancePerStakedSynthSnapshot for the given token and updates indexes.\n  @param shortValue The value locked in the short side of the market.\n  @param longValue The value locked in the long side of the market.\n  @param shortPrice The price of the short token as defined in LongShort.sol\n  @param longPrice The price of the long token as defined in LongShort.sol\n  @param marketIndex An identifier for the market.\n  */\n  function _setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot(\n    uint32 marketIndex,\n    uint256 longPrice,\n    uint256 shortPrice,\n    uint256 longValue,\n    uint256 shortValue\n  ) internal virtual {\n    (\n      uint256 newLongAccumulativeValue,\n      uint256 newShortAccumulativeValue\n    ) = _calculateNewCumulativeIssuancePerStakedSynth(marketIndex, longPrice, shortPrice, longValue, shortValue);\n\n    uint256 newIndex = latestRewardIndex[marketIndex] + 1;\n\n    // Set cumulative \'r\' value on new accumulativeIssuancePerStakedSynthSnapshot.\n    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex]\n    .accumulativeFloatPerSyntheticToken_long = newLongAccumulativeValue;\n    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex]\n    .accumulativeFloatPerSyntheticToken_short = newShortAccumulativeValue;\n\n    // Set timestamp on new accumulativeIssuancePerStakedSynthSnapshot.\n    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex].timestamp = block.timestamp;\n\n    // Update latest index to point to new accumulativeIssuancePerStakedSynthSnapshot.\n    latestRewardIndex[marketIndex] = newIndex;\n\n    emit AccumulativeIssuancePerStakedSynthSnapshotCreated(\n      marketIndex,\n      newIndex,\n      newLongAccumulativeValue,\n      newShortAccumulativeValue\n    );\n  }\n\n  /\n  @notice Adds new accumulativeIssuancePerStakedSynthSnapshots for the given long/short tokens. Called by the\n  ILongShort contract whenever there is a state change for a market.\n  @param stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted Mapping from this contract\'s shifts to LongShort.sols next price snapshots.\n  @param shortValue The value locked in the short side of the market.\n  @param longValue The value locked in the long side of the market.\n  @param shortPrice The price of the short token as defined in LongShort.sol\n  @param longPrice The price of the long token as defined in LongShort.sol\n  @param marketIndex An identifier for the market.\n  /\n  function pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(\n    uint32 marketIndex,\n    uint256 longPrice,\n    uint256 shortPrice,\n    uint256 longValue,\n    uint256 shortValue,\n    uint256 stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted // This value should be ALWAYS be zero if no shift occured\n  ) external override onlyLongShort {\n    // Only add a new accumulativeIssuancePerStakedSynthSnapshot if some time has passed.\n\n    // the stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted value will be 0 if there is no staker related action in an executed batch\n    if (stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted &gt; 0) {\n      stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[\n        batched_stakerNextTokenShiftIndex[marketIndex]\n      ] = stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted;\n      stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[\n        batched_stakerNextTokenShiftIndex[marketIndex]\n      ] = latestRewardIndex[marketIndex] + 1;\n      batched_stakerNextTokenShiftIndex[marketIndex] += 1;\n\n      emit SyntheticTokensShifted();\n    }\n\n    // Time delta is fetched twice in below code, can pass through? Which is less gas?\n    if (_calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(marketIndex) &gt; 0) {\n      _setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot(\n        marketIndex,\n        longPrice,\n        shortPrice,\n        longValue,\n        shortValue\n      );\n    }\n  }\n\n  /╔═══════════════════════════════════╗\n    ║    USER REWARD STATE FUNCTIONS    ║\n    ╚═══════════════════════════════════╝/\n\n  /// @dev Calculates the accumulated float in a specific range of staker snapshots\n  function _calculateAccumulatedFloatInRange(\n    uint32 marketIndex,\n    uint256 amountStakedLong,\n    uint256 amountStakedShort,\n    uint256 rewardIndexFrom,\n    uint256 rewardIndexTo\n  ) internal view virtual returns (uint256 floatReward) {\n    if (amountStakedLong &gt; 0) {\n      uint256 accumDeltaLong = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexTo]\n      .accumulativeFloatPerSyntheticToken_long -\n        accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexFrom]\n        .accumulativeFloatPerSyntheticToken_long;\n      floatReward += (accumDeltaLong * amountStakedLong) / FLOAT_ISSUANCE_FIXED_DECIMAL;\n    }\n\n    if (amountStakedShort &gt; 0) {\n      uint256 accumDeltaShort = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexTo]\n      .accumulativeFloatPerSyntheticToken_short -\n        accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexFrom]\n        .accumulativeFloatPerSyntheticToken_short;\n      floatReward += (accumDeltaShort * amountStakedShort) / FLOAT_ISSUANCE_FIXED_DECIMAL;\n    }\n  }\n\n  / \n  @notice Calculates float owed to the user since the user last minted float for a market.\n  @param marketIndex Identifier for the market which the user staked in.\n  @param user The address of the user.\n  @return floatReward The amount of float owed.\n   /\n  function _calculateAccumulatedFloat(uint32 marketIndex, address user) internal virtual returns (uint256 floatReward) {\n    address longToken = syntheticTokens[marketIndex][true];\n    address shortToken = syntheticTokens[marketIndex][false];\n\n    uint256 amountStakedLong = userAmountStaked[longToken][user];\n    uint256 amountStakedShort = userAmountStaked[shortToken][user];\n\n    uint256 usersLastRewardIndex = userIndexOfLastClaimedReward[marketIndex][user];\n\n    // Don\'t do the calculation and return zero immediately if there is no change\n    if (usersLastRewardIndex == latestRewardIndex[marketIndex]) {\n      return 0;\n    }\n\n    uint256 usersShiftIndex = userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][user];\n    // if there is a change in the users tokens held due to a token shift (or possibly another action in the future)\n    if (usersShiftIndex &gt; 0 &amp;&amp; usersShiftIndex &lt; batched_stakerNextTokenShiftIndex[marketIndex]) {\n      floatReward = _calculateAccumulatedFloatInRange(\n        marketIndex,\n        amountStakedLong,\n        amountStakedShort,\n        usersLastRewardIndex,\n        stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[usersShiftIndex]\n      );\n\n      // Update the users balances\n      if (userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user] &gt; 0) {\n        amountStakedShort += ILongShort(longShort).getAmountSyntheticTokenToMintOnTargetSide(\n          marketIndex,\n          userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user],\n          true,\n          stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[usersShiftIndex]\n        );\n\n        amountStakedLong -= userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user];\n        userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user] = 0;\n      }\n\n      if (userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user] &gt; 0) {\n        amountStakedLong += ILongShort(longShort).getAmountSyntheticTokenToMintOnTargetSide(\n          marketIndex,\n          userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user],\n          false,\n          stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[usersShiftIndex]\n        );\n\n        amountStakedShort -= userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user];\n        userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user] = 0;\n      }\n\n      // Save the users updated staked amounts\n      userAmountStaked[longToken][user] = amountStakedLong;\n      userAmountStaked[shortToken][user] = amountStakedShort;\n\n      floatReward += _calculateAccumulatedFloatInRange(\n        marketIndex,\n        amountStakedLong,\n        amountStakedShort,\n        stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[usersShiftIndex],\n        latestRewardIndex[marketIndex]\n      );\n\n      userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][user] = 0;\n    } else {\n      floatReward = _calculateAccumulatedFloatInRange(\n        marketIndex,\n        amountStakedLong,\n        amountStakedShort,\n        usersLastRewardIndex,\n        latestRewardIndex[marketIndex]\n      );\n    }\n  }\n\n  /\n  @notice Mints float for a user.\n  @dev Mints a fixed percentage for Float capital.\n  @param user The address of the user.\n  @param floatToMint The amount of float to mint.\n   */\n  function _mintFloat(address user, uint256 floatToMint) internal virtual {\n    IFloatToken(floatToken).mint(user, floatToMint);\n    IFloatToken(floatToken).mint(floatCapital, (floatToMint * floatPercentage) / 1e18);\n  }\n\n  /\n  @notice Mints float owed to a user for a market since they last minted.\n  @param marketIndex An identifier for the market.\n  @param user The address of the user.\n   /\n  function _mintAccumulatedFloat(uint32 marketIndex, address user) internal virtual {\n    uint256 floatToMint = _calculateAccumulatedFloat(marketIndex, user);\n\n    if (floatToMint &gt; 0) {\n      // Set the user has claimed up until now, stops them setting this forward\n      userIndexOfLastClaimedReward[marketIndex][user] = latestRewardIndex[marketIndex];\n\n      _mintFloat(user, floatToMint);\n      emit FloatMinted(user, marketIndex, floatToMint);\n    }\n  }\n\n  /\n  @notice Mints float owed to a user for multiple markets, since they last minted for those markets.\n  @param marketIndexes Identifiers for the markets.\n  @param user The address of the user.\n   /\n  function _mintAccumulatedFloatMulti(uint32[] calldata marketIndexes, address user) internal virtual {\n    uint256 floatTotal = 0;\n    for (uint256 i = 0; i &lt; marketIndexes.length; i++) {\n      uint256 floatToMint = _calculateAccumulatedFloat(marketIndexes[i], user);\n\n      if (floatToMint &gt; 0) {\n        // Set the user has claimed up until now, stops them setting this forward\n        userIndexOfLastClaimedReward[marketIndexes[i]][user] = latestRewardIndex[marketIndexes[i]];\n\n        floatTotal += floatToMint;\n\n        emit FloatMinted(user, marketIndexes[i], floatToMint);\n      }\n    }\n    if (floatTotal &gt; 0) {\n      _mintFloat(user, floatTotal);\n    }\n  }\n\n  /\n  @notice Mints outstanding float for msg.sender.\n  @param marketIndexes Identifiers for the markets for which to mint float.\n   */\n  function claimFloatCustom(uint32[] calldata marketIndexes) external {\n    ILongShort(longShort).updateSystemStateMulti(marketIndexes);\n    _mintAccumulatedFloatMulti(marketIndexes, msg.sender);\n  }\n\n  /\n  @notice Mints outstanding float on behalf of another user.\n  @param marketIndexes Identifiers for the markets for which to mint float.\n  @param user The address of the user.\n   /\n  function claimFloatCustomFor(uint32[] calldata marketIndexes, address user) external {\n    // Unbounded loop - users are responsible for paying their own gas costs on these and it doesn\'t effect the rest of the system.\n    // No need to impose limit.\n    ILongShort(longShort).updateSystemStateMulti(marketIndexes);\n    _mintAccumulatedFloatMulti(marketIndexes, user);\n  }\n\n  /╔═══════════════════════╗\n    ║        STAKING        ║\n    ╚═══════════════════════╝/\n\n  /\n  @notice A user with synthetic tokens stakes by calling stake on the token\n  contract which calls this function. We need to first update the\n  state of the LongShort contract for this market before staking to correctly calculate user rewards.\n  @param amount Amount to stake.\n  @param from Address to stake for.\n  /\n  function stakeFromUser(address from, uint256 amount) public virtual override onlyValidSynthetic((msg.sender)) {\n    ILongShort(longShort).updateSystemState(marketIndexOfToken[(msg.sender)]);\n    _stake((msg.sender), amount, from);\n  }\n\n  /\n  @dev Internal logic for staking.\n  @param token Address of the token for which to stake.\n  @param amount Amount to stake.\n  @param user Address to stake for.\n  */\n  function _stake(\n    address token,\n    uint256 amount,\n    address user\n  ) internal virtual {\n    uint32 marketIndex = marketIndexOfToken[token];\n\n    // If they already have staked and have rewards due, mint these.\n    if (\n      userIndexOfLastClaimedReward[marketIndex][user] != 0 &amp;&amp;\n      userIndexOfLastClaimedReward[marketIndex][user] &lt; latestRewardIndex[marketIndex]\n    ) {\n      _mintAccumulatedFloat(marketIndex, user);\n    }\n\n    userAmountStaked[token][user] = userAmountStaked[token][user] + amount;\n\n    userIndexOfLastClaimedReward[marketIndex][user] = latestRewardIndex[marketIndex];\n\n    emit StakeAdded(user, address(token), amount, userIndexOfLastClaimedReward[marketIndex][user]);\n  }\n\n  /\n  @notice Allows users to shift their staked tokens from one side of the market to \n  the other at the next price.\n  @param amountSyntheticTokensToShift Amount of tokens to shift.\n  @param marketIndex Identifier for the market.\n  @param isShiftFromLong Whether the shift is from long to short or short to long.\n  /\n  function shiftTokens(\n    uint256 amountSyntheticTokensToShift,\n    uint32 marketIndex,\n    bool isShiftFromLong\n  ) external virtual {\n    address token = syntheticTokens[marketIndex][isShiftFromLong];\n    require(userAmountStaked[token][msg.sender] &gt;= amountSyntheticTokensToShift, "Not enough tokens to shift");\n\n    // If the user has outstanding token shift that have already been confirmed in the LongShort\n    // contract, execute them first.\n    if (\n      userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] != 0 &amp;&amp;\n      userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] &lt;\n      batched_stakerNextTokenShiftIndex[marketIndex]\n    ) {\n      _mintAccumulatedFloat(marketIndex, msg.sender);\n    }\n\n    if (isShiftFromLong) {\n      ILongShort(longShort).shiftPositionFromLongNextPrice(marketIndex, amountSyntheticTokensToShift);\n      userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][\n        msg.sender\n      ] += amountSyntheticTokensToShift;\n    } else {\n      ILongShort(longShort).shiftPositionFromShortNextPrice(marketIndex, amountSyntheticTokensToShift);\n      userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][\n        msg.sender\n      ] += amountSyntheticTokensToShift;\n    }\n\n    userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] = batched_stakerNextTokenShiftIndex[\n      marketIndex\n    ];\n  }\n\n  /╔════════════════════════════╗\n    ║    WITHDRAWAL &amp; MINTING    ║\n    ╚════════════════════════════╝/\n\n  /\n  @notice Internal logic for withdrawing stakes.\n  @dev Mint user any outstanding float before withdrawing.\n  @param marketIndex Market index of token.\n  @param amount Amount to withdraw.\n  @param token Synthetic token that was staked.\n  /\n  function _withdraw(\n    uint32 marketIndex,\n    address token,\n    uint256 amount\n  ) internal virtual {\n    require(userAmountStaked[token][msg.sender] &gt; 0, "nothing to withdraw");\n    _mintAccumulatedFloat(marketIndex, msg.sender);\n\n    userAmountStaked[token][msg.sender] = userAmountStaked[token][msg.sender] - amount;\n\n    uint256 amountFees = (amount * marketUnstakeFee_e18[marketIndex]) / 1e18;\n\n    IERC20(token).transfer(floatTreasury, amountFees);\n    IERC20(token).transfer(msg.sender, amount - amountFees);\n\n    emit StakeWithdrawn(msg.sender, token, amount);\n  }\n\n  /\n  @notice Withdraw function. Allows users to unstake.\n  @param amount Amount to withdraw.\n  @param token Address of the token for which to withdraw.\n  */\n  function withdraw(address token, uint256 amount) external {\n    ILongShort(longShort).updateSystemState(marketIndexOfToken[token]);\n\n    uint32 marketIndex = marketIndexOfToken[token];\n\n    _withdraw(marketIndex, token, amount);\n\n    if (userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] &gt; 0) {\n      // If they still have outstanding shifts after minting float, then check\n      // that they don\'t withdraw more than their shifts allow.\n      uint256 amountToShiftForThisToken = syntheticTokens[marketIndex][true] == token\n        ? userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][msg.sender]\n        : userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][msg.sender];\n\n      require(\n        userAmountStaked[token][msg.sender] &gt;= amountToShiftForThisToken,\n        "Outstanding next price stake shifts too great"\n      );\n    }\n  }\n\n  /\n  @notice Allows users to withdraw their entire stake for a token.\n  @param token Address of the token for which to withdraw.\n  */\n  function withdrawAll(address token) external {\n    ILongShort(longShort).updateSystemState(marketIndexOfToken[token]);\n\n    uint32 marketIndex = marketIndexOfToken[token];\n\n    uint256 amountToShiftForThisToken = syntheticTokens[marketIndex][true] == token\n      ? userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][msg.sender]\n      : userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][msg.sender];\n\n    _withdraw(marketIndex, token, userAmountStaked[token][msg.sender] - amountToShiftForThisToken);\n  }\n}\n'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-17-08 08:01:17 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Chief Executive Officer |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: BUSL-1.1 pragma solidity 0.8.3; import "@openzeppelin/contracts-upgradeable/token/ERC20/presets/ERC20PresetMinterPauserUpgradeable.sol"; import "./interfaces/IFloatToken.sol"; import "./interfaces/ILongShort.sol"; import "./interfaces/IStaker.sol"; import "./interfaces/ISyntheticToken.sol"; contract Staker is IStaker, Initializable {   /╔═════════════════════════════╗     ║          VARIABLES          ║     ╚═════════════════════════════╝/ / ══════ Fixed-precision constants ══════ /   uint256 public constant FLOAT_ISSUANCE_FIXED_DECIMAL = 1e42;   // 2^52 ~= 4.5e15   // With an exponent of 5, the largest total liquidity possible in a market (to avoid integer overflow on exponentiation) is ~10^31 or 10 Trillion (10^13)   // NOTE: this also means if the total market value is less than 2^52 there will be a division by zero error   uint256 public constant safeExponentBitShifting = 52; / ══════ Global state ══════ /   address public admin;   address public floatCapital;   address public floatTreasury;   uint256 public floatPercentage; address public longShort;   address public floatToken; / ══════ Market specific ══════ /   mapping(uint32 =&gt; uint256) public marketLaunchIncentive_period; // seconds   mapping(uint32 =&gt; uint256) public marketLaunchIncentive_multipliers; // e18 scale   mapping(uint32 =&gt; uint256) public marketUnstakeFee_e18;   mapping(uint32 =&gt; uint256) public balanceIncentiveCurve_exponent;   mapping(uint32 =&gt; int256) public balanceIncentiveCurve_equilibriumOffset; mapping(uint32 =&gt; mapping(bool =&gt; address)) public syntheticTokens; mapping(address =&gt; uint32) public marketIndexOfToken; / ══════ Reward specific ══════ /   mapping(uint32 =&gt; uint256) public latestRewardIndex;   mapping(uint32 =&gt; mapping(uint256 =&gt; AccumulativeIssuancePerStakedSynthSnapshot))     public accumulativeFloatPerSyntheticTokenSnapshots;   struct AccumulativeIssuancePerStakedSynthSnapshot {     uint256 timestamp;     uint256 accumulativeFloatPerSyntheticToken_long;     uint256 accumulativeFloatPerSyntheticToken_short;   } / ══════ User specific ══════ /   mapping(uint32 =&gt; mapping(address =&gt; uint256)) public userIndexOfLastClaimedReward;   mapping(address =&gt; mapping(address =&gt; uint256)) public userAmountStaked; / ══════ Token shift management specific ══════ /   mapping(uint32 =&gt; uint256) public batched_stakerNextTokenShiftIndex;   /*   @notice Used to link a token shift to a staker state   @dev tokenShiftIndex =&gt; accumulativeFloatIssuanceSnapshotIndex     POSSIBLE OPTIMIZATION - could pack stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping and stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping into a struct of two uint128 for storage space optimization.   /   mapping(uint256 =&gt; uint256) public stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping;   /// @notice Used to fetch the price from LongShort at that point in time   /// @dev tokenShiftIndex =&gt; longShortMarketPriceSnapshotIndex   mapping(uint256 =&gt; uint256) public stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping;   /// @dev marketIndex =&gt; usersAddress =&gt; stakerTokenShiftIndex   mapping(uint32 =&gt; mapping(address =&gt; uint256)) public userNextPrice_stakedSyntheticTokenShiftIndex;   /// @dev marketIndex =&gt; usersAddress =&gt; amountUserRequestedToShiftAwayFromLongOnNextUpdate   mapping(uint32 =&gt; mapping(address =&gt; uint256)) public userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long;   /// @dev marketIndex =&gt; usersAddress =&gt; amountUserRequestedToShiftAwayFromShortOnNextUpdate   mapping(uint32 =&gt; mapping(address =&gt; uint256)) public userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short; /╔════════════════════════════╗     ║           EVENTS           ║     ╚════════════════════════════╝/ event StakerV1(     address admin,     address floatTreasury,     address floatCapital,     address floatToken,     uint256 floatPercentage   ); event MarketAddedToStaker(     uint32 marketIndex,     uint256 exitFee_e18,     uint256 period,     uint256 multiplier,     uint256 balanceIncentiveExponent,     int256 balanceIncentiveEquilibriumOffset   ); event AccumulativeIssuancePerStakedSynthSnapshotCreated(     uint32 marketIndex,     uint256 accumulativeFloatIssuanceSnapshotIndex,     uint256 accumulativeLong,     uint256 accumulativeShort   ); event StakeAdded(address user, address token, uint256 amount, uint256 lastMintIndex); event StakeWithdrawn(address user, address token, uint256 amount); // Note: the amountFloatMinted isn't strictly needed by the graph, but it is good to add it to validate calculations are accurate.   event FloatMinted(address user, uint32 marketIndex, uint256 amountFloatMinted); event MarketLaunchIncentiveParametersChanges(uint32 marketIndex, uint256 period, uint256 multiplier); event StakeWithdrawalFeeUpdated(uint32 marketIndex, uint256 stakeWithdralFee); event BalanceIncentiveExponentUpdated(uint32 marketIndex, uint256 balanceIncentiveExponent); event BalanceIncentiveEquilibriumOffsetUpdated(uint32 marketIndex, int256 balanceIncentiveEquilibriumOffset); event FloatPercentageUpdated(uint256 floatPercentage); event SyntheticTokensShifted(); event ChangeAdmin(address newAdmin); /╔═════════════════════════════╗     ║          MODIFIERS          ║     ╚═════════════════════════════╝/ function onlyAdminModifierLogic() internal virtual {     require(msg.sender == admin, "not admin");   } modifier onlyAdmin() {     onlyAdminModifierLogic();     _;   } function onlyValidSyntheticModifierLogic(address _synth) internal virtual {     require(marketIndexOfToken[_synth] != 0, "not valid synth");   } modifier onlyValidSynthetic(address synth) {     onlyValidSyntheticModifierLogic(_synth);     ;   } function onlyValidMarketModifierLogic(uint32 marketIndex) internal virtual {     require(address(syntheticTokens[marketIndex][true]) != address(0), "not valid market");   } modifier onlyValidMarket(uint32 marketIndex) {     onlyValidMarketModifierLogic(marketIndex);     _;   } function onlyLongShortModifierLogic() internal virtual {     require(msg.sender == address(longShort), "not long short");   } modifier onlyLongShort() {     onlyLongShortModifierLogic();     _;   } /╔═════════════════════════════╗     ║       CONTRACT SET-UP       ║     ╚═════════════════════════════╝/ /*   @notice Initializes the contract.   @dev Calls OpenZeppelin's initializer modifier.   @param _admin Address of the admin role.   @param _longShort Address of the LongShort contract, a deployed LongShort.sol   @param _floatToken Address of the Float token earned by staking.   @param _floatTreasury Address of the treasury contract for managing fees.   @param _floatCapital Address of the contract which earns a fixed percentage of Float.   @param _floatPercentage Determines the float percentage that gets minted for Float Capital, base 1e18.   /   function initialize(     address _admin,     address _longShort,     address _floatToken,     address _floatTreasury,     address _floatCapital,     uint256 _floatPercentage   ) external virtual initializer {     admin = _admin;     floatCapital = _floatCapital;     floatTreasury = _floatTreasury;     longShort = _longShort;     floatToken = _floatToken; _changeFloatPercentage(_floatPercentage);  emit StakerV1(_admin, _floatTreasury, _floatCapital, _floatToken, _floatPercentage);  } /╔═══════════════════╗     ║       ADMIN       ║     ╚═══════════════════╝/ /*    @notice Changes admin for the contract   @param _admin The address of the new admin.   /   function changeAdmin(address _admin) external onlyAdmin {     admin = _admin;     emit ChangeAdmin(_admin);   } /// @dev Logic for changeFloatPercentage   function _changeFloatPercentage(uint256 newFloatPercentage) internal virtual {     require(newFloatPercentage &lt;= 1e18 &amp;&amp; newFloatPercentage &gt; 0); // less than or equal to 100% and greater than 0%     floatPercentage = newFloatPercentage;   } /*   @notice Changes percentage of float that is minted for float capital.   @param newFloatPercentage The new float percentage in base 1e18.   /   function changeFloatPercentage(uint256 newFloatPercentage) external onlyAdmin {     _changeFloatPercentage(newFloatPercentage);     emit FloatPercentageUpdated(newFloatPercentage);   } /// @dev Logic for changeUnstakeFee   function _changeUnstakeFee(uint32 marketIndex, uint256 newMarketUnstakeFee_e18) internal virtual {     require(newMarketUnstakeFee_e18 &lt;= 5e16); // Explicitely stating 5% fee as the max fee possible.     marketUnstakeFee_e18[marketIndex] = newMarketUnstakeFee_e18;   } /*   @notice Changes unstake fee for a market   @param marketIndex Identifies the market.   @param newMarketUnstakeFee_e18 The new unstake fee.   /   function changeUnstakeFee(uint32 marketIndex, uint256 newMarketUnstakeFee_e18) external onlyAdmin {     _changeUnstakeFee(marketIndex, newMarketUnstakeFee_e18);     emit StakeWithdrawalFeeUpdated(marketIndex, newMarketUnstakeFee_e18);   } /// @dev Logic for changeMarketLaunchIncentiveParameters   function _changeMarketLaunchIncentiveParameters(     uint32 marketIndex,     uint256 period,     uint256 initialMultiplier   ) internal virtual {     require(initialMultiplier &gt;= 1e18, "marketLaunchIncentiveMultiplier must be &gt;= 1e18"); marketLaunchIncentive_period[marketIndex] = period; marketLaunchIncentive_multipliers[marketIndex] = initialMultiplier;  } /*   @notice Changes the market launch incentive parameters for a market   @param marketIndex Identifies the market.   @param period The new period for which float token generation should be boosted.   @param initialMultiplier The new multiplier on Float generation.   /   function changeMarketLaunchIncentiveParameters(     uint32 marketIndex,     uint256 period,     uint256 initialMultiplier   ) external onlyAdmin {     _changeMarketLaunchIncentiveParameters(marketIndex, period, initialMultiplier); emit MarketLaunchIncentiveParametersChanges(marketIndex, period, initialMultiplier);  } /// @dev Logic for changeBalanceIncentiveExponent   function _changeBalanceIncentiveExponent(uint32 marketIndex, uint256 _balanceIncentiveCurve_exponent)     internal     virtual   {     require(       // The exponent has to be less than 5 in these versions of the contracts.       _balanceIncentiveCurve_exponent &gt; 0 &amp;&amp; _balanceIncentiveCurve_exponent &lt; 6,       "balanceIncentiveCurve_exponent out of bounds"     ); balanceIncentiveCurve_exponent[marketIndex] = _balanceIncentiveCurve_exponent;  } /*    @notice Changes the balance incentive exponent for a market   @param marketIndex Identifies the market.   @param _balanceIncentiveCurve_exponent The new exponent for the curve.   /   function changeBalanceIncentiveExponent(uint32 marketIndex, uint256 _balanceIncentiveCurve_exponent)     external     onlyAdmin   {     _changeBalanceIncentiveExponent(marketIndex, _balanceIncentiveCurve_exponent); emit BalanceIncentiveExponentUpdated(marketIndex, _balanceIncentiveCurve_exponent);  } /// @dev Logic for changeBalanceIncentiveEquilibriumOffset   function _changeBalanceIncentiveEquilibriumOffset(uint32 marketIndex, int256 _balanceIncentiveCurve_equilibriumOffset)     internal     virtual   {     // Unreasonable that we would ever shift this more than 90% either way     require(       _balanceIncentiveCurve_equilibriumOffset &gt; -9e17 &amp;&amp; _balanceIncentiveCurve_equilibriumOffset &lt; 9e17,       "balanceIncentiveCurve_equilibriumOffset out of bounds"     ); balanceIncentiveCurve_equilibriumOffset[marketIndex] = _balanceIncentiveCurve_equilibriumOffset;  } /*   @notice Changes the balance incentive curve equilibrium offset for a market   @param marketIndex Identifies the market.   @param _balanceIncentiveCurve_equilibriumOffset The new offset.   /   function changeBalanceIncentiveEquilibriumOffset(uint32 marketIndex, int256 _balanceIncentiveCurve_equilibriumOffset)     external     onlyAdmin   {     _changeBalanceIncentiveEquilibriumOffset(marketIndex, _balanceIncentiveCurve_equilibriumOffset); emit BalanceIncentiveEquilibriumOffsetUpdated(marketIndex, _balanceIncentiveCurve_equilibriumOffset);  } /╔═════════════════════════════╗     ║        STAKING SETUP        ║     ╚═════════════════════════════╝/ /*   @notice Sets this contract to track staking for a market in LongShort.sol   @param marketIndex Identifies the market.   @param longToken Address of the long token for the market.   @param shortToken Address of the short token for the market.   @param kInitialMultiplier Initial boost on float generation for the market.   @param kPeriod Period which the boost should last.   @param unstakeFee_e18 Percentage of tokens that are levied on unstaking in base 1e18.   @param _balanceIncentiveCurve_exponent Exponent for balance curve (see _calculateFloatPerSecond)   @param _balanceIncentiveCurve_equilibriumOffset Offset for balance curve (see _calculateFloatPerSecond)   /   function addNewStakingFund(     uint32 marketIndex,     address longToken,     address shortToken,     uint256 kInitialMultiplier,     uint256 kPeriod,     uint256 unstakeFee_e18,     uint256 _balanceIncentiveCurve_exponent,     int256 _balanceIncentiveCurve_equilibriumOffset   ) external override onlyLongShort {     marketIndexOfToken[longToken] = marketIndex;     marketIndexOfToken[shortToken] = marketIndex; accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].timestamp = block.timestamp; accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].accumulativeFloatPerSyntheticToken_long = 0; accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].accumulativeFloatPerSyntheticToken_short = 0;  syntheticTokens[marketIndex][true] = longToken; syntheticTokens[marketIndex][false] = shortToken;  _changeBalanceIncentiveExponent(marketIndex, _balanceIncentiveCurve_exponent); _changeBalanceIncentiveEquilibriumOffset(marketIndex, _balanceIncentiveCurve_equilibriumOffset); _changeMarketLaunchIncentiveParameters(marketIndex, kPeriod, kInitialMultiplier);  _changeUnstakeFee(marketIndex, unstakeFee_e18);  // Set this value to one initially - 0 is a null value and thus potentially bug prone. batched_stakerNextTokenShiftIndex[marketIndex] = 1;  emit MarketAddedToStaker(   marketIndex,   unstakeFee_e18,   kPeriod,   kInitialMultiplier,   _balanceIncentiveCurve_exponent,   _balanceIncentiveCurve_equilibriumOffset );  emit AccumulativeIssuancePerStakedSynthSnapshotCreated(marketIndex, 0, 0, 0);  } /╔═════════════════════════════════════════════════════════════════════════╗     ║    GLOBAL FLT REWARD ACCUMULATION CALCULATION AND TRACKING FUNCTIONS    ║     ╚═════════════════════════════════════════════════════════════════════════╝/ /*   @notice Returns the K factor parameters for the given market with sensible   defaults if they haven't been set yet.   @param marketIndex The market to change the parameters for.   @return period The period for which the k factor applies for in seconds.   @return multiplier The multiplier on Float generation in this period.   /   function _getMarketLaunchIncentiveParameters(uint32 marketIndex)     internal     view     virtual     returns (uint256 period, uint256 multiplier)   {     period = marketLaunchIncentive_period[marketIndex];     multiplier = marketLaunchIncentive_multipliers[marketIndex]; if (multiplier &lt; 1e18) {   multiplier = 1e18; // multiplier of 1 by default }  } /*    @notice Returns the extent to which a markets float generation should be adjusted   based on the market's launch incentive parameters. Should start at multiplier   then linearly change to 1e18 over time.   @param marketIndex Identifies the market.   @return k The calculated modifier for float generation.   /   function _getKValue(uint32 marketIndex) internal view virtual returns (uint256) {     // Parameters controlling the float issuance multiplier.     (uint256 kPeriod, uint256 kInitialMultiplier) = _getMarketLaunchIncentiveParameters(marketIndex); // Sanity check - under normal circumstances, the multipliers should // *never* be set to a value &lt; 1e18, as there are guards against this. assert(kInitialMultiplier &gt;= 1e18);  uint256 initialTimestamp = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].timestamp;  if (block.timestamp - initialTimestamp &lt;= kPeriod) {   return kInitialMultiplier - (((kInitialMultiplier - 1e18) * (block.timestamp - initialTimestamp)) / kPeriod); } else {   return 1e18; }  } /   @notice Computes the number of float tokens a user earns per second for   every long/short synthetic token they've staked. The returned value has   a fixed decimal scale of 1e42 (!!!) for numerical stability. The return   values are float per second per synthetic token (hence the requirement   to multiply by price)   @dev to see below math in latex form see TODO add link   to interact with the equations see https://www.desmos.com/calculator/optkaxyihr   @param marketIndex The market referred to.   @param longPrice Price of the synthetic long token in units of payment token   @param shortPrice Price of the synthetic short token in units of payment token   @param longValue Amount of payment token in the long side of the market   @param shortValue Amount of payment token in the short side of the market   @return longFloatPerSecond Float token per second per long synthetic token   @return shortFloatPerSecond Float token per second per short synthetic token    /   function _calculateFloatPerSecond(     uint32 marketIndex,     uint256 longPrice,     uint256 shortPrice,     uint256 longValue,     uint256 shortValue   ) internal view virtual returns (uint256 longFloatPerSecond, uint256 shortFloatPerSecond) {     // A float issuance multiplier that starts high and decreases linearly     // over time to a value of 1. This incentivises users to stake early.     uint256 k = _getKValue(marketIndex); uint256 totalLocked = (longValue + shortValue);  // we need to scale this number by the totalLocked so that the offset remains consistent accross market size  int256 equilibriumOffsetMarketScaled = (balanceIncentiveCurve_equilibriumOffset[marketIndex] *   int256(totalLocked)) / 2e18;  uint256 denominator = ((totalLocked &gt;&gt; safeExponentBitShifting)**balanceIncentiveCurve_exponent[marketIndex]);  // Float is scaled by the percentage of the total market value held in // the opposite position. This incentivises users to stake on the // weaker position. if (int256(shortValue) - equilibriumOffsetMarketScaled &lt; int256(longValue)) {   if (equilibriumOffsetMarketScaled &gt;= int256(shortValue)) {     // edge case: imbalanced far past the equilibrium offset - full rewards go to short token     //            extremeley unlikely to happen in practice     return (0, 1e18 * k * shortPrice);   }    uint256 numerator = (uint256(int256(shortValue) - equilibriumOffsetMarketScaled) &gt;&gt;     (safeExponentBitShifting - 1))**balanceIncentiveCurve_exponent[marketIndex];    // NOTE: `x * 5e17` == `(x * 10e18) / 2`   uint256 longRewardUnscaled = (numerator * 5e17) / denominator;   uint256 shortRewardUnscaled = 1e18 - longRewardUnscaled;    return ((longRewardUnscaled * k * longPrice) / 1e18, (shortRewardUnscaled * k * shortPrice) / 1e18); } else {   if (-equilibriumOffsetMarketScaled &gt;= int256(longValue)) {     // edge case: imbalanced far past the equilibrium offset - full rewards go to long token     //            extremeley unlikely to happen in practice     return (1e18 * k * longPrice, 0);   }    uint256 numerator = (uint256(int256(longValue) + equilibriumOffsetMarketScaled) &gt;&gt;     (safeExponentBitShifting - 1))**balanceIncentiveCurve_exponent[marketIndex];    // NOTE: `x * 5e17` == `(x * 10e18) / 2`   uint256 shortRewardUnscaled = (numerator * 5e17) / denominator;   uint256 longRewardUnscaled = 1e18 - shortRewardUnscaled;    return ((longRewardUnscaled * k * longPrice) / 1e18, (shortRewardUnscaled * k * shortPrice) / 1e18); }  } /*   @notice Computes the time since last accumulativeIssuancePerStakedSynthSnapshot for the given market in seconds.   @param marketIndex The market referred to.   @return The time difference in seconds   /   function _calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(uint32 marketIndex)     internal     view     virtual     returns (uint256)   {     return       block.timestamp -       accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]].timestamp;   } /*   @notice Computes new cumulative sum of 'r' value since last accumulativeIssuancePerStakedSynthSnapshot. We use   cumulative 'r' value to avoid looping during issuance. Note that the   cumulative sum is kept in 1e42 scale (!!!) to avoid numerical issues.   @param shortValue The value locked in the short side of the market.   @param longValue The value locked in the long side of the market.   @param shortPrice The price of the short token as defined in LongShort.sol   @param longPrice The price of the long token as defined in LongShort.sol   @param marketIndex An identifier for the market.   @return longCumulativeRates The long cumulative sum.   @return shortCumulativeRates The short cumulative sum.   /   function _calculateNewCumulativeIssuancePerStakedSynth(     uint32 marketIndex,     uint256 longPrice,     uint256 shortPrice,     uint256 longValue,     uint256 shortValue   ) internal view virtual returns (uint256 longCumulativeRates, uint256 shortCumulativeRates) {     // Compute the current 'r' value for float issuance per second.     (uint256 longFloatPerSecond, uint256 shortFloatPerSecond) = _calculateFloatPerSecond(       marketIndex,       longPrice,       shortPrice,       longValue,       shortValue     ); // Compute time since last accumulativeIssuancePerStakedSynthSnapshot for the given token. uint256 timeDelta = _calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(marketIndex);  // Compute new cumulative 'r' value total. return (   accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]]   .accumulativeFloatPerSyntheticToken_long + (timeDelta * longFloatPerSecond),   accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]]   .accumulativeFloatPerSyntheticToken_short + (timeDelta * shortFloatPerSecond) );  } /*   @notice Creates a new accumulativeIssuancePerStakedSynthSnapshot for the given token and updates indexes.   @param shortValue The value locked in the short side of the market.   @param longValue The value locked in the long side of the market.   @param shortPrice The price of the short token as defined in LongShort.sol   @param longPrice The price of the long token as defined in LongShort.sol   @param marketIndex An identifier for the market.   /   function _setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot(     uint32 marketIndex,     uint256 longPrice,     uint256 shortPrice,     uint256 longValue,     uint256 shortValue   ) internal virtual {     (       uint256 newLongAccumulativeValue,       uint256 newShortAccumulativeValue     ) = _calculateNewCumulativeIssuancePerStakedSynth(marketIndex, longPrice, shortPrice, longValue, shortValue); uint256 newIndex = latestRewardIndex[marketIndex] + 1;  // Set cumulative 'r' value on new accumulativeIssuancePerStakedSynthSnapshot. accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex] .accumulativeFloatPerSyntheticToken_long = newLongAccumulativeValue; accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex] .accumulativeFloatPerSyntheticToken_short = newShortAccumulativeValue;  // Set timestamp on new accumulativeIssuancePerStakedSynthSnapshot. accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex].timestamp = block.timestamp;  // Update latest index to point to new accumulativeIssuancePerStakedSynthSnapshot. latestRewardIndex[marketIndex] = newIndex;  emit AccumulativeIssuancePerStakedSynthSnapshotCreated(   marketIndex,   newIndex,   newLongAccumulativeValue,   newShortAccumulativeValue );  } /*   @notice Adds new accumulativeIssuancePerStakedSynthSnapshots for the given long/short tokens. Called by the   ILongShort contract whenever there is a state change for a market.   @param stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted Mapping from this contract's shifts to LongShort.sols next price snapshots.   @param shortValue The value locked in the short side of the market.   @param longValue The value locked in the long side of the market.   @param shortPrice The price of the short token as defined in LongShort.sol   @param longPrice The price of the long token as defined in LongShort.sol   @param marketIndex An identifier for the market.   /   function pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(     uint32 marketIndex,     uint256 longPrice,     uint256 shortPrice,     uint256 longValue,     uint256 shortValue,     uint256 stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted // This value should be ALWAYS be zero if no shift occured   ) external override onlyLongShort {     // Only add a new accumulativeIssuancePerStakedSynthSnapshot if some time has passed. // the `stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted` value will be 0 if there is no staker related action in an executed batch if (stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted &gt; 0) {   stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[     batched_stakerNextTokenShiftIndex[marketIndex]   ] = stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted;   stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[     batched_stakerNextTokenShiftIndex[marketIndex]   ] = latestRewardIndex[marketIndex] + 1;   batched_stakerNextTokenShiftIndex[marketIndex] += 1;    emit SyntheticTokensShifted(); }  // Time delta is fetched twice in below code, can pass through? Which is less gas? if (_calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(marketIndex) &gt; 0) {   _setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot(     marketIndex,     longPrice,     shortPrice,     longValue,     shortValue   ); }  } /╔═══════════════════════════════════╗     ║    USER REWARD STATE FUNCTIONS    ║     ╚═══════════════════════════════════╝/ /// @dev Calculates the accumulated float in a specific range of staker snapshots   function _calculateAccumulatedFloatInRange(     uint32 marketIndex,     uint256 amountStakedLong,     uint256 amountStakedShort,     uint256 rewardIndexFrom,     uint256 rewardIndexTo   ) internal view virtual returns (uint256 floatReward) {     if (amountStakedLong &gt; 0) {       uint256 accumDeltaLong = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexTo]       .accumulativeFloatPerSyntheticToken_long -         accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexFrom]         .accumulativeFloatPerSyntheticToken_long;       floatReward += (accumDeltaLong * amountStakedLong) / FLOAT_ISSUANCE_FIXED_DECIMAL;     } if (amountStakedShort &gt; 0) {   uint256 accumDeltaShort = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexTo]   .accumulativeFloatPerSyntheticToken_short -     accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexFrom]     .accumulativeFloatPerSyntheticToken_short;   floatReward += (accumDeltaShort * amountStakedShort) / FLOAT_ISSUANCE_FIXED_DECIMAL; }  } /*    @notice Calculates float owed to the user since the user last minted float for a market.   @param marketIndex Identifier for the market which the user staked in.   @param user The address of the user.   @return floatReward The amount of float owed.    /   function _calculateAccumulatedFloat(uint32 marketIndex, address user) internal virtual returns (uint256 floatReward) {     address longToken = syntheticTokens[marketIndex][true];     address shortToken = syntheticTokens[marketIndex][false]; uint256 amountStakedLong = userAmountStaked[longToken][user]; uint256 amountStakedShort = userAmountStaked[shortToken][user];  uint256 usersLastRewardIndex = userIndexOfLastClaimedReward[marketIndex][user];  // Don't do the calculation and return zero immediately if there is no change if (usersLastRewardIndex == latestRewardIndex[marketIndex]) {   return 0; }  uint256 usersShiftIndex = userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][user]; // if there is a change in the users tokens held due to a token shift (or possibly another action in the future) if (usersShiftIndex &gt; 0 &amp;&amp; usersShiftIndex &lt; batched_stakerNextTokenShiftIndex[marketIndex]) {   floatReward = _calculateAccumulatedFloatInRange(     marketIndex,     amountStakedLong,     amountStakedShort,     usersLastRewardIndex,     stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[usersShiftIndex]   );    // Update the users balances   if (userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user] &gt; 0) {     amountStakedShort += ILongShort(longShort).getAmountSyntheticTokenToMintOnTargetSide(       marketIndex,       userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user],       true,       stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[usersShiftIndex]     );      amountStakedLong -= userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user];     userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user] = 0;   }    if (userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user] &gt; 0) {     amountStakedLong += ILongShort(longShort).getAmountSyntheticTokenToMintOnTargetSide(       marketIndex,       userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user],       false,       stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[usersShiftIndex]     );      amountStakedShort -= userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user];     userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user] = 0;   }    // Save the users updated staked amounts   userAmountStaked[longToken][user] = amountStakedLong;   userAmountStaked[shortToken][user] = amountStakedShort;    floatReward += _calculateAccumulatedFloatInRange(     marketIndex,     amountStakedLong,     amountStakedShort,     stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[usersShiftIndex],     latestRewardIndex[marketIndex]   );    userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][user] = 0; } else {   floatReward = _calculateAccumulatedFloatInRange(     marketIndex,     amountStakedLong,     amountStakedShort,     usersLastRewardIndex,     latestRewardIndex[marketIndex]   ); }  } /*   @notice Mints float for a user.   @dev Mints a fixed percentage for Float capital.   @param user The address of the user.   @param floatToMint The amount of float to mint.    /   function _mintFloat(address user, uint256 floatToMint) internal virtual {     IFloatToken(floatToken).mint(user, floatToMint);     IFloatToken(floatToken).mint(floatCapital, (floatToMint * floatPercentage) / 1e18);   } /*   @notice Mints float owed to a user for a market since they last minted.   @param marketIndex An identifier for the market.   @param user The address of the user.    /   function _mintAccumulatedFloat(uint32 marketIndex, address user) internal virtual {     uint256 floatToMint = _calculateAccumulatedFloat(marketIndex, user); if (floatToMint &gt; 0) {   // Set the user has claimed up until now, stops them setting this forward   userIndexOfLastClaimedReward[marketIndex][user] = latestRewardIndex[marketIndex];    _mintFloat(user, floatToMint);   emit FloatMinted(user, marketIndex, floatToMint); }  } /*   @notice Mints float owed to a user for multiple markets, since they last minted for those markets.   @param marketIndexes Identifiers for the markets.   @param user The address of the user.    /   function _mintAccumulatedFloatMulti(uint32[] calldata marketIndexes, address user) internal virtual {     uint256 floatTotal = 0;     for (uint256 i = 0; i &lt; marketIndexes.length; i++) {       uint256 floatToMint = _calculateAccumulatedFloat(marketIndexes[i], user);   if (floatToMint &gt; 0) {     // Set the user has claimed up until now, stops them setting this forward     userIndexOfLastClaimedReward[marketIndexes[i]][user] = latestRewardIndex[marketIndexes[i]];      floatTotal += floatToMint;      emit FloatMinted(user, marketIndexes[i], floatToMint);   } } if (floatTotal &gt; 0) {   _mintFloat(user, floatTotal); }  } /*   @notice Mints outstanding float for msg.sender.   @param marketIndexes Identifiers for the markets for which to mint float.    /   function claimFloatCustom(uint32[] calldata marketIndexes) external {     ILongShort(longShort).updateSystemStateMulti(marketIndexes);     _mintAccumulatedFloatMulti(marketIndexes, msg.sender);   } /*   @notice Mints outstanding float on behalf of another user.   @param marketIndexes Identifiers for the markets for which to mint float.   @param user The address of the user.    /   function claimFloatCustomFor(uint32[] calldata marketIndexes, address user) external {     // Unbounded loop - users are responsible for paying their own gas costs on these and it doesn't effect the rest of the system.     // No need to impose limit.     ILongShort(longShort).updateSystemStateMulti(marketIndexes);     _mintAccumulatedFloatMulti(marketIndexes, user);   } /╔═══════════════════════╗     ║        STAKING        ║     ╚═══════════════════════╝/ /*   @notice A user with synthetic tokens stakes by calling stake on the token   contract which calls this function. We need to first update the   state of the LongShort contract for this market before staking to correctly calculate user rewards.   @param amount Amount to stake.   @param from Address to stake for.   /   function stakeFromUser(address from, uint256 amount) public virtual override onlyValidSynthetic((msg.sender)) {     ILongShort(longShort).updateSystemState(marketIndexOfToken[(msg.sender)]);     _stake((msg.sender), amount, from);   } /*   @dev Internal logic for staking.   @param token Address of the token for which to stake.   @param amount Amount to stake.   @param user Address to stake for.   /   function _stake(     address token,     uint256 amount,     address user   ) internal virtual {     uint32 marketIndex = marketIndexOfToken[token]; // If they already have staked and have rewards due, mint these. if (   userIndexOfLastClaimedReward[marketIndex][user] != 0 &amp;&amp;   userIndexOfLastClaimedReward[marketIndex][user] &lt; latestRewardIndex[marketIndex] ) {   _mintAccumulatedFloat(marketIndex, user); }  userAmountStaked[token][user] = userAmountStaked[token][user] + amount;  userIndexOfLastClaimedReward[marketIndex][user] = latestRewardIndex[marketIndex];  emit StakeAdded(user, address(token), amount, userIndexOfLastClaimedReward[marketIndex][user]);  } /*   @notice Allows users to shift their staked tokens from one side of the market to    the other at the next price.   @param amountSyntheticTokensToShift Amount of tokens to shift.   @param marketIndex Identifier for the market.   @param isShiftFromLong Whether the shift is from long to short or short to long.   /   function shiftTokens(     uint256 amountSyntheticTokensToShift,     uint32 marketIndex,     bool isShiftFromLong   ) external virtual {     address token = syntheticTokens[marketIndex][isShiftFromLong];     require(userAmountStaked[token][msg.sender] &gt;= amountSyntheticTokensToShift, "Not enough tokens to shift"); // If the user has outstanding token shift that have already been confirmed in the LongShort // contract, execute them first. if (   userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] != 0 &amp;&amp;   userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] &lt;   batched_stakerNextTokenShiftIndex[marketIndex] ) {   _mintAccumulatedFloat(marketIndex, msg.sender); }  if (isShiftFromLong) {   ILongShort(longShort).shiftPositionFromLongNextPrice(marketIndex, amountSyntheticTokensToShift);   userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][     msg.sender   ] += amountSyntheticTokensToShift; } else {   ILongShort(longShort).shiftPositionFromShortNextPrice(marketIndex, amountSyntheticTokensToShift);   userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][     msg.sender   ] += amountSyntheticTokensToShift; }  userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] = batched_stakerNextTokenShiftIndex[   marketIndex ];  } /╔════════════════════════════╗     ║    WITHDRAWAL &amp; MINTING    ║     ╚════════════════════════════╝/ /*   @notice Internal logic for withdrawing stakes.   @dev Mint user any outstanding float before withdrawing.   @param marketIndex Market index of token.   @param amount Amount to withdraw.   @param token Synthetic token that was staked.   /   function _withdraw(     uint32 marketIndex,     address token,     uint256 amount   ) internal virtual {     require(userAmountStaked[token][msg.sender] &gt; 0, "nothing to withdraw");     _mintAccumulatedFloat(marketIndex, msg.sender); userAmountStaked[token][msg.sender] = userAmountStaked[token][msg.sender] - amount;  uint256 amountFees = (amount * marketUnstakeFee_e18[marketIndex]) / 1e18;  IERC20(token).transfer(floatTreasury, amountFees); IERC20(token).transfer(msg.sender, amount - amountFees);  emit StakeWithdrawn(msg.sender, token, amount);  } /*   @notice Withdraw function. Allows users to unstake.   @param amount Amount to withdraw.   @param token Address of the token for which to withdraw.   /   function withdraw(address token, uint256 amount) external {     ILongShort(longShort).updateSystemState(marketIndexOfToken[token]); uint32 marketIndex = marketIndexOfToken[token];  _withdraw(marketIndex, token, amount);  if (userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] &gt; 0) {   // If they still have outstanding shifts after minting float, then check   // that they don't withdraw more than their shifts allow.   uint256 amountToShiftForThisToken = syntheticTokens[marketIndex][true] == token     ? userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][msg.sender]     : userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][msg.sender];    require(     userAmountStaked[token][msg.sender] &gt;= amountToShiftForThisToken,     "Outstanding next price stake shifts too great"   ); }  } /*   @notice Allows users to withdraw their entire stake for a token.   @param token Address of the token for which to withdraw.   /   function withdrawAll(address token) external {     ILongShort(longShort).updateSystemState(marketIndexOfToken[token]); uint32 marketIndex = marketIndexOfToken[token];  uint256 amountToShiftForThisToken = syntheticTokens[marketIndex][true] == token   ? userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][msg.sender]   : userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][msg.sender];  _withdraw(marketIndex, token, userAmountStaked[token][msg.sender] - amountToShiftForThisToken);  } } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-17-08 08:01:17 INFO] Chief Executive Officer: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: BUSL-1.1

pragma solidity 0.8.3;

import "@openzeppelin/contracts-upgradeable/token/ERC20/presets/ERC20PresetMinterPauserUpgradeable.sol";

import "./interfaces/IFloatToken.sol";
import "./interfaces/ILongShort.sol";
import "./interfaces/IStaker.sol";
import "./interfaces/ISyntheticToken.sol";

contract Staker is IStaker, Initializable {
  /*╔═════════════════════════════╗
    ║          VARIABLES          ║
    ╚═════════════════════════════╝*/

  /* ══════ Fixed-precision constants ══════ */
  uint256 public constant FLOAT_ISSUANCE_FIXED_DECIMAL = 1e42;
  // 2^52 ~= 4.5e15
  // With an exponent of 5, the largest total liquidity possible in a market (to avoid integer overflow on exponentiation) is ~10^31 or 10 Trillion (10^13)
  // NOTE: this also means if the total market value is less than 2^52 there will be a division by zero error
  uint256 public constant safeExponentBitShifting = 52;

  /* ══════ Global state ══════ */
  address public admin;
  address public floatCapital;
  address public floatTreasury;
  uint256 public floatPercentage;

  address public longShort;
  address public floatToken;

  /* ══════ Market specific ══════ */
  mapping(uint32 => uint256) public marketLaunchIncentive_period; // seconds
  mapping(uint32 => uint256) public marketLaunchIncentive_multipliers; // e18 scale
  mapping(uint32 => uint256) public marketUnstakeFee_e18;
  mapping(uint32 => uint256) public balanceIncentiveCurve_exponent;
  mapping(uint32 => int256) public balanceIncentiveCurve_equilibriumOffset;

  mapping(uint32 => mapping(bool => address)) public syntheticTokens;

  mapping(address => uint32) public marketIndexOfToken;

  /* ══════ Reward specific ══════ */
  mapping(uint32 => uint256) public latestRewardIndex;
  mapping(uint32 => mapping(uint256 => AccumulativeIssuancePerStakedSynthSnapshot))
    public accumulativeFloatPerSyntheticTokenSnapshots;
  struct AccumulativeIssuancePerStakedSynthSnapshot {
    uint256 timestamp;
    uint256 accumulativeFloatPerSyntheticToken_long;
    uint256 accumulativeFloatPerSyntheticToken_short;
  }

  /* ══════ User specific ══════ */
  mapping(uint32 => mapping(address => uint256)) public userIndexOfLastClaimedReward;
  mapping(address => mapping(address => uint256)) public userAmountStaked;

  /* ══════ Token shift management specific ══════ */
  mapping(uint32 => uint256) public batched_stakerNextTokenShiftIndex;
  /**
  @notice Used to link a token shift to a staker state
  @dev tokenShiftIndex => accumulativeFloatIssuanceSnapshotIndex
    POSSIBLE OPTIMIZATION - could pack stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping and stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping into a struct of two uint128 for storage space optimization.
  */
  mapping(uint256 => uint256) public stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping;
  /// @notice Used to fetch the price from LongShort at that point in time
  /// @dev tokenShiftIndex => longShortMarketPriceSnapshotIndex
  mapping(uint256 => uint256) public stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping;
  /// @dev marketIndex => usersAddress => stakerTokenShiftIndex
  mapping(uint32 => mapping(address => uint256)) public userNextPrice_stakedSyntheticTokenShiftIndex;
  /// @dev marketIndex => usersAddress => amountUserRequestedToShiftAwayFromLongOnNextUpdate
  mapping(uint32 => mapping(address => uint256)) public userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long;
  /// @dev marketIndex => usersAddress => amountUserRequestedToShiftAwayFromShortOnNextUpdate
  mapping(uint32 => mapping(address => uint256)) public userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short;

  /*╔════════════════════════════╗
    ║           EVENTS           ║
    ╚════════════════════════════╝*/

  event StakerV1(
    address admin,
    address floatTreasury,
    address floatCapital,
    address floatToken,
    uint256 floatPercentage
  );

  event MarketAddedToStaker(
    uint32 marketIndex,
    uint256 exitFee_e18,
    uint256 period,
    uint256 multiplier,
    uint256 balanceIncentiveExponent,
    int256 balanceIncentiveEquilibriumOffset
  );

  event AccumulativeIssuancePerStakedSynthSnapshotCreated(
    uint32 marketIndex,
    uint256 accumulativeFloatIssuanceSnapshotIndex,
    uint256 accumulativeLong,
    uint256 accumulativeShort
  );

  event StakeAdded(address user, address token, uint256 amount, uint256 lastMintIndex);

  event StakeWithdrawn(address user, address token, uint256 amount);

  // Note: the `amountFloatMinted` isn't strictly needed by the graph, but it is good to add it to validate calculations are accurate.
  event FloatMinted(address user, uint32 marketIndex, uint256 amountFloatMinted);

  event MarketLaunchIncentiveParametersChanges(uint32 marketIndex, uint256 period, uint256 multiplier);

  event StakeWithdrawalFeeUpdated(uint32 marketIndex, uint256 stakeWithdralFee);

  event BalanceIncentiveExponentUpdated(uint32 marketIndex, uint256 balanceIncentiveExponent);

  event BalanceIncentiveEquilibriumOffsetUpdated(uint32 marketIndex, int256 balanceIncentiveEquilibriumOffset);

  event FloatPercentageUpdated(uint256 floatPercentage);

  event SyntheticTokensShifted();

  event ChangeAdmin(address newAdmin);

  /*╔═════════════════════════════╗
    ║          MODIFIERS          ║
    ╚═════════════════════════════╝*/

  function onlyAdminModifierLogic() internal virtual {
    require(msg.sender == admin, "not admin");
  }

  modifier onlyAdmin() {
    onlyAdminModifierLogic();
    _;
  }

  function onlyValidSyntheticModifierLogic(address _synth) internal virtual {
    require(marketIndexOfToken[_synth] != 0, "not valid synth");
  }

  modifier onlyValidSynthetic(address _synth) {
    onlyValidSyntheticModifierLogic(_synth);
    _;
  }

  function onlyValidMarketModifierLogic(uint32 marketIndex) internal virtual {
    require(address(syntheticTokens[marketIndex][true]) != address(0), "not valid market");
  }

  modifier onlyValidMarket(uint32 marketIndex) {
    onlyValidMarketModifierLogic(marketIndex);
    _;
  }

  function onlyLongShortModifierLogic() internal virtual {
    require(msg.sender == address(longShort), "not long short");
  }

  modifier onlyLongShort() {
    onlyLongShortModifierLogic();
    _;
  }

  /*╔═════════════════════════════╗
    ║       CONTRACT SET-UP       ║
    ╚═════════════════════════════╝*/

  /**
  @notice Initializes the contract.
  @dev Calls OpenZeppelin's initializer modifier.
  @param _admin Address of the admin role.
  @param _longShort Address of the LongShort contract, a deployed LongShort.sol
  @param _floatToken Address of the Float token earned by staking.
  @param _floatTreasury Address of the treasury contract for managing fees.
  @param _floatCapital Address of the contract which earns a fixed percentage of Float.
  @param _floatPercentage Determines the float percentage that gets minted for Float Capital, base 1e18.
  */
  function initialize(
    address _admin,
    address _longShort,
    address _floatToken,
    address _floatTreasury,
    address _floatCapital,
    uint256 _floatPercentage
  ) external virtual initializer {
    admin = _admin;
    floatCapital = _floatCapital;
    floatTreasury = _floatTreasury;
    longShort = _longShort;
    floatToken = _floatToken;

    _changeFloatPercentage(_floatPercentage);

    emit StakerV1(_admin, _floatTreasury, _floatCapital, _floatToken, _floatPercentage);
  }

  /*╔═══════════════════╗
    ║       ADMIN       ║
    ╚═══════════════════╝*/

  /** 
  @notice Changes admin for the contract
  @param _admin The address of the new admin.
  */
  function changeAdmin(address _admin) external onlyAdmin {
    admin = _admin;
    emit ChangeAdmin(_admin);
  }

  /// @dev Logic for changeFloatPercentage
  function _changeFloatPercentage(uint256 newFloatPercentage) internal virtual {
    require(newFloatPercentage <= 1e18 && newFloatPercentage > 0); // less than or equal to 100% and greater than 0%
    floatPercentage = newFloatPercentage;
  }

  /**
  @notice Changes percentage of float that is minted for float capital.
  @param newFloatPercentage The new float percentage in base 1e18.
  */
  function changeFloatPercentage(uint256 newFloatPercentage) external onlyAdmin {
    _changeFloatPercentage(newFloatPercentage);
    emit FloatPercentageUpdated(newFloatPercentage);
  }

  /// @dev Logic for changeUnstakeFee
  function _changeUnstakeFee(uint32 marketIndex, uint256 newMarketUnstakeFee_e18) internal virtual {
    require(newMarketUnstakeFee_e18 <= 5e16); // Explicitely stating 5% fee as the max fee possible.
    marketUnstakeFee_e18[marketIndex] = newMarketUnstakeFee_e18;
  }

  /**
  @notice Changes unstake fee for a market
  @param marketIndex Identifies the market.
  @param newMarketUnstakeFee_e18 The new unstake fee.
  */
  function changeUnstakeFee(uint32 marketIndex, uint256 newMarketUnstakeFee_e18) external onlyAdmin {
    _changeUnstakeFee(marketIndex, newMarketUnstakeFee_e18);
    emit StakeWithdrawalFeeUpdated(marketIndex, newMarketUnstakeFee_e18);
  }

  /// @dev Logic for changeMarketLaunchIncentiveParameters
  function _changeMarketLaunchIncentiveParameters(
    uint32 marketIndex,
    uint256 period,
    uint256 initialMultiplier
  ) internal virtual {
    require(initialMultiplier >= 1e18, "marketLaunchIncentiveMultiplier must be >= 1e18");

    marketLaunchIncentive_period[marketIndex] = period;
    marketLaunchIncentive_multipliers[marketIndex] = initialMultiplier;
  }

  /**
  @notice Changes the market launch incentive parameters for a market
  @param marketIndex Identifies the market.
  @param period The new period for which float token generation should be boosted.
  @param initialMultiplier The new multiplier on Float generation.
  */
  function changeMarketLaunchIncentiveParameters(
    uint32 marketIndex,
    uint256 period,
    uint256 initialMultiplier
  ) external onlyAdmin {
    _changeMarketLaunchIncentiveParameters(marketIndex, period, initialMultiplier);

    emit MarketLaunchIncentiveParametersChanges(marketIndex, period, initialMultiplier);
  }

  /// @dev Logic for changeBalanceIncentiveExponent
  function _changeBalanceIncentiveExponent(uint32 marketIndex, uint256 _balanceIncentiveCurve_exponent)
    internal
    virtual
  {
    require(
      // The exponent has to be less than 5 in these versions of the contracts.
      _balanceIncentiveCurve_exponent > 0 && _balanceIncentiveCurve_exponent < 6,
      "balanceIncentiveCurve_exponent out of bounds"
    );

    balanceIncentiveCurve_exponent[marketIndex] = _balanceIncentiveCurve_exponent;
  }

  /** 
  @notice Changes the balance incentive exponent for a market
  @param marketIndex Identifies the market.
  @param _balanceIncentiveCurve_exponent The new exponent for the curve.
  */
  function changeBalanceIncentiveExponent(uint32 marketIndex, uint256 _balanceIncentiveCurve_exponent)
    external
    onlyAdmin
  {
    _changeBalanceIncentiveExponent(marketIndex, _balanceIncentiveCurve_exponent);

    emit BalanceIncentiveExponentUpdated(marketIndex, _balanceIncentiveCurve_exponent);
  }

  /// @dev Logic for changeBalanceIncentiveEquilibriumOffset
  function _changeBalanceIncentiveEquilibriumOffset(uint32 marketIndex, int256 _balanceIncentiveCurve_equilibriumOffset)
    internal
    virtual
  {
    // Unreasonable that we would ever shift this more than 90% either way
    require(
      _balanceIncentiveCurve_equilibriumOffset > -9e17 && _balanceIncentiveCurve_equilibriumOffset < 9e17,
      "balanceIncentiveCurve_equilibriumOffset out of bounds"
    );

    balanceIncentiveCurve_equilibriumOffset[marketIndex] = _balanceIncentiveCurve_equilibriumOffset;
  }

  /**
  @notice Changes the balance incentive curve equilibrium offset for a market
  @param marketIndex Identifies the market.
  @param _balanceIncentiveCurve_equilibriumOffset The new offset.
  */
  function changeBalanceIncentiveEquilibriumOffset(uint32 marketIndex, int256 _balanceIncentiveCurve_equilibriumOffset)
    external
    onlyAdmin
  {
    _changeBalanceIncentiveEquilibriumOffset(marketIndex, _balanceIncentiveCurve_equilibriumOffset);

    emit BalanceIncentiveEquilibriumOffsetUpdated(marketIndex, _balanceIncentiveCurve_equilibriumOffset);
  }

  /*╔═════════════════════════════╗
    ║        STAKING SETUP        ║
    ╚═════════════════════════════╝*/

  /**
  @notice Sets this contract to track staking for a market in LongShort.sol
  @param marketIndex Identifies the market.
  @param longToken Address of the long token for the market.
  @param shortToken Address of the short token for the market.
  @param kInitialMultiplier Initial boost on float generation for the market.
  @param kPeriod Period which the boost should last.
  @param unstakeFee_e18 Percentage of tokens that are levied on unstaking in base 1e18.
  @param _balanceIncentiveCurve_exponent Exponent for balance curve (see _calculateFloatPerSecond)
  @param _balanceIncentiveCurve_equilibriumOffset Offset for balance curve (see _calculateFloatPerSecond)
  */
  function addNewStakingFund(
    uint32 marketIndex,
    address longToken,
    address shortToken,
    uint256 kInitialMultiplier,
    uint256 kPeriod,
    uint256 unstakeFee_e18,
    uint256 _balanceIncentiveCurve_exponent,
    int256 _balanceIncentiveCurve_equilibriumOffset
  ) external override onlyLongShort {
    marketIndexOfToken[longToken] = marketIndex;
    marketIndexOfToken[shortToken] = marketIndex;

    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].timestamp = block.timestamp;
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].accumulativeFloatPerSyntheticToken_long = 0;
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].accumulativeFloatPerSyntheticToken_short = 0;

    syntheticTokens[marketIndex][true] = longToken;
    syntheticTokens[marketIndex][false] = shortToken;

    _changeBalanceIncentiveExponent(marketIndex, _balanceIncentiveCurve_exponent);
    _changeBalanceIncentiveEquilibriumOffset(marketIndex, _balanceIncentiveCurve_equilibriumOffset);
    _changeMarketLaunchIncentiveParameters(marketIndex, kPeriod, kInitialMultiplier);

    _changeUnstakeFee(marketIndex, unstakeFee_e18);

    // Set this value to one initially - 0 is a null value and thus potentially bug prone.
    batched_stakerNextTokenShiftIndex[marketIndex] = 1;

    emit MarketAddedToStaker(
      marketIndex,
      unstakeFee_e18,
      kPeriod,
      kInitialMultiplier,
      _balanceIncentiveCurve_exponent,
      _balanceIncentiveCurve_equilibriumOffset
    );

    emit AccumulativeIssuancePerStakedSynthSnapshotCreated(marketIndex, 0, 0, 0);
  }

  /*╔═════════════════════════════════════════════════════════════════════════╗
    ║    GLOBAL FLT REWARD ACCUMULATION CALCULATION AND TRACKING FUNCTIONS    ║
    ╚═════════════════════════════════════════════════════════════════════════╝*/

  /**
  @notice Returns the K factor parameters for the given market with sensible
  defaults if they haven't been set yet.
  @param marketIndex The market to change the parameters for.
  @return period The period for which the k factor applies for in seconds.
  @return multiplier The multiplier on Float generation in this period.
  */
  function _getMarketLaunchIncentiveParameters(uint32 marketIndex)
    internal
    view
    virtual
    returns (uint256 period, uint256 multiplier)
  {
    period = marketLaunchIncentive_period[marketIndex];
    multiplier = marketLaunchIncentive_multipliers[marketIndex];

    if (multiplier < 1e18) {
      multiplier = 1e18; // multiplier of 1 by default
    }
  }

  /** 
  @notice Returns the extent to which a markets float generation should be adjusted
  based on the market's launch incentive parameters. Should start at multiplier
  then linearly change to 1e18 over time.
  @param marketIndex Identifies the market.
  @return k The calculated modifier for float generation.
  */
  function _getKValue(uint32 marketIndex) internal view virtual returns (uint256) {
    // Parameters controlling the float issuance multiplier.
    (uint256 kPeriod, uint256 kInitialMultiplier) = _getMarketLaunchIncentiveParameters(marketIndex);

    // Sanity check - under normal circumstances, the multipliers should
    // *never* be set to a value < 1e18, as there are guards against this.
    assert(kInitialMultiplier >= 1e18);

    uint256 initialTimestamp = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].timestamp;

    if (block.timestamp - initialTimestamp <= kPeriod) {
      return kInitialMultiplier - (((kInitialMultiplier - 1e18) * (block.timestamp - initialTimestamp)) / kPeriod);
    } else {
      return 1e18;
    }
  }

  /*
  @notice Computes the number of float tokens a user earns per second for
  every long/short synthetic token they've staked. The returned value has
  a fixed decimal scale of 1e42 (!!!) for numerical stability. The return
  values are float per second per synthetic token (hence the requirement
  to multiply by price)
  @dev to see below math in latex form see TODO add link
  to interact with the equations see https://www.desmos.com/calculator/optkaxyihr
  @param marketIndex The market referred to.
  @param longPrice Price of the synthetic long token in units of payment token
  @param shortPrice Price of the synthetic short token in units of payment token
  @param longValue Amount of payment token in the long side of the market
  @param shortValue Amount of payment token in the short side of the market
  @return longFloatPerSecond Float token per second per long synthetic token
  @return shortFloatPerSecond Float token per second per short synthetic token
   */
  function _calculateFloatPerSecond(
    uint32 marketIndex,
    uint256 longPrice,
    uint256 shortPrice,
    uint256 longValue,
    uint256 shortValue
  ) internal view virtual returns (uint256 longFloatPerSecond, uint256 shortFloatPerSecond) {
    // A float issuance multiplier that starts high and decreases linearly
    // over time to a value of 1. This incentivises users to stake early.
    uint256 k = _getKValue(marketIndex);

    uint256 totalLocked = (longValue + shortValue);

    // we need to scale this number by the totalLocked so that the offset remains consistent accross market size

    int256 equilibriumOffsetMarketScaled = (balanceIncentiveCurve_equilibriumOffset[marketIndex] *
      int256(totalLocked)) / 2e18;

    uint256 denominator = ((totalLocked >> safeExponentBitShifting)**balanceIncentiveCurve_exponent[marketIndex]);

    // Float is scaled by the percentage of the total market value held in
    // the opposite position. This incentivises users to stake on the
    // weaker position.
    if (int256(shortValue) - equilibriumOffsetMarketScaled < int256(longValue)) {
      if (equilibriumOffsetMarketScaled >= int256(shortValue)) {
        // edge case: imbalanced far past the equilibrium offset - full rewards go to short token
        //            extremeley unlikely to happen in practice
        return (0, 1e18 * k * shortPrice);
      }

      uint256 numerator = (uint256(int256(shortValue) - equilibriumOffsetMarketScaled) >>
        (safeExponentBitShifting - 1))**balanceIncentiveCurve_exponent[marketIndex];

      // NOTE: `x * 5e17` == `(x * 10e18) / 2`
      uint256 longRewardUnscaled = (numerator * 5e17) / denominator;
      uint256 shortRewardUnscaled = 1e18 - longRewardUnscaled;

      return ((longRewardUnscaled * k * longPrice) / 1e18, (shortRewardUnscaled * k * shortPrice) / 1e18);
    } else {
      if (-equilibriumOffsetMarketScaled >= int256(longValue)) {
        // edge case: imbalanced far past the equilibrium offset - full rewards go to long token
        //            extremeley unlikely to happen in practice
        return (1e18 * k * longPrice, 0);
      }

      uint256 numerator = (uint256(int256(longValue) + equilibriumOffsetMarketScaled) >>
        (safeExponentBitShifting - 1))**balanceIncentiveCurve_exponent[marketIndex];

      // NOTE: `x * 5e17` == `(x * 10e18) / 2`
      uint256 shortRewardUnscaled = (numerator * 5e17) / denominator;
      uint256 longRewardUnscaled = 1e18 - shortRewardUnscaled;

      return ((longRewardUnscaled * k * longPrice) / 1e18, (shortRewardUnscaled * k * shortPrice) / 1e18);
    }
  }

  /**
  @notice Computes the time since last accumulativeIssuancePerStakedSynthSnapshot for the given market in seconds.
  @param marketIndex The market referred to.
  @return The time difference in seconds
  */
  function _calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(uint32 marketIndex)
    internal
    view
    virtual
    returns (uint256)
  {
    return
      block.timestamp -
      accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]].timestamp;
  }

  /**
  @notice Computes new cumulative sum of 'r' value since last accumulativeIssuancePerStakedSynthSnapshot. We use
  cumulative 'r' value to avoid looping during issuance. Note that the
  cumulative sum is kept in 1e42 scale (!!!) to avoid numerical issues.
  @param shortValue The value locked in the short side of the market.
  @param longValue The value locked in the long side of the market.
  @param shortPrice The price of the short token as defined in LongShort.sol
  @param longPrice The price of the long token as defined in LongShort.sol
  @param marketIndex An identifier for the market.
  @return longCumulativeRates The long cumulative sum.
  @return shortCumulativeRates The short cumulative sum.
  */
  function _calculateNewCumulativeIssuancePerStakedSynth(
    uint32 marketIndex,
    uint256 longPrice,
    uint256 shortPrice,
    uint256 longValue,
    uint256 shortValue
  ) internal view virtual returns (uint256 longCumulativeRates, uint256 shortCumulativeRates) {
    // Compute the current 'r' value for float issuance per second.
    (uint256 longFloatPerSecond, uint256 shortFloatPerSecond) = _calculateFloatPerSecond(
      marketIndex,
      longPrice,
      shortPrice,
      longValue,
      shortValue
    );

    // Compute time since last accumulativeIssuancePerStakedSynthSnapshot for the given token.
    uint256 timeDelta = _calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(marketIndex);

    // Compute new cumulative 'r' value total.
    return (
      accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]]
      .accumulativeFloatPerSyntheticToken_long + (timeDelta * longFloatPerSecond),
      accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]]
      .accumulativeFloatPerSyntheticToken_short + (timeDelta * shortFloatPerSecond)
    );
  }

  /**
  @notice Creates a new accumulativeIssuancePerStakedSynthSnapshot for the given token and updates indexes.
  @param shortValue The value locked in the short side of the market.
  @param longValue The value locked in the long side of the market.
  @param shortPrice The price of the short token as defined in LongShort.sol
  @param longPrice The price of the long token as defined in LongShort.sol
  @param marketIndex An identifier for the market.
  */
  function _setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot(
    uint32 marketIndex,
    uint256 longPrice,
    uint256 shortPrice,
    uint256 longValue,
    uint256 shortValue
  ) internal virtual {
    (
      uint256 newLongAccumulativeValue,
      uint256 newShortAccumulativeValue
    ) = _calculateNewCumulativeIssuancePerStakedSynth(marketIndex, longPrice, shortPrice, longValue, shortValue);

    uint256 newIndex = latestRewardIndex[marketIndex] + 1;

    // Set cumulative 'r' value on new accumulativeIssuancePerStakedSynthSnapshot.
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex]
    .accumulativeFloatPerSyntheticToken_long = newLongAccumulativeValue;
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex]
    .accumulativeFloatPerSyntheticToken_short = newShortAccumulativeValue;

    // Set timestamp on new accumulativeIssuancePerStakedSynthSnapshot.
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex].timestamp = block.timestamp;

    // Update latest index to point to new accumulativeIssuancePerStakedSynthSnapshot.
    latestRewardIndex[marketIndex] = newIndex;

    emit AccumulativeIssuancePerStakedSynthSnapshotCreated(
      marketIndex,
      newIndex,
      newLongAccumulativeValue,
      newShortAccumulativeValue
    );
  }

  /**
  @notice Adds new accumulativeIssuancePerStakedSynthSnapshots for the given long/short tokens. Called by the
  ILongShort contract whenever there is a state change for a market.
  @param stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted Mapping from this contract's shifts to LongShort.sols next price snapshots.
  @param shortValue The value locked in the short side of the market.
  @param longValue The value locked in the long side of the market.
  @param shortPrice The price of the short token as defined in LongShort.sol
  @param longPrice The price of the long token as defined in LongShort.sol
  @param marketIndex An identifier for the market.
  */
  function pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(
    uint32 marketIndex,
    uint256 longPrice,
    uint256 shortPrice,
    uint256 longValue,
    uint256 shortValue,
    uint256 stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted // This value should be ALWAYS be zero if no shift occured
  ) external override onlyLongShort {
    // Only add a new accumulativeIssuancePerStakedSynthSnapshot if some time has passed.

    // the `stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted` value will be 0 if there is no staker related action in an executed batch
    if (stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted > 0) {
      stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[
        batched_stakerNextTokenShiftIndex[marketIndex]
      ] = stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted;
      stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[
        batched_stakerNextTokenShiftIndex[marketIndex]
      ] = latestRewardIndex[marketIndex] + 1;
      batched_stakerNextTokenShiftIndex[marketIndex] += 1;

      emit SyntheticTokensShifted();
    }

    // Time delta is fetched twice in below code, can pass through? Which is less gas?
    if (_calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(marketIndex) > 0) {
      _setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot(
        marketIndex,
        longPrice,
        shortPrice,
        longValue,
        shortValue
      );
    }
  }

  /*╔═══════════════════════════════════╗
    ║    USER REWARD STATE FUNCTIONS    ║
    ╚═══════════════════════════════════╝*/

  /// @dev Calculates the accumulated float in a specific range of staker snapshots
  function _calculateAccumulatedFloatInRange(
    uint32 marketIndex,
    uint256 amountStakedLong,
    uint256 amountStakedShort,
    uint256 rewardIndexFrom,
    uint256 rewardIndexTo
  ) internal view virtual returns (uint256 floatReward) {
    if (amountStakedLong > 0) {
      uint256 accumDeltaLong = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexTo]
      .accumulativeFloatPerSyntheticToken_long -
        accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexFrom]
        .accumulativeFloatPerSyntheticToken_long;
      floatReward += (accumDeltaLong * amountStakedLong) / FLOAT_ISSUANCE_FIXED_DECIMAL;
    }

    if (amountStakedShort > 0) {
      uint256 accumDeltaShort = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexTo]
      .accumulativeFloatPerSyntheticToken_short -
        accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexFrom]
        .accumulativeFloatPerSyntheticToken_short;
      floatReward += (accumDeltaShort * amountStakedShort) / FLOAT_ISSUANCE_FIXED_DECIMAL;
    }
  }

  /** 
  @notice Calculates float owed to the user since the user last minted float for a market.
  @param marketIndex Identifier for the market which the user staked in.
  @param user The address of the user.
  @return floatReward The amount of float owed.
   */
  function _calculateAccumulatedFloat(uint32 marketIndex, address user) internal virtual returns (uint256 floatReward) {
    address longToken = syntheticTokens[marketIndex][true];
    address shortToken = syntheticTokens[marketIndex][false];

    uint256 amountStakedLong = userAmountStaked[longToken][user];
    uint256 amountStakedShort = userAmountStaked[shortToken][user];

    uint256 usersLastRewardIndex = userIndexOfLastClaimedReward[marketIndex][user];

    // Don't do the calculation and return zero immediately if there is no change
    if (usersLastRewardIndex == latestRewardIndex[marketIndex]) {
      return 0;
    }

    uint256 usersShiftIndex = userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][user];
    // if there is a change in the users tokens held due to a token shift (or possibly another action in the future)
    if (usersShiftIndex > 0 && usersShiftIndex < batched_stakerNextTokenShiftIndex[marketIndex]) {
      floatReward = _calculateAccumulatedFloatInRange(
        marketIndex,
        amountStakedLong,
        amountStakedShort,
        usersLastRewardIndex,
        stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[usersShiftIndex]
      );

      // Update the users balances
      if (userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user] > 0) {
        amountStakedShort += ILongShort(longShort).getAmountSyntheticTokenToMintOnTargetSide(
          marketIndex,
          userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user],
          true,
          stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[usersShiftIndex]
        );

        amountStakedLong -= userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user];
        userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user] = 0;
      }

      if (userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user] > 0) {
        amountStakedLong += ILongShort(longShort).getAmountSyntheticTokenToMintOnTargetSide(
          marketIndex,
          userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user],
          false,
          stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[usersShiftIndex]
        );

        amountStakedShort -= userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user];
        userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user] = 0;
      }

      // Save the users updated staked amounts
      userAmountStaked[longToken][user] = amountStakedLong;
      userAmountStaked[shortToken][user] = amountStakedShort;

      floatReward += _calculateAccumulatedFloatInRange(
        marketIndex,
        amountStakedLong,
        amountStakedShort,
        stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[usersShiftIndex],
        latestRewardIndex[marketIndex]
      );

      userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][user] = 0;
    } else {
      floatReward = _calculateAccumulatedFloatInRange(
        marketIndex,
        amountStakedLong,
        amountStakedShort,
        usersLastRewardIndex,
        latestRewardIndex[marketIndex]
      );
    }
  }

  /**
  @notice Mints float for a user.
  @dev Mints a fixed percentage for Float capital.
  @param user The address of the user.
  @param floatToMint The amount of float to mint.
   */
  function _mintFloat(address user, uint256 floatToMint) internal virtual {
    IFloatToken(floatToken).mint(user, floatToMint);
    IFloatToken(floatToken).mint(floatCapital, (floatToMint * floatPercentage) / 1e18);
  }

  /**
  @notice Mints float owed to a user for a market since they last minted.
  @param marketIndex An identifier for the market.
  @param user The address of the user.
   */
  function _mintAccumulatedFloat(uint32 marketIndex, address user) internal virtual {
    uint256 floatToMint = _calculateAccumulatedFloat(marketIndex, user);

    if (floatToMint > 0) {
      // Set the user has claimed up until now, stops them setting this forward
      userIndexOfLastClaimedReward[marketIndex][user] = latestRewardIndex[marketIndex];

      _mintFloat(user, floatToMint);
      emit FloatMinted(user, marketIndex, floatToMint);
    }
  }

  /**
  @notice Mints float owed to a user for multiple markets, since they last minted for those markets.
  @param marketIndexes Identifiers for the markets.
  @param user The address of the user.
   */
  function _mintAccumulatedFloatMulti(uint32[] calldata marketIndexes, address user) internal virtual {
    uint256 floatTotal = 0;
    for (uint256 i = 0; i < marketIndexes.length; i++) {
      uint256 floatToMint = _calculateAccumulatedFloat(marketIndexes[i], user);

      if (floatToMint > 0) {
        // Set the user has claimed up until now, stops them setting this forward
        userIndexOfLastClaimedReward[marketIndexes[i]][user] = latestRewardIndex[marketIndexes[i]];

        floatTotal += floatToMint;

        emit FloatMinted(user, marketIndexes[i], floatToMint);
      }
    }
    if (floatTotal > 0) {
      _mintFloat(user, floatTotal);
    }
  }

  /**
  @notice Mints outstanding float for msg.sender.
  @param marketIndexes Identifiers for the markets for which to mint float.
   */
  function claimFloatCustom(uint32[] calldata marketIndexes) external {
    ILongShort(longShort).updateSystemStateMulti(marketIndexes);
    _mintAccumulatedFloatMulti(marketIndexes, msg.sender);
  }

  /**
  @notice Mints outstanding float on behalf of another user.
  @param marketIndexes Identifiers for the markets for which to mint float.
  @param user The address of the user.
   */
  function claimFloatCustomFor(uint32[] calldata marketIndexes, address user) external {
    // Unbounded loop - users are responsible for paying their own gas costs on these and it doesn't effect the rest of the system.
    // No need to impose limit.
    ILongShort(longShort).updateSystemStateMulti(marketIndexes);
    _mintAccumulatedFloatMulti(marketIndexes, user);
  }

  /*╔═══════════════════════╗
    ║        STAKING        ║
    ╚═══════════════════════╝*/

  /**
  @notice A user with synthetic tokens stakes by calling stake on the token
  contract which calls this function. We need to first update the
  state of the LongShort contract for this market before staking to correctly calculate user rewards.
  @param amount Amount to stake.
  @param from Address to stake for.
  */
  function stakeFromUser(address from, uint256 amount) public virtual override onlyValidSynthetic((msg.sender)) {
    ILongShort(longShort).updateSystemState(marketIndexOfToken[(msg.sender)]);
    _stake((msg.sender), amount, from);
  }

  /**
  @dev Internal logic for staking.
  @param token Address of the token for which to stake.
  @param amount Amount to stake.
  @param user Address to stake for.
  */
  function _stake(
    address token,
    uint256 amount,
    address user
  ) internal virtual {
    uint32 marketIndex = marketIndexOfToken[token];

    // If they already have staked and have rewards due, mint these.
    if (
      userIndexOfLastClaimedReward[marketIndex][user] != 0 &&
      userIndexOfLastClaimedReward[marketIndex][user] < latestRewardIndex[marketIndex]
    ) {
      _mintAccumulatedFloat(marketIndex, user);
    }

    userAmountStaked[token][user] = userAmountStaked[token][user] + amount;

    userIndexOfLastClaimedReward[marketIndex][user] = latestRewardIndex[marketIndex];

    emit StakeAdded(user, address(token), amount, userIndexOfLastClaimedReward[marketIndex][user]);
  }

  /**
  @notice Allows users to shift their staked tokens from one side of the market to 
  the other at the next price.
  @param amountSyntheticTokensToShift Amount of tokens to shift.
  @param marketIndex Identifier for the market.
  @param isShiftFromLong Whether the shift is from long to short or short to long.
  */
  function shiftTokens(
    uint256 amountSyntheticTokensToShift,
    uint32 marketIndex,
    bool isShiftFromLong
  ) external virtual {
    address token = syntheticTokens[marketIndex][isShiftFromLong];
    require(userAmountStaked[token][msg.sender] >= amountSyntheticTokensToShift, "Not enough tokens to shift");

    // If the user has outstanding token shift that have already been confirmed in the LongShort
    // contract, execute them first.
    if (
      userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] != 0 &&
      userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] <
      batched_stakerNextTokenShiftIndex[marketIndex]
    ) {
      _mintAccumulatedFloat(marketIndex, msg.sender);
    }

    if (isShiftFromLong) {
      ILongShort(longShort).shiftPositionFromLongNextPrice(marketIndex, amountSyntheticTokensToShift);
      userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][
        msg.sender
      ] += amountSyntheticTokensToShift;
    } else {
      ILongShort(longShort).shiftPositionFromShortNextPrice(marketIndex, amountSyntheticTokensToShift);
      userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][
        msg.sender
      ] += amountSyntheticTokensToShift;
    }

    userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] = batched_stakerNextTokenShiftIndex[
      marketIndex
    ];
  }

  /*╔════════════════════════════╗
    ║    WITHDRAWAL & MINTING    ║
    ╚════════════════════════════╝*/

  /**
  @notice Internal logic for withdrawing stakes.
  @dev Mint user any outstanding float before withdrawing.
  @param marketIndex Market index of token.
  @param amount Amount to withdraw.
  @param token Synthetic token that was staked.
  */
  function _withdraw(
    uint32 marketIndex,
    address token,
    uint256 amount
  ) internal virtual {
    require(userAmountStaked[token][msg.sender] > 0, "nothing to withdraw");
    _mintAccumulatedFloat(marketIndex, msg.sender);

    userAmountStaked[token][msg.sender] = userAmountStaked[token][msg.sender] - amount;

    uint256 amountFees = (amount * marketUnstakeFee_e18[marketIndex]) / 1e18;

    IERC20(token).transfer(floatTreasury, amountFees);
    IERC20(token).transfer(msg.sender, amount - amountFees);

    emit StakeWithdrawn(msg.sender, token, amount);
  }

  /**
  @notice Withdraw function. Allows users to unstake.
  @param amount Amount to withdraw.
  @param token Address of the token for which to withdraw.
  */
  function withdraw(address token, uint256 amount) external {
    ILongShort(longShort).updateSystemState(marketIndexOfToken[token]);

    uint32 marketIndex = marketIndexOfToken[token];

    _withdraw(marketIndex, token, amount);

    if (userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] > 0) {
      // If they still have outstanding shifts after minting float, then check
      // that they don't withdraw more than their shifts allow.
      uint256 amountToShiftForThisToken = syntheticTokens[marketIndex][true] == token
        ? userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][msg.sender]
        : userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][msg.sender];

      require(
        userAmountStaked[token][msg.sender] >= amountToShiftForThisToken,
        "Outstanding next price stake shifts too great"
      );
    }
  }

  /**
  @notice Allows users to withdraw their entire stake for a token.
  @param token Address of the token for which to withdraw.
  */
  function withdrawAll(address token) external {
    ILongShort(longShort).updateSystemState(marketIndexOfToken[token]);

    uint32 marketIndex = marketIndexOfToken[token];

    uint256 amountToShiftForThisToken = syntheticTokens[marketIndex][true] == token
      ? userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][msg.sender]
      : userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][msg.sender];

    _withdraw(marketIndex, token, userAmountStaked[token][msg.sender] - amountToShiftForThisToken);
  }
}
.]

We excel in generating innovative approaches and enhancements for Solidity smart contract code.

Here's a Solidity contract provided by the user: "// SPDX-License-Identifier: BUSL-1.1

pragma solidity 0.8.3;

import "@openzeppelin/contracts-upgradeable/token/ERC20/presets/ERC20PresetMinterPauserUpgradeable.sol";

import "./interfaces/IFloatToken.sol";
import "./interfaces/ILongShort.sol";
import "./interfaces/IStaker.sol";
import "./interfaces/ISyntheticToken.sol";

contract Staker is IStaker, Initializable {
  /*╔═════════════════════════════╗
    ║          VARIABLES          ║
    ╚═════════════════════════════╝*/

  /* ══════ Fixed-precision constants ══════ */
  uint256 public constant FLOAT_ISSUANCE_FIXED_DECIMAL = 1e42;
  // 2^52 ~= 4.5e15
  // With an exponent of 5, the largest total liquidity possible in a market (to avoid integer overflow on exponentiation) is ~10^31 or 10 Trillion (10^13)
  // NOTE: this also means if the total market value is less than 2^52 there will be a division by zero error
  uint256 public constant safeExponentBitShifting = 52;

  /* ══════ Global state ══════ */
  address public admin;
  address public floatCapital;
  address public floatTreasury;
  uint256 public floatPercentage;

  address public longShort;
  address public floatToken;

  /* ══════ Market specific ══════ */
  mapping(uint32 => uint256) public marketLaunchIncentive_period; // seconds
  mapping(uint32 => uint256) public marketLaunchIncentive_multipliers; // e18 scale
  mapping(uint32 => uint256) public marketUnstakeFee_e18;
  mapping(uint32 => uint256) public balanceIncentiveCurve_exponent;
  mapping(uint32 => int256) public balanceIncentiveCurve_equilibriumOffset;

  mapping(uint32 => mapping(bool => address)) public syntheticTokens;

  mapping(address => uint32) public marketIndexOfToken;

  /* ══════ Reward specific ══════ */
  mapping(uint32 => uint256) public latestRewardIndex;
  mapping(uint32 => mapping(uint256 => AccumulativeIssuancePerStakedSynthSnapshot))
    public accumulativeFloatPerSyntheticTokenSnapshots;
  struct AccumulativeIssuancePerStakedSynthSnapshot {
    uint256 timestamp;
    uint256 accumulativeFloatPerSyntheticToken_long;
    uint256 accumulativeFloatPerSyntheticToken_short;
  }

  /* ══════ User specific ══════ */
  mapping(uint32 => mapping(address => uint256)) public userIndexOfLastClaimedReward;
  mapping(address => mapping(address => uint256)) public userAmountStaked;

  /* ══════ Token shift management specific ══════ */
  mapping(uint32 => uint256) public batched_stakerNextTokenShiftIndex;
  /**
  @notice Used to link a token shift to a staker state
  @dev tokenShiftIndex => accumulativeFloatIssuanceSnapshotIndex
    POSSIBLE OPTIMIZATION - could pack stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping and stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping into a struct of two uint128 for storage space optimization.
  */
  mapping(uint256 => uint256) public stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping;
  /// @notice Used to fetch the price from LongShort at that point in time
  /// @dev tokenShiftIndex => longShortMarketPriceSnapshotIndex
  mapping(uint256 => uint256) public stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping;
  /// @dev marketIndex => usersAddress => stakerTokenShiftIndex
  mapping(uint32 => mapping(address => uint256)) public userNextPrice_stakedSyntheticTokenShiftIndex;
  /// @dev marketIndex => usersAddress => amountUserRequestedToShiftAwayFromLongOnNextUpdate
  mapping(uint32 => mapping(address => uint256)) public userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long;
  /// @dev marketIndex => usersAddress => amountUserRequestedToShiftAwayFromShortOnNextUpdate
  mapping(uint32 => mapping(address => uint256)) public userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short;

  /*╔════════════════════════════╗
    ║           EVENTS           ║
    ╚════════════════════════════╝*/

  event StakerV1(
    address admin,
    address floatTreasury,
    address floatCapital,
    address floatToken,
    uint256 floatPercentage
  );

  event MarketAddedToStaker(
    uint32 marketIndex,
    uint256 exitFee_e18,
    uint256 period,
    uint256 multiplier,
    uint256 balanceIncentiveExponent,
    int256 balanceIncentiveEquilibriumOffset
  );

  event AccumulativeIssuancePerStakedSynthSnapshotCreated(
    uint32 marketIndex,
    uint256 accumulativeFloatIssuanceSnapshotIndex,
    uint256 accumulativeLong,
    uint256 accumulativeShort
  );

  event StakeAdded(address user, address token, uint256 amount, uint256 lastMintIndex);

  event StakeWithdrawn(address user, address token, uint256 amount);

  // Note: the `amountFloatMinted` isn't strictly needed by the graph, but it is good to add it to validate calculations are accurate.
  event FloatMinted(address user, uint32 marketIndex, uint256 amountFloatMinted);

  event MarketLaunchIncentiveParametersChanges(uint32 marketIndex, uint256 period, uint256 multiplier);

  event StakeWithdrawalFeeUpdated(uint32 marketIndex, uint256 stakeWithdralFee);

  event BalanceIncentiveExponentUpdated(uint32 marketIndex, uint256 balanceIncentiveExponent);

  event BalanceIncentiveEquilibriumOffsetUpdated(uint32 marketIndex, int256 balanceIncentiveEquilibriumOffset);

  event FloatPercentageUpdated(uint256 floatPercentage);

  event SyntheticTokensShifted();

  event ChangeAdmin(address newAdmin);

  /*╔═════════════════════════════╗
    ║          MODIFIERS          ║
    ╚═════════════════════════════╝*/

  function onlyAdminModifierLogic() internal virtual {
    require(msg.sender == admin, "not admin");
  }

  modifier onlyAdmin() {
    onlyAdminModifierLogic();
    _;
  }

  function onlyValidSyntheticModifierLogic(address _synth) internal virtual {
    require(marketIndexOfToken[_synth] != 0, "not valid synth");
  }

  modifier onlyValidSynthetic(address _synth) {
    onlyValidSyntheticModifierLogic(_synth);
    _;
  }

  function onlyValidMarketModifierLogic(uint32 marketIndex) internal virtual {
    require(address(syntheticTokens[marketIndex][true]) != address(0), "not valid market");
  }

  modifier onlyValidMarket(uint32 marketIndex) {
    onlyValidMarketModifierLogic(marketIndex);
    _;
  }

  function onlyLongShortModifierLogic() internal virtual {
    require(msg.sender == address(longShort), "not long short");
  }

  modifier onlyLongShort() {
    onlyLongShortModifierLogic();
    _;
  }

  /*╔═════════════════════════════╗
    ║       CONTRACT SET-UP       ║
    ╚═════════════════════════════╝*/

  /**
  @notice Initializes the contract.
  @dev Calls OpenZeppelin's initializer modifier.
  @param _admin Address of the admin role.
  @param _longShort Address of the LongShort contract, a deployed LongShort.sol
  @param _floatToken Address of the Float token earned by staking.
  @param _floatTreasury Address of the treasury contract for managing fees.
  @param _floatCapital Address of the contract which earns a fixed percentage of Float.
  @param _floatPercentage Determines the float percentage that gets minted for Float Capital, base 1e18.
  */
  function initialize(
    address _admin,
    address _longShort,
    address _floatToken,
    address _floatTreasury,
    address _floatCapital,
    uint256 _floatPercentage
  ) external virtual initializer {
    admin = _admin;
    floatCapital = _floatCapital;
    floatTreasury = _floatTreasury;
    longShort = _longShort;
    floatToken = _floatToken;

    _changeFloatPercentage(_floatPercentage);

    emit StakerV1(_admin, _floatTreasury, _floatCapital, _floatToken, _floatPercentage);
  }

  /*╔═══════════════════╗
    ║       ADMIN       ║
    ╚═══════════════════╝*/

  /** 
  @notice Changes admin for the contract
  @param _admin The address of the new admin.
  */
  function changeAdmin(address _admin) external onlyAdmin {
    admin = _admin;
    emit ChangeAdmin(_admin);
  }

  /// @dev Logic for changeFloatPercentage
  function _changeFloatPercentage(uint256 newFloatPercentage) internal virtual {
    require(newFloatPercentage <= 1e18 && newFloatPercentage > 0); // less than or equal to 100% and greater than 0%
    floatPercentage = newFloatPercentage;
  }

  /**
  @notice Changes percentage of float that is minted for float capital.
  @param newFloatPercentage The new float percentage in base 1e18.
  */
  function changeFloatPercentage(uint256 newFloatPercentage) external onlyAdmin {
    _changeFloatPercentage(newFloatPercentage);
    emit FloatPercentageUpdated(newFloatPercentage);
  }

  /// @dev Logic for changeUnstakeFee
  function _changeUnstakeFee(uint32 marketIndex, uint256 newMarketUnstakeFee_e18) internal virtual {
    require(newMarketUnstakeFee_e18 <= 5e16); // Explicitely stating 5% fee as the max fee possible.
    marketUnstakeFee_e18[marketIndex] = newMarketUnstakeFee_e18;
  }

  /**
  @notice Changes unstake fee for a market
  @param marketIndex Identifies the market.
  @param newMarketUnstakeFee_e18 The new unstake fee.
  */
  function changeUnstakeFee(uint32 marketIndex, uint256 newMarketUnstakeFee_e18) external onlyAdmin {
    _changeUnstakeFee(marketIndex, newMarketUnstakeFee_e18);
    emit StakeWithdrawalFeeUpdated(marketIndex, newMarketUnstakeFee_e18);
  }

  /// @dev Logic for changeMarketLaunchIncentiveParameters
  function _changeMarketLaunchIncentiveParameters(
    uint32 marketIndex,
    uint256 period,
    uint256 initialMultiplier
  ) internal virtual {
    require(initialMultiplier >= 1e18, "marketLaunchIncentiveMultiplier must be >= 1e18");

    marketLaunchIncentive_period[marketIndex] = period;
    marketLaunchIncentive_multipliers[marketIndex] = initialMultiplier;
  }

  /**
  @notice Changes the market launch incentive parameters for a market
  @param marketIndex Identifies the market.
  @param period The new period for which float token generation should be boosted.
  @param initialMultiplier The new multiplier on Float generation.
  */
  function changeMarketLaunchIncentiveParameters(
    uint32 marketIndex,
    uint256 period,
    uint256 initialMultiplier
  ) external onlyAdmin {
    _changeMarketLaunchIncentiveParameters(marketIndex, period, initialMultiplier);

    emit MarketLaunchIncentiveParametersChanges(marketIndex, period, initialMultiplier);
  }

  /// @dev Logic for changeBalanceIncentiveExponent
  function _changeBalanceIncentiveExponent(uint32 marketIndex, uint256 _balanceIncentiveCurve_exponent)
    internal
    virtual
  {
    require(
      // The exponent has to be less than 5 in these versions of the contracts.
      _balanceIncentiveCurve_exponent > 0 && _balanceIncentiveCurve_exponent < 6,
      "balanceIncentiveCurve_exponent out of bounds"
    );

    balanceIncentiveCurve_exponent[marketIndex] = _balanceIncentiveCurve_exponent;
  }

  /** 
  @notice Changes the balance incentive exponent for a market
  @param marketIndex Identifies the market.
  @param _balanceIncentiveCurve_exponent The new exponent for the curve.
  */
  function changeBalanceIncentiveExponent(uint32 marketIndex, uint256 _balanceIncentiveCurve_exponent)
    external
    onlyAdmin
  {
    _changeBalanceIncentiveExponent(marketIndex, _balanceIncentiveCurve_exponent);

    emit BalanceIncentiveExponentUpdated(marketIndex, _balanceIncentiveCurve_exponent);
  }

  /// @dev Logic for changeBalanceIncentiveEquilibriumOffset
  function _changeBalanceIncentiveEquilibriumOffset(uint32 marketIndex, int256 _balanceIncentiveCurve_equilibriumOffset)
    internal
    virtual
  {
    // Unreasonable that we would ever shift this more than 90% either way
    require(
      _balanceIncentiveCurve_equilibriumOffset > -9e17 && _balanceIncentiveCurve_equilibriumOffset < 9e17,
      "balanceIncentiveCurve_equilibriumOffset out of bounds"
    );

    balanceIncentiveCurve_equilibriumOffset[marketIndex] = _balanceIncentiveCurve_equilibriumOffset;
  }

  /**
  @notice Changes the balance incentive curve equilibrium offset for a market
  @param marketIndex Identifies the market.
  @param _balanceIncentiveCurve_equilibriumOffset The new offset.
  */
  function changeBalanceIncentiveEquilibriumOffset(uint32 marketIndex, int256 _balanceIncentiveCurve_equilibriumOffset)
    external
    onlyAdmin
  {
    _changeBalanceIncentiveEquilibriumOffset(marketIndex, _balanceIncentiveCurve_equilibriumOffset);

    emit BalanceIncentiveEquilibriumOffsetUpdated(marketIndex, _balanceIncentiveCurve_equilibriumOffset);
  }

  /*╔═════════════════════════════╗
    ║        STAKING SETUP        ║
    ╚═════════════════════════════╝*/

  /**
  @notice Sets this contract to track staking for a market in LongShort.sol
  @param marketIndex Identifies the market.
  @param longToken Address of the long token for the market.
  @param shortToken Address of the short token for the market.
  @param kInitialMultiplier Initial boost on float generation for the market.
  @param kPeriod Period which the boost should last.
  @param unstakeFee_e18 Percentage of tokens that are levied on unstaking in base 1e18.
  @param _balanceIncentiveCurve_exponent Exponent for balance curve (see _calculateFloatPerSecond)
  @param _balanceIncentiveCurve_equilibriumOffset Offset for balance curve (see _calculateFloatPerSecond)
  */
  function addNewStakingFund(
    uint32 marketIndex,
    address longToken,
    address shortToken,
    uint256 kInitialMultiplier,
    uint256 kPeriod,
    uint256 unstakeFee_e18,
    uint256 _balanceIncentiveCurve_exponent,
    int256 _balanceIncentiveCurve_equilibriumOffset
  ) external override onlyLongShort {
    marketIndexOfToken[longToken] = marketIndex;
    marketIndexOfToken[shortToken] = marketIndex;

    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].timestamp = block.timestamp;
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].accumulativeFloatPerSyntheticToken_long = 0;
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].accumulativeFloatPerSyntheticToken_short = 0;

    syntheticTokens[marketIndex][true] = longToken;
    syntheticTokens[marketIndex][false] = shortToken;

    _changeBalanceIncentiveExponent(marketIndex, _balanceIncentiveCurve_exponent);
    _changeBalanceIncentiveEquilibriumOffset(marketIndex, _balanceIncentiveCurve_equilibriumOffset);
    _changeMarketLaunchIncentiveParameters(marketIndex, kPeriod, kInitialMultiplier);

    _changeUnstakeFee(marketIndex, unstakeFee_e18);

    // Set this value to one initially - 0 is a null value and thus potentially bug prone.
    batched_stakerNextTokenShiftIndex[marketIndex] = 1;

    emit MarketAddedToStaker(
      marketIndex,
      unstakeFee_e18,
      kPeriod,
      kInitialMultiplier,
      _balanceIncentiveCurve_exponent,
      _balanceIncentiveCurve_equilibriumOffset
    );

    emit AccumulativeIssuancePerStakedSynthSnapshotCreated(marketIndex, 0, 0, 0);
  }

  /*╔═════════════════════════════════════════════════════════════════════════╗
    ║    GLOBAL FLT REWARD ACCUMULATION CALCULATION AND TRACKING FUNCTIONS    ║
    ╚═════════════════════════════════════════════════════════════════════════╝*/

  /**
  @notice Returns the K factor parameters for the given market with sensible
  defaults if they haven't been set yet.
  @param marketIndex The market to change the parameters for.
  @return period The period for which the k factor applies for in seconds.
  @return multiplier The multiplier on Float generation in this period.
  */
  function _getMarketLaunchIncentiveParameters(uint32 marketIndex)
    internal
    view
    virtual
    returns (uint256 period, uint256 multiplier)
  {
    period = marketLaunchIncentive_period[marketIndex];
    multiplier = marketLaunchIncentive_multipliers[marketIndex];

    if (multiplier < 1e18) {
      multiplier = 1e18; // multiplier of 1 by default
    }
  }

  /** 
  @notice Returns the extent to which a markets float generation should be adjusted
  based on the market's launch incentive parameters. Should start at multiplier
  then linearly change to 1e18 over time.
  @param marketIndex Identifies the market.
  @return k The calculated modifier for float generation.
  */
  function _getKValue(uint32 marketIndex) internal view virtual returns (uint256) {
    // Parameters controlling the float issuance multiplier.
    (uint256 kPeriod, uint256 kInitialMultiplier) = _getMarketLaunchIncentiveParameters(marketIndex);

    // Sanity check - under normal circumstances, the multipliers should
    // *never* be set to a value < 1e18, as there are guards against this.
    assert(kInitialMultiplier >= 1e18);

    uint256 initialTimestamp = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].timestamp;

    if (block.timestamp - initialTimestamp <= kPeriod) {
      return kInitialMultiplier - (((kInitialMultiplier - 1e18) * (block.timestamp - initialTimestamp)) / kPeriod);
    } else {
      return 1e18;
    }
  }

  /*
  @notice Computes the number of float tokens a user earns per second for
  every long/short synthetic token they've staked. The returned value has
  a fixed decimal scale of 1e42 (!!!) for numerical stability. The return
  values are float per second per synthetic token (hence the requirement
  to multiply by price)
  @dev to see below math in latex form see TODO add link
  to interact with the equations see https://www.desmos.com/calculator/optkaxyihr
  @param marketIndex The market referred to.
  @param longPrice Price of the synthetic long token in units of payment token
  @param shortPrice Price of the synthetic short token in units of payment token
  @param longValue Amount of payment token in the long side of the market
  @param shortValue Amount of payment token in the short side of the market
  @return longFloatPerSecond Float token per second per long synthetic token
  @return shortFloatPerSecond Float token per second per short synthetic token
   */
  function _calculateFloatPerSecond(
    uint32 marketIndex,
    uint256 longPrice,
    uint256 shortPrice,
    uint256 longValue,
    uint256 shortValue
  ) internal view virtual returns (uint256 longFloatPerSecond, uint256 shortFloatPerSecond) {
    // A float issuance multiplier that starts high and decreases linearly
    // over time to a value of 1. This incentivises users to stake early.
    uint256 k = _getKValue(marketIndex);

    uint256 totalLocked = (longValue + shortValue);

    // we need to scale this number by the totalLocked so that the offset remains consistent accross market size

    int256 equilibriumOffsetMarketScaled = (balanceIncentiveCurve_equilibriumOffset[marketIndex] *
      int256(totalLocked)) / 2e18;

    uint256 denominator = ((totalLocked >> safeExponentBitShifting)**balanceIncentiveCurve_exponent[marketIndex]);

    // Float is scaled by the percentage of the total market value held in
    // the opposite position. This incentivises users to stake on the
    // weaker position.
    if (int256(shortValue) - equilibriumOffsetMarketScaled < int256(longValue)) {
      if (equilibriumOffsetMarketScaled >= int256(shortValue)) {
        // edge case: imbalanced far past the equilibrium offset - full rewards go to short token
        //            extremeley unlikely to happen in practice
        return (0, 1e18 * k * shortPrice);
      }

      uint256 numerator = (uint256(int256(shortValue) - equilibriumOffsetMarketScaled) >>
        (safeExponentBitShifting - 1))**balanceIncentiveCurve_exponent[marketIndex];

      // NOTE: `x * 5e17` == `(x * 10e18) / 2`
      uint256 longRewardUnscaled = (numerator * 5e17) / denominator;
      uint256 shortRewardUnscaled = 1e18 - longRewardUnscaled;

      return ((longRewardUnscaled * k * longPrice) / 1e18, (shortRewardUnscaled * k * shortPrice) / 1e18);
    } else {
      if (-equilibriumOffsetMarketScaled >= int256(longValue)) {
        // edge case: imbalanced far past the equilibrium offset - full rewards go to long token
        //            extremeley unlikely to happen in practice
        return (1e18 * k * longPrice, 0);
      }

      uint256 numerator = (uint256(int256(longValue) + equilibriumOffsetMarketScaled) >>
        (safeExponentBitShifting - 1))**balanceIncentiveCurve_exponent[marketIndex];

      // NOTE: `x * 5e17` == `(x * 10e18) / 2`
      uint256 shortRewardUnscaled = (numerator * 5e17) / denominator;
      uint256 longRewardUnscaled = 1e18 - shortRewardUnscaled;

      return ((longRewardUnscaled * k * longPrice) / 1e18, (shortRewardUnscaled * k * shortPrice) / 1e18);
    }
  }

  /**
  @notice Computes the time since last accumulativeIssuancePerStakedSynthSnapshot for the given market in seconds.
  @param marketIndex The market referred to.
  @return The time difference in seconds
  */
  function _calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(uint32 marketIndex)
    internal
    view
    virtual
    returns (uint256)
  {
    return
      block.timestamp -
      accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]].timestamp;
  }

  /**
  @notice Computes new cumulative sum of 'r' value since last accumulativeIssuancePerStakedSynthSnapshot. We use
  cumulative 'r' value to avoid looping during issuance. Note that the
  cumulative sum is kept in 1e42 scale (!!!) to avoid numerical issues.
  @param shortValue The value locked in the short side of the market.
  @param longValue The value locked in the long side of the market.
  @param shortPrice The price of the short token as defined in LongShort.sol
  @param longPrice The price of the long token as defined in LongShort.sol
  @param marketIndex An identifier for the market.
  @return longCumulativeRates The long cumulative sum.
  @return shortCumulativeRates The short cumulative sum.
  */
  function _calculateNewCumulativeIssuancePerStakedSynth(
    uint32 marketIndex,
    uint256 longPrice,
    uint256 shortPrice,
    uint256 longValue,
    uint256 shortValue
  ) internal view virtual returns (uint256 longCumulativeRates, uint256 shortCumulativeRates) {
    // Compute the current 'r' value for float issuance per second.
    (uint256 longFloatPerSecond, uint256 shortFloatPerSecond) = _calculateFloatPerSecond(
      marketIndex,
      longPrice,
      shortPrice,
      longValue,
      shortValue
    );

    // Compute time since last accumulativeIssuancePerStakedSynthSnapshot for the given token.
    uint256 timeDelta = _calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(marketIndex);

    // Compute new cumulative 'r' value total.
    return (
      accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]]
      .accumulativeFloatPerSyntheticToken_long + (timeDelta * longFloatPerSecond),
      accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]]
      .accumulativeFloatPerSyntheticToken_short + (timeDelta * shortFloatPerSecond)
    );
  }

  /**
  @notice Creates a new accumulativeIssuancePerStakedSynthSnapshot for the given token and updates indexes.
  @param shortValue The value locked in the short side of the market.
  @param longValue The value locked in the long side of the market.
  @param shortPrice The price of the short token as defined in LongShort.sol
  @param longPrice The price of the long token as defined in LongShort.sol
  @param marketIndex An identifier for the market.
  */
  function _setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot(
    uint32 marketIndex,
    uint256 longPrice,
    uint256 shortPrice,
    uint256 longValue,
    uint256 shortValue
  ) internal virtual {
    (
      uint256 newLongAccumulativeValue,
      uint256 newShortAccumulativeValue
    ) = _calculateNewCumulativeIssuancePerStakedSynth(marketIndex, longPrice, shortPrice, longValue, shortValue);

    uint256 newIndex = latestRewardIndex[marketIndex] + 1;

    // Set cumulative 'r' value on new accumulativeIssuancePerStakedSynthSnapshot.
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex]
    .accumulativeFloatPerSyntheticToken_long = newLongAccumulativeValue;
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex]
    .accumulativeFloatPerSyntheticToken_short = newShortAccumulativeValue;

    // Set timestamp on new accumulativeIssuancePerStakedSynthSnapshot.
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex].timestamp = block.timestamp;

    // Update latest index to point to new accumulativeIssuancePerStakedSynthSnapshot.
    latestRewardIndex[marketIndex] = newIndex;

    emit AccumulativeIssuancePerStakedSynthSnapshotCreated(
      marketIndex,
      newIndex,
      newLongAccumulativeValue,
      newShortAccumulativeValue
    );
  }

  /**
  @notice Adds new accumulativeIssuancePerStakedSynthSnapshots for the given long/short tokens. Called by the
  ILongShort contract whenever there is a state change for a market.
  @param stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted Mapping from this contract's shifts to LongShort.sols next price snapshots.
  @param shortValue The value locked in the short side of the market.
  @param longValue The value locked in the long side of the market.
  @param shortPrice The price of the short token as defined in LongShort.sol
  @param longPrice The price of the long token as defined in LongShort.sol
  @param marketIndex An identifier for the market.
  */
  function pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(
    uint32 marketIndex,
    uint256 longPrice,
    uint256 shortPrice,
    uint256 longValue,
    uint256 shortValue,
    uint256 stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted // This value should be ALWAYS be zero if no shift occured
  ) external override onlyLongShort {
    // Only add a new accumulativeIssuancePerStakedSynthSnapshot if some time has passed.

    // the `stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted` value will be 0 if there is no staker related action in an executed batch
    if (stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted > 0) {
      stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[
        batched_stakerNextTokenShiftIndex[marketIndex]
      ] = stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted;
      stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[
        batched_stakerNextTokenShiftIndex[marketIndex]
      ] = latestRewardIndex[marketIndex] + 1;
      batched_stakerNextTokenShiftIndex[marketIndex] += 1;

      emit SyntheticTokensShifted();
    }

    // Time delta is fetched twice in below code, can pass through? Which is less gas?
    if (_calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(marketIndex) > 0) {
      _setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot(
        marketIndex,
        longPrice,
        shortPrice,
        longValue,
        shortValue
      );
    }
  }

  /*╔═══════════════════════════════════╗
    ║    USER REWARD STATE FUNCTIONS    ║
    ╚═══════════════════════════════════╝*/

  /// @dev Calculates the accumulated float in a specific range of staker snapshots
  function _calculateAccumulatedFloatInRange(
    uint32 marketIndex,
    uint256 amountStakedLong,
    uint256 amountStakedShort,
    uint256 rewardIndexFrom,
    uint256 rewardIndexTo
  ) internal view virtual returns (uint256 floatReward) {
    if (amountStakedLong > 0) {
      uint256 accumDeltaLong = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexTo]
      .accumulativeFloatPerSyntheticToken_long -
        accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexFrom]
        .accumulativeFloatPerSyntheticToken_long;
      floatReward += (accumDeltaLong * amountStakedLong) / FLOAT_ISSUANCE_FIXED_DECIMAL;
    }

    if (amountStakedShort > 0) {
      uint256 accumDeltaShort = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexTo]
      .accumulativeFloatPerSyntheticToken_short -
        accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexFrom]
        .accumulativeFloatPerSyntheticToken_short;
      floatReward += (accumDeltaShort * amountStakedShort) / FLOAT_ISSUANCE_FIXED_DECIMAL;
    }
  }

  /** 
  @notice Calculates float owed to the user since the user last minted float for a market.
  @param marketIndex Identifier for the market which the user staked in.
  @param user The address of the user.
  @return floatReward The amount of float owed.
   */
  function _calculateAccumulatedFloat(uint32 marketIndex, address user) internal virtual returns (uint256 floatReward) {
    address longToken = syntheticTokens[marketIndex][true];
    address shortToken = syntheticTokens[marketIndex][false];

    uint256 amountStakedLong = userAmountStaked[longToken][user];
    uint256 amountStakedShort = userAmountStaked[shortToken][user];

    uint256 usersLastRewardIndex = userIndexOfLastClaimedReward[marketIndex][user];

    // Don't do the calculation and return zero immediately if there is no change
    if (usersLastRewardIndex == latestRewardIndex[marketIndex]) {
      return 0;
    }

    uint256 usersShiftIndex = userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][user];
    // if there is a change in the users tokens held due to a token shift (or possibly another action in the future)
    if (usersShiftIndex > 0 && usersShiftIndex < batched_stakerNextTokenShiftIndex[marketIndex]) {
      floatReward = _calculateAccumulatedFloatInRange(
        marketIndex,
        amountStakedLong,
        amountStakedShort,
        usersLastRewardIndex,
        stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[usersShiftIndex]
      );

      // Update the users balances
      if (userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user] > 0) {
        amountStakedShort += ILongShort(longShort).getAmountSyntheticTokenToMintOnTargetSide(
          marketIndex,
          userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user],
          true,
          stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[usersShiftIndex]
        );

        amountStakedLong -= userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user];
        userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user] = 0;
      }

      if (userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user] > 0) {
        amountStakedLong += ILongShort(longShort).getAmountSyntheticTokenToMintOnTargetSide(
          marketIndex,
          userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user],
          false,
          stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[usersShiftIndex]
        );

        amountStakedShort -= userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user];
        userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user] = 0;
      }

      // Save the users updated staked amounts
      userAmountStaked[longToken][user] = amountStakedLong;
      userAmountStaked[shortToken][user] = amountStakedShort;

      floatReward += _calculateAccumulatedFloatInRange(
        marketIndex,
        amountStakedLong,
        amountStakedShort,
        stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[usersShiftIndex],
        latestRewardIndex[marketIndex]
      );

      userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][user] = 0;
    } else {
      floatReward = _calculateAccumulatedFloatInRange(
        marketIndex,
        amountStakedLong,
        amountStakedShort,
        usersLastRewardIndex,
        latestRewardIndex[marketIndex]
      );
    }
  }

  /**
  @notice Mints float for a user.
  @dev Mints a fixed percentage for Float capital.
  @param user The address of the user.
  @param floatToMint The amount of float to mint.
   */
  function _mintFloat(address user, uint256 floatToMint) internal virtual {
    IFloatToken(floatToken).mint(user, floatToMint);
    IFloatToken(floatToken).mint(floatCapital, (floatToMint * floatPercentage) / 1e18);
  }

  /**
  @notice Mints float owed to a user for a market since they last minted.
  @param marketIndex An identifier for the market.
  @param user The address of the user.
   */
  function _mintAccumulatedFloat(uint32 marketIndex, address user) internal virtual {
    uint256 floatToMint = _calculateAccumulatedFloat(marketIndex, user);

    if (floatToMint > 0) {
      // Set the user has claimed up until now, stops them setting this forward
      userIndexOfLastClaimedReward[marketIndex][user] = latestRewardIndex[marketIndex];

      _mintFloat(user, floatToMint);
      emit FloatMinted(user, marketIndex, floatToMint);
    }
  }

  /**
  @notice Mints float owed to a user for multiple markets, since they last minted for those markets.
  @param marketIndexes Identifiers for the markets.
  @param user The address of the user.
   */
  function _mintAccumulatedFloatMulti(uint32[] calldata marketIndexes, address user) internal virtual {
    uint256 floatTotal = 0;
    for (uint256 i = 0; i < marketIndexes.length; i++) {
      uint256 floatToMint = _calculateAccumulatedFloat(marketIndexes[i], user);

      if (floatToMint > 0) {
        // Set the user has claimed up until now, stops them setting this forward
        userIndexOfLastClaimedReward[marketIndexes[i]][user] = latestRewardIndex[marketIndexes[i]];

        floatTotal += floatToMint;

        emit FloatMinted(user, marketIndexes[i], floatToMint);
      }
    }
    if (floatTotal > 0) {
      _mintFloat(user, floatTotal);
    }
  }

  /**
  @notice Mints outstanding float for msg.sender.
  @param marketIndexes Identifiers for the markets for which to mint float.
   */
  function claimFloatCustom(uint32[] calldata marketIndexes) external {
    ILongShort(longShort).updateSystemStateMulti(marketIndexes);
    _mintAccumulatedFloatMulti(marketIndexes, msg.sender);
  }

  /**
  @notice Mints outstanding float on behalf of another user.
  @param marketIndexes Identifiers for the markets for which to mint float.
  @param user The address of the user.
   */
  function claimFloatCustomFor(uint32[] calldata marketIndexes, address user) external {
    // Unbounded loop - users are responsible for paying their own gas costs on these and it doesn't effect the rest of the system.
    // No need to impose limit.
    ILongShort(longShort).updateSystemStateMulti(marketIndexes);
    _mintAccumulatedFloatMulti(marketIndexes, user);
  }

  /*╔═══════════════════════╗
    ║        STAKING        ║
    ╚═══════════════════════╝*/

  /**
  @notice A user with synthetic tokens stakes by calling stake on the token
  contract which calls this function. We need to first update the
  state of the LongShort contract for this market before staking to correctly calculate user rewards.
  @param amount Amount to stake.
  @param from Address to stake for.
  */
  function stakeFromUser(address from, uint256 amount) public virtual override onlyValidSynthetic((msg.sender)) {
    ILongShort(longShort).updateSystemState(marketIndexOfToken[(msg.sender)]);
    _stake((msg.sender), amount, from);
  }

  /**
  @dev Internal logic for staking.
  @param token Address of the token for which to stake.
  @param amount Amount to stake.
  @param user Address to stake for.
  */
  function _stake(
    address token,
    uint256 amount,
    address user
  ) internal virtual {
    uint32 marketIndex = marketIndexOfToken[token];

    // If they already have staked and have rewards due, mint these.
    if (
      userIndexOfLastClaimedReward[marketIndex][user] != 0 &&
      userIndexOfLastClaimedReward[marketIndex][user] < latestRewardIndex[marketIndex]
    ) {
      _mintAccumulatedFloat(marketIndex, user);
    }

    userAmountStaked[token][user] = userAmountStaked[token][user] + amount;

    userIndexOfLastClaimedReward[marketIndex][user] = latestRewardIndex[marketIndex];

    emit StakeAdded(user, address(token), amount, userIndexOfLastClaimedReward[marketIndex][user]);
  }

  /**
  @notice Allows users to shift their staked tokens from one side of the market to 
  the other at the next price.
  @param amountSyntheticTokensToShift Amount of tokens to shift.
  @param marketIndex Identifier for the market.
  @param isShiftFromLong Whether the shift is from long to short or short to long.
  */
  function shiftTokens(
    uint256 amountSyntheticTokensToShift,
    uint32 marketIndex,
    bool isShiftFromLong
  ) external virtual {
    address token = syntheticTokens[marketIndex][isShiftFromLong];
    require(userAmountStaked[token][msg.sender] >= amountSyntheticTokensToShift, "Not enough tokens to shift");

    // If the user has outstanding token shift that have already been confirmed in the LongShort
    // contract, execute them first.
    if (
      userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] != 0 &&
      userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] <
      batched_stakerNextTokenShiftIndex[marketIndex]
    ) {
      _mintAccumulatedFloat(marketIndex, msg.sender);
    }

    if (isShiftFromLong) {
      ILongShort(longShort).shiftPositionFromLongNextPrice(marketIndex, amountSyntheticTokensToShift);
      userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][
        msg.sender
      ] += amountSyntheticTokensToShift;
    } else {
      ILongShort(longShort).shiftPositionFromShortNextPrice(marketIndex, amountSyntheticTokensToShift);
      userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][
        msg.sender
      ] += amountSyntheticTokensToShift;
    }

    userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] = batched_stakerNextTokenShiftIndex[
      marketIndex
    ];
  }

  /*╔════════════════════════════╗
    ║    WITHDRAWAL & MINTING    ║
    ╚════════════════════════════╝*/

  /**
  @notice Internal logic for withdrawing stakes.
  @dev Mint user any outstanding float before withdrawing.
  @param marketIndex Market index of token.
  @param amount Amount to withdraw.
  @param token Synthetic token that was staked.
  */
  function _withdraw(
    uint32 marketIndex,
    address token,
    uint256 amount
  ) internal virtual {
    require(userAmountStaked[token][msg.sender] > 0, "nothing to withdraw");
    _mintAccumulatedFloat(marketIndex, msg.sender);

    userAmountStaked[token][msg.sender] = userAmountStaked[token][msg.sender] - amount;

    uint256 amountFees = (amount * marketUnstakeFee_e18[marketIndex]) / 1e18;

    IERC20(token).transfer(floatTreasury, amountFees);
    IERC20(token).transfer(msg.sender, amount - amountFees);

    emit StakeWithdrawn(msg.sender, token, amount);
  }

  /**
  @notice Withdraw function. Allows users to unstake.
  @param amount Amount to withdraw.
  @param token Address of the token for which to withdraw.
  */
  function withdraw(address token, uint256 amount) external {
    ILongShort(longShort).updateSystemState(marketIndexOfToken[token]);

    uint32 marketIndex = marketIndexOfToken[token];

    _withdraw(marketIndex, token, amount);

    if (userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] > 0) {
      // If they still have outstanding shifts after minting float, then check
      // that they don't withdraw more than their shifts allow.
      uint256 amountToShiftForThisToken = syntheticTokens[marketIndex][true] == token
        ? userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][msg.sender]
        : userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][msg.sender];

      require(
        userAmountStaked[token][msg.sender] >= amountToShiftForThisToken,
        "Outstanding next price stake shifts too great"
      );
    }
  }

  /**
  @notice Allows users to withdraw their entire stake for a token.
  @param token Address of the token for which to withdraw.
  */
  function withdrawAll(address token) external {
    ILongShort(longShort).updateSystemState(marketIndexOfToken[token]);

    uint32 marketIndex = marketIndexOfToken[token];

    uint256 amountToShiftForThisToken = syntheticTokens[marketIndex][true] == token
      ? userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][msg.sender]
      : userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][msg.sender];

    _withdraw(marketIndex, token, userAmountStaked[token][msg.sender] - amountToShiftForThisToken);
  }
}
".

As the Security Analyst, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user.

Note that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we've collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with <INFO>, followed directly by the final idea or enhancement suggestion, e.g. "<INFO> Implementing a multi-sig wallet mechanism for added security in transactions".

[2024-17-08 08:01:20 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-17-08 08:01:20 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 19626
completion_tokens: 1
total_tokens: 19627
cost: $-1.000000


[2024-17-08 08:01:20 INFO] Security Analyst: **Security Analyst<->Chief Executive Officer on : ContractAnalysis, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer.
Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees.
Here is a new customer's task: // SPDX-License-Identifier: BUSL-1.1

pragma solidity 0.8.3;

import "@openzeppelin/contracts-upgradeable/token/ERC20/presets/ERC20PresetMinterPauserUpgradeable.sol";

import "./interfaces/IFloatToken.sol";
import "./interfaces/ILongShort.sol";
import "./interfaces/IStaker.sol";
import "./interfaces/ISyntheticToken.sol";

contract Staker is IStaker, Initializable {
  /*╔═════════════════════════════╗
    ║          VARIABLES          ║
    ╚═════════════════════════════╝*/

  /* ══════ Fixed-precision constants ══════ */
  uint256 public constant FLOAT_ISSUANCE_FIXED_DECIMAL = 1e42;
  // 2^52 ~= 4.5e15
  // With an exponent of 5, the largest total liquidity possible in a market (to avoid integer overflow on exponentiation) is ~10^31 or 10 Trillion (10^13)
  // NOTE: this also means if the total market value is less than 2^52 there will be a division by zero error
  uint256 public constant safeExponentBitShifting = 52;

  /* ══════ Global state ══════ */
  address public admin;
  address public floatCapital;
  address public floatTreasury;
  uint256 public floatPercentage;

  address public longShort;
  address public floatToken;

  /* ══════ Market specific ══════ */
  mapping(uint32 => uint256) public marketLaunchIncentive_period; // seconds
  mapping(uint32 => uint256) public marketLaunchIncentive_multipliers; // e18 scale
  mapping(uint32 => uint256) public marketUnstakeFee_e18;
  mapping(uint32 => uint256) public balanceIncentiveCurve_exponent;
  mapping(uint32 => int256) public balanceIncentiveCurve_equilibriumOffset;

  mapping(uint32 => mapping(bool => address)) public syntheticTokens;

  mapping(address => uint32) public marketIndexOfToken;

  /* ══════ Reward specific ══════ */
  mapping(uint32 => uint256) public latestRewardIndex;
  mapping(uint32 => mapping(uint256 => AccumulativeIssuancePerStakedSynthSnapshot))
    public accumulativeFloatPerSyntheticTokenSnapshots;
  struct AccumulativeIssuancePerStakedSynthSnapshot {
    uint256 timestamp;
    uint256 accumulativeFloatPerSyntheticToken_long;
    uint256 accumulativeFloatPerSyntheticToken_short;
  }

  /* ══════ User specific ══════ */
  mapping(uint32 => mapping(address => uint256)) public userIndexOfLastClaimedReward;
  mapping(address => mapping(address => uint256)) public userAmountStaked;

  /* ══════ Token shift management specific ══════ */
  mapping(uint32 => uint256) public batched_stakerNextTokenShiftIndex;
  /**
  @notice Used to link a token shift to a staker state
  @dev tokenShiftIndex => accumulativeFloatIssuanceSnapshotIndex
    POSSIBLE OPTIMIZATION - could pack stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping and stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping into a struct of two uint128 for storage space optimization.
  */
  mapping(uint256 => uint256) public stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping;
  /// @notice Used to fetch the price from LongShort at that point in time
  /// @dev tokenShiftIndex => longShortMarketPriceSnapshotIndex
  mapping(uint256 => uint256) public stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping;
  /// @dev marketIndex => usersAddress => stakerTokenShiftIndex
  mapping(uint32 => mapping(address => uint256)) public userNextPrice_stakedSyntheticTokenShiftIndex;
  /// @dev marketIndex => usersAddress => amountUserRequestedToShiftAwayFromLongOnNextUpdate
  mapping(uint32 => mapping(address => uint256)) public userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long;
  /// @dev marketIndex => usersAddress => amountUserRequestedToShiftAwayFromShortOnNextUpdate
  mapping(uint32 => mapping(address => uint256)) public userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short;

  /*╔════════════════════════════╗
    ║           EVENTS           ║
    ╚════════════════════════════╝*/

  event StakerV1(
    address admin,
    address floatTreasury,
    address floatCapital,
    address floatToken,
    uint256 floatPercentage
  );

  event MarketAddedToStaker(
    uint32 marketIndex,
    uint256 exitFee_e18,
    uint256 period,
    uint256 multiplier,
    uint256 balanceIncentiveExponent,
    int256 balanceIncentiveEquilibriumOffset
  );

  event AccumulativeIssuancePerStakedSynthSnapshotCreated(
    uint32 marketIndex,
    uint256 accumulativeFloatIssuanceSnapshotIndex,
    uint256 accumulativeLong,
    uint256 accumulativeShort
  );

  event StakeAdded(address user, address token, uint256 amount, uint256 lastMintIndex);

  event StakeWithdrawn(address user, address token, uint256 amount);

  // Note: the `amountFloatMinted` isn't strictly needed by the graph, but it is good to add it to validate calculations are accurate.
  event FloatMinted(address user, uint32 marketIndex, uint256 amountFloatMinted);

  event MarketLaunchIncentiveParametersChanges(uint32 marketIndex, uint256 period, uint256 multiplier);

  event StakeWithdrawalFeeUpdated(uint32 marketIndex, uint256 stakeWithdralFee);

  event BalanceIncentiveExponentUpdated(uint32 marketIndex, uint256 balanceIncentiveExponent);

  event BalanceIncentiveEquilibriumOffsetUpdated(uint32 marketIndex, int256 balanceIncentiveEquilibriumOffset);

  event FloatPercentageUpdated(uint256 floatPercentage);

  event SyntheticTokensShifted();

  event ChangeAdmin(address newAdmin);

  /*╔═════════════════════════════╗
    ║          MODIFIERS          ║
    ╚═════════════════════════════╝*/

  function onlyAdminModifierLogic() internal virtual {
    require(msg.sender == admin, "not admin");
  }

  modifier onlyAdmin() {
    onlyAdminModifierLogic();
    _;
  }

  function onlyValidSyntheticModifierLogic(address _synth) internal virtual {
    require(marketIndexOfToken[_synth] != 0, "not valid synth");
  }

  modifier onlyValidSynthetic(address _synth) {
    onlyValidSyntheticModifierLogic(_synth);
    _;
  }

  function onlyValidMarketModifierLogic(uint32 marketIndex) internal virtual {
    require(address(syntheticTokens[marketIndex][true]) != address(0), "not valid market");
  }

  modifier onlyValidMarket(uint32 marketIndex) {
    onlyValidMarketModifierLogic(marketIndex);
    _;
  }

  function onlyLongShortModifierLogic() internal virtual {
    require(msg.sender == address(longShort), "not long short");
  }

  modifier onlyLongShort() {
    onlyLongShortModifierLogic();
    _;
  }

  /*╔═════════════════════════════╗
    ║       CONTRACT SET-UP       ║
    ╚═════════════════════════════╝*/

  /**
  @notice Initializes the contract.
  @dev Calls OpenZeppelin's initializer modifier.
  @param _admin Address of the admin role.
  @param _longShort Address of the LongShort contract, a deployed LongShort.sol
  @param _floatToken Address of the Float token earned by staking.
  @param _floatTreasury Address of the treasury contract for managing fees.
  @param _floatCapital Address of the contract which earns a fixed percentage of Float.
  @param _floatPercentage Determines the float percentage that gets minted for Float Capital, base 1e18.
  */
  function initialize(
    address _admin,
    address _longShort,
    address _floatToken,
    address _floatTreasury,
    address _floatCapital,
    uint256 _floatPercentage
  ) external virtual initializer {
    admin = _admin;
    floatCapital = _floatCapital;
    floatTreasury = _floatTreasury;
    longShort = _longShort;
    floatToken = _floatToken;

    _changeFloatPercentage(_floatPercentage);

    emit StakerV1(_admin, _floatTreasury, _floatCapital, _floatToken, _floatPercentage);
  }

  /*╔═══════════════════╗
    ║       ADMIN       ║
    ╚═══════════════════╝*/

  /** 
  @notice Changes admin for the contract
  @param _admin The address of the new admin.
  */
  function changeAdmin(address _admin) external onlyAdmin {
    admin = _admin;
    emit ChangeAdmin(_admin);
  }

  /// @dev Logic for changeFloatPercentage
  function _changeFloatPercentage(uint256 newFloatPercentage) internal virtual {
    require(newFloatPercentage <= 1e18 && newFloatPercentage > 0); // less than or equal to 100% and greater than 0%
    floatPercentage = newFloatPercentage;
  }

  /**
  @notice Changes percentage of float that is minted for float capital.
  @param newFloatPercentage The new float percentage in base 1e18.
  */
  function changeFloatPercentage(uint256 newFloatPercentage) external onlyAdmin {
    _changeFloatPercentage(newFloatPercentage);
    emit FloatPercentageUpdated(newFloatPercentage);
  }

  /// @dev Logic for changeUnstakeFee
  function _changeUnstakeFee(uint32 marketIndex, uint256 newMarketUnstakeFee_e18) internal virtual {
    require(newMarketUnstakeFee_e18 <= 5e16); // Explicitely stating 5% fee as the max fee possible.
    marketUnstakeFee_e18[marketIndex] = newMarketUnstakeFee_e18;
  }

  /**
  @notice Changes unstake fee for a market
  @param marketIndex Identifies the market.
  @param newMarketUnstakeFee_e18 The new unstake fee.
  */
  function changeUnstakeFee(uint32 marketIndex, uint256 newMarketUnstakeFee_e18) external onlyAdmin {
    _changeUnstakeFee(marketIndex, newMarketUnstakeFee_e18);
    emit StakeWithdrawalFeeUpdated(marketIndex, newMarketUnstakeFee_e18);
  }

  /// @dev Logic for changeMarketLaunchIncentiveParameters
  function _changeMarketLaunchIncentiveParameters(
    uint32 marketIndex,
    uint256 period,
    uint256 initialMultiplier
  ) internal virtual {
    require(initialMultiplier >= 1e18, "marketLaunchIncentiveMultiplier must be >= 1e18");

    marketLaunchIncentive_period[marketIndex] = period;
    marketLaunchIncentive_multipliers[marketIndex] = initialMultiplier;
  }

  /**
  @notice Changes the market launch incentive parameters for a market
  @param marketIndex Identifies the market.
  @param period The new period for which float token generation should be boosted.
  @param initialMultiplier The new multiplier on Float generation.
  */
  function changeMarketLaunchIncentiveParameters(
    uint32 marketIndex,
    uint256 period,
    uint256 initialMultiplier
  ) external onlyAdmin {
    _changeMarketLaunchIncentiveParameters(marketIndex, period, initialMultiplier);

    emit MarketLaunchIncentiveParametersChanges(marketIndex, period, initialMultiplier);
  }

  /// @dev Logic for changeBalanceIncentiveExponent
  function _changeBalanceIncentiveExponent(uint32 marketIndex, uint256 _balanceIncentiveCurve_exponent)
    internal
    virtual
  {
    require(
      // The exponent has to be less than 5 in these versions of the contracts.
      _balanceIncentiveCurve_exponent > 0 && _balanceIncentiveCurve_exponent < 6,
      "balanceIncentiveCurve_exponent out of bounds"
    );

    balanceIncentiveCurve_exponent[marketIndex] = _balanceIncentiveCurve_exponent;
  }

  /** 
  @notice Changes the balance incentive exponent for a market
  @param marketIndex Identifies the market.
  @param _balanceIncentiveCurve_exponent The new exponent for the curve.
  */
  function changeBalanceIncentiveExponent(uint32 marketIndex, uint256 _balanceIncentiveCurve_exponent)
    external
    onlyAdmin
  {
    _changeBalanceIncentiveExponent(marketIndex, _balanceIncentiveCurve_exponent);

    emit BalanceIncentiveExponentUpdated(marketIndex, _balanceIncentiveCurve_exponent);
  }

  /// @dev Logic for changeBalanceIncentiveEquilibriumOffset
  function _changeBalanceIncentiveEquilibriumOffset(uint32 marketIndex, int256 _balanceIncentiveCurve_equilibriumOffset)
    internal
    virtual
  {
    // Unreasonable that we would ever shift this more than 90% either way
    require(
      _balanceIncentiveCurve_equilibriumOffset > -9e17 && _balanceIncentiveCurve_equilibriumOffset < 9e17,
      "balanceIncentiveCurve_equilibriumOffset out of bounds"
    );

    balanceIncentiveCurve_equilibriumOffset[marketIndex] = _balanceIncentiveCurve_equilibriumOffset;
  }

  /**
  @notice Changes the balance incentive curve equilibrium offset for a market
  @param marketIndex Identifies the market.
  @param _balanceIncentiveCurve_equilibriumOffset The new offset.
  */
  function changeBalanceIncentiveEquilibriumOffset(uint32 marketIndex, int256 _balanceIncentiveCurve_equilibriumOffset)
    external
    onlyAdmin
  {
    _changeBalanceIncentiveEquilibriumOffset(marketIndex, _balanceIncentiveCurve_equilibriumOffset);

    emit BalanceIncentiveEquilibriumOffsetUpdated(marketIndex, _balanceIncentiveCurve_equilibriumOffset);
  }

  /*╔═════════════════════════════╗
    ║        STAKING SETUP        ║
    ╚═════════════════════════════╝*/

  /**
  @notice Sets this contract to track staking for a market in LongShort.sol
  @param marketIndex Identifies the market.
  @param longToken Address of the long token for the market.
  @param shortToken Address of the short token for the market.
  @param kInitialMultiplier Initial boost on float generation for the market.
  @param kPeriod Period which the boost should last.
  @param unstakeFee_e18 Percentage of tokens that are levied on unstaking in base 1e18.
  @param _balanceIncentiveCurve_exponent Exponent for balance curve (see _calculateFloatPerSecond)
  @param _balanceIncentiveCurve_equilibriumOffset Offset for balance curve (see _calculateFloatPerSecond)
  */
  function addNewStakingFund(
    uint32 marketIndex,
    address longToken,
    address shortToken,
    uint256 kInitialMultiplier,
    uint256 kPeriod,
    uint256 unstakeFee_e18,
    uint256 _balanceIncentiveCurve_exponent,
    int256 _balanceIncentiveCurve_equilibriumOffset
  ) external override onlyLongShort {
    marketIndexOfToken[longToken] = marketIndex;
    marketIndexOfToken[shortToken] = marketIndex;

    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].timestamp = block.timestamp;
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].accumulativeFloatPerSyntheticToken_long = 0;
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].accumulativeFloatPerSyntheticToken_short = 0;

    syntheticTokens[marketIndex][true] = longToken;
    syntheticTokens[marketIndex][false] = shortToken;

    _changeBalanceIncentiveExponent(marketIndex, _balanceIncentiveCurve_exponent);
    _changeBalanceIncentiveEquilibriumOffset(marketIndex, _balanceIncentiveCurve_equilibriumOffset);
    _changeMarketLaunchIncentiveParameters(marketIndex, kPeriod, kInitialMultiplier);

    _changeUnstakeFee(marketIndex, unstakeFee_e18);

    // Set this value to one initially - 0 is a null value and thus potentially bug prone.
    batched_stakerNextTokenShiftIndex[marketIndex] = 1;

    emit MarketAddedToStaker(
      marketIndex,
      unstakeFee_e18,
      kPeriod,
      kInitialMultiplier,
      _balanceIncentiveCurve_exponent,
      _balanceIncentiveCurve_equilibriumOffset
    );

    emit AccumulativeIssuancePerStakedSynthSnapshotCreated(marketIndex, 0, 0, 0);
  }

  /*╔═════════════════════════════════════════════════════════════════════════╗
    ║    GLOBAL FLT REWARD ACCUMULATION CALCULATION AND TRACKING FUNCTIONS    ║
    ╚═════════════════════════════════════════════════════════════════════════╝*/

  /**
  @notice Returns the K factor parameters for the given market with sensible
  defaults if they haven't been set yet.
  @param marketIndex The market to change the parameters for.
  @return period The period for which the k factor applies for in seconds.
  @return multiplier The multiplier on Float generation in this period.
  */
  function _getMarketLaunchIncentiveParameters(uint32 marketIndex)
    internal
    view
    virtual
    returns (uint256 period, uint256 multiplier)
  {
    period = marketLaunchIncentive_period[marketIndex];
    multiplier = marketLaunchIncentive_multipliers[marketIndex];

    if (multiplier < 1e18) {
      multiplier = 1e18; // multiplier of 1 by default
    }
  }

  /** 
  @notice Returns the extent to which a markets float generation should be adjusted
  based on the market's launch incentive parameters. Should start at multiplier
  then linearly change to 1e18 over time.
  @param marketIndex Identifies the market.
  @return k The calculated modifier for float generation.
  */
  function _getKValue(uint32 marketIndex) internal view virtual returns (uint256) {
    // Parameters controlling the float issuance multiplier.
    (uint256 kPeriod, uint256 kInitialMultiplier) = _getMarketLaunchIncentiveParameters(marketIndex);

    // Sanity check - under normal circumstances, the multipliers should
    // *never* be set to a value < 1e18, as there are guards against this.
    assert(kInitialMultiplier >= 1e18);

    uint256 initialTimestamp = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].timestamp;

    if (block.timestamp - initialTimestamp <= kPeriod) {
      return kInitialMultiplier - (((kInitialMultiplier - 1e18) * (block.timestamp - initialTimestamp)) / kPeriod);
    } else {
      return 1e18;
    }
  }

  /*
  @notice Computes the number of float tokens a user earns per second for
  every long/short synthetic token they've staked. The returned value has
  a fixed decimal scale of 1e42 (!!!) for numerical stability. The return
  values are float per second per synthetic token (hence the requirement
  to multiply by price)
  @dev to see below math in latex form see TODO add link
  to interact with the equations see https://www.desmos.com/calculator/optkaxyihr
  @param marketIndex The market referred to.
  @param longPrice Price of the synthetic long token in units of payment token
  @param shortPrice Price of the synthetic short token in units of payment token
  @param longValue Amount of payment token in the long side of the market
  @param shortValue Amount of payment token in the short side of the market
  @return longFloatPerSecond Float token per second per long synthetic token
  @return shortFloatPerSecond Float token per second per short synthetic token
   */
  function _calculateFloatPerSecond(
    uint32 marketIndex,
    uint256 longPrice,
    uint256 shortPrice,
    uint256 longValue,
    uint256 shortValue
  ) internal view virtual returns (uint256 longFloatPerSecond, uint256 shortFloatPerSecond) {
    // A float issuance multiplier that starts high and decreases linearly
    // over time to a value of 1. This incentivises users to stake early.
    uint256 k = _getKValue(marketIndex);

    uint256 totalLocked = (longValue + shortValue);

    // we need to scale this number by the totalLocked so that the offset remains consistent accross market size

    int256 equilibriumOffsetMarketScaled = (balanceIncentiveCurve_equilibriumOffset[marketIndex] *
      int256(totalLocked)) / 2e18;

    uint256 denominator = ((totalLocked >> safeExponentBitShifting)**balanceIncentiveCurve_exponent[marketIndex]);

    // Float is scaled by the percentage of the total market value held in
    // the opposite position. This incentivises users to stake on the
    // weaker position.
    if (int256(shortValue) - equilibriumOffsetMarketScaled < int256(longValue)) {
      if (equilibriumOffsetMarketScaled >= int256(shortValue)) {
        // edge case: imbalanced far past the equilibrium offset - full rewards go to short token
        //            extremeley unlikely to happen in practice
        return (0, 1e18 * k * shortPrice);
      }

      uint256 numerator = (uint256(int256(shortValue) - equilibriumOffsetMarketScaled) >>
        (safeExponentBitShifting - 1))**balanceIncentiveCurve_exponent[marketIndex];

      // NOTE: `x * 5e17` == `(x * 10e18) / 2`
      uint256 longRewardUnscaled = (numerator * 5e17) / denominator;
      uint256 shortRewardUnscaled = 1e18 - longRewardUnscaled;

      return ((longRewardUnscaled * k * longPrice) / 1e18, (shortRewardUnscaled * k * shortPrice) / 1e18);
    } else {
      if (-equilibriumOffsetMarketScaled >= int256(longValue)) {
        // edge case: imbalanced far past the equilibrium offset - full rewards go to long token
        //            extremeley unlikely to happen in practice
        return (1e18 * k * longPrice, 0);
      }

      uint256 numerator = (uint256(int256(longValue) + equilibriumOffsetMarketScaled) >>
        (safeExponentBitShifting - 1))**balanceIncentiveCurve_exponent[marketIndex];

      // NOTE: `x * 5e17` == `(x * 10e18) / 2`
      uint256 shortRewardUnscaled = (numerator * 5e17) / denominator;
      uint256 longRewardUnscaled = 1e18 - shortRewardUnscaled;

      return ((longRewardUnscaled * k * longPrice) / 1e18, (shortRewardUnscaled * k * shortPrice) / 1e18);
    }
  }

  /**
  @notice Computes the time since last accumulativeIssuancePerStakedSynthSnapshot for the given market in seconds.
  @param marketIndex The market referred to.
  @return The time difference in seconds
  */
  function _calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(uint32 marketIndex)
    internal
    view
    virtual
    returns (uint256)
  {
    return
      block.timestamp -
      accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]].timestamp;
  }

  /**
  @notice Computes new cumulative sum of 'r' value since last accumulativeIssuancePerStakedSynthSnapshot. We use
  cumulative 'r' value to avoid looping during issuance. Note that the
  cumulative sum is kept in 1e42 scale (!!!) to avoid numerical issues.
  @param shortValue The value locked in the short side of the market.
  @param longValue The value locked in the long side of the market.
  @param shortPrice The price of the short token as defined in LongShort.sol
  @param longPrice The price of the long token as defined in LongShort.sol
  @param marketIndex An identifier for the market.
  @return longCumulativeRates The long cumulative sum.
  @return shortCumulativeRates The short cumulative sum.
  */
  function _calculateNewCumulativeIssuancePerStakedSynth(
    uint32 marketIndex,
    uint256 longPrice,
    uint256 shortPrice,
    uint256 longValue,
    uint256 shortValue
  ) internal view virtual returns (uint256 longCumulativeRates, uint256 shortCumulativeRates) {
    // Compute the current 'r' value for float issuance per second.
    (uint256 longFloatPerSecond, uint256 shortFloatPerSecond) = _calculateFloatPerSecond(
      marketIndex,
      longPrice,
      shortPrice,
      longValue,
      shortValue
    );

    // Compute time since last accumulativeIssuancePerStakedSynthSnapshot for the given token.
    uint256 timeDelta = _calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(marketIndex);

    // Compute new cumulative 'r' value total.
    return (
      accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]]
      .accumulativeFloatPerSyntheticToken_long + (timeDelta * longFloatPerSecond),
      accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]]
      .accumulativeFloatPerSyntheticToken_short + (timeDelta * shortFloatPerSecond)
    );
  }

  /**
  @notice Creates a new accumulativeIssuancePerStakedSynthSnapshot for the given token and updates indexes.
  @param shortValue The value locked in the short side of the market.
  @param longValue The value locked in the long side of the market.
  @param shortPrice The price of the short token as defined in LongShort.sol
  @param longPrice The price of the long token as defined in LongShort.sol
  @param marketIndex An identifier for the market.
  */
  function _setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot(
    uint32 marketIndex,
    uint256 longPrice,
    uint256 shortPrice,
    uint256 longValue,
    uint256 shortValue
  ) internal virtual {
    (
      uint256 newLongAccumulativeValue,
      uint256 newShortAccumulativeValue
    ) = _calculateNewCumulativeIssuancePerStakedSynth(marketIndex, longPrice, shortPrice, longValue, shortValue);

    uint256 newIndex = latestRewardIndex[marketIndex] + 1;

    // Set cumulative 'r' value on new accumulativeIssuancePerStakedSynthSnapshot.
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex]
    .accumulativeFloatPerSyntheticToken_long = newLongAccumulativeValue;
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex]
    .accumulativeFloatPerSyntheticToken_short = newShortAccumulativeValue;

    // Set timestamp on new accumulativeIssuancePerStakedSynthSnapshot.
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex].timestamp = block.timestamp;

    // Update latest index to point to new accumulativeIssuancePerStakedSynthSnapshot.
    latestRewardIndex[marketIndex] = newIndex;

    emit AccumulativeIssuancePerStakedSynthSnapshotCreated(
      marketIndex,
      newIndex,
      newLongAccumulativeValue,
      newShortAccumulativeValue
    );
  }

  /**
  @notice Adds new accumulativeIssuancePerStakedSynthSnapshots for the given long/short tokens. Called by the
  ILongShort contract whenever there is a state change for a market.
  @param stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted Mapping from this contract's shifts to LongShort.sols next price snapshots.
  @param shortValue The value locked in the short side of the market.
  @param longValue The value locked in the long side of the market.
  @param shortPrice The price of the short token as defined in LongShort.sol
  @param longPrice The price of the long token as defined in LongShort.sol
  @param marketIndex An identifier for the market.
  */
  function pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(
    uint32 marketIndex,
    uint256 longPrice,
    uint256 shortPrice,
    uint256 longValue,
    uint256 shortValue,
    uint256 stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted // This value should be ALWAYS be zero if no shift occured
  ) external override onlyLongShort {
    // Only add a new accumulativeIssuancePerStakedSynthSnapshot if some time has passed.

    // the `stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted` value will be 0 if there is no staker related action in an executed batch
    if (stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted > 0) {
      stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[
        batched_stakerNextTokenShiftIndex[marketIndex]
      ] = stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted;
      stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[
        batched_stakerNextTokenShiftIndex[marketIndex]
      ] = latestRewardIndex[marketIndex] + 1;
      batched_stakerNextTokenShiftIndex[marketIndex] += 1;

      emit SyntheticTokensShifted();
    }

    // Time delta is fetched twice in below code, can pass through? Which is less gas?
    if (_calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(marketIndex) > 0) {
      _setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot(
        marketIndex,
        longPrice,
        shortPrice,
        longValue,
        shortValue
      );
    }
  }

  /*╔═══════════════════════════════════╗
    ║    USER REWARD STATE FUNCTIONS    ║
    ╚═══════════════════════════════════╝*/

  /// @dev Calculates the accumulated float in a specific range of staker snapshots
  function _calculateAccumulatedFloatInRange(
    uint32 marketIndex,
    uint256 amountStakedLong,
    uint256 amountStakedShort,
    uint256 rewardIndexFrom,
    uint256 rewardIndexTo
  ) internal view virtual returns (uint256 floatReward) {
    if (amountStakedLong > 0) {
      uint256 accumDeltaLong = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexTo]
      .accumulativeFloatPerSyntheticToken_long -
        accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexFrom]
        .accumulativeFloatPerSyntheticToken_long;
      floatReward += (accumDeltaLong * amountStakedLong) / FLOAT_ISSUANCE_FIXED_DECIMAL;
    }

    if (amountStakedShort > 0) {
      uint256 accumDeltaShort = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexTo]
      .accumulativeFloatPerSyntheticToken_short -
        accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexFrom]
        .accumulativeFloatPerSyntheticToken_short;
      floatReward += (accumDeltaShort * amountStakedShort) / FLOAT_ISSUANCE_FIXED_DECIMAL;
    }
  }

  /** 
  @notice Calculates float owed to the user since the user last minted float for a market.
  @param marketIndex Identifier for the market which the user staked in.
  @param user The address of the user.
  @return floatReward The amount of float owed.
   */
  function _calculateAccumulatedFloat(uint32 marketIndex, address user) internal virtual returns (uint256 floatReward) {
    address longToken = syntheticTokens[marketIndex][true];
    address shortToken = syntheticTokens[marketIndex][false];

    uint256 amountStakedLong = userAmountStaked[longToken][user];
    uint256 amountStakedShort = userAmountStaked[shortToken][user];

    uint256 usersLastRewardIndex = userIndexOfLastClaimedReward[marketIndex][user];

    // Don't do the calculation and return zero immediately if there is no change
    if (usersLastRewardIndex == latestRewardIndex[marketIndex]) {
      return 0;
    }

    uint256 usersShiftIndex = userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][user];
    // if there is a change in the users tokens held due to a token shift (or possibly another action in the future)
    if (usersShiftIndex > 0 && usersShiftIndex < batched_stakerNextTokenShiftIndex[marketIndex]) {
      floatReward = _calculateAccumulatedFloatInRange(
        marketIndex,
        amountStakedLong,
        amountStakedShort,
        usersLastRewardIndex,
        stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[usersShiftIndex]
      );

      // Update the users balances
      if (userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user] > 0) {
        amountStakedShort += ILongShort(longShort).getAmountSyntheticTokenToMintOnTargetSide(
          marketIndex,
          userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user],
          true,
          stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[usersShiftIndex]
        );

        amountStakedLong -= userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user];
        userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user] = 0;
      }

      if (userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user] > 0) {
        amountStakedLong += ILongShort(longShort).getAmountSyntheticTokenToMintOnTargetSide(
          marketIndex,
          userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user],
          false,
          stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[usersShiftIndex]
        );

        amountStakedShort -= userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user];
        userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user] = 0;
      }

      // Save the users updated staked amounts
      userAmountStaked[longToken][user] = amountStakedLong;
      userAmountStaked[shortToken][user] = amountStakedShort;

      floatReward += _calculateAccumulatedFloatInRange(
        marketIndex,
        amountStakedLong,
        amountStakedShort,
        stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[usersShiftIndex],
        latestRewardIndex[marketIndex]
      );

      userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][user] = 0;
    } else {
      floatReward = _calculateAccumulatedFloatInRange(
        marketIndex,
        amountStakedLong,
        amountStakedShort,
        usersLastRewardIndex,
        latestRewardIndex[marketIndex]
      );
    }
  }

  /**
  @notice Mints float for a user.
  @dev Mints a fixed percentage for Float capital.
  @param user The address of the user.
  @param floatToMint The amount of float to mint.
   */
  function _mintFloat(address user, uint256 floatToMint) internal virtual {
    IFloatToken(floatToken).mint(user, floatToMint);
    IFloatToken(floatToken).mint(floatCapital, (floatToMint * floatPercentage) / 1e18);
  }

  /**
  @notice Mints float owed to a user for a market since they last minted.
  @param marketIndex An identifier for the market.
  @param user The address of the user.
   */
  function _mintAccumulatedFloat(uint32 marketIndex, address user) internal virtual {
    uint256 floatToMint = _calculateAccumulatedFloat(marketIndex, user);

    if (floatToMint > 0) {
      // Set the user has claimed up until now, stops them setting this forward
      userIndexOfLastClaimedReward[marketIndex][user] = latestRewardIndex[marketIndex];

      _mintFloat(user, floatToMint);
      emit FloatMinted(user, marketIndex, floatToMint);
    }
  }

  /**
  @notice Mints float owed to a user for multiple markets, since they last minted for those markets.
  @param marketIndexes Identifiers for the markets.
  @param user The address of the user.
   */
  function _mintAccumulatedFloatMulti(uint32[] calldata marketIndexes, address user) internal virtual {
    uint256 floatTotal = 0;
    for (uint256 i = 0; i < marketIndexes.length; i++) {
      uint256 floatToMint = _calculateAccumulatedFloat(marketIndexes[i], user);

      if (floatToMint > 0) {
        // Set the user has claimed up until now, stops them setting this forward
        userIndexOfLastClaimedReward[marketIndexes[i]][user] = latestRewardIndex[marketIndexes[i]];

        floatTotal += floatToMint;

        emit FloatMinted(user, marketIndexes[i], floatToMint);
      }
    }
    if (floatTotal > 0) {
      _mintFloat(user, floatTotal);
    }
  }

  /**
  @notice Mints outstanding float for msg.sender.
  @param marketIndexes Identifiers for the markets for which to mint float.
   */
  function claimFloatCustom(uint32[] calldata marketIndexes) external {
    ILongShort(longShort).updateSystemStateMulti(marketIndexes);
    _mintAccumulatedFloatMulti(marketIndexes, msg.sender);
  }

  /**
  @notice Mints outstanding float on behalf of another user.
  @param marketIndexes Identifiers for the markets for which to mint float.
  @param user The address of the user.
   */
  function claimFloatCustomFor(uint32[] calldata marketIndexes, address user) external {
    // Unbounded loop - users are responsible for paying their own gas costs on these and it doesn't effect the rest of the system.
    // No need to impose limit.
    ILongShort(longShort).updateSystemStateMulti(marketIndexes);
    _mintAccumulatedFloatMulti(marketIndexes, user);
  }

  /*╔═══════════════════════╗
    ║        STAKING        ║
    ╚═══════════════════════╝*/

  /**
  @notice A user with synthetic tokens stakes by calling stake on the token
  contract which calls this function. We need to first update the
  state of the LongShort contract for this market before staking to correctly calculate user rewards.
  @param amount Amount to stake.
  @param from Address to stake for.
  */
  function stakeFromUser(address from, uint256 amount) public virtual override onlyValidSynthetic((msg.sender)) {
    ILongShort(longShort).updateSystemState(marketIndexOfToken[(msg.sender)]);
    _stake((msg.sender), amount, from);
  }

  /**
  @dev Internal logic for staking.
  @param token Address of the token for which to stake.
  @param amount Amount to stake.
  @param user Address to stake for.
  */
  function _stake(
    address token,
    uint256 amount,
    address user
  ) internal virtual {
    uint32 marketIndex = marketIndexOfToken[token];

    // If they already have staked and have rewards due, mint these.
    if (
      userIndexOfLastClaimedReward[marketIndex][user] != 0 &&
      userIndexOfLastClaimedReward[marketIndex][user] < latestRewardIndex[marketIndex]
    ) {
      _mintAccumulatedFloat(marketIndex, user);
    }

    userAmountStaked[token][user] = userAmountStaked[token][user] + amount;

    userIndexOfLastClaimedReward[marketIndex][user] = latestRewardIndex[marketIndex];

    emit StakeAdded(user, address(token), amount, userIndexOfLastClaimedReward[marketIndex][user]);
  }

  /**
  @notice Allows users to shift their staked tokens from one side of the market to 
  the other at the next price.
  @param amountSyntheticTokensToShift Amount of tokens to shift.
  @param marketIndex Identifier for the market.
  @param isShiftFromLong Whether the shift is from long to short or short to long.
  */
  function shiftTokens(
    uint256 amountSyntheticTokensToShift,
    uint32 marketIndex,
    bool isShiftFromLong
  ) external virtual {
    address token = syntheticTokens[marketIndex][isShiftFromLong];
    require(userAmountStaked[token][msg.sender] >= amountSyntheticTokensToShift, "Not enough tokens to shift");

    // If the user has outstanding token shift that have already been confirmed in the LongShort
    // contract, execute them first.
    if (
      userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] != 0 &&
      userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] <
      batched_stakerNextTokenShiftIndex[marketIndex]
    ) {
      _mintAccumulatedFloat(marketIndex, msg.sender);
    }

    if (isShiftFromLong) {
      ILongShort(longShort).shiftPositionFromLongNextPrice(marketIndex, amountSyntheticTokensToShift);
      userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][
        msg.sender
      ] += amountSyntheticTokensToShift;
    } else {
      ILongShort(longShort).shiftPositionFromShortNextPrice(marketIndex, amountSyntheticTokensToShift);
      userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][
        msg.sender
      ] += amountSyntheticTokensToShift;
    }

    userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] = batched_stakerNextTokenShiftIndex[
      marketIndex
    ];
  }

  /*╔════════════════════════════╗
    ║    WITHDRAWAL & MINTING    ║
    ╚════════════════════════════╝*/

  /**
  @notice Internal logic for withdrawing stakes.
  @dev Mint user any outstanding float before withdrawing.
  @param marketIndex Market index of token.
  @param amount Amount to withdraw.
  @param token Synthetic token that was staked.
  */
  function _withdraw(
    uint32 marketIndex,
    address token,
    uint256 amount
  ) internal virtual {
    require(userAmountStaked[token][msg.sender] > 0, "nothing to withdraw");
    _mintAccumulatedFloat(marketIndex, msg.sender);

    userAmountStaked[token][msg.sender] = userAmountStaked[token][msg.sender] - amount;

    uint256 amountFees = (amount * marketUnstakeFee_e18[marketIndex]) / 1e18;

    IERC20(token).transfer(floatTreasury, amountFees);
    IERC20(token).transfer(msg.sender, amount - amountFees);

    emit StakeWithdrawn(msg.sender, token, amount);
  }

  /**
  @notice Withdraw function. Allows users to unstake.
  @param amount Amount to withdraw.
  @param token Address of the token for which to withdraw.
  */
  function withdraw(address token, uint256 amount) external {
    ILongShort(longShort).updateSystemState(marketIndexOfToken[token]);

    uint32 marketIndex = marketIndexOfToken[token];

    _withdraw(marketIndex, token, amount);

    if (userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] > 0) {
      // If they still have outstanding shifts after minting float, then check
      // that they don't withdraw more than their shifts allow.
      uint256 amountToShiftForThisToken = syntheticTokens[marketIndex][true] == token
        ? userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][msg.sender]
        : userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][msg.sender];

      require(
        userAmountStaked[token][msg.sender] >= amountToShiftForThisToken,
        "Outstanding next price stake shifts too great"
      );
    }
  }

  /**
  @notice Allows users to withdraw their entire stake for a token.
  @param token Address of the token for which to withdraw.
  */
  function withdrawAll(address token) external {
    ILongShort(longShort).updateSystemState(marketIndexOfToken[token]);

    uint32 marketIndex = marketIndexOfToken[token];

    uint256 amountToShiftForThisToken = syntheticTokens[marketIndex][true] == token
      ? userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][msg.sender]
      : userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][msg.sender];

    _withdraw(marketIndex, token, userAmountStaked[token][msg.sender] - amountToShiftForThisToken);
  }
}
.]

Let's

[2024-17-08 08:01:20 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: BUSL-1.1 pragma solidity 0.8.3; import "@openzeppelin/contracts-upgradeable/token/ERC20/presets/ERC20PresetMinterPauserUpgradeable.sol"; import "./interfaces/IFloatToken.sol"; import "./interfaces/ILongShort.sol"; import "./interfaces/IStaker.sol"; import "./interfaces/ISyntheticToken.sol"; contract Staker is IStaker, Initializable {   /╔═════════════════════════════╗     ║          VARIABLES          ║     ╚═════════════════════════════╝/ / ══════ Fixed-precision constants ══════ /   uint256 public constant FLOAT_ISSUANCE_FIXED_DECIMAL = 1e42;   // 2^52 ~= 4.5e15   // With an exponent of 5, the largest total liquidity possible in a market (to avoid integer overflow on exponentiation) is ~10^31 or 10 Trillion (10^13)   // NOTE: this also means if the total market value is less than 2^52 there will be a division by zero error   uint256 public constant safeExponentBitShifting = 52; / ══════ Global state ══════ /   address public admin;   address public floatCapital;   address public floatTreasury;   uint256 public floatPercentage; address public longShort;   address public floatToken; / ══════ Market specific ══════ /   mapping(uint32 =&gt; uint256) public marketLaunchIncentive_period; // seconds   mapping(uint32 =&gt; uint256) public marketLaunchIncentive_multipliers; // e18 scale   mapping(uint32 =&gt; uint256) public marketUnstakeFee_e18;   mapping(uint32 =&gt; uint256) public balanceIncentiveCurve_exponent;   mapping(uint32 =&gt; int256) public balanceIncentiveCurve_equilibriumOffset; mapping(uint32 =&gt; mapping(bool =&gt; address)) public syntheticTokens; mapping(address =&gt; uint32) public marketIndexOfToken; / ══════ Reward specific ══════ /   mapping(uint32 =&gt; uint256) public latestRewardIndex;   mapping(uint32 =&gt; mapping(uint256 =&gt; AccumulativeIssuancePerStakedSynthSnapshot))     public accumulativeFloatPerSyntheticTokenSnapshots;   struct AccumulativeIssuancePerStakedSynthSnapshot {     uint256 timestamp;     uint256 accumulativeFloatPerSyntheticToken_long;     uint256 accumulativeFloatPerSyntheticToken_short;   } / ══════ User specific ══════ /   mapping(uint32 =&gt; mapping(address =&gt; uint256)) public userIndexOfLastClaimedReward;   mapping(address =&gt; mapping(address =&gt; uint256)) public userAmountStaked; / ══════ Token shift management specific ══════ /   mapping(uint32 =&gt; uint256) public batched_stakerNextTokenShiftIndex;   /*   @notice Used to link a token shift to a staker state   @dev tokenShiftIndex =&gt; accumulativeFloatIssuanceSnapshotIndex     POSSIBLE OPTIMIZATION - could pack stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping and stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping into a struct of two uint128 for storage space optimization.   /   mapping(uint256 =&gt; uint256) public stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping;   /// @notice Used to fetch the price from LongShort at that point in time   /// @dev tokenShiftIndex =&gt; longShortMarketPriceSnapshotIndex   mapping(uint256 =&gt; uint256) public stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping;   /// @dev marketIndex =&gt; usersAddress =&gt; stakerTokenShiftIndex   mapping(uint32 =&gt; mapping(address =&gt; uint256)) public userNextPrice_stakedSyntheticTokenShiftIndex;   /// @dev marketIndex =&gt; usersAddress =&gt; amountUserRequestedToShiftAwayFromLongOnNextUpdate   mapping(uint32 =&gt; mapping(address =&gt; uint256)) public userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long;   /// @dev marketIndex =&gt; usersAddress =&gt; amountUserRequestedToShiftAwayFromShortOnNextUpdate   mapping(uint32 =&gt; mapping(address =&gt; uint256)) public userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short; /╔════════════════════════════╗     ║           EVENTS           ║     ╚════════════════════════════╝/ event StakerV1(     address admin,     address floatTreasury,     address floatCapital,     address floatToken,     uint256 floatPercentage   ); event MarketAddedToStaker(     uint32 marketIndex,     uint256 exitFee_e18,     uint256 period,     uint256 multiplier,     uint256 balanceIncentiveExponent,     int256 balanceIncentiveEquilibriumOffset   ); event AccumulativeIssuancePerStakedSynthSnapshotCreated(     uint32 marketIndex,     uint256 accumulativeFloatIssuanceSnapshotIndex,     uint256 accumulativeLong,     uint256 accumulativeShort   ); event StakeAdded(address user, address token, uint256 amount, uint256 lastMintIndex); event StakeWithdrawn(address user, address token, uint256 amount); // Note: the amountFloatMinted isn't strictly needed by the graph, but it is good to add it to validate calculations are accurate.   event FloatMinted(address user, uint32 marketIndex, uint256 amountFloatMinted); event MarketLaunchIncentiveParametersChanges(uint32 marketIndex, uint256 period, uint256 multiplier); event StakeWithdrawalFeeUpdated(uint32 marketIndex, uint256 stakeWithdralFee); event BalanceIncentiveExponentUpdated(uint32 marketIndex, uint256 balanceIncentiveExponent); event BalanceIncentiveEquilibriumOffsetUpdated(uint32 marketIndex, int256 balanceIncentiveEquilibriumOffset); event FloatPercentageUpdated(uint256 floatPercentage); event SyntheticTokensShifted(); event ChangeAdmin(address newAdmin); /╔═════════════════════════════╗     ║          MODIFIERS          ║     ╚═════════════════════════════╝/ function onlyAdminModifierLogic() internal virtual {     require(msg.sender == admin, "not admin");   } modifier onlyAdmin() {     onlyAdminModifierLogic();     _;   } function onlyValidSyntheticModifierLogic(address _synth) internal virtual {     require(marketIndexOfToken[_synth] != 0, "not valid synth");   } modifier onlyValidSynthetic(address synth) {     onlyValidSyntheticModifierLogic(_synth);     ;   } function onlyValidMarketModifierLogic(uint32 marketIndex) internal virtual {     require(address(syntheticTokens[marketIndex][true]) != address(0), "not valid market");   } modifier onlyValidMarket(uint32 marketIndex) {     onlyValidMarketModifierLogic(marketIndex);     _;   } function onlyLongShortModifierLogic() internal virtual {     require(msg.sender == address(longShort), "not long short");   } modifier onlyLongShort() {     onlyLongShortModifierLogic();     _;   } /╔═════════════════════════════╗     ║       CONTRACT SET-UP       ║     ╚═════════════════════════════╝/ /*   @notice Initializes the contract.   @dev Calls OpenZeppelin's initializer modifier.   @param _admin Address of the admin role.   @param _longShort Address of the LongShort contract, a deployed LongShort.sol   @param _floatToken Address of the Float token earned by staking.   @param _floatTreasury Address of the treasury contract for managing fees.   @param _floatCapital Address of the contract which earns a fixed percentage of Float.   @param _floatPercentage Determines the float percentage that gets minted for Float Capital, base 1e18.   /   function initialize(     address _admin,     address _longShort,     address _floatToken,     address _floatTreasury,     address _floatCapital,     uint256 _floatPercentage   ) external virtual initializer {     admin = _admin;     floatCapital = _floatCapital;     floatTreasury = _floatTreasury;     longShort = _longShort;     floatToken = _floatToken; _changeFloatPercentage(_floatPercentage);  emit StakerV1(_admin, _floatTreasury, _floatCapital, _floatToken, _floatPercentage);  } /╔═══════════════════╗     ║       ADMIN       ║     ╚═══════════════════╝/ /*    @notice Changes admin for the contract   @param _admin The address of the new admin.   /   function changeAdmin(address _admin) external onlyAdmin {     admin = _admin;     emit ChangeAdmin(_admin);   } /// @dev Logic for changeFloatPercentage   function _changeFloatPercentage(uint256 newFloatPercentage) internal virtual {     require(newFloatPercentage &lt;= 1e18 &amp;&amp; newFloatPercentage &gt; 0); // less than or equal to 100% and greater than 0%     floatPercentage = newFloatPercentage;   } /*   @notice Changes percentage of float that is minted for float capital.   @param newFloatPercentage The new float percentage in base 1e18.   /   function changeFloatPercentage(uint256 newFloatPercentage) external onlyAdmin {     _changeFloatPercentage(newFloatPercentage);     emit FloatPercentageUpdated(newFloatPercentage);   } /// @dev Logic for changeUnstakeFee   function _changeUnstakeFee(uint32 marketIndex, uint256 newMarketUnstakeFee_e18) internal virtual {     require(newMarketUnstakeFee_e18 &lt;= 5e16); // Explicitely stating 5% fee as the max fee possible.     marketUnstakeFee_e18[marketIndex] = newMarketUnstakeFee_e18;   } /*   @notice Changes unstake fee for a market   @param marketIndex Identifies the market.   @param newMarketUnstakeFee_e18 The new unstake fee.   /   function changeUnstakeFee(uint32 marketIndex, uint256 newMarketUnstakeFee_e18) external onlyAdmin {     _changeUnstakeFee(marketIndex, newMarketUnstakeFee_e18);     emit StakeWithdrawalFeeUpdated(marketIndex, newMarketUnstakeFee_e18);   } /// @dev Logic for changeMarketLaunchIncentiveParameters   function _changeMarketLaunchIncentiveParameters(     uint32 marketIndex,     uint256 period,     uint256 initialMultiplier   ) internal virtual {     require(initialMultiplier &gt;= 1e18, "marketLaunchIncentiveMultiplier must be &gt;= 1e18"); marketLaunchIncentive_period[marketIndex] = period; marketLaunchIncentive_multipliers[marketIndex] = initialMultiplier;  } /*   @notice Changes the market launch incentive parameters for a market   @param marketIndex Identifies the market.   @param period The new period for which float token generation should be boosted.   @param initialMultiplier The new multiplier on Float generation.   /   function changeMarketLaunchIncentiveParameters(     uint32 marketIndex,     uint256 period,     uint256 initialMultiplier   ) external onlyAdmin {     _changeMarketLaunchIncentiveParameters(marketIndex, period, initialMultiplier); emit MarketLaunchIncentiveParametersChanges(marketIndex, period, initialMultiplier);  } /// @dev Logic for changeBalanceIncentiveExponent   function _changeBalanceIncentiveExponent(uint32 marketIndex, uint256 _balanceIncentiveCurve_exponent)     internal     virtual   {     require(       // The exponent has to be less than 5 in these versions of the contracts.       _balanceIncentiveCurve_exponent &gt; 0 &amp;&amp; _balanceIncentiveCurve_exponent &lt; 6,       "balanceIncentiveCurve_exponent out of bounds"     ); balanceIncentiveCurve_exponent[marketIndex] = _balanceIncentiveCurve_exponent;  } /*    @notice Changes the balance incentive exponent for a market   @param marketIndex Identifies the market.   @param _balanceIncentiveCurve_exponent The new exponent for the curve.   /   function changeBalanceIncentiveExponent(uint32 marketIndex, uint256 _balanceIncentiveCurve_exponent)     external     onlyAdmin   {     _changeBalanceIncentiveExponent(marketIndex, _balanceIncentiveCurve_exponent); emit BalanceIncentiveExponentUpdated(marketIndex, _balanceIncentiveCurve_exponent);  } /// @dev Logic for changeBalanceIncentiveEquilibriumOffset   function _changeBalanceIncentiveEquilibriumOffset(uint32 marketIndex, int256 _balanceIncentiveCurve_equilibriumOffset)     internal     virtual   {     // Unreasonable that we would ever shift this more than 90% either way     require(       _balanceIncentiveCurve_equilibriumOffset &gt; -9e17 &amp;&amp; _balanceIncentiveCurve_equilibriumOffset &lt; 9e17,       "balanceIncentiveCurve_equilibriumOffset out of bounds"     ); balanceIncentiveCurve_equilibriumOffset[marketIndex] = _balanceIncentiveCurve_equilibriumOffset;  } /*   @notice Changes the balance incentive curve equilibrium offset for a market   @param marketIndex Identifies the market.   @param _balanceIncentiveCurve_equilibriumOffset The new offset.   /   function changeBalanceIncentiveEquilibriumOffset(uint32 marketIndex, int256 _balanceIncentiveCurve_equilibriumOffset)     external     onlyAdmin   {     _changeBalanceIncentiveEquilibriumOffset(marketIndex, _balanceIncentiveCurve_equilibriumOffset); emit BalanceIncentiveEquilibriumOffsetUpdated(marketIndex, _balanceIncentiveCurve_equilibriumOffset);  } /╔═════════════════════════════╗     ║        STAKING SETUP        ║     ╚═════════════════════════════╝/ /*   @notice Sets this contract to track staking for a market in LongShort.sol   @param marketIndex Identifies the market.   @param longToken Address of the long token for the market.   @param shortToken Address of the short token for the market.   @param kInitialMultiplier Initial boost on float generation for the market.   @param kPeriod Period which the boost should last.   @param unstakeFee_e18 Percentage of tokens that are levied on unstaking in base 1e18.   @param _balanceIncentiveCurve_exponent Exponent for balance curve (see _calculateFloatPerSecond)   @param _balanceIncentiveCurve_equilibriumOffset Offset for balance curve (see _calculateFloatPerSecond)   /   function addNewStakingFund(     uint32 marketIndex,     address longToken,     address shortToken,     uint256 kInitialMultiplier,     uint256 kPeriod,     uint256 unstakeFee_e18,     uint256 _balanceIncentiveCurve_exponent,     int256 _balanceIncentiveCurve_equilibriumOffset   ) external override onlyLongShort {     marketIndexOfToken[longToken] = marketIndex;     marketIndexOfToken[shortToken] = marketIndex; accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].timestamp = block.timestamp; accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].accumulativeFloatPerSyntheticToken_long = 0; accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].accumulativeFloatPerSyntheticToken_short = 0;  syntheticTokens[marketIndex][true] = longToken; syntheticTokens[marketIndex][false] = shortToken;  _changeBalanceIncentiveExponent(marketIndex, _balanceIncentiveCurve_exponent); _changeBalanceIncentiveEquilibriumOffset(marketIndex, _balanceIncentiveCurve_equilibriumOffset); _changeMarketLaunchIncentiveParameters(marketIndex, kPeriod, kInitialMultiplier);  _changeUnstakeFee(marketIndex, unstakeFee_e18);  // Set this value to one initially - 0 is a null value and thus potentially bug prone. batched_stakerNextTokenShiftIndex[marketIndex] = 1;  emit MarketAddedToStaker(   marketIndex,   unstakeFee_e18,   kPeriod,   kInitialMultiplier,   _balanceIncentiveCurve_exponent,   _balanceIncentiveCurve_equilibriumOffset );  emit AccumulativeIssuancePerStakedSynthSnapshotCreated(marketIndex, 0, 0, 0);  } /╔═════════════════════════════════════════════════════════════════════════╗     ║    GLOBAL FLT REWARD ACCUMULATION CALCULATION AND TRACKING FUNCTIONS    ║     ╚═════════════════════════════════════════════════════════════════════════╝/ /*   @notice Returns the K factor parameters for the given market with sensible   defaults if they haven't been set yet.   @param marketIndex The market to change the parameters for.   @return period The period for which the k factor applies for in seconds.   @return multiplier The multiplier on Float generation in this period.   /   function _getMarketLaunchIncentiveParameters(uint32 marketIndex)     internal     view     virtual     returns (uint256 period, uint256 multiplier)   {     period = marketLaunchIncentive_period[marketIndex];     multiplier = marketLaunchIncentive_multipliers[marketIndex]; if (multiplier &lt; 1e18) {   multiplier = 1e18; // multiplier of 1 by default }  } /*    @notice Returns the extent to which a markets float generation should be adjusted   based on the market's launch incentive parameters. Should start at multiplier   then linearly change to 1e18 over time.   @param marketIndex Identifies the market.   @return k The calculated modifier for float generation.   /   function _getKValue(uint32 marketIndex) internal view virtual returns (uint256) {     // Parameters controlling the float issuance multiplier.     (uint256 kPeriod, uint256 kInitialMultiplier) = _getMarketLaunchIncentiveParameters(marketIndex); // Sanity check - under normal circumstances, the multipliers should // *never* be set to a value &lt; 1e18, as there are guards against this. assert(kInitialMultiplier &gt;= 1e18);  uint256 initialTimestamp = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].timestamp;  if (block.timestamp - initialTimestamp &lt;= kPeriod) {   return kInitialMultiplier - (((kInitialMultiplier - 1e18) * (block.timestamp - initialTimestamp)) / kPeriod); } else {   return 1e18; }  } /   @notice Computes the number of float tokens a user earns per second for   every long/short synthetic token they've staked. The returned value has   a fixed decimal scale of 1e42 (!!!) for numerical stability. The return   values are float per second per synthetic token (hence the requirement   to multiply by price)   @dev to see below math in latex form see TODO add link   to interact with the equations see https://www.desmos.com/calculator/optkaxyihr   @param marketIndex The market referred to.   @param longPrice Price of the synthetic long token in units of payment token   @param shortPrice Price of the synthetic short token in units of payment token   @param longValue Amount of payment token in the long side of the market   @param shortValue Amount of payment token in the short side of the market   @return longFloatPerSecond Float token per second per long synthetic token   @return shortFloatPerSecond Float token per second per short synthetic token    /   function _calculateFloatPerSecond(     uint32 marketIndex,     uint256 longPrice,     uint256 shortPrice,     uint256 longValue,     uint256 shortValue   ) internal view virtual returns (uint256 longFloatPerSecond, uint256 shortFloatPerSecond) {     // A float issuance multiplier that starts high and decreases linearly     // over time to a value of 1. This incentivises users to stake early.     uint256 k = _getKValue(marketIndex); uint256 totalLocked = (longValue + shortValue);  // we need to scale this number by the totalLocked so that the offset remains consistent accross market size  int256 equilibriumOffsetMarketScaled = (balanceIncentiveCurve_equilibriumOffset[marketIndex] *   int256(totalLocked)) / 2e18;  uint256 denominator = ((totalLocked &gt;&gt; safeExponentBitShifting)**balanceIncentiveCurve_exponent[marketIndex]);  // Float is scaled by the percentage of the total market value held in // the opposite position. This incentivises users to stake on the // weaker position. if (int256(shortValue) - equilibriumOffsetMarketScaled &lt; int256(longValue)) {   if (equilibriumOffsetMarketScaled &gt;= int256(shortValue)) {     // edge case: imbalanced far past the equilibrium offset - full rewards go to short token     //            extremeley unlikely to happen in practice     return (0, 1e18 * k * shortPrice);   }    uint256 numerator = (uint256(int256(shortValue) - equilibriumOffsetMarketScaled) &gt;&gt;     (safeExponentBitShifting - 1))**balanceIncentiveCurve_exponent[marketIndex];    // NOTE: `x * 5e17` == `(x * 10e18) / 2`   uint256 longRewardUnscaled = (numerator * 5e17) / denominator;   uint256 shortRewardUnscaled = 1e18 - longRewardUnscaled;    return ((longRewardUnscaled * k * longPrice) / 1e18, (shortRewardUnscaled * k * shortPrice) / 1e18); } else {   if (-equilibriumOffsetMarketScaled &gt;= int256(longValue)) {     // edge case: imbalanced far past the equilibrium offset - full rewards go to long token     //            extremeley unlikely to happen in practice     return (1e18 * k * longPrice, 0);   }    uint256 numerator = (uint256(int256(longValue) + equilibriumOffsetMarketScaled) &gt;&gt;     (safeExponentBitShifting - 1))**balanceIncentiveCurve_exponent[marketIndex];    // NOTE: `x * 5e17` == `(x * 10e18) / 2`   uint256 shortRewardUnscaled = (numerator * 5e17) / denominator;   uint256 longRewardUnscaled = 1e18 - shortRewardUnscaled;    return ((longRewardUnscaled * k * longPrice) / 1e18, (shortRewardUnscaled * k * shortPrice) / 1e18); }  } /*   @notice Computes the time since last accumulativeIssuancePerStakedSynthSnapshot for the given market in seconds.   @param marketIndex The market referred to.   @return The time difference in seconds   /   function _calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(uint32 marketIndex)     internal     view     virtual     returns (uint256)   {     return       block.timestamp -       accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]].timestamp;   } /*   @notice Computes new cumulative sum of 'r' value since last accumulativeIssuancePerStakedSynthSnapshot. We use   cumulative 'r' value to avoid looping during issuance. Note that the   cumulative sum is kept in 1e42 scale (!!!) to avoid numerical issues.   @param shortValue The value locked in the short side of the market.   @param longValue The value locked in the long side of the market.   @param shortPrice The price of the short token as defined in LongShort.sol   @param longPrice The price of the long token as defined in LongShort.sol   @param marketIndex An identifier for the market.   @return longCumulativeRates The long cumulative sum.   @return shortCumulativeRates The short cumulative sum.   /   function _calculateNewCumulativeIssuancePerStakedSynth(     uint32 marketIndex,     uint256 longPrice,     uint256 shortPrice,     uint256 longValue,     uint256 shortValue   ) internal view virtual returns (uint256 longCumulativeRates, uint256 shortCumulativeRates) {     // Compute the current 'r' value for float issuance per second.     (uint256 longFloatPerSecond, uint256 shortFloatPerSecond) = _calculateFloatPerSecond(       marketIndex,       longPrice,       shortPrice,       longValue,       shortValue     ); // Compute time since last accumulativeIssuancePerStakedSynthSnapshot for the given token. uint256 timeDelta = _calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(marketIndex);  // Compute new cumulative 'r' value total. return (   accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]]   .accumulativeFloatPerSyntheticToken_long + (timeDelta * longFloatPerSecond),   accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]]   .accumulativeFloatPerSyntheticToken_short + (timeDelta * shortFloatPerSecond) );  } /*   @notice Creates a new accumulativeIssuancePerStakedSynthSnapshot for the given token and updates indexes.   @param shortValue The value locked in the short side of the market.   @param longValue The value locked in the long side of the market.   @param shortPrice The price of the short token as defined in LongShort.sol   @param longPrice The price of the long token as defined in LongShort.sol   @param marketIndex An identifier for the market.   /   function _setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot(     uint32 marketIndex,     uint256 longPrice,     uint256 shortPrice,     uint256 longValue,     uint256 shortValue   ) internal virtual {     (       uint256 newLongAccumulativeValue,       uint256 newShortAccumulativeValue     ) = _calculateNewCumulativeIssuancePerStakedSynth(marketIndex, longPrice, shortPrice, longValue, shortValue); uint256 newIndex = latestRewardIndex[marketIndex] + 1;  // Set cumulative 'r' value on new accumulativeIssuancePerStakedSynthSnapshot. accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex] .accumulativeFloatPerSyntheticToken_long = newLongAccumulativeValue; accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex] .accumulativeFloatPerSyntheticToken_short = newShortAccumulativeValue;  // Set timestamp on new accumulativeIssuancePerStakedSynthSnapshot. accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex].timestamp = block.timestamp;  // Update latest index to point to new accumulativeIssuancePerStakedSynthSnapshot. latestRewardIndex[marketIndex] = newIndex;  emit AccumulativeIssuancePerStakedSynthSnapshotCreated(   marketIndex,   newIndex,   newLongAccumulativeValue,   newShortAccumulativeValue );  } /*   @notice Adds new accumulativeIssuancePerStakedSynthSnapshots for the given long/short tokens. Called by the   ILongShort contract whenever there is a state change for a market.   @param stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted Mapping from this contract's shifts to LongShort.sols next price snapshots.   @param shortValue The value locked in the short side of the market.   @param longValue The value locked in the long side of the market.   @param shortPrice The price of the short token as defined in LongShort.sol   @param longPrice The price of the long token as defined in LongShort.sol   @param marketIndex An identifier for the market.   /   function pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(     uint32 marketIndex,     uint256 longPrice,     uint256 shortPrice,     uint256 longValue,     uint256 shortValue,     uint256 stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted // This value should be ALWAYS be zero if no shift occured   ) external override onlyLongShort {     // Only add a new accumulativeIssuancePerStakedSynthSnapshot if some time has passed. // the `stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted` value will be 0 if there is no staker related action in an executed batch if (stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted &gt; 0) {   stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[     batched_stakerNextTokenShiftIndex[marketIndex]   ] = stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted;   stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[     batched_stakerNextTokenShiftIndex[marketIndex]   ] = latestRewardIndex[marketIndex] + 1;   batched_stakerNextTokenShiftIndex[marketIndex] += 1;    emit SyntheticTokensShifted(); }  // Time delta is fetched twice in below code, can pass through? Which is less gas? if (_calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(marketIndex) &gt; 0) {   _setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot(     marketIndex,     longPrice,     shortPrice,     longValue,     shortValue   ); }  } /╔═══════════════════════════════════╗     ║    USER REWARD STATE FUNCTIONS    ║     ╚═══════════════════════════════════╝/ /// @dev Calculates the accumulated float in a specific range of staker snapshots   function _calculateAccumulatedFloatInRange(     uint32 marketIndex,     uint256 amountStakedLong,     uint256 amountStakedShort,     uint256 rewardIndexFrom,     uint256 rewardIndexTo   ) internal view virtual returns (uint256 floatReward) {     if (amountStakedLong &gt; 0) {       uint256 accumDeltaLong = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexTo]       .accumulativeFloatPerSyntheticToken_long -         accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexFrom]         .accumulativeFloatPerSyntheticToken_long;       floatReward += (accumDeltaLong * amountStakedLong) / FLOAT_ISSUANCE_FIXED_DECIMAL;     } if (amountStakedShort &gt; 0) {   uint256 accumDeltaShort = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexTo]   .accumulativeFloatPerSyntheticToken_short -     accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexFrom]     .accumulativeFloatPerSyntheticToken_short;   floatReward += (accumDeltaShort * amountStakedShort) / FLOAT_ISSUANCE_FIXED_DECIMAL; }  } /*    @notice Calculates float owed to the user since the user last minted float for a market.   @param marketIndex Identifier for the market which the user staked in.   @param user The address of the user.   @return floatReward The amount of float owed.    /   function _calculateAccumulatedFloat(uint32 marketIndex, address user) internal virtual returns (uint256 floatReward) {     address longToken = syntheticTokens[marketIndex][true];     address shortToken = syntheticTokens[marketIndex][false]; uint256 amountStakedLong = userAmountStaked[longToken][user]; uint256 amountStakedShort = userAmountStaked[shortToken][user];  uint256 usersLastRewardIndex = userIndexOfLastClaimedReward[marketIndex][user];  // Don't do the calculation and return zero immediately if there is no change if (usersLastRewardIndex == latestRewardIndex[marketIndex]) {   return 0; }  uint256 usersShiftIndex = userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][user]; // if there is a change in the users tokens held due to a token shift (or possibly another action in the future) if (usersShiftIndex &gt; 0 &amp;&amp; usersShiftIndex &lt; batched_stakerNextTokenShiftIndex[marketIndex]) {   floatReward = _calculateAccumulatedFloatInRange(     marketIndex,     amountStakedLong,     amountStakedShort,     usersLastRewardIndex,     stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[usersShiftIndex]   );    // Update the users balances   if (userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user] &gt; 0) {     amountStakedShort += ILongShort(longShort).getAmountSyntheticTokenToMintOnTargetSide(       marketIndex,       userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user],       true,       stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[usersShiftIndex]     );      amountStakedLong -= userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user];     userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user] = 0;   }    if (userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user] &gt; 0) {     amountStakedLong += ILongShort(longShort).getAmountSyntheticTokenToMintOnTargetSide(       marketIndex,       userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user],       false,       stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[usersShiftIndex]     );      amountStakedShort -= userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user];     userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user] = 0;   }    // Save the users updated staked amounts   userAmountStaked[longToken][user] = amountStakedLong;   userAmountStaked[shortToken][user] = amountStakedShort;    floatReward += _calculateAccumulatedFloatInRange(     marketIndex,     amountStakedLong,     amountStakedShort,     stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[usersShiftIndex],     latestRewardIndex[marketIndex]   );    userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][user] = 0; } else {   floatReward = _calculateAccumulatedFloatInRange(     marketIndex,     amountStakedLong,     amountStakedShort,     usersLastRewardIndex,     latestRewardIndex[marketIndex]   ); }  } /*   @notice Mints float for a user.   @dev Mints a fixed percentage for Float capital.   @param user The address of the user.   @param floatToMint The amount of float to mint.    /   function _mintFloat(address user, uint256 floatToMint) internal virtual {     IFloatToken(floatToken).mint(user, floatToMint);     IFloatToken(floatToken).mint(floatCapital, (floatToMint * floatPercentage) / 1e18);   } /*   @notice Mints float owed to a user for a market since they last minted.   @param marketIndex An identifier for the market.   @param user The address of the user.    /   function _mintAccumulatedFloat(uint32 marketIndex, address user) internal virtual {     uint256 floatToMint = _calculateAccumulatedFloat(marketIndex, user); if (floatToMint &gt; 0) {   // Set the user has claimed up until now, stops them setting this forward   userIndexOfLastClaimedReward[marketIndex][user] = latestRewardIndex[marketIndex];    _mintFloat(user, floatToMint);   emit FloatMinted(user, marketIndex, floatToMint); }  } /*   @notice Mints float owed to a user for multiple markets, since they last minted for those markets.   @param marketIndexes Identifiers for the markets.   @param user The address of the user.    /   function _mintAccumulatedFloatMulti(uint32[] calldata marketIndexes, address user) internal virtual {     uint256 floatTotal = 0;     for (uint256 i = 0; i &lt; marketIndexes.length; i++) {       uint256 floatToMint = _calculateAccumulatedFloat(marketIndexes[i], user);   if (floatToMint &gt; 0) {     // Set the user has claimed up until now, stops them setting this forward     userIndexOfLastClaimedReward[marketIndexes[i]][user] = latestRewardIndex[marketIndexes[i]];      floatTotal += floatToMint;      emit FloatMinted(user, marketIndexes[i], floatToMint);   } } if (floatTotal &gt; 0) {   _mintFloat(user, floatTotal); }  } /*   @notice Mints outstanding float for msg.sender.   @param marketIndexes Identifiers for the markets for which to mint float.    /   function claimFloatCustom(uint32[] calldata marketIndexes) external {     ILongShort(longShort).updateSystemStateMulti(marketIndexes);     _mintAccumulatedFloatMulti(marketIndexes, msg.sender);   } /*   @notice Mints outstanding float on behalf of another user.   @param marketIndexes Identifiers for the markets for which to mint float.   @param user The address of the user.    /   function claimFloatCustomFor(uint32[] calldata marketIndexes, address user) external {     // Unbounded loop - users are responsible for paying their own gas costs on these and it doesn't effect the rest of the system.     // No need to impose limit.     ILongShort(longShort).updateSystemStateMulti(marketIndexes);     _mintAccumulatedFloatMulti(marketIndexes, user);   } /╔═══════════════════════╗     ║        STAKING        ║     ╚═══════════════════════╝/ /*   @notice A user with synthetic tokens stakes by calling stake on the token   contract which calls this function. We need to first update the   state of the LongShort contract for this market before staking to correctly calculate user rewards.   @param amount Amount to stake.   @param from Address to stake for.   /   function stakeFromUser(address from, uint256 amount) public virtual override onlyValidSynthetic((msg.sender)) {     ILongShort(longShort).updateSystemState(marketIndexOfToken[(msg.sender)]);     _stake((msg.sender), amount, from);   } /*   @dev Internal logic for staking.   @param token Address of the token for which to stake.   @param amount Amount to stake.   @param user Address to stake for.   /   function _stake(     address token,     uint256 amount,     address user   ) internal virtual {     uint32 marketIndex = marketIndexOfToken[token]; // If they already have staked and have rewards due, mint these. if (   userIndexOfLastClaimedReward[marketIndex][user] != 0 &amp;&amp;   userIndexOfLastClaimedReward[marketIndex][user] &lt; latestRewardIndex[marketIndex] ) {   _mintAccumulatedFloat(marketIndex, user); }  userAmountStaked[token][user] = userAmountStaked[token][user] + amount;  userIndexOfLastClaimedReward[marketIndex][user] = latestRewardIndex[marketIndex];  emit StakeAdded(user, address(token), amount, userIndexOfLastClaimedReward[marketIndex][user]);  } /*   @notice Allows users to shift their staked tokens from one side of the market to    the other at the next price.   @param amountSyntheticTokensToShift Amount of tokens to shift.   @param marketIndex Identifier for the market.   @param isShiftFromLong Whether the shift is from long to short or short to long.   /   function shiftTokens(     uint256 amountSyntheticTokensToShift,     uint32 marketIndex,     bool isShiftFromLong   ) external virtual {     address token = syntheticTokens[marketIndex][isShiftFromLong];     require(userAmountStaked[token][msg.sender] &gt;= amountSyntheticTokensToShift, "Not enough tokens to shift"); // If the user has outstanding token shift that have already been confirmed in the LongShort // contract, execute them first. if (   userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] != 0 &amp;&amp;   userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] &lt;   batched_stakerNextTokenShiftIndex[marketIndex] ) {   _mintAccumulatedFloat(marketIndex, msg.sender); }  if (isShiftFromLong) {   ILongShort(longShort).shiftPositionFromLongNextPrice(marketIndex, amountSyntheticTokensToShift);   userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][     msg.sender   ] += amountSyntheticTokensToShift; } else {   ILongShort(longShort).shiftPositionFromShortNextPrice(marketIndex, amountSyntheticTokensToShift);   userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][     msg.sender   ] += amountSyntheticTokensToShift; }  userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] = batched_stakerNextTokenShiftIndex[   marketIndex ];  } /╔════════════════════════════╗     ║    WITHDRAWAL &amp; MINTING    ║     ╚════════════════════════════╝/ /*   @notice Internal logic for withdrawing stakes.   @dev Mint user any outstanding float before withdrawing.   @param marketIndex Market index of token.   @param amount Amount to withdraw.   @param token Synthetic token that was staked.   /   function _withdraw(     uint32 marketIndex,     address token,     uint256 amount   ) internal virtual {     require(userAmountStaked[token][msg.sender] &gt; 0, "nothing to withdraw");     _mintAccumulatedFloat(marketIndex, msg.sender); userAmountStaked[token][msg.sender] = userAmountStaked[token][msg.sender] - amount;  uint256 amountFees = (amount * marketUnstakeFee_e18[marketIndex]) / 1e18;  IERC20(token).transfer(floatTreasury, amountFees); IERC20(token).transfer(msg.sender, amount - amountFees);  emit StakeWithdrawn(msg.sender, token, amount);  } /*   @notice Withdraw function. Allows users to unstake.   @param amount Amount to withdraw.   @param token Address of the token for which to withdraw.   /   function withdraw(address token, uint256 amount) external {     ILongShort(longShort).updateSystemState(marketIndexOfToken[token]); uint32 marketIndex = marketIndexOfToken[token];  _withdraw(marketIndex, token, amount);  if (userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] &gt; 0) {   // If they still have outstanding shifts after minting float, then check   // that they don't withdraw more than their shifts allow.   uint256 amountToShiftForThisToken = syntheticTokens[marketIndex][true] == token     ? userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][msg.sender]     : userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][msg.sender];    require(     userAmountStaked[token][msg.sender] &gt;= amountToShiftForThisToken,     "Outstanding next price stake shifts too great"   ); }  } /*   @notice Allows users to withdraw their entire stake for a token.   @param token Address of the token for which to withdraw.   /   function withdrawAll(address token) external {     ILongShort(longShort).updateSystemState(marketIndexOfToken[token]); uint32 marketIndex = marketIndexOfToken[token];  uint256 amountToShiftForThisToken = syntheticTokens[marketIndex][true] == token   ? userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][msg.sender]   : userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][msg.sender];  _withdraw(marketIndex, token, userAmountStaked[token][msg.sender] - amountToShiftForThisToken);  } } |
| **assistant_role_name** | Chief Executive Officer |
| **user_role_name** | Counselor |
| **phase_prompt** | Here is a conversation between two roles: {conversations} {question} |
| **phase_name** | Reflection |
| **assistant_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Counselor. Now, we share a common interest in collaborating to successfully complete a task assigned by a new customer. Your main responsibilities include asking what user and customer think and provide your valuable suggestions.  Here is a new customer's task: {task}. |
| **placeholders** | {'conversations': 'Security Analyst: We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.\nYou are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.\nYou can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites\nHere is a new customer\'s task: // SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.3;\nimport "@openzeppelin/contracts-upgradeable/token/ERC20/presets/ERC20PresetMinterPauserUpgradeable.sol";\nimport "./interfaces/IFloatToken.sol";\nimport "./interfaces/ILongShort.sol";\nimport "./interfaces/IStaker.sol";\nimport "./interfaces/ISyntheticToken.sol";\ncontract Staker is IStaker, Initializable {\n  /╔═════════════════════════════╗\n    ║          VARIABLES          ║\n    ╚═════════════════════════════╝/\n  / ══════ Fixed-precision constants ══════ /\n  uint256 public constant FLOAT_ISSUANCE_FIXED_DECIMAL = 1e42;\n  // 2^52 ~= 4.5e15\n  // With an exponent of 5, the largest total liquidity possible in a market (to avoid integer overflow on exponentiation) is ~10^31 or 10 Trillion (10^13)\n  // NOTE: this also means if the total market value is less than 2^52 there will be a division by zero error\n  uint256 public constant safeExponentBitShifting = 52;\n  / ══════ Global state ══════ /\n  address public admin;\n  address public floatCapital;\n  address public floatTreasury;\n  uint256 public floatPercentage;\n  address public longShort;\n  address public floatToken;\n  / ══════ Market specific ══════ /\n  mapping(uint32 =&gt; uint256) public marketLaunchIncentive_period; // seconds\n  mapping(uint32 =&gt; uint256) public marketLaunchIncentive_multipliers; // e18 scale\n  mapping(uint32 =&gt; uint256) public marketUnstakeFee_e18;\n  mapping(uint32 =&gt; uint256) public balanceIncentiveCurve_exponent;\n  mapping(uint32 =&gt; int256) public balanceIncentiveCurve_equilibriumOffset;\n  mapping(uint32 =&gt; mapping(bool =&gt; address)) public syntheticTokens;\n  mapping(address =&gt; uint32) public marketIndexOfToken;\n  / ══════ Reward specific ══════ /\n  mapping(uint32 =&gt; uint256) public latestRewardIndex;\n  mapping(uint32 =&gt; mapping(uint256 =&gt; AccumulativeIssuancePerStakedSynthSnapshot))\n    public accumulativeFloatPerSyntheticTokenSnapshots;\n  struct AccumulativeIssuancePerStakedSynthSnapshot {\n    uint256 timestamp;\n    uint256 accumulativeFloatPerSyntheticToken_long;\n    uint256 accumulativeFloatPerSyntheticToken_short;\n  }\n  / ══════ User specific ══════ /\n  mapping(uint32 =&gt; mapping(address =&gt; uint256)) public userIndexOfLastClaimedReward;\n  mapping(address =&gt; mapping(address =&gt; uint256)) public userAmountStaked;\n  / ══════ Token shift management specific ══════ /\n  mapping(uint32 =&gt; uint256) public batched_stakerNextTokenShiftIndex;\n  /\n  @notice Used to link a token shift to a staker state\n  @dev tokenShiftIndex =&gt; accumulativeFloatIssuanceSnapshotIndex\n    POSSIBLE OPTIMIZATION - could pack stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping and stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping into a struct of two uint128 for storage space optimization.\n  /\n  mapping(uint256 =&gt; uint256) public stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping;\n  /// @notice Used to fetch the price from LongShort at that point in time\n  /// @dev tokenShiftIndex =&gt; longShortMarketPriceSnapshotIndex\n  mapping(uint256 =&gt; uint256) public stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping;\n  /// @dev marketIndex =&gt; usersAddress =&gt; stakerTokenShiftIndex\n  mapping(uint32 =&gt; mapping(address =&gt; uint256)) public userNextPrice_stakedSyntheticTokenShiftIndex;\n  /// @dev marketIndex =&gt; usersAddress =&gt; amountUserRequestedToShiftAwayFromLongOnNextUpdate\n  mapping(uint32 =&gt; mapping(address =&gt; uint256)) public userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long;\n  /// @dev marketIndex =&gt; usersAddress =&gt; amountUserRequestedToShiftAwayFromShortOnNextUpdate\n  mapping(uint32 =&gt; mapping(address =&gt; uint256)) public userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short;\n  /╔════════════════════════════╗\n    ║           EVENTS           ║\n    ╚════════════════════════════╝/\n  event StakerV1(\n    address admin,\n    address floatTreasury,\n    address floatCapital,\n    address floatToken,\n    uint256 floatPercentage\n  );\n  event MarketAddedToStaker(\n    uint32 marketIndex,\n    uint256 exitFee_e18,\n    uint256 period,\n    uint256 multiplier,\n    uint256 balanceIncentiveExponent,\n    int256 balanceIncentiveEquilibriumOffset\n  );\n  event AccumulativeIssuancePerStakedSynthSnapshotCreated(\n    uint32 marketIndex,\n    uint256 accumulativeFloatIssuanceSnapshotIndex,\n    uint256 accumulativeLong,\n    uint256 accumulativeShort\n  );\n  event StakeAdded(address user, address token, uint256 amount, uint256 lastMintIndex);\n  event StakeWithdrawn(address user, address token, uint256 amount);\n  // Note: the amountFloatMinted isn\'t strictly needed by the graph, but it is good to add it to validate calculations are accurate.\n  event FloatMinted(address user, uint32 marketIndex, uint256 amountFloatMinted);\n  event MarketLaunchIncentiveParametersChanges(uint32 marketIndex, uint256 period, uint256 multiplier);\n  event StakeWithdrawalFeeUpdated(uint32 marketIndex, uint256 stakeWithdralFee);\n  event BalanceIncentiveExponentUpdated(uint32 marketIndex, uint256 balanceIncentiveExponent);\n  event BalanceIncentiveEquilibriumOffsetUpdated(uint32 marketIndex, int256 balanceIncentiveEquilibriumOffset);\n  event FloatPercentageUpdated(uint256 floatPercentage);\n  event SyntheticTokensShifted();\n  event ChangeAdmin(address newAdmin);\n  /╔═════════════════════════════╗\n    ║          MODIFIERS          ║\n    ╚═════════════════════════════╝/\n  function onlyAdminModifierLogic() internal virtual {\n    require(msg.sender == admin, "not admin");\n  }\n  modifier onlyAdmin() {\n    onlyAdminModifierLogic();\n    ;\n  }\n  function onlyValidSyntheticModifierLogic(address _synth) internal virtual {\n    require(marketIndexOfToken[_synth] != 0, "not valid synth");\n  }\n  modifier onlyValidSynthetic(address _synth) {\n    onlyValidSyntheticModifierLogic(_synth);\n    ;\n  }\n  function onlyValidMarketModifierLogic(uint32 marketIndex) internal virtual {\n    require(address(syntheticTokens[marketIndex][true]) != address(0), "not valid market");\n  }\n  modifier onlyValidMarket(uint32 marketIndex) {\n    onlyValidMarketModifierLogic(marketIndex);\n    ;\n  }\n  function onlyLongShortModifierLogic() internal virtual {\n    require(msg.sender == address(longShort), "not long short");\n  }\n  modifier onlyLongShort() {\n    onlyLongShortModifierLogic();\n    ;\n  }\n  /╔═════════════════════════════╗\n    ║       CONTRACT SET-UP       ║\n    ╚═════════════════════════════╝*/\n  /\n  @notice Initializes the contract.\n  @dev Calls OpenZeppelin\'s initializer modifier.\n  @param admin Address of the admin role.\n  @param _longShort Address of the LongShort contract, a deployed LongShort.sol\n  @param _floatToken Address of the Float token earned by staking.\n  @param _floatTreasury Address of the treasury contract for managing fees.\n  @param _floatCapital Address of the contract which earns a fixed percentage of Float.\n  @param _floatPercentage Determines the float percentage that gets minted for Float Capital, base 1e18.\n  /\n  function initialize(\n    address _admin,\n    address _longShort,\n    address _floatToken,\n    address _floatTreasury,\n    address _floatCapital,\n    uint256 _floatPercentage\n  ) external virtual initializer {\n    admin = _admin;\n    floatCapital = _floatCapital;\n    floatTreasury = _floatTreasury;\n    longShort = _longShort;\n    floatToken = _floatToken;\n    _changeFloatPercentage(_floatPercentage);\n    emit StakerV1(_admin, _floatTreasury, _floatCapital, _floatToken, _floatPercentage);\n  }\n  /╔═══════════════════╗\n    ║       ADMIN       ║\n    ╚═══════════════════╝/\n  / \n  @notice Changes admin for the contract\n  @param _admin The address of the new admin.\n  /\n  function changeAdmin(address _admin) external onlyAdmin {\n    admin = _admin;\n    emit ChangeAdmin(_admin);\n  }\n  /// @dev Logic for changeFloatPercentage\n  function _changeFloatPercentage(uint256 newFloatPercentage) internal virtual {\n    require(newFloatPercentage &lt;= 1e18 &amp;&amp; newFloatPercentage &gt; 0); // less than or equal to 100% and greater than 0%\n    floatPercentage = newFloatPercentage;\n  }\n  /\n  @notice Changes percentage of float that is minted for float capital.\n  @param newFloatPercentage The new float percentage in base 1e18.\n  */\n  function changeFloatPercentage(uint256 newFloatPercentage) external onlyAdmin {\n    _changeFloatPercentage(newFloatPercentage);\n    emit FloatPercentageUpdated(newFloatPercentage);\n  }\n  /// @dev Logic for changeUnstakeFee\n  function _changeUnstakeFee(uint32 marketIndex, uint256 newMarketUnstakeFee_e18) internal virtual {\n    require(newMarketUnstakeFee_e18 &lt;= 5e16); // Explicitely stating 5% fee as the max fee possible.\n    marketUnstakeFee_e18[marketIndex] = newMarketUnstakeFee_e18;\n  }\n  /\n  @notice Changes unstake fee for a market\n  @param marketIndex Identifies the market.\n  @param newMarketUnstakeFee_e18 The new unstake fee.\n  /\n  function changeUnstakeFee(uint32 marketIndex, uint256 newMarketUnstakeFee_e18) external onlyAdmin {\n    _changeUnstakeFee(marketIndex, newMarketUnstakeFee_e18);\n    emit StakeWithdrawalFeeUpdated(marketIndex, newMarketUnstakeFee_e18);\n  }\n  /// @dev Logic for changeMarketLaunchIncentiveParameters\n  function _changeMarketLaunchIncentiveParameters(\n    uint32 marketIndex,\n    uint256 period,\n    uint256 initialMultiplier\n  ) internal virtual {\n    require(initialMultiplier &gt;= 1e18, "marketLaunchIncentiveMultiplier must be &gt;= 1e18");\n    marketLaunchIncentive_period[marketIndex] = period;\n    marketLaunchIncentive_multipliers[marketIndex] = initialMultiplier;\n  }\n  /\n  @notice Changes the market launch incentive parameters for a market\n  @param marketIndex Identifies the market.\n  @param period The new period for which float token generation should be boosted.\n  @param initialMultiplier The new multiplier on Float generation.\n  /\n  function changeMarketLaunchIncentiveParameters(\n    uint32 marketIndex,\n    uint256 period,\n    uint256 initialMultiplier\n  ) external onlyAdmin {\n    _changeMarketLaunchIncentiveParameters(marketIndex, period, initialMultiplier);\n    emit MarketLaunchIncentiveParametersChanges(marketIndex, period, initialMultiplier);\n  }\n  /// @dev Logic for changeBalanceIncentiveExponent\n  function _changeBalanceIncentiveExponent(uint32 marketIndex, uint256 _balanceIncentiveCurve_exponent)\n    internal\n    virtual\n  {\n    require(\n      // The exponent has to be less than 5 in these versions of the contracts.\n      _balanceIncentiveCurve_exponent &gt; 0 &amp;&amp; _balanceIncentiveCurve_exponent &lt; 6,\n      "balanceIncentiveCurve_exponent out of bounds"\n    );\n    balanceIncentiveCurve_exponent[marketIndex] = _balanceIncentiveCurve_exponent;\n  }\n  / \n  @notice Changes the balance incentive exponent for a market\n  @param marketIndex Identifies the market.\n  @param _balanceIncentiveCurve_exponent The new exponent for the curve.\n  */\n  function changeBalanceIncentiveExponent(uint32 marketIndex, uint256 _balanceIncentiveCurve_exponent)\n    external\n    onlyAdmin\n  {\n    _changeBalanceIncentiveExponent(marketIndex, _balanceIncentiveCurve_exponent);\n    emit BalanceIncentiveExponentUpdated(marketIndex, _balanceIncentiveCurve_exponent);\n  }\n  /// @dev Logic for changeBalanceIncentiveEquilibriumOffset\n  function _changeBalanceIncentiveEquilibriumOffset(uint32 marketIndex, int256 _balanceIncentiveCurve_equilibriumOffset)\n    internal\n    virtual\n  {\n    // Unreasonable that we would ever shift this more than 90% either way\n    require(\n      _balanceIncentiveCurve_equilibriumOffset &gt; -9e17 &amp;&amp; _balanceIncentiveCurve_equilibriumOffset &lt; 9e17,\n      "balanceIncentiveCurve_equilibriumOffset out of bounds"\n    );\n    balanceIncentiveCurve_equilibriumOffset[marketIndex] = _balanceIncentiveCurve_equilibriumOffset;\n  }\n  /\n  @notice Changes the balance incentive curve equilibrium offset for a market\n  @param marketIndex Identifies the market.\n  @param _balanceIncentiveCurve_equilibriumOffset The new offset.\n  /\n  function changeBalanceIncentiveEquilibriumOffset(uint32 marketIndex, int256 _balanceIncentiveCurve_equilibriumOffset)\n    external\n    onlyAdmin\n  {\n    _changeBalanceIncentiveEquilibriumOffset(marketIndex, _balanceIncentiveCurve_equilibriumOffset);\n    emit BalanceIncentiveEquilibriumOffsetUpdated(marketIndex, _balanceIncentiveCurve_equilibriumOffset);\n  }\n  /╔═════════════════════════════╗\n    ║        STAKING SETUP        ║\n    ╚═════════════════════════════╝/\n  /\n  @notice Sets this contract to track staking for a market in LongShort.sol\n  @param marketIndex Identifies the market.\n  @param longToken Address of the long token for the market.\n  @param shortToken Address of the short token for the market.\n  @param kInitialMultiplier Initial boost on float generation for the market.\n  @param kPeriod Period which the boost should last.\n  @param unstakeFee_e18 Percentage of tokens that are levied on unstaking in base 1e18.\n  @param _balanceIncentiveCurve_exponent Exponent for balance curve (see _calculateFloatPerSecond)\n  @param _balanceIncentiveCurve_equilibriumOffset Offset for balance curve (see _calculateFloatPerSecond)\n  /\n  function addNewStakingFund(\n    uint32 marketIndex,\n    address longToken,\n    address shortToken,\n    uint256 kInitialMultiplier,\n    uint256 kPeriod,\n    uint256 unstakeFee_e18,\n    uint256 _balanceIncentiveCurve_exponent,\n    int256 _balanceIncentiveCurve_equilibriumOffset\n  ) external override onlyLongShort {\n    marketIndexOfToken[longToken] = marketIndex;\n    marketIndexOfToken[shortToken] = marketIndex;\n    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].timestamp = block.timestamp;\n    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].accumulativeFloatPerSyntheticToken_long = 0;\n    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].accumulativeFloatPerSyntheticToken_short = 0;\n    syntheticTokens[marketIndex][true] = longToken;\n    syntheticTokens[marketIndex][false] = shortToken;\n    _changeBalanceIncentiveExponent(marketIndex, _balanceIncentiveCurve_exponent);\n    _changeBalanceIncentiveEquilibriumOffset(marketIndex, _balanceIncentiveCurve_equilibriumOffset);\n    _changeMarketLaunchIncentiveParameters(marketIndex, kPeriod, kInitialMultiplier);\n    _changeUnstakeFee(marketIndex, unstakeFee_e18);\n    // Set this value to one initially - 0 is a null value and thus potentially bug prone.\n    batched_stakerNextTokenShiftIndex[marketIndex] = 1;\n    emit MarketAddedToStaker(\n      marketIndex,\n      unstakeFee_e18,\n      kPeriod,\n      kInitialMultiplier,\n      _balanceIncentiveCurve_exponent,\n      _balanceIncentiveCurve_equilibriumOffset\n    );\n    emit AccumulativeIssuancePerStakedSynthSnapshotCreated(marketIndex, 0, 0, 0);\n  }\n  /╔═════════════════════════════════════════════════════════════════════════╗\n    ║    GLOBAL FLT REWARD ACCUMULATION CALCULATION AND TRACKING FUNCTIONS    ║\n    ╚═════════════════════════════════════════════════════════════════════════╝/\n  /\n  @notice Returns the K factor parameters for the given market with sensible\n  defaults if they haven\'t been set yet.\n  @param marketIndex The market to change the parameters for.\n  @return period The period for which the k factor applies for in seconds.\n  @return multiplier The multiplier on Float generation in this period.\n  */\n  function _getMarketLaunchIncentiveParameters(uint32 marketIndex)\n    internal\n    view\n    virtual\n    returns (uint256 period, uint256 multiplier)\n  {\n    period = marketLaunchIncentive_period[marketIndex];\n    multiplier = marketLaunchIncentive_multipliers[marketIndex];\n    if (multiplier &lt; 1e18) {\n      multiplier = 1e18; // multiplier of 1 by default\n    }\n  }\n  / \n  @notice Returns the extent to which a markets float generation should be adjusted\n  based on the market\'s launch incentive parameters. Should start at multiplier\n  then linearly change to 1e18 over time.\n  @param marketIndex Identifies the market.\n  @return k The calculated modifier for float generation.\n  /\n  function _getKValue(uint32 marketIndex) internal view virtual returns (uint256) {\n    // Parameters controlling the float issuance multiplier.\n    (uint256 kPeriod, uint256 kInitialMultiplier) = _getMarketLaunchIncentiveParameters(marketIndex);\n    // Sanity check - under normal circumstances, the multipliers should\n    // never be set to a value &lt; 1e18, as there are guards against this.\n    assert(kInitialMultiplier &gt;= 1e18);\n    uint256 initialTimestamp = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].timestamp;\n    if (block.timestamp - initialTimestamp &lt;= kPeriod) {\n      return kInitialMultiplier - (((kInitialMultiplier - 1e18) * (block.timestamp - initialTimestamp)) / kPeriod);\n    } else {\n      return 1e18;\n    }\n  }\n  /\n  @notice Computes the number of float tokens a user earns per second for\n  every long/short synthetic token they\'ve staked. The returned value has\n  a fixed decimal scale of 1e42 (!!!) for numerical stability. The return\n  values are float per second per synthetic token (hence the requirement\n  to multiply by price)\n  @dev to see below math in latex form see TODO add link\n  to interact with the equations see https://www.desmos.com/calculator/optkaxyihr\n  @param marketIndex The market referred to.\n  @param longPrice Price of the synthetic long token in units of payment token\n  @param shortPrice Price of the synthetic short token in units of payment token\n  @param longValue Amount of payment token in the long side of the market\n  @param shortValue Amount of payment token in the short side of the market\n  @return longFloatPerSecond Float token per second per long synthetic token\n  @return shortFloatPerSecond Float token per second per short synthetic token\n   /\n  function _calculateFloatPerSecond(\n    uint32 marketIndex,\n    uint256 longPrice,\n    uint256 shortPrice,\n    uint256 longValue,\n    uint256 shortValue\n  ) internal view virtual returns (uint256 longFloatPerSecond, uint256 shortFloatPerSecond) {\n    // A float issuance multiplier that starts high and decreases linearly\n    // over time to a value of 1. This incentivises users to stake early.\n    uint256 k = _getKValue(marketIndex);\n    uint256 totalLocked = (longValue + shortValue);\n    // we need to scale this number by the totalLocked so that the offset remains consistent accross market size\n    int256 equilibriumOffsetMarketScaled = (balanceIncentiveCurve_equilibriumOffset[marketIndex] \n      int256(totalLocked)) / 2e18;\n    uint256 denominator = ((totalLocked &gt;&gt; safeExponentBitShifting)balanceIncentiveCurve_exponent[marketIndex]);\n    // Float is scaled by the percentage of the total market value held in\n    // the opposite position. This incentivises users to stake on the\n    // weaker position.\n    if (int256(shortValue) - equilibriumOffsetMarketScaled &lt; int256(longValue)) {\n      if (equilibriumOffsetMarketScaled &gt;= int256(shortValue)) {\n        // edge case: imbalanced far past the equilibrium offset - full rewards go to short token\n        //            extremeley unlikely to happen in practice\n        return (0, 1e18 * k * shortPrice);\n      }\n      uint256 numerator = (uint256(int256(shortValue) - equilibriumOffsetMarketScaled) &gt;&gt;\n        (safeExponentBitShifting - 1))balanceIncentiveCurve_exponent[marketIndex];\n      // NOTE: x * 5e17 == (x * 10e18) / 2\n      uint256 longRewardUnscaled = (numerator * 5e17) / denominator;\n      uint256 shortRewardUnscaled = 1e18 - longRewardUnscaled;\n      return ((longRewardUnscaled * k * longPrice) / 1e18, (shortRewardUnscaled * k * shortPrice) / 1e18);\n    } else {\n      if (-equilibriumOffsetMarketScaled &gt;= int256(longValue)) {\n        // edge case: imbalanced far past the equilibrium offset - full rewards go to long token\n        //            extremeley unlikely to happen in practice\n        return (1e18 * k * longPrice, 0);\n      }\n      uint256 numerator = (uint256(int256(longValue) + equilibriumOffsetMarketScaled) &gt;&gt;\n        (safeExponentBitShifting - 1))balanceIncentiveCurve_exponent[marketIndex];\n      // NOTE: x * 5e17 == (x * 10e18) / 2\n      uint256 shortRewardUnscaled = (numerator * 5e17) / denominator;\n      uint256 longRewardUnscaled = 1e18 - shortRewardUnscaled;\n      return ((longRewardUnscaled * k * longPrice) / 1e18, (shortRewardUnscaled * k * shortPrice) / 1e18);\n    }\n  }\n  /\n  @notice Computes the time since last accumulativeIssuancePerStakedSynthSnapshot for the given market in seconds.\n  @param marketIndex The market referred to.\n  @return The time difference in seconds\n  /\n  function _calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(uint32 marketIndex)\n    internal\n    view\n    virtual\n    returns (uint256)\n  {\n    return\n      block.timestamp -\n      accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]].timestamp;\n  }\n  /\n  @notice Computes new cumulative sum of \'r\' value since last accumulativeIssuancePerStakedSynthSnapshot. We use\n  cumulative \'r\' value to avoid looping during issuance. Note that the\n  cumulative sum is kept in 1e42 scale (!!!) to avoid numerical issues.\n  @param shortValue The value locked in the short side of the market.\n  @param longValue The value locked in the long side of the market.\n  @param shortPrice The price of the short token as defined in LongShort.sol\n  @param longPrice The price of the long token as defined in LongShort.sol\n  @param marketIndex An identifier for the market.\n  @return longCumulativeRates The long cumulative sum.\n  @return shortCumulativeRates The short cumulative sum.\n  /\n  function _calculateNewCumulativeIssuancePerStakedSynth(\n    uint32 marketIndex,\n    uint256 longPrice,\n    uint256 shortPrice,\n    uint256 longValue,\n    uint256 shortValue\n  ) internal view virtual returns (uint256 longCumulativeRates, uint256 shortCumulativeRates) {\n    // Compute the current \'r\' value for float issuance per second.\n    (uint256 longFloatPerSecond, uint256 shortFloatPerSecond) = _calculateFloatPerSecond(\n      marketIndex,\n      longPrice,\n      shortPrice,\n      longValue,\n      shortValue\n    );\n    // Compute time since last accumulativeIssuancePerStakedSynthSnapshot for the given token.\n    uint256 timeDelta = _calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(marketIndex);\n    // Compute new cumulative \'r\' value total.\n    return (\n      accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]]\n      .accumulativeFloatPerSyntheticToken_long + (timeDelta * longFloatPerSecond),\n      accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]]\n      .accumulativeFloatPerSyntheticToken_short + (timeDelta * shortFloatPerSecond)\n    );\n  }\n  /\n  @notice Creates a new accumulativeIssuancePerStakedSynthSnapshot for the given token and updates indexes.\n  @param shortValue The value locked in the short side of the market.\n  @param longValue The value locked in the long side of the market.\n  @param shortPrice The price of the short token as defined in LongShort.sol\n  @param longPrice The price of the long token as defined in LongShort.sol\n  @param marketIndex An identifier for the market.\n  */\n  function _setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot(\n    uint32 marketIndex,\n    uint256 longPrice,\n    uint256 shortPrice,\n    uint256 longValue,\n    uint256 shortValue\n  ) internal virtual {\n    (\n      uint256 newLongAccumulativeValue,\n      uint256 newShortAccumulativeValue\n    ) = _calculateNewCumulativeIssuancePerStakedSynth(marketIndex, longPrice, shortPrice, longValue, shortValue);\n    uint256 newIndex = latestRewardIndex[marketIndex] + 1;\n    // Set cumulative \'r\' value on new accumulativeIssuancePerStakedSynthSnapshot.\n    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex]\n    .accumulativeFloatPerSyntheticToken_long = newLongAccumulativeValue;\n    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex]\n    .accumulativeFloatPerSyntheticToken_short = newShortAccumulativeValue;\n    // Set timestamp on new accumulativeIssuancePerStakedSynthSnapshot.\n    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex].timestamp = block.timestamp;\n    // Update latest index to point to new accumulativeIssuancePerStakedSynthSnapshot.\n    latestRewardIndex[marketIndex] = newIndex;\n    emit AccumulativeIssuancePerStakedSynthSnapshotCreated(\n      marketIndex,\n      newIndex,\n      newLongAccumulativeValue,\n      newShortAccumulativeValue\n    );\n  }\n  /\n  @notice Adds new accumulativeIssuancePerStakedSynthSnapshots for the given long/short tokens. Called by the\n  ILongShort contract whenever there is a state change for a market.\n  @param stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted Mapping from this contract\'s shifts to LongShort.sols next price snapshots.\n  @param shortValue The value locked in the short side of the market.\n  @param longValue The value locked in the long side of the market.\n  @param shortPrice The price of the short token as defined in LongShort.sol\n  @param longPrice The price of the long token as defined in LongShort.sol\n  @param marketIndex An identifier for the market.\n  /\n  function pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(\n    uint32 marketIndex,\n    uint256 longPrice,\n    uint256 shortPrice,\n    uint256 longValue,\n    uint256 shortValue,\n    uint256 stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted // This value should be ALWAYS be zero if no shift occured\n  ) external override onlyLongShort {\n    // Only add a new accumulativeIssuancePerStakedSynthSnapshot if some time has passed.\n    // the stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted value will be 0 if there is no staker related action in an executed batch\n    if (stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted &gt; 0) {\n      stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[\n        batched_stakerNextTokenShiftIndex[marketIndex]\n      ] = stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted;\n      stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[\n        batched_stakerNextTokenShiftIndex[marketIndex]\n      ] = latestRewardIndex[marketIndex] + 1;\n      batched_stakerNextTokenShiftIndex[marketIndex] += 1;\n      emit SyntheticTokensShifted();\n    }\n    // Time delta is fetched twice in below code, can pass through? Which is less gas?\n    if (_calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(marketIndex) &gt; 0) {\n      _setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot(\n        marketIndex,\n        longPrice,\n        shortPrice,\n        longValue,\n        shortValue\n      );\n    }\n  }\n  /╔═══════════════════════════════════╗\n    ║    USER REWARD STATE FUNCTIONS    ║\n    ╚═══════════════════════════════════╝/\n  /// @dev Calculates the accumulated float in a specific range of staker snapshots\n  function _calculateAccumulatedFloatInRange(\n    uint32 marketIndex,\n    uint256 amountStakedLong,\n    uint256 amountStakedShort,\n    uint256 rewardIndexFrom,\n    uint256 rewardIndexTo\n  ) internal view virtual returns (uint256 floatReward) {\n    if (amountStakedLong &gt; 0) {\n      uint256 accumDeltaLong = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexTo]\n      .accumulativeFloatPerSyntheticToken_long -\n        accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexFrom]\n        .accumulativeFloatPerSyntheticToken_long;\n      floatReward += (accumDeltaLong * amountStakedLong) / FLOAT_ISSUANCE_FIXED_DECIMAL;\n    }\n    if (amountStakedShort &gt; 0) {\n      uint256 accumDeltaShort = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexTo]\n      .accumulativeFloatPerSyntheticToken_short -\n        accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexFrom]\n        .accumulativeFloatPerSyntheticToken_short;\n      floatReward += (accumDeltaShort * amountStakedShort) / FLOAT_ISSUANCE_FIXED_DECIMAL;\n    }\n  }\n  / \n  @notice Calculates float owed to the user since the user last minted float for a market.\n  @param marketIndex Identifier for the market which the user staked in.\n  @param user The address of the user.\n  @return floatReward The amount of float owed.\n   /\n  function _calculateAccumulatedFloat(uint32 marketIndex, address user) internal virtual returns (uint256 floatReward) {\n    address longToken = syntheticTokens[marketIndex][true];\n    address shortToken = syntheticTokens[marketIndex][false];\n    uint256 amountStakedLong = userAmountStaked[longToken][user];\n    uint256 amountStakedShort = userAmountStaked[shortToken][user];\n    uint256 usersLastRewardIndex = userIndexOfLastClaimedReward[marketIndex][user];\n    // Don\'t do the calculation and return zero immediately if there is no change\n    if (usersLastRewardIndex == latestRewardIndex[marketIndex]) {\n      return 0;\n    }\n    uint256 usersShiftIndex = userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][user];\n    // if there is a change in the users tokens held due to a token shift (or possibly another action in the future)\n    if (usersShiftIndex &gt; 0 &amp;&amp; usersShiftIndex &lt; batched_stakerNextTokenShiftIndex[marketIndex]) {\n      floatReward = _calculateAccumulatedFloatInRange(\n        marketIndex,\n        amountStakedLong,\n        amountStakedShort,\n        usersLastRewardIndex,\n        stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[usersShiftIndex]\n      );\n      // Update the users balances\n      if (userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user] &gt; 0) {\n        amountStakedShort += ILongShort(longShort).getAmountSyntheticTokenToMintOnTargetSide(\n          marketIndex,\n          userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user],\n          true,\n          stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[usersShiftIndex]\n        );\n        amountStakedLong -= userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user];\n        userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user] = 0;\n      }\n      if (userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user] &gt; 0) {\n        amountStakedLong += ILongShort(longShort).getAmountSyntheticTokenToMintOnTargetSide(\n          marketIndex,\n          userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user],\n          false,\n          stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[usersShiftIndex]\n        );\n        amountStakedShort -= userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user];\n        userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user] = 0;\n      }\n      // Save the users updated staked amounts\n      userAmountStaked[longToken][user] = amountStakedLong;\n      userAmountStaked[shortToken][user] = amountStakedShort;\n      floatReward += _calculateAccumulatedFloatInRange(\n        marketIndex,\n        amountStakedLong,\n        amountStakedShort,\n        stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[usersShiftIndex],\n        latestRewardIndex[marketIndex]\n      );\n      userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][user] = 0;\n    } else {\n      floatReward = _calculateAccumulatedFloatInRange(\n        marketIndex,\n        amountStakedLong,\n        amountStakedShort,\n        usersLastRewardIndex,\n        latestRewardIndex[marketIndex]\n      );\n    }\n  }\n  /\n  @notice Mints float for a user.\n  @dev Mints a fixed percentage for Float capital.\n  @param user The address of the user.\n  @param floatToMint The amount of float to mint.\n   */\n  function _mintFloat(address user, uint256 floatToMint) internal virtual {\n    IFloatToken(floatToken).mint(user, floatToMint);\n    IFloatToken(floatToken).mint(floatCapital, (floatToMint * floatPercentage) / 1e18);\n  }\n  /\n  @notice Mints float owed to a user for a market since they last minted.\n  @param marketIndex An identifier for the market.\n  @param user The address of the user.\n   /\n  function _mintAccumulatedFloat(uint32 marketIndex, address user) internal virtual {\n    uint256 floatToMint = _calculateAccumulatedFloat(marketIndex, user);\n    if (floatToMint &gt; 0) {\n      // Set the user has claimed up until now, stops them setting this forward\n      userIndexOfLastClaimedReward[marketIndex][user] = latestRewardIndex[marketIndex];\n      _mintFloat(user, floatToMint);\n      emit FloatMinted(user, marketIndex, floatToMint);\n    }\n  }\n  /\n  @notice Mints float owed to a user for multiple markets, since they last minted for those markets.\n  @param marketIndexes Identifiers for the markets.\n  @param user The address of the user.\n   /\n  function _mintAccumulatedFloatMulti(uint32[] calldata marketIndexes, address user) internal virtual {\n    uint256 floatTotal = 0;\n    for (uint256 i = 0; i &lt; marketIndexes.length; i++) {\n      uint256 floatToMint = _calculateAccumulatedFloat(marketIndexes[i], user);\n      if (floatToMint &gt; 0) {\n        // Set the user has claimed up until now, stops them setting this forward\n        userIndexOfLastClaimedReward[marketIndexes[i]][user] = latestRewardIndex[marketIndexes[i]];\n        floatTotal += floatToMint;\n        emit FloatMinted(user, marketIndexes[i], floatToMint);\n      }\n    }\n    if (floatTotal &gt; 0) {\n      _mintFloat(user, floatTotal);\n    }\n  }\n  /\n  @notice Mints outstanding float for msg.sender.\n  @param marketIndexes Identifiers for the markets for which to mint float.\n   */\n  function claimFloatCustom(uint32[] calldata marketIndexes) external {\n    ILongShort(longShort).updateSystemStateMulti(marketIndexes);\n    _mintAccumulatedFloatMulti(marketIndexes, msg.sender);\n  }\n  /\n  @notice Mints outstanding float on behalf of another user.\n  @param marketIndexes Identifiers for the markets for which to mint float.\n  @param user The address of the user.\n   /\n  function claimFloatCustomFor(uint32[] calldata marketIndexes, address user) external {\n    // Unbounded loop - users are responsible for paying their own gas costs on these and it doesn\'t effect the rest of the system.\n    // No need to impose limit.\n    ILongShort(longShort).updateSystemStateMulti(marketIndexes);\n    _mintAccumulatedFloatMulti(marketIndexes, user);\n  }\n  /╔═══════════════════════╗\n    ║        STAKING        ║\n    ╚═══════════════════════╝/\n  /\n  @notice A user with synthetic tokens stakes by calling stake on the token\n  contract which calls this function. We need to first update the\n  state of the LongShort contract for this market before staking to correctly calculate user rewards.\n  @param amount Amount to stake.\n  @param from Address to stake for.\n  /\n  function stakeFromUser(address from, uint256 amount) public virtual override onlyValidSynthetic((msg.sender)) {\n    ILongShort(longShort).updateSystemState(marketIndexOfToken[(msg.sender)]);\n    _stake((msg.sender), amount, from);\n  }\n  /\n  @dev Internal logic for staking.\n  @param token Address of the token for which to stake.\n  @param amount Amount to stake.\n  @param user Address to stake for.\n  */\n  function _stake(\n    address token,\n    uint256 amount,\n    address user\n  ) internal virtual {\n    uint32 marketIndex = marketIndexOfToken[token];\n    // If they already have staked and have rewards due, mint these.\n    if (\n      userIndexOfLastClaimedReward[marketIndex][user] != 0 &amp;&amp;\n      userIndexOfLastClaimedReward[marketIndex][user] &lt; latestRewardIndex[marketIndex]\n    ) {\n      _mintAccumulatedFloat(marketIndex, user);\n    }\n    userAmountStaked[token][user] = userAmountStaked[token][user] + amount;\n    userIndexOfLastClaimedReward[marketIndex][user] = latestRewardIndex[marketIndex];\n    emit StakeAdded(user, address(token), amount, userIndexOfLastClaimedReward[marketIndex][user]);\n  }\n  /\n  @notice Allows users to shift their staked tokens from one side of the market to \n  the other at the next price.\n  @param amountSyntheticTokensToShift Amount of tokens to shift.\n  @param marketIndex Identifier for the market.\n  @param isShiftFromLong Whether the shift is from long to short or short to long.\n  /\n  function shiftTokens(\n    uint256 amountSyntheticTokensToShift,\n    uint32 marketIndex,\n    bool isShiftFromLong\n  ) external virtual {\n    address token = syntheticTokens[marketIndex][isShiftFromLong];\n    require(userAmountStaked[token][msg.sender] &gt;= amountSyntheticTokensToShift, "Not enough tokens to shift");\n    // If the user has outstanding token shift that have already been confirmed in the LongShort\n    // contract, execute them first.\n    if (\n      userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] != 0 &amp;&amp;\n      userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] &lt;\n      batched_stakerNextTokenShiftIndex[marketIndex]\n    ) {\n      _mintAccumulatedFloat(marketIndex, msg.sender);\n    }\n    if (isShiftFromLong) {\n      ILongShort(longShort).shiftPositionFromLongNextPrice(marketIndex, amountSyntheticTokensToShift);\n      userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][\n        msg.sender\n      ] += amountSyntheticTokensToShift;\n    } else {\n      ILongShort(longShort).shiftPositionFromShortNextPrice(marketIndex, amountSyntheticTokensToShift);\n      userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][\n        msg.sender\n      ] += amountSyntheticTokensToShift;\n    }\n    userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] = batched_stakerNextTokenShiftIndex[\n      marketIndex\n    ];\n  }\n  /╔════════════════════════════╗\n    ║    WITHDRAWAL &amp; MINTING    ║\n    ╚════════════════════════════╝/\n  /\n  @notice Internal logic for withdrawing stakes.\n  @dev Mint user any outstanding float before withdrawing.\n  @param marketIndex Market index of token.\n  @param amount Amount to withdraw.\n  @param token Synthetic token that was staked.\n  /\n  function _withdraw(\n    uint32 marketIndex,\n    address token,\n    uint256 amount\n  ) internal virtual {\n    require(userAmountStaked[token][msg.sender] &gt; 0, "nothing to withdraw");\n    _mintAccumulatedFloat(marketIndex, msg.sender);\n    userAmountStaked[token][msg.sender] = userAmountStaked[token][msg.sender] - amount;\n    uint256 amountFees = (amount * marketUnstakeFee_e18[marketIndex]) / 1e18;\n    IERC20(token).transfer(floatTreasury, amountFees);\n    IERC20(token).transfer(msg.sender, amount - amountFees);\n    emit StakeWithdrawn(msg.sender, token, amount);\n  }\n  /\n  @notice Withdraw function. Allows users to unstake.\n  @param amount Amount to withdraw.\n  @param token Address of the token for which to withdraw.\n  */\n  function withdraw(address token, uint256 amount) external {\n    ILongShort(longShort).updateSystemState(marketIndexOfToken[token]);\n    uint32 marketIndex = marketIndexOfToken[token];\n    _withdraw(marketIndex, token, amount);\n    if (userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] &gt; 0) {\n      // If they still have outstanding shifts after minting float, then check\n      // that they don\'t withdraw more than their shifts allow.\n      uint256 amountToShiftForThisToken = syntheticTokens[marketIndex][true] == token\n        ? userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][msg.sender]\n        : userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][msg.sender];\n      require(\n        userAmountStaked[token][msg.sender] &gt;= amountToShiftForThisToken,\n        "Outstanding next price stake shifts too great"\n      );\n    }\n  }\n  /\n  @notice Allows users to withdraw their entire stake for a token.\n  @param token Address of the token for which to withdraw.\n  /\n  function withdrawAll(address token) external {\n    ILongShort(longShort).updateSystemState(marketIndexOfToken[token]);\n    uint32 marketIndex = marketIndexOfToken[token];\n    uint256 amountToShiftForThisToken = syntheticTokens[marketIndex][true] == token\n      ? userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][msg.sender]\n      : userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][msg.sender];\n    _withdraw(marketIndex, token, userAmountStaked[token][msg.sender] - amountToShiftForThisToken);\n  }\n}\n.\n\nChief Executive Officer: We excel in generating innovative approaches and enhancements for Solidity smart contract code.\nHere\'s a Solidity contract provided by the user: "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.3;\nimport "@openzeppelin/contracts-upgradeable/token/ERC20/presets/ERC20PresetMinterPauserUpgradeable.sol";\nimport "./interfaces/IFloatToken.sol";\nimport "./interfaces/ILongShort.sol";\nimport "./interfaces/IStaker.sol";\nimport "./interfaces/ISyntheticToken.sol";\ncontract Staker is IStaker, Initializable {\n  /╔═════════════════════════════╗\n    ║          VARIABLES          ║\n    ╚═════════════════════════════╝/\n  / ══════ Fixed-precision constants ══════ /\n  uint256 public constant FLOAT_ISSUANCE_FIXED_DECIMAL = 1e42;\n  // 2^52 ~= 4.5e15\n  // With an exponent of 5, the largest total liquidity possible in a market (to avoid integer overflow on exponentiation) is ~10^31 or 10 Trillion (10^13)\n  // NOTE: this also means if the total market value is less than 2^52 there will be a division by zero error\n  uint256 public constant safeExponentBitShifting = 52;\n  / ══════ Global state ══════ /\n  address public admin;\n  address public floatCapital;\n  address public floatTreasury;\n  uint256 public floatPercentage;\n  address public longShort;\n  address public floatToken;\n  / ══════ Market specific ══════ /\n  mapping(uint32 =&gt; uint256) public marketLaunchIncentive_period; // seconds\n  mapping(uint32 =&gt; uint256) public marketLaunchIncentive_multipliers; // e18 scale\n  mapping(uint32 =&gt; uint256) public marketUnstakeFee_e18;\n  mapping(uint32 =&gt; uint256) public balanceIncentiveCurve_exponent;\n  mapping(uint32 =&gt; int256) public balanceIncentiveCurve_equilibriumOffset;\n  mapping(uint32 =&gt; mapping(bool =&gt; address)) public syntheticTokens;\n  mapping(address =&gt; uint32) public marketIndexOfToken;\n  / ══════ Reward specific ══════ /\n  mapping(uint32 =&gt; uint256) public latestRewardIndex;\n  mapping(uint32 =&gt; mapping(uint256 =&gt; AccumulativeIssuancePerStakedSynthSnapshot))\n    public accumulativeFloatPerSyntheticTokenSnapshots;\n  struct AccumulativeIssuancePerStakedSynthSnapshot {\n    uint256 timestamp;\n    uint256 accumulativeFloatPerSyntheticToken_long;\n    uint256 accumulativeFloatPerSyntheticToken_short;\n  }\n  / ══════ User specific ══════ /\n  mapping(uint32 =&gt; mapping(address =&gt; uint256)) public userIndexOfLastClaimedReward;\n  mapping(address =&gt; mapping(address =&gt; uint256)) public userAmountStaked;\n  / ══════ Token shift management specific ══════ /\n  mapping(uint32 =&gt; uint256) public batched_stakerNextTokenShiftIndex;\n  /\n  @notice Used to link a token shift to a staker state\n  @dev tokenShiftIndex =&gt; accumulativeFloatIssuanceSnapshotIndex\n    POSSIBLE OPTIMIZATION - could pack stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping and stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping into a struct of two uint128 for storage space optimization.\n  /\n  mapping(uint256 =&gt; uint256) public stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping;\n  /// @notice Used to fetch the price from LongShort at that point in time\n  /// @dev tokenShiftIndex =&gt; longShortMarketPriceSnapshotIndex\n  mapping(uint256 =&gt; uint256) public stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping;\n  /// @dev marketIndex =&gt; usersAddress =&gt; stakerTokenShiftIndex\n  mapping(uint32 =&gt; mapping(address =&gt; uint256)) public userNextPrice_stakedSyntheticTokenShiftIndex;\n  /// @dev marketIndex =&gt; usersAddress =&gt; amountUserRequestedToShiftAwayFromLongOnNextUpdate\n  mapping(uint32 =&gt; mapping(address =&gt; uint256)) public userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long;\n  /// @dev marketIndex =&gt; usersAddress =&gt; amountUserRequestedToShiftAwayFromShortOnNextUpdate\n  mapping(uint32 =&gt; mapping(address =&gt; uint256)) public userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short;\n  /╔════════════════════════════╗\n    ║           EVENTS           ║\n    ╚════════════════════════════╝/\n  event StakerV1(\n    address admin,\n    address floatTreasury,\n    address floatCapital,\n    address floatToken,\n    uint256 floatPercentage\n  );\n  event MarketAddedToStaker(\n    uint32 marketIndex,\n    uint256 exitFee_e18,\n    uint256 period,\n    uint256 multiplier,\n    uint256 balanceIncentiveExponent,\n    int256 balanceIncentiveEquilibriumOffset\n  );\n  event AccumulativeIssuancePerStakedSynthSnapshotCreated(\n    uint32 marketIndex,\n    uint256 accumulativeFloatIssuanceSnapshotIndex,\n    uint256 accumulativeLong,\n    uint256 accumulativeShort\n  );\n  event StakeAdded(address user, address token, uint256 amount, uint256 lastMintIndex);\n  event StakeWithdrawn(address user, address token, uint256 amount);\n  // Note: the amountFloatMinted isn\'t strictly needed by the graph, but it is good to add it to validate calculations are accurate.\n  event FloatMinted(address user, uint32 marketIndex, uint256 amountFloatMinted);\n  event MarketLaunchIncentiveParametersChanges(uint32 marketIndex, uint256 period, uint256 multiplier);\n  event StakeWithdrawalFeeUpdated(uint32 marketIndex, uint256 stakeWithdralFee);\n  event BalanceIncentiveExponentUpdated(uint32 marketIndex, uint256 balanceIncentiveExponent);\n  event BalanceIncentiveEquilibriumOffsetUpdated(uint32 marketIndex, int256 balanceIncentiveEquilibriumOffset);\n  event FloatPercentageUpdated(uint256 floatPercentage);\n  event SyntheticTokensShifted();\n  event ChangeAdmin(address newAdmin);\n  /╔═════════════════════════════╗\n    ║          MODIFIERS          ║\n    ╚═════════════════════════════╝/\n  function onlyAdminModifierLogic() internal virtual {\n    require(msg.sender == admin, "not admin");\n  }\n  modifier onlyAdmin() {\n    onlyAdminModifierLogic();\n    ;\n  }\n  function onlyValidSyntheticModifierLogic(address synth) internal virtual {\n    require(marketIndexOfToken[_synth] != 0, "not valid synth");\n  }\n  modifier onlyValidSynthetic(address _synth) {\n    onlyValidSyntheticModifierLogic(_synth);\n    ;\n  }\n  function onlyValidMarketModifierLogic(uint32 marketIndex) internal virtual {\n    require(address(syntheticTokens[marketIndex][true]) != address(0), "not valid market");\n  }\n  modifier onlyValidMarket(uint32 marketIndex) {\n    onlyValidMarketModifierLogic(marketIndex);\n    ;\n  }\n  function onlyLongShortModifierLogic() internal virtual {\n    require(msg.sender == address(longShort), "not long short");\n  }\n  modifier onlyLongShort() {\n    onlyLongShortModifierLogic();\n    ;\n  }\n  /╔═════════════════════════════╗\n    ║       CONTRACT SET-UP       ║\n    ╚═════════════════════════════╝/\n  /\n  @notice Initializes the contract.\n  @dev Calls OpenZeppelin\'s initializer modifier.\n  @param _admin Address of the admin role.\n  @param _longShort Address of the LongShort contract, a deployed LongShort.sol\n  @param _floatToken Address of the Float token earned by staking.\n  @param _floatTreasury Address of the treasury contract for managing fees.\n  @param _floatCapital Address of the contract which earns a fixed percentage of Float.\n  @param _floatPercentage Determines the float percentage that gets minted for Float Capital, base 1e18.\n  /\n  function initialize(\n    address _admin,\n    address _longShort,\n    address _floatToken,\n    address _floatTreasury,\n    address _floatCapital,\n    uint256 _floatPercentage\n  ) external virtual initializer {\n    admin = _admin;\n    floatCapital = _floatCapital;\n    floatTreasury = _floatTreasury;\n    longShort = _longShort;\n    floatToken = _floatToken;\n    _changeFloatPercentage(_floatPercentage);\n    emit StakerV1(_admin, _floatTreasury, _floatCapital, _floatToken, _floatPercentage);\n  }\n  /╔═══════════════════╗\n    ║       ADMIN       ║\n    ╚═══════════════════╝*/\n  / \n  @notice Changes admin for the contract\n  @param _admin The address of the new admin.\n  /\n  function changeAdmin(address _admin) external onlyAdmin {\n    admin = _admin;\n    emit ChangeAdmin(_admin);\n  }\n  /// @dev Logic for changeFloatPercentage\n  function _changeFloatPercentage(uint256 newFloatPercentage) internal virtual {\n    require(newFloatPercentage &lt;= 1e18 &amp;&amp; newFloatPercentage &gt; 0); // less than or equal to 100% and greater than 0%\n    floatPercentage = newFloatPercentage;\n  }\n  /\n  @notice Changes percentage of float that is minted for float capital.\n  @param newFloatPercentage The new float percentage in base 1e18.\n  /\n  function changeFloatPercentage(uint256 newFloatPercentage) external onlyAdmin {\n    _changeFloatPercentage(newFloatPercentage);\n    emit FloatPercentageUpdated(newFloatPercentage);\n  }\n  /// @dev Logic for changeUnstakeFee\n  function _changeUnstakeFee(uint32 marketIndex, uint256 newMarketUnstakeFee_e18) internal virtual {\n    require(newMarketUnstakeFee_e18 &lt;= 5e16); // Explicitely stating 5% fee as the max fee possible.\n    marketUnstakeFee_e18[marketIndex] = newMarketUnstakeFee_e18;\n  }\n  /\n  @notice Changes unstake fee for a market\n  @param marketIndex Identifies the market.\n  @param newMarketUnstakeFee_e18 The new unstake fee.\n  */\n  function changeUnstakeFee(uint32 marketIndex, uint256 newMarketUnstakeFee_e18) external onlyAdmin {\n    _changeUnstakeFee(marketIndex, newMarketUnstakeFee_e18);\n    emit StakeWithdrawalFeeUpdated(marketIndex, newMarketUnstakeFee_e18);\n  }\n  /// @dev Logic for changeMarketLaunchIncentiveParameters\n  function _changeMarketLaunchIncentiveParameters(\n    uint32 marketIndex,\n    uint256 period,\n    uint256 initialMultiplier\n  ) internal virtual {\n    require(initialMultiplier &gt;= 1e18, "marketLaunchIncentiveMultiplier must be &gt;= 1e18");\n    marketLaunchIncentive_period[marketIndex] = period;\n    marketLaunchIncentive_multipliers[marketIndex] = initialMultiplier;\n  }\n  /\n  @notice Changes the market launch incentive parameters for a market\n  @param marketIndex Identifies the market.\n  @param period The new period for which float token generation should be boosted.\n  @param initialMultiplier The new multiplier on Float generation.\n  /\n  function changeMarketLaunchIncentiveParameters(\n    uint32 marketIndex,\n    uint256 period,\n    uint256 initialMultiplier\n  ) external onlyAdmin {\n    _changeMarketLaunchIncentiveParameters(marketIndex, period, initialMultiplier);\n    emit MarketLaunchIncentiveParametersChanges(marketIndex, period, initialMultiplier);\n  }\n  /// @dev Logic for changeBalanceIncentiveExponent\n  function _changeBalanceIncentiveExponent(uint32 marketIndex, uint256 _balanceIncentiveCurve_exponent)\n    internal\n    virtual\n  {\n    require(\n      // The exponent has to be less than 5 in these versions of the contracts.\n      _balanceIncentiveCurve_exponent &gt; 0 &amp;&amp; _balanceIncentiveCurve_exponent &lt; 6,\n      "balanceIncentiveCurve_exponent out of bounds"\n    );\n    balanceIncentiveCurve_exponent[marketIndex] = _balanceIncentiveCurve_exponent;\n  }\n  / \n  @notice Changes the balance incentive exponent for a market\n  @param marketIndex Identifies the market.\n  @param _balanceIncentiveCurve_exponent The new exponent for the curve.\n  /\n  function changeBalanceIncentiveExponent(uint32 marketIndex, uint256 _balanceIncentiveCurve_exponent)\n    external\n    onlyAdmin\n  {\n    _changeBalanceIncentiveExponent(marketIndex, _balanceIncentiveCurve_exponent);\n    emit BalanceIncentiveExponentUpdated(marketIndex, _balanceIncentiveCurve_exponent);\n  }\n  /// @dev Logic for changeBalanceIncentiveEquilibriumOffset\n  function _changeBalanceIncentiveEquilibriumOffset(uint32 marketIndex, int256 _balanceIncentiveCurve_equilibriumOffset)\n    internal\n    virtual\n  {\n    // Unreasonable that we would ever shift this more than 90% either way\n    require(\n      _balanceIncentiveCurve_equilibriumOffset &gt; -9e17 &amp;&amp; _balanceIncentiveCurve_equilibriumOffset &lt; 9e17,\n      "balanceIncentiveCurve_equilibriumOffset out of bounds"\n    );\n    balanceIncentiveCurve_equilibriumOffset[marketIndex] = _balanceIncentiveCurve_equilibriumOffset;\n  }\n  /\n  @notice Changes the balance incentive curve equilibrium offset for a market\n  @param marketIndex Identifies the market.\n  @param _balanceIncentiveCurve_equilibriumOffset The new offset.\n  /\n  function changeBalanceIncentiveEquilibriumOffset(uint32 marketIndex, int256 _balanceIncentiveCurve_equilibriumOffset)\n    external\n    onlyAdmin\n  {\n    _changeBalanceIncentiveEquilibriumOffset(marketIndex, _balanceIncentiveCurve_equilibriumOffset);\n    emit BalanceIncentiveEquilibriumOffsetUpdated(marketIndex, _balanceIncentiveCurve_equilibriumOffset);\n  }\n  /╔═════════════════════════════╗\n    ║        STAKING SETUP        ║\n    ╚═════════════════════════════╝*/\n  /\n  @notice Sets this contract to track staking for a market in LongShort.sol\n  @param marketIndex Identifies the market.\n  @param longToken Address of the long token for the market.\n  @param shortToken Address of the short token for the market.\n  @param kInitialMultiplier Initial boost on float generation for the market.\n  @param kPeriod Period which the boost should last.\n  @param unstakeFee_e18 Percentage of tokens that are levied on unstaking in base 1e18.\n  @param _balanceIncentiveCurve_exponent Exponent for balance curve (see _calculateFloatPerSecond)\n  @param _balanceIncentiveCurve_equilibriumOffset Offset for balance curve (see _calculateFloatPerSecond)\n  /\n  function addNewStakingFund(\n    uint32 marketIndex,\n    address longToken,\n    address shortToken,\n    uint256 kInitialMultiplier,\n    uint256 kPeriod,\n    uint256 unstakeFee_e18,\n    uint256 _balanceIncentiveCurve_exponent,\n    int256 _balanceIncentiveCurve_equilibriumOffset\n  ) external override onlyLongShort {\n    marketIndexOfToken[longToken] = marketIndex;\n    marketIndexOfToken[shortToken] = marketIndex;\n    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].timestamp = block.timestamp;\n    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].accumulativeFloatPerSyntheticToken_long = 0;\n    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].accumulativeFloatPerSyntheticToken_short = 0;\n    syntheticTokens[marketIndex][true] = longToken;\n    syntheticTokens[marketIndex][false] = shortToken;\n    _changeBalanceIncentiveExponent(marketIndex, _balanceIncentiveCurve_exponent);\n    _changeBalanceIncentiveEquilibriumOffset(marketIndex, _balanceIncentiveCurve_equilibriumOffset);\n    _changeMarketLaunchIncentiveParameters(marketIndex, kPeriod, kInitialMultiplier);\n    _changeUnstakeFee(marketIndex, unstakeFee_e18);\n    // Set this value to one initially - 0 is a null value and thus potentially bug prone.\n    batched_stakerNextTokenShiftIndex[marketIndex] = 1;\n    emit MarketAddedToStaker(\n      marketIndex,\n      unstakeFee_e18,\n      kPeriod,\n      kInitialMultiplier,\n      _balanceIncentiveCurve_exponent,\n      _balanceIncentiveCurve_equilibriumOffset\n    );\n    emit AccumulativeIssuancePerStakedSynthSnapshotCreated(marketIndex, 0, 0, 0);\n  }\n  /╔═════════════════════════════════════════════════════════════════════════╗\n    ║    GLOBAL FLT REWARD ACCUMULATION CALCULATION AND TRACKING FUNCTIONS    ║\n    ╚═════════════════════════════════════════════════════════════════════════╝/\n  /\n  @notice Returns the K factor parameters for the given market with sensible\n  defaults if they haven\'t been set yet.\n  @param marketIndex The market to change the parameters for.\n  @return period The period for which the k factor applies for in seconds.\n  @return multiplier The multiplier on Float generation in this period.\n  /\n  function _getMarketLaunchIncentiveParameters(uint32 marketIndex)\n    internal\n    view\n    virtual\n    returns (uint256 period, uint256 multiplier)\n  {\n    period = marketLaunchIncentive_period[marketIndex];\n    multiplier = marketLaunchIncentive_multipliers[marketIndex];\n    if (multiplier &lt; 1e18) {\n      multiplier = 1e18; // multiplier of 1 by default\n    }\n  }\n  / \n  @notice Returns the extent to which a markets float generation should be adjusted\n  based on the market\'s launch incentive parameters. Should start at multiplier\n  then linearly change to 1e18 over time.\n  @param marketIndex Identifies the market.\n  @return k The calculated modifier for float generation.\n  /\n  function _getKValue(uint32 marketIndex) internal view virtual returns (uint256) {\n    // Parameters controlling the float issuance multiplier.\n    (uint256 kPeriod, uint256 kInitialMultiplier) = _getMarketLaunchIncentiveParameters(marketIndex);\n    // Sanity check - under normal circumstances, the multipliers should\n    // never be set to a value &lt; 1e18, as there are guards against this.\n    assert(kInitialMultiplier &gt;= 1e18);\n    uint256 initialTimestamp = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].timestamp;\n    if (block.timestamp - initialTimestamp &lt;= kPeriod) {\n      return kInitialMultiplier - (((kInitialMultiplier - 1e18) * (block.timestamp - initialTimestamp)) / kPeriod);\n    } else {\n      return 1e18;\n    }\n  }\n  /\n  @notice Computes the number of float tokens a user earns per second for\n  every long/short synthetic token they\'ve staked. The returned value has\n  a fixed decimal scale of 1e42 (!!!) for numerical stability. The return\n  values are float per second per synthetic token (hence the requirement\n  to multiply by price)\n  @dev to see below math in latex form see TODO add link\n  to interact with the equations see https://www.desmos.com/calculator/optkaxyihr\n  @param marketIndex The market referred to.\n  @param longPrice Price of the synthetic long token in units of payment token\n  @param shortPrice Price of the synthetic short token in units of payment token\n  @param longValue Amount of payment token in the long side of the market\n  @param shortValue Amount of payment token in the short side of the market\n  @return longFloatPerSecond Float token per second per long synthetic token\n  @return shortFloatPerSecond Float token per second per short synthetic token\n   /\n  function _calculateFloatPerSecond(\n    uint32 marketIndex,\n    uint256 longPrice,\n    uint256 shortPrice,\n    uint256 longValue,\n    uint256 shortValue\n  ) internal view virtual returns (uint256 longFloatPerSecond, uint256 shortFloatPerSecond) {\n    // A float issuance multiplier that starts high and decreases linearly\n    // over time to a value of 1. This incentivises users to stake early.\n    uint256 k = _getKValue(marketIndex);\n    uint256 totalLocked = (longValue + shortValue);\n    // we need to scale this number by the totalLocked so that the offset remains consistent accross market size\n    int256 equilibriumOffsetMarketScaled = (balanceIncentiveCurve_equilibriumOffset[marketIndex] \n      int256(totalLocked)) / 2e18;\n    uint256 denominator = ((totalLocked &gt;&gt; safeExponentBitShifting)balanceIncentiveCurve_exponent[marketIndex]);\n    // Float is scaled by the percentage of the total market value held in\n    // the opposite position. This incentivises users to stake on the\n    // weaker position.\n    if (int256(shortValue) - equilibriumOffsetMarketScaled &lt; int256(longValue)) {\n      if (equilibriumOffsetMarketScaled &gt;= int256(shortValue)) {\n        // edge case: imbalanced far past the equilibrium offset - full rewards go to short token\n        //            extremeley unlikely to happen in practice\n        return (0, 1e18 * k * shortPrice);\n      }\n      uint256 numerator = (uint256(int256(shortValue) - equilibriumOffsetMarketScaled) &gt;&gt;\n        (safeExponentBitShifting - 1))balanceIncentiveCurve_exponent[marketIndex];\n      // NOTE: x * 5e17 == (x * 10e18) / 2\n      uint256 longRewardUnscaled = (numerator * 5e17) / denominator;\n      uint256 shortRewardUnscaled = 1e18 - longRewardUnscaled;\n      return ((longRewardUnscaled * k * longPrice) / 1e18, (shortRewardUnscaled * k * shortPrice) / 1e18);\n    } else {\n      if (-equilibriumOffsetMarketScaled &gt;= int256(longValue)) {\n        // edge case: imbalanced far past the equilibrium offset - full rewards go to long token\n        //            extremeley unlikely to happen in practice\n        return (1e18 * k * longPrice, 0);\n      }\n      uint256 numerator = (uint256(int256(longValue) + equilibriumOffsetMarketScaled) &gt;&gt;\n        (safeExponentBitShifting - 1))balanceIncentiveCurve_exponent[marketIndex];\n      // NOTE: x * 5e17 == (x * 10e18) / 2\n      uint256 shortRewardUnscaled = (numerator * 5e17) / denominator;\n      uint256 longRewardUnscaled = 1e18 - shortRewardUnscaled;\n      return ((longRewardUnscaled * k * longPrice) / 1e18, (shortRewardUnscaled * k * shortPrice) / 1e18);\n    }\n  }\n  /\n  @notice Computes the time since last accumulativeIssuancePerStakedSynthSnapshot for the given market in seconds.\n  @param marketIndex The market referred to.\n  @return The time difference in seconds\n  */\n  function _calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(uint32 marketIndex)\n    internal\n    view\n    virtual\n    returns (uint256)\n  {\n    return\n      block.timestamp -\n      accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]].timestamp;\n  }\n  /\n  @notice Computes new cumulative sum of \'r\' value since last accumulativeIssuancePerStakedSynthSnapshot. We use\n  cumulative \'r\' value to avoid looping during issuance. Note that the\n  cumulative sum is kept in 1e42 scale (!!!) to avoid numerical issues.\n  @param shortValue The value locked in the short side of the market.\n  @param longValue The value locked in the long side of the market.\n  @param shortPrice The price of the short token as defined in LongShort.sol\n  @param longPrice The price of the long token as defined in LongShort.sol\n  @param marketIndex An identifier for the market.\n  @return longCumulativeRates The long cumulative sum.\n  @return shortCumulativeRates The short cumulative sum.\n  /\n  function _calculateNewCumulativeIssuancePerStakedSynth(\n    uint32 marketIndex,\n    uint256 longPrice,\n    uint256 shortPrice,\n    uint256 longValue,\n    uint256 shortValue\n  ) internal view virtual returns (uint256 longCumulativeRates, uint256 shortCumulativeRates) {\n    // Compute the current \'r\' value for float issuance per second.\n    (uint256 longFloatPerSecond, uint256 shortFloatPerSecond) = _calculateFloatPerSecond(\n      marketIndex,\n      longPrice,\n      shortPrice,\n      longValue,\n      shortValue\n    );\n    // Compute time since last accumulativeIssuancePerStakedSynthSnapshot for the given token.\n    uint256 timeDelta = _calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(marketIndex);\n    // Compute new cumulative \'r\' value total.\n    return (\n      accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]]\n      .accumulativeFloatPerSyntheticToken_long + (timeDelta * longFloatPerSecond),\n      accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]]\n      .accumulativeFloatPerSyntheticToken_short + (timeDelta * shortFloatPerSecond)\n    );\n  }\n  /\n  @notice Creates a new accumulativeIssuancePerStakedSynthSnapshot for the given token and updates indexes.\n  @param shortValue The value locked in the short side of the market.\n  @param longValue The value locked in the long side of the market.\n  @param shortPrice The price of the short token as defined in LongShort.sol\n  @param longPrice The price of the long token as defined in LongShort.sol\n  @param marketIndex An identifier for the market.\n  /\n  function _setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot(\n    uint32 marketIndex,\n    uint256 longPrice,\n    uint256 shortPrice,\n    uint256 longValue,\n    uint256 shortValue\n  ) internal virtual {\n    (\n      uint256 newLongAccumulativeValue,\n      uint256 newShortAccumulativeValue\n    ) = _calculateNewCumulativeIssuancePerStakedSynth(marketIndex, longPrice, shortPrice, longValue, shortValue);\n    uint256 newIndex = latestRewardIndex[marketIndex] + 1;\n    // Set cumulative \'r\' value on new accumulativeIssuancePerStakedSynthSnapshot.\n    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex]\n    .accumulativeFloatPerSyntheticToken_long = newLongAccumulativeValue;\n    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex]\n    .accumulativeFloatPerSyntheticToken_short = newShortAccumulativeValue;\n    // Set timestamp on new accumulativeIssuancePerStakedSynthSnapshot.\n    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex].timestamp = block.timestamp;\n    // Update latest index to point to new accumulativeIssuancePerStakedSynthSnapshot.\n    latestRewardIndex[marketIndex] = newIndex;\n    emit AccumulativeIssuancePerStakedSynthSnapshotCreated(\n      marketIndex,\n      newIndex,\n      newLongAccumulativeValue,\n      newShortAccumulativeValue\n    );\n  }\n  /\n  @notice Adds new accumulativeIssuancePerStakedSynthSnapshots for the given long/short tokens. Called by the\n  ILongShort contract whenever there is a state change for a market.\n  @param stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted Mapping from this contract\'s shifts to LongShort.sols next price snapshots.\n  @param shortValue The value locked in the short side of the market.\n  @param longValue The value locked in the long side of the market.\n  @param shortPrice The price of the short token as defined in LongShort.sol\n  @param longPrice The price of the long token as defined in LongShort.sol\n  @param marketIndex An identifier for the market.\n  /\n  function pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(\n    uint32 marketIndex,\n    uint256 longPrice,\n    uint256 shortPrice,\n    uint256 longValue,\n    uint256 shortValue,\n    uint256 stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted // This value should be ALWAYS be zero if no shift occured\n  ) external override onlyLongShort {\n    // Only add a new accumulativeIssuancePerStakedSynthSnapshot if some time has passed.\n    // the stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted value will be 0 if there is no staker related action in an executed batch\n    if (stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted &gt; 0) {\n      stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[\n        batched_stakerNextTokenShiftIndex[marketIndex]\n      ] = stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted;\n      stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[\n        batched_stakerNextTokenShiftIndex[marketIndex]\n      ] = latestRewardIndex[marketIndex] + 1;\n      batched_stakerNextTokenShiftIndex[marketIndex] += 1;\n      emit SyntheticTokensShifted();\n    }\n    // Time delta is fetched twice in below code, can pass through? Which is less gas?\n    if (_calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(marketIndex) &gt; 0) {\n      _setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot(\n        marketIndex,\n        longPrice,\n        shortPrice,\n        longValue,\n        shortValue\n      );\n    }\n  }\n  /╔═══════════════════════════════════╗\n    ║    USER REWARD STATE FUNCTIONS    ║\n    ╚═══════════════════════════════════╝*/\n  /// @dev Calculates the accumulated float in a specific range of staker snapshots\n  function _calculateAccumulatedFloatInRange(\n    uint32 marketIndex,\n    uint256 amountStakedLong,\n    uint256 amountStakedShort,\n    uint256 rewardIndexFrom,\n    uint256 rewardIndexTo\n  ) internal view virtual returns (uint256 floatReward) {\n    if (amountStakedLong &gt; 0) {\n      uint256 accumDeltaLong = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexTo]\n      .accumulativeFloatPerSyntheticToken_long -\n        accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexFrom]\n        .accumulativeFloatPerSyntheticToken_long;\n      floatReward += (accumDeltaLong * amountStakedLong) / FLOAT_ISSUANCE_FIXED_DECIMAL;\n    }\n    if (amountStakedShort &gt; 0) {\n      uint256 accumDeltaShort = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexTo]\n      .accumulativeFloatPerSyntheticToken_short -\n        accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexFrom]\n        .accumulativeFloatPerSyntheticToken_short;\n      floatReward += (accumDeltaShort * amountStakedShort) / FLOAT_ISSUANCE_FIXED_DECIMAL;\n    }\n  }\n  / \n  @notice Calculates float owed to the user since the user last minted float for a market.\n  @param marketIndex Identifier for the market which the user staked in.\n  @param user The address of the user.\n  @return floatReward The amount of float owed.\n   /\n  function _calculateAccumulatedFloat(uint32 marketIndex, address user) internal virtual returns (uint256 floatReward) {\n    address longToken = syntheticTokens[marketIndex][true];\n    address shortToken = syntheticTokens[marketIndex][false];\n    uint256 amountStakedLong = userAmountStaked[longToken][user];\n    uint256 amountStakedShort = userAmountStaked[shortToken][user];\n    uint256 usersLastRewardIndex = userIndexOfLastClaimedReward[marketIndex][user];\n    // Don\'t do the calculation and return zero immediately if there is no change\n    if (usersLastRewardIndex == latestRewardIndex[marketIndex]) {\n      return 0;\n    }\n    uint256 usersShiftIndex = userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][user];\n    // if there is a change in the users tokens held due to a token shift (or possibly another action in the future)\n    if (usersShiftIndex &gt; 0 &amp;&amp; usersShiftIndex &lt; batched_stakerNextTokenShiftIndex[marketIndex]) {\n      floatReward = _calculateAccumulatedFloatInRange(\n        marketIndex,\n        amountStakedLong,\n        amountStakedShort,\n        usersLastRewardIndex,\n        stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[usersShiftIndex]\n      );\n      // Update the users balances\n      if (userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user] &gt; 0) {\n        amountStakedShort += ILongShort(longShort).getAmountSyntheticTokenToMintOnTargetSide(\n          marketIndex,\n          userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user],\n          true,\n          stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[usersShiftIndex]\n        );\n        amountStakedLong -= userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user];\n        userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user] = 0;\n      }\n      if (userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user] &gt; 0) {\n        amountStakedLong += ILongShort(longShort).getAmountSyntheticTokenToMintOnTargetSide(\n          marketIndex,\n          userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user],\n          false,\n          stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[usersShiftIndex]\n        );\n        amountStakedShort -= userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user];\n        userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user] = 0;\n      }\n      // Save the users updated staked amounts\n      userAmountStaked[longToken][user] = amountStakedLong;\n      userAmountStaked[shortToken][user] = amountStakedShort;\n      floatReward += _calculateAccumulatedFloatInRange(\n        marketIndex,\n        amountStakedLong,\n        amountStakedShort,\n        stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[usersShiftIndex],\n        latestRewardIndex[marketIndex]\n      );\n      userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][user] = 0;\n    } else {\n      floatReward = _calculateAccumulatedFloatInRange(\n        marketIndex,\n        amountStakedLong,\n        amountStakedShort,\n        usersLastRewardIndex,\n        latestRewardIndex[marketIndex]\n      );\n    }\n  }\n  /\n  @notice Mints float for a user.\n  @dev Mints a fixed percentage for Float capital.\n  @param user The address of the user.\n  @param floatToMint The amount of float to mint.\n   /\n  function _mintFloat(address user, uint256 floatToMint) internal virtual {\n    IFloatToken(floatToken).mint(user, floatToMint);\n    IFloatToken(floatToken).mint(floatCapital, (floatToMint * floatPercentage) / 1e18);\n  }\n  /\n  @notice Mints float owed to a user for a market since they last minted.\n  @param marketIndex An identifier for the market.\n  @param user The address of the user.\n   */\n  function _mintAccumulatedFloat(uint32 marketIndex, address user) internal virtual {\n    uint256 floatToMint = _calculateAccumulatedFloat(marketIndex, user);\n    if (floatToMint &gt; 0) {\n      // Set the user has claimed up until now, stops them setting this forward\n      userIndexOfLastClaimedReward[marketIndex][user] = latestRewardIndex[marketIndex];\n      _mintFloat(user, floatToMint);\n      emit FloatMinted(user, marketIndex, floatToMint);\n    }\n  }\n  /\n  @notice Mints float owed to a user for multiple markets, since they last minted for those markets.\n  @param marketIndexes Identifiers for the markets.\n  @param user The address of the user.\n   /\n  function _mintAccumulatedFloatMulti(uint32[] calldata marketIndexes, address user) internal virtual {\n    uint256 floatTotal = 0;\n    for (uint256 i = 0; i &lt; marketIndexes.length; i++) {\n      uint256 floatToMint = _calculateAccumulatedFloat(marketIndexes[i], user);\n      if (floatToMint &gt; 0) {\n        // Set the user has claimed up until now, stops them setting this forward\n        userIndexOfLastClaimedReward[marketIndexes[i]][user] = latestRewardIndex[marketIndexes[i]];\n        floatTotal += floatToMint;\n        emit FloatMinted(user, marketIndexes[i], floatToMint);\n      }\n    }\n    if (floatTotal &gt; 0) {\n      _mintFloat(user, floatTotal);\n    }\n  }\n  /\n  @notice Mints outstanding float for msg.sender.\n  @param marketIndexes Identifiers for the markets for which to mint float.\n   /\n  function claimFloatCustom(uint32[] calldata marketIndexes) external {\n    ILongShort(longShort).updateSystemStateMulti(marketIndexes);\n    _mintAccumulatedFloatMulti(marketIndexes, msg.sender);\n  }\n  /\n  @notice Mints outstanding float on behalf of another user.\n  @param marketIndexes Identifiers for the markets for which to mint float.\n  @param user The address of the user.\n   /\n  function claimFloatCustomFor(uint32[] calldata marketIndexes, address user) external {\n    // Unbounded loop - users are responsible for paying their own gas costs on these and it doesn\'t effect the rest of the system.\n    // No need to impose limit.\n    ILongShort(longShort).updateSystemStateMulti(marketIndexes);\n    _mintAccumulatedFloatMulti(marketIndexes, user);\n  }\n  /╔═══════════════════════╗\n    ║        STAKING        ║\n    ╚═══════════════════════╝*/\n  /\n  @notice A user with synthetic tokens stakes by calling stake on the token\n  contract which calls this function. We need to first update the\n  state of the LongShort contract for this market before staking to correctly calculate user rewards.\n  @param amount Amount to stake.\n  @param from Address to stake for.\n  /\n  function stakeFromUser(address from, uint256 amount) public virtual override onlyValidSynthetic((msg.sender)) {\n    ILongShort(longShort).updateSystemState(marketIndexOfToken[(msg.sender)]);\n    _stake((msg.sender), amount, from);\n  }\n  /\n  @dev Internal logic for staking.\n  @param token Address of the token for which to stake.\n  @param amount Amount to stake.\n  @param user Address to stake for.\n  /\n  function _stake(\n    address token,\n    uint256 amount,\n    address user\n  ) internal virtual {\n    uint32 marketIndex = marketIndexOfToken[token];\n    // If they already have staked and have rewards due, mint these.\n    if (\n      userIndexOfLastClaimedReward[marketIndex][user] != 0 &amp;&amp;\n      userIndexOfLastClaimedReward[marketIndex][user] &lt; latestRewardIndex[marketIndex]\n    ) {\n      _mintAccumulatedFloat(marketIndex, user);\n    }\n    userAmountStaked[token][user] = userAmountStaked[token][user] + amount;\n    userIndexOfLastClaimedReward[marketIndex][user] = latestRewardIndex[marketIndex];\n    emit StakeAdded(user, address(token), amount, userIndexOfLastClaimedReward[marketIndex][user]);\n  }\n  /\n  @notice Allows users to shift their staked tokens from one side of the market to \n  the other at the next price.\n  @param amountSyntheticTokensToShift Amount of tokens to shift.\n  @param marketIndex Identifier for the market.\n  @param isShiftFromLong Whether the shift is from long to short or short to long.\n  /\n  function shiftTokens(\n    uint256 amountSyntheticTokensToShift,\n    uint32 marketIndex,\n    bool isShiftFromLong\n  ) external virtual {\n    address token = syntheticTokens[marketIndex][isShiftFromLong];\n    require(userAmountStaked[token][msg.sender] &gt;= amountSyntheticTokensToShift, "Not enough tokens to shift");\n    // If the user has outstanding token shift that have already been confirmed in the LongShort\n    // contract, execute them first.\n    if (\n      userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] != 0 &amp;&amp;\n      userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] &lt;\n      batched_stakerNextTokenShiftIndex[marketIndex]\n    ) {\n      _mintAccumulatedFloat(marketIndex, msg.sender);\n    }\n    if (isShiftFromLong) {\n      ILongShort(longShort).shiftPositionFromLongNextPrice(marketIndex, amountSyntheticTokensToShift);\n      userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][\n        msg.sender\n      ] += amountSyntheticTokensToShift;\n    } else {\n      ILongShort(longShort).shiftPositionFromShortNextPrice(marketIndex, amountSyntheticTokensToShift);\n      userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][\n        msg.sender\n      ] += amountSyntheticTokensToShift;\n    }\n    userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] = batched_stakerNextTokenShiftIndex[\n      marketIndex\n    ];\n  }\n  /╔════════════════════════════╗\n    ║    WITHDRAWAL &amp; MINTING    ║\n    ╚════════════════════════════╝*/\n  /\n  @notice Internal logic for withdrawing stakes.\n  @dev Mint user any outstanding float before withdrawing.\n  @param marketIndex Market index of token.\n  @param amount Amount to withdraw.\n  @param token Synthetic token that was staked.\n  /\n  function _withdraw(\n    uint32 marketIndex,\n    address token,\n    uint256 amount\n  ) internal virtual {\n    require(userAmountStaked[token][msg.sender] &gt; 0, "nothing to withdraw");\n    _mintAccumulatedFloat(marketIndex, msg.sender);\n    userAmountStaked[token][msg.sender] = userAmountStaked[token][msg.sender] - amount;\n    uint256 amountFees = (amount * marketUnstakeFee_e18[marketIndex]) / 1e18;\n    IERC20(token).transfer(floatTreasury, amountFees);\n    IERC20(token).transfer(msg.sender, amount - amountFees);\n    emit StakeWithdrawn(msg.sender, token, amount);\n  }\n  /\n  @notice Withdraw function. Allows users to unstake.\n  @param amount Amount to withdraw.\n  @param token Address of the token for which to withdraw.\n  /\n  function withdraw(address token, uint256 amount) external {\n    ILongShort(longShort).updateSystemState(marketIndexOfToken[token]);\n    uint32 marketIndex = marketIndexOfToken[token];\n    _withdraw(marketIndex, token, amount);\n    if (userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] &gt; 0) {\n      // If they still have outstanding shifts after minting float, then check\n      // that they don\'t withdraw more than their shifts allow.\n      uint256 amountToShiftForThisToken = syntheticTokens[marketIndex][true] == token\n        ? userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][msg.sender]\n        : userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][msg.sender];\n      require(\n        userAmountStaked[token][msg.sender] &gt;= amountToShiftForThisToken,\n        "Outstanding next price stake shifts too great"\n      );\n    }\n  }\n  /*\n  @notice Allows users to withdraw their entire stake for a token.\n  @param token Address of the token for which to withdraw.\n  /\n  function withdrawAll(address token) external {\n    ILongShort(longShort).updateSystemState(marketIndexOfToken[token]);\n    uint32 marketIndex = marketIndexOfToken[token];\n    uint256 amountToShiftForThisToken = syntheticTokens[marketIndex][true] == token\n      ? userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][msg.sender]\n      : userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][msg.sender];\n    _withdraw(marketIndex, token, userAmountStaked[token][msg.sender] - amountToShiftForThisToken);\n  }\n}\n".\nAs the Security Analyst, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user.\nNote that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we\'ve collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with , followed directly by the final idea or enhancement suggestion, e.g. " Implementing a multi-sig wallet mechanism for added security in transactions".\n\nSecurity Analyst: Let\'s', 'question': 'Answer their Solidity smart contract ideas in the discussion without any other words, e.g., "A smart contract where we talk about Security: What functions the contract performs" '} |
| **need_reflect** | False |
| **memory** | No existed memory |
| **chat_turn_limit** | 1 |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-17-08 08:01:20 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Chief Executive Officer |
| **user_role_name** | Counselor |
| **assistant_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Counselor. Now, we share a common interest in collaborating to successfully complete a task assigned by a new customer. Your main responsibilities include asking what user and customer think and provide your valuable suggestions.  Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: BUSL-1.1 pragma solidity 0.8.3; import "@openzeppelin/contracts-upgradeable/token/ERC20/presets/ERC20PresetMinterPauserUpgradeable.sol"; import "./interfaces/IFloatToken.sol"; import "./interfaces/ILongShort.sol"; import "./interfaces/IStaker.sol"; import "./interfaces/ISyntheticToken.sol"; contract Staker is IStaker, Initializable {   /╔═════════════════════════════╗     ║          VARIABLES          ║     ╚═════════════════════════════╝/ / ══════ Fixed-precision constants ══════ /   uint256 public constant FLOAT_ISSUANCE_FIXED_DECIMAL = 1e42;   // 2^52 ~= 4.5e15   // With an exponent of 5, the largest total liquidity possible in a market (to avoid integer overflow on exponentiation) is ~10^31 or 10 Trillion (10^13)   // NOTE: this also means if the total market value is less than 2^52 there will be a division by zero error   uint256 public constant safeExponentBitShifting = 52; / ══════ Global state ══════ /   address public admin;   address public floatCapital;   address public floatTreasury;   uint256 public floatPercentage; address public longShort;   address public floatToken; / ══════ Market specific ══════ /   mapping(uint32 =&gt; uint256) public marketLaunchIncentive_period; // seconds   mapping(uint32 =&gt; uint256) public marketLaunchIncentive_multipliers; // e18 scale   mapping(uint32 =&gt; uint256) public marketUnstakeFee_e18;   mapping(uint32 =&gt; uint256) public balanceIncentiveCurve_exponent;   mapping(uint32 =&gt; int256) public balanceIncentiveCurve_equilibriumOffset; mapping(uint32 =&gt; mapping(bool =&gt; address)) public syntheticTokens; mapping(address =&gt; uint32) public marketIndexOfToken; / ══════ Reward specific ══════ /   mapping(uint32 =&gt; uint256) public latestRewardIndex;   mapping(uint32 =&gt; mapping(uint256 =&gt; AccumulativeIssuancePerStakedSynthSnapshot))     public accumulativeFloatPerSyntheticTokenSnapshots;   struct AccumulativeIssuancePerStakedSynthSnapshot {     uint256 timestamp;     uint256 accumulativeFloatPerSyntheticToken_long;     uint256 accumulativeFloatPerSyntheticToken_short;   } / ══════ User specific ══════ /   mapping(uint32 =&gt; mapping(address =&gt; uint256)) public userIndexOfLastClaimedReward;   mapping(address =&gt; mapping(address =&gt; uint256)) public userAmountStaked; / ══════ Token shift management specific ══════ /   mapping(uint32 =&gt; uint256) public batched_stakerNextTokenShiftIndex;   /*   @notice Used to link a token shift to a staker state   @dev tokenShiftIndex =&gt; accumulativeFloatIssuanceSnapshotIndex     POSSIBLE OPTIMIZATION - could pack stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping and stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping into a struct of two uint128 for storage space optimization.   /   mapping(uint256 =&gt; uint256) public stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping;   /// @notice Used to fetch the price from LongShort at that point in time   /// @dev tokenShiftIndex =&gt; longShortMarketPriceSnapshotIndex   mapping(uint256 =&gt; uint256) public stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping;   /// @dev marketIndex =&gt; usersAddress =&gt; stakerTokenShiftIndex   mapping(uint32 =&gt; mapping(address =&gt; uint256)) public userNextPrice_stakedSyntheticTokenShiftIndex;   /// @dev marketIndex =&gt; usersAddress =&gt; amountUserRequestedToShiftAwayFromLongOnNextUpdate   mapping(uint32 =&gt; mapping(address =&gt; uint256)) public userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long;   /// @dev marketIndex =&gt; usersAddress =&gt; amountUserRequestedToShiftAwayFromShortOnNextUpdate   mapping(uint32 =&gt; mapping(address =&gt; uint256)) public userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short; /╔════════════════════════════╗     ║           EVENTS           ║     ╚════════════════════════════╝/ event StakerV1(     address admin,     address floatTreasury,     address floatCapital,     address floatToken,     uint256 floatPercentage   ); event MarketAddedToStaker(     uint32 marketIndex,     uint256 exitFee_e18,     uint256 period,     uint256 multiplier,     uint256 balanceIncentiveExponent,     int256 balanceIncentiveEquilibriumOffset   ); event AccumulativeIssuancePerStakedSynthSnapshotCreated(     uint32 marketIndex,     uint256 accumulativeFloatIssuanceSnapshotIndex,     uint256 accumulativeLong,     uint256 accumulativeShort   ); event StakeAdded(address user, address token, uint256 amount, uint256 lastMintIndex); event StakeWithdrawn(address user, address token, uint256 amount); // Note: the amountFloatMinted isn't strictly needed by the graph, but it is good to add it to validate calculations are accurate.   event FloatMinted(address user, uint32 marketIndex, uint256 amountFloatMinted); event MarketLaunchIncentiveParametersChanges(uint32 marketIndex, uint256 period, uint256 multiplier); event StakeWithdrawalFeeUpdated(uint32 marketIndex, uint256 stakeWithdralFee); event BalanceIncentiveExponentUpdated(uint32 marketIndex, uint256 balanceIncentiveExponent); event BalanceIncentiveEquilibriumOffsetUpdated(uint32 marketIndex, int256 balanceIncentiveEquilibriumOffset); event FloatPercentageUpdated(uint256 floatPercentage); event SyntheticTokensShifted(); event ChangeAdmin(address newAdmin); /╔═════════════════════════════╗     ║          MODIFIERS          ║     ╚═════════════════════════════╝/ function onlyAdminModifierLogic() internal virtual {     require(msg.sender == admin, "not admin");   } modifier onlyAdmin() {     onlyAdminModifierLogic();     _;   } function onlyValidSyntheticModifierLogic(address _synth) internal virtual {     require(marketIndexOfToken[_synth] != 0, "not valid synth");   } modifier onlyValidSynthetic(address synth) {     onlyValidSyntheticModifierLogic(_synth);     ;   } function onlyValidMarketModifierLogic(uint32 marketIndex) internal virtual {     require(address(syntheticTokens[marketIndex][true]) != address(0), "not valid market");   } modifier onlyValidMarket(uint32 marketIndex) {     onlyValidMarketModifierLogic(marketIndex);     _;   } function onlyLongShortModifierLogic() internal virtual {     require(msg.sender == address(longShort), "not long short");   } modifier onlyLongShort() {     onlyLongShortModifierLogic();     _;   } /╔═════════════════════════════╗     ║       CONTRACT SET-UP       ║     ╚═════════════════════════════╝/ /*   @notice Initializes the contract.   @dev Calls OpenZeppelin's initializer modifier.   @param _admin Address of the admin role.   @param _longShort Address of the LongShort contract, a deployed LongShort.sol   @param _floatToken Address of the Float token earned by staking.   @param _floatTreasury Address of the treasury contract for managing fees.   @param _floatCapital Address of the contract which earns a fixed percentage of Float.   @param _floatPercentage Determines the float percentage that gets minted for Float Capital, base 1e18.   /   function initialize(     address _admin,     address _longShort,     address _floatToken,     address _floatTreasury,     address _floatCapital,     uint256 _floatPercentage   ) external virtual initializer {     admin = _admin;     floatCapital = _floatCapital;     floatTreasury = _floatTreasury;     longShort = _longShort;     floatToken = _floatToken; _changeFloatPercentage(_floatPercentage);  emit StakerV1(_admin, _floatTreasury, _floatCapital, _floatToken, _floatPercentage);  } /╔═══════════════════╗     ║       ADMIN       ║     ╚═══════════════════╝/ /*    @notice Changes admin for the contract   @param _admin The address of the new admin.   /   function changeAdmin(address _admin) external onlyAdmin {     admin = _admin;     emit ChangeAdmin(_admin);   } /// @dev Logic for changeFloatPercentage   function _changeFloatPercentage(uint256 newFloatPercentage) internal virtual {     require(newFloatPercentage &lt;= 1e18 &amp;&amp; newFloatPercentage &gt; 0); // less than or equal to 100% and greater than 0%     floatPercentage = newFloatPercentage;   } /*   @notice Changes percentage of float that is minted for float capital.   @param newFloatPercentage The new float percentage in base 1e18.   /   function changeFloatPercentage(uint256 newFloatPercentage) external onlyAdmin {     _changeFloatPercentage(newFloatPercentage);     emit FloatPercentageUpdated(newFloatPercentage);   } /// @dev Logic for changeUnstakeFee   function _changeUnstakeFee(uint32 marketIndex, uint256 newMarketUnstakeFee_e18) internal virtual {     require(newMarketUnstakeFee_e18 &lt;= 5e16); // Explicitely stating 5% fee as the max fee possible.     marketUnstakeFee_e18[marketIndex] = newMarketUnstakeFee_e18;   } /*   @notice Changes unstake fee for a market   @param marketIndex Identifies the market.   @param newMarketUnstakeFee_e18 The new unstake fee.   /   function changeUnstakeFee(uint32 marketIndex, uint256 newMarketUnstakeFee_e18) external onlyAdmin {     _changeUnstakeFee(marketIndex, newMarketUnstakeFee_e18);     emit StakeWithdrawalFeeUpdated(marketIndex, newMarketUnstakeFee_e18);   } /// @dev Logic for changeMarketLaunchIncentiveParameters   function _changeMarketLaunchIncentiveParameters(     uint32 marketIndex,     uint256 period,     uint256 initialMultiplier   ) internal virtual {     require(initialMultiplier &gt;= 1e18, "marketLaunchIncentiveMultiplier must be &gt;= 1e18"); marketLaunchIncentive_period[marketIndex] = period; marketLaunchIncentive_multipliers[marketIndex] = initialMultiplier;  } /*   @notice Changes the market launch incentive parameters for a market   @param marketIndex Identifies the market.   @param period The new period for which float token generation should be boosted.   @param initialMultiplier The new multiplier on Float generation.   /   function changeMarketLaunchIncentiveParameters(     uint32 marketIndex,     uint256 period,     uint256 initialMultiplier   ) external onlyAdmin {     _changeMarketLaunchIncentiveParameters(marketIndex, period, initialMultiplier); emit MarketLaunchIncentiveParametersChanges(marketIndex, period, initialMultiplier);  } /// @dev Logic for changeBalanceIncentiveExponent   function _changeBalanceIncentiveExponent(uint32 marketIndex, uint256 _balanceIncentiveCurve_exponent)     internal     virtual   {     require(       // The exponent has to be less than 5 in these versions of the contracts.       _balanceIncentiveCurve_exponent &gt; 0 &amp;&amp; _balanceIncentiveCurve_exponent &lt; 6,       "balanceIncentiveCurve_exponent out of bounds"     ); balanceIncentiveCurve_exponent[marketIndex] = _balanceIncentiveCurve_exponent;  } /*    @notice Changes the balance incentive exponent for a market   @param marketIndex Identifies the market.   @param _balanceIncentiveCurve_exponent The new exponent for the curve.   /   function changeBalanceIncentiveExponent(uint32 marketIndex, uint256 _balanceIncentiveCurve_exponent)     external     onlyAdmin   {     _changeBalanceIncentiveExponent(marketIndex, _balanceIncentiveCurve_exponent); emit BalanceIncentiveExponentUpdated(marketIndex, _balanceIncentiveCurve_exponent);  } /// @dev Logic for changeBalanceIncentiveEquilibriumOffset   function _changeBalanceIncentiveEquilibriumOffset(uint32 marketIndex, int256 _balanceIncentiveCurve_equilibriumOffset)     internal     virtual   {     // Unreasonable that we would ever shift this more than 90% either way     require(       _balanceIncentiveCurve_equilibriumOffset &gt; -9e17 &amp;&amp; _balanceIncentiveCurve_equilibriumOffset &lt; 9e17,       "balanceIncentiveCurve_equilibriumOffset out of bounds"     ); balanceIncentiveCurve_equilibriumOffset[marketIndex] = _balanceIncentiveCurve_equilibriumOffset;  } /*   @notice Changes the balance incentive curve equilibrium offset for a market   @param marketIndex Identifies the market.   @param _balanceIncentiveCurve_equilibriumOffset The new offset.   /   function changeBalanceIncentiveEquilibriumOffset(uint32 marketIndex, int256 _balanceIncentiveCurve_equilibriumOffset)     external     onlyAdmin   {     _changeBalanceIncentiveEquilibriumOffset(marketIndex, _balanceIncentiveCurve_equilibriumOffset); emit BalanceIncentiveEquilibriumOffsetUpdated(marketIndex, _balanceIncentiveCurve_equilibriumOffset);  } /╔═════════════════════════════╗     ║        STAKING SETUP        ║     ╚═════════════════════════════╝/ /*   @notice Sets this contract to track staking for a market in LongShort.sol   @param marketIndex Identifies the market.   @param longToken Address of the long token for the market.   @param shortToken Address of the short token for the market.   @param kInitialMultiplier Initial boost on float generation for the market.   @param kPeriod Period which the boost should last.   @param unstakeFee_e18 Percentage of tokens that are levied on unstaking in base 1e18.   @param _balanceIncentiveCurve_exponent Exponent for balance curve (see _calculateFloatPerSecond)   @param _balanceIncentiveCurve_equilibriumOffset Offset for balance curve (see _calculateFloatPerSecond)   /   function addNewStakingFund(     uint32 marketIndex,     address longToken,     address shortToken,     uint256 kInitialMultiplier,     uint256 kPeriod,     uint256 unstakeFee_e18,     uint256 _balanceIncentiveCurve_exponent,     int256 _balanceIncentiveCurve_equilibriumOffset   ) external override onlyLongShort {     marketIndexOfToken[longToken] = marketIndex;     marketIndexOfToken[shortToken] = marketIndex; accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].timestamp = block.timestamp; accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].accumulativeFloatPerSyntheticToken_long = 0; accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].accumulativeFloatPerSyntheticToken_short = 0;  syntheticTokens[marketIndex][true] = longToken; syntheticTokens[marketIndex][false] = shortToken;  _changeBalanceIncentiveExponent(marketIndex, _balanceIncentiveCurve_exponent); _changeBalanceIncentiveEquilibriumOffset(marketIndex, _balanceIncentiveCurve_equilibriumOffset); _changeMarketLaunchIncentiveParameters(marketIndex, kPeriod, kInitialMultiplier);  _changeUnstakeFee(marketIndex, unstakeFee_e18);  // Set this value to one initially - 0 is a null value and thus potentially bug prone. batched_stakerNextTokenShiftIndex[marketIndex] = 1;  emit MarketAddedToStaker(   marketIndex,   unstakeFee_e18,   kPeriod,   kInitialMultiplier,   _balanceIncentiveCurve_exponent,   _balanceIncentiveCurve_equilibriumOffset );  emit AccumulativeIssuancePerStakedSynthSnapshotCreated(marketIndex, 0, 0, 0);  } /╔═════════════════════════════════════════════════════════════════════════╗     ║    GLOBAL FLT REWARD ACCUMULATION CALCULATION AND TRACKING FUNCTIONS    ║     ╚═════════════════════════════════════════════════════════════════════════╝/ /*   @notice Returns the K factor parameters for the given market with sensible   defaults if they haven't been set yet.   @param marketIndex The market to change the parameters for.   @return period The period for which the k factor applies for in seconds.   @return multiplier The multiplier on Float generation in this period.   /   function _getMarketLaunchIncentiveParameters(uint32 marketIndex)     internal     view     virtual     returns (uint256 period, uint256 multiplier)   {     period = marketLaunchIncentive_period[marketIndex];     multiplier = marketLaunchIncentive_multipliers[marketIndex]; if (multiplier &lt; 1e18) {   multiplier = 1e18; // multiplier of 1 by default }  } /*    @notice Returns the extent to which a markets float generation should be adjusted   based on the market's launch incentive parameters. Should start at multiplier   then linearly change to 1e18 over time.   @param marketIndex Identifies the market.   @return k The calculated modifier for float generation.   /   function _getKValue(uint32 marketIndex) internal view virtual returns (uint256) {     // Parameters controlling the float issuance multiplier.     (uint256 kPeriod, uint256 kInitialMultiplier) = _getMarketLaunchIncentiveParameters(marketIndex); // Sanity check - under normal circumstances, the multipliers should // *never* be set to a value &lt; 1e18, as there are guards against this. assert(kInitialMultiplier &gt;= 1e18);  uint256 initialTimestamp = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].timestamp;  if (block.timestamp - initialTimestamp &lt;= kPeriod) {   return kInitialMultiplier - (((kInitialMultiplier - 1e18) * (block.timestamp - initialTimestamp)) / kPeriod); } else {   return 1e18; }  } /   @notice Computes the number of float tokens a user earns per second for   every long/short synthetic token they've staked. The returned value has   a fixed decimal scale of 1e42 (!!!) for numerical stability. The return   values are float per second per synthetic token (hence the requirement   to multiply by price)   @dev to see below math in latex form see TODO add link   to interact with the equations see https://www.desmos.com/calculator/optkaxyihr   @param marketIndex The market referred to.   @param longPrice Price of the synthetic long token in units of payment token   @param shortPrice Price of the synthetic short token in units of payment token   @param longValue Amount of payment token in the long side of the market   @param shortValue Amount of payment token in the short side of the market   @return longFloatPerSecond Float token per second per long synthetic token   @return shortFloatPerSecond Float token per second per short synthetic token    /   function _calculateFloatPerSecond(     uint32 marketIndex,     uint256 longPrice,     uint256 shortPrice,     uint256 longValue,     uint256 shortValue   ) internal view virtual returns (uint256 longFloatPerSecond, uint256 shortFloatPerSecond) {     // A float issuance multiplier that starts high and decreases linearly     // over time to a value of 1. This incentivises users to stake early.     uint256 k = _getKValue(marketIndex); uint256 totalLocked = (longValue + shortValue);  // we need to scale this number by the totalLocked so that the offset remains consistent accross market size  int256 equilibriumOffsetMarketScaled = (balanceIncentiveCurve_equilibriumOffset[marketIndex] *   int256(totalLocked)) / 2e18;  uint256 denominator = ((totalLocked &gt;&gt; safeExponentBitShifting)**balanceIncentiveCurve_exponent[marketIndex]);  // Float is scaled by the percentage of the total market value held in // the opposite position. This incentivises users to stake on the // weaker position. if (int256(shortValue) - equilibriumOffsetMarketScaled &lt; int256(longValue)) {   if (equilibriumOffsetMarketScaled &gt;= int256(shortValue)) {     // edge case: imbalanced far past the equilibrium offset - full rewards go to short token     //            extremeley unlikely to happen in practice     return (0, 1e18 * k * shortPrice);   }    uint256 numerator = (uint256(int256(shortValue) - equilibriumOffsetMarketScaled) &gt;&gt;     (safeExponentBitShifting - 1))**balanceIncentiveCurve_exponent[marketIndex];    // NOTE: `x * 5e17` == `(x * 10e18) / 2`   uint256 longRewardUnscaled = (numerator * 5e17) / denominator;   uint256 shortRewardUnscaled = 1e18 - longRewardUnscaled;    return ((longRewardUnscaled * k * longPrice) / 1e18, (shortRewardUnscaled * k * shortPrice) / 1e18); } else {   if (-equilibriumOffsetMarketScaled &gt;= int256(longValue)) {     // edge case: imbalanced far past the equilibrium offset - full rewards go to long token     //            extremeley unlikely to happen in practice     return (1e18 * k * longPrice, 0);   }    uint256 numerator = (uint256(int256(longValue) + equilibriumOffsetMarketScaled) &gt;&gt;     (safeExponentBitShifting - 1))**balanceIncentiveCurve_exponent[marketIndex];    // NOTE: `x * 5e17` == `(x * 10e18) / 2`   uint256 shortRewardUnscaled = (numerator * 5e17) / denominator;   uint256 longRewardUnscaled = 1e18 - shortRewardUnscaled;    return ((longRewardUnscaled * k * longPrice) / 1e18, (shortRewardUnscaled * k * shortPrice) / 1e18); }  } /*   @notice Computes the time since last accumulativeIssuancePerStakedSynthSnapshot for the given market in seconds.   @param marketIndex The market referred to.   @return The time difference in seconds   /   function _calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(uint32 marketIndex)     internal     view     virtual     returns (uint256)   {     return       block.timestamp -       accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]].timestamp;   } /*   @notice Computes new cumulative sum of 'r' value since last accumulativeIssuancePerStakedSynthSnapshot. We use   cumulative 'r' value to avoid looping during issuance. Note that the   cumulative sum is kept in 1e42 scale (!!!) to avoid numerical issues.   @param shortValue The value locked in the short side of the market.   @param longValue The value locked in the long side of the market.   @param shortPrice The price of the short token as defined in LongShort.sol   @param longPrice The price of the long token as defined in LongShort.sol   @param marketIndex An identifier for the market.   @return longCumulativeRates The long cumulative sum.   @return shortCumulativeRates The short cumulative sum.   /   function _calculateNewCumulativeIssuancePerStakedSynth(     uint32 marketIndex,     uint256 longPrice,     uint256 shortPrice,     uint256 longValue,     uint256 shortValue   ) internal view virtual returns (uint256 longCumulativeRates, uint256 shortCumulativeRates) {     // Compute the current 'r' value for float issuance per second.     (uint256 longFloatPerSecond, uint256 shortFloatPerSecond) = _calculateFloatPerSecond(       marketIndex,       longPrice,       shortPrice,       longValue,       shortValue     ); // Compute time since last accumulativeIssuancePerStakedSynthSnapshot for the given token. uint256 timeDelta = _calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(marketIndex);  // Compute new cumulative 'r' value total. return (   accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]]   .accumulativeFloatPerSyntheticToken_long + (timeDelta * longFloatPerSecond),   accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]]   .accumulativeFloatPerSyntheticToken_short + (timeDelta * shortFloatPerSecond) );  } /*   @notice Creates a new accumulativeIssuancePerStakedSynthSnapshot for the given token and updates indexes.   @param shortValue The value locked in the short side of the market.   @param longValue The value locked in the long side of the market.   @param shortPrice The price of the short token as defined in LongShort.sol   @param longPrice The price of the long token as defined in LongShort.sol   @param marketIndex An identifier for the market.   /   function _setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot(     uint32 marketIndex,     uint256 longPrice,     uint256 shortPrice,     uint256 longValue,     uint256 shortValue   ) internal virtual {     (       uint256 newLongAccumulativeValue,       uint256 newShortAccumulativeValue     ) = _calculateNewCumulativeIssuancePerStakedSynth(marketIndex, longPrice, shortPrice, longValue, shortValue); uint256 newIndex = latestRewardIndex[marketIndex] + 1;  // Set cumulative 'r' value on new accumulativeIssuancePerStakedSynthSnapshot. accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex] .accumulativeFloatPerSyntheticToken_long = newLongAccumulativeValue; accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex] .accumulativeFloatPerSyntheticToken_short = newShortAccumulativeValue;  // Set timestamp on new accumulativeIssuancePerStakedSynthSnapshot. accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex].timestamp = block.timestamp;  // Update latest index to point to new accumulativeIssuancePerStakedSynthSnapshot. latestRewardIndex[marketIndex] = newIndex;  emit AccumulativeIssuancePerStakedSynthSnapshotCreated(   marketIndex,   newIndex,   newLongAccumulativeValue,   newShortAccumulativeValue );  } /*   @notice Adds new accumulativeIssuancePerStakedSynthSnapshots for the given long/short tokens. Called by the   ILongShort contract whenever there is a state change for a market.   @param stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted Mapping from this contract's shifts to LongShort.sols next price snapshots.   @param shortValue The value locked in the short side of the market.   @param longValue The value locked in the long side of the market.   @param shortPrice The price of the short token as defined in LongShort.sol   @param longPrice The price of the long token as defined in LongShort.sol   @param marketIndex An identifier for the market.   /   function pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(     uint32 marketIndex,     uint256 longPrice,     uint256 shortPrice,     uint256 longValue,     uint256 shortValue,     uint256 stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted // This value should be ALWAYS be zero if no shift occured   ) external override onlyLongShort {     // Only add a new accumulativeIssuancePerStakedSynthSnapshot if some time has passed. // the `stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted` value will be 0 if there is no staker related action in an executed batch if (stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted &gt; 0) {   stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[     batched_stakerNextTokenShiftIndex[marketIndex]   ] = stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted;   stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[     batched_stakerNextTokenShiftIndex[marketIndex]   ] = latestRewardIndex[marketIndex] + 1;   batched_stakerNextTokenShiftIndex[marketIndex] += 1;    emit SyntheticTokensShifted(); }  // Time delta is fetched twice in below code, can pass through? Which is less gas? if (_calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(marketIndex) &gt; 0) {   _setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot(     marketIndex,     longPrice,     shortPrice,     longValue,     shortValue   ); }  } /╔═══════════════════════════════════╗     ║    USER REWARD STATE FUNCTIONS    ║     ╚═══════════════════════════════════╝/ /// @dev Calculates the accumulated float in a specific range of staker snapshots   function _calculateAccumulatedFloatInRange(     uint32 marketIndex,     uint256 amountStakedLong,     uint256 amountStakedShort,     uint256 rewardIndexFrom,     uint256 rewardIndexTo   ) internal view virtual returns (uint256 floatReward) {     if (amountStakedLong &gt; 0) {       uint256 accumDeltaLong = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexTo]       .accumulativeFloatPerSyntheticToken_long -         accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexFrom]         .accumulativeFloatPerSyntheticToken_long;       floatReward += (accumDeltaLong * amountStakedLong) / FLOAT_ISSUANCE_FIXED_DECIMAL;     } if (amountStakedShort &gt; 0) {   uint256 accumDeltaShort = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexTo]   .accumulativeFloatPerSyntheticToken_short -     accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexFrom]     .accumulativeFloatPerSyntheticToken_short;   floatReward += (accumDeltaShort * amountStakedShort) / FLOAT_ISSUANCE_FIXED_DECIMAL; }  } /*    @notice Calculates float owed to the user since the user last minted float for a market.   @param marketIndex Identifier for the market which the user staked in.   @param user The address of the user.   @return floatReward The amount of float owed.    /   function _calculateAccumulatedFloat(uint32 marketIndex, address user) internal virtual returns (uint256 floatReward) {     address longToken = syntheticTokens[marketIndex][true];     address shortToken = syntheticTokens[marketIndex][false]; uint256 amountStakedLong = userAmountStaked[longToken][user]; uint256 amountStakedShort = userAmountStaked[shortToken][user];  uint256 usersLastRewardIndex = userIndexOfLastClaimedReward[marketIndex][user];  // Don't do the calculation and return zero immediately if there is no change if (usersLastRewardIndex == latestRewardIndex[marketIndex]) {   return 0; }  uint256 usersShiftIndex = userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][user]; // if there is a change in the users tokens held due to a token shift (or possibly another action in the future) if (usersShiftIndex &gt; 0 &amp;&amp; usersShiftIndex &lt; batched_stakerNextTokenShiftIndex[marketIndex]) {   floatReward = _calculateAccumulatedFloatInRange(     marketIndex,     amountStakedLong,     amountStakedShort,     usersLastRewardIndex,     stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[usersShiftIndex]   );    // Update the users balances   if (userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user] &gt; 0) {     amountStakedShort += ILongShort(longShort).getAmountSyntheticTokenToMintOnTargetSide(       marketIndex,       userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user],       true,       stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[usersShiftIndex]     );      amountStakedLong -= userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user];     userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user] = 0;   }    if (userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user] &gt; 0) {     amountStakedLong += ILongShort(longShort).getAmountSyntheticTokenToMintOnTargetSide(       marketIndex,       userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user],       false,       stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[usersShiftIndex]     );      amountStakedShort -= userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user];     userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user] = 0;   }    // Save the users updated staked amounts   userAmountStaked[longToken][user] = amountStakedLong;   userAmountStaked[shortToken][user] = amountStakedShort;    floatReward += _calculateAccumulatedFloatInRange(     marketIndex,     amountStakedLong,     amountStakedShort,     stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[usersShiftIndex],     latestRewardIndex[marketIndex]   );    userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][user] = 0; } else {   floatReward = _calculateAccumulatedFloatInRange(     marketIndex,     amountStakedLong,     amountStakedShort,     usersLastRewardIndex,     latestRewardIndex[marketIndex]   ); }  } /*   @notice Mints float for a user.   @dev Mints a fixed percentage for Float capital.   @param user The address of the user.   @param floatToMint The amount of float to mint.    /   function _mintFloat(address user, uint256 floatToMint) internal virtual {     IFloatToken(floatToken).mint(user, floatToMint);     IFloatToken(floatToken).mint(floatCapital, (floatToMint * floatPercentage) / 1e18);   } /*   @notice Mints float owed to a user for a market since they last minted.   @param marketIndex An identifier for the market.   @param user The address of the user.    /   function _mintAccumulatedFloat(uint32 marketIndex, address user) internal virtual {     uint256 floatToMint = _calculateAccumulatedFloat(marketIndex, user); if (floatToMint &gt; 0) {   // Set the user has claimed up until now, stops them setting this forward   userIndexOfLastClaimedReward[marketIndex][user] = latestRewardIndex[marketIndex];    _mintFloat(user, floatToMint);   emit FloatMinted(user, marketIndex, floatToMint); }  } /*   @notice Mints float owed to a user for multiple markets, since they last minted for those markets.   @param marketIndexes Identifiers for the markets.   @param user The address of the user.    /   function _mintAccumulatedFloatMulti(uint32[] calldata marketIndexes, address user) internal virtual {     uint256 floatTotal = 0;     for (uint256 i = 0; i &lt; marketIndexes.length; i++) {       uint256 floatToMint = _calculateAccumulatedFloat(marketIndexes[i], user);   if (floatToMint &gt; 0) {     // Set the user has claimed up until now, stops them setting this forward     userIndexOfLastClaimedReward[marketIndexes[i]][user] = latestRewardIndex[marketIndexes[i]];      floatTotal += floatToMint;      emit FloatMinted(user, marketIndexes[i], floatToMint);   } } if (floatTotal &gt; 0) {   _mintFloat(user, floatTotal); }  } /*   @notice Mints outstanding float for msg.sender.   @param marketIndexes Identifiers for the markets for which to mint float.    /   function claimFloatCustom(uint32[] calldata marketIndexes) external {     ILongShort(longShort).updateSystemStateMulti(marketIndexes);     _mintAccumulatedFloatMulti(marketIndexes, msg.sender);   } /*   @notice Mints outstanding float on behalf of another user.   @param marketIndexes Identifiers for the markets for which to mint float.   @param user The address of the user.    /   function claimFloatCustomFor(uint32[] calldata marketIndexes, address user) external {     // Unbounded loop - users are responsible for paying their own gas costs on these and it doesn't effect the rest of the system.     // No need to impose limit.     ILongShort(longShort).updateSystemStateMulti(marketIndexes);     _mintAccumulatedFloatMulti(marketIndexes, user);   } /╔═══════════════════════╗     ║        STAKING        ║     ╚═══════════════════════╝/ /*   @notice A user with synthetic tokens stakes by calling stake on the token   contract which calls this function. We need to first update the   state of the LongShort contract for this market before staking to correctly calculate user rewards.   @param amount Amount to stake.   @param from Address to stake for.   /   function stakeFromUser(address from, uint256 amount) public virtual override onlyValidSynthetic((msg.sender)) {     ILongShort(longShort).updateSystemState(marketIndexOfToken[(msg.sender)]);     _stake((msg.sender), amount, from);   } /*   @dev Internal logic for staking.   @param token Address of the token for which to stake.   @param amount Amount to stake.   @param user Address to stake for.   /   function _stake(     address token,     uint256 amount,     address user   ) internal virtual {     uint32 marketIndex = marketIndexOfToken[token]; // If they already have staked and have rewards due, mint these. if (   userIndexOfLastClaimedReward[marketIndex][user] != 0 &amp;&amp;   userIndexOfLastClaimedReward[marketIndex][user] &lt; latestRewardIndex[marketIndex] ) {   _mintAccumulatedFloat(marketIndex, user); }  userAmountStaked[token][user] = userAmountStaked[token][user] + amount;  userIndexOfLastClaimedReward[marketIndex][user] = latestRewardIndex[marketIndex];  emit StakeAdded(user, address(token), amount, userIndexOfLastClaimedReward[marketIndex][user]);  } /*   @notice Allows users to shift their staked tokens from one side of the market to    the other at the next price.   @param amountSyntheticTokensToShift Amount of tokens to shift.   @param marketIndex Identifier for the market.   @param isShiftFromLong Whether the shift is from long to short or short to long.   /   function shiftTokens(     uint256 amountSyntheticTokensToShift,     uint32 marketIndex,     bool isShiftFromLong   ) external virtual {     address token = syntheticTokens[marketIndex][isShiftFromLong];     require(userAmountStaked[token][msg.sender] &gt;= amountSyntheticTokensToShift, "Not enough tokens to shift"); // If the user has outstanding token shift that have already been confirmed in the LongShort // contract, execute them first. if (   userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] != 0 &amp;&amp;   userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] &lt;   batched_stakerNextTokenShiftIndex[marketIndex] ) {   _mintAccumulatedFloat(marketIndex, msg.sender); }  if (isShiftFromLong) {   ILongShort(longShort).shiftPositionFromLongNextPrice(marketIndex, amountSyntheticTokensToShift);   userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][     msg.sender   ] += amountSyntheticTokensToShift; } else {   ILongShort(longShort).shiftPositionFromShortNextPrice(marketIndex, amountSyntheticTokensToShift);   userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][     msg.sender   ] += amountSyntheticTokensToShift; }  userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] = batched_stakerNextTokenShiftIndex[   marketIndex ];  } /╔════════════════════════════╗     ║    WITHDRAWAL &amp; MINTING    ║     ╚════════════════════════════╝/ /*   @notice Internal logic for withdrawing stakes.   @dev Mint user any outstanding float before withdrawing.   @param marketIndex Market index of token.   @param amount Amount to withdraw.   @param token Synthetic token that was staked.   /   function _withdraw(     uint32 marketIndex,     address token,     uint256 amount   ) internal virtual {     require(userAmountStaked[token][msg.sender] &gt; 0, "nothing to withdraw");     _mintAccumulatedFloat(marketIndex, msg.sender); userAmountStaked[token][msg.sender] = userAmountStaked[token][msg.sender] - amount;  uint256 amountFees = (amount * marketUnstakeFee_e18[marketIndex]) / 1e18;  IERC20(token).transfer(floatTreasury, amountFees); IERC20(token).transfer(msg.sender, amount - amountFees);  emit StakeWithdrawn(msg.sender, token, amount);  } /*   @notice Withdraw function. Allows users to unstake.   @param amount Amount to withdraw.   @param token Address of the token for which to withdraw.   /   function withdraw(address token, uint256 amount) external {     ILongShort(longShort).updateSystemState(marketIndexOfToken[token]); uint32 marketIndex = marketIndexOfToken[token];  _withdraw(marketIndex, token, amount);  if (userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] &gt; 0) {   // If they still have outstanding shifts after minting float, then check   // that they don't withdraw more than their shifts allow.   uint256 amountToShiftForThisToken = syntheticTokens[marketIndex][true] == token     ? userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][msg.sender]     : userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][msg.sender];    require(     userAmountStaked[token][msg.sender] &gt;= amountToShiftForThisToken,     "Outstanding next price stake shifts too great"   ); }  } /*   @notice Allows users to withdraw their entire stake for a token.   @param token Address of the token for which to withdraw.   /   function withdrawAll(address token) external {     ILongShort(longShort).updateSystemState(marketIndexOfToken[token]); uint32 marketIndex = marketIndexOfToken[token];  uint256 amountToShiftForThisToken = syntheticTokens[marketIndex][true] == token   ? userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][msg.sender]   : userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][msg.sender];  _withdraw(marketIndex, token, userAmountStaked[token][msg.sender] - amountToShiftForThisToken);  } } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-17-08 08:01:20 INFO] Counselor: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer.
Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees.
Here is a new customer's task: // SPDX-License-Identifier: BUSL-1.1

pragma solidity 0.8.3;

import "@openzeppelin/contracts-upgradeable/token/ERC20/presets/ERC20PresetMinterPauserUpgradeable.sol";

import "./interfaces/IFloatToken.sol";
import "./interfaces/ILongShort.sol";
import "./interfaces/IStaker.sol";
import "./interfaces/ISyntheticToken.sol";

contract Staker is IStaker, Initializable {
  /*╔═════════════════════════════╗
    ║          VARIABLES          ║
    ╚═════════════════════════════╝*/

  /* ══════ Fixed-precision constants ══════ */
  uint256 public constant FLOAT_ISSUANCE_FIXED_DECIMAL = 1e42;
  // 2^52 ~= 4.5e15
  // With an exponent of 5, the largest total liquidity possible in a market (to avoid integer overflow on exponentiation) is ~10^31 or 10 Trillion (10^13)
  // NOTE: this also means if the total market value is less than 2^52 there will be a division by zero error
  uint256 public constant safeExponentBitShifting = 52;

  /* ══════ Global state ══════ */
  address public admin;
  address public floatCapital;
  address public floatTreasury;
  uint256 public floatPercentage;

  address public longShort;
  address public floatToken;

  /* ══════ Market specific ══════ */
  mapping(uint32 => uint256) public marketLaunchIncentive_period; // seconds
  mapping(uint32 => uint256) public marketLaunchIncentive_multipliers; // e18 scale
  mapping(uint32 => uint256) public marketUnstakeFee_e18;
  mapping(uint32 => uint256) public balanceIncentiveCurve_exponent;
  mapping(uint32 => int256) public balanceIncentiveCurve_equilibriumOffset;

  mapping(uint32 => mapping(bool => address)) public syntheticTokens;

  mapping(address => uint32) public marketIndexOfToken;

  /* ══════ Reward specific ══════ */
  mapping(uint32 => uint256) public latestRewardIndex;
  mapping(uint32 => mapping(uint256 => AccumulativeIssuancePerStakedSynthSnapshot))
    public accumulativeFloatPerSyntheticTokenSnapshots;
  struct AccumulativeIssuancePerStakedSynthSnapshot {
    uint256 timestamp;
    uint256 accumulativeFloatPerSyntheticToken_long;
    uint256 accumulativeFloatPerSyntheticToken_short;
  }

  /* ══════ User specific ══════ */
  mapping(uint32 => mapping(address => uint256)) public userIndexOfLastClaimedReward;
  mapping(address => mapping(address => uint256)) public userAmountStaked;

  /* ══════ Token shift management specific ══════ */
  mapping(uint32 => uint256) public batched_stakerNextTokenShiftIndex;
  /**
  @notice Used to link a token shift to a staker state
  @dev tokenShiftIndex => accumulativeFloatIssuanceSnapshotIndex
    POSSIBLE OPTIMIZATION - could pack stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping and stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping into a struct of two uint128 for storage space optimization.
  */
  mapping(uint256 => uint256) public stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping;
  /// @notice Used to fetch the price from LongShort at that point in time
  /// @dev tokenShiftIndex => longShortMarketPriceSnapshotIndex
  mapping(uint256 => uint256) public stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping;
  /// @dev marketIndex => usersAddress => stakerTokenShiftIndex
  mapping(uint32 => mapping(address => uint256)) public userNextPrice_stakedSyntheticTokenShiftIndex;
  /// @dev marketIndex => usersAddress => amountUserRequestedToShiftAwayFromLongOnNextUpdate
  mapping(uint32 => mapping(address => uint256)) public userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long;
  /// @dev marketIndex => usersAddress => amountUserRequestedToShiftAwayFromShortOnNextUpdate
  mapping(uint32 => mapping(address => uint256)) public userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short;

  /*╔════════════════════════════╗
    ║           EVENTS           ║
    ╚════════════════════════════╝*/

  event StakerV1(
    address admin,
    address floatTreasury,
    address floatCapital,
    address floatToken,
    uint256 floatPercentage
  );

  event MarketAddedToStaker(
    uint32 marketIndex,
    uint256 exitFee_e18,
    uint256 period,
    uint256 multiplier,
    uint256 balanceIncentiveExponent,
    int256 balanceIncentiveEquilibriumOffset
  );

  event AccumulativeIssuancePerStakedSynthSnapshotCreated(
    uint32 marketIndex,
    uint256 accumulativeFloatIssuanceSnapshotIndex,
    uint256 accumulativeLong,
    uint256 accumulativeShort
  );

  event StakeAdded(address user, address token, uint256 amount, uint256 lastMintIndex);

  event StakeWithdrawn(address user, address token, uint256 amount);

  // Note: the `amountFloatMinted` isn't strictly needed by the graph, but it is good to add it to validate calculations are accurate.
  event FloatMinted(address user, uint32 marketIndex, uint256 amountFloatMinted);

  event MarketLaunchIncentiveParametersChanges(uint32 marketIndex, uint256 period, uint256 multiplier);

  event StakeWithdrawalFeeUpdated(uint32 marketIndex, uint256 stakeWithdralFee);

  event BalanceIncentiveExponentUpdated(uint32 marketIndex, uint256 balanceIncentiveExponent);

  event BalanceIncentiveEquilibriumOffsetUpdated(uint32 marketIndex, int256 balanceIncentiveEquilibriumOffset);

  event FloatPercentageUpdated(uint256 floatPercentage);

  event SyntheticTokensShifted();

  event ChangeAdmin(address newAdmin);

  /*╔═════════════════════════════╗
    ║          MODIFIERS          ║
    ╚═════════════════════════════╝*/

  function onlyAdminModifierLogic() internal virtual {
    require(msg.sender == admin, "not admin");
  }

  modifier onlyAdmin() {
    onlyAdminModifierLogic();
    _;
  }

  function onlyValidSyntheticModifierLogic(address _synth) internal virtual {
    require(marketIndexOfToken[_synth] != 0, "not valid synth");
  }

  modifier onlyValidSynthetic(address _synth) {
    onlyValidSyntheticModifierLogic(_synth);
    _;
  }

  function onlyValidMarketModifierLogic(uint32 marketIndex) internal virtual {
    require(address(syntheticTokens[marketIndex][true]) != address(0), "not valid market");
  }

  modifier onlyValidMarket(uint32 marketIndex) {
    onlyValidMarketModifierLogic(marketIndex);
    _;
  }

  function onlyLongShortModifierLogic() internal virtual {
    require(msg.sender == address(longShort), "not long short");
  }

  modifier onlyLongShort() {
    onlyLongShortModifierLogic();
    _;
  }

  /*╔═════════════════════════════╗
    ║       CONTRACT SET-UP       ║
    ╚═════════════════════════════╝*/

  /**
  @notice Initializes the contract.
  @dev Calls OpenZeppelin's initializer modifier.
  @param _admin Address of the admin role.
  @param _longShort Address of the LongShort contract, a deployed LongShort.sol
  @param _floatToken Address of the Float token earned by staking.
  @param _floatTreasury Address of the treasury contract for managing fees.
  @param _floatCapital Address of the contract which earns a fixed percentage of Float.
  @param _floatPercentage Determines the float percentage that gets minted for Float Capital, base 1e18.
  */
  function initialize(
    address _admin,
    address _longShort,
    address _floatToken,
    address _floatTreasury,
    address _floatCapital,
    uint256 _floatPercentage
  ) external virtual initializer {
    admin = _admin;
    floatCapital = _floatCapital;
    floatTreasury = _floatTreasury;
    longShort = _longShort;
    floatToken = _floatToken;

    _changeFloatPercentage(_floatPercentage);

    emit StakerV1(_admin, _floatTreasury, _floatCapital, _floatToken, _floatPercentage);
  }

  /*╔═══════════════════╗
    ║       ADMIN       ║
    ╚═══════════════════╝*/

  /** 
  @notice Changes admin for the contract
  @param _admin The address of the new admin.
  */
  function changeAdmin(address _admin) external onlyAdmin {
    admin = _admin;
    emit ChangeAdmin(_admin);
  }

  /// @dev Logic for changeFloatPercentage
  function _changeFloatPercentage(uint256 newFloatPercentage) internal virtual {
    require(newFloatPercentage <= 1e18 && newFloatPercentage > 0); // less than or equal to 100% and greater than 0%
    floatPercentage = newFloatPercentage;
  }

  /**
  @notice Changes percentage of float that is minted for float capital.
  @param newFloatPercentage The new float percentage in base 1e18.
  */
  function changeFloatPercentage(uint256 newFloatPercentage) external onlyAdmin {
    _changeFloatPercentage(newFloatPercentage);
    emit FloatPercentageUpdated(newFloatPercentage);
  }

  /// @dev Logic for changeUnstakeFee
  function _changeUnstakeFee(uint32 marketIndex, uint256 newMarketUnstakeFee_e18) internal virtual {
    require(newMarketUnstakeFee_e18 <= 5e16); // Explicitely stating 5% fee as the max fee possible.
    marketUnstakeFee_e18[marketIndex] = newMarketUnstakeFee_e18;
  }

  /**
  @notice Changes unstake fee for a market
  @param marketIndex Identifies the market.
  @param newMarketUnstakeFee_e18 The new unstake fee.
  */
  function changeUnstakeFee(uint32 marketIndex, uint256 newMarketUnstakeFee_e18) external onlyAdmin {
    _changeUnstakeFee(marketIndex, newMarketUnstakeFee_e18);
    emit StakeWithdrawalFeeUpdated(marketIndex, newMarketUnstakeFee_e18);
  }

  /// @dev Logic for changeMarketLaunchIncentiveParameters
  function _changeMarketLaunchIncentiveParameters(
    uint32 marketIndex,
    uint256 period,
    uint256 initialMultiplier
  ) internal virtual {
    require(initialMultiplier >= 1e18, "marketLaunchIncentiveMultiplier must be >= 1e18");

    marketLaunchIncentive_period[marketIndex] = period;
    marketLaunchIncentive_multipliers[marketIndex] = initialMultiplier;
  }

  /**
  @notice Changes the market launch incentive parameters for a market
  @param marketIndex Identifies the market.
  @param period The new period for which float token generation should be boosted.
  @param initialMultiplier The new multiplier on Float generation.
  */
  function changeMarketLaunchIncentiveParameters(
    uint32 marketIndex,
    uint256 period,
    uint256 initialMultiplier
  ) external onlyAdmin {
    _changeMarketLaunchIncentiveParameters(marketIndex, period, initialMultiplier);

    emit MarketLaunchIncentiveParametersChanges(marketIndex, period, initialMultiplier);
  }

  /// @dev Logic for changeBalanceIncentiveExponent
  function _changeBalanceIncentiveExponent(uint32 marketIndex, uint256 _balanceIncentiveCurve_exponent)
    internal
    virtual
  {
    require(
      // The exponent has to be less than 5 in these versions of the contracts.
      _balanceIncentiveCurve_exponent > 0 && _balanceIncentiveCurve_exponent < 6,
      "balanceIncentiveCurve_exponent out of bounds"
    );

    balanceIncentiveCurve_exponent[marketIndex] = _balanceIncentiveCurve_exponent;
  }

  /** 
  @notice Changes the balance incentive exponent for a market
  @param marketIndex Identifies the market.
  @param _balanceIncentiveCurve_exponent The new exponent for the curve.
  */
  function changeBalanceIncentiveExponent(uint32 marketIndex, uint256 _balanceIncentiveCurve_exponent)
    external
    onlyAdmin
  {
    _changeBalanceIncentiveExponent(marketIndex, _balanceIncentiveCurve_exponent);

    emit BalanceIncentiveExponentUpdated(marketIndex, _balanceIncentiveCurve_exponent);
  }

  /// @dev Logic for changeBalanceIncentiveEquilibriumOffset
  function _changeBalanceIncentiveEquilibriumOffset(uint32 marketIndex, int256 _balanceIncentiveCurve_equilibriumOffset)
    internal
    virtual
  {
    // Unreasonable that we would ever shift this more than 90% either way
    require(
      _balanceIncentiveCurve_equilibriumOffset > -9e17 && _balanceIncentiveCurve_equilibriumOffset < 9e17,
      "balanceIncentiveCurve_equilibriumOffset out of bounds"
    );

    balanceIncentiveCurve_equilibriumOffset[marketIndex] = _balanceIncentiveCurve_equilibriumOffset;
  }

  /**
  @notice Changes the balance incentive curve equilibrium offset for a market
  @param marketIndex Identifies the market.
  @param _balanceIncentiveCurve_equilibriumOffset The new offset.
  */
  function changeBalanceIncentiveEquilibriumOffset(uint32 marketIndex, int256 _balanceIncentiveCurve_equilibriumOffset)
    external
    onlyAdmin
  {
    _changeBalanceIncentiveEquilibriumOffset(marketIndex, _balanceIncentiveCurve_equilibriumOffset);

    emit BalanceIncentiveEquilibriumOffsetUpdated(marketIndex, _balanceIncentiveCurve_equilibriumOffset);
  }

  /*╔═════════════════════════════╗
    ║        STAKING SETUP        ║
    ╚═════════════════════════════╝*/

  /**
  @notice Sets this contract to track staking for a market in LongShort.sol
  @param marketIndex Identifies the market.
  @param longToken Address of the long token for the market.
  @param shortToken Address of the short token for the market.
  @param kInitialMultiplier Initial boost on float generation for the market.
  @param kPeriod Period which the boost should last.
  @param unstakeFee_e18 Percentage of tokens that are levied on unstaking in base 1e18.
  @param _balanceIncentiveCurve_exponent Exponent for balance curve (see _calculateFloatPerSecond)
  @param _balanceIncentiveCurve_equilibriumOffset Offset for balance curve (see _calculateFloatPerSecond)
  */
  function addNewStakingFund(
    uint32 marketIndex,
    address longToken,
    address shortToken,
    uint256 kInitialMultiplier,
    uint256 kPeriod,
    uint256 unstakeFee_e18,
    uint256 _balanceIncentiveCurve_exponent,
    int256 _balanceIncentiveCurve_equilibriumOffset
  ) external override onlyLongShort {
    marketIndexOfToken[longToken] = marketIndex;
    marketIndexOfToken[shortToken] = marketIndex;

    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].timestamp = block.timestamp;
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].accumulativeFloatPerSyntheticToken_long = 0;
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].accumulativeFloatPerSyntheticToken_short = 0;

    syntheticTokens[marketIndex][true] = longToken;
    syntheticTokens[marketIndex][false] = shortToken;

    _changeBalanceIncentiveExponent(marketIndex, _balanceIncentiveCurve_exponent);
    _changeBalanceIncentiveEquilibriumOffset(marketIndex, _balanceIncentiveCurve_equilibriumOffset);
    _changeMarketLaunchIncentiveParameters(marketIndex, kPeriod, kInitialMultiplier);

    _changeUnstakeFee(marketIndex, unstakeFee_e18);

    // Set this value to one initially - 0 is a null value and thus potentially bug prone.
    batched_stakerNextTokenShiftIndex[marketIndex] = 1;

    emit MarketAddedToStaker(
      marketIndex,
      unstakeFee_e18,
      kPeriod,
      kInitialMultiplier,
      _balanceIncentiveCurve_exponent,
      _balanceIncentiveCurve_equilibriumOffset
    );

    emit AccumulativeIssuancePerStakedSynthSnapshotCreated(marketIndex, 0, 0, 0);
  }

  /*╔═════════════════════════════════════════════════════════════════════════╗
    ║    GLOBAL FLT REWARD ACCUMULATION CALCULATION AND TRACKING FUNCTIONS    ║
    ╚═════════════════════════════════════════════════════════════════════════╝*/

  /**
  @notice Returns the K factor parameters for the given market with sensible
  defaults if they haven't been set yet.
  @param marketIndex The market to change the parameters for.
  @return period The period for which the k factor applies for in seconds.
  @return multiplier The multiplier on Float generation in this period.
  */
  function _getMarketLaunchIncentiveParameters(uint32 marketIndex)
    internal
    view
    virtual
    returns (uint256 period, uint256 multiplier)
  {
    period = marketLaunchIncentive_period[marketIndex];
    multiplier = marketLaunchIncentive_multipliers[marketIndex];

    if (multiplier < 1e18) {
      multiplier = 1e18; // multiplier of 1 by default
    }
  }

  /** 
  @notice Returns the extent to which a markets float generation should be adjusted
  based on the market's launch incentive parameters. Should start at multiplier
  then linearly change to 1e18 over time.
  @param marketIndex Identifies the market.
  @return k The calculated modifier for float generation.
  */
  function _getKValue(uint32 marketIndex) internal view virtual returns (uint256) {
    // Parameters controlling the float issuance multiplier.
    (uint256 kPeriod, uint256 kInitialMultiplier) = _getMarketLaunchIncentiveParameters(marketIndex);

    // Sanity check - under normal circumstances, the multipliers should
    // *never* be set to a value < 1e18, as there are guards against this.
    assert(kInitialMultiplier >= 1e18);

    uint256 initialTimestamp = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].timestamp;

    if (block.timestamp - initialTimestamp <= kPeriod) {
      return kInitialMultiplier - (((kInitialMultiplier - 1e18) * (block.timestamp - initialTimestamp)) / kPeriod);
    } else {
      return 1e18;
    }
  }

  /*
  @notice Computes the number of float tokens a user earns per second for
  every long/short synthetic token they've staked. The returned value has
  a fixed decimal scale of 1e42 (!!!) for numerical stability. The return
  values are float per second per synthetic token (hence the requirement
  to multiply by price)
  @dev to see below math in latex form see TODO add link
  to interact with the equations see https://www.desmos.com/calculator/optkaxyihr
  @param marketIndex The market referred to.
  @param longPrice Price of the synthetic long token in units of payment token
  @param shortPrice Price of the synthetic short token in units of payment token
  @param longValue Amount of payment token in the long side of the market
  @param shortValue Amount of payment token in the short side of the market
  @return longFloatPerSecond Float token per second per long synthetic token
  @return shortFloatPerSecond Float token per second per short synthetic token
   */
  function _calculateFloatPerSecond(
    uint32 marketIndex,
    uint256 longPrice,
    uint256 shortPrice,
    uint256 longValue,
    uint256 shortValue
  ) internal view virtual returns (uint256 longFloatPerSecond, uint256 shortFloatPerSecond) {
    // A float issuance multiplier that starts high and decreases linearly
    // over time to a value of 1. This incentivises users to stake early.
    uint256 k = _getKValue(marketIndex);

    uint256 totalLocked = (longValue + shortValue);

    // we need to scale this number by the totalLocked so that the offset remains consistent accross market size

    int256 equilibriumOffsetMarketScaled = (balanceIncentiveCurve_equilibriumOffset[marketIndex] *
      int256(totalLocked)) / 2e18;

    uint256 denominator = ((totalLocked >> safeExponentBitShifting)**balanceIncentiveCurve_exponent[marketIndex]);

    // Float is scaled by the percentage of the total market value held in
    // the opposite position. This incentivises users to stake on the
    // weaker position.
    if (int256(shortValue) - equilibriumOffsetMarketScaled < int256(longValue)) {
      if (equilibriumOffsetMarketScaled >= int256(shortValue)) {
        // edge case: imbalanced far past the equilibrium offset - full rewards go to short token
        //            extremeley unlikely to happen in practice
        return (0, 1e18 * k * shortPrice);
      }

      uint256 numerator = (uint256(int256(shortValue) - equilibriumOffsetMarketScaled) >>
        (safeExponentBitShifting - 1))**balanceIncentiveCurve_exponent[marketIndex];

      // NOTE: `x * 5e17` == `(x * 10e18) / 2`
      uint256 longRewardUnscaled = (numerator * 5e17) / denominator;
      uint256 shortRewardUnscaled = 1e18 - longRewardUnscaled;

      return ((longRewardUnscaled * k * longPrice) / 1e18, (shortRewardUnscaled * k * shortPrice) / 1e18);
    } else {
      if (-equilibriumOffsetMarketScaled >= int256(longValue)) {
        // edge case: imbalanced far past the equilibrium offset - full rewards go to long token
        //            extremeley unlikely to happen in practice
        return (1e18 * k * longPrice, 0);
      }

      uint256 numerator = (uint256(int256(longValue) + equilibriumOffsetMarketScaled) >>
        (safeExponentBitShifting - 1))**balanceIncentiveCurve_exponent[marketIndex];

      // NOTE: `x * 5e17` == `(x * 10e18) / 2`
      uint256 shortRewardUnscaled = (numerator * 5e17) / denominator;
      uint256 longRewardUnscaled = 1e18 - shortRewardUnscaled;

      return ((longRewardUnscaled * k * longPrice) / 1e18, (shortRewardUnscaled * k * shortPrice) / 1e18);
    }
  }

  /**
  @notice Computes the time since last accumulativeIssuancePerStakedSynthSnapshot for the given market in seconds.
  @param marketIndex The market referred to.
  @return The time difference in seconds
  */
  function _calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(uint32 marketIndex)
    internal
    view
    virtual
    returns (uint256)
  {
    return
      block.timestamp -
      accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]].timestamp;
  }

  /**
  @notice Computes new cumulative sum of 'r' value since last accumulativeIssuancePerStakedSynthSnapshot. We use
  cumulative 'r' value to avoid looping during issuance. Note that the
  cumulative sum is kept in 1e42 scale (!!!) to avoid numerical issues.
  @param shortValue The value locked in the short side of the market.
  @param longValue The value locked in the long side of the market.
  @param shortPrice The price of the short token as defined in LongShort.sol
  @param longPrice The price of the long token as defined in LongShort.sol
  @param marketIndex An identifier for the market.
  @return longCumulativeRates The long cumulative sum.
  @return shortCumulativeRates The short cumulative sum.
  */
  function _calculateNewCumulativeIssuancePerStakedSynth(
    uint32 marketIndex,
    uint256 longPrice,
    uint256 shortPrice,
    uint256 longValue,
    uint256 shortValue
  ) internal view virtual returns (uint256 longCumulativeRates, uint256 shortCumulativeRates) {
    // Compute the current 'r' value for float issuance per second.
    (uint256 longFloatPerSecond, uint256 shortFloatPerSecond) = _calculateFloatPerSecond(
      marketIndex,
      longPrice,
      shortPrice,
      longValue,
      shortValue
    );

    // Compute time since last accumulativeIssuancePerStakedSynthSnapshot for the given token.
    uint256 timeDelta = _calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(marketIndex);

    // Compute new cumulative 'r' value total.
    return (
      accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]]
      .accumulativeFloatPerSyntheticToken_long + (timeDelta * longFloatPerSecond),
      accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]]
      .accumulativeFloatPerSyntheticToken_short + (timeDelta * shortFloatPerSecond)
    );
  }

  /**
  @notice Creates a new accumulativeIssuancePerStakedSynthSnapshot for the given token and updates indexes.
  @param shortValue The value locked in the short side of the market.
  @param longValue The value locked in the long side of the market.
  @param shortPrice The price of the short token as defined in LongShort.sol
  @param longPrice The price of the long token as defined in LongShort.sol
  @param marketIndex An identifier for the market.
  */
  function _setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot(
    uint32 marketIndex,
    uint256 longPrice,
    uint256 shortPrice,
    uint256 longValue,
    uint256 shortValue
  ) internal virtual {
    (
      uint256 newLongAccumulativeValue,
      uint256 newShortAccumulativeValue
    ) = _calculateNewCumulativeIssuancePerStakedSynth(marketIndex, longPrice, shortPrice, longValue, shortValue);

    uint256 newIndex = latestRewardIndex[marketIndex] + 1;

    // Set cumulative 'r' value on new accumulativeIssuancePerStakedSynthSnapshot.
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex]
    .accumulativeFloatPerSyntheticToken_long = newLongAccumulativeValue;
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex]
    .accumulativeFloatPerSyntheticToken_short = newShortAccumulativeValue;

    // Set timestamp on new accumulativeIssuancePerStakedSynthSnapshot.
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex].timestamp = block.timestamp;

    // Update latest index to point to new accumulativeIssuancePerStakedSynthSnapshot.
    latestRewardIndex[marketIndex] = newIndex;

    emit AccumulativeIssuancePerStakedSynthSnapshotCreated(
      marketIndex,
      newIndex,
      newLongAccumulativeValue,
      newShortAccumulativeValue
    );
  }

  /**
  @notice Adds new accumulativeIssuancePerStakedSynthSnapshots for the given long/short tokens. Called by the
  ILongShort contract whenever there is a state change for a market.
  @param stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted Mapping from this contract's shifts to LongShort.sols next price snapshots.
  @param shortValue The value locked in the short side of the market.
  @param longValue The value locked in the long side of the market.
  @param shortPrice The price of the short token as defined in LongShort.sol
  @param longPrice The price of the long token as defined in LongShort.sol
  @param marketIndex An identifier for the market.
  */
  function pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(
    uint32 marketIndex,
    uint256 longPrice,
    uint256 shortPrice,
    uint256 longValue,
    uint256 shortValue,
    uint256 stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted // This value should be ALWAYS be zero if no shift occured
  ) external override onlyLongShort {
    // Only add a new accumulativeIssuancePerStakedSynthSnapshot if some time has passed.

    // the `stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted` value will be 0 if there is no staker related action in an executed batch
    if (stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted > 0) {
      stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[
        batched_stakerNextTokenShiftIndex[marketIndex]
      ] = stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted;
      stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[
        batched_stakerNextTokenShiftIndex[marketIndex]
      ] = latestRewardIndex[marketIndex] + 1;
      batched_stakerNextTokenShiftIndex[marketIndex] += 1;

      emit SyntheticTokensShifted();
    }

    // Time delta is fetched twice in below code, can pass through? Which is less gas?
    if (_calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(marketIndex) > 0) {
      _setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot(
        marketIndex,
        longPrice,
        shortPrice,
        longValue,
        shortValue
      );
    }
  }

  /*╔═══════════════════════════════════╗
    ║    USER REWARD STATE FUNCTIONS    ║
    ╚═══════════════════════════════════╝*/

  /// @dev Calculates the accumulated float in a specific range of staker snapshots
  function _calculateAccumulatedFloatInRange(
    uint32 marketIndex,
    uint256 amountStakedLong,
    uint256 amountStakedShort,
    uint256 rewardIndexFrom,
    uint256 rewardIndexTo
  ) internal view virtual returns (uint256 floatReward) {
    if (amountStakedLong > 0) {
      uint256 accumDeltaLong = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexTo]
      .accumulativeFloatPerSyntheticToken_long -
        accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexFrom]
        .accumulativeFloatPerSyntheticToken_long;
      floatReward += (accumDeltaLong * amountStakedLong) / FLOAT_ISSUANCE_FIXED_DECIMAL;
    }

    if (amountStakedShort > 0) {
      uint256 accumDeltaShort = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexTo]
      .accumulativeFloatPerSyntheticToken_short -
        accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexFrom]
        .accumulativeFloatPerSyntheticToken_short;
      floatReward += (accumDeltaShort * amountStakedShort) / FLOAT_ISSUANCE_FIXED_DECIMAL;
    }
  }

  /** 
  @notice Calculates float owed to the user since the user last minted float for a market.
  @param marketIndex Identifier for the market which the user staked in.
  @param user The address of the user.
  @return floatReward The amount of float owed.
   */
  function _calculateAccumulatedFloat(uint32 marketIndex, address user) internal virtual returns (uint256 floatReward) {
    address longToken = syntheticTokens[marketIndex][true];
    address shortToken = syntheticTokens[marketIndex][false];

    uint256 amountStakedLong = userAmountStaked[longToken][user];
    uint256 amountStakedShort = userAmountStaked[shortToken][user];

    uint256 usersLastRewardIndex = userIndexOfLastClaimedReward[marketIndex][user];

    // Don't do the calculation and return zero immediately if there is no change
    if (usersLastRewardIndex == latestRewardIndex[marketIndex]) {
      return 0;
    }

    uint256 usersShiftIndex = userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][user];
    // if there is a change in the users tokens held due to a token shift (or possibly another action in the future)
    if (usersShiftIndex > 0 && usersShiftIndex < batched_stakerNextTokenShiftIndex[marketIndex]) {
      floatReward = _calculateAccumulatedFloatInRange(
        marketIndex,
        amountStakedLong,
        amountStakedShort,
        usersLastRewardIndex,
        stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[usersShiftIndex]
      );

      // Update the users balances
      if (userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user] > 0) {
        amountStakedShort += ILongShort(longShort).getAmountSyntheticTokenToMintOnTargetSide(
          marketIndex,
          userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user],
          true,
          stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[usersShiftIndex]
        );

        amountStakedLong -= userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user];
        userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user] = 0;
      }

      if (userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user] > 0) {
        amountStakedLong += ILongShort(longShort).getAmountSyntheticTokenToMintOnTargetSide(
          marketIndex,
          userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user],
          false,
          stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[usersShiftIndex]
        );

        amountStakedShort -= userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user];
        userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user] = 0;
      }

      // Save the users updated staked amounts
      userAmountStaked[longToken][user] = amountStakedLong;
      userAmountStaked[shortToken][user] = amountStakedShort;

      floatReward += _calculateAccumulatedFloatInRange(
        marketIndex,
        amountStakedLong,
        amountStakedShort,
        stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[usersShiftIndex],
        latestRewardIndex[marketIndex]
      );

      userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][user] = 0;
    } else {
      floatReward = _calculateAccumulatedFloatInRange(
        marketIndex,
        amountStakedLong,
        amountStakedShort,
        usersLastRewardIndex,
        latestRewardIndex[marketIndex]
      );
    }
  }

  /**
  @notice Mints float for a user.
  @dev Mints a fixed percentage for Float capital.
  @param user The address of the user.
  @param floatToMint The amount of float to mint.
   */
  function _mintFloat(address user, uint256 floatToMint) internal virtual {
    IFloatToken(floatToken).mint(user, floatToMint);
    IFloatToken(floatToken).mint(floatCapital, (floatToMint * floatPercentage) / 1e18);
  }

  /**
  @notice Mints float owed to a user for a market since they last minted.
  @param marketIndex An identifier for the market.
  @param user The address of the user.
   */
  function _mintAccumulatedFloat(uint32 marketIndex, address user) internal virtual {
    uint256 floatToMint = _calculateAccumulatedFloat(marketIndex, user);

    if (floatToMint > 0) {
      // Set the user has claimed up until now, stops them setting this forward
      userIndexOfLastClaimedReward[marketIndex][user] = latestRewardIndex[marketIndex];

      _mintFloat(user, floatToMint);
      emit FloatMinted(user, marketIndex, floatToMint);
    }
  }

  /**
  @notice Mints float owed to a user for multiple markets, since they last minted for those markets.
  @param marketIndexes Identifiers for the markets.
  @param user The address of the user.
   */
  function _mintAccumulatedFloatMulti(uint32[] calldata marketIndexes, address user) internal virtual {
    uint256 floatTotal = 0;
    for (uint256 i = 0; i < marketIndexes.length; i++) {
      uint256 floatToMint = _calculateAccumulatedFloat(marketIndexes[i], user);

      if (floatToMint > 0) {
        // Set the user has claimed up until now, stops them setting this forward
        userIndexOfLastClaimedReward[marketIndexes[i]][user] = latestRewardIndex[marketIndexes[i]];

        floatTotal += floatToMint;

        emit FloatMinted(user, marketIndexes[i], floatToMint);
      }
    }
    if (floatTotal > 0) {
      _mintFloat(user, floatTotal);
    }
  }

  /**
  @notice Mints outstanding float for msg.sender.
  @param marketIndexes Identifiers for the markets for which to mint float.
   */
  function claimFloatCustom(uint32[] calldata marketIndexes) external {
    ILongShort(longShort).updateSystemStateMulti(marketIndexes);
    _mintAccumulatedFloatMulti(marketIndexes, msg.sender);
  }

  /**
  @notice Mints outstanding float on behalf of another user.
  @param marketIndexes Identifiers for the markets for which to mint float.
  @param user The address of the user.
   */
  function claimFloatCustomFor(uint32[] calldata marketIndexes, address user) external {
    // Unbounded loop - users are responsible for paying their own gas costs on these and it doesn't effect the rest of the system.
    // No need to impose limit.
    ILongShort(longShort).updateSystemStateMulti(marketIndexes);
    _mintAccumulatedFloatMulti(marketIndexes, user);
  }

  /*╔═══════════════════════╗
    ║        STAKING        ║
    ╚═══════════════════════╝*/

  /**
  @notice A user with synthetic tokens stakes by calling stake on the token
  contract which calls this function. We need to first update the
  state of the LongShort contract for this market before staking to correctly calculate user rewards.
  @param amount Amount to stake.
  @param from Address to stake for.
  */
  function stakeFromUser(address from, uint256 amount) public virtual override onlyValidSynthetic((msg.sender)) {
    ILongShort(longShort).updateSystemState(marketIndexOfToken[(msg.sender)]);
    _stake((msg.sender), amount, from);
  }

  /**
  @dev Internal logic for staking.
  @param token Address of the token for which to stake.
  @param amount Amount to stake.
  @param user Address to stake for.
  */
  function _stake(
    address token,
    uint256 amount,
    address user
  ) internal virtual {
    uint32 marketIndex = marketIndexOfToken[token];

    // If they already have staked and have rewards due, mint these.
    if (
      userIndexOfLastClaimedReward[marketIndex][user] != 0 &&
      userIndexOfLastClaimedReward[marketIndex][user] < latestRewardIndex[marketIndex]
    ) {
      _mintAccumulatedFloat(marketIndex, user);
    }

    userAmountStaked[token][user] = userAmountStaked[token][user] + amount;

    userIndexOfLastClaimedReward[marketIndex][user] = latestRewardIndex[marketIndex];

    emit StakeAdded(user, address(token), amount, userIndexOfLastClaimedReward[marketIndex][user]);
  }

  /**
  @notice Allows users to shift their staked tokens from one side of the market to 
  the other at the next price.
  @param amountSyntheticTokensToShift Amount of tokens to shift.
  @param marketIndex Identifier for the market.
  @param isShiftFromLong Whether the shift is from long to short or short to long.
  */
  function shiftTokens(
    uint256 amountSyntheticTokensToShift,
    uint32 marketIndex,
    bool isShiftFromLong
  ) external virtual {
    address token = syntheticTokens[marketIndex][isShiftFromLong];
    require(userAmountStaked[token][msg.sender] >= amountSyntheticTokensToShift, "Not enough tokens to shift");

    // If the user has outstanding token shift that have already been confirmed in the LongShort
    // contract, execute them first.
    if (
      userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] != 0 &&
      userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] <
      batched_stakerNextTokenShiftIndex[marketIndex]
    ) {
      _mintAccumulatedFloat(marketIndex, msg.sender);
    }

    if (isShiftFromLong) {
      ILongShort(longShort).shiftPositionFromLongNextPrice(marketIndex, amountSyntheticTokensToShift);
      userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][
        msg.sender
      ] += amountSyntheticTokensToShift;
    } else {
      ILongShort(longShort).shiftPositionFromShortNextPrice(marketIndex, amountSyntheticTokensToShift);
      userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][
        msg.sender
      ] += amountSyntheticTokensToShift;
    }

    userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] = batched_stakerNextTokenShiftIndex[
      marketIndex
    ];
  }

  /*╔════════════════════════════╗
    ║    WITHDRAWAL & MINTING    ║
    ╚════════════════════════════╝*/

  /**
  @notice Internal logic for withdrawing stakes.
  @dev Mint user any outstanding float before withdrawing.
  @param marketIndex Market index of token.
  @param amount Amount to withdraw.
  @param token Synthetic token that was staked.
  */
  function _withdraw(
    uint32 marketIndex,
    address token,
    uint256 amount
  ) internal virtual {
    require(userAmountStaked[token][msg.sender] > 0, "nothing to withdraw");
    _mintAccumulatedFloat(marketIndex, msg.sender);

    userAmountStaked[token][msg.sender] = userAmountStaked[token][msg.sender] - amount;

    uint256 amountFees = (amount * marketUnstakeFee_e18[marketIndex]) / 1e18;

    IERC20(token).transfer(floatTreasury, amountFees);
    IERC20(token).transfer(msg.sender, amount - amountFees);

    emit StakeWithdrawn(msg.sender, token, amount);
  }

  /**
  @notice Withdraw function. Allows users to unstake.
  @param amount Amount to withdraw.
  @param token Address of the token for which to withdraw.
  */
  function withdraw(address token, uint256 amount) external {
    ILongShort(longShort).updateSystemState(marketIndexOfToken[token]);

    uint32 marketIndex = marketIndexOfToken[token];

    _withdraw(marketIndex, token, amount);

    if (userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] > 0) {
      // If they still have outstanding shifts after minting float, then check
      // that they don't withdraw more than their shifts allow.
      uint256 amountToShiftForThisToken = syntheticTokens[marketIndex][true] == token
        ? userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][msg.sender]
        : userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][msg.sender];

      require(
        userAmountStaked[token][msg.sender] >= amountToShiftForThisToken,
        "Outstanding next price stake shifts too great"
      );
    }
  }

  /**
  @notice Allows users to withdraw their entire stake for a token.
  @param token Address of the token for which to withdraw.
  */
  function withdrawAll(address token) external {
    ILongShort(longShort).updateSystemState(marketIndexOfToken[token]);

    uint32 marketIndex = marketIndexOfToken[token];

    uint256 amountToShiftForThisToken = syntheticTokens[marketIndex][true] == token
      ? userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][msg.sender]
      : userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][msg.sender];

    _withdraw(marketIndex, token, userAmountStaked[token][msg.sender] - amountToShiftForThisToken);
  }
}
.]

Here is a conversation between two roles: Security Analyst: We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.3;
import "@openzeppelin/contracts-upgradeable/token/ERC20/presets/ERC20PresetMinterPauserUpgradeable.sol";
import "./interfaces/IFloatToken.sol";
import "./interfaces/ILongShort.sol";
import "./interfaces/IStaker.sol";
import "./interfaces/ISyntheticToken.sol";
contract Staker is IStaker, Initializable {
  /*╔═════════════════════════════╗
    ║          VARIABLES          ║
    ╚═════════════════════════════╝*/
  /* ══════ Fixed-precision constants ══════ */
  uint256 public constant FLOAT_ISSUANCE_FIXED_DECIMAL = 1e42;
  // 2^52 ~= 4.5e15
  // With an exponent of 5, the largest total liquidity possible in a market (to avoid integer overflow on exponentiation) is ~10^31 or 10 Trillion (10^13)
  // NOTE: this also means if the total market value is less than 2^52 there will be a division by zero error
  uint256 public constant safeExponentBitShifting = 52;
  /* ══════ Global state ══════ */
  address public admin;
  address public floatCapital;
  address public floatTreasury;
  uint256 public floatPercentage;
  address public longShort;
  address public floatToken;
  /* ══════ Market specific ══════ */
  mapping(uint32 => uint256) public marketLaunchIncentive_period; // seconds
  mapping(uint32 => uint256) public marketLaunchIncentive_multipliers; // e18 scale
  mapping(uint32 => uint256) public marketUnstakeFee_e18;
  mapping(uint32 => uint256) public balanceIncentiveCurve_exponent;
  mapping(uint32 => int256) public balanceIncentiveCurve_equilibriumOffset;
  mapping(uint32 => mapping(bool => address)) public syntheticTokens;
  mapping(address => uint32) public marketIndexOfToken;
  /* ══════ Reward specific ══════ */
  mapping(uint32 => uint256) public latestRewardIndex;
  mapping(uint32 => mapping(uint256 => AccumulativeIssuancePerStakedSynthSnapshot))
    public accumulativeFloatPerSyntheticTokenSnapshots;
  struct AccumulativeIssuancePerStakedSynthSnapshot {
    uint256 timestamp;
    uint256 accumulativeFloatPerSyntheticToken_long;
    uint256 accumulativeFloatPerSyntheticToken_short;
  }
  /* ══════ User specific ══════ */
  mapping(uint32 => mapping(address => uint256)) public userIndexOfLastClaimedReward;
  mapping(address => mapping(address => uint256)) public userAmountStaked;
  /* ══════ Token shift management specific ══════ */
  mapping(uint32 => uint256) public batched_stakerNextTokenShiftIndex;
  /**
  @notice Used to link a token shift to a staker state
  @dev tokenShiftIndex => accumulativeFloatIssuanceSnapshotIndex
    POSSIBLE OPTIMIZATION - could pack stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping and stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping into a struct of two uint128 for storage space optimization.
  */
  mapping(uint256 => uint256) public stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping;
  /// @notice Used to fetch the price from LongShort at that point in time
  /// @dev tokenShiftIndex => longShortMarketPriceSnapshotIndex
  mapping(uint256 => uint256) public stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping;
  /// @dev marketIndex => usersAddress => stakerTokenShiftIndex
  mapping(uint32 => mapping(address => uint256)) public userNextPrice_stakedSyntheticTokenShiftIndex;
  /// @dev marketIndex => usersAddress => amountUserRequestedToShiftAwayFromLongOnNextUpdate
  mapping(uint32 => mapping(address => uint256)) public userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long;
  /// @dev marketIndex => usersAddress => amountUserRequestedToShiftAwayFromShortOnNextUpdate
  mapping(uint32 => mapping(address => uint256)) public userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short;
  /*╔════════════════════════════╗
    ║           EVENTS           ║
    ╚════════════════════════════╝*/
  event StakerV1(
    address admin,
    address floatTreasury,
    address floatCapital,
    address floatToken,
    uint256 floatPercentage
  );
  event MarketAddedToStaker(
    uint32 marketIndex,
    uint256 exitFee_e18,
    uint256 period,
    uint256 multiplier,
    uint256 balanceIncentiveExponent,
    int256 balanceIncentiveEquilibriumOffset
  );
  event AccumulativeIssuancePerStakedSynthSnapshotCreated(
    uint32 marketIndex,
    uint256 accumulativeFloatIssuanceSnapshotIndex,
    uint256 accumulativeLong,
    uint256 accumulativeShort
  );
  event StakeAdded(address user, address token, uint256 amount, uint256 lastMintIndex);
  event StakeWithdrawn(address user, address token, uint256 amount);
  // Note: the `amountFloatMinted` isn't strictly needed by the graph, but it is good to add it to validate calculations are accurate.
  event FloatMinted(address user, uint32 marketIndex, uint256 amountFloatMinted);
  event MarketLaunchIncentiveParametersChanges(uint32 marketIndex, uint256 period, uint256 multiplier);
  event StakeWithdrawalFeeUpdated(uint32 marketIndex, uint256 stakeWithdralFee);
  event BalanceIncentiveExponentUpdated(uint32 marketIndex, uint256 balanceIncentiveExponent);
  event BalanceIncentiveEquilibriumOffsetUpdated(uint32 marketIndex, int256 balanceIncentiveEquilibriumOffset);
  event FloatPercentageUpdated(uint256 floatPercentage);
  event SyntheticTokensShifted();
  event ChangeAdmin(address newAdmin);
  /*╔═════════════════════════════╗
    ║          MODIFIERS          ║
    ╚═════════════════════════════╝*/
  function onlyAdminModifierLogic() internal virtual {
    require(msg.sender == admin, "not admin");
  }
  modifier onlyAdmin() {
    onlyAdminModifierLogic();
    _;
  }
  function onlyValidSyntheticModifierLogic(address _synth) internal virtual {
    require(marketIndexOfToken[_synth] != 0, "not valid synth");
  }
  modifier onlyValidSynthetic(address _synth) {
    onlyValidSyntheticModifierLogic(_synth);
    _;
  }
  function onlyValidMarketModifierLogic(uint32 marketIndex) internal virtual {
    require(address(syntheticTokens[marketIndex][true]) != address(0), "not valid market");
  }
  modifier onlyValidMarket(uint32 marketIndex) {
    onlyValidMarketModifierLogic(marketIndex);
    _;
  }
  function onlyLongShortModifierLogic() internal virtual {
    require(msg.sender == address(longShort), "not long short");
  }
  modifier onlyLongShort() {
    onlyLongShortModifierLogic();
    _;
  }
  /*╔═════════════════════════════╗
    ║       CONTRACT SET-UP       ║
    ╚═════════════════════════════╝*/
  /**
  @notice Initializes the contract.
  @dev Calls OpenZeppelin's initializer modifier.
  @param _admin Address of the admin role.
  @param _longShort Address of the LongShort contract, a deployed LongShort.sol
  @param _floatToken Address of the Float token earned by staking.
  @param _floatTreasury Address of the treasury contract for managing fees.
  @param _floatCapital Address of the contract which earns a fixed percentage of Float.
  @param _floatPercentage Determines the float percentage that gets minted for Float Capital, base 1e18.
  */
  function initialize(
    address _admin,
    address _longShort,
    address _floatToken,
    address _floatTreasury,
    address _floatCapital,
    uint256 _floatPercentage
  ) external virtual initializer {
    admin = _admin;
    floatCapital = _floatCapital;
    floatTreasury = _floatTreasury;
    longShort = _longShort;
    floatToken = _floatToken;
    _changeFloatPercentage(_floatPercentage);
    emit StakerV1(_admin, _floatTreasury, _floatCapital, _floatToken, _floatPercentage);
  }
  /*╔═══════════════════╗
    ║       ADMIN       ║
    ╚═══════════════════╝*/
  /** 
  @notice Changes admin for the contract
  @param _admin The address of the new admin.
  */
  function changeAdmin(address _admin) external onlyAdmin {
    admin = _admin;
    emit ChangeAdmin(_admin);
  }
  /// @dev Logic for changeFloatPercentage
  function _changeFloatPercentage(uint256 newFloatPercentage) internal virtual {
    require(newFloatPercentage <= 1e18 && newFloatPercentage > 0); // less than or equal to 100% and greater than 0%
    floatPercentage = newFloatPercentage;
  }
  /**
  @notice Changes percentage of float that is minted for float capital.
  @param newFloatPercentage The new float percentage in base 1e18.
  */
  function changeFloatPercentage(uint256 newFloatPercentage) external onlyAdmin {
    _changeFloatPercentage(newFloatPercentage);
    emit FloatPercentageUpdated(newFloatPercentage);
  }
  /// @dev Logic for changeUnstakeFee
  function _changeUnstakeFee(uint32 marketIndex, uint256 newMarketUnstakeFee_e18) internal virtual {
    require(newMarketUnstakeFee_e18 <= 5e16); // Explicitely stating 5% fee as the max fee possible.
    marketUnstakeFee_e18[marketIndex] = newMarketUnstakeFee_e18;
  }
  /**
  @notice Changes unstake fee for a market
  @param marketIndex Identifies the market.
  @param newMarketUnstakeFee_e18 The new unstake fee.
  */
  function changeUnstakeFee(uint32 marketIndex, uint256 newMarketUnstakeFee_e18) external onlyAdmin {
    _changeUnstakeFee(marketIndex, newMarketUnstakeFee_e18);
    emit StakeWithdrawalFeeUpdated(marketIndex, newMarketUnstakeFee_e18);
  }
  /// @dev Logic for changeMarketLaunchIncentiveParameters
  function _changeMarketLaunchIncentiveParameters(
    uint32 marketIndex,
    uint256 period,
    uint256 initialMultiplier
  ) internal virtual {
    require(initialMultiplier >= 1e18, "marketLaunchIncentiveMultiplier must be >= 1e18");
    marketLaunchIncentive_period[marketIndex] = period;
    marketLaunchIncentive_multipliers[marketIndex] = initialMultiplier;
  }
  /**
  @notice Changes the market launch incentive parameters for a market
  @param marketIndex Identifies the market.
  @param period The new period for which float token generation should be boosted.
  @param initialMultiplier The new multiplier on Float generation.
  */
  function changeMarketLaunchIncentiveParameters(
    uint32 marketIndex,
    uint256 period,
    uint256 initialMultiplier
  ) external onlyAdmin {
    _changeMarketLaunchIncentiveParameters(marketIndex, period, initialMultiplier);
    emit MarketLaunchIncentiveParametersChanges(marketIndex, period, initialMultiplier);
  }
  /// @dev Logic for changeBalanceIncentiveExponent
  function _changeBalanceIncentiveExponent(uint32 marketIndex, uint256 _balanceIncentiveCurve_exponent)
    internal
    virtual
  {
    require(
      // The exponent has to be less than 5 in these versions of the contracts.
      _balanceIncentiveCurve_exponent > 0 && _balanceIncentiveCurve_exponent < 6,
      "balanceIncentiveCurve_exponent out of bounds"
    );
    balanceIncentiveCurve_exponent[marketIndex] = _balanceIncentiveCurve_exponent;
  }
  /** 
  @notice Changes the balance incentive exponent for a market
  @param marketIndex Identifies the market.
  @param _balanceIncentiveCurve_exponent The new exponent for the curve.
  */
  function changeBalanceIncentiveExponent(uint32 marketIndex, uint256 _balanceIncentiveCurve_exponent)
    external
    onlyAdmin
  {
    _changeBalanceIncentiveExponent(marketIndex, _balanceIncentiveCurve_exponent);
    emit BalanceIncentiveExponentUpdated(marketIndex, _balanceIncentiveCurve_exponent);
  }
  /// @dev Logic for changeBalanceIncentiveEquilibriumOffset
  function _changeBalanceIncentiveEquilibriumOffset(uint32 marketIndex, int256 _balanceIncentiveCurve_equilibriumOffset)
    internal
    virtual
  {
    // Unreasonable that we would ever shift this more than 90% either way
    require(
      _balanceIncentiveCurve_equilibriumOffset > -9e17 && _balanceIncentiveCurve_equilibriumOffset < 9e17,
      "balanceIncentiveCurve_equilibriumOffset out of bounds"
    );
    balanceIncentiveCurve_equilibriumOffset[marketIndex] = _balanceIncentiveCurve_equilibriumOffset;
  }
  /**
  @notice Changes the balance incentive curve equilibrium offset for a market
  @param marketIndex Identifies the market.
  @param _balanceIncentiveCurve_equilibriumOffset The new offset.
  */
  function changeBalanceIncentiveEquilibriumOffset(uint32 marketIndex, int256 _balanceIncentiveCurve_equilibriumOffset)
    external
    onlyAdmin
  {
    _changeBalanceIncentiveEquilibriumOffset(marketIndex, _balanceIncentiveCurve_equilibriumOffset);
    emit BalanceIncentiveEquilibriumOffsetUpdated(marketIndex, _balanceIncentiveCurve_equilibriumOffset);
  }
  /*╔═════════════════════════════╗
    ║        STAKING SETUP        ║
    ╚═════════════════════════════╝*/
  /**
  @notice Sets this contract to track staking for a market in LongShort.sol
  @param marketIndex Identifies the market.
  @param longToken Address of the long token for the market.
  @param shortToken Address of the short token for the market.
  @param kInitialMultiplier Initial boost on float generation for the market.
  @param kPeriod Period which the boost should last.
  @param unstakeFee_e18 Percentage of tokens that are levied on unstaking in base 1e18.
  @param _balanceIncentiveCurve_exponent Exponent for balance curve (see _calculateFloatPerSecond)
  @param _balanceIncentiveCurve_equilibriumOffset Offset for balance curve (see _calculateFloatPerSecond)
  */
  function addNewStakingFund(
    uint32 marketIndex,
    address longToken,
    address shortToken,
    uint256 kInitialMultiplier,
    uint256 kPeriod,
    uint256 unstakeFee_e18,
    uint256 _balanceIncentiveCurve_exponent,
    int256 _balanceIncentiveCurve_equilibriumOffset
  ) external override onlyLongShort {
    marketIndexOfToken[longToken] = marketIndex;
    marketIndexOfToken[shortToken] = marketIndex;
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].timestamp = block.timestamp;
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].accumulativeFloatPerSyntheticToken_long = 0;
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].accumulativeFloatPerSyntheticToken_short = 0;
    syntheticTokens[marketIndex][true] = longToken;
    syntheticTokens[marketIndex][false] = shortToken;
    _changeBalanceIncentiveExponent(marketIndex, _balanceIncentiveCurve_exponent);
    _changeBalanceIncentiveEquilibriumOffset(marketIndex, _balanceIncentiveCurve_equilibriumOffset);
    _changeMarketLaunchIncentiveParameters(marketIndex, kPeriod, kInitialMultiplier);
    _changeUnstakeFee(marketIndex, unstakeFee_e18);
    // Set this value to one initially - 0 is a null value and thus potentially bug prone.
    batched_stakerNextTokenShiftIndex[marketIndex] = 1;
    emit MarketAddedToStaker(
      marketIndex,
      unstakeFee_e18,
      kPeriod,
      kInitialMultiplier,
      _balanceIncentiveCurve_exponent,
      _balanceIncentiveCurve_equilibriumOffset
    );
    emit AccumulativeIssuancePerStakedSynthSnapshotCreated(marketIndex, 0, 0, 0);
  }
  /*╔═════════════════════════════════════════════════════════════════════════╗
    ║    GLOBAL FLT REWARD ACCUMULATION CALCULATION AND TRACKING FUNCTIONS    ║
    ╚═════════════════════════════════════════════════════════════════════════╝*/
  /**
  @notice Returns the K factor parameters for the given market with sensible
  defaults if they haven't been set yet.
  @param marketIndex The market to change the parameters for.
  @return period The period for which the k factor applies for in seconds.
  @return multiplier The multiplier on Float generation in this period.
  */
  function _getMarketLaunchIncentiveParameters(uint32 marketIndex)
    internal
    view
    virtual
    returns (uint256 period, uint256 multiplier)
  {
    period = marketLaunchIncentive_period[marketIndex];
    multiplier = marketLaunchIncentive_multipliers[marketIndex];
    if (multiplier < 1e18) {
      multiplier = 1e18; // multiplier of 1 by default
    }
  }
  /** 
  @notice Returns the extent to which a markets float generation should be adjusted
  based on the market's launch incentive parameters. Should start at multiplier
  then linearly change to 1e18 over time.
  @param marketIndex Identifies the market.
  @return k The calculated modifier for float generation.
  */
  function _getKValue(uint32 marketIndex) internal view virtual returns (uint256) {
    // Parameters controlling the float issuance multiplier.
    (uint256 kPeriod, uint256 kInitialMultiplier) = _getMarketLaunchIncentiveParameters(marketIndex);
    // Sanity check - under normal circumstances, the multipliers should
    // *never* be set to a value < 1e18, as there are guards against this.
    assert(kInitialMultiplier >= 1e18);
    uint256 initialTimestamp = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].timestamp;
    if (block.timestamp - initialTimestamp <= kPeriod) {
      return kInitialMultiplier - (((kInitialMultiplier - 1e18) * (block.timestamp - initialTimestamp)) / kPeriod);
    } else {
      return 1e18;
    }
  }
  /*
  @notice Computes the number of float tokens a user earns per second for
  every long/short synthetic token they've staked. The returned value has
  a fixed decimal scale of 1e42 (!!!) for numerical stability. The return
  values are float per second per synthetic token (hence the requirement
  to multiply by price)
  @dev to see below math in latex form see TODO add link
  to interact with the equations see https://www.desmos.com/calculator/optkaxyihr
  @param marketIndex The market referred to.
  @param longPrice Price of the synthetic long token in units of payment token
  @param shortPrice Price of the synthetic short token in units of payment token
  @param longValue Amount of payment token in the long side of the market
  @param shortValue Amount of payment token in the short side of the market
  @return longFloatPerSecond Float token per second per long synthetic token
  @return shortFloatPerSecond Float token per second per short synthetic token
   */
  function _calculateFloatPerSecond(
    uint32 marketIndex,
    uint256 longPrice,
    uint256 shortPrice,
    uint256 longValue,
    uint256 shortValue
  ) internal view virtual returns (uint256 longFloatPerSecond, uint256 shortFloatPerSecond) {
    // A float issuance multiplier that starts high and decreases linearly
    // over time to a value of 1. This incentivises users to stake early.
    uint256 k = _getKValue(marketIndex);
    uint256 totalLocked = (longValue + shortValue);
    // we need to scale this number by the totalLocked so that the offset remains consistent accross market size
    int256 equilibriumOffsetMarketScaled = (balanceIncentiveCurve_equilibriumOffset[marketIndex] *
      int256(totalLocked)) / 2e18;
    uint256 denominator = ((totalLocked >> safeExponentBitShifting)**balanceIncentiveCurve_exponent[marketIndex]);
    // Float is scaled by the percentage of the total market value held in
    // the opposite position. This incentivises users to stake on the
    // weaker position.
    if (int256(shortValue) - equilibriumOffsetMarketScaled < int256(longValue)) {
      if (equilibriumOffsetMarketScaled >= int256(shortValue)) {
        // edge case: imbalanced far past the equilibrium offset - full rewards go to short token
        //            extremeley unlikely to happen in practice
        return (0, 1e18 * k * shortPrice);
      }
      uint256 numerator = (uint256(int256(shortValue) - equilibriumOffsetMarketScaled) >>
        (safeExponentBitShifting - 1))**balanceIncentiveCurve_exponent[marketIndex];
      // NOTE: `x * 5e17` == `(x * 10e18) / 2`
      uint256 longRewardUnscaled = (numerator * 5e17) / denominator;
      uint256 shortRewardUnscaled = 1e18 - longRewardUnscaled;
      return ((longRewardUnscaled * k * longPrice) / 1e18, (shortRewardUnscaled * k * shortPrice) / 1e18);
    } else {
      if (-equilibriumOffsetMarketScaled >= int256(longValue)) {
        // edge case: imbalanced far past the equilibrium offset - full rewards go to long token
        //            extremeley unlikely to happen in practice
        return (1e18 * k * longPrice, 0);
      }
      uint256 numerator = (uint256(int256(longValue) + equilibriumOffsetMarketScaled) >>
        (safeExponentBitShifting - 1))**balanceIncentiveCurve_exponent[marketIndex];
      // NOTE: `x * 5e17` == `(x * 10e18) / 2`
      uint256 shortRewardUnscaled = (numerator * 5e17) / denominator;
      uint256 longRewardUnscaled = 1e18 - shortRewardUnscaled;
      return ((longRewardUnscaled * k * longPrice) / 1e18, (shortRewardUnscaled * k * shortPrice) / 1e18);
    }
  }
  /**
  @notice Computes the time since last accumulativeIssuancePerStakedSynthSnapshot for the given market in seconds.
  @param marketIndex The market referred to.
  @return The time difference in seconds
  */
  function _calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(uint32 marketIndex)
    internal
    view
    virtual
    returns (uint256)
  {
    return
      block.timestamp -
      accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]].timestamp;
  }
  /**
  @notice Computes new cumulative sum of 'r' value since last accumulativeIssuancePerStakedSynthSnapshot. We use
  cumulative 'r' value to avoid looping during issuance. Note that the
  cumulative sum is kept in 1e42 scale (!!!) to avoid numerical issues.
  @param shortValue The value locked in the short side of the market.
  @param longValue The value locked in the long side of the market.
  @param shortPrice The price of the short token as defined in LongShort.sol
  @param longPrice The price of the long token as defined in LongShort.sol
  @param marketIndex An identifier for the market.
  @return longCumulativeRates The long cumulative sum.
  @return shortCumulativeRates The short cumulative sum.
  */
  function _calculateNewCumulativeIssuancePerStakedSynth(
    uint32 marketIndex,
    uint256 longPrice,
    uint256 shortPrice,
    uint256 longValue,
    uint256 shortValue
  ) internal view virtual returns (uint256 longCumulativeRates, uint256 shortCumulativeRates) {
    // Compute the current 'r' value for float issuance per second.
    (uint256 longFloatPerSecond, uint256 shortFloatPerSecond) = _calculateFloatPerSecond(
      marketIndex,
      longPrice,
      shortPrice,
      longValue,
      shortValue
    );
    // Compute time since last accumulativeIssuancePerStakedSynthSnapshot for the given token.
    uint256 timeDelta = _calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(marketIndex);
    // Compute new cumulative 'r' value total.
    return (
      accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]]
      .accumulativeFloatPerSyntheticToken_long + (timeDelta * longFloatPerSecond),
      accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]]
      .accumulativeFloatPerSyntheticToken_short + (timeDelta * shortFloatPerSecond)
    );
  }
  /**
  @notice Creates a new accumulativeIssuancePerStakedSynthSnapshot for the given token and updates indexes.
  @param shortValue The value locked in the short side of the market.
  @param longValue The value locked in the long side of the market.
  @param shortPrice The price of the short token as defined in LongShort.sol
  @param longPrice The price of the long token as defined in LongShort.sol
  @param marketIndex An identifier for the market.
  */
  function _setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot(
    uint32 marketIndex,
    uint256 longPrice,
    uint256 shortPrice,
    uint256 longValue,
    uint256 shortValue
  ) internal virtual {
    (
      uint256 newLongAccumulativeValue,
      uint256 newShortAccumulativeValue
    ) = _calculateNewCumulativeIssuancePerStakedSynth(marketIndex, longPrice, shortPrice, longValue, shortValue);
    uint256 newIndex = latestRewardIndex[marketIndex] + 1;
    // Set cumulative 'r' value on new accumulativeIssuancePerStakedSynthSnapshot.
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex]
    .accumulativeFloatPerSyntheticToken_long = newLongAccumulativeValue;
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex]
    .accumulativeFloatPerSyntheticToken_short = newShortAccumulativeValue;
    // Set timestamp on new accumulativeIssuancePerStakedSynthSnapshot.
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex].timestamp = block.timestamp;
    // Update latest index to point to new accumulativeIssuancePerStakedSynthSnapshot.
    latestRewardIndex[marketIndex] = newIndex;
    emit AccumulativeIssuancePerStakedSynthSnapshotCreated(
      marketIndex,
      newIndex,
      newLongAccumulativeValue,
      newShortAccumulativeValue
    );
  }
  /**
  @notice Adds new accumulativeIssuancePerStakedSynthSnapshots for the given long/short tokens. Called by the
  ILongShort contract whenever there is a state change for a market.
  @param stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted Mapping from this contract's shifts to LongShort.sols next price snapshots.
  @param shortValue The value locked in the short side of the market.
  @param longValue The value locked in the long side of the market.
  @param shortPrice The price of the short token as defined in LongShort.sol
  @param longPrice The price of the long token as defined in LongShort.sol
  @param marketIndex An identifier for the market.
  */
  function pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(
    uint32 marketIndex,
    uint256 longPrice,
    uint256 shortPrice,
    uint256 longValue,
    uint256 shortValue,
    uint256 stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted // This value should be ALWAYS be zero if no shift occured
  ) external override onlyLongShort {
    // Only add a new accumulativeIssuancePerStakedSynthSnapshot if some time has passed.
    // the `stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted` value will be 0 if there is no staker related action in an executed batch
    if (stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted > 0) {
      stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[
        batched_stakerNextTokenShiftIndex[marketIndex]
      ] = stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted;
      stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[
        batched_stakerNextTokenShiftIndex[marketIndex]
      ] = latestRewardIndex[marketIndex] + 1;
      batched_stakerNextTokenShiftIndex[marketIndex] += 1;
      emit SyntheticTokensShifted();
    }
    // Time delta is fetched twice in below code, can pass through? Which is less gas?
    if (_calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(marketIndex) > 0) {
      _setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot(
        marketIndex,
        longPrice,
        shortPrice,
        longValue,
        shortValue
      );
    }
  }
  /*╔═══════════════════════════════════╗
    ║    USER REWARD STATE FUNCTIONS    ║
    ╚═══════════════════════════════════╝*/
  /// @dev Calculates the accumulated float in a specific range of staker snapshots
  function _calculateAccumulatedFloatInRange(
    uint32 marketIndex,
    uint256 amountStakedLong,
    uint256 amountStakedShort,
    uint256 rewardIndexFrom,
    uint256 rewardIndexTo
  ) internal view virtual returns (uint256 floatReward) {
    if (amountStakedLong > 0) {
      uint256 accumDeltaLong = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexTo]
      .accumulativeFloatPerSyntheticToken_long -
        accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexFrom]
        .accumulativeFloatPerSyntheticToken_long;
      floatReward += (accumDeltaLong * amountStakedLong) / FLOAT_ISSUANCE_FIXED_DECIMAL;
    }
    if (amountStakedShort > 0) {
      uint256 accumDeltaShort = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexTo]
      .accumulativeFloatPerSyntheticToken_short -
        accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexFrom]
        .accumulativeFloatPerSyntheticToken_short;
      floatReward += (accumDeltaShort * amountStakedShort) / FLOAT_ISSUANCE_FIXED_DECIMAL;
    }
  }
  /** 
  @notice Calculates float owed to the user since the user last minted float for a market.
  @param marketIndex Identifier for the market which the user staked in.
  @param user The address of the user.
  @return floatReward The amount of float owed.
   */
  function _calculateAccumulatedFloat(uint32 marketIndex, address user) internal virtual returns (uint256 floatReward) {
    address longToken = syntheticTokens[marketIndex][true];
    address shortToken = syntheticTokens[marketIndex][false];
    uint256 amountStakedLong = userAmountStaked[longToken][user];
    uint256 amountStakedShort = userAmountStaked[shortToken][user];
    uint256 usersLastRewardIndex = userIndexOfLastClaimedReward[marketIndex][user];
    // Don't do the calculation and return zero immediately if there is no change
    if (usersLastRewardIndex == latestRewardIndex[marketIndex]) {
      return 0;
    }
    uint256 usersShiftIndex = userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][user];
    // if there is a change in the users tokens held due to a token shift (or possibly another action in the future)
    if (usersShiftIndex > 0 && usersShiftIndex < batched_stakerNextTokenShiftIndex[marketIndex]) {
      floatReward = _calculateAccumulatedFloatInRange(
        marketIndex,
        amountStakedLong,
        amountStakedShort,
        usersLastRewardIndex,
        stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[usersShiftIndex]
      );
      // Update the users balances
      if (userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user] > 0) {
        amountStakedShort += ILongShort(longShort).getAmountSyntheticTokenToMintOnTargetSide(
          marketIndex,
          userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user],
          true,
          stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[usersShiftIndex]
        );
        amountStakedLong -= userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user];
        userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user] = 0;
      }
      if (userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user] > 0) {
        amountStakedLong += ILongShort(longShort).getAmountSyntheticTokenToMintOnTargetSide(
          marketIndex,
          userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user],
          false,
          stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[usersShiftIndex]
        );
        amountStakedShort -= userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user];
        userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user] = 0;
      }
      // Save the users updated staked amounts
      userAmountStaked[longToken][user] = amountStakedLong;
      userAmountStaked[shortToken][user] = amountStakedShort;
      floatReward += _calculateAccumulatedFloatInRange(
        marketIndex,
        amountStakedLong,
        amountStakedShort,
        stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[usersShiftIndex],
        latestRewardIndex[marketIndex]
      );
      userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][user] = 0;
    } else {
      floatReward = _calculateAccumulatedFloatInRange(
        marketIndex,
        amountStakedLong,
        amountStakedShort,
        usersLastRewardIndex,
        latestRewardIndex[marketIndex]
      );
    }
  }
  /**
  @notice Mints float for a user.
  @dev Mints a fixed percentage for Float capital.
  @param user The address of the user.
  @param floatToMint The amount of float to mint.
   */
  function _mintFloat(address user, uint256 floatToMint) internal virtual {
    IFloatToken(floatToken).mint(user, floatToMint);
    IFloatToken(floatToken).mint(floatCapital, (floatToMint * floatPercentage) / 1e18);
  }
  /**
  @notice Mints float owed to a user for a market since they last minted.
  @param marketIndex An identifier for the market.
  @param user The address of the user.
   */
  function _mintAccumulatedFloat(uint32 marketIndex, address user) internal virtual {
    uint256 floatToMint = _calculateAccumulatedFloat(marketIndex, user);
    if (floatToMint > 0) {
      // Set the user has claimed up until now, stops them setting this forward
      userIndexOfLastClaimedReward[marketIndex][user] = latestRewardIndex[marketIndex];
      _mintFloat(user, floatToMint);
      emit FloatMinted(user, marketIndex, floatToMint);
    }
  }
  /**
  @notice Mints float owed to a user for multiple markets, since they last minted for those markets.
  @param marketIndexes Identifiers for the markets.
  @param user The address of the user.
   */
  function _mintAccumulatedFloatMulti(uint32[] calldata marketIndexes, address user) internal virtual {
    uint256 floatTotal = 0;
    for (uint256 i = 0; i < marketIndexes.length; i++) {
      uint256 floatToMint = _calculateAccumulatedFloat(marketIndexes[i], user);
      if (floatToMint > 0) {
        // Set the user has claimed up until now, stops them setting this forward
        userIndexOfLastClaimedReward[marketIndexes[i]][user] = latestRewardIndex[marketIndexes[i]];
        floatTotal += floatToMint;
        emit FloatMinted(user, marketIndexes[i], floatToMint);
      }
    }
    if (floatTotal > 0) {
      _mintFloat(user, floatTotal);
    }
  }
  /**
  @notice Mints outstanding float for msg.sender.
  @param marketIndexes Identifiers for the markets for which to mint float.
   */
  function claimFloatCustom(uint32[] calldata marketIndexes) external {
    ILongShort(longShort).updateSystemStateMulti(marketIndexes);
    _mintAccumulatedFloatMulti(marketIndexes, msg.sender);
  }
  /**
  @notice Mints outstanding float on behalf of another user.
  @param marketIndexes Identifiers for the markets for which to mint float.
  @param user The address of the user.
   */
  function claimFloatCustomFor(uint32[] calldata marketIndexes, address user) external {
    // Unbounded loop - users are responsible for paying their own gas costs on these and it doesn't effect the rest of the system.
    // No need to impose limit.
    ILongShort(longShort).updateSystemStateMulti(marketIndexes);
    _mintAccumulatedFloatMulti(marketIndexes, user);
  }
  /*╔═══════════════════════╗
    ║        STAKING        ║
    ╚═══════════════════════╝*/
  /**
  @notice A user with synthetic tokens stakes by calling stake on the token
  contract which calls this function. We need to first update the
  state of the LongShort contract for this market before staking to correctly calculate user rewards.
  @param amount Amount to stake.
  @param from Address to stake for.
  */
  function stakeFromUser(address from, uint256 amount) public virtual override onlyValidSynthetic((msg.sender)) {
    ILongShort(longShort).updateSystemState(marketIndexOfToken[(msg.sender)]);
    _stake((msg.sender), amount, from);
  }
  /**
  @dev Internal logic for staking.
  @param token Address of the token for which to stake.
  @param amount Amount to stake.
  @param user Address to stake for.
  */
  function _stake(
    address token,
    uint256 amount,
    address user
  ) internal virtual {
    uint32 marketIndex = marketIndexOfToken[token];
    // If they already have staked and have rewards due, mint these.
    if (
      userIndexOfLastClaimedReward[marketIndex][user] != 0 &&
      userIndexOfLastClaimedReward[marketIndex][user] < latestRewardIndex[marketIndex]
    ) {
      _mintAccumulatedFloat(marketIndex, user);
    }
    userAmountStaked[token][user] = userAmountStaked[token][user] + amount;
    userIndexOfLastClaimedReward[marketIndex][user] = latestRewardIndex[marketIndex];
    emit StakeAdded(user, address(token), amount, userIndexOfLastClaimedReward[marketIndex][user]);
  }
  /**
  @notice Allows users to shift their staked tokens from one side of the market to 
  the other at the next price.
  @param amountSyntheticTokensToShift Amount of tokens to shift.
  @param marketIndex Identifier for the market.
  @param isShiftFromLong Whether the shift is from long to short or short to long.
  */
  function shiftTokens(
    uint256 amountSyntheticTokensToShift,
    uint32 marketIndex,
    bool isShiftFromLong
  ) external virtual {
    address token = syntheticTokens[marketIndex][isShiftFromLong];
    require(userAmountStaked[token][msg.sender] >= amountSyntheticTokensToShift, "Not enough tokens to shift");
    // If the user has outstanding token shift that have already been confirmed in the LongShort
    // contract, execute them first.
    if (
      userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] != 0 &&
      userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] <
      batched_stakerNextTokenShiftIndex[marketIndex]
    ) {
      _mintAccumulatedFloat(marketIndex, msg.sender);
    }
    if (isShiftFromLong) {
      ILongShort(longShort).shiftPositionFromLongNextPrice(marketIndex, amountSyntheticTokensToShift);
      userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][
        msg.sender
      ] += amountSyntheticTokensToShift;
    } else {
      ILongShort(longShort).shiftPositionFromShortNextPrice(marketIndex, amountSyntheticTokensToShift);
      userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][
        msg.sender
      ] += amountSyntheticTokensToShift;
    }
    userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] = batched_stakerNextTokenShiftIndex[
      marketIndex
    ];
  }
  /*╔════════════════════════════╗
    ║    WITHDRAWAL & MINTING    ║
    ╚════════════════════════════╝*/
  /**
  @notice Internal logic for withdrawing stakes.
  @dev Mint user any outstanding float before withdrawing.
  @param marketIndex Market index of token.
  @param amount Amount to withdraw.
  @param token Synthetic token that was staked.
  */
  function _withdraw(
    uint32 marketIndex,
    address token,
    uint256 amount
  ) internal virtual {
    require(userAmountStaked[token][msg.sender] > 0, "nothing to withdraw");
    _mintAccumulatedFloat(marketIndex, msg.sender);
    userAmountStaked[token][msg.sender] = userAmountStaked[token][msg.sender] - amount;
    uint256 amountFees = (amount * marketUnstakeFee_e18[marketIndex]) / 1e18;
    IERC20(token).transfer(floatTreasury, amountFees);
    IERC20(token).transfer(msg.sender, amount - amountFees);
    emit StakeWithdrawn(msg.sender, token, amount);
  }
  /**
  @notice Withdraw function. Allows users to unstake.
  @param amount Amount to withdraw.
  @param token Address of the token for which to withdraw.
  */
  function withdraw(address token, uint256 amount) external {
    ILongShort(longShort).updateSystemState(marketIndexOfToken[token]);
    uint32 marketIndex = marketIndexOfToken[token];
    _withdraw(marketIndex, token, amount);
    if (userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] > 0) {
      // If they still have outstanding shifts after minting float, then check
      // that they don't withdraw more than their shifts allow.
      uint256 amountToShiftForThisToken = syntheticTokens[marketIndex][true] == token
        ? userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][msg.sender]
        : userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][msg.sender];
      require(
        userAmountStaked[token][msg.sender] >= amountToShiftForThisToken,
        "Outstanding next price stake shifts too great"
      );
    }
  }
  /**
  @notice Allows users to withdraw their entire stake for a token.
  @param token Address of the token for which to withdraw.
  */
  function withdrawAll(address token) external {
    ILongShort(longShort).updateSystemState(marketIndexOfToken[token]);
    uint32 marketIndex = marketIndexOfToken[token];
    uint256 amountToShiftForThisToken = syntheticTokens[marketIndex][true] == token
      ? userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][msg.sender]
      : userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][msg.sender];
    _withdraw(marketIndex, token, userAmountStaked[token][msg.sender] - amountToShiftForThisToken);
  }
}
.

Chief Executive Officer: We excel in generating innovative approaches and enhancements for Solidity smart contract code.
Here's a Solidity contract provided by the user: "// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.3;
import "@openzeppelin/contracts-upgradeable/token/ERC20/presets/ERC20PresetMinterPauserUpgradeable.sol";
import "./interfaces/IFloatToken.sol";
import "./interfaces/ILongShort.sol";
import "./interfaces/IStaker.sol";
import "./interfaces/ISyntheticToken.sol";
contract Staker is IStaker, Initializable {
  /*╔═════════════════════════════╗
    ║          VARIABLES          ║
    ╚═════════════════════════════╝*/
  /* ══════ Fixed-precision constants ══════ */
  uint256 public constant FLOAT_ISSUANCE_FIXED_DECIMAL = 1e42;
  // 2^52 ~= 4.5e15
  // With an exponent of 5, the largest total liquidity possible in a market (to avoid integer overflow on exponentiation) is ~10^31 or 10 Trillion (10^13)
  // NOTE: this also means if the total market value is less than 2^52 there will be a division by zero error
  uint256 public constant safeExponentBitShifting = 52;
  /* ══════ Global state ══════ */
  address public admin;
  address public floatCapital;
  address public floatTreasury;
  uint256 public floatPercentage;
  address public longShort;
  address public floatToken;
  /* ══════ Market specific ══════ */
  mapping(uint32 => uint256) public marketLaunchIncentive_period; // seconds
  mapping(uint32 => uint256) public marketLaunchIncentive_multipliers; // e18 scale
  mapping(uint32 => uint256) public marketUnstakeFee_e18;
  mapping(uint32 => uint256) public balanceIncentiveCurve_exponent;
  mapping(uint32 => int256) public balanceIncentiveCurve_equilibriumOffset;
  mapping(uint32 => mapping(bool => address)) public syntheticTokens;
  mapping(address => uint32) public marketIndexOfToken;
  /* ══════ Reward specific ══════ */
  mapping(uint32 => uint256) public latestRewardIndex;
  mapping(uint32 => mapping(uint256 => AccumulativeIssuancePerStakedSynthSnapshot))
    public accumulativeFloatPerSyntheticTokenSnapshots;
  struct AccumulativeIssuancePerStakedSynthSnapshot {
    uint256 timestamp;
    uint256 accumulativeFloatPerSyntheticToken_long;
    uint256 accumulativeFloatPerSyntheticToken_short;
  }
  /* ══════ User specific ══════ */
  mapping(uint32 => mapping(address => uint256)) public userIndexOfLastClaimedReward;
  mapping(address => mapping(address => uint256)) public userAmountStaked;
  /* ══════ Token shift management specific ══════ */
  mapping(uint32 => uint256) public batched_stakerNextTokenShiftIndex;
  /**
  @notice Used to link a token shift to a staker state
  @dev tokenShiftIndex => accumulativeFloatIssuanceSnapshotIndex
    POSSIBLE OPTIMIZATION - could pack stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping and stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping into a struct of two uint128 for storage space optimization.
  */
  mapping(uint256 => uint256) public stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping;
  /// @notice Used to fetch the price from LongShort at that point in time
  /// @dev tokenShiftIndex => longShortMarketPriceSnapshotIndex
  mapping(uint256 => uint256) public stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping;
  /// @dev marketIndex => usersAddress => stakerTokenShiftIndex
  mapping(uint32 => mapping(address => uint256)) public userNextPrice_stakedSyntheticTokenShiftIndex;
  /// @dev marketIndex => usersAddress => amountUserRequestedToShiftAwayFromLongOnNextUpdate
  mapping(uint32 => mapping(address => uint256)) public userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long;
  /// @dev marketIndex => usersAddress => amountUserRequestedToShiftAwayFromShortOnNextUpdate
  mapping(uint32 => mapping(address => uint256)) public userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short;
  /*╔════════════════════════════╗
    ║           EVENTS           ║
    ╚════════════════════════════╝*/
  event StakerV1(
    address admin,
    address floatTreasury,
    address floatCapital,
    address floatToken,
    uint256 floatPercentage
  );
  event MarketAddedToStaker(
    uint32 marketIndex,
    uint256 exitFee_e18,
    uint256 period,
    uint256 multiplier,
    uint256 balanceIncentiveExponent,
    int256 balanceIncentiveEquilibriumOffset
  );
  event AccumulativeIssuancePerStakedSynthSnapshotCreated(
    uint32 marketIndex,
    uint256 accumulativeFloatIssuanceSnapshotIndex,
    uint256 accumulativeLong,
    uint256 accumulativeShort
  );
  event StakeAdded(address user, address token, uint256 amount, uint256 lastMintIndex);
  event StakeWithdrawn(address user, address token, uint256 amount);
  // Note: the `amountFloatMinted` isn't strictly needed by the graph, but it is good to add it to validate calculations are accurate.
  event FloatMinted(address user, uint32 marketIndex, uint256 amountFloatMinted);
  event MarketLaunchIncentiveParametersChanges(uint32 marketIndex, uint256 period, uint256 multiplier);
  event StakeWithdrawalFeeUpdated(uint32 marketIndex, uint256 stakeWithdralFee);
  event BalanceIncentiveExponentUpdated(uint32 marketIndex, uint256 balanceIncentiveExponent);
  event BalanceIncentiveEquilibriumOffsetUpdated(uint32 marketIndex, int256 balanceIncentiveEquilibriumOffset);
  event FloatPercentageUpdated(uint256 floatPercentage);
  event SyntheticTokensShifted();
  event ChangeAdmin(address newAdmin);
  /*╔═════════════════════════════╗
    ║          MODIFIERS          ║
    ╚═════════════════════════════╝*/
  function onlyAdminModifierLogic() internal virtual {
    require(msg.sender == admin, "not admin");
  }
  modifier onlyAdmin() {
    onlyAdminModifierLogic();
    _;
  }
  function onlyValidSyntheticModifierLogic(address _synth) internal virtual {
    require(marketIndexOfToken[_synth] != 0, "not valid synth");
  }
  modifier onlyValidSynthetic(address _synth) {
    onlyValidSyntheticModifierLogic(_synth);
    _;
  }
  function onlyValidMarketModifierLogic(uint32 marketIndex) internal virtual {
    require(address(syntheticTokens[marketIndex][true]) != address(0), "not valid market");
  }
  modifier onlyValidMarket(uint32 marketIndex) {
    onlyValidMarketModifierLogic(marketIndex);
    _;
  }
  function onlyLongShortModifierLogic() internal virtual {
    require(msg.sender == address(longShort), "not long short");
  }
  modifier onlyLongShort() {
    onlyLongShortModifierLogic();
    _;
  }
  /*╔═════════════════════════════╗
    ║       CONTRACT SET-UP       ║
    ╚═════════════════════════════╝*/
  /**
  @notice Initializes the contract.
  @dev Calls OpenZeppelin's initializer modifier.
  @param _admin Address of the admin role.
  @param _longShort Address of the LongShort contract, a deployed LongShort.sol
  @param _floatToken Address of the Float token earned by staking.
  @param _floatTreasury Address of the treasury contract for managing fees.
  @param _floatCapital Address of the contract which earns a fixed percentage of Float.
  @param _floatPercentage Determines the float percentage that gets minted for Float Capital, base 1e18.
  */
  function initialize(
    address _admin,
    address _longShort,
    address _floatToken,
    address _floatTreasury,
    address _floatCapital,
    uint256 _floatPercentage
  ) external virtual initializer {
    admin = _admin;
    floatCapital = _floatCapital;
    floatTreasury = _floatTreasury;
    longShort = _longShort;
    floatToken = _floatToken;
    _changeFloatPercentage(_floatPercentage);
    emit StakerV1(_admin, _floatTreasury, _floatCapital, _floatToken, _floatPercentage);
  }
  /*╔═══════════════════╗
    ║       ADMIN       ║
    ╚═══════════════════╝*/
  /** 
  @notice Changes admin for the contract
  @param _admin The address of the new admin.
  */
  function changeAdmin(address _admin) external onlyAdmin {
    admin = _admin;
    emit ChangeAdmin(_admin);
  }
  /// @dev Logic for changeFloatPercentage
  function _changeFloatPercentage(uint256 newFloatPercentage) internal virtual {
    require(newFloatPercentage <= 1e18 && newFloatPercentage > 0); // less than or equal to 100% and greater than 0%
    floatPercentage = newFloatPercentage;
  }
  /**
  @notice Changes percentage of float that is minted for float capital.
  @param newFloatPercentage The new float percentage in base 1e18.
  */
  function changeFloatPercentage(uint256 newFloatPercentage) external onlyAdmin {
    _changeFloatPercentage(newFloatPercentage);
    emit FloatPercentageUpdated(newFloatPercentage);
  }
  /// @dev Logic for changeUnstakeFee
  function _changeUnstakeFee(uint32 marketIndex, uint256 newMarketUnstakeFee_e18) internal virtual {
    require(newMarketUnstakeFee_e18 <= 5e16); // Explicitely stating 5% fee as the max fee possible.
    marketUnstakeFee_e18[marketIndex] = newMarketUnstakeFee_e18;
  }
  /**
  @notice Changes unstake fee for a market
  @param marketIndex Identifies the market.
  @param newMarketUnstakeFee_e18 The new unstake fee.
  */
  function changeUnstakeFee(uint32 marketIndex, uint256 newMarketUnstakeFee_e18) external onlyAdmin {
    _changeUnstakeFee(marketIndex, newMarketUnstakeFee_e18);
    emit StakeWithdrawalFeeUpdated(marketIndex, newMarketUnstakeFee_e18);
  }
  /// @dev Logic for changeMarketLaunchIncentiveParameters
  function _changeMarketLaunchIncentiveParameters(
    uint32 marketIndex,
    uint256 period,
    uint256 initialMultiplier
  ) internal virtual {
    require(initialMultiplier >= 1e18, "marketLaunchIncentiveMultiplier must be >= 1e18");
    marketLaunchIncentive_period[marketIndex] = period;
    marketLaunchIncentive_multipliers[marketIndex] = initialMultiplier;
  }
  /**
  @notice Changes the market launch incentive parameters for a market
  @param marketIndex Identifies the market.
  @param period The new period for which float token generation should be boosted.
  @param initialMultiplier The new multiplier on Float generation.
  */
  function changeMarketLaunchIncentiveParameters(
    uint32 marketIndex,
    uint256 period,
    uint256 initialMultiplier
  ) external onlyAdmin {
    _changeMarketLaunchIncentiveParameters(marketIndex, period, initialMultiplier);
    emit MarketLaunchIncentiveParametersChanges(marketIndex, period, initialMultiplier);
  }
  /// @dev Logic for changeBalanceIncentiveExponent
  function _changeBalanceIncentiveExponent(uint32 marketIndex, uint256 _balanceIncentiveCurve_exponent)
    internal
    virtual
  {
    require(
      // The exponent has to be less than 5 in these versions of the contracts.
      _balanceIncentiveCurve_exponent > 0 && _balanceIncentiveCurve_exponent < 6,
      "balanceIncentiveCurve_exponent out of bounds"
    );
    balanceIncentiveCurve_exponent[marketIndex] = _balanceIncentiveCurve_exponent;
  }
  /** 
  @notice Changes the balance incentive exponent for a market
  @param marketIndex Identifies the market.
  @param _balanceIncentiveCurve_exponent The new exponent for the curve.
  */
  function changeBalanceIncentiveExponent(uint32 marketIndex, uint256 _balanceIncentiveCurve_exponent)
    external
    onlyAdmin
  {
    _changeBalanceIncentiveExponent(marketIndex, _balanceIncentiveCurve_exponent);
    emit BalanceIncentiveExponentUpdated(marketIndex, _balanceIncentiveCurve_exponent);
  }
  /// @dev Logic for changeBalanceIncentiveEquilibriumOffset
  function _changeBalanceIncentiveEquilibriumOffset(uint32 marketIndex, int256 _balanceIncentiveCurve_equilibriumOffset)
    internal
    virtual
  {
    // Unreasonable that we would ever shift this more than 90% either way
    require(
      _balanceIncentiveCurve_equilibriumOffset > -9e17 && _balanceIncentiveCurve_equilibriumOffset < 9e17,
      "balanceIncentiveCurve_equilibriumOffset out of bounds"
    );
    balanceIncentiveCurve_equilibriumOffset[marketIndex] = _balanceIncentiveCurve_equilibriumOffset;
  }
  /**
  @notice Changes the balance incentive curve equilibrium offset for a market
  @param marketIndex Identifies the market.
  @param _balanceIncentiveCurve_equilibriumOffset The new offset.
  */
  function changeBalanceIncentiveEquilibriumOffset(uint32 marketIndex, int256 _balanceIncentiveCurve_equilibriumOffset)
    external
    onlyAdmin
  {
    _changeBalanceIncentiveEquilibriumOffset(marketIndex, _balanceIncentiveCurve_equilibriumOffset);
    emit BalanceIncentiveEquilibriumOffsetUpdated(marketIndex, _balanceIncentiveCurve_equilibriumOffset);
  }
  /*╔═════════════════════════════╗
    ║        STAKING SETUP        ║
    ╚═════════════════════════════╝*/
  /**
  @notice Sets this contract to track staking for a market in LongShort.sol
  @param marketIndex Identifies the market.
  @param longToken Address of the long token for the market.
  @param shortToken Address of the short token for the market.
  @param kInitialMultiplier Initial boost on float generation for the market.
  @param kPeriod Period which the boost should last.
  @param unstakeFee_e18 Percentage of tokens that are levied on unstaking in base 1e18.
  @param _balanceIncentiveCurve_exponent Exponent for balance curve (see _calculateFloatPerSecond)
  @param _balanceIncentiveCurve_equilibriumOffset Offset for balance curve (see _calculateFloatPerSecond)
  */
  function addNewStakingFund(
    uint32 marketIndex,
    address longToken,
    address shortToken,
    uint256 kInitialMultiplier,
    uint256 kPeriod,
    uint256 unstakeFee_e18,
    uint256 _balanceIncentiveCurve_exponent,
    int256 _balanceIncentiveCurve_equilibriumOffset
  ) external override onlyLongShort {
    marketIndexOfToken[longToken] = marketIndex;
    marketIndexOfToken[shortToken] = marketIndex;
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].timestamp = block.timestamp;
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].accumulativeFloatPerSyntheticToken_long = 0;
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].accumulativeFloatPerSyntheticToken_short = 0;
    syntheticTokens[marketIndex][true] = longToken;
    syntheticTokens[marketIndex][false] = shortToken;
    _changeBalanceIncentiveExponent(marketIndex, _balanceIncentiveCurve_exponent);
    _changeBalanceIncentiveEquilibriumOffset(marketIndex, _balanceIncentiveCurve_equilibriumOffset);
    _changeMarketLaunchIncentiveParameters(marketIndex, kPeriod, kInitialMultiplier);
    _changeUnstakeFee(marketIndex, unstakeFee_e18);
    // Set this value to one initially - 0 is a null value and thus potentially bug prone.
    batched_stakerNextTokenShiftIndex[marketIndex] = 1;
    emit MarketAddedToStaker(
      marketIndex,
      unstakeFee_e18,
      kPeriod,
      kInitialMultiplier,
      _balanceIncentiveCurve_exponent,
      _balanceIncentiveCurve_equilibriumOffset
    );
    emit AccumulativeIssuancePerStakedSynthSnapshotCreated(marketIndex, 0, 0, 0);
  }
  /*╔═════════════════════════════════════════════════════════════════════════╗
    ║    GLOBAL FLT REWARD ACCUMULATION CALCULATION AND TRACKING FUNCTIONS    ║
    ╚═════════════════════════════════════════════════════════════════════════╝*/
  /**
  @notice Returns the K factor parameters for the given market with sensible
  defaults if they haven't been set yet.
  @param marketIndex The market to change the parameters for.
  @return period The period for which the k factor applies for in seconds.
  @return multiplier The multiplier on Float generation in this period.
  */
  function _getMarketLaunchIncentiveParameters(uint32 marketIndex)
    internal
    view
    virtual
    returns (uint256 period, uint256 multiplier)
  {
    period = marketLaunchIncentive_period[marketIndex];
    multiplier = marketLaunchIncentive_multipliers[marketIndex];
    if (multiplier < 1e18) {
      multiplier = 1e18; // multiplier of 1 by default
    }
  }
  /** 
  @notice Returns the extent to which a markets float generation should be adjusted
  based on the market's launch incentive parameters. Should start at multiplier
  then linearly change to 1e18 over time.
  @param marketIndex Identifies the market.
  @return k The calculated modifier for float generation.
  */
  function _getKValue(uint32 marketIndex) internal view virtual returns (uint256) {
    // Parameters controlling the float issuance multiplier.
    (uint256 kPeriod, uint256 kInitialMultiplier) = _getMarketLaunchIncentiveParameters(marketIndex);
    // Sanity check - under normal circumstances, the multipliers should
    // *never* be set to a value < 1e18, as there are guards against this.
    assert(kInitialMultiplier >= 1e18);
    uint256 initialTimestamp = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].timestamp;
    if (block.timestamp - initialTimestamp <= kPeriod) {
      return kInitialMultiplier - (((kInitialMultiplier - 1e18) * (block.timestamp - initialTimestamp)) / kPeriod);
    } else {
      return 1e18;
    }
  }
  /*
  @notice Computes the number of float tokens a user earns per second for
  every long/short synthetic token they've staked. The returned value has
  a fixed decimal scale of 1e42 (!!!) for numerical stability. The return
  values are float per second per synthetic token (hence the requirement
  to multiply by price)
  @dev to see below math in latex form see TODO add link
  to interact with the equations see https://www.desmos.com/calculator/optkaxyihr
  @param marketIndex The market referred to.
  @param longPrice Price of the synthetic long token in units of payment token
  @param shortPrice Price of the synthetic short token in units of payment token
  @param longValue Amount of payment token in the long side of the market
  @param shortValue Amount of payment token in the short side of the market
  @return longFloatPerSecond Float token per second per long synthetic token
  @return shortFloatPerSecond Float token per second per short synthetic token
   */
  function _calculateFloatPerSecond(
    uint32 marketIndex,
    uint256 longPrice,
    uint256 shortPrice,
    uint256 longValue,
    uint256 shortValue
  ) internal view virtual returns (uint256 longFloatPerSecond, uint256 shortFloatPerSecond) {
    // A float issuance multiplier that starts high and decreases linearly
    // over time to a value of 1. This incentivises users to stake early.
    uint256 k = _getKValue(marketIndex);
    uint256 totalLocked = (longValue + shortValue);
    // we need to scale this number by the totalLocked so that the offset remains consistent accross market size
    int256 equilibriumOffsetMarketScaled = (balanceIncentiveCurve_equilibriumOffset[marketIndex] *
      int256(totalLocked)) / 2e18;
    uint256 denominator = ((totalLocked >> safeExponentBitShifting)**balanceIncentiveCurve_exponent[marketIndex]);
    // Float is scaled by the percentage of the total market value held in
    // the opposite position. This incentivises users to stake on the
    // weaker position.
    if (int256(shortValue) - equilibriumOffsetMarketScaled < int256(longValue)) {
      if (equilibriumOffsetMarketScaled >= int256(shortValue)) {
        // edge case: imbalanced far past the equilibrium offset - full rewards go to short token
        //            extremeley unlikely to happen in practice
        return (0, 1e18 * k * shortPrice);
      }
      uint256 numerator = (uint256(int256(shortValue) - equilibriumOffsetMarketScaled) >>
        (safeExponentBitShifting - 1))**balanceIncentiveCurve_exponent[marketIndex];
      // NOTE: `x * 5e17` == `(x * 10e18) / 2`
      uint256 longRewardUnscaled = (numerator * 5e17) / denominator;
      uint256 shortRewardUnscaled = 1e18 - longRewardUnscaled;
      return ((longRewardUnscaled * k * longPrice) / 1e18, (shortRewardUnscaled * k * shortPrice) / 1e18);
    } else {
      if (-equilibriumOffsetMarketScaled >= int256(longValue)) {
        // edge case: imbalanced far past the equilibrium offset - full rewards go to long token
        //            extremeley unlikely to happen in practice
        return (1e18 * k * longPrice, 0);
      }
      uint256 numerator = (uint256(int256(longValue) + equilibriumOffsetMarketScaled) >>
        (safeExponentBitShifting - 1))**balanceIncentiveCurve_exponent[marketIndex];
      // NOTE: `x * 5e17` == `(x * 10e18) / 2`
      uint256 shortRewardUnscaled = (numerator * 5e17) / denominator;
      uint256 longRewardUnscaled = 1e18 - shortRewardUnscaled;
      return ((longRewardUnscaled * k * longPrice) / 1e18, (shortRewardUnscaled * k * shortPrice) / 1e18);
    }
  }
  /**
  @notice Computes the time since last accumulativeIssuancePerStakedSynthSnapshot for the given market in seconds.
  @param marketIndex The market referred to.
  @return The time difference in seconds
  */
  function _calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(uint32 marketIndex)
    internal
    view
    virtual
    returns (uint256)
  {
    return
      block.timestamp -
      accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]].timestamp;
  }
  /**
  @notice Computes new cumulative sum of 'r' value since last accumulativeIssuancePerStakedSynthSnapshot. We use
  cumulative 'r' value to avoid looping during issuance. Note that the
  cumulative sum is kept in 1e42 scale (!!!) to avoid numerical issues.
  @param shortValue The value locked in the short side of the market.
  @param longValue The value locked in the long side of the market.
  @param shortPrice The price of the short token as defined in LongShort.sol
  @param longPrice The price of the long token as defined in LongShort.sol
  @param marketIndex An identifier for the market.
  @return longCumulativeRates The long cumulative sum.
  @return shortCumulativeRates The short cumulative sum.
  */
  function _calculateNewCumulativeIssuancePerStakedSynth(
    uint32 marketIndex,
    uint256 longPrice,
    uint256 shortPrice,
    uint256 longValue,
    uint256 shortValue
  ) internal view virtual returns (uint256 longCumulativeRates, uint256 shortCumulativeRates) {
    // Compute the current 'r' value for float issuance per second.
    (uint256 longFloatPerSecond, uint256 shortFloatPerSecond) = _calculateFloatPerSecond(
      marketIndex,
      longPrice,
      shortPrice,
      longValue,
      shortValue
    );
    // Compute time since last accumulativeIssuancePerStakedSynthSnapshot for the given token.
    uint256 timeDelta = _calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(marketIndex);
    // Compute new cumulative 'r' value total.
    return (
      accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]]
      .accumulativeFloatPerSyntheticToken_long + (timeDelta * longFloatPerSecond),
      accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]]
      .accumulativeFloatPerSyntheticToken_short + (timeDelta * shortFloatPerSecond)
    );
  }
  /**
  @notice Creates a new accumulativeIssuancePerStakedSynthSnapshot for the given token and updates indexes.
  @param shortValue The value locked in the short side of the market.
  @param longValue The value locked in the long side of the market.
  @param shortPrice The price of the short token as defined in LongShort.sol
  @param longPrice The price of the long token as defined in LongShort.sol
  @param marketIndex An identifier for the market.
  */
  function _setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot(
    uint32 marketIndex,
    uint256 longPrice,
    uint256 shortPrice,
    uint256 longValue,
    uint256 shortValue
  ) internal virtual {
    (
      uint256 newLongAccumulativeValue,
      uint256 newShortAccumulativeValue
    ) = _calculateNewCumulativeIssuancePerStakedSynth(marketIndex, longPrice, shortPrice, longValue, shortValue);
    uint256 newIndex = latestRewardIndex[marketIndex] + 1;
    // Set cumulative 'r' value on new accumulativeIssuancePerStakedSynthSnapshot.
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex]
    .accumulativeFloatPerSyntheticToken_long = newLongAccumulativeValue;
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex]
    .accumulativeFloatPerSyntheticToken_short = newShortAccumulativeValue;
    // Set timestamp on new accumulativeIssuancePerStakedSynthSnapshot.
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex].timestamp = block.timestamp;
    // Update latest index to point to new accumulativeIssuancePerStakedSynthSnapshot.
    latestRewardIndex[marketIndex] = newIndex;
    emit AccumulativeIssuancePerStakedSynthSnapshotCreated(
      marketIndex,
      newIndex,
      newLongAccumulativeValue,
      newShortAccumulativeValue
    );
  }
  /**
  @notice Adds new accumulativeIssuancePerStakedSynthSnapshots for the given long/short tokens. Called by the
  ILongShort contract whenever there is a state change for a market.
  @param stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted Mapping from this contract's shifts to LongShort.sols next price snapshots.
  @param shortValue The value locked in the short side of the market.
  @param longValue The value locked in the long side of the market.
  @param shortPrice The price of the short token as defined in LongShort.sol
  @param longPrice The price of the long token as defined in LongShort.sol
  @param marketIndex An identifier for the market.
  */
  function pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(
    uint32 marketIndex,
    uint256 longPrice,
    uint256 shortPrice,
    uint256 longValue,
    uint256 shortValue,
    uint256 stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted // This value should be ALWAYS be zero if no shift occured
  ) external override onlyLongShort {
    // Only add a new accumulativeIssuancePerStakedSynthSnapshot if some time has passed.
    // the `stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted` value will be 0 if there is no staker related action in an executed batch
    if (stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted > 0) {
      stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[
        batched_stakerNextTokenShiftIndex[marketIndex]
      ] = stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted;
      stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[
        batched_stakerNextTokenShiftIndex[marketIndex]
      ] = latestRewardIndex[marketIndex] + 1;
      batched_stakerNextTokenShiftIndex[marketIndex] += 1;
      emit SyntheticTokensShifted();
    }
    // Time delta is fetched twice in below code, can pass through? Which is less gas?
    if (_calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(marketIndex) > 0) {
      _setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot(
        marketIndex,
        longPrice,
        shortPrice,
        longValue,
        shortValue
      );
    }
  }
  /*╔═══════════════════════════════════╗
    ║    USER REWARD STATE FUNCTIONS    ║
    ╚═══════════════════════════════════╝*/
  /// @dev Calculates the accumulated float in a specific range of staker snapshots
  function _calculateAccumulatedFloatInRange(
    uint32 marketIndex,
    uint256 amountStakedLong,
    uint256 amountStakedShort,
    uint256 rewardIndexFrom,
    uint256 rewardIndexTo
  ) internal view virtual returns (uint256 floatReward) {
    if (amountStakedLong > 0) {
      uint256 accumDeltaLong = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexTo]
      .accumulativeFloatPerSyntheticToken_long -
        accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexFrom]
        .accumulativeFloatPerSyntheticToken_long;
      floatReward += (accumDeltaLong * amountStakedLong) / FLOAT_ISSUANCE_FIXED_DECIMAL;
    }
    if (amountStakedShort > 0) {
      uint256 accumDeltaShort = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexTo]
      .accumulativeFloatPerSyntheticToken_short -
        accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexFrom]
        .accumulativeFloatPerSyntheticToken_short;
      floatReward += (accumDeltaShort * amountStakedShort) / FLOAT_ISSUANCE_FIXED_DECIMAL;
    }
  }
  /** 
  @notice Calculates float owed to the user since the user last minted float for a market.
  @param marketIndex Identifier for the market which the user staked in.
  @param user The address of the user.
  @return floatReward The amount of float owed.
   */
  function _calculateAccumulatedFloat(uint32 marketIndex, address user) internal virtual returns (uint256 floatReward) {
    address longToken = syntheticTokens[marketIndex][true];
    address shortToken = syntheticTokens[marketIndex][false];
    uint256 amountStakedLong = userAmountStaked[longToken][user];
    uint256 amountStakedShort = userAmountStaked[shortToken][user];
    uint256 usersLastRewardIndex = userIndexOfLastClaimedReward[marketIndex][user];
    // Don't do the calculation and return zero immediately if there is no change
    if (usersLastRewardIndex == latestRewardIndex[marketIndex]) {
      return 0;
    }
    uint256 usersShiftIndex = userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][user];
    // if there is a change in the users tokens held due to a token shift (or possibly another action in the future)
    if (usersShiftIndex > 0 && usersShiftIndex < batched_stakerNextTokenShiftIndex[marketIndex]) {
      floatReward = _calculateAccumulatedFloatInRange(
        marketIndex,
        amountStakedLong,
        amountStakedShort,
        usersLastRewardIndex,
        stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[usersShiftIndex]
      );
      // Update the users balances
      if (userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user] > 0) {
        amountStakedShort += ILongShort(longShort).getAmountSyntheticTokenToMintOnTargetSide(
          marketIndex,
          userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user],
          true,
          stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[usersShiftIndex]
        );
        amountStakedLong -= userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user];
        userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user] = 0;
      }
      if (userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user] > 0) {
        amountStakedLong += ILongShort(longShort).getAmountSyntheticTokenToMintOnTargetSide(
          marketIndex,
          userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user],
          false,
          stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[usersShiftIndex]
        );
        amountStakedShort -= userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user];
        userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user] = 0;
      }
      // Save the users updated staked amounts
      userAmountStaked[longToken][user] = amountStakedLong;
      userAmountStaked[shortToken][user] = amountStakedShort;
      floatReward += _calculateAccumulatedFloatInRange(
        marketIndex,
        amountStakedLong,
        amountStakedShort,
        stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[usersShiftIndex],
        latestRewardIndex[marketIndex]
      );
      userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][user] = 0;
    } else {
      floatReward = _calculateAccumulatedFloatInRange(
        marketIndex,
        amountStakedLong,
        amountStakedShort,
        usersLastRewardIndex,
        latestRewardIndex[marketIndex]
      );
    }
  }
  /**
  @notice Mints float for a user.
  @dev Mints a fixed percentage for Float capital.
  @param user The address of the user.
  @param floatToMint The amount of float to mint.
   */
  function _mintFloat(address user, uint256 floatToMint) internal virtual {
    IFloatToken(floatToken).mint(user, floatToMint);
    IFloatToken(floatToken).mint(floatCapital, (floatToMint * floatPercentage) / 1e18);
  }
  /**
  @notice Mints float owed to a user for a market since they last minted.
  @param marketIndex An identifier for the market.
  @param user The address of the user.
   */
  function _mintAccumulatedFloat(uint32 marketIndex, address user) internal virtual {
    uint256 floatToMint = _calculateAccumulatedFloat(marketIndex, user);
    if (floatToMint > 0) {
      // Set the user has claimed up until now, stops them setting this forward
      userIndexOfLastClaimedReward[marketIndex][user] = latestRewardIndex[marketIndex];
      _mintFloat(user, floatToMint);
      emit FloatMinted(user, marketIndex, floatToMint);
    }
  }
  /**
  @notice Mints float owed to a user for multiple markets, since they last minted for those markets.
  @param marketIndexes Identifiers for the markets.
  @param user The address of the user.
   */
  function _mintAccumulatedFloatMulti(uint32[] calldata marketIndexes, address user) internal virtual {
    uint256 floatTotal = 0;
    for (uint256 i = 0; i < marketIndexes.length; i++) {
      uint256 floatToMint = _calculateAccumulatedFloat(marketIndexes[i], user);
      if (floatToMint > 0) {
        // Set the user has claimed up until now, stops them setting this forward
        userIndexOfLastClaimedReward[marketIndexes[i]][user] = latestRewardIndex[marketIndexes[i]];
        floatTotal += floatToMint;
        emit FloatMinted(user, marketIndexes[i], floatToMint);
      }
    }
    if (floatTotal > 0) {
      _mintFloat(user, floatTotal);
    }
  }
  /**
  @notice Mints outstanding float for msg.sender.
  @param marketIndexes Identifiers for the markets for which to mint float.
   */
  function claimFloatCustom(uint32[] calldata marketIndexes) external {
    ILongShort(longShort).updateSystemStateMulti(marketIndexes);
    _mintAccumulatedFloatMulti(marketIndexes, msg.sender);
  }
  /**
  @notice Mints outstanding float on behalf of another user.
  @param marketIndexes Identifiers for the markets for which to mint float.
  @param user The address of the user.
   */
  function claimFloatCustomFor(uint32[] calldata marketIndexes, address user) external {
    // Unbounded loop - users are responsible for paying their own gas costs on these and it doesn't effect the rest of the system.
    // No need to impose limit.
    ILongShort(longShort).updateSystemStateMulti(marketIndexes);
    _mintAccumulatedFloatMulti(marketIndexes, user);
  }
  /*╔═══════════════════════╗
    ║        STAKING        ║
    ╚═══════════════════════╝*/
  /**
  @notice A user with synthetic tokens stakes by calling stake on the token
  contract which calls this function. We need to first update the
  state of the LongShort contract for this market before staking to correctly calculate user rewards.
  @param amount Amount to stake.
  @param from Address to stake for.
  */
  function stakeFromUser(address from, uint256 amount) public virtual override onlyValidSynthetic((msg.sender)) {
    ILongShort(longShort).updateSystemState(marketIndexOfToken[(msg.sender)]);
    _stake((msg.sender), amount, from);
  }
  /**
  @dev Internal logic for staking.
  @param token Address of the token for which to stake.
  @param amount Amount to stake.
  @param user Address to stake for.
  */
  function _stake(
    address token,
    uint256 amount,
    address user
  ) internal virtual {
    uint32 marketIndex = marketIndexOfToken[token];
    // If they already have staked and have rewards due, mint these.
    if (
      userIndexOfLastClaimedReward[marketIndex][user] != 0 &&
      userIndexOfLastClaimedReward[marketIndex][user] < latestRewardIndex[marketIndex]
    ) {
      _mintAccumulatedFloat(marketIndex, user);
    }
    userAmountStaked[token][user] = userAmountStaked[token][user] + amount;
    userIndexOfLastClaimedReward[marketIndex][user] = latestRewardIndex[marketIndex];
    emit StakeAdded(user, address(token), amount, userIndexOfLastClaimedReward[marketIndex][user]);
  }
  /**
  @notice Allows users to shift their staked tokens from one side of the market to 
  the other at the next price.
  @param amountSyntheticTokensToShift Amount of tokens to shift.
  @param marketIndex Identifier for the market.
  @param isShiftFromLong Whether the shift is from long to short or short to long.
  */
  function shiftTokens(
    uint256 amountSyntheticTokensToShift,
    uint32 marketIndex,
    bool isShiftFromLong
  ) external virtual {
    address token = syntheticTokens[marketIndex][isShiftFromLong];
    require(userAmountStaked[token][msg.sender] >= amountSyntheticTokensToShift, "Not enough tokens to shift");
    // If the user has outstanding token shift that have already been confirmed in the LongShort
    // contract, execute them first.
    if (
      userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] != 0 &&
      userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] <
      batched_stakerNextTokenShiftIndex[marketIndex]
    ) {
      _mintAccumulatedFloat(marketIndex, msg.sender);
    }
    if (isShiftFromLong) {
      ILongShort(longShort).shiftPositionFromLongNextPrice(marketIndex, amountSyntheticTokensToShift);
      userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][
        msg.sender
      ] += amountSyntheticTokensToShift;
    } else {
      ILongShort(longShort).shiftPositionFromShortNextPrice(marketIndex, amountSyntheticTokensToShift);
      userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][
        msg.sender
      ] += amountSyntheticTokensToShift;
    }
    userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] = batched_stakerNextTokenShiftIndex[
      marketIndex
    ];
  }
  /*╔════════════════════════════╗
    ║    WITHDRAWAL & MINTING    ║
    ╚════════════════════════════╝*/
  /**
  @notice Internal logic for withdrawing stakes.
  @dev Mint user any outstanding float before withdrawing.
  @param marketIndex Market index of token.
  @param amount Amount to withdraw.
  @param token Synthetic token that was staked.
  */
  function _withdraw(
    uint32 marketIndex,
    address token,
    uint256 amount
  ) internal virtual {
    require(userAmountStaked[token][msg.sender] > 0, "nothing to withdraw");
    _mintAccumulatedFloat(marketIndex, msg.sender);
    userAmountStaked[token][msg.sender] = userAmountStaked[token][msg.sender] - amount;
    uint256 amountFees = (amount * marketUnstakeFee_e18[marketIndex]) / 1e18;
    IERC20(token).transfer(floatTreasury, amountFees);
    IERC20(token).transfer(msg.sender, amount - amountFees);
    emit StakeWithdrawn(msg.sender, token, amount);
  }
  /**
  @notice Withdraw function. Allows users to unstake.
  @param amount Amount to withdraw.
  @param token Address of the token for which to withdraw.
  */
  function withdraw(address token, uint256 amount) external {
    ILongShort(longShort).updateSystemState(marketIndexOfToken[token]);
    uint32 marketIndex = marketIndexOfToken[token];
    _withdraw(marketIndex, token, amount);
    if (userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] > 0) {
      // If they still have outstanding shifts after minting float, then check
      // that they don't withdraw more than their shifts allow.
      uint256 amountToShiftForThisToken = syntheticTokens[marketIndex][true] == token
        ? userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][msg.sender]
        : userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][msg.sender];
      require(
        userAmountStaked[token][msg.sender] >= amountToShiftForThisToken,
        "Outstanding next price stake shifts too great"
      );
    }
  }
  /**
  @notice Allows users to withdraw their entire stake for a token.
  @param token Address of the token for which to withdraw.
  */
  function withdrawAll(address token) external {
    ILongShort(longShort).updateSystemState(marketIndexOfToken[token]);
    uint32 marketIndex = marketIndexOfToken[token];
    uint256 amountToShiftForThisToken = syntheticTokens[marketIndex][true] == token
      ? userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][msg.sender]
      : userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][msg.sender];
    _withdraw(marketIndex, token, userAmountStaked[token][msg.sender] - amountToShiftForThisToken);
  }
}
".
As the Security Analyst, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user.
Note that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we've collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with <INFO>, followed directly by the final idea or enhancement suggestion, e.g. "<INFO> Implementing a multi-sig wallet mechanism for added security in transactions".

Security Analyst: Let's Answer their Solidity smart contract ideas in the discussion without any other words, e.g., "A smart contract where we talk about Security: What functions the contract performs" 

[2024-17-08 08:01:24 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-17-08 08:01:24 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 29492
completion_tokens: 1
total_tokens: 29493
cost: $-1.000000


[2024-17-08 08:01:24 INFO] Chief Executive Officer: **Chief Executive Officer<->Counselor on : Reflection, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Counselor. Now, we share a common interest in collaborating to successfully complete a task assigned by a new customer.
Your main responsibilities include asking what user and customer think and provide your valuable suggestions. 
Here is a new customer's task: // SPDX-License-Identifier: BUSL-1.1

pragma solidity 0.8.3;

import "@openzeppelin/contracts-upgradeable/token/ERC20/presets/ERC20PresetMinterPauserUpgradeable.sol";

import "./interfaces/IFloatToken.sol";
import "./interfaces/ILongShort.sol";
import "./interfaces/IStaker.sol";
import "./interfaces/ISyntheticToken.sol";

contract Staker is IStaker, Initializable {
  /*╔═════════════════════════════╗
    ║          VARIABLES          ║
    ╚═════════════════════════════╝*/

  /* ══════ Fixed-precision constants ══════ */
  uint256 public constant FLOAT_ISSUANCE_FIXED_DECIMAL = 1e42;
  // 2^52 ~= 4.5e15
  // With an exponent of 5, the largest total liquidity possible in a market (to avoid integer overflow on exponentiation) is ~10^31 or 10 Trillion (10^13)
  // NOTE: this also means if the total market value is less than 2^52 there will be a division by zero error
  uint256 public constant safeExponentBitShifting = 52;

  /* ══════ Global state ══════ */
  address public admin;
  address public floatCapital;
  address public floatTreasury;
  uint256 public floatPercentage;

  address public longShort;
  address public floatToken;

  /* ══════ Market specific ══════ */
  mapping(uint32 => uint256) public marketLaunchIncentive_period; // seconds
  mapping(uint32 => uint256) public marketLaunchIncentive_multipliers; // e18 scale
  mapping(uint32 => uint256) public marketUnstakeFee_e18;
  mapping(uint32 => uint256) public balanceIncentiveCurve_exponent;
  mapping(uint32 => int256) public balanceIncentiveCurve_equilibriumOffset;

  mapping(uint32 => mapping(bool => address)) public syntheticTokens;

  mapping(address => uint32) public marketIndexOfToken;

  /* ══════ Reward specific ══════ */
  mapping(uint32 => uint256) public latestRewardIndex;
  mapping(uint32 => mapping(uint256 => AccumulativeIssuancePerStakedSynthSnapshot))
    public accumulativeFloatPerSyntheticTokenSnapshots;
  struct AccumulativeIssuancePerStakedSynthSnapshot {
    uint256 timestamp;
    uint256 accumulativeFloatPerSyntheticToken_long;
    uint256 accumulativeFloatPerSyntheticToken_short;
  }

  /* ══════ User specific ══════ */
  mapping(uint32 => mapping(address => uint256)) public userIndexOfLastClaimedReward;
  mapping(address => mapping(address => uint256)) public userAmountStaked;

  /* ══════ Token shift management specific ══════ */
  mapping(uint32 => uint256) public batched_stakerNextTokenShiftIndex;
  /**
  @notice Used to link a token shift to a staker state
  @dev tokenShiftIndex => accumulativeFloatIssuanceSnapshotIndex
    POSSIBLE OPTIMIZATION - could pack stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping and stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping into a struct of two uint128 for storage space optimization.
  */
  mapping(uint256 => uint256) public stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping;
  /// @notice Used to fetch the price from LongShort at that point in time
  /// @dev tokenShiftIndex => longShortMarketPriceSnapshotIndex
  mapping(uint256 => uint256) public stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping;
  /// @dev marketIndex => usersAddress => stakerTokenShiftIndex
  mapping(uint32 => mapping(address => uint256)) public userNextPrice_stakedSyntheticTokenShiftIndex;
  /// @dev marketIndex => usersAddress => amountUserRequestedToShiftAwayFromLongOnNextUpdate
  mapping(uint32 => mapping(address => uint256)) public userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long;
  /// @dev marketIndex => usersAddress => amountUserRequestedToShiftAwayFromShortOnNextUpdate
  mapping(uint32 => mapping(address => uint256)) public userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short;

  /*╔════════════════════════════╗
    ║           EVENTS           ║
    ╚════════════════════════════╝*/

  event StakerV1(
    address admin,
    address floatTreasury,
    address floatCapital,
    address floatToken,
    uint256 floatPercentage
  );

  event MarketAddedToStaker(
    uint32 marketIndex,
    uint256 exitFee_e18,
    uint256 period,
    uint256 multiplier,
    uint256 balanceIncentiveExponent,
    int256 balanceIncentiveEquilibriumOffset
  );

  event AccumulativeIssuancePerStakedSynthSnapshotCreated(
    uint32 marketIndex,
    uint256 accumulativeFloatIssuanceSnapshotIndex,
    uint256 accumulativeLong,
    uint256 accumulativeShort
  );

  event StakeAdded(address user, address token, uint256 amount, uint256 lastMintIndex);

  event StakeWithdrawn(address user, address token, uint256 amount);

  // Note: the `amountFloatMinted` isn't strictly needed by the graph, but it is good to add it to validate calculations are accurate.
  event FloatMinted(address user, uint32 marketIndex, uint256 amountFloatMinted);

  event MarketLaunchIncentiveParametersChanges(uint32 marketIndex, uint256 period, uint256 multiplier);

  event StakeWithdrawalFeeUpdated(uint32 marketIndex, uint256 stakeWithdralFee);

  event BalanceIncentiveExponentUpdated(uint32 marketIndex, uint256 balanceIncentiveExponent);

  event BalanceIncentiveEquilibriumOffsetUpdated(uint32 marketIndex, int256 balanceIncentiveEquilibriumOffset);

  event FloatPercentageUpdated(uint256 floatPercentage);

  event SyntheticTokensShifted();

  event ChangeAdmin(address newAdmin);

  /*╔═════════════════════════════╗
    ║          MODIFIERS          ║
    ╚═════════════════════════════╝*/

  function onlyAdminModifierLogic() internal virtual {
    require(msg.sender == admin, "not admin");
  }

  modifier onlyAdmin() {
    onlyAdminModifierLogic();
    _;
  }

  function onlyValidSyntheticModifierLogic(address _synth) internal virtual {
    require(marketIndexOfToken[_synth] != 0, "not valid synth");
  }

  modifier onlyValidSynthetic(address _synth) {
    onlyValidSyntheticModifierLogic(_synth);
    _;
  }

  function onlyValidMarketModifierLogic(uint32 marketIndex) internal virtual {
    require(address(syntheticTokens[marketIndex][true]) != address(0), "not valid market");
  }

  modifier onlyValidMarket(uint32 marketIndex) {
    onlyValidMarketModifierLogic(marketIndex);
    _;
  }

  function onlyLongShortModifierLogic() internal virtual {
    require(msg.sender == address(longShort), "not long short");
  }

  modifier onlyLongShort() {
    onlyLongShortModifierLogic();
    _;
  }

  /*╔═════════════════════════════╗
    ║       CONTRACT SET-UP       ║
    ╚═════════════════════════════╝*/

  /**
  @notice Initializes the contract.
  @dev Calls OpenZeppelin's initializer modifier.
  @param _admin Address of the admin role.
  @param _longShort Address of the LongShort contract, a deployed LongShort.sol
  @param _floatToken Address of the Float token earned by staking.
  @param _floatTreasury Address of the treasury contract for managing fees.
  @param _floatCapital Address of the contract which earns a fixed percentage of Float.
  @param _floatPercentage Determines the float percentage that gets minted for Float Capital, base 1e18.
  */
  function initialize(
    address _admin,
    address _longShort,
    address _floatToken,
    address _floatTreasury,
    address _floatCapital,
    uint256 _floatPercentage
  ) external virtual initializer {
    admin = _admin;
    floatCapital = _floatCapital;
    floatTreasury = _floatTreasury;
    longShort = _longShort;
    floatToken = _floatToken;

    _changeFloatPercentage(_floatPercentage);

    emit StakerV1(_admin, _floatTreasury, _floatCapital, _floatToken, _floatPercentage);
  }

  /*╔═══════════════════╗
    ║       ADMIN       ║
    ╚═══════════════════╝*/

  /** 
  @notice Changes admin for the contract
  @param _admin The address of the new admin.
  */
  function changeAdmin(address _admin) external onlyAdmin {
    admin = _admin;
    emit ChangeAdmin(_admin);
  }

  /// @dev Logic for changeFloatPercentage
  function _changeFloatPercentage(uint256 newFloatPercentage) internal virtual {
    require(newFloatPercentage <= 1e18 && newFloatPercentage > 0); // less than or equal to 100% and greater than 0%
    floatPercentage = newFloatPercentage;
  }

  /**
  @notice Changes percentage of float that is minted for float capital.
  @param newFloatPercentage The new float percentage in base 1e18.
  */
  function changeFloatPercentage(uint256 newFloatPercentage) external onlyAdmin {
    _changeFloatPercentage(newFloatPercentage);
    emit FloatPercentageUpdated(newFloatPercentage);
  }

  /// @dev Logic for changeUnstakeFee
  function _changeUnstakeFee(uint32 marketIndex, uint256 newMarketUnstakeFee_e18) internal virtual {
    require(newMarketUnstakeFee_e18 <= 5e16); // Explicitely stating 5% fee as the max fee possible.
    marketUnstakeFee_e18[marketIndex] = newMarketUnstakeFee_e18;
  }

  /**
  @notice Changes unstake fee for a market
  @param marketIndex Identifies the market.
  @param newMarketUnstakeFee_e18 The new unstake fee.
  */
  function changeUnstakeFee(uint32 marketIndex, uint256 newMarketUnstakeFee_e18) external onlyAdmin {
    _changeUnstakeFee(marketIndex, newMarketUnstakeFee_e18);
    emit StakeWithdrawalFeeUpdated(marketIndex, newMarketUnstakeFee_e18);
  }

  /// @dev Logic for changeMarketLaunchIncentiveParameters
  function _changeMarketLaunchIncentiveParameters(
    uint32 marketIndex,
    uint256 period,
    uint256 initialMultiplier
  ) internal virtual {
    require(initialMultiplier >= 1e18, "marketLaunchIncentiveMultiplier must be >= 1e18");

    marketLaunchIncentive_period[marketIndex] = period;
    marketLaunchIncentive_multipliers[marketIndex] = initialMultiplier;
  }

  /**
  @notice Changes the market launch incentive parameters for a market
  @param marketIndex Identifies the market.
  @param period The new period for which float token generation should be boosted.
  @param initialMultiplier The new multiplier on Float generation.
  */
  function changeMarketLaunchIncentiveParameters(
    uint32 marketIndex,
    uint256 period,
    uint256 initialMultiplier
  ) external onlyAdmin {
    _changeMarketLaunchIncentiveParameters(marketIndex, period, initialMultiplier);

    emit MarketLaunchIncentiveParametersChanges(marketIndex, period, initialMultiplier);
  }

  /// @dev Logic for changeBalanceIncentiveExponent
  function _changeBalanceIncentiveExponent(uint32 marketIndex, uint256 _balanceIncentiveCurve_exponent)
    internal
    virtual
  {
    require(
      // The exponent has to be less than 5 in these versions of the contracts.
      _balanceIncentiveCurve_exponent > 0 && _balanceIncentiveCurve_exponent < 6,
      "balanceIncentiveCurve_exponent out of bounds"
    );

    balanceIncentiveCurve_exponent[marketIndex] = _balanceIncentiveCurve_exponent;
  }

  /** 
  @notice Changes the balance incentive exponent for a market
  @param marketIndex Identifies the market.
  @param _balanceIncentiveCurve_exponent The new exponent for the curve.
  */
  function changeBalanceIncentiveExponent(uint32 marketIndex, uint256 _balanceIncentiveCurve_exponent)
    external
    onlyAdmin
  {
    _changeBalanceIncentiveExponent(marketIndex, _balanceIncentiveCurve_exponent);

    emit BalanceIncentiveExponentUpdated(marketIndex, _balanceIncentiveCurve_exponent);
  }

  /// @dev Logic for changeBalanceIncentiveEquilibriumOffset
  function _changeBalanceIncentiveEquilibriumOffset(uint32 marketIndex, int256 _balanceIncentiveCurve_equilibriumOffset)
    internal
    virtual
  {
    // Unreasonable that we would ever shift this more than 90% either way
    require(
      _balanceIncentiveCurve_equilibriumOffset > -9e17 && _balanceIncentiveCurve_equilibriumOffset < 9e17,
      "balanceIncentiveCurve_equilibriumOffset out of bounds"
    );

    balanceIncentiveCurve_equilibriumOffset[marketIndex] = _balanceIncentiveCurve_equilibriumOffset;
  }

  /**
  @notice Changes the balance incentive curve equilibrium offset for a market
  @param marketIndex Identifies the market.
  @param _balanceIncentiveCurve_equilibriumOffset The new offset.
  */
  function changeBalanceIncentiveEquilibriumOffset(uint32 marketIndex, int256 _balanceIncentiveCurve_equilibriumOffset)
    external
    onlyAdmin
  {
    _changeBalanceIncentiveEquilibriumOffset(marketIndex, _balanceIncentiveCurve_equilibriumOffset);

    emit BalanceIncentiveEquilibriumOffsetUpdated(marketIndex, _balanceIncentiveCurve_equilibriumOffset);
  }

  /*╔═════════════════════════════╗
    ║        STAKING SETUP        ║
    ╚═════════════════════════════╝*/

  /**
  @notice Sets this contract to track staking for a market in LongShort.sol
  @param marketIndex Identifies the market.
  @param longToken Address of the long token for the market.
  @param shortToken Address of the short token for the market.
  @param kInitialMultiplier Initial boost on float generation for the market.
  @param kPeriod Period which the boost should last.
  @param unstakeFee_e18 Percentage of tokens that are levied on unstaking in base 1e18.
  @param _balanceIncentiveCurve_exponent Exponent for balance curve (see _calculateFloatPerSecond)
  @param _balanceIncentiveCurve_equilibriumOffset Offset for balance curve (see _calculateFloatPerSecond)
  */
  function addNewStakingFund(
    uint32 marketIndex,
    address longToken,
    address shortToken,
    uint256 kInitialMultiplier,
    uint256 kPeriod,
    uint256 unstakeFee_e18,
    uint256 _balanceIncentiveCurve_exponent,
    int256 _balanceIncentiveCurve_equilibriumOffset
  ) external override onlyLongShort {
    marketIndexOfToken[longToken] = marketIndex;
    marketIndexOfToken[shortToken] = marketIndex;

    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].timestamp = block.timestamp;
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].accumulativeFloatPerSyntheticToken_long = 0;
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].accumulativeFloatPerSyntheticToken_short = 0;

    syntheticTokens[marketIndex][true] = longToken;
    syntheticTokens[marketIndex][false] = shortToken;

    _changeBalanceIncentiveExponent(marketIndex, _balanceIncentiveCurve_exponent);
    _changeBalanceIncentiveEquilibriumOffset(marketIndex, _balanceIncentiveCurve_equilibriumOffset);
    _changeMarketLaunchIncentiveParameters(marketIndex, kPeriod, kInitialMultiplier);

    _changeUnstakeFee(marketIndex, unstakeFee_e18);

    // Set this value to one initially - 0 is a null value and thus potentially bug prone.
    batched_stakerNextTokenShiftIndex[marketIndex] = 1;

    emit MarketAddedToStaker(
      marketIndex,
      unstakeFee_e18,
      kPeriod,
      kInitialMultiplier,
      _balanceIncentiveCurve_exponent,
      _balanceIncentiveCurve_equilibriumOffset
    );

    emit AccumulativeIssuancePerStakedSynthSnapshotCreated(marketIndex, 0, 0, 0);
  }

  /*╔═════════════════════════════════════════════════════════════════════════╗
    ║    GLOBAL FLT REWARD ACCUMULATION CALCULATION AND TRACKING FUNCTIONS    ║
    ╚═════════════════════════════════════════════════════════════════════════╝*/

  /**
  @notice Returns the K factor parameters for the given market with sensible
  defaults if they haven't been set yet.
  @param marketIndex The market to change the parameters for.
  @return period The period for which the k factor applies for in seconds.
  @return multiplier The multiplier on Float generation in this period.
  */
  function _getMarketLaunchIncentiveParameters(uint32 marketIndex)
    internal
    view
    virtual
    returns (uint256 period, uint256 multiplier)
  {
    period = marketLaunchIncentive_period[marketIndex];
    multiplier = marketLaunchIncentive_multipliers[marketIndex];

    if (multiplier < 1e18) {
      multiplier = 1e18; // multiplier of 1 by default
    }
  }

  /** 
  @notice Returns the extent to which a markets float generation should be adjusted
  based on the market's launch incentive parameters. Should start at multiplier
  then linearly change to 1e18 over time.
  @param marketIndex Identifies the market.
  @return k The calculated modifier for float generation.
  */
  function _getKValue(uint32 marketIndex) internal view virtual returns (uint256) {
    // Parameters controlling the float issuance multiplier.
    (uint256 kPeriod, uint256 kInitialMultiplier) = _getMarketLaunchIncentiveParameters(marketIndex);

    // Sanity check - under normal circumstances, the multipliers should
    // *never* be set to a value < 1e18, as there are guards against this.
    assert(kInitialMultiplier >= 1e18);

    uint256 initialTimestamp = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].timestamp;

    if (block.timestamp - initialTimestamp <= kPeriod) {
      return kInitialMultiplier - (((kInitialMultiplier - 1e18) * (block.timestamp - initialTimestamp)) / kPeriod);
    } else {
      return 1e18;
    }
  }

  /*
  @notice Computes the number of float tokens a user earns per second for
  every long/short synthetic token they've staked. The returned value has
  a fixed decimal scale of 1e42 (!!!) for numerical stability. The return
  values are float per second per synthetic token (hence the requirement
  to multiply by price)
  @dev to see below math in latex form see TODO add link
  to interact with the equations see https://www.desmos.com/calculator/optkaxyihr
  @param marketIndex The market referred to.
  @param longPrice Price of the synthetic long token in units of payment token
  @param shortPrice Price of the synthetic short token in units of payment token
  @param longValue Amount of payment token in the long side of the market
  @param shortValue Amount of payment token in the short side of the market
  @return longFloatPerSecond Float token per second per long synthetic token
  @return shortFloatPerSecond Float token per second per short synthetic token
   */
  function _calculateFloatPerSecond(
    uint32 marketIndex,
    uint256 longPrice,
    uint256 shortPrice,
    uint256 longValue,
    uint256 shortValue
  ) internal view virtual returns (uint256 longFloatPerSecond, uint256 shortFloatPerSecond) {
    // A float issuance multiplier that starts high and decreases linearly
    // over time to a value of 1. This incentivises users to stake early.
    uint256 k = _getKValue(marketIndex);

    uint256 totalLocked = (longValue + shortValue);

    // we need to scale this number by the totalLocked so that the offset remains consistent accross market size

    int256 equilibriumOffsetMarketScaled = (balanceIncentiveCurve_equilibriumOffset[marketIndex] *
      int256(totalLocked)) / 2e18;

    uint256 denominator = ((totalLocked >> safeExponentBitShifting)**balanceIncentiveCurve_exponent[marketIndex]);

    // Float is scaled by the percentage of the total market value held in
    // the opposite position. This incentivises users to stake on the
    // weaker position.
    if (int256(shortValue) - equilibriumOffsetMarketScaled < int256(longValue)) {
      if (equilibriumOffsetMarketScaled >= int256(shortValue)) {
        // edge case: imbalanced far past the equilibrium offset - full rewards go to short token
        //            extremeley unlikely to happen in practice
        return (0, 1e18 * k * shortPrice);
      }

      uint256 numerator = (uint256(int256(shortValue) - equilibriumOffsetMarketScaled) >>
        (safeExponentBitShifting - 1))**balanceIncentiveCurve_exponent[marketIndex];

      // NOTE: `x * 5e17` == `(x * 10e18) / 2`
      uint256 longRewardUnscaled = (numerator * 5e17) / denominator;
      uint256 shortRewardUnscaled = 1e18 - longRewardUnscaled;

      return ((longRewardUnscaled * k * longPrice) / 1e18, (shortRewardUnscaled * k * shortPrice) / 1e18);
    } else {
      if (-equilibriumOffsetMarketScaled >= int256(longValue)) {
        // edge case: imbalanced far past the equilibrium offset - full rewards go to long token
        //            extremeley unlikely to happen in practice
        return (1e18 * k * longPrice, 0);
      }

      uint256 numerator = (uint256(int256(longValue) + equilibriumOffsetMarketScaled) >>
        (safeExponentBitShifting - 1))**balanceIncentiveCurve_exponent[marketIndex];

      // NOTE: `x * 5e17` == `(x * 10e18) / 2`
      uint256 shortRewardUnscaled = (numerator * 5e17) / denominator;
      uint256 longRewardUnscaled = 1e18 - shortRewardUnscaled;

      return ((longRewardUnscaled * k * longPrice) / 1e18, (shortRewardUnscaled * k * shortPrice) / 1e18);
    }
  }

  /**
  @notice Computes the time since last accumulativeIssuancePerStakedSynthSnapshot for the given market in seconds.
  @param marketIndex The market referred to.
  @return The time difference in seconds
  */
  function _calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(uint32 marketIndex)
    internal
    view
    virtual
    returns (uint256)
  {
    return
      block.timestamp -
      accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]].timestamp;
  }

  /**
  @notice Computes new cumulative sum of 'r' value since last accumulativeIssuancePerStakedSynthSnapshot. We use
  cumulative 'r' value to avoid looping during issuance. Note that the
  cumulative sum is kept in 1e42 scale (!!!) to avoid numerical issues.
  @param shortValue The value locked in the short side of the market.
  @param longValue The value locked in the long side of the market.
  @param shortPrice The price of the short token as defined in LongShort.sol
  @param longPrice The price of the long token as defined in LongShort.sol
  @param marketIndex An identifier for the market.
  @return longCumulativeRates The long cumulative sum.
  @return shortCumulativeRates The short cumulative sum.
  */
  function _calculateNewCumulativeIssuancePerStakedSynth(
    uint32 marketIndex,
    uint256 longPrice,
    uint256 shortPrice,
    uint256 longValue,
    uint256 shortValue
  ) internal view virtual returns (uint256 longCumulativeRates, uint256 shortCumulativeRates) {
    // Compute the current 'r' value for float issuance per second.
    (uint256 longFloatPerSecond, uint256 shortFloatPerSecond) = _calculateFloatPerSecond(
      marketIndex,
      longPrice,
      shortPrice,
      longValue,
      shortValue
    );

    // Compute time since last accumulativeIssuancePerStakedSynthSnapshot for the given token.
    uint256 timeDelta = _calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(marketIndex);

    // Compute new cumulative 'r' value total.
    return (
      accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]]
      .accumulativeFloatPerSyntheticToken_long + (timeDelta * longFloatPerSecond),
      accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]]
      .accumulativeFloatPerSyntheticToken_short + (timeDelta * shortFloatPerSecond)
    );
  }

  /**
  @notice Creates a new accumulativeIssuancePerStakedSynthSnapshot for the given token and updates indexes.
  @param shortValue The value locked in the short side of the market.
  @param longValue The value locked in the long side of the market.
  @param shortPrice The price of the short token as defined in LongShort.sol
  @param longPrice The price of the long token as defined in LongShort.sol
  @param marketIndex An identifier for the market.
  */
  function _setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot(
    uint32 marketIndex,
    uint256 longPrice,
    uint256 shortPrice,
    uint256 longValue,
    uint256 shortValue
  ) internal virtual {
    (
      uint256 newLongAccumulativeValue,
      uint256 newShortAccumulativeValue
    ) = _calculateNewCumulativeIssuancePerStakedSynth(marketIndex, longPrice, shortPrice, longValue, shortValue);

    uint256 newIndex = latestRewardIndex[marketIndex] + 1;

    // Set cumulative 'r' value on new accumulativeIssuancePerStakedSynthSnapshot.
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex]
    .accumulativeFloatPerSyntheticToken_long = newLongAccumulativeValue;
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex]
    .accumulativeFloatPerSyntheticToken_short = newShortAccumulativeValue;

    // Set timestamp on new accumulativeIssuancePerStakedSynthSnapshot.
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex].timestamp = block.timestamp;

    // Update latest index to point to new accumulativeIssuancePerStakedSynthSnapshot.
    latestRewardIndex[marketIndex] = newIndex;

    emit AccumulativeIssuancePerStakedSynthSnapshotCreated(
      marketIndex,
      newIndex,
      newLongAccumulativeValue,
      newShortAccumulativeValue
    );
  }

  /**
  @notice Adds new accumulativeIssuancePerStakedSynthSnapshots for the given long/short tokens. Called by the
  ILongShort contract whenever there is a state change for a market.
  @param stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted Mapping from this contract's shifts to LongShort.sols next price snapshots.
  @param shortValue The value locked in the short side of the market.
  @param longValue The value locked in the long side of the market.
  @param shortPrice The price of the short token as defined in LongShort.sol
  @param longPrice The price of the long token as defined in LongShort.sol
  @param marketIndex An identifier for the market.
  */
  function pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(
    uint32 marketIndex,
    uint256 longPrice,
    uint256 shortPrice,
    uint256 longValue,
    uint256 shortValue,
    uint256 stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted // This value should be ALWAYS be zero if no shift occured
  ) external override onlyLongShort {
    // Only add a new accumulativeIssuancePerStakedSynthSnapshot if some time has passed.

    // the `stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted` value will be 0 if there is no staker related action in an executed batch
    if (stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted > 0) {
      stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[
        batched_stakerNextTokenShiftIndex[marketIndex]
      ] = stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted;
      stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[
        batched_stakerNextTokenShiftIndex[marketIndex]
      ] = latestRewardIndex[marketIndex] + 1;
      batched_stakerNextTokenShiftIndex[marketIndex] += 1;

      emit SyntheticTokensShifted();
    }

    // Time delta is fetched twice in below code, can pass through? Which is less gas?
    if (_calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(marketIndex) > 0) {
      _setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot(
        marketIndex,
        longPrice,
        shortPrice,
        longValue,
        shortValue
      );
    }
  }

  /*╔═══════════════════════════════════╗
    ║    USER REWARD STATE FUNCTIONS    ║
    ╚═══════════════════════════════════╝*/

  /// @dev Calculates the accumulated float in a specific range of staker snapshots
  function _calculateAccumulatedFloatInRange(
    uint32 marketIndex,
    uint256 amountStakedLong,
    uint256 amountStakedShort,
    uint256 rewardIndexFrom,
    uint256 rewardIndexTo
  ) internal view virtual returns (uint256 floatReward) {
    if (amountStakedLong > 0) {
      uint256 accumDeltaLong = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexTo]
      .accumulativeFloatPerSyntheticToken_long -
        accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexFrom]
        .accumulativeFloatPerSyntheticToken_long;
      floatReward += (accumDeltaLong * amountStakedLong) / FLOAT_ISSUANCE_FIXED_DECIMAL;
    }

    if (amountStakedShort > 0) {
      uint256 accumDeltaShort = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexTo]
      .accumulativeFloatPerSyntheticToken_short -
        accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexFrom]
        .accumulativeFloatPerSyntheticToken_short;
      floatReward += (accumDeltaShort * amountStakedShort) / FLOAT_ISSUANCE_FIXED_DECIMAL;
    }
  }

  /** 
  @notice Calculates float owed to the user since the user last minted float for a market.
  @param marketIndex Identifier for the market which the user staked in.
  @param user The address of the user.
  @return floatReward The amount of float owed.
   */
  function _calculateAccumulatedFloat(uint32 marketIndex, address user) internal virtual returns (uint256 floatReward) {
    address longToken = syntheticTokens[marketIndex][true];
    address shortToken = syntheticTokens[marketIndex][false];

    uint256 amountStakedLong = userAmountStaked[longToken][user];
    uint256 amountStakedShort = userAmountStaked[shortToken][user];

    uint256 usersLastRewardIndex = userIndexOfLastClaimedReward[marketIndex][user];

    // Don't do the calculation and return zero immediately if there is no change
    if (usersLastRewardIndex == latestRewardIndex[marketIndex]) {
      return 0;
    }

    uint256 usersShiftIndex = userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][user];
    // if there is a change in the users tokens held due to a token shift (or possibly another action in the future)
    if (usersShiftIndex > 0 && usersShiftIndex < batched_stakerNextTokenShiftIndex[marketIndex]) {
      floatReward = _calculateAccumulatedFloatInRange(
        marketIndex,
        amountStakedLong,
        amountStakedShort,
        usersLastRewardIndex,
        stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[usersShiftIndex]
      );

      // Update the users balances
      if (userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user] > 0) {
        amountStakedShort += ILongShort(longShort).getAmountSyntheticTokenToMintOnTargetSide(
          marketIndex,
          userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user],
          true,
          stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[usersShiftIndex]
        );

        amountStakedLong -= userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user];
        userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user] = 0;
      }

      if (userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user] > 0) {
        amountStakedLong += ILongShort(longShort).getAmountSyntheticTokenToMintOnTargetSide(
          marketIndex,
          userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user],
          false,
          stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[usersShiftIndex]
        );

        amountStakedShort -= userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user];
        userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user] = 0;
      }

      // Save the users updated staked amounts
      userAmountStaked[longToken][user] = amountStakedLong;
      userAmountStaked[shortToken][user] = amountStakedShort;

      floatReward += _calculateAccumulatedFloatInRange(
        marketIndex,
        amountStakedLong,
        amountStakedShort,
        stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[usersShiftIndex],
        latestRewardIndex[marketIndex]
      );

      userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][user] = 0;
    } else {
      floatReward = _calculateAccumulatedFloatInRange(
        marketIndex,
        amountStakedLong,
        amountStakedShort,
        usersLastRewardIndex,
        latestRewardIndex[marketIndex]
      );
    }
  }

  /**
  @notice Mints float for a user.
  @dev Mints a fixed percentage for Float capital.
  @param user The address of the user.
  @param floatToMint The amount of float to mint.
   */
  function _mintFloat(address user, uint256 floatToMint) internal virtual {
    IFloatToken(floatToken).mint(user, floatToMint);
    IFloatToken(floatToken).mint(floatCapital, (floatToMint * floatPercentage) / 1e18);
  }

  /**
  @notice Mints float owed to a user for a market since they last minted.
  @param marketIndex An identifier for the market.
  @param user The address of the user.
   */
  function _mintAccumulatedFloat(uint32 marketIndex, address user) internal virtual {
    uint256 floatToMint = _calculateAccumulatedFloat(marketIndex, user);

    if (floatToMint > 0) {
      // Set the user has claimed up until now, stops them setting this forward
      userIndexOfLastClaimedReward[marketIndex][user] = latestRewardIndex[marketIndex];

      _mintFloat(user, floatToMint);
      emit FloatMinted(user, marketIndex, floatToMint);
    }
  }

  /**
  @notice Mints float owed to a user for multiple markets, since they last minted for those markets.
  @param marketIndexes Identifiers for the markets.
  @param user The address of the user.
   */
  function _mintAccumulatedFloatMulti(uint32[] calldata marketIndexes, address user) internal virtual {
    uint256 floatTotal = 0;
    for (uint256 i = 0; i < marketIndexes.length; i++) {
      uint256 floatToMint = _calculateAccumulatedFloat(marketIndexes[i], user);

      if (floatToMint > 0) {
        // Set the user has claimed up until now, stops them setting this forward
        userIndexOfLastClaimedReward[marketIndexes[i]][user] = latestRewardIndex[marketIndexes[i]];

        floatTotal += floatToMint;

        emit FloatMinted(user, marketIndexes[i], floatToMint);
      }
    }
    if (floatTotal > 0) {
      _mintFloat(user, floatTotal);
    }
  }

  /**
  @notice Mints outstanding float for msg.sender.
  @param marketIndexes Identifiers for the markets for which to mint float.
   */
  function claimFloatCustom(uint32[] calldata marketIndexes) external {
    ILongShort(longShort).updateSystemStateMulti(marketIndexes);
    _mintAccumulatedFloatMulti(marketIndexes, msg.sender);
  }

  /**
  @notice Mints outstanding float on behalf of another user.
  @param marketIndexes Identifiers for the markets for which to mint float.
  @param user The address of the user.
   */
  function claimFloatCustomFor(uint32[] calldata marketIndexes, address user) external {
    // Unbounded loop - users are responsible for paying their own gas costs on these and it doesn't effect the rest of the system.
    // No need to impose limit.
    ILongShort(longShort).updateSystemStateMulti(marketIndexes);
    _mintAccumulatedFloatMulti(marketIndexes, user);
  }

  /*╔═══════════════════════╗
    ║        STAKING        ║
    ╚═══════════════════════╝*/

  /**
  @notice A user with synthetic tokens stakes by calling stake on the token
  contract which calls this function. We need to first update the
  state of the LongShort contract for this market before staking to correctly calculate user rewards.
  @param amount Amount to stake.
  @param from Address to stake for.
  */
  function stakeFromUser(address from, uint256 amount) public virtual override onlyValidSynthetic((msg.sender)) {
    ILongShort(longShort).updateSystemState(marketIndexOfToken[(msg.sender)]);
    _stake((msg.sender), amount, from);
  }

  /**
  @dev Internal logic for staking.
  @param token Address of the token for which to stake.
  @param amount Amount to stake.
  @param user Address to stake for.
  */
  function _stake(
    address token,
    uint256 amount,
    address user
  ) internal virtual {
    uint32 marketIndex = marketIndexOfToken[token];

    // If they already have staked and have rewards due, mint these.
    if (
      userIndexOfLastClaimedReward[marketIndex][user] != 0 &&
      userIndexOfLastClaimedReward[marketIndex][user] < latestRewardIndex[marketIndex]
    ) {
      _mintAccumulatedFloat(marketIndex, user);
    }

    userAmountStaked[token][user] = userAmountStaked[token][user] + amount;

    userIndexOfLastClaimedReward[marketIndex][user] = latestRewardIndex[marketIndex];

    emit StakeAdded(user, address(token), amount, userIndexOfLastClaimedReward[marketIndex][user]);
  }

  /**
  @notice Allows users to shift their staked tokens from one side of the market to 
  the other at the next price.
  @param amountSyntheticTokensToShift Amount of tokens to shift.
  @param marketIndex Identifier for the market.
  @param isShiftFromLong Whether the shift is from long to short or short to long.
  */
  function shiftTokens(
    uint256 amountSyntheticTokensToShift,
    uint32 marketIndex,
    bool isShiftFromLong
  ) external virtual {
    address token = syntheticTokens[marketIndex][isShiftFromLong];
    require(userAmountStaked[token][msg.sender] >= amountSyntheticTokensToShift, "Not enough tokens to shift");

    // If the user has outstanding token shift that have already been confirmed in the LongShort
    // contract, execute them first.
    if (
      userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] != 0 &&
      userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] <
      batched_stakerNextTokenShiftIndex[marketIndex]
    ) {
      _mintAccumulatedFloat(marketIndex, msg.sender);
    }

    if (isShiftFromLong) {
      ILongShort(longShort).shiftPositionFromLongNextPrice(marketIndex, amountSyntheticTokensToShift);
      userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][
        msg.sender
      ] += amountSyntheticTokensToShift;
    } else {
      ILongShort(longShort).shiftPositionFromShortNextPrice(marketIndex, amountSyntheticTokensToShift);
      userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][
        msg.sender
      ] += amountSyntheticTokensToShift;
    }

    userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] = batched_stakerNextTokenShiftIndex[
      marketIndex
    ];
  }

  /*╔════════════════════════════╗
    ║    WITHDRAWAL & MINTING    ║
    ╚════════════════════════════╝*/

  /**
  @notice Internal logic for withdrawing stakes.
  @dev Mint user any outstanding float before withdrawing.
  @param marketIndex Market index of token.
  @param amount Amount to withdraw.
  @param token Synthetic token that was staked.
  */
  function _withdraw(
    uint32 marketIndex,
    address token,
    uint256 amount
  ) internal virtual {
    require(userAmountStaked[token][msg.sender] > 0, "nothing to withdraw");
    _mintAccumulatedFloat(marketIndex, msg.sender);

    userAmountStaked[token][msg.sender] = userAmountStaked[token][msg.sender] - amount;

    uint256 amountFees = (amount * marketUnstakeFee_e18[marketIndex]) / 1e18;

    IERC20(token).transfer(floatTreasury, amountFees);
    IERC20(token).transfer(msg.sender, amount - amountFees);

    emit StakeWithdrawn(msg.sender, token, amount);
  }

  /**
  @notice Withdraw function. Allows users to unstake.
  @param amount Amount to withdraw.
  @param token Address of the token for which to withdraw.
  */
  function withdraw(address token, uint256 amount) external {
    ILongShort(longShort).updateSystemState(marketIndexOfToken[token]);

    uint32 marketIndex = marketIndexOfToken[token];

    _withdraw(marketIndex, token, amount);

    if (userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] > 0) {
      // If they still have outstanding shifts after minting float, then check
      // that they don't withdraw more than their shifts allow.
      uint256 amountToShiftForThisToken = syntheticTokens[marketIndex][true] == token
        ? userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][msg.sender]
        : userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][msg.sender];

      require(
        userAmountStaked[token][msg.sender] >= amountToShiftForThisToken,
        "Outstanding next price stake shifts too great"
      );
    }
  }

  /**
  @notice Allows users to withdraw their entire stake for a token.
  @param token Address of the token for which to withdraw.
  */
  function withdrawAll(address token) external {
    ILongShort(longShort).updateSystemState(marketIndexOfToken[token]);

    uint32 marketIndex = marketIndexOfToken[token];

    uint256 amountToShiftForThisToken = syntheticTokens[marketIndex][true] == token
      ? userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][msg.sender]
      : userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][msg.sender];

    _withdraw(marketIndex, token, userAmountStaked[token][msg.sender] - amountToShiftForThisToken);
  }
}
.]

Security

[2024-17-08 08:01:24 INFO] **[Seminar Conclusion]**:

 Security

[2024-17-08 08:01:24 INFO] **[Seminar Conclusion]**:

 <INFO> Security

[2024-17-08 08:01:24 INFO] **[Execute Detail]**

execute SimplePhase:[ContractReviewComment] in ComposedPhase:[CodeReview], cycle 1

[2024-17-08 08:01:24 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: BUSL-1.1 pragma solidity 0.8.3; import "@openzeppelin/contracts-upgradeable/token/ERC20/presets/ERC20PresetMinterPauserUpgradeable.sol"; import "./interfaces/IFloatToken.sol"; import "./interfaces/ILongShort.sol"; import "./interfaces/IStaker.sol"; import "./interfaces/ISyntheticToken.sol"; contract Staker is IStaker, Initializable {   /╔═════════════════════════════╗     ║          VARIABLES          ║     ╚═════════════════════════════╝/ / ══════ Fixed-precision constants ══════ /   uint256 public constant FLOAT_ISSUANCE_FIXED_DECIMAL = 1e42;   // 2^52 ~= 4.5e15   // With an exponent of 5, the largest total liquidity possible in a market (to avoid integer overflow on exponentiation) is ~10^31 or 10 Trillion (10^13)   // NOTE: this also means if the total market value is less than 2^52 there will be a division by zero error   uint256 public constant safeExponentBitShifting = 52; / ══════ Global state ══════ /   address public admin;   address public floatCapital;   address public floatTreasury;   uint256 public floatPercentage; address public longShort;   address public floatToken; / ══════ Market specific ══════ /   mapping(uint32 =&gt; uint256) public marketLaunchIncentive_period; // seconds   mapping(uint32 =&gt; uint256) public marketLaunchIncentive_multipliers; // e18 scale   mapping(uint32 =&gt; uint256) public marketUnstakeFee_e18;   mapping(uint32 =&gt; uint256) public balanceIncentiveCurve_exponent;   mapping(uint32 =&gt; int256) public balanceIncentiveCurve_equilibriumOffset; mapping(uint32 =&gt; mapping(bool =&gt; address)) public syntheticTokens; mapping(address =&gt; uint32) public marketIndexOfToken; / ══════ Reward specific ══════ /   mapping(uint32 =&gt; uint256) public latestRewardIndex;   mapping(uint32 =&gt; mapping(uint256 =&gt; AccumulativeIssuancePerStakedSynthSnapshot))     public accumulativeFloatPerSyntheticTokenSnapshots;   struct AccumulativeIssuancePerStakedSynthSnapshot {     uint256 timestamp;     uint256 accumulativeFloatPerSyntheticToken_long;     uint256 accumulativeFloatPerSyntheticToken_short;   } / ══════ User specific ══════ /   mapping(uint32 =&gt; mapping(address =&gt; uint256)) public userIndexOfLastClaimedReward;   mapping(address =&gt; mapping(address =&gt; uint256)) public userAmountStaked; / ══════ Token shift management specific ══════ /   mapping(uint32 =&gt; uint256) public batched_stakerNextTokenShiftIndex;   /*   @notice Used to link a token shift to a staker state   @dev tokenShiftIndex =&gt; accumulativeFloatIssuanceSnapshotIndex     POSSIBLE OPTIMIZATION - could pack stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping and stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping into a struct of two uint128 for storage space optimization.   /   mapping(uint256 =&gt; uint256) public stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping;   /// @notice Used to fetch the price from LongShort at that point in time   /// @dev tokenShiftIndex =&gt; longShortMarketPriceSnapshotIndex   mapping(uint256 =&gt; uint256) public stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping;   /// @dev marketIndex =&gt; usersAddress =&gt; stakerTokenShiftIndex   mapping(uint32 =&gt; mapping(address =&gt; uint256)) public userNextPrice_stakedSyntheticTokenShiftIndex;   /// @dev marketIndex =&gt; usersAddress =&gt; amountUserRequestedToShiftAwayFromLongOnNextUpdate   mapping(uint32 =&gt; mapping(address =&gt; uint256)) public userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long;   /// @dev marketIndex =&gt; usersAddress =&gt; amountUserRequestedToShiftAwayFromShortOnNextUpdate   mapping(uint32 =&gt; mapping(address =&gt; uint256)) public userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short; /╔════════════════════════════╗     ║           EVENTS           ║     ╚════════════════════════════╝/ event StakerV1(     address admin,     address floatTreasury,     address floatCapital,     address floatToken,     uint256 floatPercentage   ); event MarketAddedToStaker(     uint32 marketIndex,     uint256 exitFee_e18,     uint256 period,     uint256 multiplier,     uint256 balanceIncentiveExponent,     int256 balanceIncentiveEquilibriumOffset   ); event AccumulativeIssuancePerStakedSynthSnapshotCreated(     uint32 marketIndex,     uint256 accumulativeFloatIssuanceSnapshotIndex,     uint256 accumulativeLong,     uint256 accumulativeShort   ); event StakeAdded(address user, address token, uint256 amount, uint256 lastMintIndex); event StakeWithdrawn(address user, address token, uint256 amount); // Note: the amountFloatMinted isn't strictly needed by the graph, but it is good to add it to validate calculations are accurate.   event FloatMinted(address user, uint32 marketIndex, uint256 amountFloatMinted); event MarketLaunchIncentiveParametersChanges(uint32 marketIndex, uint256 period, uint256 multiplier); event StakeWithdrawalFeeUpdated(uint32 marketIndex, uint256 stakeWithdralFee); event BalanceIncentiveExponentUpdated(uint32 marketIndex, uint256 balanceIncentiveExponent); event BalanceIncentiveEquilibriumOffsetUpdated(uint32 marketIndex, int256 balanceIncentiveEquilibriumOffset); event FloatPercentageUpdated(uint256 floatPercentage); event SyntheticTokensShifted(); event ChangeAdmin(address newAdmin); /╔═════════════════════════════╗     ║          MODIFIERS          ║     ╚═════════════════════════════╝/ function onlyAdminModifierLogic() internal virtual {     require(msg.sender == admin, "not admin");   } modifier onlyAdmin() {     onlyAdminModifierLogic();     _;   } function onlyValidSyntheticModifierLogic(address _synth) internal virtual {     require(marketIndexOfToken[_synth] != 0, "not valid synth");   } modifier onlyValidSynthetic(address synth) {     onlyValidSyntheticModifierLogic(_synth);     ;   } function onlyValidMarketModifierLogic(uint32 marketIndex) internal virtual {     require(address(syntheticTokens[marketIndex][true]) != address(0), "not valid market");   } modifier onlyValidMarket(uint32 marketIndex) {     onlyValidMarketModifierLogic(marketIndex);     _;   } function onlyLongShortModifierLogic() internal virtual {     require(msg.sender == address(longShort), "not long short");   } modifier onlyLongShort() {     onlyLongShortModifierLogic();     _;   } /╔═════════════════════════════╗     ║       CONTRACT SET-UP       ║     ╚═════════════════════════════╝/ /*   @notice Initializes the contract.   @dev Calls OpenZeppelin's initializer modifier.   @param _admin Address of the admin role.   @param _longShort Address of the LongShort contract, a deployed LongShort.sol   @param _floatToken Address of the Float token earned by staking.   @param _floatTreasury Address of the treasury contract for managing fees.   @param _floatCapital Address of the contract which earns a fixed percentage of Float.   @param _floatPercentage Determines the float percentage that gets minted for Float Capital, base 1e18.   /   function initialize(     address _admin,     address _longShort,     address _floatToken,     address _floatTreasury,     address _floatCapital,     uint256 _floatPercentage   ) external virtual initializer {     admin = _admin;     floatCapital = _floatCapital;     floatTreasury = _floatTreasury;     longShort = _longShort;     floatToken = _floatToken; _changeFloatPercentage(_floatPercentage);  emit StakerV1(_admin, _floatTreasury, _floatCapital, _floatToken, _floatPercentage);  } /╔═══════════════════╗     ║       ADMIN       ║     ╚═══════════════════╝/ /*    @notice Changes admin for the contract   @param _admin The address of the new admin.   /   function changeAdmin(address _admin) external onlyAdmin {     admin = _admin;     emit ChangeAdmin(_admin);   } /// @dev Logic for changeFloatPercentage   function _changeFloatPercentage(uint256 newFloatPercentage) internal virtual {     require(newFloatPercentage &lt;= 1e18 &amp;&amp; newFloatPercentage &gt; 0); // less than or equal to 100% and greater than 0%     floatPercentage = newFloatPercentage;   } /*   @notice Changes percentage of float that is minted for float capital.   @param newFloatPercentage The new float percentage in base 1e18.   /   function changeFloatPercentage(uint256 newFloatPercentage) external onlyAdmin {     _changeFloatPercentage(newFloatPercentage);     emit FloatPercentageUpdated(newFloatPercentage);   } /// @dev Logic for changeUnstakeFee   function _changeUnstakeFee(uint32 marketIndex, uint256 newMarketUnstakeFee_e18) internal virtual {     require(newMarketUnstakeFee_e18 &lt;= 5e16); // Explicitely stating 5% fee as the max fee possible.     marketUnstakeFee_e18[marketIndex] = newMarketUnstakeFee_e18;   } /*   @notice Changes unstake fee for a market   @param marketIndex Identifies the market.   @param newMarketUnstakeFee_e18 The new unstake fee.   /   function changeUnstakeFee(uint32 marketIndex, uint256 newMarketUnstakeFee_e18) external onlyAdmin {     _changeUnstakeFee(marketIndex, newMarketUnstakeFee_e18);     emit StakeWithdrawalFeeUpdated(marketIndex, newMarketUnstakeFee_e18);   } /// @dev Logic for changeMarketLaunchIncentiveParameters   function _changeMarketLaunchIncentiveParameters(     uint32 marketIndex,     uint256 period,     uint256 initialMultiplier   ) internal virtual {     require(initialMultiplier &gt;= 1e18, "marketLaunchIncentiveMultiplier must be &gt;= 1e18"); marketLaunchIncentive_period[marketIndex] = period; marketLaunchIncentive_multipliers[marketIndex] = initialMultiplier;  } /*   @notice Changes the market launch incentive parameters for a market   @param marketIndex Identifies the market.   @param period The new period for which float token generation should be boosted.   @param initialMultiplier The new multiplier on Float generation.   /   function changeMarketLaunchIncentiveParameters(     uint32 marketIndex,     uint256 period,     uint256 initialMultiplier   ) external onlyAdmin {     _changeMarketLaunchIncentiveParameters(marketIndex, period, initialMultiplier); emit MarketLaunchIncentiveParametersChanges(marketIndex, period, initialMultiplier);  } /// @dev Logic for changeBalanceIncentiveExponent   function _changeBalanceIncentiveExponent(uint32 marketIndex, uint256 _balanceIncentiveCurve_exponent)     internal     virtual   {     require(       // The exponent has to be less than 5 in these versions of the contracts.       _balanceIncentiveCurve_exponent &gt; 0 &amp;&amp; _balanceIncentiveCurve_exponent &lt; 6,       "balanceIncentiveCurve_exponent out of bounds"     ); balanceIncentiveCurve_exponent[marketIndex] = _balanceIncentiveCurve_exponent;  } /*    @notice Changes the balance incentive exponent for a market   @param marketIndex Identifies the market.   @param _balanceIncentiveCurve_exponent The new exponent for the curve.   /   function changeBalanceIncentiveExponent(uint32 marketIndex, uint256 _balanceIncentiveCurve_exponent)     external     onlyAdmin   {     _changeBalanceIncentiveExponent(marketIndex, _balanceIncentiveCurve_exponent); emit BalanceIncentiveExponentUpdated(marketIndex, _balanceIncentiveCurve_exponent);  } /// @dev Logic for changeBalanceIncentiveEquilibriumOffset   function _changeBalanceIncentiveEquilibriumOffset(uint32 marketIndex, int256 _balanceIncentiveCurve_equilibriumOffset)     internal     virtual   {     // Unreasonable that we would ever shift this more than 90% either way     require(       _balanceIncentiveCurve_equilibriumOffset &gt; -9e17 &amp;&amp; _balanceIncentiveCurve_equilibriumOffset &lt; 9e17,       "balanceIncentiveCurve_equilibriumOffset out of bounds"     ); balanceIncentiveCurve_equilibriumOffset[marketIndex] = _balanceIncentiveCurve_equilibriumOffset;  } /*   @notice Changes the balance incentive curve equilibrium offset for a market   @param marketIndex Identifies the market.   @param _balanceIncentiveCurve_equilibriumOffset The new offset.   /   function changeBalanceIncentiveEquilibriumOffset(uint32 marketIndex, int256 _balanceIncentiveCurve_equilibriumOffset)     external     onlyAdmin   {     _changeBalanceIncentiveEquilibriumOffset(marketIndex, _balanceIncentiveCurve_equilibriumOffset); emit BalanceIncentiveEquilibriumOffsetUpdated(marketIndex, _balanceIncentiveCurve_equilibriumOffset);  } /╔═════════════════════════════╗     ║        STAKING SETUP        ║     ╚═════════════════════════════╝/ /*   @notice Sets this contract to track staking for a market in LongShort.sol   @param marketIndex Identifies the market.   @param longToken Address of the long token for the market.   @param shortToken Address of the short token for the market.   @param kInitialMultiplier Initial boost on float generation for the market.   @param kPeriod Period which the boost should last.   @param unstakeFee_e18 Percentage of tokens that are levied on unstaking in base 1e18.   @param _balanceIncentiveCurve_exponent Exponent for balance curve (see _calculateFloatPerSecond)   @param _balanceIncentiveCurve_equilibriumOffset Offset for balance curve (see _calculateFloatPerSecond)   /   function addNewStakingFund(     uint32 marketIndex,     address longToken,     address shortToken,     uint256 kInitialMultiplier,     uint256 kPeriod,     uint256 unstakeFee_e18,     uint256 _balanceIncentiveCurve_exponent,     int256 _balanceIncentiveCurve_equilibriumOffset   ) external override onlyLongShort {     marketIndexOfToken[longToken] = marketIndex;     marketIndexOfToken[shortToken] = marketIndex; accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].timestamp = block.timestamp; accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].accumulativeFloatPerSyntheticToken_long = 0; accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].accumulativeFloatPerSyntheticToken_short = 0;  syntheticTokens[marketIndex][true] = longToken; syntheticTokens[marketIndex][false] = shortToken;  _changeBalanceIncentiveExponent(marketIndex, _balanceIncentiveCurve_exponent); _changeBalanceIncentiveEquilibriumOffset(marketIndex, _balanceIncentiveCurve_equilibriumOffset); _changeMarketLaunchIncentiveParameters(marketIndex, kPeriod, kInitialMultiplier);  _changeUnstakeFee(marketIndex, unstakeFee_e18);  // Set this value to one initially - 0 is a null value and thus potentially bug prone. batched_stakerNextTokenShiftIndex[marketIndex] = 1;  emit MarketAddedToStaker(   marketIndex,   unstakeFee_e18,   kPeriod,   kInitialMultiplier,   _balanceIncentiveCurve_exponent,   _balanceIncentiveCurve_equilibriumOffset );  emit AccumulativeIssuancePerStakedSynthSnapshotCreated(marketIndex, 0, 0, 0);  } /╔═════════════════════════════════════════════════════════════════════════╗     ║    GLOBAL FLT REWARD ACCUMULATION CALCULATION AND TRACKING FUNCTIONS    ║     ╚═════════════════════════════════════════════════════════════════════════╝/ /*   @notice Returns the K factor parameters for the given market with sensible   defaults if they haven't been set yet.   @param marketIndex The market to change the parameters for.   @return period The period for which the k factor applies for in seconds.   @return multiplier The multiplier on Float generation in this period.   /   function _getMarketLaunchIncentiveParameters(uint32 marketIndex)     internal     view     virtual     returns (uint256 period, uint256 multiplier)   {     period = marketLaunchIncentive_period[marketIndex];     multiplier = marketLaunchIncentive_multipliers[marketIndex]; if (multiplier &lt; 1e18) {   multiplier = 1e18; // multiplier of 1 by default }  } /*    @notice Returns the extent to which a markets float generation should be adjusted   based on the market's launch incentive parameters. Should start at multiplier   then linearly change to 1e18 over time.   @param marketIndex Identifies the market.   @return k The calculated modifier for float generation.   /   function _getKValue(uint32 marketIndex) internal view virtual returns (uint256) {     // Parameters controlling the float issuance multiplier.     (uint256 kPeriod, uint256 kInitialMultiplier) = _getMarketLaunchIncentiveParameters(marketIndex); // Sanity check - under normal circumstances, the multipliers should // *never* be set to a value &lt; 1e18, as there are guards against this. assert(kInitialMultiplier &gt;= 1e18);  uint256 initialTimestamp = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].timestamp;  if (block.timestamp - initialTimestamp &lt;= kPeriod) {   return kInitialMultiplier - (((kInitialMultiplier - 1e18) * (block.timestamp - initialTimestamp)) / kPeriod); } else {   return 1e18; }  } /   @notice Computes the number of float tokens a user earns per second for   every long/short synthetic token they've staked. The returned value has   a fixed decimal scale of 1e42 (!!!) for numerical stability. The return   values are float per second per synthetic token (hence the requirement   to multiply by price)   @dev to see below math in latex form see TODO add link   to interact with the equations see https://www.desmos.com/calculator/optkaxyihr   @param marketIndex The market referred to.   @param longPrice Price of the synthetic long token in units of payment token   @param shortPrice Price of the synthetic short token in units of payment token   @param longValue Amount of payment token in the long side of the market   @param shortValue Amount of payment token in the short side of the market   @return longFloatPerSecond Float token per second per long synthetic token   @return shortFloatPerSecond Float token per second per short synthetic token    /   function _calculateFloatPerSecond(     uint32 marketIndex,     uint256 longPrice,     uint256 shortPrice,     uint256 longValue,     uint256 shortValue   ) internal view virtual returns (uint256 longFloatPerSecond, uint256 shortFloatPerSecond) {     // A float issuance multiplier that starts high and decreases linearly     // over time to a value of 1. This incentivises users to stake early.     uint256 k = _getKValue(marketIndex); uint256 totalLocked = (longValue + shortValue);  // we need to scale this number by the totalLocked so that the offset remains consistent accross market size  int256 equilibriumOffsetMarketScaled = (balanceIncentiveCurve_equilibriumOffset[marketIndex] *   int256(totalLocked)) / 2e18;  uint256 denominator = ((totalLocked &gt;&gt; safeExponentBitShifting)**balanceIncentiveCurve_exponent[marketIndex]);  // Float is scaled by the percentage of the total market value held in // the opposite position. This incentivises users to stake on the // weaker position. if (int256(shortValue) - equilibriumOffsetMarketScaled &lt; int256(longValue)) {   if (equilibriumOffsetMarketScaled &gt;= int256(shortValue)) {     // edge case: imbalanced far past the equilibrium offset - full rewards go to short token     //            extremeley unlikely to happen in practice     return (0, 1e18 * k * shortPrice);   }    uint256 numerator = (uint256(int256(shortValue) - equilibriumOffsetMarketScaled) &gt;&gt;     (safeExponentBitShifting - 1))**balanceIncentiveCurve_exponent[marketIndex];    // NOTE: `x * 5e17` == `(x * 10e18) / 2`   uint256 longRewardUnscaled = (numerator * 5e17) / denominator;   uint256 shortRewardUnscaled = 1e18 - longRewardUnscaled;    return ((longRewardUnscaled * k * longPrice) / 1e18, (shortRewardUnscaled * k * shortPrice) / 1e18); } else {   if (-equilibriumOffsetMarketScaled &gt;= int256(longValue)) {     // edge case: imbalanced far past the equilibrium offset - full rewards go to long token     //            extremeley unlikely to happen in practice     return (1e18 * k * longPrice, 0);   }    uint256 numerator = (uint256(int256(longValue) + equilibriumOffsetMarketScaled) &gt;&gt;     (safeExponentBitShifting - 1))**balanceIncentiveCurve_exponent[marketIndex];    // NOTE: `x * 5e17` == `(x * 10e18) / 2`   uint256 shortRewardUnscaled = (numerator * 5e17) / denominator;   uint256 longRewardUnscaled = 1e18 - shortRewardUnscaled;    return ((longRewardUnscaled * k * longPrice) / 1e18, (shortRewardUnscaled * k * shortPrice) / 1e18); }  } /*   @notice Computes the time since last accumulativeIssuancePerStakedSynthSnapshot for the given market in seconds.   @param marketIndex The market referred to.   @return The time difference in seconds   /   function _calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(uint32 marketIndex)     internal     view     virtual     returns (uint256)   {     return       block.timestamp -       accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]].timestamp;   } /*   @notice Computes new cumulative sum of 'r' value since last accumulativeIssuancePerStakedSynthSnapshot. We use   cumulative 'r' value to avoid looping during issuance. Note that the   cumulative sum is kept in 1e42 scale (!!!) to avoid numerical issues.   @param shortValue The value locked in the short side of the market.   @param longValue The value locked in the long side of the market.   @param shortPrice The price of the short token as defined in LongShort.sol   @param longPrice The price of the long token as defined in LongShort.sol   @param marketIndex An identifier for the market.   @return longCumulativeRates The long cumulative sum.   @return shortCumulativeRates The short cumulative sum.   /   function _calculateNewCumulativeIssuancePerStakedSynth(     uint32 marketIndex,     uint256 longPrice,     uint256 shortPrice,     uint256 longValue,     uint256 shortValue   ) internal view virtual returns (uint256 longCumulativeRates, uint256 shortCumulativeRates) {     // Compute the current 'r' value for float issuance per second.     (uint256 longFloatPerSecond, uint256 shortFloatPerSecond) = _calculateFloatPerSecond(       marketIndex,       longPrice,       shortPrice,       longValue,       shortValue     ); // Compute time since last accumulativeIssuancePerStakedSynthSnapshot for the given token. uint256 timeDelta = _calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(marketIndex);  // Compute new cumulative 'r' value total. return (   accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]]   .accumulativeFloatPerSyntheticToken_long + (timeDelta * longFloatPerSecond),   accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]]   .accumulativeFloatPerSyntheticToken_short + (timeDelta * shortFloatPerSecond) );  } /*   @notice Creates a new accumulativeIssuancePerStakedSynthSnapshot for the given token and updates indexes.   @param shortValue The value locked in the short side of the market.   @param longValue The value locked in the long side of the market.   @param shortPrice The price of the short token as defined in LongShort.sol   @param longPrice The price of the long token as defined in LongShort.sol   @param marketIndex An identifier for the market.   /   function _setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot(     uint32 marketIndex,     uint256 longPrice,     uint256 shortPrice,     uint256 longValue,     uint256 shortValue   ) internal virtual {     (       uint256 newLongAccumulativeValue,       uint256 newShortAccumulativeValue     ) = _calculateNewCumulativeIssuancePerStakedSynth(marketIndex, longPrice, shortPrice, longValue, shortValue); uint256 newIndex = latestRewardIndex[marketIndex] + 1;  // Set cumulative 'r' value on new accumulativeIssuancePerStakedSynthSnapshot. accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex] .accumulativeFloatPerSyntheticToken_long = newLongAccumulativeValue; accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex] .accumulativeFloatPerSyntheticToken_short = newShortAccumulativeValue;  // Set timestamp on new accumulativeIssuancePerStakedSynthSnapshot. accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex].timestamp = block.timestamp;  // Update latest index to point to new accumulativeIssuancePerStakedSynthSnapshot. latestRewardIndex[marketIndex] = newIndex;  emit AccumulativeIssuancePerStakedSynthSnapshotCreated(   marketIndex,   newIndex,   newLongAccumulativeValue,   newShortAccumulativeValue );  } /*   @notice Adds new accumulativeIssuancePerStakedSynthSnapshots for the given long/short tokens. Called by the   ILongShort contract whenever there is a state change for a market.   @param stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted Mapping from this contract's shifts to LongShort.sols next price snapshots.   @param shortValue The value locked in the short side of the market.   @param longValue The value locked in the long side of the market.   @param shortPrice The price of the short token as defined in LongShort.sol   @param longPrice The price of the long token as defined in LongShort.sol   @param marketIndex An identifier for the market.   /   function pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(     uint32 marketIndex,     uint256 longPrice,     uint256 shortPrice,     uint256 longValue,     uint256 shortValue,     uint256 stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted // This value should be ALWAYS be zero if no shift occured   ) external override onlyLongShort {     // Only add a new accumulativeIssuancePerStakedSynthSnapshot if some time has passed. // the `stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted` value will be 0 if there is no staker related action in an executed batch if (stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted &gt; 0) {   stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[     batched_stakerNextTokenShiftIndex[marketIndex]   ] = stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted;   stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[     batched_stakerNextTokenShiftIndex[marketIndex]   ] = latestRewardIndex[marketIndex] + 1;   batched_stakerNextTokenShiftIndex[marketIndex] += 1;    emit SyntheticTokensShifted(); }  // Time delta is fetched twice in below code, can pass through? Which is less gas? if (_calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(marketIndex) &gt; 0) {   _setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot(     marketIndex,     longPrice,     shortPrice,     longValue,     shortValue   ); }  } /╔═══════════════════════════════════╗     ║    USER REWARD STATE FUNCTIONS    ║     ╚═══════════════════════════════════╝/ /// @dev Calculates the accumulated float in a specific range of staker snapshots   function _calculateAccumulatedFloatInRange(     uint32 marketIndex,     uint256 amountStakedLong,     uint256 amountStakedShort,     uint256 rewardIndexFrom,     uint256 rewardIndexTo   ) internal view virtual returns (uint256 floatReward) {     if (amountStakedLong &gt; 0) {       uint256 accumDeltaLong = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexTo]       .accumulativeFloatPerSyntheticToken_long -         accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexFrom]         .accumulativeFloatPerSyntheticToken_long;       floatReward += (accumDeltaLong * amountStakedLong) / FLOAT_ISSUANCE_FIXED_DECIMAL;     } if (amountStakedShort &gt; 0) {   uint256 accumDeltaShort = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexTo]   .accumulativeFloatPerSyntheticToken_short -     accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexFrom]     .accumulativeFloatPerSyntheticToken_short;   floatReward += (accumDeltaShort * amountStakedShort) / FLOAT_ISSUANCE_FIXED_DECIMAL; }  } /*    @notice Calculates float owed to the user since the user last minted float for a market.   @param marketIndex Identifier for the market which the user staked in.   @param user The address of the user.   @return floatReward The amount of float owed.    /   function _calculateAccumulatedFloat(uint32 marketIndex, address user) internal virtual returns (uint256 floatReward) {     address longToken = syntheticTokens[marketIndex][true];     address shortToken = syntheticTokens[marketIndex][false]; uint256 amountStakedLong = userAmountStaked[longToken][user]; uint256 amountStakedShort = userAmountStaked[shortToken][user];  uint256 usersLastRewardIndex = userIndexOfLastClaimedReward[marketIndex][user];  // Don't do the calculation and return zero immediately if there is no change if (usersLastRewardIndex == latestRewardIndex[marketIndex]) {   return 0; }  uint256 usersShiftIndex = userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][user]; // if there is a change in the users tokens held due to a token shift (or possibly another action in the future) if (usersShiftIndex &gt; 0 &amp;&amp; usersShiftIndex &lt; batched_stakerNextTokenShiftIndex[marketIndex]) {   floatReward = _calculateAccumulatedFloatInRange(     marketIndex,     amountStakedLong,     amountStakedShort,     usersLastRewardIndex,     stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[usersShiftIndex]   );    // Update the users balances   if (userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user] &gt; 0) {     amountStakedShort += ILongShort(longShort).getAmountSyntheticTokenToMintOnTargetSide(       marketIndex,       userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user],       true,       stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[usersShiftIndex]     );      amountStakedLong -= userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user];     userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user] = 0;   }    if (userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user] &gt; 0) {     amountStakedLong += ILongShort(longShort).getAmountSyntheticTokenToMintOnTargetSide(       marketIndex,       userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user],       false,       stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[usersShiftIndex]     );      amountStakedShort -= userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user];     userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user] = 0;   }    // Save the users updated staked amounts   userAmountStaked[longToken][user] = amountStakedLong;   userAmountStaked[shortToken][user] = amountStakedShort;    floatReward += _calculateAccumulatedFloatInRange(     marketIndex,     amountStakedLong,     amountStakedShort,     stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[usersShiftIndex],     latestRewardIndex[marketIndex]   );    userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][user] = 0; } else {   floatReward = _calculateAccumulatedFloatInRange(     marketIndex,     amountStakedLong,     amountStakedShort,     usersLastRewardIndex,     latestRewardIndex[marketIndex]   ); }  } /*   @notice Mints float for a user.   @dev Mints a fixed percentage for Float capital.   @param user The address of the user.   @param floatToMint The amount of float to mint.    /   function _mintFloat(address user, uint256 floatToMint) internal virtual {     IFloatToken(floatToken).mint(user, floatToMint);     IFloatToken(floatToken).mint(floatCapital, (floatToMint * floatPercentage) / 1e18);   } /*   @notice Mints float owed to a user for a market since they last minted.   @param marketIndex An identifier for the market.   @param user The address of the user.    /   function _mintAccumulatedFloat(uint32 marketIndex, address user) internal virtual {     uint256 floatToMint = _calculateAccumulatedFloat(marketIndex, user); if (floatToMint &gt; 0) {   // Set the user has claimed up until now, stops them setting this forward   userIndexOfLastClaimedReward[marketIndex][user] = latestRewardIndex[marketIndex];    _mintFloat(user, floatToMint);   emit FloatMinted(user, marketIndex, floatToMint); }  } /*   @notice Mints float owed to a user for multiple markets, since they last minted for those markets.   @param marketIndexes Identifiers for the markets.   @param user The address of the user.    /   function _mintAccumulatedFloatMulti(uint32[] calldata marketIndexes, address user) internal virtual {     uint256 floatTotal = 0;     for (uint256 i = 0; i &lt; marketIndexes.length; i++) {       uint256 floatToMint = _calculateAccumulatedFloat(marketIndexes[i], user);   if (floatToMint &gt; 0) {     // Set the user has claimed up until now, stops them setting this forward     userIndexOfLastClaimedReward[marketIndexes[i]][user] = latestRewardIndex[marketIndexes[i]];      floatTotal += floatToMint;      emit FloatMinted(user, marketIndexes[i], floatToMint);   } } if (floatTotal &gt; 0) {   _mintFloat(user, floatTotal); }  } /*   @notice Mints outstanding float for msg.sender.   @param marketIndexes Identifiers for the markets for which to mint float.    /   function claimFloatCustom(uint32[] calldata marketIndexes) external {     ILongShort(longShort).updateSystemStateMulti(marketIndexes);     _mintAccumulatedFloatMulti(marketIndexes, msg.sender);   } /*   @notice Mints outstanding float on behalf of another user.   @param marketIndexes Identifiers for the markets for which to mint float.   @param user The address of the user.    /   function claimFloatCustomFor(uint32[] calldata marketIndexes, address user) external {     // Unbounded loop - users are responsible for paying their own gas costs on these and it doesn't effect the rest of the system.     // No need to impose limit.     ILongShort(longShort).updateSystemStateMulti(marketIndexes);     _mintAccumulatedFloatMulti(marketIndexes, user);   } /╔═══════════════════════╗     ║        STAKING        ║     ╚═══════════════════════╝/ /*   @notice A user with synthetic tokens stakes by calling stake on the token   contract which calls this function. We need to first update the   state of the LongShort contract for this market before staking to correctly calculate user rewards.   @param amount Amount to stake.   @param from Address to stake for.   /   function stakeFromUser(address from, uint256 amount) public virtual override onlyValidSynthetic((msg.sender)) {     ILongShort(longShort).updateSystemState(marketIndexOfToken[(msg.sender)]);     _stake((msg.sender), amount, from);   } /*   @dev Internal logic for staking.   @param token Address of the token for which to stake.   @param amount Amount to stake.   @param user Address to stake for.   /   function _stake(     address token,     uint256 amount,     address user   ) internal virtual {     uint32 marketIndex = marketIndexOfToken[token]; // If they already have staked and have rewards due, mint these. if (   userIndexOfLastClaimedReward[marketIndex][user] != 0 &amp;&amp;   userIndexOfLastClaimedReward[marketIndex][user] &lt; latestRewardIndex[marketIndex] ) {   _mintAccumulatedFloat(marketIndex, user); }  userAmountStaked[token][user] = userAmountStaked[token][user] + amount;  userIndexOfLastClaimedReward[marketIndex][user] = latestRewardIndex[marketIndex];  emit StakeAdded(user, address(token), amount, userIndexOfLastClaimedReward[marketIndex][user]);  } /*   @notice Allows users to shift their staked tokens from one side of the market to    the other at the next price.   @param amountSyntheticTokensToShift Amount of tokens to shift.   @param marketIndex Identifier for the market.   @param isShiftFromLong Whether the shift is from long to short or short to long.   /   function shiftTokens(     uint256 amountSyntheticTokensToShift,     uint32 marketIndex,     bool isShiftFromLong   ) external virtual {     address token = syntheticTokens[marketIndex][isShiftFromLong];     require(userAmountStaked[token][msg.sender] &gt;= amountSyntheticTokensToShift, "Not enough tokens to shift"); // If the user has outstanding token shift that have already been confirmed in the LongShort // contract, execute them first. if (   userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] != 0 &amp;&amp;   userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] &lt;   batched_stakerNextTokenShiftIndex[marketIndex] ) {   _mintAccumulatedFloat(marketIndex, msg.sender); }  if (isShiftFromLong) {   ILongShort(longShort).shiftPositionFromLongNextPrice(marketIndex, amountSyntheticTokensToShift);   userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][     msg.sender   ] += amountSyntheticTokensToShift; } else {   ILongShort(longShort).shiftPositionFromShortNextPrice(marketIndex, amountSyntheticTokensToShift);   userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][     msg.sender   ] += amountSyntheticTokensToShift; }  userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] = batched_stakerNextTokenShiftIndex[   marketIndex ];  } /╔════════════════════════════╗     ║    WITHDRAWAL &amp; MINTING    ║     ╚════════════════════════════╝/ /*   @notice Internal logic for withdrawing stakes.   @dev Mint user any outstanding float before withdrawing.   @param marketIndex Market index of token.   @param amount Amount to withdraw.   @param token Synthetic token that was staked.   /   function _withdraw(     uint32 marketIndex,     address token,     uint256 amount   ) internal virtual {     require(userAmountStaked[token][msg.sender] &gt; 0, "nothing to withdraw");     _mintAccumulatedFloat(marketIndex, msg.sender); userAmountStaked[token][msg.sender] = userAmountStaked[token][msg.sender] - amount;  uint256 amountFees = (amount * marketUnstakeFee_e18[marketIndex]) / 1e18;  IERC20(token).transfer(floatTreasury, amountFees); IERC20(token).transfer(msg.sender, amount - amountFees);  emit StakeWithdrawn(msg.sender, token, amount);  } /*   @notice Withdraw function. Allows users to unstake.   @param amount Amount to withdraw.   @param token Address of the token for which to withdraw.   /   function withdraw(address token, uint256 amount) external {     ILongShort(longShort).updateSystemState(marketIndexOfToken[token]); uint32 marketIndex = marketIndexOfToken[token];  _withdraw(marketIndex, token, amount);  if (userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] &gt; 0) {   // If they still have outstanding shifts after minting float, then check   // that they don't withdraw more than their shifts allow.   uint256 amountToShiftForThisToken = syntheticTokens[marketIndex][true] == token     ? userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][msg.sender]     : userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][msg.sender];    require(     userAmountStaked[token][msg.sender] &gt;= amountToShiftForThisToken,     "Outstanding next price stake shifts too great"   ); }  } /*   @notice Allows users to withdraw their entire stake for a token.   @param token Address of the token for which to withdraw.   /   function withdrawAll(address token) external {     ILongShort(longShort).updateSystemState(marketIndexOfToken[token]); uint32 marketIndex = marketIndexOfToken[token];  uint256 amountToShiftForThisToken = syntheticTokens[marketIndex][true] == token   ? userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][msg.sender]   : userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][msg.sender];  _withdraw(marketIndex, token, userAmountStaked[token][msg.sender] - amountToShiftForThisToken);  } } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: "{task}". Ideas: "{ideas}". As the {assistant_role}, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability. For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix. Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: " Analysis Complete." |
| **phase_name** | ContractReviewComment |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 1, 'task': '// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.3;\n\nimport "@openzeppelin/contracts-upgradeable/token/ERC20/presets/ERC20PresetMinterPauserUpgradeable.sol";\n\nimport "./interfaces/IFloatToken.sol";\nimport "./interfaces/ILongShort.sol";\nimport "./interfaces/IStaker.sol";\nimport "./interfaces/ISyntheticToken.sol";\n\ncontract Staker is IStaker, Initializable {\n  /╔═════════════════════════════╗\n    ║          VARIABLES          ║\n    ╚═════════════════════════════╝/\n\n  / ══════ Fixed-precision constants ══════ /\n  uint256 public constant FLOAT_ISSUANCE_FIXED_DECIMAL = 1e42;\n  // 2^52 ~= 4.5e15\n  // With an exponent of 5, the largest total liquidity possible in a market (to avoid integer overflow on exponentiation) is ~10^31 or 10 Trillion (10^13)\n  // NOTE: this also means if the total market value is less than 2^52 there will be a division by zero error\n  uint256 public constant safeExponentBitShifting = 52;\n\n  / ══════ Global state ══════ /\n  address public admin;\n  address public floatCapital;\n  address public floatTreasury;\n  uint256 public floatPercentage;\n\n  address public longShort;\n  address public floatToken;\n\n  / ══════ Market specific ══════ /\n  mapping(uint32 =&gt; uint256) public marketLaunchIncentive_period; // seconds\n  mapping(uint32 =&gt; uint256) public marketLaunchIncentive_multipliers; // e18 scale\n  mapping(uint32 =&gt; uint256) public marketUnstakeFee_e18;\n  mapping(uint32 =&gt; uint256) public balanceIncentiveCurve_exponent;\n  mapping(uint32 =&gt; int256) public balanceIncentiveCurve_equilibriumOffset;\n\n  mapping(uint32 =&gt; mapping(bool =&gt; address)) public syntheticTokens;\n\n  mapping(address =&gt; uint32) public marketIndexOfToken;\n\n  / ══════ Reward specific ══════ /\n  mapping(uint32 =&gt; uint256) public latestRewardIndex;\n  mapping(uint32 =&gt; mapping(uint256 =&gt; AccumulativeIssuancePerStakedSynthSnapshot))\n    public accumulativeFloatPerSyntheticTokenSnapshots;\n  struct AccumulativeIssuancePerStakedSynthSnapshot {\n    uint256 timestamp;\n    uint256 accumulativeFloatPerSyntheticToken_long;\n    uint256 accumulativeFloatPerSyntheticToken_short;\n  }\n\n  / ══════ User specific ══════ /\n  mapping(uint32 =&gt; mapping(address =&gt; uint256)) public userIndexOfLastClaimedReward;\n  mapping(address =&gt; mapping(address =&gt; uint256)) public userAmountStaked;\n\n  / ══════ Token shift management specific ══════ /\n  mapping(uint32 =&gt; uint256) public batched_stakerNextTokenShiftIndex;\n  /\n  @notice Used to link a token shift to a staker state\n  @dev tokenShiftIndex =&gt; accumulativeFloatIssuanceSnapshotIndex\n    POSSIBLE OPTIMIZATION - could pack stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping and stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping into a struct of two uint128 for storage space optimization.\n  /\n  mapping(uint256 =&gt; uint256) public stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping;\n  /// @notice Used to fetch the price from LongShort at that point in time\n  /// @dev tokenShiftIndex =&gt; longShortMarketPriceSnapshotIndex\n  mapping(uint256 =&gt; uint256) public stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping;\n  /// @dev marketIndex =&gt; usersAddress =&gt; stakerTokenShiftIndex\n  mapping(uint32 =&gt; mapping(address =&gt; uint256)) public userNextPrice_stakedSyntheticTokenShiftIndex;\n  /// @dev marketIndex =&gt; usersAddress =&gt; amountUserRequestedToShiftAwayFromLongOnNextUpdate\n  mapping(uint32 =&gt; mapping(address =&gt; uint256)) public userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long;\n  /// @dev marketIndex =&gt; usersAddress =&gt; amountUserRequestedToShiftAwayFromShortOnNextUpdate\n  mapping(uint32 =&gt; mapping(address =&gt; uint256)) public userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short;\n\n  /╔════════════════════════════╗\n    ║           EVENTS           ║\n    ╚════════════════════════════╝/\n\n  event StakerV1(\n    address admin,\n    address floatTreasury,\n    address floatCapital,\n    address floatToken,\n    uint256 floatPercentage\n  );\n\n  event MarketAddedToStaker(\n    uint32 marketIndex,\n    uint256 exitFee_e18,\n    uint256 period,\n    uint256 multiplier,\n    uint256 balanceIncentiveExponent,\n    int256 balanceIncentiveEquilibriumOffset\n  );\n\n  event AccumulativeIssuancePerStakedSynthSnapshotCreated(\n    uint32 marketIndex,\n    uint256 accumulativeFloatIssuanceSnapshotIndex,\n    uint256 accumulativeLong,\n    uint256 accumulativeShort\n  );\n\n  event StakeAdded(address user, address token, uint256 amount, uint256 lastMintIndex);\n\n  event StakeWithdrawn(address user, address token, uint256 amount);\n\n  // Note: the amountFloatMinted isn\'t strictly needed by the graph, but it is good to add it to validate calculations are accurate.\n  event FloatMinted(address user, uint32 marketIndex, uint256 amountFloatMinted);\n\n  event MarketLaunchIncentiveParametersChanges(uint32 marketIndex, uint256 period, uint256 multiplier);\n\n  event StakeWithdrawalFeeUpdated(uint32 marketIndex, uint256 stakeWithdralFee);\n\n  event BalanceIncentiveExponentUpdated(uint32 marketIndex, uint256 balanceIncentiveExponent);\n\n  event BalanceIncentiveEquilibriumOffsetUpdated(uint32 marketIndex, int256 balanceIncentiveEquilibriumOffset);\n\n  event FloatPercentageUpdated(uint256 floatPercentage);\n\n  event SyntheticTokensShifted();\n\n  event ChangeAdmin(address newAdmin);\n\n  /╔═════════════════════════════╗\n    ║          MODIFIERS          ║\n    ╚═════════════════════════════╝/\n\n  function onlyAdminModifierLogic() internal virtual {\n    require(msg.sender == admin, "not admin");\n  }\n\n  modifier onlyAdmin() {\n    onlyAdminModifierLogic();\n    ;\n  }\n\n  function onlyValidSyntheticModifierLogic(address _synth) internal virtual {\n    require(marketIndexOfToken[_synth] != 0, "not valid synth");\n  }\n\n  modifier onlyValidSynthetic(address _synth) {\n    onlyValidSyntheticModifierLogic(_synth);\n    ;\n  }\n\n  function onlyValidMarketModifierLogic(uint32 marketIndex) internal virtual {\n    require(address(syntheticTokens[marketIndex][true]) != address(0), "not valid market");\n  }\n\n  modifier onlyValidMarket(uint32 marketIndex) {\n    onlyValidMarketModifierLogic(marketIndex);\n    ;\n  }\n\n  function onlyLongShortModifierLogic() internal virtual {\n    require(msg.sender == address(longShort), "not long short");\n  }\n\n  modifier onlyLongShort() {\n    onlyLongShortModifierLogic();\n    ;\n  }\n\n  /╔═════════════════════════════╗\n    ║       CONTRACT SET-UP       ║\n    ╚═════════════════════════════╝*/\n\n  /\n  @notice Initializes the contract.\n  @dev Calls OpenZeppelin\'s initializer modifier.\n  @param _admin Address of the admin role.\n  @param _longShort Address of the LongShort contract, a deployed LongShort.sol\n  @param _floatToken Address of the Float token earned by staking.\n  @param _floatTreasury Address of the treasury contract for managing fees.\n  @param _floatCapital Address of the contract which earns a fixed percentage of Float.\n  @param _floatPercentage Determines the float percentage that gets minted for Float Capital, base 1e18.\n  /\n  function initialize(\n    address _admin,\n    address _longShort,\n    address _floatToken,\n    address _floatTreasury,\n    address _floatCapital,\n    uint256 _floatPercentage\n  ) external virtual initializer {\n    admin = _admin;\n    floatCapital = _floatCapital;\n    floatTreasury = _floatTreasury;\n    longShort = _longShort;\n    floatToken = _floatToken;\n\n    _changeFloatPercentage(_floatPercentage);\n\n    emit StakerV1(_admin, _floatTreasury, _floatCapital, _floatToken, _floatPercentage);\n  }\n\n  /╔═══════════════════╗\n    ║       ADMIN       ║\n    ╚═══════════════════╝/\n\n  / \n  @notice Changes admin for the contract\n  @param _admin The address of the new admin.\n  /\n  function changeAdmin(address _admin) external onlyAdmin {\n    admin = _admin;\n    emit ChangeAdmin(_admin);\n  }\n\n  /// @dev Logic for changeFloatPercentage\n  function _changeFloatPercentage(uint256 newFloatPercentage) internal virtual {\n    require(newFloatPercentage &lt;= 1e18 &amp;&amp; newFloatPercentage &gt; 0); // less than or equal to 100% and greater than 0%\n    floatPercentage = newFloatPercentage;\n  }\n\n  /\n  @notice Changes percentage of float that is minted for float capital.\n  @param newFloatPercentage The new float percentage in base 1e18.\n  */\n  function changeFloatPercentage(uint256 newFloatPercentage) external onlyAdmin {\n    _changeFloatPercentage(newFloatPercentage);\n    emit FloatPercentageUpdated(newFloatPercentage);\n  }\n\n  /// @dev Logic for changeUnstakeFee\n  function _changeUnstakeFee(uint32 marketIndex, uint256 newMarketUnstakeFee_e18) internal virtual {\n    require(newMarketUnstakeFee_e18 &lt;= 5e16); // Explicitely stating 5% fee as the max fee possible.\n    marketUnstakeFee_e18[marketIndex] = newMarketUnstakeFee_e18;\n  }\n\n  /\n  @notice Changes unstake fee for a market\n  @param marketIndex Identifies the market.\n  @param newMarketUnstakeFee_e18 The new unstake fee.\n  /\n  function changeUnstakeFee(uint32 marketIndex, uint256 newMarketUnstakeFee_e18) external onlyAdmin {\n    _changeUnstakeFee(marketIndex, newMarketUnstakeFee_e18);\n    emit StakeWithdrawalFeeUpdated(marketIndex, newMarketUnstakeFee_e18);\n  }\n\n  /// @dev Logic for changeMarketLaunchIncentiveParameters\n  function _changeMarketLaunchIncentiveParameters(\n    uint32 marketIndex,\n    uint256 period,\n    uint256 initialMultiplier\n  ) internal virtual {\n    require(initialMultiplier &gt;= 1e18, "marketLaunchIncentiveMultiplier must be &gt;= 1e18");\n\n    marketLaunchIncentive_period[marketIndex] = period;\n    marketLaunchIncentive_multipliers[marketIndex] = initialMultiplier;\n  }\n\n  /\n  @notice Changes the market launch incentive parameters for a market\n  @param marketIndex Identifies the market.\n  @param period The new period for which float token generation should be boosted.\n  @param initialMultiplier The new multiplier on Float generation.\n  /\n  function changeMarketLaunchIncentiveParameters(\n    uint32 marketIndex,\n    uint256 period,\n    uint256 initialMultiplier\n  ) external onlyAdmin {\n    _changeMarketLaunchIncentiveParameters(marketIndex, period, initialMultiplier);\n\n    emit MarketLaunchIncentiveParametersChanges(marketIndex, period, initialMultiplier);\n  }\n\n  /// @dev Logic for changeBalanceIncentiveExponent\n  function _changeBalanceIncentiveExponent(uint32 marketIndex, uint256 _balanceIncentiveCurve_exponent)\n    internal\n    virtual\n  {\n    require(\n      // The exponent has to be less than 5 in these versions of the contracts.\n      _balanceIncentiveCurve_exponent &gt; 0 &amp;&amp; _balanceIncentiveCurve_exponent &lt; 6,\n      "balanceIncentiveCurve_exponent out of bounds"\n    );\n\n    balanceIncentiveCurve_exponent[marketIndex] = _balanceIncentiveCurve_exponent;\n  }\n\n  / \n  @notice Changes the balance incentive exponent for a market\n  @param marketIndex Identifies the market.\n  @param _balanceIncentiveCurve_exponent The new exponent for the curve.\n  */\n  function changeBalanceIncentiveExponent(uint32 marketIndex, uint256 _balanceIncentiveCurve_exponent)\n    external\n    onlyAdmin\n  {\n    _changeBalanceIncentiveExponent(marketIndex, _balanceIncentiveCurve_exponent);\n\n    emit BalanceIncentiveExponentUpdated(marketIndex, _balanceIncentiveCurve_exponent);\n  }\n\n  /// @dev Logic for changeBalanceIncentiveEquilibriumOffset\n  function _changeBalanceIncentiveEquilibriumOffset(uint32 marketIndex, int256 _balanceIncentiveCurve_equilibriumOffset)\n    internal\n    virtual\n  {\n    // Unreasonable that we would ever shift this more than 90% either way\n    require(\n      _balanceIncentiveCurve_equilibriumOffset &gt; -9e17 &amp;&amp; _balanceIncentiveCurve_equilibriumOffset &lt; 9e17,\n      "balanceIncentiveCurve_equilibriumOffset out of bounds"\n    );\n\n    balanceIncentiveCurve_equilibriumOffset[marketIndex] = _balanceIncentiveCurve_equilibriumOffset;\n  }\n\n  /\n  @notice Changes the balance incentive curve equilibrium offset for a market\n  @param marketIndex Identifies the market.\n  @param _balanceIncentiveCurve_equilibriumOffset The new offset.\n  /\n  function changeBalanceIncentiveEquilibriumOffset(uint32 marketIndex, int256 _balanceIncentiveCurve_equilibriumOffset)\n    external\n    onlyAdmin\n  {\n    _changeBalanceIncentiveEquilibriumOffset(marketIndex, _balanceIncentiveCurve_equilibriumOffset);\n\n    emit BalanceIncentiveEquilibriumOffsetUpdated(marketIndex, _balanceIncentiveCurve_equilibriumOffset);\n  }\n\n  /╔═════════════════════════════╗\n    ║        STAKING SETUP        ║\n    ╚═════════════════════════════╝/\n\n  /\n  @notice Sets this contract to track staking for a market in LongShort.sol\n  @param marketIndex Identifies the market.\n  @param longToken Address of the long token for the market.\n  @param shortToken Address of the short token for the market.\n  @param kInitialMultiplier Initial boost on float generation for the market.\n  @param kPeriod Period which the boost should last.\n  @param unstakeFee_e18 Percentage of tokens that are levied on unstaking in base 1e18.\n  @param _balanceIncentiveCurve_exponent Exponent for balance curve (see _calculateFloatPerSecond)\n  @param _balanceIncentiveCurve_equilibriumOffset Offset for balance curve (see _calculateFloatPerSecond)\n  /\n  function addNewStakingFund(\n    uint32 marketIndex,\n    address longToken,\n    address shortToken,\n    uint256 kInitialMultiplier,\n    uint256 kPeriod,\n    uint256 unstakeFee_e18,\n    uint256 _balanceIncentiveCurve_exponent,\n    int256 _balanceIncentiveCurve_equilibriumOffset\n  ) external override onlyLongShort {\n    marketIndexOfToken[longToken] = marketIndex;\n    marketIndexOfToken[shortToken] = marketIndex;\n\n    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].timestamp = block.timestamp;\n    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].accumulativeFloatPerSyntheticToken_long = 0;\n    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].accumulativeFloatPerSyntheticToken_short = 0;\n\n    syntheticTokens[marketIndex][true] = longToken;\n    syntheticTokens[marketIndex][false] = shortToken;\n\n    _changeBalanceIncentiveExponent(marketIndex, _balanceIncentiveCurve_exponent);\n    _changeBalanceIncentiveEquilibriumOffset(marketIndex, _balanceIncentiveCurve_equilibriumOffset);\n    _changeMarketLaunchIncentiveParameters(marketIndex, kPeriod, kInitialMultiplier);\n\n    _changeUnstakeFee(marketIndex, unstakeFee_e18);\n\n    // Set this value to one initially - 0 is a null value and thus potentially bug prone.\n    batched_stakerNextTokenShiftIndex[marketIndex] = 1;\n\n    emit MarketAddedToStaker(\n      marketIndex,\n      unstakeFee_e18,\n      kPeriod,\n      kInitialMultiplier,\n      _balanceIncentiveCurve_exponent,\n      _balanceIncentiveCurve_equilibriumOffset\n    );\n\n    emit AccumulativeIssuancePerStakedSynthSnapshotCreated(marketIndex, 0, 0, 0);\n  }\n\n  /╔═════════════════════════════════════════════════════════════════════════╗\n    ║    GLOBAL FLT REWARD ACCUMULATION CALCULATION AND TRACKING FUNCTIONS    ║\n    ╚═════════════════════════════════════════════════════════════════════════╝/\n\n  /\n  @notice Returns the K factor parameters for the given market with sensible\n  defaults if they haven\'t been set yet.\n  @param marketIndex The market to change the parameters for.\n  @return period The period for which the k factor applies for in seconds.\n  @return multiplier The multiplier on Float generation in this period.\n  */\n  function _getMarketLaunchIncentiveParameters(uint32 marketIndex)\n    internal\n    view\n    virtual\n    returns (uint256 period, uint256 multiplier)\n  {\n    period = marketLaunchIncentive_period[marketIndex];\n    multiplier = marketLaunchIncentive_multipliers[marketIndex];\n\n    if (multiplier &lt; 1e18) {\n      multiplier = 1e18; // multiplier of 1 by default\n    }\n  }\n\n  / \n  @notice Returns the extent to which a markets float generation should be adjusted\n  based on the market\'s launch incentive parameters. Should start at multiplier\n  then linearly change to 1e18 over time.\n  @param marketIndex Identifies the market.\n  @return k The calculated modifier for float generation.\n  /\n  function _getKValue(uint32 marketIndex) internal view virtual returns (uint256) {\n    // Parameters controlling the float issuance multiplier.\n    (uint256 kPeriod, uint256 kInitialMultiplier) = _getMarketLaunchIncentiveParameters(marketIndex);\n\n    // Sanity check - under normal circumstances, the multipliers should\n    // never be set to a value &lt; 1e18, as there are guards against this.\n    assert(kInitialMultiplier &gt;= 1e18);\n\n    uint256 initialTimestamp = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].timestamp;\n\n    if (block.timestamp - initialTimestamp &lt;= kPeriod) {\n      return kInitialMultiplier - (((kInitialMultiplier - 1e18) * (block.timestamp - initialTimestamp)) / kPeriod);\n    } else {\n      return 1e18;\n    }\n  }\n\n  /\n  @notice Computes the number of float tokens a user earns per second for\n  every long/short synthetic token they\'ve staked. The returned value has\n  a fixed decimal scale of 1e42 (!!!) for numerical stability. The return\n  values are float per second per synthetic token (hence the requirement\n  to multiply by price)\n  @dev to see below math in latex form see TODO add link\n  to interact with the equations see https://www.desmos.com/calculator/optkaxyihr\n  @param marketIndex The market referred to.\n  @param longPrice Price of the synthetic long token in units of payment token\n  @param shortPrice Price of the synthetic short token in units of payment token\n  @param longValue Amount of payment token in the long side of the market\n  @param shortValue Amount of payment token in the short side of the market\n  @return longFloatPerSecond Float token per second per long synthetic token\n  @return shortFloatPerSecond Float token per second per short synthetic token\n   /\n  function _calculateFloatPerSecond(\n    uint32 marketIndex,\n    uint256 longPrice,\n    uint256 shortPrice,\n    uint256 longValue,\n    uint256 shortValue\n  ) internal view virtual returns (uint256 longFloatPerSecond, uint256 shortFloatPerSecond) {\n    // A float issuance multiplier that starts high and decreases linearly\n    // over time to a value of 1. This incentivises users to stake early.\n    uint256 k = _getKValue(marketIndex);\n\n    uint256 totalLocked = (longValue + shortValue);\n\n    // we need to scale this number by the totalLocked so that the offset remains consistent accross market size\n\n    int256 equilibriumOffsetMarketScaled = (balanceIncentiveCurve_equilibriumOffset[marketIndex] \n      int256(totalLocked)) / 2e18;\n\n    uint256 denominator = ((totalLocked &gt;&gt; safeExponentBitShifting)balanceIncentiveCurve_exponent[marketIndex]);\n\n    // Float is scaled by the percentage of the total market value held in\n    // the opposite position. This incentivises users to stake on the\n    // weaker position.\n    if (int256(shortValue) - equilibriumOffsetMarketScaled &lt; int256(longValue)) {\n      if (equilibriumOffsetMarketScaled &gt;= int256(shortValue)) {\n        // edge case: imbalanced far past the equilibrium offset - full rewards go to short token\n        //            extremeley unlikely to happen in practice\n        return (0, 1e18 * k * shortPrice);\n      }\n\n      uint256 numerator = (uint256(int256(shortValue) - equilibriumOffsetMarketScaled) &gt;&gt;\n        (safeExponentBitShifting - 1))balanceIncentiveCurve_exponent[marketIndex];\n\n      // NOTE: x * 5e17 == (x * 10e18) / 2\n      uint256 longRewardUnscaled = (numerator * 5e17) / denominator;\n      uint256 shortRewardUnscaled = 1e18 - longRewardUnscaled;\n\n      return ((longRewardUnscaled * k * longPrice) / 1e18, (shortRewardUnscaled * k * shortPrice) / 1e18);\n    } else {\n      if (-equilibriumOffsetMarketScaled &gt;= int256(longValue)) {\n        // edge case: imbalanced far past the equilibrium offset - full rewards go to long token\n        //            extremeley unlikely to happen in practice\n        return (1e18 * k * longPrice, 0);\n      }\n\n      uint256 numerator = (uint256(int256(longValue) + equilibriumOffsetMarketScaled) &gt;&gt;\n        (safeExponentBitShifting - 1))balanceIncentiveCurve_exponent[marketIndex];\n\n      // NOTE: x * 5e17 == (x * 10e18) / 2\n      uint256 shortRewardUnscaled = (numerator * 5e17) / denominator;\n      uint256 longRewardUnscaled = 1e18 - shortRewardUnscaled;\n\n      return ((longRewardUnscaled * k * longPrice) / 1e18, (shortRewardUnscaled * k * shortPrice) / 1e18);\n    }\n  }\n\n  /\n  @notice Computes the time since last accumulativeIssuancePerStakedSynthSnapshot for the given market in seconds.\n  @param marketIndex The market referred to.\n  @return The time difference in seconds\n  /\n  function _calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(uint32 marketIndex)\n    internal\n    view\n    virtual\n    returns (uint256)\n  {\n    return\n      block.timestamp -\n      accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]].timestamp;\n  }\n\n  /\n  @notice Computes new cumulative sum of \'r\' value since last accumulativeIssuancePerStakedSynthSnapshot. We use\n  cumulative \'r\' value to avoid looping during issuance. Note that the\n  cumulative sum is kept in 1e42 scale (!!!) to avoid numerical issues.\n  @param shortValue The value locked in the short side of the market.\n  @param longValue The value locked in the long side of the market.\n  @param shortPrice The price of the short token as defined in LongShort.sol\n  @param longPrice The price of the long token as defined in LongShort.sol\n  @param marketIndex An identifier for the market.\n  @return longCumulativeRates The long cumulative sum.\n  @return shortCumulativeRates The short cumulative sum.\n  /\n  function _calculateNewCumulativeIssuancePerStakedSynth(\n    uint32 marketIndex,\n    uint256 longPrice,\n    uint256 shortPrice,\n    uint256 longValue,\n    uint256 shortValue\n  ) internal view virtual returns (uint256 longCumulativeRates, uint256 shortCumulativeRates) {\n    // Compute the current \'r\' value for float issuance per second.\n    (uint256 longFloatPerSecond, uint256 shortFloatPerSecond) = _calculateFloatPerSecond(\n      marketIndex,\n      longPrice,\n      shortPrice,\n      longValue,\n      shortValue\n    );\n\n    // Compute time since last accumulativeIssuancePerStakedSynthSnapshot for the given token.\n    uint256 timeDelta = _calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(marketIndex);\n\n    // Compute new cumulative \'r\' value total.\n    return (\n      accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]]\n      .accumulativeFloatPerSyntheticToken_long + (timeDelta * longFloatPerSecond),\n      accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]]\n      .accumulativeFloatPerSyntheticToken_short + (timeDelta * shortFloatPerSecond)\n    );\n  }\n\n  /\n  @notice Creates a new accumulativeIssuancePerStakedSynthSnapshot for the given token and updates indexes.\n  @param shortValue The value locked in the short side of the market.\n  @param longValue The value locked in the long side of the market.\n  @param shortPrice The price of the short token as defined in LongShort.sol\n  @param longPrice The price of the long token as defined in LongShort.sol\n  @param marketIndex An identifier for the market.\n  */\n  function _setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot(\n    uint32 marketIndex,\n    uint256 longPrice,\n    uint256 shortPrice,\n    uint256 longValue,\n    uint256 shortValue\n  ) internal virtual {\n    (\n      uint256 newLongAccumulativeValue,\n      uint256 newShortAccumulativeValue\n    ) = _calculateNewCumulativeIssuancePerStakedSynth(marketIndex, longPrice, shortPrice, longValue, shortValue);\n\n    uint256 newIndex = latestRewardIndex[marketIndex] + 1;\n\n    // Set cumulative \'r\' value on new accumulativeIssuancePerStakedSynthSnapshot.\n    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex]\n    .accumulativeFloatPerSyntheticToken_long = newLongAccumulativeValue;\n    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex]\n    .accumulativeFloatPerSyntheticToken_short = newShortAccumulativeValue;\n\n    // Set timestamp on new accumulativeIssuancePerStakedSynthSnapshot.\n    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex].timestamp = block.timestamp;\n\n    // Update latest index to point to new accumulativeIssuancePerStakedSynthSnapshot.\n    latestRewardIndex[marketIndex] = newIndex;\n\n    emit AccumulativeIssuancePerStakedSynthSnapshotCreated(\n      marketIndex,\n      newIndex,\n      newLongAccumulativeValue,\n      newShortAccumulativeValue\n    );\n  }\n\n  /\n  @notice Adds new accumulativeIssuancePerStakedSynthSnapshots for the given long/short tokens. Called by the\n  ILongShort contract whenever there is a state change for a market.\n  @param stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted Mapping from this contract\'s shifts to LongShort.sols next price snapshots.\n  @param shortValue The value locked in the short side of the market.\n  @param longValue The value locked in the long side of the market.\n  @param shortPrice The price of the short token as defined in LongShort.sol\n  @param longPrice The price of the long token as defined in LongShort.sol\n  @param marketIndex An identifier for the market.\n  /\n  function pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(\n    uint32 marketIndex,\n    uint256 longPrice,\n    uint256 shortPrice,\n    uint256 longValue,\n    uint256 shortValue,\n    uint256 stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted // This value should be ALWAYS be zero if no shift occured\n  ) external override onlyLongShort {\n    // Only add a new accumulativeIssuancePerStakedSynthSnapshot if some time has passed.\n\n    // the stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted value will be 0 if there is no staker related action in an executed batch\n    if (stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted &gt; 0) {\n      stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[\n        batched_stakerNextTokenShiftIndex[marketIndex]\n      ] = stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted;\n      stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[\n        batched_stakerNextTokenShiftIndex[marketIndex]\n      ] = latestRewardIndex[marketIndex] + 1;\n      batched_stakerNextTokenShiftIndex[marketIndex] += 1;\n\n      emit SyntheticTokensShifted();\n    }\n\n    // Time delta is fetched twice in below code, can pass through? Which is less gas?\n    if (_calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(marketIndex) &gt; 0) {\n      _setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot(\n        marketIndex,\n        longPrice,\n        shortPrice,\n        longValue,\n        shortValue\n      );\n    }\n  }\n\n  /╔═══════════════════════════════════╗\n    ║    USER REWARD STATE FUNCTIONS    ║\n    ╚═══════════════════════════════════╝/\n\n  /// @dev Calculates the accumulated float in a specific range of staker snapshots\n  function _calculateAccumulatedFloatInRange(\n    uint32 marketIndex,\n    uint256 amountStakedLong,\n    uint256 amountStakedShort,\n    uint256 rewardIndexFrom,\n    uint256 rewardIndexTo\n  ) internal view virtual returns (uint256 floatReward) {\n    if (amountStakedLong &gt; 0) {\n      uint256 accumDeltaLong = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexTo]\n      .accumulativeFloatPerSyntheticToken_long -\n        accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexFrom]\n        .accumulativeFloatPerSyntheticToken_long;\n      floatReward += (accumDeltaLong * amountStakedLong) / FLOAT_ISSUANCE_FIXED_DECIMAL;\n    }\n\n    if (amountStakedShort &gt; 0) {\n      uint256 accumDeltaShort = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexTo]\n      .accumulativeFloatPerSyntheticToken_short -\n        accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexFrom]\n        .accumulativeFloatPerSyntheticToken_short;\n      floatReward += (accumDeltaShort * amountStakedShort) / FLOAT_ISSUANCE_FIXED_DECIMAL;\n    }\n  }\n\n  / \n  @notice Calculates float owed to the user since the user last minted float for a market.\n  @param marketIndex Identifier for the market which the user staked in.\n  @param user The address of the user.\n  @return floatReward The amount of float owed.\n   /\n  function _calculateAccumulatedFloat(uint32 marketIndex, address user) internal virtual returns (uint256 floatReward) {\n    address longToken = syntheticTokens[marketIndex][true];\n    address shortToken = syntheticTokens[marketIndex][false];\n\n    uint256 amountStakedLong = userAmountStaked[longToken][user];\n    uint256 amountStakedShort = userAmountStaked[shortToken][user];\n\n    uint256 usersLastRewardIndex = userIndexOfLastClaimedReward[marketIndex][user];\n\n    // Don\'t do the calculation and return zero immediately if there is no change\n    if (usersLastRewardIndex == latestRewardIndex[marketIndex]) {\n      return 0;\n    }\n\n    uint256 usersShiftIndex = userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][user];\n    // if there is a change in the users tokens held due to a token shift (or possibly another action in the future)\n    if (usersShiftIndex &gt; 0 &amp;&amp; usersShiftIndex &lt; batched_stakerNextTokenShiftIndex[marketIndex]) {\n      floatReward = _calculateAccumulatedFloatInRange(\n        marketIndex,\n        amountStakedLong,\n        amountStakedShort,\n        usersLastRewardIndex,\n        stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[usersShiftIndex]\n      );\n\n      // Update the users balances\n      if (userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user] &gt; 0) {\n        amountStakedShort += ILongShort(longShort).getAmountSyntheticTokenToMintOnTargetSide(\n          marketIndex,\n          userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user],\n          true,\n          stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[usersShiftIndex]\n        );\n\n        amountStakedLong -= userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user];\n        userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user] = 0;\n      }\n\n      if (userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user] &gt; 0) {\n        amountStakedLong += ILongShort(longShort).getAmountSyntheticTokenToMintOnTargetSide(\n          marketIndex,\n          userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user],\n          false,\n          stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[usersShiftIndex]\n        );\n\n        amountStakedShort -= userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user];\n        userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user] = 0;\n      }\n\n      // Save the users updated staked amounts\n      userAmountStaked[longToken][user] = amountStakedLong;\n      userAmountStaked[shortToken][user] = amountStakedShort;\n\n      floatReward += _calculateAccumulatedFloatInRange(\n        marketIndex,\n        amountStakedLong,\n        amountStakedShort,\n        stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[usersShiftIndex],\n        latestRewardIndex[marketIndex]\n      );\n\n      userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][user] = 0;\n    } else {\n      floatReward = _calculateAccumulatedFloatInRange(\n        marketIndex,\n        amountStakedLong,\n        amountStakedShort,\n        usersLastRewardIndex,\n        latestRewardIndex[marketIndex]\n      );\n    }\n  }\n\n  /\n  @notice Mints float for a user.\n  @dev Mints a fixed percentage for Float capital.\n  @param user The address of the user.\n  @param floatToMint The amount of float to mint.\n   */\n  function _mintFloat(address user, uint256 floatToMint) internal virtual {\n    IFloatToken(floatToken).mint(user, floatToMint);\n    IFloatToken(floatToken).mint(floatCapital, (floatToMint * floatPercentage) / 1e18);\n  }\n\n  /\n  @notice Mints float owed to a user for a market since they last minted.\n  @param marketIndex An identifier for the market.\n  @param user The address of the user.\n   /\n  function _mintAccumulatedFloat(uint32 marketIndex, address user) internal virtual {\n    uint256 floatToMint = _calculateAccumulatedFloat(marketIndex, user);\n\n    if (floatToMint &gt; 0) {\n      // Set the user has claimed up until now, stops them setting this forward\n      userIndexOfLastClaimedReward[marketIndex][user] = latestRewardIndex[marketIndex];\n\n      _mintFloat(user, floatToMint);\n      emit FloatMinted(user, marketIndex, floatToMint);\n    }\n  }\n\n  /\n  @notice Mints float owed to a user for multiple markets, since they last minted for those markets.\n  @param marketIndexes Identifiers for the markets.\n  @param user The address of the user.\n   /\n  function _mintAccumulatedFloatMulti(uint32[] calldata marketIndexes, address user) internal virtual {\n    uint256 floatTotal = 0;\n    for (uint256 i = 0; i &lt; marketIndexes.length; i++) {\n      uint256 floatToMint = _calculateAccumulatedFloat(marketIndexes[i], user);\n\n      if (floatToMint &gt; 0) {\n        // Set the user has claimed up until now, stops them setting this forward\n        userIndexOfLastClaimedReward[marketIndexes[i]][user] = latestRewardIndex[marketIndexes[i]];\n\n        floatTotal += floatToMint;\n\n        emit FloatMinted(user, marketIndexes[i], floatToMint);\n      }\n    }\n    if (floatTotal &gt; 0) {\n      _mintFloat(user, floatTotal);\n    }\n  }\n\n  /\n  @notice Mints outstanding float for msg.sender.\n  @param marketIndexes Identifiers for the markets for which to mint float.\n   */\n  function claimFloatCustom(uint32[] calldata marketIndexes) external {\n    ILongShort(longShort).updateSystemStateMulti(marketIndexes);\n    _mintAccumulatedFloatMulti(marketIndexes, msg.sender);\n  }\n\n  /\n  @notice Mints outstanding float on behalf of another user.\n  @param marketIndexes Identifiers for the markets for which to mint float.\n  @param user The address of the user.\n   /\n  function claimFloatCustomFor(uint32[] calldata marketIndexes, address user) external {\n    // Unbounded loop - users are responsible for paying their own gas costs on these and it doesn\'t effect the rest of the system.\n    // No need to impose limit.\n    ILongShort(longShort).updateSystemStateMulti(marketIndexes);\n    _mintAccumulatedFloatMulti(marketIndexes, user);\n  }\n\n  /╔═══════════════════════╗\n    ║        STAKING        ║\n    ╚═══════════════════════╝/\n\n  /\n  @notice A user with synthetic tokens stakes by calling stake on the token\n  contract which calls this function. We need to first update the\n  state of the LongShort contract for this market before staking to correctly calculate user rewards.\n  @param amount Amount to stake.\n  @param from Address to stake for.\n  /\n  function stakeFromUser(address from, uint256 amount) public virtual override onlyValidSynthetic((msg.sender)) {\n    ILongShort(longShort).updateSystemState(marketIndexOfToken[(msg.sender)]);\n    _stake((msg.sender), amount, from);\n  }\n\n  /\n  @dev Internal logic for staking.\n  @param token Address of the token for which to stake.\n  @param amount Amount to stake.\n  @param user Address to stake for.\n  */\n  function _stake(\n    address token,\n    uint256 amount,\n    address user\n  ) internal virtual {\n    uint32 marketIndex = marketIndexOfToken[token];\n\n    // If they already have staked and have rewards due, mint these.\n    if (\n      userIndexOfLastClaimedReward[marketIndex][user] != 0 &amp;&amp;\n      userIndexOfLastClaimedReward[marketIndex][user] &lt; latestRewardIndex[marketIndex]\n    ) {\n      _mintAccumulatedFloat(marketIndex, user);\n    }\n\n    userAmountStaked[token][user] = userAmountStaked[token][user] + amount;\n\n    userIndexOfLastClaimedReward[marketIndex][user] = latestRewardIndex[marketIndex];\n\n    emit StakeAdded(user, address(token), amount, userIndexOfLastClaimedReward[marketIndex][user]);\n  }\n\n  /\n  @notice Allows users to shift their staked tokens from one side of the market to \n  the other at the next price.\n  @param amountSyntheticTokensToShift Amount of tokens to shift.\n  @param marketIndex Identifier for the market.\n  @param isShiftFromLong Whether the shift is from long to short or short to long.\n  /\n  function shiftTokens(\n    uint256 amountSyntheticTokensToShift,\n    uint32 marketIndex,\n    bool isShiftFromLong\n  ) external virtual {\n    address token = syntheticTokens[marketIndex][isShiftFromLong];\n    require(userAmountStaked[token][msg.sender] &gt;= amountSyntheticTokensToShift, "Not enough tokens to shift");\n\n    // If the user has outstanding token shift that have already been confirmed in the LongShort\n    // contract, execute them first.\n    if (\n      userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] != 0 &amp;&amp;\n      userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] &lt;\n      batched_stakerNextTokenShiftIndex[marketIndex]\n    ) {\n      _mintAccumulatedFloat(marketIndex, msg.sender);\n    }\n\n    if (isShiftFromLong) {\n      ILongShort(longShort).shiftPositionFromLongNextPrice(marketIndex, amountSyntheticTokensToShift);\n      userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][\n        msg.sender\n      ] += amountSyntheticTokensToShift;\n    } else {\n      ILongShort(longShort).shiftPositionFromShortNextPrice(marketIndex, amountSyntheticTokensToShift);\n      userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][\n        msg.sender\n      ] += amountSyntheticTokensToShift;\n    }\n\n    userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] = batched_stakerNextTokenShiftIndex[\n      marketIndex\n    ];\n  }\n\n  /╔════════════════════════════╗\n    ║    WITHDRAWAL &amp; MINTING    ║\n    ╚════════════════════════════╝/\n\n  /\n  @notice Internal logic for withdrawing stakes.\n  @dev Mint user any outstanding float before withdrawing.\n  @param marketIndex Market index of token.\n  @param amount Amount to withdraw.\n  @param token Synthetic token that was staked.\n  /\n  function _withdraw(\n    uint32 marketIndex,\n    address token,\n    uint256 amount\n  ) internal virtual {\n    require(userAmountStaked[token][msg.sender] &gt; 0, "nothing to withdraw");\n    _mintAccumulatedFloat(marketIndex, msg.sender);\n\n    userAmountStaked[token][msg.sender] = userAmountStaked[token][msg.sender] - amount;\n\n    uint256 amountFees = (amount * marketUnstakeFee_e18[marketIndex]) / 1e18;\n\n    IERC20(token).transfer(floatTreasury, amountFees);\n    IERC20(token).transfer(msg.sender, amount - amountFees);\n\n    emit StakeWithdrawn(msg.sender, token, amount);\n  }\n\n  /\n  @notice Withdraw function. Allows users to unstake.\n  @param amount Amount to withdraw.\n  @param token Address of the token for which to withdraw.\n  */\n  function withdraw(address token, uint256 amount) external {\n    ILongShort(longShort).updateSystemState(marketIndexOfToken[token]);\n\n    uint32 marketIndex = marketIndexOfToken[token];\n\n    _withdraw(marketIndex, token, amount);\n\n    if (userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] &gt; 0) {\n      // If they still have outstanding shifts after minting float, then check\n      // that they don\'t withdraw more than their shifts allow.\n      uint256 amountToShiftForThisToken = syntheticTokens[marketIndex][true] == token\n        ? userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][msg.sender]\n        : userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][msg.sender];\n\n      require(\n        userAmountStaked[token][msg.sender] &gt;= amountToShiftForThisToken,\n        "Outstanding next price stake shifts too great"\n      );\n    }\n  }\n\n  /\n  @notice Allows users to withdraw their entire stake for a token.\n  @param token Address of the token for which to withdraw.\n  */\n  function withdrawAll(address token) external {\n    ILongShort(longShort).updateSystemState(marketIndexOfToken[token]);\n\n    uint32 marketIndex = marketIndexOfToken[token];\n\n    uint256 amountToShiftForThisToken = syntheticTokens[marketIndex][true] == token\n      ? userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][msg.sender]\n      : userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][msg.sender];\n\n    _withdraw(marketIndex, token, userAmountStaked[token][msg.sender] - amountToShiftForThisToken);\n  }\n}\n', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-17-08 08:01:24 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: BUSL-1.1 pragma solidity 0.8.3; import "@openzeppelin/contracts-upgradeable/token/ERC20/presets/ERC20PresetMinterPauserUpgradeable.sol"; import "./interfaces/IFloatToken.sol"; import "./interfaces/ILongShort.sol"; import "./interfaces/IStaker.sol"; import "./interfaces/ISyntheticToken.sol"; contract Staker is IStaker, Initializable {   /╔═════════════════════════════╗     ║          VARIABLES          ║     ╚═════════════════════════════╝/ / ══════ Fixed-precision constants ══════ /   uint256 public constant FLOAT_ISSUANCE_FIXED_DECIMAL = 1e42;   // 2^52 ~= 4.5e15   // With an exponent of 5, the largest total liquidity possible in a market (to avoid integer overflow on exponentiation) is ~10^31 or 10 Trillion (10^13)   // NOTE: this also means if the total market value is less than 2^52 there will be a division by zero error   uint256 public constant safeExponentBitShifting = 52; / ══════ Global state ══════ /   address public admin;   address public floatCapital;   address public floatTreasury;   uint256 public floatPercentage; address public longShort;   address public floatToken; / ══════ Market specific ══════ /   mapping(uint32 =&gt; uint256) public marketLaunchIncentive_period; // seconds   mapping(uint32 =&gt; uint256) public marketLaunchIncentive_multipliers; // e18 scale   mapping(uint32 =&gt; uint256) public marketUnstakeFee_e18;   mapping(uint32 =&gt; uint256) public balanceIncentiveCurve_exponent;   mapping(uint32 =&gt; int256) public balanceIncentiveCurve_equilibriumOffset; mapping(uint32 =&gt; mapping(bool =&gt; address)) public syntheticTokens; mapping(address =&gt; uint32) public marketIndexOfToken; / ══════ Reward specific ══════ /   mapping(uint32 =&gt; uint256) public latestRewardIndex;   mapping(uint32 =&gt; mapping(uint256 =&gt; AccumulativeIssuancePerStakedSynthSnapshot))     public accumulativeFloatPerSyntheticTokenSnapshots;   struct AccumulativeIssuancePerStakedSynthSnapshot {     uint256 timestamp;     uint256 accumulativeFloatPerSyntheticToken_long;     uint256 accumulativeFloatPerSyntheticToken_short;   } / ══════ User specific ══════ /   mapping(uint32 =&gt; mapping(address =&gt; uint256)) public userIndexOfLastClaimedReward;   mapping(address =&gt; mapping(address =&gt; uint256)) public userAmountStaked; / ══════ Token shift management specific ══════ /   mapping(uint32 =&gt; uint256) public batched_stakerNextTokenShiftIndex;   /*   @notice Used to link a token shift to a staker state   @dev tokenShiftIndex =&gt; accumulativeFloatIssuanceSnapshotIndex     POSSIBLE OPTIMIZATION - could pack stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping and stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping into a struct of two uint128 for storage space optimization.   /   mapping(uint256 =&gt; uint256) public stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping;   /// @notice Used to fetch the price from LongShort at that point in time   /// @dev tokenShiftIndex =&gt; longShortMarketPriceSnapshotIndex   mapping(uint256 =&gt; uint256) public stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping;   /// @dev marketIndex =&gt; usersAddress =&gt; stakerTokenShiftIndex   mapping(uint32 =&gt; mapping(address =&gt; uint256)) public userNextPrice_stakedSyntheticTokenShiftIndex;   /// @dev marketIndex =&gt; usersAddress =&gt; amountUserRequestedToShiftAwayFromLongOnNextUpdate   mapping(uint32 =&gt; mapping(address =&gt; uint256)) public userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long;   /// @dev marketIndex =&gt; usersAddress =&gt; amountUserRequestedToShiftAwayFromShortOnNextUpdate   mapping(uint32 =&gt; mapping(address =&gt; uint256)) public userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short; /╔════════════════════════════╗     ║           EVENTS           ║     ╚════════════════════════════╝/ event StakerV1(     address admin,     address floatTreasury,     address floatCapital,     address floatToken,     uint256 floatPercentage   ); event MarketAddedToStaker(     uint32 marketIndex,     uint256 exitFee_e18,     uint256 period,     uint256 multiplier,     uint256 balanceIncentiveExponent,     int256 balanceIncentiveEquilibriumOffset   ); event AccumulativeIssuancePerStakedSynthSnapshotCreated(     uint32 marketIndex,     uint256 accumulativeFloatIssuanceSnapshotIndex,     uint256 accumulativeLong,     uint256 accumulativeShort   ); event StakeAdded(address user, address token, uint256 amount, uint256 lastMintIndex); event StakeWithdrawn(address user, address token, uint256 amount); // Note: the amountFloatMinted isn't strictly needed by the graph, but it is good to add it to validate calculations are accurate.   event FloatMinted(address user, uint32 marketIndex, uint256 amountFloatMinted); event MarketLaunchIncentiveParametersChanges(uint32 marketIndex, uint256 period, uint256 multiplier); event StakeWithdrawalFeeUpdated(uint32 marketIndex, uint256 stakeWithdralFee); event BalanceIncentiveExponentUpdated(uint32 marketIndex, uint256 balanceIncentiveExponent); event BalanceIncentiveEquilibriumOffsetUpdated(uint32 marketIndex, int256 balanceIncentiveEquilibriumOffset); event FloatPercentageUpdated(uint256 floatPercentage); event SyntheticTokensShifted(); event ChangeAdmin(address newAdmin); /╔═════════════════════════════╗     ║          MODIFIERS          ║     ╚═════════════════════════════╝/ function onlyAdminModifierLogic() internal virtual {     require(msg.sender == admin, "not admin");   } modifier onlyAdmin() {     onlyAdminModifierLogic();     _;   } function onlyValidSyntheticModifierLogic(address _synth) internal virtual {     require(marketIndexOfToken[_synth] != 0, "not valid synth");   } modifier onlyValidSynthetic(address synth) {     onlyValidSyntheticModifierLogic(_synth);     ;   } function onlyValidMarketModifierLogic(uint32 marketIndex) internal virtual {     require(address(syntheticTokens[marketIndex][true]) != address(0), "not valid market");   } modifier onlyValidMarket(uint32 marketIndex) {     onlyValidMarketModifierLogic(marketIndex);     _;   } function onlyLongShortModifierLogic() internal virtual {     require(msg.sender == address(longShort), "not long short");   } modifier onlyLongShort() {     onlyLongShortModifierLogic();     _;   } /╔═════════════════════════════╗     ║       CONTRACT SET-UP       ║     ╚═════════════════════════════╝/ /*   @notice Initializes the contract.   @dev Calls OpenZeppelin's initializer modifier.   @param _admin Address of the admin role.   @param _longShort Address of the LongShort contract, a deployed LongShort.sol   @param _floatToken Address of the Float token earned by staking.   @param _floatTreasury Address of the treasury contract for managing fees.   @param _floatCapital Address of the contract which earns a fixed percentage of Float.   @param _floatPercentage Determines the float percentage that gets minted for Float Capital, base 1e18.   /   function initialize(     address _admin,     address _longShort,     address _floatToken,     address _floatTreasury,     address _floatCapital,     uint256 _floatPercentage   ) external virtual initializer {     admin = _admin;     floatCapital = _floatCapital;     floatTreasury = _floatTreasury;     longShort = _longShort;     floatToken = _floatToken; _changeFloatPercentage(_floatPercentage);  emit StakerV1(_admin, _floatTreasury, _floatCapital, _floatToken, _floatPercentage);  } /╔═══════════════════╗     ║       ADMIN       ║     ╚═══════════════════╝/ /*    @notice Changes admin for the contract   @param _admin The address of the new admin.   /   function changeAdmin(address _admin) external onlyAdmin {     admin = _admin;     emit ChangeAdmin(_admin);   } /// @dev Logic for changeFloatPercentage   function _changeFloatPercentage(uint256 newFloatPercentage) internal virtual {     require(newFloatPercentage &lt;= 1e18 &amp;&amp; newFloatPercentage &gt; 0); // less than or equal to 100% and greater than 0%     floatPercentage = newFloatPercentage;   } /*   @notice Changes percentage of float that is minted for float capital.   @param newFloatPercentage The new float percentage in base 1e18.   /   function changeFloatPercentage(uint256 newFloatPercentage) external onlyAdmin {     _changeFloatPercentage(newFloatPercentage);     emit FloatPercentageUpdated(newFloatPercentage);   } /// @dev Logic for changeUnstakeFee   function _changeUnstakeFee(uint32 marketIndex, uint256 newMarketUnstakeFee_e18) internal virtual {     require(newMarketUnstakeFee_e18 &lt;= 5e16); // Explicitely stating 5% fee as the max fee possible.     marketUnstakeFee_e18[marketIndex] = newMarketUnstakeFee_e18;   } /*   @notice Changes unstake fee for a market   @param marketIndex Identifies the market.   @param newMarketUnstakeFee_e18 The new unstake fee.   /   function changeUnstakeFee(uint32 marketIndex, uint256 newMarketUnstakeFee_e18) external onlyAdmin {     _changeUnstakeFee(marketIndex, newMarketUnstakeFee_e18);     emit StakeWithdrawalFeeUpdated(marketIndex, newMarketUnstakeFee_e18);   } /// @dev Logic for changeMarketLaunchIncentiveParameters   function _changeMarketLaunchIncentiveParameters(     uint32 marketIndex,     uint256 period,     uint256 initialMultiplier   ) internal virtual {     require(initialMultiplier &gt;= 1e18, "marketLaunchIncentiveMultiplier must be &gt;= 1e18"); marketLaunchIncentive_period[marketIndex] = period; marketLaunchIncentive_multipliers[marketIndex] = initialMultiplier;  } /*   @notice Changes the market launch incentive parameters for a market   @param marketIndex Identifies the market.   @param period The new period for which float token generation should be boosted.   @param initialMultiplier The new multiplier on Float generation.   /   function changeMarketLaunchIncentiveParameters(     uint32 marketIndex,     uint256 period,     uint256 initialMultiplier   ) external onlyAdmin {     _changeMarketLaunchIncentiveParameters(marketIndex, period, initialMultiplier); emit MarketLaunchIncentiveParametersChanges(marketIndex, period, initialMultiplier);  } /// @dev Logic for changeBalanceIncentiveExponent   function _changeBalanceIncentiveExponent(uint32 marketIndex, uint256 _balanceIncentiveCurve_exponent)     internal     virtual   {     require(       // The exponent has to be less than 5 in these versions of the contracts.       _balanceIncentiveCurve_exponent &gt; 0 &amp;&amp; _balanceIncentiveCurve_exponent &lt; 6,       "balanceIncentiveCurve_exponent out of bounds"     ); balanceIncentiveCurve_exponent[marketIndex] = _balanceIncentiveCurve_exponent;  } /*    @notice Changes the balance incentive exponent for a market   @param marketIndex Identifies the market.   @param _balanceIncentiveCurve_exponent The new exponent for the curve.   /   function changeBalanceIncentiveExponent(uint32 marketIndex, uint256 _balanceIncentiveCurve_exponent)     external     onlyAdmin   {     _changeBalanceIncentiveExponent(marketIndex, _balanceIncentiveCurve_exponent); emit BalanceIncentiveExponentUpdated(marketIndex, _balanceIncentiveCurve_exponent);  } /// @dev Logic for changeBalanceIncentiveEquilibriumOffset   function _changeBalanceIncentiveEquilibriumOffset(uint32 marketIndex, int256 _balanceIncentiveCurve_equilibriumOffset)     internal     virtual   {     // Unreasonable that we would ever shift this more than 90% either way     require(       _balanceIncentiveCurve_equilibriumOffset &gt; -9e17 &amp;&amp; _balanceIncentiveCurve_equilibriumOffset &lt; 9e17,       "balanceIncentiveCurve_equilibriumOffset out of bounds"     ); balanceIncentiveCurve_equilibriumOffset[marketIndex] = _balanceIncentiveCurve_equilibriumOffset;  } /*   @notice Changes the balance incentive curve equilibrium offset for a market   @param marketIndex Identifies the market.   @param _balanceIncentiveCurve_equilibriumOffset The new offset.   /   function changeBalanceIncentiveEquilibriumOffset(uint32 marketIndex, int256 _balanceIncentiveCurve_equilibriumOffset)     external     onlyAdmin   {     _changeBalanceIncentiveEquilibriumOffset(marketIndex, _balanceIncentiveCurve_equilibriumOffset); emit BalanceIncentiveEquilibriumOffsetUpdated(marketIndex, _balanceIncentiveCurve_equilibriumOffset);  } /╔═════════════════════════════╗     ║        STAKING SETUP        ║     ╚═════════════════════════════╝/ /*   @notice Sets this contract to track staking for a market in LongShort.sol   @param marketIndex Identifies the market.   @param longToken Address of the long token for the market.   @param shortToken Address of the short token for the market.   @param kInitialMultiplier Initial boost on float generation for the market.   @param kPeriod Period which the boost should last.   @param unstakeFee_e18 Percentage of tokens that are levied on unstaking in base 1e18.   @param _balanceIncentiveCurve_exponent Exponent for balance curve (see _calculateFloatPerSecond)   @param _balanceIncentiveCurve_equilibriumOffset Offset for balance curve (see _calculateFloatPerSecond)   /   function addNewStakingFund(     uint32 marketIndex,     address longToken,     address shortToken,     uint256 kInitialMultiplier,     uint256 kPeriod,     uint256 unstakeFee_e18,     uint256 _balanceIncentiveCurve_exponent,     int256 _balanceIncentiveCurve_equilibriumOffset   ) external override onlyLongShort {     marketIndexOfToken[longToken] = marketIndex;     marketIndexOfToken[shortToken] = marketIndex; accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].timestamp = block.timestamp; accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].accumulativeFloatPerSyntheticToken_long = 0; accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].accumulativeFloatPerSyntheticToken_short = 0;  syntheticTokens[marketIndex][true] = longToken; syntheticTokens[marketIndex][false] = shortToken;  _changeBalanceIncentiveExponent(marketIndex, _balanceIncentiveCurve_exponent); _changeBalanceIncentiveEquilibriumOffset(marketIndex, _balanceIncentiveCurve_equilibriumOffset); _changeMarketLaunchIncentiveParameters(marketIndex, kPeriod, kInitialMultiplier);  _changeUnstakeFee(marketIndex, unstakeFee_e18);  // Set this value to one initially - 0 is a null value and thus potentially bug prone. batched_stakerNextTokenShiftIndex[marketIndex] = 1;  emit MarketAddedToStaker(   marketIndex,   unstakeFee_e18,   kPeriod,   kInitialMultiplier,   _balanceIncentiveCurve_exponent,   _balanceIncentiveCurve_equilibriumOffset );  emit AccumulativeIssuancePerStakedSynthSnapshotCreated(marketIndex, 0, 0, 0);  } /╔═════════════════════════════════════════════════════════════════════════╗     ║    GLOBAL FLT REWARD ACCUMULATION CALCULATION AND TRACKING FUNCTIONS    ║     ╚═════════════════════════════════════════════════════════════════════════╝/ /*   @notice Returns the K factor parameters for the given market with sensible   defaults if they haven't been set yet.   @param marketIndex The market to change the parameters for.   @return period The period for which the k factor applies for in seconds.   @return multiplier The multiplier on Float generation in this period.   /   function _getMarketLaunchIncentiveParameters(uint32 marketIndex)     internal     view     virtual     returns (uint256 period, uint256 multiplier)   {     period = marketLaunchIncentive_period[marketIndex];     multiplier = marketLaunchIncentive_multipliers[marketIndex]; if (multiplier &lt; 1e18) {   multiplier = 1e18; // multiplier of 1 by default }  } /*    @notice Returns the extent to which a markets float generation should be adjusted   based on the market's launch incentive parameters. Should start at multiplier   then linearly change to 1e18 over time.   @param marketIndex Identifies the market.   @return k The calculated modifier for float generation.   /   function _getKValue(uint32 marketIndex) internal view virtual returns (uint256) {     // Parameters controlling the float issuance multiplier.     (uint256 kPeriod, uint256 kInitialMultiplier) = _getMarketLaunchIncentiveParameters(marketIndex); // Sanity check - under normal circumstances, the multipliers should // *never* be set to a value &lt; 1e18, as there are guards against this. assert(kInitialMultiplier &gt;= 1e18);  uint256 initialTimestamp = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].timestamp;  if (block.timestamp - initialTimestamp &lt;= kPeriod) {   return kInitialMultiplier - (((kInitialMultiplier - 1e18) * (block.timestamp - initialTimestamp)) / kPeriod); } else {   return 1e18; }  } /   @notice Computes the number of float tokens a user earns per second for   every long/short synthetic token they've staked. The returned value has   a fixed decimal scale of 1e42 (!!!) for numerical stability. The return   values are float per second per synthetic token (hence the requirement   to multiply by price)   @dev to see below math in latex form see TODO add link   to interact with the equations see https://www.desmos.com/calculator/optkaxyihr   @param marketIndex The market referred to.   @param longPrice Price of the synthetic long token in units of payment token   @param shortPrice Price of the synthetic short token in units of payment token   @param longValue Amount of payment token in the long side of the market   @param shortValue Amount of payment token in the short side of the market   @return longFloatPerSecond Float token per second per long synthetic token   @return shortFloatPerSecond Float token per second per short synthetic token    /   function _calculateFloatPerSecond(     uint32 marketIndex,     uint256 longPrice,     uint256 shortPrice,     uint256 longValue,     uint256 shortValue   ) internal view virtual returns (uint256 longFloatPerSecond, uint256 shortFloatPerSecond) {     // A float issuance multiplier that starts high and decreases linearly     // over time to a value of 1. This incentivises users to stake early.     uint256 k = _getKValue(marketIndex); uint256 totalLocked = (longValue + shortValue);  // we need to scale this number by the totalLocked so that the offset remains consistent accross market size  int256 equilibriumOffsetMarketScaled = (balanceIncentiveCurve_equilibriumOffset[marketIndex] *   int256(totalLocked)) / 2e18;  uint256 denominator = ((totalLocked &gt;&gt; safeExponentBitShifting)**balanceIncentiveCurve_exponent[marketIndex]);  // Float is scaled by the percentage of the total market value held in // the opposite position. This incentivises users to stake on the // weaker position. if (int256(shortValue) - equilibriumOffsetMarketScaled &lt; int256(longValue)) {   if (equilibriumOffsetMarketScaled &gt;= int256(shortValue)) {     // edge case: imbalanced far past the equilibrium offset - full rewards go to short token     //            extremeley unlikely to happen in practice     return (0, 1e18 * k * shortPrice);   }    uint256 numerator = (uint256(int256(shortValue) - equilibriumOffsetMarketScaled) &gt;&gt;     (safeExponentBitShifting - 1))**balanceIncentiveCurve_exponent[marketIndex];    // NOTE: `x * 5e17` == `(x * 10e18) / 2`   uint256 longRewardUnscaled = (numerator * 5e17) / denominator;   uint256 shortRewardUnscaled = 1e18 - longRewardUnscaled;    return ((longRewardUnscaled * k * longPrice) / 1e18, (shortRewardUnscaled * k * shortPrice) / 1e18); } else {   if (-equilibriumOffsetMarketScaled &gt;= int256(longValue)) {     // edge case: imbalanced far past the equilibrium offset - full rewards go to long token     //            extremeley unlikely to happen in practice     return (1e18 * k * longPrice, 0);   }    uint256 numerator = (uint256(int256(longValue) + equilibriumOffsetMarketScaled) &gt;&gt;     (safeExponentBitShifting - 1))**balanceIncentiveCurve_exponent[marketIndex];    // NOTE: `x * 5e17` == `(x * 10e18) / 2`   uint256 shortRewardUnscaled = (numerator * 5e17) / denominator;   uint256 longRewardUnscaled = 1e18 - shortRewardUnscaled;    return ((longRewardUnscaled * k * longPrice) / 1e18, (shortRewardUnscaled * k * shortPrice) / 1e18); }  } /*   @notice Computes the time since last accumulativeIssuancePerStakedSynthSnapshot for the given market in seconds.   @param marketIndex The market referred to.   @return The time difference in seconds   /   function _calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(uint32 marketIndex)     internal     view     virtual     returns (uint256)   {     return       block.timestamp -       accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]].timestamp;   } /*   @notice Computes new cumulative sum of 'r' value since last accumulativeIssuancePerStakedSynthSnapshot. We use   cumulative 'r' value to avoid looping during issuance. Note that the   cumulative sum is kept in 1e42 scale (!!!) to avoid numerical issues.   @param shortValue The value locked in the short side of the market.   @param longValue The value locked in the long side of the market.   @param shortPrice The price of the short token as defined in LongShort.sol   @param longPrice The price of the long token as defined in LongShort.sol   @param marketIndex An identifier for the market.   @return longCumulativeRates The long cumulative sum.   @return shortCumulativeRates The short cumulative sum.   /   function _calculateNewCumulativeIssuancePerStakedSynth(     uint32 marketIndex,     uint256 longPrice,     uint256 shortPrice,     uint256 longValue,     uint256 shortValue   ) internal view virtual returns (uint256 longCumulativeRates, uint256 shortCumulativeRates) {     // Compute the current 'r' value for float issuance per second.     (uint256 longFloatPerSecond, uint256 shortFloatPerSecond) = _calculateFloatPerSecond(       marketIndex,       longPrice,       shortPrice,       longValue,       shortValue     ); // Compute time since last accumulativeIssuancePerStakedSynthSnapshot for the given token. uint256 timeDelta = _calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(marketIndex);  // Compute new cumulative 'r' value total. return (   accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]]   .accumulativeFloatPerSyntheticToken_long + (timeDelta * longFloatPerSecond),   accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]]   .accumulativeFloatPerSyntheticToken_short + (timeDelta * shortFloatPerSecond) );  } /*   @notice Creates a new accumulativeIssuancePerStakedSynthSnapshot for the given token and updates indexes.   @param shortValue The value locked in the short side of the market.   @param longValue The value locked in the long side of the market.   @param shortPrice The price of the short token as defined in LongShort.sol   @param longPrice The price of the long token as defined in LongShort.sol   @param marketIndex An identifier for the market.   /   function _setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot(     uint32 marketIndex,     uint256 longPrice,     uint256 shortPrice,     uint256 longValue,     uint256 shortValue   ) internal virtual {     (       uint256 newLongAccumulativeValue,       uint256 newShortAccumulativeValue     ) = _calculateNewCumulativeIssuancePerStakedSynth(marketIndex, longPrice, shortPrice, longValue, shortValue); uint256 newIndex = latestRewardIndex[marketIndex] + 1;  // Set cumulative 'r' value on new accumulativeIssuancePerStakedSynthSnapshot. accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex] .accumulativeFloatPerSyntheticToken_long = newLongAccumulativeValue; accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex] .accumulativeFloatPerSyntheticToken_short = newShortAccumulativeValue;  // Set timestamp on new accumulativeIssuancePerStakedSynthSnapshot. accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex].timestamp = block.timestamp;  // Update latest index to point to new accumulativeIssuancePerStakedSynthSnapshot. latestRewardIndex[marketIndex] = newIndex;  emit AccumulativeIssuancePerStakedSynthSnapshotCreated(   marketIndex,   newIndex,   newLongAccumulativeValue,   newShortAccumulativeValue );  } /*   @notice Adds new accumulativeIssuancePerStakedSynthSnapshots for the given long/short tokens. Called by the   ILongShort contract whenever there is a state change for a market.   @param stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted Mapping from this contract's shifts to LongShort.sols next price snapshots.   @param shortValue The value locked in the short side of the market.   @param longValue The value locked in the long side of the market.   @param shortPrice The price of the short token as defined in LongShort.sol   @param longPrice The price of the long token as defined in LongShort.sol   @param marketIndex An identifier for the market.   /   function pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(     uint32 marketIndex,     uint256 longPrice,     uint256 shortPrice,     uint256 longValue,     uint256 shortValue,     uint256 stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted // This value should be ALWAYS be zero if no shift occured   ) external override onlyLongShort {     // Only add a new accumulativeIssuancePerStakedSynthSnapshot if some time has passed. // the `stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted` value will be 0 if there is no staker related action in an executed batch if (stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted &gt; 0) {   stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[     batched_stakerNextTokenShiftIndex[marketIndex]   ] = stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted;   stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[     batched_stakerNextTokenShiftIndex[marketIndex]   ] = latestRewardIndex[marketIndex] + 1;   batched_stakerNextTokenShiftIndex[marketIndex] += 1;    emit SyntheticTokensShifted(); }  // Time delta is fetched twice in below code, can pass through? Which is less gas? if (_calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(marketIndex) &gt; 0) {   _setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot(     marketIndex,     longPrice,     shortPrice,     longValue,     shortValue   ); }  } /╔═══════════════════════════════════╗     ║    USER REWARD STATE FUNCTIONS    ║     ╚═══════════════════════════════════╝/ /// @dev Calculates the accumulated float in a specific range of staker snapshots   function _calculateAccumulatedFloatInRange(     uint32 marketIndex,     uint256 amountStakedLong,     uint256 amountStakedShort,     uint256 rewardIndexFrom,     uint256 rewardIndexTo   ) internal view virtual returns (uint256 floatReward) {     if (amountStakedLong &gt; 0) {       uint256 accumDeltaLong = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexTo]       .accumulativeFloatPerSyntheticToken_long -         accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexFrom]         .accumulativeFloatPerSyntheticToken_long;       floatReward += (accumDeltaLong * amountStakedLong) / FLOAT_ISSUANCE_FIXED_DECIMAL;     } if (amountStakedShort &gt; 0) {   uint256 accumDeltaShort = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexTo]   .accumulativeFloatPerSyntheticToken_short -     accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexFrom]     .accumulativeFloatPerSyntheticToken_short;   floatReward += (accumDeltaShort * amountStakedShort) / FLOAT_ISSUANCE_FIXED_DECIMAL; }  } /*    @notice Calculates float owed to the user since the user last minted float for a market.   @param marketIndex Identifier for the market which the user staked in.   @param user The address of the user.   @return floatReward The amount of float owed.    /   function _calculateAccumulatedFloat(uint32 marketIndex, address user) internal virtual returns (uint256 floatReward) {     address longToken = syntheticTokens[marketIndex][true];     address shortToken = syntheticTokens[marketIndex][false]; uint256 amountStakedLong = userAmountStaked[longToken][user]; uint256 amountStakedShort = userAmountStaked[shortToken][user];  uint256 usersLastRewardIndex = userIndexOfLastClaimedReward[marketIndex][user];  // Don't do the calculation and return zero immediately if there is no change if (usersLastRewardIndex == latestRewardIndex[marketIndex]) {   return 0; }  uint256 usersShiftIndex = userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][user]; // if there is a change in the users tokens held due to a token shift (or possibly another action in the future) if (usersShiftIndex &gt; 0 &amp;&amp; usersShiftIndex &lt; batched_stakerNextTokenShiftIndex[marketIndex]) {   floatReward = _calculateAccumulatedFloatInRange(     marketIndex,     amountStakedLong,     amountStakedShort,     usersLastRewardIndex,     stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[usersShiftIndex]   );    // Update the users balances   if (userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user] &gt; 0) {     amountStakedShort += ILongShort(longShort).getAmountSyntheticTokenToMintOnTargetSide(       marketIndex,       userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user],       true,       stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[usersShiftIndex]     );      amountStakedLong -= userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user];     userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user] = 0;   }    if (userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user] &gt; 0) {     amountStakedLong += ILongShort(longShort).getAmountSyntheticTokenToMintOnTargetSide(       marketIndex,       userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user],       false,       stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[usersShiftIndex]     );      amountStakedShort -= userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user];     userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user] = 0;   }    // Save the users updated staked amounts   userAmountStaked[longToken][user] = amountStakedLong;   userAmountStaked[shortToken][user] = amountStakedShort;    floatReward += _calculateAccumulatedFloatInRange(     marketIndex,     amountStakedLong,     amountStakedShort,     stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[usersShiftIndex],     latestRewardIndex[marketIndex]   );    userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][user] = 0; } else {   floatReward = _calculateAccumulatedFloatInRange(     marketIndex,     amountStakedLong,     amountStakedShort,     usersLastRewardIndex,     latestRewardIndex[marketIndex]   ); }  } /*   @notice Mints float for a user.   @dev Mints a fixed percentage for Float capital.   @param user The address of the user.   @param floatToMint The amount of float to mint.    /   function _mintFloat(address user, uint256 floatToMint) internal virtual {     IFloatToken(floatToken).mint(user, floatToMint);     IFloatToken(floatToken).mint(floatCapital, (floatToMint * floatPercentage) / 1e18);   } /*   @notice Mints float owed to a user for a market since they last minted.   @param marketIndex An identifier for the market.   @param user The address of the user.    /   function _mintAccumulatedFloat(uint32 marketIndex, address user) internal virtual {     uint256 floatToMint = _calculateAccumulatedFloat(marketIndex, user); if (floatToMint &gt; 0) {   // Set the user has claimed up until now, stops them setting this forward   userIndexOfLastClaimedReward[marketIndex][user] = latestRewardIndex[marketIndex];    _mintFloat(user, floatToMint);   emit FloatMinted(user, marketIndex, floatToMint); }  } /*   @notice Mints float owed to a user for multiple markets, since they last minted for those markets.   @param marketIndexes Identifiers for the markets.   @param user The address of the user.    /   function _mintAccumulatedFloatMulti(uint32[] calldata marketIndexes, address user) internal virtual {     uint256 floatTotal = 0;     for (uint256 i = 0; i &lt; marketIndexes.length; i++) {       uint256 floatToMint = _calculateAccumulatedFloat(marketIndexes[i], user);   if (floatToMint &gt; 0) {     // Set the user has claimed up until now, stops them setting this forward     userIndexOfLastClaimedReward[marketIndexes[i]][user] = latestRewardIndex[marketIndexes[i]];      floatTotal += floatToMint;      emit FloatMinted(user, marketIndexes[i], floatToMint);   } } if (floatTotal &gt; 0) {   _mintFloat(user, floatTotal); }  } /*   @notice Mints outstanding float for msg.sender.   @param marketIndexes Identifiers for the markets for which to mint float.    /   function claimFloatCustom(uint32[] calldata marketIndexes) external {     ILongShort(longShort).updateSystemStateMulti(marketIndexes);     _mintAccumulatedFloatMulti(marketIndexes, msg.sender);   } /*   @notice Mints outstanding float on behalf of another user.   @param marketIndexes Identifiers for the markets for which to mint float.   @param user The address of the user.    /   function claimFloatCustomFor(uint32[] calldata marketIndexes, address user) external {     // Unbounded loop - users are responsible for paying their own gas costs on these and it doesn't effect the rest of the system.     // No need to impose limit.     ILongShort(longShort).updateSystemStateMulti(marketIndexes);     _mintAccumulatedFloatMulti(marketIndexes, user);   } /╔═══════════════════════╗     ║        STAKING        ║     ╚═══════════════════════╝/ /*   @notice A user with synthetic tokens stakes by calling stake on the token   contract which calls this function. We need to first update the   state of the LongShort contract for this market before staking to correctly calculate user rewards.   @param amount Amount to stake.   @param from Address to stake for.   /   function stakeFromUser(address from, uint256 amount) public virtual override onlyValidSynthetic((msg.sender)) {     ILongShort(longShort).updateSystemState(marketIndexOfToken[(msg.sender)]);     _stake((msg.sender), amount, from);   } /*   @dev Internal logic for staking.   @param token Address of the token for which to stake.   @param amount Amount to stake.   @param user Address to stake for.   /   function _stake(     address token,     uint256 amount,     address user   ) internal virtual {     uint32 marketIndex = marketIndexOfToken[token]; // If they already have staked and have rewards due, mint these. if (   userIndexOfLastClaimedReward[marketIndex][user] != 0 &amp;&amp;   userIndexOfLastClaimedReward[marketIndex][user] &lt; latestRewardIndex[marketIndex] ) {   _mintAccumulatedFloat(marketIndex, user); }  userAmountStaked[token][user] = userAmountStaked[token][user] + amount;  userIndexOfLastClaimedReward[marketIndex][user] = latestRewardIndex[marketIndex];  emit StakeAdded(user, address(token), amount, userIndexOfLastClaimedReward[marketIndex][user]);  } /*   @notice Allows users to shift their staked tokens from one side of the market to    the other at the next price.   @param amountSyntheticTokensToShift Amount of tokens to shift.   @param marketIndex Identifier for the market.   @param isShiftFromLong Whether the shift is from long to short or short to long.   /   function shiftTokens(     uint256 amountSyntheticTokensToShift,     uint32 marketIndex,     bool isShiftFromLong   ) external virtual {     address token = syntheticTokens[marketIndex][isShiftFromLong];     require(userAmountStaked[token][msg.sender] &gt;= amountSyntheticTokensToShift, "Not enough tokens to shift"); // If the user has outstanding token shift that have already been confirmed in the LongShort // contract, execute them first. if (   userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] != 0 &amp;&amp;   userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] &lt;   batched_stakerNextTokenShiftIndex[marketIndex] ) {   _mintAccumulatedFloat(marketIndex, msg.sender); }  if (isShiftFromLong) {   ILongShort(longShort).shiftPositionFromLongNextPrice(marketIndex, amountSyntheticTokensToShift);   userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][     msg.sender   ] += amountSyntheticTokensToShift; } else {   ILongShort(longShort).shiftPositionFromShortNextPrice(marketIndex, amountSyntheticTokensToShift);   userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][     msg.sender   ] += amountSyntheticTokensToShift; }  userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] = batched_stakerNextTokenShiftIndex[   marketIndex ];  } /╔════════════════════════════╗     ║    WITHDRAWAL &amp; MINTING    ║     ╚════════════════════════════╝/ /*   @notice Internal logic for withdrawing stakes.   @dev Mint user any outstanding float before withdrawing.   @param marketIndex Market index of token.   @param amount Amount to withdraw.   @param token Synthetic token that was staked.   /   function _withdraw(     uint32 marketIndex,     address token,     uint256 amount   ) internal virtual {     require(userAmountStaked[token][msg.sender] &gt; 0, "nothing to withdraw");     _mintAccumulatedFloat(marketIndex, msg.sender); userAmountStaked[token][msg.sender] = userAmountStaked[token][msg.sender] - amount;  uint256 amountFees = (amount * marketUnstakeFee_e18[marketIndex]) / 1e18;  IERC20(token).transfer(floatTreasury, amountFees); IERC20(token).transfer(msg.sender, amount - amountFees);  emit StakeWithdrawn(msg.sender, token, amount);  } /*   @notice Withdraw function. Allows users to unstake.   @param amount Amount to withdraw.   @param token Address of the token for which to withdraw.   /   function withdraw(address token, uint256 amount) external {     ILongShort(longShort).updateSystemState(marketIndexOfToken[token]); uint32 marketIndex = marketIndexOfToken[token];  _withdraw(marketIndex, token, amount);  if (userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] &gt; 0) {   // If they still have outstanding shifts after minting float, then check   // that they don't withdraw more than their shifts allow.   uint256 amountToShiftForThisToken = syntheticTokens[marketIndex][true] == token     ? userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][msg.sender]     : userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][msg.sender];    require(     userAmountStaked[token][msg.sender] &gt;= amountToShiftForThisToken,     "Outstanding next price stake shifts too great"   ); }  } /*   @notice Allows users to withdraw their entire stake for a token.   @param token Address of the token for which to withdraw.   /   function withdrawAll(address token) external {     ILongShort(longShort).updateSystemState(marketIndexOfToken[token]); uint32 marketIndex = marketIndexOfToken[token];  uint256 amountToShiftForThisToken = syntheticTokens[marketIndex][true] == token   ? userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][msg.sender]   : userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][msg.sender];  _withdraw(marketIndex, token, userAmountStaked[token][msg.sender] - amountToShiftForThisToken);  } } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-17-08 08:01:24 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: BUSL-1.1

pragma solidity 0.8.3;

import "@openzeppelin/contracts-upgradeable/token/ERC20/presets/ERC20PresetMinterPauserUpgradeable.sol";

import "./interfaces/IFloatToken.sol";
import "./interfaces/ILongShort.sol";
import "./interfaces/IStaker.sol";
import "./interfaces/ISyntheticToken.sol";

contract Staker is IStaker, Initializable {
  /*╔═════════════════════════════╗
    ║          VARIABLES          ║
    ╚═════════════════════════════╝*/

  /* ══════ Fixed-precision constants ══════ */
  uint256 public constant FLOAT_ISSUANCE_FIXED_DECIMAL = 1e42;
  // 2^52 ~= 4.5e15
  // With an exponent of 5, the largest total liquidity possible in a market (to avoid integer overflow on exponentiation) is ~10^31 or 10 Trillion (10^13)
  // NOTE: this also means if the total market value is less than 2^52 there will be a division by zero error
  uint256 public constant safeExponentBitShifting = 52;

  /* ══════ Global state ══════ */
  address public admin;
  address public floatCapital;
  address public floatTreasury;
  uint256 public floatPercentage;

  address public longShort;
  address public floatToken;

  /* ══════ Market specific ══════ */
  mapping(uint32 => uint256) public marketLaunchIncentive_period; // seconds
  mapping(uint32 => uint256) public marketLaunchIncentive_multipliers; // e18 scale
  mapping(uint32 => uint256) public marketUnstakeFee_e18;
  mapping(uint32 => uint256) public balanceIncentiveCurve_exponent;
  mapping(uint32 => int256) public balanceIncentiveCurve_equilibriumOffset;

  mapping(uint32 => mapping(bool => address)) public syntheticTokens;

  mapping(address => uint32) public marketIndexOfToken;

  /* ══════ Reward specific ══════ */
  mapping(uint32 => uint256) public latestRewardIndex;
  mapping(uint32 => mapping(uint256 => AccumulativeIssuancePerStakedSynthSnapshot))
    public accumulativeFloatPerSyntheticTokenSnapshots;
  struct AccumulativeIssuancePerStakedSynthSnapshot {
    uint256 timestamp;
    uint256 accumulativeFloatPerSyntheticToken_long;
    uint256 accumulativeFloatPerSyntheticToken_short;
  }

  /* ══════ User specific ══════ */
  mapping(uint32 => mapping(address => uint256)) public userIndexOfLastClaimedReward;
  mapping(address => mapping(address => uint256)) public userAmountStaked;

  /* ══════ Token shift management specific ══════ */
  mapping(uint32 => uint256) public batched_stakerNextTokenShiftIndex;
  /**
  @notice Used to link a token shift to a staker state
  @dev tokenShiftIndex => accumulativeFloatIssuanceSnapshotIndex
    POSSIBLE OPTIMIZATION - could pack stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping and stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping into a struct of two uint128 for storage space optimization.
  */
  mapping(uint256 => uint256) public stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping;
  /// @notice Used to fetch the price from LongShort at that point in time
  /// @dev tokenShiftIndex => longShortMarketPriceSnapshotIndex
  mapping(uint256 => uint256) public stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping;
  /// @dev marketIndex => usersAddress => stakerTokenShiftIndex
  mapping(uint32 => mapping(address => uint256)) public userNextPrice_stakedSyntheticTokenShiftIndex;
  /// @dev marketIndex => usersAddress => amountUserRequestedToShiftAwayFromLongOnNextUpdate
  mapping(uint32 => mapping(address => uint256)) public userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long;
  /// @dev marketIndex => usersAddress => amountUserRequestedToShiftAwayFromShortOnNextUpdate
  mapping(uint32 => mapping(address => uint256)) public userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short;

  /*╔════════════════════════════╗
    ║           EVENTS           ║
    ╚════════════════════════════╝*/

  event StakerV1(
    address admin,
    address floatTreasury,
    address floatCapital,
    address floatToken,
    uint256 floatPercentage
  );

  event MarketAddedToStaker(
    uint32 marketIndex,
    uint256 exitFee_e18,
    uint256 period,
    uint256 multiplier,
    uint256 balanceIncentiveExponent,
    int256 balanceIncentiveEquilibriumOffset
  );

  event AccumulativeIssuancePerStakedSynthSnapshotCreated(
    uint32 marketIndex,
    uint256 accumulativeFloatIssuanceSnapshotIndex,
    uint256 accumulativeLong,
    uint256 accumulativeShort
  );

  event StakeAdded(address user, address token, uint256 amount, uint256 lastMintIndex);

  event StakeWithdrawn(address user, address token, uint256 amount);

  // Note: the `amountFloatMinted` isn't strictly needed by the graph, but it is good to add it to validate calculations are accurate.
  event FloatMinted(address user, uint32 marketIndex, uint256 amountFloatMinted);

  event MarketLaunchIncentiveParametersChanges(uint32 marketIndex, uint256 period, uint256 multiplier);

  event StakeWithdrawalFeeUpdated(uint32 marketIndex, uint256 stakeWithdralFee);

  event BalanceIncentiveExponentUpdated(uint32 marketIndex, uint256 balanceIncentiveExponent);

  event BalanceIncentiveEquilibriumOffsetUpdated(uint32 marketIndex, int256 balanceIncentiveEquilibriumOffset);

  event FloatPercentageUpdated(uint256 floatPercentage);

  event SyntheticTokensShifted();

  event ChangeAdmin(address newAdmin);

  /*╔═════════════════════════════╗
    ║          MODIFIERS          ║
    ╚═════════════════════════════╝*/

  function onlyAdminModifierLogic() internal virtual {
    require(msg.sender == admin, "not admin");
  }

  modifier onlyAdmin() {
    onlyAdminModifierLogic();
    _;
  }

  function onlyValidSyntheticModifierLogic(address _synth) internal virtual {
    require(marketIndexOfToken[_synth] != 0, "not valid synth");
  }

  modifier onlyValidSynthetic(address _synth) {
    onlyValidSyntheticModifierLogic(_synth);
    _;
  }

  function onlyValidMarketModifierLogic(uint32 marketIndex) internal virtual {
    require(address(syntheticTokens[marketIndex][true]) != address(0), "not valid market");
  }

  modifier onlyValidMarket(uint32 marketIndex) {
    onlyValidMarketModifierLogic(marketIndex);
    _;
  }

  function onlyLongShortModifierLogic() internal virtual {
    require(msg.sender == address(longShort), "not long short");
  }

  modifier onlyLongShort() {
    onlyLongShortModifierLogic();
    _;
  }

  /*╔═════════════════════════════╗
    ║       CONTRACT SET-UP       ║
    ╚═════════════════════════════╝*/

  /**
  @notice Initializes the contract.
  @dev Calls OpenZeppelin's initializer modifier.
  @param _admin Address of the admin role.
  @param _longShort Address of the LongShort contract, a deployed LongShort.sol
  @param _floatToken Address of the Float token earned by staking.
  @param _floatTreasury Address of the treasury contract for managing fees.
  @param _floatCapital Address of the contract which earns a fixed percentage of Float.
  @param _floatPercentage Determines the float percentage that gets minted for Float Capital, base 1e18.
  */
  function initialize(
    address _admin,
    address _longShort,
    address _floatToken,
    address _floatTreasury,
    address _floatCapital,
    uint256 _floatPercentage
  ) external virtual initializer {
    admin = _admin;
    floatCapital = _floatCapital;
    floatTreasury = _floatTreasury;
    longShort = _longShort;
    floatToken = _floatToken;

    _changeFloatPercentage(_floatPercentage);

    emit StakerV1(_admin, _floatTreasury, _floatCapital, _floatToken, _floatPercentage);
  }

  /*╔═══════════════════╗
    ║       ADMIN       ║
    ╚═══════════════════╝*/

  /** 
  @notice Changes admin for the contract
  @param _admin The address of the new admin.
  */
  function changeAdmin(address _admin) external onlyAdmin {
    admin = _admin;
    emit ChangeAdmin(_admin);
  }

  /// @dev Logic for changeFloatPercentage
  function _changeFloatPercentage(uint256 newFloatPercentage) internal virtual {
    require(newFloatPercentage <= 1e18 && newFloatPercentage > 0); // less than or equal to 100% and greater than 0%
    floatPercentage = newFloatPercentage;
  }

  /**
  @notice Changes percentage of float that is minted for float capital.
  @param newFloatPercentage The new float percentage in base 1e18.
  */
  function changeFloatPercentage(uint256 newFloatPercentage) external onlyAdmin {
    _changeFloatPercentage(newFloatPercentage);
    emit FloatPercentageUpdated(newFloatPercentage);
  }

  /// @dev Logic for changeUnstakeFee
  function _changeUnstakeFee(uint32 marketIndex, uint256 newMarketUnstakeFee_e18) internal virtual {
    require(newMarketUnstakeFee_e18 <= 5e16); // Explicitely stating 5% fee as the max fee possible.
    marketUnstakeFee_e18[marketIndex] = newMarketUnstakeFee_e18;
  }

  /**
  @notice Changes unstake fee for a market
  @param marketIndex Identifies the market.
  @param newMarketUnstakeFee_e18 The new unstake fee.
  */
  function changeUnstakeFee(uint32 marketIndex, uint256 newMarketUnstakeFee_e18) external onlyAdmin {
    _changeUnstakeFee(marketIndex, newMarketUnstakeFee_e18);
    emit StakeWithdrawalFeeUpdated(marketIndex, newMarketUnstakeFee_e18);
  }

  /// @dev Logic for changeMarketLaunchIncentiveParameters
  function _changeMarketLaunchIncentiveParameters(
    uint32 marketIndex,
    uint256 period,
    uint256 initialMultiplier
  ) internal virtual {
    require(initialMultiplier >= 1e18, "marketLaunchIncentiveMultiplier must be >= 1e18");

    marketLaunchIncentive_period[marketIndex] = period;
    marketLaunchIncentive_multipliers[marketIndex] = initialMultiplier;
  }

  /**
  @notice Changes the market launch incentive parameters for a market
  @param marketIndex Identifies the market.
  @param period The new period for which float token generation should be boosted.
  @param initialMultiplier The new multiplier on Float generation.
  */
  function changeMarketLaunchIncentiveParameters(
    uint32 marketIndex,
    uint256 period,
    uint256 initialMultiplier
  ) external onlyAdmin {
    _changeMarketLaunchIncentiveParameters(marketIndex, period, initialMultiplier);

    emit MarketLaunchIncentiveParametersChanges(marketIndex, period, initialMultiplier);
  }

  /// @dev Logic for changeBalanceIncentiveExponent
  function _changeBalanceIncentiveExponent(uint32 marketIndex, uint256 _balanceIncentiveCurve_exponent)
    internal
    virtual
  {
    require(
      // The exponent has to be less than 5 in these versions of the contracts.
      _balanceIncentiveCurve_exponent > 0 && _balanceIncentiveCurve_exponent < 6,
      "balanceIncentiveCurve_exponent out of bounds"
    );

    balanceIncentiveCurve_exponent[marketIndex] = _balanceIncentiveCurve_exponent;
  }

  /** 
  @notice Changes the balance incentive exponent for a market
  @param marketIndex Identifies the market.
  @param _balanceIncentiveCurve_exponent The new exponent for the curve.
  */
  function changeBalanceIncentiveExponent(uint32 marketIndex, uint256 _balanceIncentiveCurve_exponent)
    external
    onlyAdmin
  {
    _changeBalanceIncentiveExponent(marketIndex, _balanceIncentiveCurve_exponent);

    emit BalanceIncentiveExponentUpdated(marketIndex, _balanceIncentiveCurve_exponent);
  }

  /// @dev Logic for changeBalanceIncentiveEquilibriumOffset
  function _changeBalanceIncentiveEquilibriumOffset(uint32 marketIndex, int256 _balanceIncentiveCurve_equilibriumOffset)
    internal
    virtual
  {
    // Unreasonable that we would ever shift this more than 90% either way
    require(
      _balanceIncentiveCurve_equilibriumOffset > -9e17 && _balanceIncentiveCurve_equilibriumOffset < 9e17,
      "balanceIncentiveCurve_equilibriumOffset out of bounds"
    );

    balanceIncentiveCurve_equilibriumOffset[marketIndex] = _balanceIncentiveCurve_equilibriumOffset;
  }

  /**
  @notice Changes the balance incentive curve equilibrium offset for a market
  @param marketIndex Identifies the market.
  @param _balanceIncentiveCurve_equilibriumOffset The new offset.
  */
  function changeBalanceIncentiveEquilibriumOffset(uint32 marketIndex, int256 _balanceIncentiveCurve_equilibriumOffset)
    external
    onlyAdmin
  {
    _changeBalanceIncentiveEquilibriumOffset(marketIndex, _balanceIncentiveCurve_equilibriumOffset);

    emit BalanceIncentiveEquilibriumOffsetUpdated(marketIndex, _balanceIncentiveCurve_equilibriumOffset);
  }

  /*╔═════════════════════════════╗
    ║        STAKING SETUP        ║
    ╚═════════════════════════════╝*/

  /**
  @notice Sets this contract to track staking for a market in LongShort.sol
  @param marketIndex Identifies the market.
  @param longToken Address of the long token for the market.
  @param shortToken Address of the short token for the market.
  @param kInitialMultiplier Initial boost on float generation for the market.
  @param kPeriod Period which the boost should last.
  @param unstakeFee_e18 Percentage of tokens that are levied on unstaking in base 1e18.
  @param _balanceIncentiveCurve_exponent Exponent for balance curve (see _calculateFloatPerSecond)
  @param _balanceIncentiveCurve_equilibriumOffset Offset for balance curve (see _calculateFloatPerSecond)
  */
  function addNewStakingFund(
    uint32 marketIndex,
    address longToken,
    address shortToken,
    uint256 kInitialMultiplier,
    uint256 kPeriod,
    uint256 unstakeFee_e18,
    uint256 _balanceIncentiveCurve_exponent,
    int256 _balanceIncentiveCurve_equilibriumOffset
  ) external override onlyLongShort {
    marketIndexOfToken[longToken] = marketIndex;
    marketIndexOfToken[shortToken] = marketIndex;

    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].timestamp = block.timestamp;
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].accumulativeFloatPerSyntheticToken_long = 0;
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].accumulativeFloatPerSyntheticToken_short = 0;

    syntheticTokens[marketIndex][true] = longToken;
    syntheticTokens[marketIndex][false] = shortToken;

    _changeBalanceIncentiveExponent(marketIndex, _balanceIncentiveCurve_exponent);
    _changeBalanceIncentiveEquilibriumOffset(marketIndex, _balanceIncentiveCurve_equilibriumOffset);
    _changeMarketLaunchIncentiveParameters(marketIndex, kPeriod, kInitialMultiplier);

    _changeUnstakeFee(marketIndex, unstakeFee_e18);

    // Set this value to one initially - 0 is a null value and thus potentially bug prone.
    batched_stakerNextTokenShiftIndex[marketIndex] = 1;

    emit MarketAddedToStaker(
      marketIndex,
      unstakeFee_e18,
      kPeriod,
      kInitialMultiplier,
      _balanceIncentiveCurve_exponent,
      _balanceIncentiveCurve_equilibriumOffset
    );

    emit AccumulativeIssuancePerStakedSynthSnapshotCreated(marketIndex, 0, 0, 0);
  }

  /*╔═════════════════════════════════════════════════════════════════════════╗
    ║    GLOBAL FLT REWARD ACCUMULATION CALCULATION AND TRACKING FUNCTIONS    ║
    ╚═════════════════════════════════════════════════════════════════════════╝*/

  /**
  @notice Returns the K factor parameters for the given market with sensible
  defaults if they haven't been set yet.
  @param marketIndex The market to change the parameters for.
  @return period The period for which the k factor applies for in seconds.
  @return multiplier The multiplier on Float generation in this period.
  */
  function _getMarketLaunchIncentiveParameters(uint32 marketIndex)
    internal
    view
    virtual
    returns (uint256 period, uint256 multiplier)
  {
    period = marketLaunchIncentive_period[marketIndex];
    multiplier = marketLaunchIncentive_multipliers[marketIndex];

    if (multiplier < 1e18) {
      multiplier = 1e18; // multiplier of 1 by default
    }
  }

  /** 
  @notice Returns the extent to which a markets float generation should be adjusted
  based on the market's launch incentive parameters. Should start at multiplier
  then linearly change to 1e18 over time.
  @param marketIndex Identifies the market.
  @return k The calculated modifier for float generation.
  */
  function _getKValue(uint32 marketIndex) internal view virtual returns (uint256) {
    // Parameters controlling the float issuance multiplier.
    (uint256 kPeriod, uint256 kInitialMultiplier) = _getMarketLaunchIncentiveParameters(marketIndex);

    // Sanity check - under normal circumstances, the multipliers should
    // *never* be set to a value < 1e18, as there are guards against this.
    assert(kInitialMultiplier >= 1e18);

    uint256 initialTimestamp = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].timestamp;

    if (block.timestamp - initialTimestamp <= kPeriod) {
      return kInitialMultiplier - (((kInitialMultiplier - 1e18) * (block.timestamp - initialTimestamp)) / kPeriod);
    } else {
      return 1e18;
    }
  }

  /*
  @notice Computes the number of float tokens a user earns per second for
  every long/short synthetic token they've staked. The returned value has
  a fixed decimal scale of 1e42 (!!!) for numerical stability. The return
  values are float per second per synthetic token (hence the requirement
  to multiply by price)
  @dev to see below math in latex form see TODO add link
  to interact with the equations see https://www.desmos.com/calculator/optkaxyihr
  @param marketIndex The market referred to.
  @param longPrice Price of the synthetic long token in units of payment token
  @param shortPrice Price of the synthetic short token in units of payment token
  @param longValue Amount of payment token in the long side of the market
  @param shortValue Amount of payment token in the short side of the market
  @return longFloatPerSecond Float token per second per long synthetic token
  @return shortFloatPerSecond Float token per second per short synthetic token
   */
  function _calculateFloatPerSecond(
    uint32 marketIndex,
    uint256 longPrice,
    uint256 shortPrice,
    uint256 longValue,
    uint256 shortValue
  ) internal view virtual returns (uint256 longFloatPerSecond, uint256 shortFloatPerSecond) {
    // A float issuance multiplier that starts high and decreases linearly
    // over time to a value of 1. This incentivises users to stake early.
    uint256 k = _getKValue(marketIndex);

    uint256 totalLocked = (longValue + shortValue);

    // we need to scale this number by the totalLocked so that the offset remains consistent accross market size

    int256 equilibriumOffsetMarketScaled = (balanceIncentiveCurve_equilibriumOffset[marketIndex] *
      int256(totalLocked)) / 2e18;

    uint256 denominator = ((totalLocked >> safeExponentBitShifting)**balanceIncentiveCurve_exponent[marketIndex]);

    // Float is scaled by the percentage of the total market value held in
    // the opposite position. This incentivises users to stake on the
    // weaker position.
    if (int256(shortValue) - equilibriumOffsetMarketScaled < int256(longValue)) {
      if (equilibriumOffsetMarketScaled >= int256(shortValue)) {
        // edge case: imbalanced far past the equilibrium offset - full rewards go to short token
        //            extremeley unlikely to happen in practice
        return (0, 1e18 * k * shortPrice);
      }

      uint256 numerator = (uint256(int256(shortValue) - equilibriumOffsetMarketScaled) >>
        (safeExponentBitShifting - 1))**balanceIncentiveCurve_exponent[marketIndex];

      // NOTE: `x * 5e17` == `(x * 10e18) / 2`
      uint256 longRewardUnscaled = (numerator * 5e17) / denominator;
      uint256 shortRewardUnscaled = 1e18 - longRewardUnscaled;

      return ((longRewardUnscaled * k * longPrice) / 1e18, (shortRewardUnscaled * k * shortPrice) / 1e18);
    } else {
      if (-equilibriumOffsetMarketScaled >= int256(longValue)) {
        // edge case: imbalanced far past the equilibrium offset - full rewards go to long token
        //            extremeley unlikely to happen in practice
        return (1e18 * k * longPrice, 0);
      }

      uint256 numerator = (uint256(int256(longValue) + equilibriumOffsetMarketScaled) >>
        (safeExponentBitShifting - 1))**balanceIncentiveCurve_exponent[marketIndex];

      // NOTE: `x * 5e17` == `(x * 10e18) / 2`
      uint256 shortRewardUnscaled = (numerator * 5e17) / denominator;
      uint256 longRewardUnscaled = 1e18 - shortRewardUnscaled;

      return ((longRewardUnscaled * k * longPrice) / 1e18, (shortRewardUnscaled * k * shortPrice) / 1e18);
    }
  }

  /**
  @notice Computes the time since last accumulativeIssuancePerStakedSynthSnapshot for the given market in seconds.
  @param marketIndex The market referred to.
  @return The time difference in seconds
  */
  function _calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(uint32 marketIndex)
    internal
    view
    virtual
    returns (uint256)
  {
    return
      block.timestamp -
      accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]].timestamp;
  }

  /**
  @notice Computes new cumulative sum of 'r' value since last accumulativeIssuancePerStakedSynthSnapshot. We use
  cumulative 'r' value to avoid looping during issuance. Note that the
  cumulative sum is kept in 1e42 scale (!!!) to avoid numerical issues.
  @param shortValue The value locked in the short side of the market.
  @param longValue The value locked in the long side of the market.
  @param shortPrice The price of the short token as defined in LongShort.sol
  @param longPrice The price of the long token as defined in LongShort.sol
  @param marketIndex An identifier for the market.
  @return longCumulativeRates The long cumulative sum.
  @return shortCumulativeRates The short cumulative sum.
  */
  function _calculateNewCumulativeIssuancePerStakedSynth(
    uint32 marketIndex,
    uint256 longPrice,
    uint256 shortPrice,
    uint256 longValue,
    uint256 shortValue
  ) internal view virtual returns (uint256 longCumulativeRates, uint256 shortCumulativeRates) {
    // Compute the current 'r' value for float issuance per second.
    (uint256 longFloatPerSecond, uint256 shortFloatPerSecond) = _calculateFloatPerSecond(
      marketIndex,
      longPrice,
      shortPrice,
      longValue,
      shortValue
    );

    // Compute time since last accumulativeIssuancePerStakedSynthSnapshot for the given token.
    uint256 timeDelta = _calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(marketIndex);

    // Compute new cumulative 'r' value total.
    return (
      accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]]
      .accumulativeFloatPerSyntheticToken_long + (timeDelta * longFloatPerSecond),
      accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]]
      .accumulativeFloatPerSyntheticToken_short + (timeDelta * shortFloatPerSecond)
    );
  }

  /**
  @notice Creates a new accumulativeIssuancePerStakedSynthSnapshot for the given token and updates indexes.
  @param shortValue The value locked in the short side of the market.
  @param longValue The value locked in the long side of the market.
  @param shortPrice The price of the short token as defined in LongShort.sol
  @param longPrice The price of the long token as defined in LongShort.sol
  @param marketIndex An identifier for the market.
  */
  function _setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot(
    uint32 marketIndex,
    uint256 longPrice,
    uint256 shortPrice,
    uint256 longValue,
    uint256 shortValue
  ) internal virtual {
    (
      uint256 newLongAccumulativeValue,
      uint256 newShortAccumulativeValue
    ) = _calculateNewCumulativeIssuancePerStakedSynth(marketIndex, longPrice, shortPrice, longValue, shortValue);

    uint256 newIndex = latestRewardIndex[marketIndex] + 1;

    // Set cumulative 'r' value on new accumulativeIssuancePerStakedSynthSnapshot.
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex]
    .accumulativeFloatPerSyntheticToken_long = newLongAccumulativeValue;
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex]
    .accumulativeFloatPerSyntheticToken_short = newShortAccumulativeValue;

    // Set timestamp on new accumulativeIssuancePerStakedSynthSnapshot.
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex].timestamp = block.timestamp;

    // Update latest index to point to new accumulativeIssuancePerStakedSynthSnapshot.
    latestRewardIndex[marketIndex] = newIndex;

    emit AccumulativeIssuancePerStakedSynthSnapshotCreated(
      marketIndex,
      newIndex,
      newLongAccumulativeValue,
      newShortAccumulativeValue
    );
  }

  /**
  @notice Adds new accumulativeIssuancePerStakedSynthSnapshots for the given long/short tokens. Called by the
  ILongShort contract whenever there is a state change for a market.
  @param stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted Mapping from this contract's shifts to LongShort.sols next price snapshots.
  @param shortValue The value locked in the short side of the market.
  @param longValue The value locked in the long side of the market.
  @param shortPrice The price of the short token as defined in LongShort.sol
  @param longPrice The price of the long token as defined in LongShort.sol
  @param marketIndex An identifier for the market.
  */
  function pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(
    uint32 marketIndex,
    uint256 longPrice,
    uint256 shortPrice,
    uint256 longValue,
    uint256 shortValue,
    uint256 stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted // This value should be ALWAYS be zero if no shift occured
  ) external override onlyLongShort {
    // Only add a new accumulativeIssuancePerStakedSynthSnapshot if some time has passed.

    // the `stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted` value will be 0 if there is no staker related action in an executed batch
    if (stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted > 0) {
      stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[
        batched_stakerNextTokenShiftIndex[marketIndex]
      ] = stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted;
      stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[
        batched_stakerNextTokenShiftIndex[marketIndex]
      ] = latestRewardIndex[marketIndex] + 1;
      batched_stakerNextTokenShiftIndex[marketIndex] += 1;

      emit SyntheticTokensShifted();
    }

    // Time delta is fetched twice in below code, can pass through? Which is less gas?
    if (_calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(marketIndex) > 0) {
      _setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot(
        marketIndex,
        longPrice,
        shortPrice,
        longValue,
        shortValue
      );
    }
  }

  /*╔═══════════════════════════════════╗
    ║    USER REWARD STATE FUNCTIONS    ║
    ╚═══════════════════════════════════╝*/

  /// @dev Calculates the accumulated float in a specific range of staker snapshots
  function _calculateAccumulatedFloatInRange(
    uint32 marketIndex,
    uint256 amountStakedLong,
    uint256 amountStakedShort,
    uint256 rewardIndexFrom,
    uint256 rewardIndexTo
  ) internal view virtual returns (uint256 floatReward) {
    if (amountStakedLong > 0) {
      uint256 accumDeltaLong = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexTo]
      .accumulativeFloatPerSyntheticToken_long -
        accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexFrom]
        .accumulativeFloatPerSyntheticToken_long;
      floatReward += (accumDeltaLong * amountStakedLong) / FLOAT_ISSUANCE_FIXED_DECIMAL;
    }

    if (amountStakedShort > 0) {
      uint256 accumDeltaShort = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexTo]
      .accumulativeFloatPerSyntheticToken_short -
        accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexFrom]
        .accumulativeFloatPerSyntheticToken_short;
      floatReward += (accumDeltaShort * amountStakedShort) / FLOAT_ISSUANCE_FIXED_DECIMAL;
    }
  }

  /** 
  @notice Calculates float owed to the user since the user last minted float for a market.
  @param marketIndex Identifier for the market which the user staked in.
  @param user The address of the user.
  @return floatReward The amount of float owed.
   */
  function _calculateAccumulatedFloat(uint32 marketIndex, address user) internal virtual returns (uint256 floatReward) {
    address longToken = syntheticTokens[marketIndex][true];
    address shortToken = syntheticTokens[marketIndex][false];

    uint256 amountStakedLong = userAmountStaked[longToken][user];
    uint256 amountStakedShort = userAmountStaked[shortToken][user];

    uint256 usersLastRewardIndex = userIndexOfLastClaimedReward[marketIndex][user];

    // Don't do the calculation and return zero immediately if there is no change
    if (usersLastRewardIndex == latestRewardIndex[marketIndex]) {
      return 0;
    }

    uint256 usersShiftIndex = userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][user];
    // if there is a change in the users tokens held due to a token shift (or possibly another action in the future)
    if (usersShiftIndex > 0 && usersShiftIndex < batched_stakerNextTokenShiftIndex[marketIndex]) {
      floatReward = _calculateAccumulatedFloatInRange(
        marketIndex,
        amountStakedLong,
        amountStakedShort,
        usersLastRewardIndex,
        stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[usersShiftIndex]
      );

      // Update the users balances
      if (userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user] > 0) {
        amountStakedShort += ILongShort(longShort).getAmountSyntheticTokenToMintOnTargetSide(
          marketIndex,
          userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user],
          true,
          stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[usersShiftIndex]
        );

        amountStakedLong -= userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user];
        userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user] = 0;
      }

      if (userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user] > 0) {
        amountStakedLong += ILongShort(longShort).getAmountSyntheticTokenToMintOnTargetSide(
          marketIndex,
          userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user],
          false,
          stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[usersShiftIndex]
        );

        amountStakedShort -= userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user];
        userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user] = 0;
      }

      // Save the users updated staked amounts
      userAmountStaked[longToken][user] = amountStakedLong;
      userAmountStaked[shortToken][user] = amountStakedShort;

      floatReward += _calculateAccumulatedFloatInRange(
        marketIndex,
        amountStakedLong,
        amountStakedShort,
        stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[usersShiftIndex],
        latestRewardIndex[marketIndex]
      );

      userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][user] = 0;
    } else {
      floatReward = _calculateAccumulatedFloatInRange(
        marketIndex,
        amountStakedLong,
        amountStakedShort,
        usersLastRewardIndex,
        latestRewardIndex[marketIndex]
      );
    }
  }

  /**
  @notice Mints float for a user.
  @dev Mints a fixed percentage for Float capital.
  @param user The address of the user.
  @param floatToMint The amount of float to mint.
   */
  function _mintFloat(address user, uint256 floatToMint) internal virtual {
    IFloatToken(floatToken).mint(user, floatToMint);
    IFloatToken(floatToken).mint(floatCapital, (floatToMint * floatPercentage) / 1e18);
  }

  /**
  @notice Mints float owed to a user for a market since they last minted.
  @param marketIndex An identifier for the market.
  @param user The address of the user.
   */
  function _mintAccumulatedFloat(uint32 marketIndex, address user) internal virtual {
    uint256 floatToMint = _calculateAccumulatedFloat(marketIndex, user);

    if (floatToMint > 0) {
      // Set the user has claimed up until now, stops them setting this forward
      userIndexOfLastClaimedReward[marketIndex][user] = latestRewardIndex[marketIndex];

      _mintFloat(user, floatToMint);
      emit FloatMinted(user, marketIndex, floatToMint);
    }
  }

  /**
  @notice Mints float owed to a user for multiple markets, since they last minted for those markets.
  @param marketIndexes Identifiers for the markets.
  @param user The address of the user.
   */
  function _mintAccumulatedFloatMulti(uint32[] calldata marketIndexes, address user) internal virtual {
    uint256 floatTotal = 0;
    for (uint256 i = 0; i < marketIndexes.length; i++) {
      uint256 floatToMint = _calculateAccumulatedFloat(marketIndexes[i], user);

      if (floatToMint > 0) {
        // Set the user has claimed up until now, stops them setting this forward
        userIndexOfLastClaimedReward[marketIndexes[i]][user] = latestRewardIndex[marketIndexes[i]];

        floatTotal += floatToMint;

        emit FloatMinted(user, marketIndexes[i], floatToMint);
      }
    }
    if (floatTotal > 0) {
      _mintFloat(user, floatTotal);
    }
  }

  /**
  @notice Mints outstanding float for msg.sender.
  @param marketIndexes Identifiers for the markets for which to mint float.
   */
  function claimFloatCustom(uint32[] calldata marketIndexes) external {
    ILongShort(longShort).updateSystemStateMulti(marketIndexes);
    _mintAccumulatedFloatMulti(marketIndexes, msg.sender);
  }

  /**
  @notice Mints outstanding float on behalf of another user.
  @param marketIndexes Identifiers for the markets for which to mint float.
  @param user The address of the user.
   */
  function claimFloatCustomFor(uint32[] calldata marketIndexes, address user) external {
    // Unbounded loop - users are responsible for paying their own gas costs on these and it doesn't effect the rest of the system.
    // No need to impose limit.
    ILongShort(longShort).updateSystemStateMulti(marketIndexes);
    _mintAccumulatedFloatMulti(marketIndexes, user);
  }

  /*╔═══════════════════════╗
    ║        STAKING        ║
    ╚═══════════════════════╝*/

  /**
  @notice A user with synthetic tokens stakes by calling stake on the token
  contract which calls this function. We need to first update the
  state of the LongShort contract for this market before staking to correctly calculate user rewards.
  @param amount Amount to stake.
  @param from Address to stake for.
  */
  function stakeFromUser(address from, uint256 amount) public virtual override onlyValidSynthetic((msg.sender)) {
    ILongShort(longShort).updateSystemState(marketIndexOfToken[(msg.sender)]);
    _stake((msg.sender), amount, from);
  }

  /**
  @dev Internal logic for staking.
  @param token Address of the token for which to stake.
  @param amount Amount to stake.
  @param user Address to stake for.
  */
  function _stake(
    address token,
    uint256 amount,
    address user
  ) internal virtual {
    uint32 marketIndex = marketIndexOfToken[token];

    // If they already have staked and have rewards due, mint these.
    if (
      userIndexOfLastClaimedReward[marketIndex][user] != 0 &&
      userIndexOfLastClaimedReward[marketIndex][user] < latestRewardIndex[marketIndex]
    ) {
      _mintAccumulatedFloat(marketIndex, user);
    }

    userAmountStaked[token][user] = userAmountStaked[token][user] + amount;

    userIndexOfLastClaimedReward[marketIndex][user] = latestRewardIndex[marketIndex];

    emit StakeAdded(user, address(token), amount, userIndexOfLastClaimedReward[marketIndex][user]);
  }

  /**
  @notice Allows users to shift their staked tokens from one side of the market to 
  the other at the next price.
  @param amountSyntheticTokensToShift Amount of tokens to shift.
  @param marketIndex Identifier for the market.
  @param isShiftFromLong Whether the shift is from long to short or short to long.
  */
  function shiftTokens(
    uint256 amountSyntheticTokensToShift,
    uint32 marketIndex,
    bool isShiftFromLong
  ) external virtual {
    address token = syntheticTokens[marketIndex][isShiftFromLong];
    require(userAmountStaked[token][msg.sender] >= amountSyntheticTokensToShift, "Not enough tokens to shift");

    // If the user has outstanding token shift that have already been confirmed in the LongShort
    // contract, execute them first.
    if (
      userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] != 0 &&
      userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] <
      batched_stakerNextTokenShiftIndex[marketIndex]
    ) {
      _mintAccumulatedFloat(marketIndex, msg.sender);
    }

    if (isShiftFromLong) {
      ILongShort(longShort).shiftPositionFromLongNextPrice(marketIndex, amountSyntheticTokensToShift);
      userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][
        msg.sender
      ] += amountSyntheticTokensToShift;
    } else {
      ILongShort(longShort).shiftPositionFromShortNextPrice(marketIndex, amountSyntheticTokensToShift);
      userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][
        msg.sender
      ] += amountSyntheticTokensToShift;
    }

    userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] = batched_stakerNextTokenShiftIndex[
      marketIndex
    ];
  }

  /*╔════════════════════════════╗
    ║    WITHDRAWAL & MINTING    ║
    ╚════════════════════════════╝*/

  /**
  @notice Internal logic for withdrawing stakes.
  @dev Mint user any outstanding float before withdrawing.
  @param marketIndex Market index of token.
  @param amount Amount to withdraw.
  @param token Synthetic token that was staked.
  */
  function _withdraw(
    uint32 marketIndex,
    address token,
    uint256 amount
  ) internal virtual {
    require(userAmountStaked[token][msg.sender] > 0, "nothing to withdraw");
    _mintAccumulatedFloat(marketIndex, msg.sender);

    userAmountStaked[token][msg.sender] = userAmountStaked[token][msg.sender] - amount;

    uint256 amountFees = (amount * marketUnstakeFee_e18[marketIndex]) / 1e18;

    IERC20(token).transfer(floatTreasury, amountFees);
    IERC20(token).transfer(msg.sender, amount - amountFees);

    emit StakeWithdrawn(msg.sender, token, amount);
  }

  /**
  @notice Withdraw function. Allows users to unstake.
  @param amount Amount to withdraw.
  @param token Address of the token for which to withdraw.
  */
  function withdraw(address token, uint256 amount) external {
    ILongShort(longShort).updateSystemState(marketIndexOfToken[token]);

    uint32 marketIndex = marketIndexOfToken[token];

    _withdraw(marketIndex, token, amount);

    if (userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] > 0) {
      // If they still have outstanding shifts after minting float, then check
      // that they don't withdraw more than their shifts allow.
      uint256 amountToShiftForThisToken = syntheticTokens[marketIndex][true] == token
        ? userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][msg.sender]
        : userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][msg.sender];

      require(
        userAmountStaked[token][msg.sender] >= amountToShiftForThisToken,
        "Outstanding next price stake shifts too great"
      );
    }
  }

  /**
  @notice Allows users to withdraw their entire stake for a token.
  @param token Address of the token for which to withdraw.
  */
  function withdrawAll(address token) external {
    ILongShort(longShort).updateSystemState(marketIndexOfToken[token]);

    uint32 marketIndex = marketIndexOfToken[token];

    uint256 amountToShiftForThisToken = syntheticTokens[marketIndex][true] == token
      ? userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][msg.sender]
      : userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][msg.sender];

    _withdraw(marketIndex, token, userAmountStaked[token][msg.sender] - amountToShiftForThisToken);
  }
}
.]

Given the user's task and the brainstorming ideas provided:
Task: "// SPDX-License-Identifier: BUSL-1.1

pragma solidity 0.8.3;

import "@openzeppelin/contracts-upgradeable/token/ERC20/presets/ERC20PresetMinterPauserUpgradeable.sol";

import "./interfaces/IFloatToken.sol";
import "./interfaces/ILongShort.sol";
import "./interfaces/IStaker.sol";
import "./interfaces/ISyntheticToken.sol";

contract Staker is IStaker, Initializable {
  /*╔═════════════════════════════╗
    ║          VARIABLES          ║
    ╚═════════════════════════════╝*/

  /* ══════ Fixed-precision constants ══════ */
  uint256 public constant FLOAT_ISSUANCE_FIXED_DECIMAL = 1e42;
  // 2^52 ~= 4.5e15
  // With an exponent of 5, the largest total liquidity possible in a market (to avoid integer overflow on exponentiation) is ~10^31 or 10 Trillion (10^13)
  // NOTE: this also means if the total market value is less than 2^52 there will be a division by zero error
  uint256 public constant safeExponentBitShifting = 52;

  /* ══════ Global state ══════ */
  address public admin;
  address public floatCapital;
  address public floatTreasury;
  uint256 public floatPercentage;

  address public longShort;
  address public floatToken;

  /* ══════ Market specific ══════ */
  mapping(uint32 => uint256) public marketLaunchIncentive_period; // seconds
  mapping(uint32 => uint256) public marketLaunchIncentive_multipliers; // e18 scale
  mapping(uint32 => uint256) public marketUnstakeFee_e18;
  mapping(uint32 => uint256) public balanceIncentiveCurve_exponent;
  mapping(uint32 => int256) public balanceIncentiveCurve_equilibriumOffset;

  mapping(uint32 => mapping(bool => address)) public syntheticTokens;

  mapping(address => uint32) public marketIndexOfToken;

  /* ══════ Reward specific ══════ */
  mapping(uint32 => uint256) public latestRewardIndex;
  mapping(uint32 => mapping(uint256 => AccumulativeIssuancePerStakedSynthSnapshot))
    public accumulativeFloatPerSyntheticTokenSnapshots;
  struct AccumulativeIssuancePerStakedSynthSnapshot {
    uint256 timestamp;
    uint256 accumulativeFloatPerSyntheticToken_long;
    uint256 accumulativeFloatPerSyntheticToken_short;
  }

  /* ══════ User specific ══════ */
  mapping(uint32 => mapping(address => uint256)) public userIndexOfLastClaimedReward;
  mapping(address => mapping(address => uint256)) public userAmountStaked;

  /* ══════ Token shift management specific ══════ */
  mapping(uint32 => uint256) public batched_stakerNextTokenShiftIndex;
  /**
  @notice Used to link a token shift to a staker state
  @dev tokenShiftIndex => accumulativeFloatIssuanceSnapshotIndex
    POSSIBLE OPTIMIZATION - could pack stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping and stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping into a struct of two uint128 for storage space optimization.
  */
  mapping(uint256 => uint256) public stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping;
  /// @notice Used to fetch the price from LongShort at that point in time
  /// @dev tokenShiftIndex => longShortMarketPriceSnapshotIndex
  mapping(uint256 => uint256) public stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping;
  /// @dev marketIndex => usersAddress => stakerTokenShiftIndex
  mapping(uint32 => mapping(address => uint256)) public userNextPrice_stakedSyntheticTokenShiftIndex;
  /// @dev marketIndex => usersAddress => amountUserRequestedToShiftAwayFromLongOnNextUpdate
  mapping(uint32 => mapping(address => uint256)) public userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long;
  /// @dev marketIndex => usersAddress => amountUserRequestedToShiftAwayFromShortOnNextUpdate
  mapping(uint32 => mapping(address => uint256)) public userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short;

  /*╔════════════════════════════╗
    ║           EVENTS           ║
    ╚════════════════════════════╝*/

  event StakerV1(
    address admin,
    address floatTreasury,
    address floatCapital,
    address floatToken,
    uint256 floatPercentage
  );

  event MarketAddedToStaker(
    uint32 marketIndex,
    uint256 exitFee_e18,
    uint256 period,
    uint256 multiplier,
    uint256 balanceIncentiveExponent,
    int256 balanceIncentiveEquilibriumOffset
  );

  event AccumulativeIssuancePerStakedSynthSnapshotCreated(
    uint32 marketIndex,
    uint256 accumulativeFloatIssuanceSnapshotIndex,
    uint256 accumulativeLong,
    uint256 accumulativeShort
  );

  event StakeAdded(address user, address token, uint256 amount, uint256 lastMintIndex);

  event StakeWithdrawn(address user, address token, uint256 amount);

  // Note: the `amountFloatMinted` isn't strictly needed by the graph, but it is good to add it to validate calculations are accurate.
  event FloatMinted(address user, uint32 marketIndex, uint256 amountFloatMinted);

  event MarketLaunchIncentiveParametersChanges(uint32 marketIndex, uint256 period, uint256 multiplier);

  event StakeWithdrawalFeeUpdated(uint32 marketIndex, uint256 stakeWithdralFee);

  event BalanceIncentiveExponentUpdated(uint32 marketIndex, uint256 balanceIncentiveExponent);

  event BalanceIncentiveEquilibriumOffsetUpdated(uint32 marketIndex, int256 balanceIncentiveEquilibriumOffset);

  event FloatPercentageUpdated(uint256 floatPercentage);

  event SyntheticTokensShifted();

  event ChangeAdmin(address newAdmin);

  /*╔═════════════════════════════╗
    ║          MODIFIERS          ║
    ╚═════════════════════════════╝*/

  function onlyAdminModifierLogic() internal virtual {
    require(msg.sender == admin, "not admin");
  }

  modifier onlyAdmin() {
    onlyAdminModifierLogic();
    _;
  }

  function onlyValidSyntheticModifierLogic(address _synth) internal virtual {
    require(marketIndexOfToken[_synth] != 0, "not valid synth");
  }

  modifier onlyValidSynthetic(address _synth) {
    onlyValidSyntheticModifierLogic(_synth);
    _;
  }

  function onlyValidMarketModifierLogic(uint32 marketIndex) internal virtual {
    require(address(syntheticTokens[marketIndex][true]) != address(0), "not valid market");
  }

  modifier onlyValidMarket(uint32 marketIndex) {
    onlyValidMarketModifierLogic(marketIndex);
    _;
  }

  function onlyLongShortModifierLogic() internal virtual {
    require(msg.sender == address(longShort), "not long short");
  }

  modifier onlyLongShort() {
    onlyLongShortModifierLogic();
    _;
  }

  /*╔═════════════════════════════╗
    ║       CONTRACT SET-UP       ║
    ╚═════════════════════════════╝*/

  /**
  @notice Initializes the contract.
  @dev Calls OpenZeppelin's initializer modifier.
  @param _admin Address of the admin role.
  @param _longShort Address of the LongShort contract, a deployed LongShort.sol
  @param _floatToken Address of the Float token earned by staking.
  @param _floatTreasury Address of the treasury contract for managing fees.
  @param _floatCapital Address of the contract which earns a fixed percentage of Float.
  @param _floatPercentage Determines the float percentage that gets minted for Float Capital, base 1e18.
  */
  function initialize(
    address _admin,
    address _longShort,
    address _floatToken,
    address _floatTreasury,
    address _floatCapital,
    uint256 _floatPercentage
  ) external virtual initializer {
    admin = _admin;
    floatCapital = _floatCapital;
    floatTreasury = _floatTreasury;
    longShort = _longShort;
    floatToken = _floatToken;

    _changeFloatPercentage(_floatPercentage);

    emit StakerV1(_admin, _floatTreasury, _floatCapital, _floatToken, _floatPercentage);
  }

  /*╔═══════════════════╗
    ║       ADMIN       ║
    ╚═══════════════════╝*/

  /** 
  @notice Changes admin for the contract
  @param _admin The address of the new admin.
  */
  function changeAdmin(address _admin) external onlyAdmin {
    admin = _admin;
    emit ChangeAdmin(_admin);
  }

  /// @dev Logic for changeFloatPercentage
  function _changeFloatPercentage(uint256 newFloatPercentage) internal virtual {
    require(newFloatPercentage <= 1e18 && newFloatPercentage > 0); // less than or equal to 100% and greater than 0%
    floatPercentage = newFloatPercentage;
  }

  /**
  @notice Changes percentage of float that is minted for float capital.
  @param newFloatPercentage The new float percentage in base 1e18.
  */
  function changeFloatPercentage(uint256 newFloatPercentage) external onlyAdmin {
    _changeFloatPercentage(newFloatPercentage);
    emit FloatPercentageUpdated(newFloatPercentage);
  }

  /// @dev Logic for changeUnstakeFee
  function _changeUnstakeFee(uint32 marketIndex, uint256 newMarketUnstakeFee_e18) internal virtual {
    require(newMarketUnstakeFee_e18 <= 5e16); // Explicitely stating 5% fee as the max fee possible.
    marketUnstakeFee_e18[marketIndex] = newMarketUnstakeFee_e18;
  }

  /**
  @notice Changes unstake fee for a market
  @param marketIndex Identifies the market.
  @param newMarketUnstakeFee_e18 The new unstake fee.
  */
  function changeUnstakeFee(uint32 marketIndex, uint256 newMarketUnstakeFee_e18) external onlyAdmin {
    _changeUnstakeFee(marketIndex, newMarketUnstakeFee_e18);
    emit StakeWithdrawalFeeUpdated(marketIndex, newMarketUnstakeFee_e18);
  }

  /// @dev Logic for changeMarketLaunchIncentiveParameters
  function _changeMarketLaunchIncentiveParameters(
    uint32 marketIndex,
    uint256 period,
    uint256 initialMultiplier
  ) internal virtual {
    require(initialMultiplier >= 1e18, "marketLaunchIncentiveMultiplier must be >= 1e18");

    marketLaunchIncentive_period[marketIndex] = period;
    marketLaunchIncentive_multipliers[marketIndex] = initialMultiplier;
  }

  /**
  @notice Changes the market launch incentive parameters for a market
  @param marketIndex Identifies the market.
  @param period The new period for which float token generation should be boosted.
  @param initialMultiplier The new multiplier on Float generation.
  */
  function changeMarketLaunchIncentiveParameters(
    uint32 marketIndex,
    uint256 period,
    uint256 initialMultiplier
  ) external onlyAdmin {
    _changeMarketLaunchIncentiveParameters(marketIndex, period, initialMultiplier);

    emit MarketLaunchIncentiveParametersChanges(marketIndex, period, initialMultiplier);
  }

  /// @dev Logic for changeBalanceIncentiveExponent
  function _changeBalanceIncentiveExponent(uint32 marketIndex, uint256 _balanceIncentiveCurve_exponent)
    internal
    virtual
  {
    require(
      // The exponent has to be less than 5 in these versions of the contracts.
      _balanceIncentiveCurve_exponent > 0 && _balanceIncentiveCurve_exponent < 6,
      "balanceIncentiveCurve_exponent out of bounds"
    );

    balanceIncentiveCurve_exponent[marketIndex] = _balanceIncentiveCurve_exponent;
  }

  /** 
  @notice Changes the balance incentive exponent for a market
  @param marketIndex Identifies the market.
  @param _balanceIncentiveCurve_exponent The new exponent for the curve.
  */
  function changeBalanceIncentiveExponent(uint32 marketIndex, uint256 _balanceIncentiveCurve_exponent)
    external
    onlyAdmin
  {
    _changeBalanceIncentiveExponent(marketIndex, _balanceIncentiveCurve_exponent);

    emit BalanceIncentiveExponentUpdated(marketIndex, _balanceIncentiveCurve_exponent);
  }

  /// @dev Logic for changeBalanceIncentiveEquilibriumOffset
  function _changeBalanceIncentiveEquilibriumOffset(uint32 marketIndex, int256 _balanceIncentiveCurve_equilibriumOffset)
    internal
    virtual
  {
    // Unreasonable that we would ever shift this more than 90% either way
    require(
      _balanceIncentiveCurve_equilibriumOffset > -9e17 && _balanceIncentiveCurve_equilibriumOffset < 9e17,
      "balanceIncentiveCurve_equilibriumOffset out of bounds"
    );

    balanceIncentiveCurve_equilibriumOffset[marketIndex] = _balanceIncentiveCurve_equilibriumOffset;
  }

  /**
  @notice Changes the balance incentive curve equilibrium offset for a market
  @param marketIndex Identifies the market.
  @param _balanceIncentiveCurve_equilibriumOffset The new offset.
  */
  function changeBalanceIncentiveEquilibriumOffset(uint32 marketIndex, int256 _balanceIncentiveCurve_equilibriumOffset)
    external
    onlyAdmin
  {
    _changeBalanceIncentiveEquilibriumOffset(marketIndex, _balanceIncentiveCurve_equilibriumOffset);

    emit BalanceIncentiveEquilibriumOffsetUpdated(marketIndex, _balanceIncentiveCurve_equilibriumOffset);
  }

  /*╔═════════════════════════════╗
    ║        STAKING SETUP        ║
    ╚═════════════════════════════╝*/

  /**
  @notice Sets this contract to track staking for a market in LongShort.sol
  @param marketIndex Identifies the market.
  @param longToken Address of the long token for the market.
  @param shortToken Address of the short token for the market.
  @param kInitialMultiplier Initial boost on float generation for the market.
  @param kPeriod Period which the boost should last.
  @param unstakeFee_e18 Percentage of tokens that are levied on unstaking in base 1e18.
  @param _balanceIncentiveCurve_exponent Exponent for balance curve (see _calculateFloatPerSecond)
  @param _balanceIncentiveCurve_equilibriumOffset Offset for balance curve (see _calculateFloatPerSecond)
  */
  function addNewStakingFund(
    uint32 marketIndex,
    address longToken,
    address shortToken,
    uint256 kInitialMultiplier,
    uint256 kPeriod,
    uint256 unstakeFee_e18,
    uint256 _balanceIncentiveCurve_exponent,
    int256 _balanceIncentiveCurve_equilibriumOffset
  ) external override onlyLongShort {
    marketIndexOfToken[longToken] = marketIndex;
    marketIndexOfToken[shortToken] = marketIndex;

    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].timestamp = block.timestamp;
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].accumulativeFloatPerSyntheticToken_long = 0;
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].accumulativeFloatPerSyntheticToken_short = 0;

    syntheticTokens[marketIndex][true] = longToken;
    syntheticTokens[marketIndex][false] = shortToken;

    _changeBalanceIncentiveExponent(marketIndex, _balanceIncentiveCurve_exponent);
    _changeBalanceIncentiveEquilibriumOffset(marketIndex, _balanceIncentiveCurve_equilibriumOffset);
    _changeMarketLaunchIncentiveParameters(marketIndex, kPeriod, kInitialMultiplier);

    _changeUnstakeFee(marketIndex, unstakeFee_e18);

    // Set this value to one initially - 0 is a null value and thus potentially bug prone.
    batched_stakerNextTokenShiftIndex[marketIndex] = 1;

    emit MarketAddedToStaker(
      marketIndex,
      unstakeFee_e18,
      kPeriod,
      kInitialMultiplier,
      _balanceIncentiveCurve_exponent,
      _balanceIncentiveCurve_equilibriumOffset
    );

    emit AccumulativeIssuancePerStakedSynthSnapshotCreated(marketIndex, 0, 0, 0);
  }

  /*╔═════════════════════════════════════════════════════════════════════════╗
    ║    GLOBAL FLT REWARD ACCUMULATION CALCULATION AND TRACKING FUNCTIONS    ║
    ╚═════════════════════════════════════════════════════════════════════════╝*/

  /**
  @notice Returns the K factor parameters for the given market with sensible
  defaults if they haven't been set yet.
  @param marketIndex The market to change the parameters for.
  @return period The period for which the k factor applies for in seconds.
  @return multiplier The multiplier on Float generation in this period.
  */
  function _getMarketLaunchIncentiveParameters(uint32 marketIndex)
    internal
    view
    virtual
    returns (uint256 period, uint256 multiplier)
  {
    period = marketLaunchIncentive_period[marketIndex];
    multiplier = marketLaunchIncentive_multipliers[marketIndex];

    if (multiplier < 1e18) {
      multiplier = 1e18; // multiplier of 1 by default
    }
  }

  /** 
  @notice Returns the extent to which a markets float generation should be adjusted
  based on the market's launch incentive parameters. Should start at multiplier
  then linearly change to 1e18 over time.
  @param marketIndex Identifies the market.
  @return k The calculated modifier for float generation.
  */
  function _getKValue(uint32 marketIndex) internal view virtual returns (uint256) {
    // Parameters controlling the float issuance multiplier.
    (uint256 kPeriod, uint256 kInitialMultiplier) = _getMarketLaunchIncentiveParameters(marketIndex);

    // Sanity check - under normal circumstances, the multipliers should
    // *never* be set to a value < 1e18, as there are guards against this.
    assert(kInitialMultiplier >= 1e18);

    uint256 initialTimestamp = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].timestamp;

    if (block.timestamp - initialTimestamp <= kPeriod) {
      return kInitialMultiplier - (((kInitialMultiplier - 1e18) * (block.timestamp - initialTimestamp)) / kPeriod);
    } else {
      return 1e18;
    }
  }

  /*
  @notice Computes the number of float tokens a user earns per second for
  every long/short synthetic token they've staked. The returned value has
  a fixed decimal scale of 1e42 (!!!) for numerical stability. The return
  values are float per second per synthetic token (hence the requirement
  to multiply by price)
  @dev to see below math in latex form see TODO add link
  to interact with the equations see https://www.desmos.com/calculator/optkaxyihr
  @param marketIndex The market referred to.
  @param longPrice Price of the synthetic long token in units of payment token
  @param shortPrice Price of the synthetic short token in units of payment token
  @param longValue Amount of payment token in the long side of the market
  @param shortValue Amount of payment token in the short side of the market
  @return longFloatPerSecond Float token per second per long synthetic token
  @return shortFloatPerSecond Float token per second per short synthetic token
   */
  function _calculateFloatPerSecond(
    uint32 marketIndex,
    uint256 longPrice,
    uint256 shortPrice,
    uint256 longValue,
    uint256 shortValue
  ) internal view virtual returns (uint256 longFloatPerSecond, uint256 shortFloatPerSecond) {
    // A float issuance multiplier that starts high and decreases linearly
    // over time to a value of 1. This incentivises users to stake early.
    uint256 k = _getKValue(marketIndex);

    uint256 totalLocked = (longValue + shortValue);

    // we need to scale this number by the totalLocked so that the offset remains consistent accross market size

    int256 equilibriumOffsetMarketScaled = (balanceIncentiveCurve_equilibriumOffset[marketIndex] *
      int256(totalLocked)) / 2e18;

    uint256 denominator = ((totalLocked >> safeExponentBitShifting)**balanceIncentiveCurve_exponent[marketIndex]);

    // Float is scaled by the percentage of the total market value held in
    // the opposite position. This incentivises users to stake on the
    // weaker position.
    if (int256(shortValue) - equilibriumOffsetMarketScaled < int256(longValue)) {
      if (equilibriumOffsetMarketScaled >= int256(shortValue)) {
        // edge case: imbalanced far past the equilibrium offset - full rewards go to short token
        //            extremeley unlikely to happen in practice
        return (0, 1e18 * k * shortPrice);
      }

      uint256 numerator = (uint256(int256(shortValue) - equilibriumOffsetMarketScaled) >>
        (safeExponentBitShifting - 1))**balanceIncentiveCurve_exponent[marketIndex];

      // NOTE: `x * 5e17` == `(x * 10e18) / 2`
      uint256 longRewardUnscaled = (numerator * 5e17) / denominator;
      uint256 shortRewardUnscaled = 1e18 - longRewardUnscaled;

      return ((longRewardUnscaled * k * longPrice) / 1e18, (shortRewardUnscaled * k * shortPrice) / 1e18);
    } else {
      if (-equilibriumOffsetMarketScaled >= int256(longValue)) {
        // edge case: imbalanced far past the equilibrium offset - full rewards go to long token
        //            extremeley unlikely to happen in practice
        return (1e18 * k * longPrice, 0);
      }

      uint256 numerator = (uint256(int256(longValue) + equilibriumOffsetMarketScaled) >>
        (safeExponentBitShifting - 1))**balanceIncentiveCurve_exponent[marketIndex];

      // NOTE: `x * 5e17` == `(x * 10e18) / 2`
      uint256 shortRewardUnscaled = (numerator * 5e17) / denominator;
      uint256 longRewardUnscaled = 1e18 - shortRewardUnscaled;

      return ((longRewardUnscaled * k * longPrice) / 1e18, (shortRewardUnscaled * k * shortPrice) / 1e18);
    }
  }

  /**
  @notice Computes the time since last accumulativeIssuancePerStakedSynthSnapshot for the given market in seconds.
  @param marketIndex The market referred to.
  @return The time difference in seconds
  */
  function _calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(uint32 marketIndex)
    internal
    view
    virtual
    returns (uint256)
  {
    return
      block.timestamp -
      accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]].timestamp;
  }

  /**
  @notice Computes new cumulative sum of 'r' value since last accumulativeIssuancePerStakedSynthSnapshot. We use
  cumulative 'r' value to avoid looping during issuance. Note that the
  cumulative sum is kept in 1e42 scale (!!!) to avoid numerical issues.
  @param shortValue The value locked in the short side of the market.
  @param longValue The value locked in the long side of the market.
  @param shortPrice The price of the short token as defined in LongShort.sol
  @param longPrice The price of the long token as defined in LongShort.sol
  @param marketIndex An identifier for the market.
  @return longCumulativeRates The long cumulative sum.
  @return shortCumulativeRates The short cumulative sum.
  */
  function _calculateNewCumulativeIssuancePerStakedSynth(
    uint32 marketIndex,
    uint256 longPrice,
    uint256 shortPrice,
    uint256 longValue,
    uint256 shortValue
  ) internal view virtual returns (uint256 longCumulativeRates, uint256 shortCumulativeRates) {
    // Compute the current 'r' value for float issuance per second.
    (uint256 longFloatPerSecond, uint256 shortFloatPerSecond) = _calculateFloatPerSecond(
      marketIndex,
      longPrice,
      shortPrice,
      longValue,
      shortValue
    );

    // Compute time since last accumulativeIssuancePerStakedSynthSnapshot for the given token.
    uint256 timeDelta = _calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(marketIndex);

    // Compute new cumulative 'r' value total.
    return (
      accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]]
      .accumulativeFloatPerSyntheticToken_long + (timeDelta * longFloatPerSecond),
      accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]]
      .accumulativeFloatPerSyntheticToken_short + (timeDelta * shortFloatPerSecond)
    );
  }

  /**
  @notice Creates a new accumulativeIssuancePerStakedSynthSnapshot for the given token and updates indexes.
  @param shortValue The value locked in the short side of the market.
  @param longValue The value locked in the long side of the market.
  @param shortPrice The price of the short token as defined in LongShort.sol
  @param longPrice The price of the long token as defined in LongShort.sol
  @param marketIndex An identifier for the market.
  */
  function _setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot(
    uint32 marketIndex,
    uint256 longPrice,
    uint256 shortPrice,
    uint256 longValue,
    uint256 shortValue
  ) internal virtual {
    (
      uint256 newLongAccumulativeValue,
      uint256 newShortAccumulativeValue
    ) = _calculateNewCumulativeIssuancePerStakedSynth(marketIndex, longPrice, shortPrice, longValue, shortValue);

    uint256 newIndex = latestRewardIndex[marketIndex] + 1;

    // Set cumulative 'r' value on new accumulativeIssuancePerStakedSynthSnapshot.
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex]
    .accumulativeFloatPerSyntheticToken_long = newLongAccumulativeValue;
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex]
    .accumulativeFloatPerSyntheticToken_short = newShortAccumulativeValue;

    // Set timestamp on new accumulativeIssuancePerStakedSynthSnapshot.
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex].timestamp = block.timestamp;

    // Update latest index to point to new accumulativeIssuancePerStakedSynthSnapshot.
    latestRewardIndex[marketIndex] = newIndex;

    emit AccumulativeIssuancePerStakedSynthSnapshotCreated(
      marketIndex,
      newIndex,
      newLongAccumulativeValue,
      newShortAccumulativeValue
    );
  }

  /**
  @notice Adds new accumulativeIssuancePerStakedSynthSnapshots for the given long/short tokens. Called by the
  ILongShort contract whenever there is a state change for a market.
  @param stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted Mapping from this contract's shifts to LongShort.sols next price snapshots.
  @param shortValue The value locked in the short side of the market.
  @param longValue The value locked in the long side of the market.
  @param shortPrice The price of the short token as defined in LongShort.sol
  @param longPrice The price of the long token as defined in LongShort.sol
  @param marketIndex An identifier for the market.
  */
  function pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(
    uint32 marketIndex,
    uint256 longPrice,
    uint256 shortPrice,
    uint256 longValue,
    uint256 shortValue,
    uint256 stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted // This value should be ALWAYS be zero if no shift occured
  ) external override onlyLongShort {
    // Only add a new accumulativeIssuancePerStakedSynthSnapshot if some time has passed.

    // the `stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted` value will be 0 if there is no staker related action in an executed batch
    if (stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted > 0) {
      stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[
        batched_stakerNextTokenShiftIndex[marketIndex]
      ] = stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted;
      stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[
        batched_stakerNextTokenShiftIndex[marketIndex]
      ] = latestRewardIndex[marketIndex] + 1;
      batched_stakerNextTokenShiftIndex[marketIndex] += 1;

      emit SyntheticTokensShifted();
    }

    // Time delta is fetched twice in below code, can pass through? Which is less gas?
    if (_calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(marketIndex) > 0) {
      _setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot(
        marketIndex,
        longPrice,
        shortPrice,
        longValue,
        shortValue
      );
    }
  }

  /*╔═══════════════════════════════════╗
    ║    USER REWARD STATE FUNCTIONS    ║
    ╚═══════════════════════════════════╝*/

  /// @dev Calculates the accumulated float in a specific range of staker snapshots
  function _calculateAccumulatedFloatInRange(
    uint32 marketIndex,
    uint256 amountStakedLong,
    uint256 amountStakedShort,
    uint256 rewardIndexFrom,
    uint256 rewardIndexTo
  ) internal view virtual returns (uint256 floatReward) {
    if (amountStakedLong > 0) {
      uint256 accumDeltaLong = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexTo]
      .accumulativeFloatPerSyntheticToken_long -
        accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexFrom]
        .accumulativeFloatPerSyntheticToken_long;
      floatReward += (accumDeltaLong * amountStakedLong) / FLOAT_ISSUANCE_FIXED_DECIMAL;
    }

    if (amountStakedShort > 0) {
      uint256 accumDeltaShort = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexTo]
      .accumulativeFloatPerSyntheticToken_short -
        accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexFrom]
        .accumulativeFloatPerSyntheticToken_short;
      floatReward += (accumDeltaShort * amountStakedShort) / FLOAT_ISSUANCE_FIXED_DECIMAL;
    }
  }

  /** 
  @notice Calculates float owed to the user since the user last minted float for a market.
  @param marketIndex Identifier for the market which the user staked in.
  @param user The address of the user.
  @return floatReward The amount of float owed.
   */
  function _calculateAccumulatedFloat(uint32 marketIndex, address user) internal virtual returns (uint256 floatReward) {
    address longToken = syntheticTokens[marketIndex][true];
    address shortToken = syntheticTokens[marketIndex][false];

    uint256 amountStakedLong = userAmountStaked[longToken][user];
    uint256 amountStakedShort = userAmountStaked[shortToken][user];

    uint256 usersLastRewardIndex = userIndexOfLastClaimedReward[marketIndex][user];

    // Don't do the calculation and return zero immediately if there is no change
    if (usersLastRewardIndex == latestRewardIndex[marketIndex]) {
      return 0;
    }

    uint256 usersShiftIndex = userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][user];
    // if there is a change in the users tokens held due to a token shift (or possibly another action in the future)
    if (usersShiftIndex > 0 && usersShiftIndex < batched_stakerNextTokenShiftIndex[marketIndex]) {
      floatReward = _calculateAccumulatedFloatInRange(
        marketIndex,
        amountStakedLong,
        amountStakedShort,
        usersLastRewardIndex,
        stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[usersShiftIndex]
      );

      // Update the users balances
      if (userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user] > 0) {
        amountStakedShort += ILongShort(longShort).getAmountSyntheticTokenToMintOnTargetSide(
          marketIndex,
          userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user],
          true,
          stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[usersShiftIndex]
        );

        amountStakedLong -= userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user];
        userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user] = 0;
      }

      if (userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user] > 0) {
        amountStakedLong += ILongShort(longShort).getAmountSyntheticTokenToMintOnTargetSide(
          marketIndex,
          userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user],
          false,
          stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[usersShiftIndex]
        );

        amountStakedShort -= userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user];
        userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user] = 0;
      }

      // Save the users updated staked amounts
      userAmountStaked[longToken][user] = amountStakedLong;
      userAmountStaked[shortToken][user] = amountStakedShort;

      floatReward += _calculateAccumulatedFloatInRange(
        marketIndex,
        amountStakedLong,
        amountStakedShort,
        stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[usersShiftIndex],
        latestRewardIndex[marketIndex]
      );

      userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][user] = 0;
    } else {
      floatReward = _calculateAccumulatedFloatInRange(
        marketIndex,
        amountStakedLong,
        amountStakedShort,
        usersLastRewardIndex,
        latestRewardIndex[marketIndex]
      );
    }
  }

  /**
  @notice Mints float for a user.
  @dev Mints a fixed percentage for Float capital.
  @param user The address of the user.
  @param floatToMint The amount of float to mint.
   */
  function _mintFloat(address user, uint256 floatToMint) internal virtual {
    IFloatToken(floatToken).mint(user, floatToMint);
    IFloatToken(floatToken).mint(floatCapital, (floatToMint * floatPercentage) / 1e18);
  }

  /**
  @notice Mints float owed to a user for a market since they last minted.
  @param marketIndex An identifier for the market.
  @param user The address of the user.
   */
  function _mintAccumulatedFloat(uint32 marketIndex, address user) internal virtual {
    uint256 floatToMint = _calculateAccumulatedFloat(marketIndex, user);

    if (floatToMint > 0) {
      // Set the user has claimed up until now, stops them setting this forward
      userIndexOfLastClaimedReward[marketIndex][user] = latestRewardIndex[marketIndex];

      _mintFloat(user, floatToMint);
      emit FloatMinted(user, marketIndex, floatToMint);
    }
  }

  /**
  @notice Mints float owed to a user for multiple markets, since they last minted for those markets.
  @param marketIndexes Identifiers for the markets.
  @param user The address of the user.
   */
  function _mintAccumulatedFloatMulti(uint32[] calldata marketIndexes, address user) internal virtual {
    uint256 floatTotal = 0;
    for (uint256 i = 0; i < marketIndexes.length; i++) {
      uint256 floatToMint = _calculateAccumulatedFloat(marketIndexes[i], user);

      if (floatToMint > 0) {
        // Set the user has claimed up until now, stops them setting this forward
        userIndexOfLastClaimedReward[marketIndexes[i]][user] = latestRewardIndex[marketIndexes[i]];

        floatTotal += floatToMint;

        emit FloatMinted(user, marketIndexes[i], floatToMint);
      }
    }
    if (floatTotal > 0) {
      _mintFloat(user, floatTotal);
    }
  }

  /**
  @notice Mints outstanding float for msg.sender.
  @param marketIndexes Identifiers for the markets for which to mint float.
   */
  function claimFloatCustom(uint32[] calldata marketIndexes) external {
    ILongShort(longShort).updateSystemStateMulti(marketIndexes);
    _mintAccumulatedFloatMulti(marketIndexes, msg.sender);
  }

  /**
  @notice Mints outstanding float on behalf of another user.
  @param marketIndexes Identifiers for the markets for which to mint float.
  @param user The address of the user.
   */
  function claimFloatCustomFor(uint32[] calldata marketIndexes, address user) external {
    // Unbounded loop - users are responsible for paying their own gas costs on these and it doesn't effect the rest of the system.
    // No need to impose limit.
    ILongShort(longShort).updateSystemStateMulti(marketIndexes);
    _mintAccumulatedFloatMulti(marketIndexes, user);
  }

  /*╔═══════════════════════╗
    ║        STAKING        ║
    ╚═══════════════════════╝*/

  /**
  @notice A user with synthetic tokens stakes by calling stake on the token
  contract which calls this function. We need to first update the
  state of the LongShort contract for this market before staking to correctly calculate user rewards.
  @param amount Amount to stake.
  @param from Address to stake for.
  */
  function stakeFromUser(address from, uint256 amount) public virtual override onlyValidSynthetic((msg.sender)) {
    ILongShort(longShort).updateSystemState(marketIndexOfToken[(msg.sender)]);
    _stake((msg.sender), amount, from);
  }

  /**
  @dev Internal logic for staking.
  @param token Address of the token for which to stake.
  @param amount Amount to stake.
  @param user Address to stake for.
  */
  function _stake(
    address token,
    uint256 amount,
    address user
  ) internal virtual {
    uint32 marketIndex = marketIndexOfToken[token];

    // If they already have staked and have rewards due, mint these.
    if (
      userIndexOfLastClaimedReward[marketIndex][user] != 0 &&
      userIndexOfLastClaimedReward[marketIndex][user] < latestRewardIndex[marketIndex]
    ) {
      _mintAccumulatedFloat(marketIndex, user);
    }

    userAmountStaked[token][user] = userAmountStaked[token][user] + amount;

    userIndexOfLastClaimedReward[marketIndex][user] = latestRewardIndex[marketIndex];

    emit StakeAdded(user, address(token), amount, userIndexOfLastClaimedReward[marketIndex][user]);
  }

  /**
  @notice Allows users to shift their staked tokens from one side of the market to 
  the other at the next price.
  @param amountSyntheticTokensToShift Amount of tokens to shift.
  @param marketIndex Identifier for the market.
  @param isShiftFromLong Whether the shift is from long to short or short to long.
  */
  function shiftTokens(
    uint256 amountSyntheticTokensToShift,
    uint32 marketIndex,
    bool isShiftFromLong
  ) external virtual {
    address token = syntheticTokens[marketIndex][isShiftFromLong];
    require(userAmountStaked[token][msg.sender] >= amountSyntheticTokensToShift, "Not enough tokens to shift");

    // If the user has outstanding token shift that have already been confirmed in the LongShort
    // contract, execute them first.
    if (
      userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] != 0 &&
      userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] <
      batched_stakerNextTokenShiftIndex[marketIndex]
    ) {
      _mintAccumulatedFloat(marketIndex, msg.sender);
    }

    if (isShiftFromLong) {
      ILongShort(longShort).shiftPositionFromLongNextPrice(marketIndex, amountSyntheticTokensToShift);
      userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][
        msg.sender
      ] += amountSyntheticTokensToShift;
    } else {
      ILongShort(longShort).shiftPositionFromShortNextPrice(marketIndex, amountSyntheticTokensToShift);
      userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][
        msg.sender
      ] += amountSyntheticTokensToShift;
    }

    userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] = batched_stakerNextTokenShiftIndex[
      marketIndex
    ];
  }

  /*╔════════════════════════════╗
    ║    WITHDRAWAL & MINTING    ║
    ╚════════════════════════════╝*/

  /**
  @notice Internal logic for withdrawing stakes.
  @dev Mint user any outstanding float before withdrawing.
  @param marketIndex Market index of token.
  @param amount Amount to withdraw.
  @param token Synthetic token that was staked.
  */
  function _withdraw(
    uint32 marketIndex,
    address token,
    uint256 amount
  ) internal virtual {
    require(userAmountStaked[token][msg.sender] > 0, "nothing to withdraw");
    _mintAccumulatedFloat(marketIndex, msg.sender);

    userAmountStaked[token][msg.sender] = userAmountStaked[token][msg.sender] - amount;

    uint256 amountFees = (amount * marketUnstakeFee_e18[marketIndex]) / 1e18;

    IERC20(token).transfer(floatTreasury, amountFees);
    IERC20(token).transfer(msg.sender, amount - amountFees);

    emit StakeWithdrawn(msg.sender, token, amount);
  }

  /**
  @notice Withdraw function. Allows users to unstake.
  @param amount Amount to withdraw.
  @param token Address of the token for which to withdraw.
  */
  function withdraw(address token, uint256 amount) external {
    ILongShort(longShort).updateSystemState(marketIndexOfToken[token]);

    uint32 marketIndex = marketIndexOfToken[token];

    _withdraw(marketIndex, token, amount);

    if (userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] > 0) {
      // If they still have outstanding shifts after minting float, then check
      // that they don't withdraw more than their shifts allow.
      uint256 amountToShiftForThisToken = syntheticTokens[marketIndex][true] == token
        ? userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][msg.sender]
        : userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][msg.sender];

      require(
        userAmountStaked[token][msg.sender] >= amountToShiftForThisToken,
        "Outstanding next price stake shifts too great"
      );
    }
  }

  /**
  @notice Allows users to withdraw their entire stake for a token.
  @param token Address of the token for which to withdraw.
  */
  function withdrawAll(address token) external {
    ILongShort(longShort).updateSystemState(marketIndexOfToken[token]);

    uint32 marketIndex = marketIndexOfToken[token];

    uint256 amountToShiftForThisToken = syntheticTokens[marketIndex][true] == token
      ? userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][msg.sender]
      : userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][msg.sender];

    _withdraw(marketIndex, token, userAmountStaked[token][msg.sender] - amountToShiftForThisToken);
  }
}
".
Ideas: " Security".
As the Security Analyst, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability.
For each vulnerability identified, use the following format:
VULNERABILITY NAME or TYPE
```
DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix.
```
Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: "<INFO> Analysis Complete."

[2024-17-08 08:01:27 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-17-08 08:01:27 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 19617
completion_tokens: 1
total_tokens: 19618
cost: $-1.000000


[2024-17-08 08:01:27 INFO] Security Analyst: **Security Analyst<->Solidity Programming Expert on : ContractReviewComment, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: BUSL-1.1

pragma solidity 0.8.3;

import "@openzeppelin/contracts-upgradeable/token/ERC20/presets/ERC20PresetMinterPauserUpgradeable.sol";

import "./interfaces/IFloatToken.sol";
import "./interfaces/ILongShort.sol";
import "./interfaces/IStaker.sol";
import "./interfaces/ISyntheticToken.sol";

contract Staker is IStaker, Initializable {
  /*╔═════════════════════════════╗
    ║          VARIABLES          ║
    ╚═════════════════════════════╝*/

  /* ══════ Fixed-precision constants ══════ */
  uint256 public constant FLOAT_ISSUANCE_FIXED_DECIMAL = 1e42;
  // 2^52 ~= 4.5e15
  // With an exponent of 5, the largest total liquidity possible in a market (to avoid integer overflow on exponentiation) is ~10^31 or 10 Trillion (10^13)
  // NOTE: this also means if the total market value is less than 2^52 there will be a division by zero error
  uint256 public constant safeExponentBitShifting = 52;

  /* ══════ Global state ══════ */
  address public admin;
  address public floatCapital;
  address public floatTreasury;
  uint256 public floatPercentage;

  address public longShort;
  address public floatToken;

  /* ══════ Market specific ══════ */
  mapping(uint32 => uint256) public marketLaunchIncentive_period; // seconds
  mapping(uint32 => uint256) public marketLaunchIncentive_multipliers; // e18 scale
  mapping(uint32 => uint256) public marketUnstakeFee_e18;
  mapping(uint32 => uint256) public balanceIncentiveCurve_exponent;
  mapping(uint32 => int256) public balanceIncentiveCurve_equilibriumOffset;

  mapping(uint32 => mapping(bool => address)) public syntheticTokens;

  mapping(address => uint32) public marketIndexOfToken;

  /* ══════ Reward specific ══════ */
  mapping(uint32 => uint256) public latestRewardIndex;
  mapping(uint32 => mapping(uint256 => AccumulativeIssuancePerStakedSynthSnapshot))
    public accumulativeFloatPerSyntheticTokenSnapshots;
  struct AccumulativeIssuancePerStakedSynthSnapshot {
    uint256 timestamp;
    uint256 accumulativeFloatPerSyntheticToken_long;
    uint256 accumulativeFloatPerSyntheticToken_short;
  }

  /* ══════ User specific ══════ */
  mapping(uint32 => mapping(address => uint256)) public userIndexOfLastClaimedReward;
  mapping(address => mapping(address => uint256)) public userAmountStaked;

  /* ══════ Token shift management specific ══════ */
  mapping(uint32 => uint256) public batched_stakerNextTokenShiftIndex;
  /**
  @notice Used to link a token shift to a staker state
  @dev tokenShiftIndex => accumulativeFloatIssuanceSnapshotIndex
    POSSIBLE OPTIMIZATION - could pack stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping and stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping into a struct of two uint128 for storage space optimization.
  */
  mapping(uint256 => uint256) public stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping;
  /// @notice Used to fetch the price from LongShort at that point in time
  /// @dev tokenShiftIndex => longShortMarketPriceSnapshotIndex
  mapping(uint256 => uint256) public stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping;
  /// @dev marketIndex => usersAddress => stakerTokenShiftIndex
  mapping(uint32 => mapping(address => uint256)) public userNextPrice_stakedSyntheticTokenShiftIndex;
  /// @dev marketIndex => usersAddress => amountUserRequestedToShiftAwayFromLongOnNextUpdate
  mapping(uint32 => mapping(address => uint256)) public userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long;
  /// @dev marketIndex => usersAddress => amountUserRequestedToShiftAwayFromShortOnNextUpdate
  mapping(uint32 => mapping(address => uint256)) public userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short;

  /*╔════════════════════════════╗
    ║           EVENTS           ║
    ╚════════════════════════════╝*/

  event StakerV1(
    address admin,
    address floatTreasury,
    address floatCapital,
    address floatToken,
    uint256 floatPercentage
  );

  event MarketAddedToStaker(
    uint32 marketIndex,
    uint256 exitFee_e18,
    uint256 period,
    uint256 multiplier,
    uint256 balanceIncentiveExponent,
    int256 balanceIncentiveEquilibriumOffset
  );

  event AccumulativeIssuancePerStakedSynthSnapshotCreated(
    uint32 marketIndex,
    uint256 accumulativeFloatIssuanceSnapshotIndex,
    uint256 accumulativeLong,
    uint256 accumulativeShort
  );

  event StakeAdded(address user, address token, uint256 amount, uint256 lastMintIndex);

  event StakeWithdrawn(address user, address token, uint256 amount);

  // Note: the `amountFloatMinted` isn't strictly needed by the graph, but it is good to add it to validate calculations are accurate.
  event FloatMinted(address user, uint32 marketIndex, uint256 amountFloatMinted);

  event MarketLaunchIncentiveParametersChanges(uint32 marketIndex, uint256 period, uint256 multiplier);

  event StakeWithdrawalFeeUpdated(uint32 marketIndex, uint256 stakeWithdralFee);

  event BalanceIncentiveExponentUpdated(uint32 marketIndex, uint256 balanceIncentiveExponent);

  event BalanceIncentiveEquilibriumOffsetUpdated(uint32 marketIndex, int256 balanceIncentiveEquilibriumOffset);

  event FloatPercentageUpdated(uint256 floatPercentage);

  event SyntheticTokensShifted();

  event ChangeAdmin(address newAdmin);

  /*╔═════════════════════════════╗
    ║          MODIFIERS          ║
    ╚═════════════════════════════╝*/

  function onlyAdminModifierLogic() internal virtual {
    require(msg.sender == admin, "not admin");
  }

  modifier onlyAdmin() {
    onlyAdminModifierLogic();
    _;
  }

  function onlyValidSyntheticModifierLogic(address _synth) internal virtual {
    require(marketIndexOfToken[_synth] != 0, "not valid synth");
  }

  modifier onlyValidSynthetic(address _synth) {
    onlyValidSyntheticModifierLogic(_synth);
    _;
  }

  function onlyValidMarketModifierLogic(uint32 marketIndex) internal virtual {
    require(address(syntheticTokens[marketIndex][true]) != address(0), "not valid market");
  }

  modifier onlyValidMarket(uint32 marketIndex) {
    onlyValidMarketModifierLogic(marketIndex);
    _;
  }

  function onlyLongShortModifierLogic() internal virtual {
    require(msg.sender == address(longShort), "not long short");
  }

  modifier onlyLongShort() {
    onlyLongShortModifierLogic();
    _;
  }

  /*╔═════════════════════════════╗
    ║       CONTRACT SET-UP       ║
    ╚═════════════════════════════╝*/

  /**
  @notice Initializes the contract.
  @dev Calls OpenZeppelin's initializer modifier.
  @param _admin Address of the admin role.
  @param _longShort Address of the LongShort contract, a deployed LongShort.sol
  @param _floatToken Address of the Float token earned by staking.
  @param _floatTreasury Address of the treasury contract for managing fees.
  @param _floatCapital Address of the contract which earns a fixed percentage of Float.
  @param _floatPercentage Determines the float percentage that gets minted for Float Capital, base 1e18.
  */
  function initialize(
    address _admin,
    address _longShort,
    address _floatToken,
    address _floatTreasury,
    address _floatCapital,
    uint256 _floatPercentage
  ) external virtual initializer {
    admin = _admin;
    floatCapital = _floatCapital;
    floatTreasury = _floatTreasury;
    longShort = _longShort;
    floatToken = _floatToken;

    _changeFloatPercentage(_floatPercentage);

    emit StakerV1(_admin, _floatTreasury, _floatCapital, _floatToken, _floatPercentage);
  }

  /*╔═══════════════════╗
    ║       ADMIN       ║
    ╚═══════════════════╝*/

  /** 
  @notice Changes admin for the contract
  @param _admin The address of the new admin.
  */
  function changeAdmin(address _admin) external onlyAdmin {
    admin = _admin;
    emit ChangeAdmin(_admin);
  }

  /// @dev Logic for changeFloatPercentage
  function _changeFloatPercentage(uint256 newFloatPercentage) internal virtual {
    require(newFloatPercentage <= 1e18 && newFloatPercentage > 0); // less than or equal to 100% and greater than 0%
    floatPercentage = newFloatPercentage;
  }

  /**
  @notice Changes percentage of float that is minted for float capital.
  @param newFloatPercentage The new float percentage in base 1e18.
  */
  function changeFloatPercentage(uint256 newFloatPercentage) external onlyAdmin {
    _changeFloatPercentage(newFloatPercentage);
    emit FloatPercentageUpdated(newFloatPercentage);
  }

  /// @dev Logic for changeUnstakeFee
  function _changeUnstakeFee(uint32 marketIndex, uint256 newMarketUnstakeFee_e18) internal virtual {
    require(newMarketUnstakeFee_e18 <= 5e16); // Explicitely stating 5% fee as the max fee possible.
    marketUnstakeFee_e18[marketIndex] = newMarketUnstakeFee_e18;
  }

  /**
  @notice Changes unstake fee for a market
  @param marketIndex Identifies the market.
  @param newMarketUnstakeFee_e18 The new unstake fee.
  */
  function changeUnstakeFee(uint32 marketIndex, uint256 newMarketUnstakeFee_e18) external onlyAdmin {
    _changeUnstakeFee(marketIndex, newMarketUnstakeFee_e18);
    emit StakeWithdrawalFeeUpdated(marketIndex, newMarketUnstakeFee_e18);
  }

  /// @dev Logic for changeMarketLaunchIncentiveParameters
  function _changeMarketLaunchIncentiveParameters(
    uint32 marketIndex,
    uint256 period,
    uint256 initialMultiplier
  ) internal virtual {
    require(initialMultiplier >= 1e18, "marketLaunchIncentiveMultiplier must be >= 1e18");

    marketLaunchIncentive_period[marketIndex] = period;
    marketLaunchIncentive_multipliers[marketIndex] = initialMultiplier;
  }

  /**
  @notice Changes the market launch incentive parameters for a market
  @param marketIndex Identifies the market.
  @param period The new period for which float token generation should be boosted.
  @param initialMultiplier The new multiplier on Float generation.
  */
  function changeMarketLaunchIncentiveParameters(
    uint32 marketIndex,
    uint256 period,
    uint256 initialMultiplier
  ) external onlyAdmin {
    _changeMarketLaunchIncentiveParameters(marketIndex, period, initialMultiplier);

    emit MarketLaunchIncentiveParametersChanges(marketIndex, period, initialMultiplier);
  }

  /// @dev Logic for changeBalanceIncentiveExponent
  function _changeBalanceIncentiveExponent(uint32 marketIndex, uint256 _balanceIncentiveCurve_exponent)
    internal
    virtual
  {
    require(
      // The exponent has to be less than 5 in these versions of the contracts.
      _balanceIncentiveCurve_exponent > 0 && _balanceIncentiveCurve_exponent < 6,
      "balanceIncentiveCurve_exponent out of bounds"
    );

    balanceIncentiveCurve_exponent[marketIndex] = _balanceIncentiveCurve_exponent;
  }

  /** 
  @notice Changes the balance incentive exponent for a market
  @param marketIndex Identifies the market.
  @param _balanceIncentiveCurve_exponent The new exponent for the curve.
  */
  function changeBalanceIncentiveExponent(uint32 marketIndex, uint256 _balanceIncentiveCurve_exponent)
    external
    onlyAdmin
  {
    _changeBalanceIncentiveExponent(marketIndex, _balanceIncentiveCurve_exponent);

    emit BalanceIncentiveExponentUpdated(marketIndex, _balanceIncentiveCurve_exponent);
  }

  /// @dev Logic for changeBalanceIncentiveEquilibriumOffset
  function _changeBalanceIncentiveEquilibriumOffset(uint32 marketIndex, int256 _balanceIncentiveCurve_equilibriumOffset)
    internal
    virtual
  {
    // Unreasonable that we would ever shift this more than 90% either way
    require(
      _balanceIncentiveCurve_equilibriumOffset > -9e17 && _balanceIncentiveCurve_equilibriumOffset < 9e17,
      "balanceIncentiveCurve_equilibriumOffset out of bounds"
    );

    balanceIncentiveCurve_equilibriumOffset[marketIndex] = _balanceIncentiveCurve_equilibriumOffset;
  }

  /**
  @notice Changes the balance incentive curve equilibrium offset for a market
  @param marketIndex Identifies the market.
  @param _balanceIncentiveCurve_equilibriumOffset The new offset.
  */
  function changeBalanceIncentiveEquilibriumOffset(uint32 marketIndex, int256 _balanceIncentiveCurve_equilibriumOffset)
    external
    onlyAdmin
  {
    _changeBalanceIncentiveEquilibriumOffset(marketIndex, _balanceIncentiveCurve_equilibriumOffset);

    emit BalanceIncentiveEquilibriumOffsetUpdated(marketIndex, _balanceIncentiveCurve_equilibriumOffset);
  }

  /*╔═════════════════════════════╗
    ║        STAKING SETUP        ║
    ╚═════════════════════════════╝*/

  /**
  @notice Sets this contract to track staking for a market in LongShort.sol
  @param marketIndex Identifies the market.
  @param longToken Address of the long token for the market.
  @param shortToken Address of the short token for the market.
  @param kInitialMultiplier Initial boost on float generation for the market.
  @param kPeriod Period which the boost should last.
  @param unstakeFee_e18 Percentage of tokens that are levied on unstaking in base 1e18.
  @param _balanceIncentiveCurve_exponent Exponent for balance curve (see _calculateFloatPerSecond)
  @param _balanceIncentiveCurve_equilibriumOffset Offset for balance curve (see _calculateFloatPerSecond)
  */
  function addNewStakingFund(
    uint32 marketIndex,
    address longToken,
    address shortToken,
    uint256 kInitialMultiplier,
    uint256 kPeriod,
    uint256 unstakeFee_e18,
    uint256 _balanceIncentiveCurve_exponent,
    int256 _balanceIncentiveCurve_equilibriumOffset
  ) external override onlyLongShort {
    marketIndexOfToken[longToken] = marketIndex;
    marketIndexOfToken[shortToken] = marketIndex;

    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].timestamp = block.timestamp;
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].accumulativeFloatPerSyntheticToken_long = 0;
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].accumulativeFloatPerSyntheticToken_short = 0;

    syntheticTokens[marketIndex][true] = longToken;
    syntheticTokens[marketIndex][false] = shortToken;

    _changeBalanceIncentiveExponent(marketIndex, _balanceIncentiveCurve_exponent);
    _changeBalanceIncentiveEquilibriumOffset(marketIndex, _balanceIncentiveCurve_equilibriumOffset);
    _changeMarketLaunchIncentiveParameters(marketIndex, kPeriod, kInitialMultiplier);

    _changeUnstakeFee(marketIndex, unstakeFee_e18);

    // Set this value to one initially - 0 is a null value and thus potentially bug prone.
    batched_stakerNextTokenShiftIndex[marketIndex] = 1;

    emit MarketAddedToStaker(
      marketIndex,
      unstakeFee_e18,
      kPeriod,
      kInitialMultiplier,
      _balanceIncentiveCurve_exponent,
      _balanceIncentiveCurve_equilibriumOffset
    );

    emit AccumulativeIssuancePerStakedSynthSnapshotCreated(marketIndex, 0, 0, 0);
  }

  /*╔═════════════════════════════════════════════════════════════════════════╗
    ║    GLOBAL FLT REWARD ACCUMULATION CALCULATION AND TRACKING FUNCTIONS    ║
    ╚═════════════════════════════════════════════════════════════════════════╝*/

  /**
  @notice Returns the K factor parameters for the given market with sensible
  defaults if they haven't been set yet.
  @param marketIndex The market to change the parameters for.
  @return period The period for which the k factor applies for in seconds.
  @return multiplier The multiplier on Float generation in this period.
  */
  function _getMarketLaunchIncentiveParameters(uint32 marketIndex)
    internal
    view
    virtual
    returns (uint256 period, uint256 multiplier)
  {
    period = marketLaunchIncentive_period[marketIndex];
    multiplier = marketLaunchIncentive_multipliers[marketIndex];

    if (multiplier < 1e18) {
      multiplier = 1e18; // multiplier of 1 by default
    }
  }

  /** 
  @notice Returns the extent to which a markets float generation should be adjusted
  based on the market's launch incentive parameters. Should start at multiplier
  then linearly change to 1e18 over time.
  @param marketIndex Identifies the market.
  @return k The calculated modifier for float generation.
  */
  function _getKValue(uint32 marketIndex) internal view virtual returns (uint256) {
    // Parameters controlling the float issuance multiplier.
    (uint256 kPeriod, uint256 kInitialMultiplier) = _getMarketLaunchIncentiveParameters(marketIndex);

    // Sanity check - under normal circumstances, the multipliers should
    // *never* be set to a value < 1e18, as there are guards against this.
    assert(kInitialMultiplier >= 1e18);

    uint256 initialTimestamp = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].timestamp;

    if (block.timestamp - initialTimestamp <= kPeriod) {
      return kInitialMultiplier - (((kInitialMultiplier - 1e18) * (block.timestamp - initialTimestamp)) / kPeriod);
    } else {
      return 1e18;
    }
  }

  /*
  @notice Computes the number of float tokens a user earns per second for
  every long/short synthetic token they've staked. The returned value has
  a fixed decimal scale of 1e42 (!!!) for numerical stability. The return
  values are float per second per synthetic token (hence the requirement
  to multiply by price)
  @dev to see below math in latex form see TODO add link
  to interact with the equations see https://www.desmos.com/calculator/optkaxyihr
  @param marketIndex The market referred to.
  @param longPrice Price of the synthetic long token in units of payment token
  @param shortPrice Price of the synthetic short token in units of payment token
  @param longValue Amount of payment token in the long side of the market
  @param shortValue Amount of payment token in the short side of the market
  @return longFloatPerSecond Float token per second per long synthetic token
  @return shortFloatPerSecond Float token per second per short synthetic token
   */
  function _calculateFloatPerSecond(
    uint32 marketIndex,
    uint256 longPrice,
    uint256 shortPrice,
    uint256 longValue,
    uint256 shortValue
  ) internal view virtual returns (uint256 longFloatPerSecond, uint256 shortFloatPerSecond) {
    // A float issuance multiplier that starts high and decreases linearly
    // over time to a value of 1. This incentivises users to stake early.
    uint256 k = _getKValue(marketIndex);

    uint256 totalLocked = (longValue + shortValue);

    // we need to scale this number by the totalLocked so that the offset remains consistent accross market size

    int256 equilibriumOffsetMarketScaled = (balanceIncentiveCurve_equilibriumOffset[marketIndex] *
      int256(totalLocked)) / 2e18;

    uint256 denominator = ((totalLocked >> safeExponentBitShifting)**balanceIncentiveCurve_exponent[marketIndex]);

    // Float is scaled by the percentage of the total market value held in
    // the opposite position. This incentivises users to stake on the
    // weaker position.
    if (int256(shortValue) - equilibriumOffsetMarketScaled < int256(longValue)) {
      if (equilibriumOffsetMarketScaled >= int256(shortValue)) {
        // edge case: imbalanced far past the equilibrium offset - full rewards go to short token
        //            extremeley unlikely to happen in practice
        return (0, 1e18 * k * shortPrice);
      }

      uint256 numerator = (uint256(int256(shortValue) - equilibriumOffsetMarketScaled) >>
        (safeExponentBitShifting - 1))**balanceIncentiveCurve_exponent[marketIndex];

      // NOTE: `x * 5e17` == `(x * 10e18) / 2`
      uint256 longRewardUnscaled = (numerator * 5e17) / denominator;
      uint256 shortRewardUnscaled = 1e18 - longRewardUnscaled;

      return ((longRewardUnscaled * k * longPrice) / 1e18, (shortRewardUnscaled * k * shortPrice) / 1e18);
    } else {
      if (-equilibriumOffsetMarketScaled >= int256(longValue)) {
        // edge case: imbalanced far past the equilibrium offset - full rewards go to long token
        //            extremeley unlikely to happen in practice
        return (1e18 * k * longPrice, 0);
      }

      uint256 numerator = (uint256(int256(longValue) + equilibriumOffsetMarketScaled) >>
        (safeExponentBitShifting - 1))**balanceIncentiveCurve_exponent[marketIndex];

      // NOTE: `x * 5e17` == `(x * 10e18) / 2`
      uint256 shortRewardUnscaled = (numerator * 5e17) / denominator;
      uint256 longRewardUnscaled = 1e18 - shortRewardUnscaled;

      return ((longRewardUnscaled * k * longPrice) / 1e18, (shortRewardUnscaled * k * shortPrice) / 1e18);
    }
  }

  /**
  @notice Computes the time since last accumulativeIssuancePerStakedSynthSnapshot for the given market in seconds.
  @param marketIndex The market referred to.
  @return The time difference in seconds
  */
  function _calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(uint32 marketIndex)
    internal
    view
    virtual
    returns (uint256)
  {
    return
      block.timestamp -
      accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]].timestamp;
  }

  /**
  @notice Computes new cumulative sum of 'r' value since last accumulativeIssuancePerStakedSynthSnapshot. We use
  cumulative 'r' value to avoid looping during issuance. Note that the
  cumulative sum is kept in 1e42 scale (!!!) to avoid numerical issues.
  @param shortValue The value locked in the short side of the market.
  @param longValue The value locked in the long side of the market.
  @param shortPrice The price of the short token as defined in LongShort.sol
  @param longPrice The price of the long token as defined in LongShort.sol
  @param marketIndex An identifier for the market.
  @return longCumulativeRates The long cumulative sum.
  @return shortCumulativeRates The short cumulative sum.
  */
  function _calculateNewCumulativeIssuancePerStakedSynth(
    uint32 marketIndex,
    uint256 longPrice,
    uint256 shortPrice,
    uint256 longValue,
    uint256 shortValue
  ) internal view virtual returns (uint256 longCumulativeRates, uint256 shortCumulativeRates) {
    // Compute the current 'r' value for float issuance per second.
    (uint256 longFloatPerSecond, uint256 shortFloatPerSecond) = _calculateFloatPerSecond(
      marketIndex,
      longPrice,
      shortPrice,
      longValue,
      shortValue
    );

    // Compute time since last accumulativeIssuancePerStakedSynthSnapshot for the given token.
    uint256 timeDelta = _calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(marketIndex);

    // Compute new cumulative 'r' value total.
    return (
      accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]]
      .accumulativeFloatPerSyntheticToken_long + (timeDelta * longFloatPerSecond),
      accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]]
      .accumulativeFloatPerSyntheticToken_short + (timeDelta * shortFloatPerSecond)
    );
  }

  /**
  @notice Creates a new accumulativeIssuancePerStakedSynthSnapshot for the given token and updates indexes.
  @param shortValue The value locked in the short side of the market.
  @param longValue The value locked in the long side of the market.
  @param shortPrice The price of the short token as defined in LongShort.sol
  @param longPrice The price of the long token as defined in LongShort.sol
  @param marketIndex An identifier for the market.
  */
  function _setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot(
    uint32 marketIndex,
    uint256 longPrice,
    uint256 shortPrice,
    uint256 longValue,
    uint256 shortValue
  ) internal virtual {
    (
      uint256 newLongAccumulativeValue,
      uint256 newShortAccumulativeValue
    ) = _calculateNewCumulativeIssuancePerStakedSynth(marketIndex, longPrice, shortPrice, longValue, shortValue);

    uint256 newIndex = latestRewardIndex[marketIndex] + 1;

    // Set cumulative 'r' value on new accumulativeIssuancePerStakedSynthSnapshot.
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex]
    .accumulativeFloatPerSyntheticToken_long = newLongAccumulativeValue;
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex]
    .accumulativeFloatPerSyntheticToken_short = newShortAccumulativeValue;

    // Set timestamp on new accumulativeIssuancePerStakedSynthSnapshot.
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex].timestamp = block.timestamp;

    // Update latest index to point to new accumulativeIssuancePerStakedSynthSnapshot.
    latestRewardIndex[marketIndex] = newIndex;

    emit AccumulativeIssuancePerStakedSynthSnapshotCreated(
      marketIndex,
      newIndex,
      newLongAccumulativeValue,
      newShortAccumulativeValue
    );
  }

  /**
  @notice Adds new accumulativeIssuancePerStakedSynthSnapshots for the given long/short tokens. Called by the
  ILongShort contract whenever there is a state change for a market.
  @param stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted Mapping from this contract's shifts to LongShort.sols next price snapshots.
  @param shortValue The value locked in the short side of the market.
  @param longValue The value locked in the long side of the market.
  @param shortPrice The price of the short token as defined in LongShort.sol
  @param longPrice The price of the long token as defined in LongShort.sol
  @param marketIndex An identifier for the market.
  */
  function pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(
    uint32 marketIndex,
    uint256 longPrice,
    uint256 shortPrice,
    uint256 longValue,
    uint256 shortValue,
    uint256 stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted // This value should be ALWAYS be zero if no shift occured
  ) external override onlyLongShort {
    // Only add a new accumulativeIssuancePerStakedSynthSnapshot if some time has passed.

    // the `stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted` value will be 0 if there is no staker related action in an executed batch
    if (stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted > 0) {
      stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[
        batched_stakerNextTokenShiftIndex[marketIndex]
      ] = stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted;
      stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[
        batched_stakerNextTokenShiftIndex[marketIndex]
      ] = latestRewardIndex[marketIndex] + 1;
      batched_stakerNextTokenShiftIndex[marketIndex] += 1;

      emit SyntheticTokensShifted();
    }

    // Time delta is fetched twice in below code, can pass through? Which is less gas?
    if (_calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(marketIndex) > 0) {
      _setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot(
        marketIndex,
        longPrice,
        shortPrice,
        longValue,
        shortValue
      );
    }
  }

  /*╔═══════════════════════════════════╗
    ║    USER REWARD STATE FUNCTIONS    ║
    ╚═══════════════════════════════════╝*/

  /// @dev Calculates the accumulated float in a specific range of staker snapshots
  function _calculateAccumulatedFloatInRange(
    uint32 marketIndex,
    uint256 amountStakedLong,
    uint256 amountStakedShort,
    uint256 rewardIndexFrom,
    uint256 rewardIndexTo
  ) internal view virtual returns (uint256 floatReward) {
    if (amountStakedLong > 0) {
      uint256 accumDeltaLong = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexTo]
      .accumulativeFloatPerSyntheticToken_long -
        accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexFrom]
        .accumulativeFloatPerSyntheticToken_long;
      floatReward += (accumDeltaLong * amountStakedLong) / FLOAT_ISSUANCE_FIXED_DECIMAL;
    }

    if (amountStakedShort > 0) {
      uint256 accumDeltaShort = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexTo]
      .accumulativeFloatPerSyntheticToken_short -
        accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexFrom]
        .accumulativeFloatPerSyntheticToken_short;
      floatReward += (accumDeltaShort * amountStakedShort) / FLOAT_ISSUANCE_FIXED_DECIMAL;
    }
  }

  /** 
  @notice Calculates float owed to the user since the user last minted float for a market.
  @param marketIndex Identifier for the market which the user staked in.
  @param user The address of the user.
  @return floatReward The amount of float owed.
   */
  function _calculateAccumulatedFloat(uint32 marketIndex, address user) internal virtual returns (uint256 floatReward) {
    address longToken = syntheticTokens[marketIndex][true];
    address shortToken = syntheticTokens[marketIndex][false];

    uint256 amountStakedLong = userAmountStaked[longToken][user];
    uint256 amountStakedShort = userAmountStaked[shortToken][user];

    uint256 usersLastRewardIndex = userIndexOfLastClaimedReward[marketIndex][user];

    // Don't do the calculation and return zero immediately if there is no change
    if (usersLastRewardIndex == latestRewardIndex[marketIndex]) {
      return 0;
    }

    uint256 usersShiftIndex = userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][user];
    // if there is a change in the users tokens held due to a token shift (or possibly another action in the future)
    if (usersShiftIndex > 0 && usersShiftIndex < batched_stakerNextTokenShiftIndex[marketIndex]) {
      floatReward = _calculateAccumulatedFloatInRange(
        marketIndex,
        amountStakedLong,
        amountStakedShort,
        usersLastRewardIndex,
        stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[usersShiftIndex]
      );

      // Update the users balances
      if (userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user] > 0) {
        amountStakedShort += ILongShort(longShort).getAmountSyntheticTokenToMintOnTargetSide(
          marketIndex,
          userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user],
          true,
          stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[usersShiftIndex]
        );

        amountStakedLong -= userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user];
        userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user] = 0;
      }

      if (userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user] > 0) {
        amountStakedLong += ILongShort(longShort).getAmountSyntheticTokenToMintOnTargetSide(
          marketIndex,
          userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user],
          false,
          stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[usersShiftIndex]
        );

        amountStakedShort -= userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user];
        userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user] = 0;
      }

      // Save the users updated staked amounts
      userAmountStaked[longToken][user] = amountStakedLong;
      userAmountStaked[shortToken][user] = amountStakedShort;

      floatReward += _calculateAccumulatedFloatInRange(
        marketIndex,
        amountStakedLong,
        amountStakedShort,
        stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[usersShiftIndex],
        latestRewardIndex[marketIndex]
      );

      userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][user] = 0;
    } else {
      floatReward = _calculateAccumulatedFloatInRange(
        marketIndex,
        amountStakedLong,
        amountStakedShort,
        usersLastRewardIndex,
        latestRewardIndex[marketIndex]
      );
    }
  }

  /**
  @notice Mints float for a user.
  @dev Mints a fixed percentage for Float capital.
  @param user The address of the user.
  @param floatToMint The amount of float to mint.
   */
  function _mintFloat(address user, uint256 floatToMint) internal virtual {
    IFloatToken(floatToken).mint(user, floatToMint);
    IFloatToken(floatToken).mint(floatCapital, (floatToMint * floatPercentage) / 1e18);
  }

  /**
  @notice Mints float owed to a user for a market since they last minted.
  @param marketIndex An identifier for the market.
  @param user The address of the user.
   */
  function _mintAccumulatedFloat(uint32 marketIndex, address user) internal virtual {
    uint256 floatToMint = _calculateAccumulatedFloat(marketIndex, user);

    if (floatToMint > 0) {
      // Set the user has claimed up until now, stops them setting this forward
      userIndexOfLastClaimedReward[marketIndex][user] = latestRewardIndex[marketIndex];

      _mintFloat(user, floatToMint);
      emit FloatMinted(user, marketIndex, floatToMint);
    }
  }

  /**
  @notice Mints float owed to a user for multiple markets, since they last minted for those markets.
  @param marketIndexes Identifiers for the markets.
  @param user The address of the user.
   */
  function _mintAccumulatedFloatMulti(uint32[] calldata marketIndexes, address user) internal virtual {
    uint256 floatTotal = 0;
    for (uint256 i = 0; i < marketIndexes.length; i++) {
      uint256 floatToMint = _calculateAccumulatedFloat(marketIndexes[i], user);

      if (floatToMint > 0) {
        // Set the user has claimed up until now, stops them setting this forward
        userIndexOfLastClaimedReward[marketIndexes[i]][user] = latestRewardIndex[marketIndexes[i]];

        floatTotal += floatToMint;

        emit FloatMinted(user, marketIndexes[i], floatToMint);
      }
    }
    if (floatTotal > 0) {
      _mintFloat(user, floatTotal);
    }
  }

  /**
  @notice Mints outstanding float for msg.sender.
  @param marketIndexes Identifiers for the markets for which to mint float.
   */
  function claimFloatCustom(uint32[] calldata marketIndexes) external {
    ILongShort(longShort).updateSystemStateMulti(marketIndexes);
    _mintAccumulatedFloatMulti(marketIndexes, msg.sender);
  }

  /**
  @notice Mints outstanding float on behalf of another user.
  @param marketIndexes Identifiers for the markets for which to mint float.
  @param user The address of the user.
   */
  function claimFloatCustomFor(uint32[] calldata marketIndexes, address user) external {
    // Unbounded loop - users are responsible for paying their own gas costs on these and it doesn't effect the rest of the system.
    // No need to impose limit.
    ILongShort(longShort).updateSystemStateMulti(marketIndexes);
    _mintAccumulatedFloatMulti(marketIndexes, user);
  }

  /*╔═══════════════════════╗
    ║        STAKING        ║
    ╚═══════════════════════╝*/

  /**
  @notice A user with synthetic tokens stakes by calling stake on the token
  contract which calls this function. We need to first update the
  state of the LongShort contract for this market before staking to correctly calculate user rewards.
  @param amount Amount to stake.
  @param from Address to stake for.
  */
  function stakeFromUser(address from, uint256 amount) public virtual override onlyValidSynthetic((msg.sender)) {
    ILongShort(longShort).updateSystemState(marketIndexOfToken[(msg.sender)]);
    _stake((msg.sender), amount, from);
  }

  /**
  @dev Internal logic for staking.
  @param token Address of the token for which to stake.
  @param amount Amount to stake.
  @param user Address to stake for.
  */
  function _stake(
    address token,
    uint256 amount,
    address user
  ) internal virtual {
    uint32 marketIndex = marketIndexOfToken[token];

    // If they already have staked and have rewards due, mint these.
    if (
      userIndexOfLastClaimedReward[marketIndex][user] != 0 &&
      userIndexOfLastClaimedReward[marketIndex][user] < latestRewardIndex[marketIndex]
    ) {
      _mintAccumulatedFloat(marketIndex, user);
    }

    userAmountStaked[token][user] = userAmountStaked[token][user] + amount;

    userIndexOfLastClaimedReward[marketIndex][user] = latestRewardIndex[marketIndex];

    emit StakeAdded(user, address(token), amount, userIndexOfLastClaimedReward[marketIndex][user]);
  }

  /**
  @notice Allows users to shift their staked tokens from one side of the market to 
  the other at the next price.
  @param amountSyntheticTokensToShift Amount of tokens to shift.
  @param marketIndex Identifier for the market.
  @param isShiftFromLong Whether the shift is from long to short or short to long.
  */
  function shiftTokens(
    uint256 amountSyntheticTokensToShift,
    uint32 marketIndex,
    bool isShiftFromLong
  ) external virtual {
    address token = syntheticTokens[marketIndex][isShiftFromLong];
    require(userAmountStaked[token][msg.sender] >= amountSyntheticTokensToShift, "Not enough tokens to shift");

    // If the user has outstanding token shift that have already been confirmed in the LongShort
    // contract, execute them first.
    if (
      userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] != 0 &&
      userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] <
      batched_stakerNextTokenShiftIndex[marketIndex]
    ) {
      _mintAccumulatedFloat(marketIndex, msg.sender);
    }

    if (isShiftFromLong) {
      ILongShort(longShort).shiftPositionFromLongNextPrice(marketIndex, amountSyntheticTokensToShift);
      userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][
        msg.sender
      ] += amountSyntheticTokensToShift;
    } else {
      ILongShort(longShort).shiftPositionFromShortNextPrice(marketIndex, amountSyntheticTokensToShift);
      userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][
        msg.sender
      ] += amountSyntheticTokensToShift;
    }

    userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] = batched_stakerNextTokenShiftIndex[
      marketIndex
    ];
  }

  /*╔════════════════════════════╗
    ║    WITHDRAWAL & MINTING    ║
    ╚════════════════════════════╝*/

  /**
  @notice Internal logic for withdrawing stakes.
  @dev Mint user any outstanding float before withdrawing.
  @param marketIndex Market index of token.
  @param amount Amount to withdraw.
  @param token Synthetic token that was staked.
  */
  function _withdraw(
    uint32 marketIndex,
    address token,
    uint256 amount
  ) internal virtual {
    require(userAmountStaked[token][msg.sender] > 0, "nothing to withdraw");
    _mintAccumulatedFloat(marketIndex, msg.sender);

    userAmountStaked[token][msg.sender] = userAmountStaked[token][msg.sender] - amount;

    uint256 amountFees = (amount * marketUnstakeFee_e18[marketIndex]) / 1e18;

    IERC20(token).transfer(floatTreasury, amountFees);
    IERC20(token).transfer(msg.sender, amount - amountFees);

    emit StakeWithdrawn(msg.sender, token, amount);
  }

  /**
  @notice Withdraw function. Allows users to unstake.
  @param amount Amount to withdraw.
  @param token Address of the token for which to withdraw.
  */
  function withdraw(address token, uint256 amount) external {
    ILongShort(longShort).updateSystemState(marketIndexOfToken[token]);

    uint32 marketIndex = marketIndexOfToken[token];

    _withdraw(marketIndex, token, amount);

    if (userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] > 0) {
      // If they still have outstanding shifts after minting float, then check
      // that they don't withdraw more than their shifts allow.
      uint256 amountToShiftForThisToken = syntheticTokens[marketIndex][true] == token
        ? userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][msg.sender]
        : userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][msg.sender];

      require(
        userAmountStaked[token][msg.sender] >= amountToShiftForThisToken,
        "Outstanding next price stake shifts too great"
      );
    }
  }

  /**
  @notice Allows users to withdraw their entire stake for a token.
  @param token Address of the token for which to withdraw.
  */
  function withdrawAll(address token) external {
    ILongShort(longShort).updateSystemState(marketIndexOfToken[token]);

    uint32 marketIndex = marketIndexOfToken[token];

    uint256 amountToShiftForThisToken = syntheticTokens[marketIndex][true] == token
      ? userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][msg.sender]
      : userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][msg.sender];

    _withdraw(marketIndex, token, userAmountStaked[token][msg.sender] - amountToShiftForThisToken);
  }
}
.]

###

[2024-17-08 08:01:27 INFO] **[Seminar Conclusion]**:

 ###

[2024-17-08 08:01:27 INFO] **[Execute Detail]**

execute SimplePhase:[BugsSummary] in ComposedPhase:[CodeReview], cycle 1

[2024-17-08 08:01:27 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: BUSL-1.1 pragma solidity 0.8.3; import "@openzeppelin/contracts-upgradeable/token/ERC20/presets/ERC20PresetMinterPauserUpgradeable.sol"; import "./interfaces/IFloatToken.sol"; import "./interfaces/ILongShort.sol"; import "./interfaces/IStaker.sol"; import "./interfaces/ISyntheticToken.sol"; contract Staker is IStaker, Initializable {   /╔═════════════════════════════╗     ║          VARIABLES          ║     ╚═════════════════════════════╝/ / ══════ Fixed-precision constants ══════ /   uint256 public constant FLOAT_ISSUANCE_FIXED_DECIMAL = 1e42;   // 2^52 ~= 4.5e15   // With an exponent of 5, the largest total liquidity possible in a market (to avoid integer overflow on exponentiation) is ~10^31 or 10 Trillion (10^13)   // NOTE: this also means if the total market value is less than 2^52 there will be a division by zero error   uint256 public constant safeExponentBitShifting = 52; / ══════ Global state ══════ /   address public admin;   address public floatCapital;   address public floatTreasury;   uint256 public floatPercentage; address public longShort;   address public floatToken; / ══════ Market specific ══════ /   mapping(uint32 =&gt; uint256) public marketLaunchIncentive_period; // seconds   mapping(uint32 =&gt; uint256) public marketLaunchIncentive_multipliers; // e18 scale   mapping(uint32 =&gt; uint256) public marketUnstakeFee_e18;   mapping(uint32 =&gt; uint256) public balanceIncentiveCurve_exponent;   mapping(uint32 =&gt; int256) public balanceIncentiveCurve_equilibriumOffset; mapping(uint32 =&gt; mapping(bool =&gt; address)) public syntheticTokens; mapping(address =&gt; uint32) public marketIndexOfToken; / ══════ Reward specific ══════ /   mapping(uint32 =&gt; uint256) public latestRewardIndex;   mapping(uint32 =&gt; mapping(uint256 =&gt; AccumulativeIssuancePerStakedSynthSnapshot))     public accumulativeFloatPerSyntheticTokenSnapshots;   struct AccumulativeIssuancePerStakedSynthSnapshot {     uint256 timestamp;     uint256 accumulativeFloatPerSyntheticToken_long;     uint256 accumulativeFloatPerSyntheticToken_short;   } / ══════ User specific ══════ /   mapping(uint32 =&gt; mapping(address =&gt; uint256)) public userIndexOfLastClaimedReward;   mapping(address =&gt; mapping(address =&gt; uint256)) public userAmountStaked; / ══════ Token shift management specific ══════ /   mapping(uint32 =&gt; uint256) public batched_stakerNextTokenShiftIndex;   /*   @notice Used to link a token shift to a staker state   @dev tokenShiftIndex =&gt; accumulativeFloatIssuanceSnapshotIndex     POSSIBLE OPTIMIZATION - could pack stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping and stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping into a struct of two uint128 for storage space optimization.   /   mapping(uint256 =&gt; uint256) public stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping;   /// @notice Used to fetch the price from LongShort at that point in time   /// @dev tokenShiftIndex =&gt; longShortMarketPriceSnapshotIndex   mapping(uint256 =&gt; uint256) public stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping;   /// @dev marketIndex =&gt; usersAddress =&gt; stakerTokenShiftIndex   mapping(uint32 =&gt; mapping(address =&gt; uint256)) public userNextPrice_stakedSyntheticTokenShiftIndex;   /// @dev marketIndex =&gt; usersAddress =&gt; amountUserRequestedToShiftAwayFromLongOnNextUpdate   mapping(uint32 =&gt; mapping(address =&gt; uint256)) public userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long;   /// @dev marketIndex =&gt; usersAddress =&gt; amountUserRequestedToShiftAwayFromShortOnNextUpdate   mapping(uint32 =&gt; mapping(address =&gt; uint256)) public userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short; /╔════════════════════════════╗     ║           EVENTS           ║     ╚════════════════════════════╝/ event StakerV1(     address admin,     address floatTreasury,     address floatCapital,     address floatToken,     uint256 floatPercentage   ); event MarketAddedToStaker(     uint32 marketIndex,     uint256 exitFee_e18,     uint256 period,     uint256 multiplier,     uint256 balanceIncentiveExponent,     int256 balanceIncentiveEquilibriumOffset   ); event AccumulativeIssuancePerStakedSynthSnapshotCreated(     uint32 marketIndex,     uint256 accumulativeFloatIssuanceSnapshotIndex,     uint256 accumulativeLong,     uint256 accumulativeShort   ); event StakeAdded(address user, address token, uint256 amount, uint256 lastMintIndex); event StakeWithdrawn(address user, address token, uint256 amount); // Note: the amountFloatMinted isn't strictly needed by the graph, but it is good to add it to validate calculations are accurate.   event FloatMinted(address user, uint32 marketIndex, uint256 amountFloatMinted); event MarketLaunchIncentiveParametersChanges(uint32 marketIndex, uint256 period, uint256 multiplier); event StakeWithdrawalFeeUpdated(uint32 marketIndex, uint256 stakeWithdralFee); event BalanceIncentiveExponentUpdated(uint32 marketIndex, uint256 balanceIncentiveExponent); event BalanceIncentiveEquilibriumOffsetUpdated(uint32 marketIndex, int256 balanceIncentiveEquilibriumOffset); event FloatPercentageUpdated(uint256 floatPercentage); event SyntheticTokensShifted(); event ChangeAdmin(address newAdmin); /╔═════════════════════════════╗     ║          MODIFIERS          ║     ╚═════════════════════════════╝/ function onlyAdminModifierLogic() internal virtual {     require(msg.sender == admin, "not admin");   } modifier onlyAdmin() {     onlyAdminModifierLogic();     _;   } function onlyValidSyntheticModifierLogic(address _synth) internal virtual {     require(marketIndexOfToken[_synth] != 0, "not valid synth");   } modifier onlyValidSynthetic(address synth) {     onlyValidSyntheticModifierLogic(_synth);     ;   } function onlyValidMarketModifierLogic(uint32 marketIndex) internal virtual {     require(address(syntheticTokens[marketIndex][true]) != address(0), "not valid market");   } modifier onlyValidMarket(uint32 marketIndex) {     onlyValidMarketModifierLogic(marketIndex);     _;   } function onlyLongShortModifierLogic() internal virtual {     require(msg.sender == address(longShort), "not long short");   } modifier onlyLongShort() {     onlyLongShortModifierLogic();     _;   } /╔═════════════════════════════╗     ║       CONTRACT SET-UP       ║     ╚═════════════════════════════╝/ /*   @notice Initializes the contract.   @dev Calls OpenZeppelin's initializer modifier.   @param _admin Address of the admin role.   @param _longShort Address of the LongShort contract, a deployed LongShort.sol   @param _floatToken Address of the Float token earned by staking.   @param _floatTreasury Address of the treasury contract for managing fees.   @param _floatCapital Address of the contract which earns a fixed percentage of Float.   @param _floatPercentage Determines the float percentage that gets minted for Float Capital, base 1e18.   /   function initialize(     address _admin,     address _longShort,     address _floatToken,     address _floatTreasury,     address _floatCapital,     uint256 _floatPercentage   ) external virtual initializer {     admin = _admin;     floatCapital = _floatCapital;     floatTreasury = _floatTreasury;     longShort = _longShort;     floatToken = _floatToken; _changeFloatPercentage(_floatPercentage);  emit StakerV1(_admin, _floatTreasury, _floatCapital, _floatToken, _floatPercentage);  } /╔═══════════════════╗     ║       ADMIN       ║     ╚═══════════════════╝/ /*    @notice Changes admin for the contract   @param _admin The address of the new admin.   /   function changeAdmin(address _admin) external onlyAdmin {     admin = _admin;     emit ChangeAdmin(_admin);   } /// @dev Logic for changeFloatPercentage   function _changeFloatPercentage(uint256 newFloatPercentage) internal virtual {     require(newFloatPercentage &lt;= 1e18 &amp;&amp; newFloatPercentage &gt; 0); // less than or equal to 100% and greater than 0%     floatPercentage = newFloatPercentage;   } /*   @notice Changes percentage of float that is minted for float capital.   @param newFloatPercentage The new float percentage in base 1e18.   /   function changeFloatPercentage(uint256 newFloatPercentage) external onlyAdmin {     _changeFloatPercentage(newFloatPercentage);     emit FloatPercentageUpdated(newFloatPercentage);   } /// @dev Logic for changeUnstakeFee   function _changeUnstakeFee(uint32 marketIndex, uint256 newMarketUnstakeFee_e18) internal virtual {     require(newMarketUnstakeFee_e18 &lt;= 5e16); // Explicitely stating 5% fee as the max fee possible.     marketUnstakeFee_e18[marketIndex] = newMarketUnstakeFee_e18;   } /*   @notice Changes unstake fee for a market   @param marketIndex Identifies the market.   @param newMarketUnstakeFee_e18 The new unstake fee.   /   function changeUnstakeFee(uint32 marketIndex, uint256 newMarketUnstakeFee_e18) external onlyAdmin {     _changeUnstakeFee(marketIndex, newMarketUnstakeFee_e18);     emit StakeWithdrawalFeeUpdated(marketIndex, newMarketUnstakeFee_e18);   } /// @dev Logic for changeMarketLaunchIncentiveParameters   function _changeMarketLaunchIncentiveParameters(     uint32 marketIndex,     uint256 period,     uint256 initialMultiplier   ) internal virtual {     require(initialMultiplier &gt;= 1e18, "marketLaunchIncentiveMultiplier must be &gt;= 1e18"); marketLaunchIncentive_period[marketIndex] = period; marketLaunchIncentive_multipliers[marketIndex] = initialMultiplier;  } /*   @notice Changes the market launch incentive parameters for a market   @param marketIndex Identifies the market.   @param period The new period for which float token generation should be boosted.   @param initialMultiplier The new multiplier on Float generation.   /   function changeMarketLaunchIncentiveParameters(     uint32 marketIndex,     uint256 period,     uint256 initialMultiplier   ) external onlyAdmin {     _changeMarketLaunchIncentiveParameters(marketIndex, period, initialMultiplier); emit MarketLaunchIncentiveParametersChanges(marketIndex, period, initialMultiplier);  } /// @dev Logic for changeBalanceIncentiveExponent   function _changeBalanceIncentiveExponent(uint32 marketIndex, uint256 _balanceIncentiveCurve_exponent)     internal     virtual   {     require(       // The exponent has to be less than 5 in these versions of the contracts.       _balanceIncentiveCurve_exponent &gt; 0 &amp;&amp; _balanceIncentiveCurve_exponent &lt; 6,       "balanceIncentiveCurve_exponent out of bounds"     ); balanceIncentiveCurve_exponent[marketIndex] = _balanceIncentiveCurve_exponent;  } /*    @notice Changes the balance incentive exponent for a market   @param marketIndex Identifies the market.   @param _balanceIncentiveCurve_exponent The new exponent for the curve.   /   function changeBalanceIncentiveExponent(uint32 marketIndex, uint256 _balanceIncentiveCurve_exponent)     external     onlyAdmin   {     _changeBalanceIncentiveExponent(marketIndex, _balanceIncentiveCurve_exponent); emit BalanceIncentiveExponentUpdated(marketIndex, _balanceIncentiveCurve_exponent);  } /// @dev Logic for changeBalanceIncentiveEquilibriumOffset   function _changeBalanceIncentiveEquilibriumOffset(uint32 marketIndex, int256 _balanceIncentiveCurve_equilibriumOffset)     internal     virtual   {     // Unreasonable that we would ever shift this more than 90% either way     require(       _balanceIncentiveCurve_equilibriumOffset &gt; -9e17 &amp;&amp; _balanceIncentiveCurve_equilibriumOffset &lt; 9e17,       "balanceIncentiveCurve_equilibriumOffset out of bounds"     ); balanceIncentiveCurve_equilibriumOffset[marketIndex] = _balanceIncentiveCurve_equilibriumOffset;  } /*   @notice Changes the balance incentive curve equilibrium offset for a market   @param marketIndex Identifies the market.   @param _balanceIncentiveCurve_equilibriumOffset The new offset.   /   function changeBalanceIncentiveEquilibriumOffset(uint32 marketIndex, int256 _balanceIncentiveCurve_equilibriumOffset)     external     onlyAdmin   {     _changeBalanceIncentiveEquilibriumOffset(marketIndex, _balanceIncentiveCurve_equilibriumOffset); emit BalanceIncentiveEquilibriumOffsetUpdated(marketIndex, _balanceIncentiveCurve_equilibriumOffset);  } /╔═════════════════════════════╗     ║        STAKING SETUP        ║     ╚═════════════════════════════╝/ /*   @notice Sets this contract to track staking for a market in LongShort.sol   @param marketIndex Identifies the market.   @param longToken Address of the long token for the market.   @param shortToken Address of the short token for the market.   @param kInitialMultiplier Initial boost on float generation for the market.   @param kPeriod Period which the boost should last.   @param unstakeFee_e18 Percentage of tokens that are levied on unstaking in base 1e18.   @param _balanceIncentiveCurve_exponent Exponent for balance curve (see _calculateFloatPerSecond)   @param _balanceIncentiveCurve_equilibriumOffset Offset for balance curve (see _calculateFloatPerSecond)   /   function addNewStakingFund(     uint32 marketIndex,     address longToken,     address shortToken,     uint256 kInitialMultiplier,     uint256 kPeriod,     uint256 unstakeFee_e18,     uint256 _balanceIncentiveCurve_exponent,     int256 _balanceIncentiveCurve_equilibriumOffset   ) external override onlyLongShort {     marketIndexOfToken[longToken] = marketIndex;     marketIndexOfToken[shortToken] = marketIndex; accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].timestamp = block.timestamp; accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].accumulativeFloatPerSyntheticToken_long = 0; accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].accumulativeFloatPerSyntheticToken_short = 0;  syntheticTokens[marketIndex][true] = longToken; syntheticTokens[marketIndex][false] = shortToken;  _changeBalanceIncentiveExponent(marketIndex, _balanceIncentiveCurve_exponent); _changeBalanceIncentiveEquilibriumOffset(marketIndex, _balanceIncentiveCurve_equilibriumOffset); _changeMarketLaunchIncentiveParameters(marketIndex, kPeriod, kInitialMultiplier);  _changeUnstakeFee(marketIndex, unstakeFee_e18);  // Set this value to one initially - 0 is a null value and thus potentially bug prone. batched_stakerNextTokenShiftIndex[marketIndex] = 1;  emit MarketAddedToStaker(   marketIndex,   unstakeFee_e18,   kPeriod,   kInitialMultiplier,   _balanceIncentiveCurve_exponent,   _balanceIncentiveCurve_equilibriumOffset );  emit AccumulativeIssuancePerStakedSynthSnapshotCreated(marketIndex, 0, 0, 0);  } /╔═════════════════════════════════════════════════════════════════════════╗     ║    GLOBAL FLT REWARD ACCUMULATION CALCULATION AND TRACKING FUNCTIONS    ║     ╚═════════════════════════════════════════════════════════════════════════╝/ /*   @notice Returns the K factor parameters for the given market with sensible   defaults if they haven't been set yet.   @param marketIndex The market to change the parameters for.   @return period The period for which the k factor applies for in seconds.   @return multiplier The multiplier on Float generation in this period.   /   function _getMarketLaunchIncentiveParameters(uint32 marketIndex)     internal     view     virtual     returns (uint256 period, uint256 multiplier)   {     period = marketLaunchIncentive_period[marketIndex];     multiplier = marketLaunchIncentive_multipliers[marketIndex]; if (multiplier &lt; 1e18) {   multiplier = 1e18; // multiplier of 1 by default }  } /*    @notice Returns the extent to which a markets float generation should be adjusted   based on the market's launch incentive parameters. Should start at multiplier   then linearly change to 1e18 over time.   @param marketIndex Identifies the market.   @return k The calculated modifier for float generation.   /   function _getKValue(uint32 marketIndex) internal view virtual returns (uint256) {     // Parameters controlling the float issuance multiplier.     (uint256 kPeriod, uint256 kInitialMultiplier) = _getMarketLaunchIncentiveParameters(marketIndex); // Sanity check - under normal circumstances, the multipliers should // *never* be set to a value &lt; 1e18, as there are guards against this. assert(kInitialMultiplier &gt;= 1e18);  uint256 initialTimestamp = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].timestamp;  if (block.timestamp - initialTimestamp &lt;= kPeriod) {   return kInitialMultiplier - (((kInitialMultiplier - 1e18) * (block.timestamp - initialTimestamp)) / kPeriod); } else {   return 1e18; }  } /   @notice Computes the number of float tokens a user earns per second for   every long/short synthetic token they've staked. The returned value has   a fixed decimal scale of 1e42 (!!!) for numerical stability. The return   values are float per second per synthetic token (hence the requirement   to multiply by price)   @dev to see below math in latex form see TODO add link   to interact with the equations see https://www.desmos.com/calculator/optkaxyihr   @param marketIndex The market referred to.   @param longPrice Price of the synthetic long token in units of payment token   @param shortPrice Price of the synthetic short token in units of payment token   @param longValue Amount of payment token in the long side of the market   @param shortValue Amount of payment token in the short side of the market   @return longFloatPerSecond Float token per second per long synthetic token   @return shortFloatPerSecond Float token per second per short synthetic token    /   function _calculateFloatPerSecond(     uint32 marketIndex,     uint256 longPrice,     uint256 shortPrice,     uint256 longValue,     uint256 shortValue   ) internal view virtual returns (uint256 longFloatPerSecond, uint256 shortFloatPerSecond) {     // A float issuance multiplier that starts high and decreases linearly     // over time to a value of 1. This incentivises users to stake early.     uint256 k = _getKValue(marketIndex); uint256 totalLocked = (longValue + shortValue);  // we need to scale this number by the totalLocked so that the offset remains consistent accross market size  int256 equilibriumOffsetMarketScaled = (balanceIncentiveCurve_equilibriumOffset[marketIndex] *   int256(totalLocked)) / 2e18;  uint256 denominator = ((totalLocked &gt;&gt; safeExponentBitShifting)**balanceIncentiveCurve_exponent[marketIndex]);  // Float is scaled by the percentage of the total market value held in // the opposite position. This incentivises users to stake on the // weaker position. if (int256(shortValue) - equilibriumOffsetMarketScaled &lt; int256(longValue)) {   if (equilibriumOffsetMarketScaled &gt;= int256(shortValue)) {     // edge case: imbalanced far past the equilibrium offset - full rewards go to short token     //            extremeley unlikely to happen in practice     return (0, 1e18 * k * shortPrice);   }    uint256 numerator = (uint256(int256(shortValue) - equilibriumOffsetMarketScaled) &gt;&gt;     (safeExponentBitShifting - 1))**balanceIncentiveCurve_exponent[marketIndex];    // NOTE: `x * 5e17` == `(x * 10e18) / 2`   uint256 longRewardUnscaled = (numerator * 5e17) / denominator;   uint256 shortRewardUnscaled = 1e18 - longRewardUnscaled;    return ((longRewardUnscaled * k * longPrice) / 1e18, (shortRewardUnscaled * k * shortPrice) / 1e18); } else {   if (-equilibriumOffsetMarketScaled &gt;= int256(longValue)) {     // edge case: imbalanced far past the equilibrium offset - full rewards go to long token     //            extremeley unlikely to happen in practice     return (1e18 * k * longPrice, 0);   }    uint256 numerator = (uint256(int256(longValue) + equilibriumOffsetMarketScaled) &gt;&gt;     (safeExponentBitShifting - 1))**balanceIncentiveCurve_exponent[marketIndex];    // NOTE: `x * 5e17` == `(x * 10e18) / 2`   uint256 shortRewardUnscaled = (numerator * 5e17) / denominator;   uint256 longRewardUnscaled = 1e18 - shortRewardUnscaled;    return ((longRewardUnscaled * k * longPrice) / 1e18, (shortRewardUnscaled * k * shortPrice) / 1e18); }  } /*   @notice Computes the time since last accumulativeIssuancePerStakedSynthSnapshot for the given market in seconds.   @param marketIndex The market referred to.   @return The time difference in seconds   /   function _calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(uint32 marketIndex)     internal     view     virtual     returns (uint256)   {     return       block.timestamp -       accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]].timestamp;   } /*   @notice Computes new cumulative sum of 'r' value since last accumulativeIssuancePerStakedSynthSnapshot. We use   cumulative 'r' value to avoid looping during issuance. Note that the   cumulative sum is kept in 1e42 scale (!!!) to avoid numerical issues.   @param shortValue The value locked in the short side of the market.   @param longValue The value locked in the long side of the market.   @param shortPrice The price of the short token as defined in LongShort.sol   @param longPrice The price of the long token as defined in LongShort.sol   @param marketIndex An identifier for the market.   @return longCumulativeRates The long cumulative sum.   @return shortCumulativeRates The short cumulative sum.   /   function _calculateNewCumulativeIssuancePerStakedSynth(     uint32 marketIndex,     uint256 longPrice,     uint256 shortPrice,     uint256 longValue,     uint256 shortValue   ) internal view virtual returns (uint256 longCumulativeRates, uint256 shortCumulativeRates) {     // Compute the current 'r' value for float issuance per second.     (uint256 longFloatPerSecond, uint256 shortFloatPerSecond) = _calculateFloatPerSecond(       marketIndex,       longPrice,       shortPrice,       longValue,       shortValue     ); // Compute time since last accumulativeIssuancePerStakedSynthSnapshot for the given token. uint256 timeDelta = _calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(marketIndex);  // Compute new cumulative 'r' value total. return (   accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]]   .accumulativeFloatPerSyntheticToken_long + (timeDelta * longFloatPerSecond),   accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]]   .accumulativeFloatPerSyntheticToken_short + (timeDelta * shortFloatPerSecond) );  } /*   @notice Creates a new accumulativeIssuancePerStakedSynthSnapshot for the given token and updates indexes.   @param shortValue The value locked in the short side of the market.   @param longValue The value locked in the long side of the market.   @param shortPrice The price of the short token as defined in LongShort.sol   @param longPrice The price of the long token as defined in LongShort.sol   @param marketIndex An identifier for the market.   /   function _setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot(     uint32 marketIndex,     uint256 longPrice,     uint256 shortPrice,     uint256 longValue,     uint256 shortValue   ) internal virtual {     (       uint256 newLongAccumulativeValue,       uint256 newShortAccumulativeValue     ) = _calculateNewCumulativeIssuancePerStakedSynth(marketIndex, longPrice, shortPrice, longValue, shortValue); uint256 newIndex = latestRewardIndex[marketIndex] + 1;  // Set cumulative 'r' value on new accumulativeIssuancePerStakedSynthSnapshot. accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex] .accumulativeFloatPerSyntheticToken_long = newLongAccumulativeValue; accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex] .accumulativeFloatPerSyntheticToken_short = newShortAccumulativeValue;  // Set timestamp on new accumulativeIssuancePerStakedSynthSnapshot. accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex].timestamp = block.timestamp;  // Update latest index to point to new accumulativeIssuancePerStakedSynthSnapshot. latestRewardIndex[marketIndex] = newIndex;  emit AccumulativeIssuancePerStakedSynthSnapshotCreated(   marketIndex,   newIndex,   newLongAccumulativeValue,   newShortAccumulativeValue );  } /*   @notice Adds new accumulativeIssuancePerStakedSynthSnapshots for the given long/short tokens. Called by the   ILongShort contract whenever there is a state change for a market.   @param stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted Mapping from this contract's shifts to LongShort.sols next price snapshots.   @param shortValue The value locked in the short side of the market.   @param longValue The value locked in the long side of the market.   @param shortPrice The price of the short token as defined in LongShort.sol   @param longPrice The price of the long token as defined in LongShort.sol   @param marketIndex An identifier for the market.   /   function pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(     uint32 marketIndex,     uint256 longPrice,     uint256 shortPrice,     uint256 longValue,     uint256 shortValue,     uint256 stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted // This value should be ALWAYS be zero if no shift occured   ) external override onlyLongShort {     // Only add a new accumulativeIssuancePerStakedSynthSnapshot if some time has passed. // the `stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted` value will be 0 if there is no staker related action in an executed batch if (stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted &gt; 0) {   stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[     batched_stakerNextTokenShiftIndex[marketIndex]   ] = stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted;   stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[     batched_stakerNextTokenShiftIndex[marketIndex]   ] = latestRewardIndex[marketIndex] + 1;   batched_stakerNextTokenShiftIndex[marketIndex] += 1;    emit SyntheticTokensShifted(); }  // Time delta is fetched twice in below code, can pass through? Which is less gas? if (_calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(marketIndex) &gt; 0) {   _setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot(     marketIndex,     longPrice,     shortPrice,     longValue,     shortValue   ); }  } /╔═══════════════════════════════════╗     ║    USER REWARD STATE FUNCTIONS    ║     ╚═══════════════════════════════════╝/ /// @dev Calculates the accumulated float in a specific range of staker snapshots   function _calculateAccumulatedFloatInRange(     uint32 marketIndex,     uint256 amountStakedLong,     uint256 amountStakedShort,     uint256 rewardIndexFrom,     uint256 rewardIndexTo   ) internal view virtual returns (uint256 floatReward) {     if (amountStakedLong &gt; 0) {       uint256 accumDeltaLong = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexTo]       .accumulativeFloatPerSyntheticToken_long -         accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexFrom]         .accumulativeFloatPerSyntheticToken_long;       floatReward += (accumDeltaLong * amountStakedLong) / FLOAT_ISSUANCE_FIXED_DECIMAL;     } if (amountStakedShort &gt; 0) {   uint256 accumDeltaShort = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexTo]   .accumulativeFloatPerSyntheticToken_short -     accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexFrom]     .accumulativeFloatPerSyntheticToken_short;   floatReward += (accumDeltaShort * amountStakedShort) / FLOAT_ISSUANCE_FIXED_DECIMAL; }  } /*    @notice Calculates float owed to the user since the user last minted float for a market.   @param marketIndex Identifier for the market which the user staked in.   @param user The address of the user.   @return floatReward The amount of float owed.    /   function _calculateAccumulatedFloat(uint32 marketIndex, address user) internal virtual returns (uint256 floatReward) {     address longToken = syntheticTokens[marketIndex][true];     address shortToken = syntheticTokens[marketIndex][false]; uint256 amountStakedLong = userAmountStaked[longToken][user]; uint256 amountStakedShort = userAmountStaked[shortToken][user];  uint256 usersLastRewardIndex = userIndexOfLastClaimedReward[marketIndex][user];  // Don't do the calculation and return zero immediately if there is no change if (usersLastRewardIndex == latestRewardIndex[marketIndex]) {   return 0; }  uint256 usersShiftIndex = userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][user]; // if there is a change in the users tokens held due to a token shift (or possibly another action in the future) if (usersShiftIndex &gt; 0 &amp;&amp; usersShiftIndex &lt; batched_stakerNextTokenShiftIndex[marketIndex]) {   floatReward = _calculateAccumulatedFloatInRange(     marketIndex,     amountStakedLong,     amountStakedShort,     usersLastRewardIndex,     stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[usersShiftIndex]   );    // Update the users balances   if (userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user] &gt; 0) {     amountStakedShort += ILongShort(longShort).getAmountSyntheticTokenToMintOnTargetSide(       marketIndex,       userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user],       true,       stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[usersShiftIndex]     );      amountStakedLong -= userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user];     userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user] = 0;   }    if (userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user] &gt; 0) {     amountStakedLong += ILongShort(longShort).getAmountSyntheticTokenToMintOnTargetSide(       marketIndex,       userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user],       false,       stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[usersShiftIndex]     );      amountStakedShort -= userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user];     userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user] = 0;   }    // Save the users updated staked amounts   userAmountStaked[longToken][user] = amountStakedLong;   userAmountStaked[shortToken][user] = amountStakedShort;    floatReward += _calculateAccumulatedFloatInRange(     marketIndex,     amountStakedLong,     amountStakedShort,     stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[usersShiftIndex],     latestRewardIndex[marketIndex]   );    userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][user] = 0; } else {   floatReward = _calculateAccumulatedFloatInRange(     marketIndex,     amountStakedLong,     amountStakedShort,     usersLastRewardIndex,     latestRewardIndex[marketIndex]   ); }  } /*   @notice Mints float for a user.   @dev Mints a fixed percentage for Float capital.   @param user The address of the user.   @param floatToMint The amount of float to mint.    /   function _mintFloat(address user, uint256 floatToMint) internal virtual {     IFloatToken(floatToken).mint(user, floatToMint);     IFloatToken(floatToken).mint(floatCapital, (floatToMint * floatPercentage) / 1e18);   } /*   @notice Mints float owed to a user for a market since they last minted.   @param marketIndex An identifier for the market.   @param user The address of the user.    /   function _mintAccumulatedFloat(uint32 marketIndex, address user) internal virtual {     uint256 floatToMint = _calculateAccumulatedFloat(marketIndex, user); if (floatToMint &gt; 0) {   // Set the user has claimed up until now, stops them setting this forward   userIndexOfLastClaimedReward[marketIndex][user] = latestRewardIndex[marketIndex];    _mintFloat(user, floatToMint);   emit FloatMinted(user, marketIndex, floatToMint); }  } /*   @notice Mints float owed to a user for multiple markets, since they last minted for those markets.   @param marketIndexes Identifiers for the markets.   @param user The address of the user.    /   function _mintAccumulatedFloatMulti(uint32[] calldata marketIndexes, address user) internal virtual {     uint256 floatTotal = 0;     for (uint256 i = 0; i &lt; marketIndexes.length; i++) {       uint256 floatToMint = _calculateAccumulatedFloat(marketIndexes[i], user);   if (floatToMint &gt; 0) {     // Set the user has claimed up until now, stops them setting this forward     userIndexOfLastClaimedReward[marketIndexes[i]][user] = latestRewardIndex[marketIndexes[i]];      floatTotal += floatToMint;      emit FloatMinted(user, marketIndexes[i], floatToMint);   } } if (floatTotal &gt; 0) {   _mintFloat(user, floatTotal); }  } /*   @notice Mints outstanding float for msg.sender.   @param marketIndexes Identifiers for the markets for which to mint float.    /   function claimFloatCustom(uint32[] calldata marketIndexes) external {     ILongShort(longShort).updateSystemStateMulti(marketIndexes);     _mintAccumulatedFloatMulti(marketIndexes, msg.sender);   } /*   @notice Mints outstanding float on behalf of another user.   @param marketIndexes Identifiers for the markets for which to mint float.   @param user The address of the user.    /   function claimFloatCustomFor(uint32[] calldata marketIndexes, address user) external {     // Unbounded loop - users are responsible for paying their own gas costs on these and it doesn't effect the rest of the system.     // No need to impose limit.     ILongShort(longShort).updateSystemStateMulti(marketIndexes);     _mintAccumulatedFloatMulti(marketIndexes, user);   } /╔═══════════════════════╗     ║        STAKING        ║     ╚═══════════════════════╝/ /*   @notice A user with synthetic tokens stakes by calling stake on the token   contract which calls this function. We need to first update the   state of the LongShort contract for this market before staking to correctly calculate user rewards.   @param amount Amount to stake.   @param from Address to stake for.   /   function stakeFromUser(address from, uint256 amount) public virtual override onlyValidSynthetic((msg.sender)) {     ILongShort(longShort).updateSystemState(marketIndexOfToken[(msg.sender)]);     _stake((msg.sender), amount, from);   } /*   @dev Internal logic for staking.   @param token Address of the token for which to stake.   @param amount Amount to stake.   @param user Address to stake for.   /   function _stake(     address token,     uint256 amount,     address user   ) internal virtual {     uint32 marketIndex = marketIndexOfToken[token]; // If they already have staked and have rewards due, mint these. if (   userIndexOfLastClaimedReward[marketIndex][user] != 0 &amp;&amp;   userIndexOfLastClaimedReward[marketIndex][user] &lt; latestRewardIndex[marketIndex] ) {   _mintAccumulatedFloat(marketIndex, user); }  userAmountStaked[token][user] = userAmountStaked[token][user] + amount;  userIndexOfLastClaimedReward[marketIndex][user] = latestRewardIndex[marketIndex];  emit StakeAdded(user, address(token), amount, userIndexOfLastClaimedReward[marketIndex][user]);  } /*   @notice Allows users to shift their staked tokens from one side of the market to    the other at the next price.   @param amountSyntheticTokensToShift Amount of tokens to shift.   @param marketIndex Identifier for the market.   @param isShiftFromLong Whether the shift is from long to short or short to long.   /   function shiftTokens(     uint256 amountSyntheticTokensToShift,     uint32 marketIndex,     bool isShiftFromLong   ) external virtual {     address token = syntheticTokens[marketIndex][isShiftFromLong];     require(userAmountStaked[token][msg.sender] &gt;= amountSyntheticTokensToShift, "Not enough tokens to shift"); // If the user has outstanding token shift that have already been confirmed in the LongShort // contract, execute them first. if (   userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] != 0 &amp;&amp;   userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] &lt;   batched_stakerNextTokenShiftIndex[marketIndex] ) {   _mintAccumulatedFloat(marketIndex, msg.sender); }  if (isShiftFromLong) {   ILongShort(longShort).shiftPositionFromLongNextPrice(marketIndex, amountSyntheticTokensToShift);   userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][     msg.sender   ] += amountSyntheticTokensToShift; } else {   ILongShort(longShort).shiftPositionFromShortNextPrice(marketIndex, amountSyntheticTokensToShift);   userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][     msg.sender   ] += amountSyntheticTokensToShift; }  userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] = batched_stakerNextTokenShiftIndex[   marketIndex ];  } /╔════════════════════════════╗     ║    WITHDRAWAL &amp; MINTING    ║     ╚════════════════════════════╝/ /*   @notice Internal logic for withdrawing stakes.   @dev Mint user any outstanding float before withdrawing.   @param marketIndex Market index of token.   @param amount Amount to withdraw.   @param token Synthetic token that was staked.   /   function _withdraw(     uint32 marketIndex,     address token,     uint256 amount   ) internal virtual {     require(userAmountStaked[token][msg.sender] &gt; 0, "nothing to withdraw");     _mintAccumulatedFloat(marketIndex, msg.sender); userAmountStaked[token][msg.sender] = userAmountStaked[token][msg.sender] - amount;  uint256 amountFees = (amount * marketUnstakeFee_e18[marketIndex]) / 1e18;  IERC20(token).transfer(floatTreasury, amountFees); IERC20(token).transfer(msg.sender, amount - amountFees);  emit StakeWithdrawn(msg.sender, token, amount);  } /*   @notice Withdraw function. Allows users to unstake.   @param amount Amount to withdraw.   @param token Address of the token for which to withdraw.   /   function withdraw(address token, uint256 amount) external {     ILongShort(longShort).updateSystemState(marketIndexOfToken[token]); uint32 marketIndex = marketIndexOfToken[token];  _withdraw(marketIndex, token, amount);  if (userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] &gt; 0) {   // If they still have outstanding shifts after minting float, then check   // that they don't withdraw more than their shifts allow.   uint256 amountToShiftForThisToken = syntheticTokens[marketIndex][true] == token     ? userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][msg.sender]     : userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][msg.sender];    require(     userAmountStaked[token][msg.sender] &gt;= amountToShiftForThisToken,     "Outstanding next price stake shifts too great"   ); }  } /*   @notice Allows users to withdraw their entire stake for a token.   @param token Address of the token for which to withdraw.   /   function withdrawAll(address token) external {     ILongShort(longShort).updateSystemState(marketIndexOfToken[token]); uint32 marketIndex = marketIndexOfToken[token];  uint256 amountToShiftForThisToken = syntheticTokens[marketIndex][true] == token   ? userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][msg.sender]   : userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][msg.sender];  _withdraw(marketIndex, token, userAmountStaked[token][msg.sender] - amountToShiftForThisToken);  } } |
| **need_reflect** | False |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **phase_prompt** | Below are the details of our smart contract codes and their corresponding analysis reports: Task: "{task}". As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report. |
| **phase_name** | BugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 1, 'task': '', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-17-08 08:01:27 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: BUSL-1.1 pragma solidity 0.8.3; import "@openzeppelin/contracts-upgradeable/token/ERC20/presets/ERC20PresetMinterPauserUpgradeable.sol"; import "./interfaces/IFloatToken.sol"; import "./interfaces/ILongShort.sol"; import "./interfaces/IStaker.sol"; import "./interfaces/ISyntheticToken.sol"; contract Staker is IStaker, Initializable {   /╔═════════════════════════════╗     ║          VARIABLES          ║     ╚═════════════════════════════╝/ / ══════ Fixed-precision constants ══════ /   uint256 public constant FLOAT_ISSUANCE_FIXED_DECIMAL = 1e42;   // 2^52 ~= 4.5e15   // With an exponent of 5, the largest total liquidity possible in a market (to avoid integer overflow on exponentiation) is ~10^31 or 10 Trillion (10^13)   // NOTE: this also means if the total market value is less than 2^52 there will be a division by zero error   uint256 public constant safeExponentBitShifting = 52; / ══════ Global state ══════ /   address public admin;   address public floatCapital;   address public floatTreasury;   uint256 public floatPercentage; address public longShort;   address public floatToken; / ══════ Market specific ══════ /   mapping(uint32 =&gt; uint256) public marketLaunchIncentive_period; // seconds   mapping(uint32 =&gt; uint256) public marketLaunchIncentive_multipliers; // e18 scale   mapping(uint32 =&gt; uint256) public marketUnstakeFee_e18;   mapping(uint32 =&gt; uint256) public balanceIncentiveCurve_exponent;   mapping(uint32 =&gt; int256) public balanceIncentiveCurve_equilibriumOffset; mapping(uint32 =&gt; mapping(bool =&gt; address)) public syntheticTokens; mapping(address =&gt; uint32) public marketIndexOfToken; / ══════ Reward specific ══════ /   mapping(uint32 =&gt; uint256) public latestRewardIndex;   mapping(uint32 =&gt; mapping(uint256 =&gt; AccumulativeIssuancePerStakedSynthSnapshot))     public accumulativeFloatPerSyntheticTokenSnapshots;   struct AccumulativeIssuancePerStakedSynthSnapshot {     uint256 timestamp;     uint256 accumulativeFloatPerSyntheticToken_long;     uint256 accumulativeFloatPerSyntheticToken_short;   } / ══════ User specific ══════ /   mapping(uint32 =&gt; mapping(address =&gt; uint256)) public userIndexOfLastClaimedReward;   mapping(address =&gt; mapping(address =&gt; uint256)) public userAmountStaked; / ══════ Token shift management specific ══════ /   mapping(uint32 =&gt; uint256) public batched_stakerNextTokenShiftIndex;   /*   @notice Used to link a token shift to a staker state   @dev tokenShiftIndex =&gt; accumulativeFloatIssuanceSnapshotIndex     POSSIBLE OPTIMIZATION - could pack stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping and stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping into a struct of two uint128 for storage space optimization.   /   mapping(uint256 =&gt; uint256) public stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping;   /// @notice Used to fetch the price from LongShort at that point in time   /// @dev tokenShiftIndex =&gt; longShortMarketPriceSnapshotIndex   mapping(uint256 =&gt; uint256) public stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping;   /// @dev marketIndex =&gt; usersAddress =&gt; stakerTokenShiftIndex   mapping(uint32 =&gt; mapping(address =&gt; uint256)) public userNextPrice_stakedSyntheticTokenShiftIndex;   /// @dev marketIndex =&gt; usersAddress =&gt; amountUserRequestedToShiftAwayFromLongOnNextUpdate   mapping(uint32 =&gt; mapping(address =&gt; uint256)) public userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long;   /// @dev marketIndex =&gt; usersAddress =&gt; amountUserRequestedToShiftAwayFromShortOnNextUpdate   mapping(uint32 =&gt; mapping(address =&gt; uint256)) public userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short; /╔════════════════════════════╗     ║           EVENTS           ║     ╚════════════════════════════╝/ event StakerV1(     address admin,     address floatTreasury,     address floatCapital,     address floatToken,     uint256 floatPercentage   ); event MarketAddedToStaker(     uint32 marketIndex,     uint256 exitFee_e18,     uint256 period,     uint256 multiplier,     uint256 balanceIncentiveExponent,     int256 balanceIncentiveEquilibriumOffset   ); event AccumulativeIssuancePerStakedSynthSnapshotCreated(     uint32 marketIndex,     uint256 accumulativeFloatIssuanceSnapshotIndex,     uint256 accumulativeLong,     uint256 accumulativeShort   ); event StakeAdded(address user, address token, uint256 amount, uint256 lastMintIndex); event StakeWithdrawn(address user, address token, uint256 amount); // Note: the amountFloatMinted isn't strictly needed by the graph, but it is good to add it to validate calculations are accurate.   event FloatMinted(address user, uint32 marketIndex, uint256 amountFloatMinted); event MarketLaunchIncentiveParametersChanges(uint32 marketIndex, uint256 period, uint256 multiplier); event StakeWithdrawalFeeUpdated(uint32 marketIndex, uint256 stakeWithdralFee); event BalanceIncentiveExponentUpdated(uint32 marketIndex, uint256 balanceIncentiveExponent); event BalanceIncentiveEquilibriumOffsetUpdated(uint32 marketIndex, int256 balanceIncentiveEquilibriumOffset); event FloatPercentageUpdated(uint256 floatPercentage); event SyntheticTokensShifted(); event ChangeAdmin(address newAdmin); /╔═════════════════════════════╗     ║          MODIFIERS          ║     ╚═════════════════════════════╝/ function onlyAdminModifierLogic() internal virtual {     require(msg.sender == admin, "not admin");   } modifier onlyAdmin() {     onlyAdminModifierLogic();     _;   } function onlyValidSyntheticModifierLogic(address _synth) internal virtual {     require(marketIndexOfToken[_synth] != 0, "not valid synth");   } modifier onlyValidSynthetic(address synth) {     onlyValidSyntheticModifierLogic(_synth);     ;   } function onlyValidMarketModifierLogic(uint32 marketIndex) internal virtual {     require(address(syntheticTokens[marketIndex][true]) != address(0), "not valid market");   } modifier onlyValidMarket(uint32 marketIndex) {     onlyValidMarketModifierLogic(marketIndex);     _;   } function onlyLongShortModifierLogic() internal virtual {     require(msg.sender == address(longShort), "not long short");   } modifier onlyLongShort() {     onlyLongShortModifierLogic();     _;   } /╔═════════════════════════════╗     ║       CONTRACT SET-UP       ║     ╚═════════════════════════════╝/ /*   @notice Initializes the contract.   @dev Calls OpenZeppelin's initializer modifier.   @param _admin Address of the admin role.   @param _longShort Address of the LongShort contract, a deployed LongShort.sol   @param _floatToken Address of the Float token earned by staking.   @param _floatTreasury Address of the treasury contract for managing fees.   @param _floatCapital Address of the contract which earns a fixed percentage of Float.   @param _floatPercentage Determines the float percentage that gets minted for Float Capital, base 1e18.   /   function initialize(     address _admin,     address _longShort,     address _floatToken,     address _floatTreasury,     address _floatCapital,     uint256 _floatPercentage   ) external virtual initializer {     admin = _admin;     floatCapital = _floatCapital;     floatTreasury = _floatTreasury;     longShort = _longShort;     floatToken = _floatToken; _changeFloatPercentage(_floatPercentage);  emit StakerV1(_admin, _floatTreasury, _floatCapital, _floatToken, _floatPercentage);  } /╔═══════════════════╗     ║       ADMIN       ║     ╚═══════════════════╝/ /*    @notice Changes admin for the contract   @param _admin The address of the new admin.   /   function changeAdmin(address _admin) external onlyAdmin {     admin = _admin;     emit ChangeAdmin(_admin);   } /// @dev Logic for changeFloatPercentage   function _changeFloatPercentage(uint256 newFloatPercentage) internal virtual {     require(newFloatPercentage &lt;= 1e18 &amp;&amp; newFloatPercentage &gt; 0); // less than or equal to 100% and greater than 0%     floatPercentage = newFloatPercentage;   } /*   @notice Changes percentage of float that is minted for float capital.   @param newFloatPercentage The new float percentage in base 1e18.   /   function changeFloatPercentage(uint256 newFloatPercentage) external onlyAdmin {     _changeFloatPercentage(newFloatPercentage);     emit FloatPercentageUpdated(newFloatPercentage);   } /// @dev Logic for changeUnstakeFee   function _changeUnstakeFee(uint32 marketIndex, uint256 newMarketUnstakeFee_e18) internal virtual {     require(newMarketUnstakeFee_e18 &lt;= 5e16); // Explicitely stating 5% fee as the max fee possible.     marketUnstakeFee_e18[marketIndex] = newMarketUnstakeFee_e18;   } /*   @notice Changes unstake fee for a market   @param marketIndex Identifies the market.   @param newMarketUnstakeFee_e18 The new unstake fee.   /   function changeUnstakeFee(uint32 marketIndex, uint256 newMarketUnstakeFee_e18) external onlyAdmin {     _changeUnstakeFee(marketIndex, newMarketUnstakeFee_e18);     emit StakeWithdrawalFeeUpdated(marketIndex, newMarketUnstakeFee_e18);   } /// @dev Logic for changeMarketLaunchIncentiveParameters   function _changeMarketLaunchIncentiveParameters(     uint32 marketIndex,     uint256 period,     uint256 initialMultiplier   ) internal virtual {     require(initialMultiplier &gt;= 1e18, "marketLaunchIncentiveMultiplier must be &gt;= 1e18"); marketLaunchIncentive_period[marketIndex] = period; marketLaunchIncentive_multipliers[marketIndex] = initialMultiplier;  } /*   @notice Changes the market launch incentive parameters for a market   @param marketIndex Identifies the market.   @param period The new period for which float token generation should be boosted.   @param initialMultiplier The new multiplier on Float generation.   /   function changeMarketLaunchIncentiveParameters(     uint32 marketIndex,     uint256 period,     uint256 initialMultiplier   ) external onlyAdmin {     _changeMarketLaunchIncentiveParameters(marketIndex, period, initialMultiplier); emit MarketLaunchIncentiveParametersChanges(marketIndex, period, initialMultiplier);  } /// @dev Logic for changeBalanceIncentiveExponent   function _changeBalanceIncentiveExponent(uint32 marketIndex, uint256 _balanceIncentiveCurve_exponent)     internal     virtual   {     require(       // The exponent has to be less than 5 in these versions of the contracts.       _balanceIncentiveCurve_exponent &gt; 0 &amp;&amp; _balanceIncentiveCurve_exponent &lt; 6,       "balanceIncentiveCurve_exponent out of bounds"     ); balanceIncentiveCurve_exponent[marketIndex] = _balanceIncentiveCurve_exponent;  } /*    @notice Changes the balance incentive exponent for a market   @param marketIndex Identifies the market.   @param _balanceIncentiveCurve_exponent The new exponent for the curve.   /   function changeBalanceIncentiveExponent(uint32 marketIndex, uint256 _balanceIncentiveCurve_exponent)     external     onlyAdmin   {     _changeBalanceIncentiveExponent(marketIndex, _balanceIncentiveCurve_exponent); emit BalanceIncentiveExponentUpdated(marketIndex, _balanceIncentiveCurve_exponent);  } /// @dev Logic for changeBalanceIncentiveEquilibriumOffset   function _changeBalanceIncentiveEquilibriumOffset(uint32 marketIndex, int256 _balanceIncentiveCurve_equilibriumOffset)     internal     virtual   {     // Unreasonable that we would ever shift this more than 90% either way     require(       _balanceIncentiveCurve_equilibriumOffset &gt; -9e17 &amp;&amp; _balanceIncentiveCurve_equilibriumOffset &lt; 9e17,       "balanceIncentiveCurve_equilibriumOffset out of bounds"     ); balanceIncentiveCurve_equilibriumOffset[marketIndex] = _balanceIncentiveCurve_equilibriumOffset;  } /*   @notice Changes the balance incentive curve equilibrium offset for a market   @param marketIndex Identifies the market.   @param _balanceIncentiveCurve_equilibriumOffset The new offset.   /   function changeBalanceIncentiveEquilibriumOffset(uint32 marketIndex, int256 _balanceIncentiveCurve_equilibriumOffset)     external     onlyAdmin   {     _changeBalanceIncentiveEquilibriumOffset(marketIndex, _balanceIncentiveCurve_equilibriumOffset); emit BalanceIncentiveEquilibriumOffsetUpdated(marketIndex, _balanceIncentiveCurve_equilibriumOffset);  } /╔═════════════════════════════╗     ║        STAKING SETUP        ║     ╚═════════════════════════════╝/ /*   @notice Sets this contract to track staking for a market in LongShort.sol   @param marketIndex Identifies the market.   @param longToken Address of the long token for the market.   @param shortToken Address of the short token for the market.   @param kInitialMultiplier Initial boost on float generation for the market.   @param kPeriod Period which the boost should last.   @param unstakeFee_e18 Percentage of tokens that are levied on unstaking in base 1e18.   @param _balanceIncentiveCurve_exponent Exponent for balance curve (see _calculateFloatPerSecond)   @param _balanceIncentiveCurve_equilibriumOffset Offset for balance curve (see _calculateFloatPerSecond)   /   function addNewStakingFund(     uint32 marketIndex,     address longToken,     address shortToken,     uint256 kInitialMultiplier,     uint256 kPeriod,     uint256 unstakeFee_e18,     uint256 _balanceIncentiveCurve_exponent,     int256 _balanceIncentiveCurve_equilibriumOffset   ) external override onlyLongShort {     marketIndexOfToken[longToken] = marketIndex;     marketIndexOfToken[shortToken] = marketIndex; accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].timestamp = block.timestamp; accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].accumulativeFloatPerSyntheticToken_long = 0; accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].accumulativeFloatPerSyntheticToken_short = 0;  syntheticTokens[marketIndex][true] = longToken; syntheticTokens[marketIndex][false] = shortToken;  _changeBalanceIncentiveExponent(marketIndex, _balanceIncentiveCurve_exponent); _changeBalanceIncentiveEquilibriumOffset(marketIndex, _balanceIncentiveCurve_equilibriumOffset); _changeMarketLaunchIncentiveParameters(marketIndex, kPeriod, kInitialMultiplier);  _changeUnstakeFee(marketIndex, unstakeFee_e18);  // Set this value to one initially - 0 is a null value and thus potentially bug prone. batched_stakerNextTokenShiftIndex[marketIndex] = 1;  emit MarketAddedToStaker(   marketIndex,   unstakeFee_e18,   kPeriod,   kInitialMultiplier,   _balanceIncentiveCurve_exponent,   _balanceIncentiveCurve_equilibriumOffset );  emit AccumulativeIssuancePerStakedSynthSnapshotCreated(marketIndex, 0, 0, 0);  } /╔═════════════════════════════════════════════════════════════════════════╗     ║    GLOBAL FLT REWARD ACCUMULATION CALCULATION AND TRACKING FUNCTIONS    ║     ╚═════════════════════════════════════════════════════════════════════════╝/ /*   @notice Returns the K factor parameters for the given market with sensible   defaults if they haven't been set yet.   @param marketIndex The market to change the parameters for.   @return period The period for which the k factor applies for in seconds.   @return multiplier The multiplier on Float generation in this period.   /   function _getMarketLaunchIncentiveParameters(uint32 marketIndex)     internal     view     virtual     returns (uint256 period, uint256 multiplier)   {     period = marketLaunchIncentive_period[marketIndex];     multiplier = marketLaunchIncentive_multipliers[marketIndex]; if (multiplier &lt; 1e18) {   multiplier = 1e18; // multiplier of 1 by default }  } /*    @notice Returns the extent to which a markets float generation should be adjusted   based on the market's launch incentive parameters. Should start at multiplier   then linearly change to 1e18 over time.   @param marketIndex Identifies the market.   @return k The calculated modifier for float generation.   /   function _getKValue(uint32 marketIndex) internal view virtual returns (uint256) {     // Parameters controlling the float issuance multiplier.     (uint256 kPeriod, uint256 kInitialMultiplier) = _getMarketLaunchIncentiveParameters(marketIndex); // Sanity check - under normal circumstances, the multipliers should // *never* be set to a value &lt; 1e18, as there are guards against this. assert(kInitialMultiplier &gt;= 1e18);  uint256 initialTimestamp = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].timestamp;  if (block.timestamp - initialTimestamp &lt;= kPeriod) {   return kInitialMultiplier - (((kInitialMultiplier - 1e18) * (block.timestamp - initialTimestamp)) / kPeriod); } else {   return 1e18; }  } /   @notice Computes the number of float tokens a user earns per second for   every long/short synthetic token they've staked. The returned value has   a fixed decimal scale of 1e42 (!!!) for numerical stability. The return   values are float per second per synthetic token (hence the requirement   to multiply by price)   @dev to see below math in latex form see TODO add link   to interact with the equations see https://www.desmos.com/calculator/optkaxyihr   @param marketIndex The market referred to.   @param longPrice Price of the synthetic long token in units of payment token   @param shortPrice Price of the synthetic short token in units of payment token   @param longValue Amount of payment token in the long side of the market   @param shortValue Amount of payment token in the short side of the market   @return longFloatPerSecond Float token per second per long synthetic token   @return shortFloatPerSecond Float token per second per short synthetic token    /   function _calculateFloatPerSecond(     uint32 marketIndex,     uint256 longPrice,     uint256 shortPrice,     uint256 longValue,     uint256 shortValue   ) internal view virtual returns (uint256 longFloatPerSecond, uint256 shortFloatPerSecond) {     // A float issuance multiplier that starts high and decreases linearly     // over time to a value of 1. This incentivises users to stake early.     uint256 k = _getKValue(marketIndex); uint256 totalLocked = (longValue + shortValue);  // we need to scale this number by the totalLocked so that the offset remains consistent accross market size  int256 equilibriumOffsetMarketScaled = (balanceIncentiveCurve_equilibriumOffset[marketIndex] *   int256(totalLocked)) / 2e18;  uint256 denominator = ((totalLocked &gt;&gt; safeExponentBitShifting)**balanceIncentiveCurve_exponent[marketIndex]);  // Float is scaled by the percentage of the total market value held in // the opposite position. This incentivises users to stake on the // weaker position. if (int256(shortValue) - equilibriumOffsetMarketScaled &lt; int256(longValue)) {   if (equilibriumOffsetMarketScaled &gt;= int256(shortValue)) {     // edge case: imbalanced far past the equilibrium offset - full rewards go to short token     //            extremeley unlikely to happen in practice     return (0, 1e18 * k * shortPrice);   }    uint256 numerator = (uint256(int256(shortValue) - equilibriumOffsetMarketScaled) &gt;&gt;     (safeExponentBitShifting - 1))**balanceIncentiveCurve_exponent[marketIndex];    // NOTE: `x * 5e17` == `(x * 10e18) / 2`   uint256 longRewardUnscaled = (numerator * 5e17) / denominator;   uint256 shortRewardUnscaled = 1e18 - longRewardUnscaled;    return ((longRewardUnscaled * k * longPrice) / 1e18, (shortRewardUnscaled * k * shortPrice) / 1e18); } else {   if (-equilibriumOffsetMarketScaled &gt;= int256(longValue)) {     // edge case: imbalanced far past the equilibrium offset - full rewards go to long token     //            extremeley unlikely to happen in practice     return (1e18 * k * longPrice, 0);   }    uint256 numerator = (uint256(int256(longValue) + equilibriumOffsetMarketScaled) &gt;&gt;     (safeExponentBitShifting - 1))**balanceIncentiveCurve_exponent[marketIndex];    // NOTE: `x * 5e17` == `(x * 10e18) / 2`   uint256 shortRewardUnscaled = (numerator * 5e17) / denominator;   uint256 longRewardUnscaled = 1e18 - shortRewardUnscaled;    return ((longRewardUnscaled * k * longPrice) / 1e18, (shortRewardUnscaled * k * shortPrice) / 1e18); }  } /*   @notice Computes the time since last accumulativeIssuancePerStakedSynthSnapshot for the given market in seconds.   @param marketIndex The market referred to.   @return The time difference in seconds   /   function _calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(uint32 marketIndex)     internal     view     virtual     returns (uint256)   {     return       block.timestamp -       accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]].timestamp;   } /*   @notice Computes new cumulative sum of 'r' value since last accumulativeIssuancePerStakedSynthSnapshot. We use   cumulative 'r' value to avoid looping during issuance. Note that the   cumulative sum is kept in 1e42 scale (!!!) to avoid numerical issues.   @param shortValue The value locked in the short side of the market.   @param longValue The value locked in the long side of the market.   @param shortPrice The price of the short token as defined in LongShort.sol   @param longPrice The price of the long token as defined in LongShort.sol   @param marketIndex An identifier for the market.   @return longCumulativeRates The long cumulative sum.   @return shortCumulativeRates The short cumulative sum.   /   function _calculateNewCumulativeIssuancePerStakedSynth(     uint32 marketIndex,     uint256 longPrice,     uint256 shortPrice,     uint256 longValue,     uint256 shortValue   ) internal view virtual returns (uint256 longCumulativeRates, uint256 shortCumulativeRates) {     // Compute the current 'r' value for float issuance per second.     (uint256 longFloatPerSecond, uint256 shortFloatPerSecond) = _calculateFloatPerSecond(       marketIndex,       longPrice,       shortPrice,       longValue,       shortValue     ); // Compute time since last accumulativeIssuancePerStakedSynthSnapshot for the given token. uint256 timeDelta = _calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(marketIndex);  // Compute new cumulative 'r' value total. return (   accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]]   .accumulativeFloatPerSyntheticToken_long + (timeDelta * longFloatPerSecond),   accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]]   .accumulativeFloatPerSyntheticToken_short + (timeDelta * shortFloatPerSecond) );  } /*   @notice Creates a new accumulativeIssuancePerStakedSynthSnapshot for the given token and updates indexes.   @param shortValue The value locked in the short side of the market.   @param longValue The value locked in the long side of the market.   @param shortPrice The price of the short token as defined in LongShort.sol   @param longPrice The price of the long token as defined in LongShort.sol   @param marketIndex An identifier for the market.   /   function _setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot(     uint32 marketIndex,     uint256 longPrice,     uint256 shortPrice,     uint256 longValue,     uint256 shortValue   ) internal virtual {     (       uint256 newLongAccumulativeValue,       uint256 newShortAccumulativeValue     ) = _calculateNewCumulativeIssuancePerStakedSynth(marketIndex, longPrice, shortPrice, longValue, shortValue); uint256 newIndex = latestRewardIndex[marketIndex] + 1;  // Set cumulative 'r' value on new accumulativeIssuancePerStakedSynthSnapshot. accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex] .accumulativeFloatPerSyntheticToken_long = newLongAccumulativeValue; accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex] .accumulativeFloatPerSyntheticToken_short = newShortAccumulativeValue;  // Set timestamp on new accumulativeIssuancePerStakedSynthSnapshot. accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex].timestamp = block.timestamp;  // Update latest index to point to new accumulativeIssuancePerStakedSynthSnapshot. latestRewardIndex[marketIndex] = newIndex;  emit AccumulativeIssuancePerStakedSynthSnapshotCreated(   marketIndex,   newIndex,   newLongAccumulativeValue,   newShortAccumulativeValue );  } /*   @notice Adds new accumulativeIssuancePerStakedSynthSnapshots for the given long/short tokens. Called by the   ILongShort contract whenever there is a state change for a market.   @param stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted Mapping from this contract's shifts to LongShort.sols next price snapshots.   @param shortValue The value locked in the short side of the market.   @param longValue The value locked in the long side of the market.   @param shortPrice The price of the short token as defined in LongShort.sol   @param longPrice The price of the long token as defined in LongShort.sol   @param marketIndex An identifier for the market.   /   function pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(     uint32 marketIndex,     uint256 longPrice,     uint256 shortPrice,     uint256 longValue,     uint256 shortValue,     uint256 stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted // This value should be ALWAYS be zero if no shift occured   ) external override onlyLongShort {     // Only add a new accumulativeIssuancePerStakedSynthSnapshot if some time has passed. // the `stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted` value will be 0 if there is no staker related action in an executed batch if (stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted &gt; 0) {   stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[     batched_stakerNextTokenShiftIndex[marketIndex]   ] = stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted;   stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[     batched_stakerNextTokenShiftIndex[marketIndex]   ] = latestRewardIndex[marketIndex] + 1;   batched_stakerNextTokenShiftIndex[marketIndex] += 1;    emit SyntheticTokensShifted(); }  // Time delta is fetched twice in below code, can pass through? Which is less gas? if (_calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(marketIndex) &gt; 0) {   _setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot(     marketIndex,     longPrice,     shortPrice,     longValue,     shortValue   ); }  } /╔═══════════════════════════════════╗     ║    USER REWARD STATE FUNCTIONS    ║     ╚═══════════════════════════════════╝/ /// @dev Calculates the accumulated float in a specific range of staker snapshots   function _calculateAccumulatedFloatInRange(     uint32 marketIndex,     uint256 amountStakedLong,     uint256 amountStakedShort,     uint256 rewardIndexFrom,     uint256 rewardIndexTo   ) internal view virtual returns (uint256 floatReward) {     if (amountStakedLong &gt; 0) {       uint256 accumDeltaLong = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexTo]       .accumulativeFloatPerSyntheticToken_long -         accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexFrom]         .accumulativeFloatPerSyntheticToken_long;       floatReward += (accumDeltaLong * amountStakedLong) / FLOAT_ISSUANCE_FIXED_DECIMAL;     } if (amountStakedShort &gt; 0) {   uint256 accumDeltaShort = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexTo]   .accumulativeFloatPerSyntheticToken_short -     accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexFrom]     .accumulativeFloatPerSyntheticToken_short;   floatReward += (accumDeltaShort * amountStakedShort) / FLOAT_ISSUANCE_FIXED_DECIMAL; }  } /*    @notice Calculates float owed to the user since the user last minted float for a market.   @param marketIndex Identifier for the market which the user staked in.   @param user The address of the user.   @return floatReward The amount of float owed.    /   function _calculateAccumulatedFloat(uint32 marketIndex, address user) internal virtual returns (uint256 floatReward) {     address longToken = syntheticTokens[marketIndex][true];     address shortToken = syntheticTokens[marketIndex][false]; uint256 amountStakedLong = userAmountStaked[longToken][user]; uint256 amountStakedShort = userAmountStaked[shortToken][user];  uint256 usersLastRewardIndex = userIndexOfLastClaimedReward[marketIndex][user];  // Don't do the calculation and return zero immediately if there is no change if (usersLastRewardIndex == latestRewardIndex[marketIndex]) {   return 0; }  uint256 usersShiftIndex = userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][user]; // if there is a change in the users tokens held due to a token shift (or possibly another action in the future) if (usersShiftIndex &gt; 0 &amp;&amp; usersShiftIndex &lt; batched_stakerNextTokenShiftIndex[marketIndex]) {   floatReward = _calculateAccumulatedFloatInRange(     marketIndex,     amountStakedLong,     amountStakedShort,     usersLastRewardIndex,     stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[usersShiftIndex]   );    // Update the users balances   if (userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user] &gt; 0) {     amountStakedShort += ILongShort(longShort).getAmountSyntheticTokenToMintOnTargetSide(       marketIndex,       userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user],       true,       stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[usersShiftIndex]     );      amountStakedLong -= userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user];     userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user] = 0;   }    if (userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user] &gt; 0) {     amountStakedLong += ILongShort(longShort).getAmountSyntheticTokenToMintOnTargetSide(       marketIndex,       userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user],       false,       stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[usersShiftIndex]     );      amountStakedShort -= userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user];     userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user] = 0;   }    // Save the users updated staked amounts   userAmountStaked[longToken][user] = amountStakedLong;   userAmountStaked[shortToken][user] = amountStakedShort;    floatReward += _calculateAccumulatedFloatInRange(     marketIndex,     amountStakedLong,     amountStakedShort,     stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[usersShiftIndex],     latestRewardIndex[marketIndex]   );    userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][user] = 0; } else {   floatReward = _calculateAccumulatedFloatInRange(     marketIndex,     amountStakedLong,     amountStakedShort,     usersLastRewardIndex,     latestRewardIndex[marketIndex]   ); }  } /*   @notice Mints float for a user.   @dev Mints a fixed percentage for Float capital.   @param user The address of the user.   @param floatToMint The amount of float to mint.    /   function _mintFloat(address user, uint256 floatToMint) internal virtual {     IFloatToken(floatToken).mint(user, floatToMint);     IFloatToken(floatToken).mint(floatCapital, (floatToMint * floatPercentage) / 1e18);   } /*   @notice Mints float owed to a user for a market since they last minted.   @param marketIndex An identifier for the market.   @param user The address of the user.    /   function _mintAccumulatedFloat(uint32 marketIndex, address user) internal virtual {     uint256 floatToMint = _calculateAccumulatedFloat(marketIndex, user); if (floatToMint &gt; 0) {   // Set the user has claimed up until now, stops them setting this forward   userIndexOfLastClaimedReward[marketIndex][user] = latestRewardIndex[marketIndex];    _mintFloat(user, floatToMint);   emit FloatMinted(user, marketIndex, floatToMint); }  } /*   @notice Mints float owed to a user for multiple markets, since they last minted for those markets.   @param marketIndexes Identifiers for the markets.   @param user The address of the user.    /   function _mintAccumulatedFloatMulti(uint32[] calldata marketIndexes, address user) internal virtual {     uint256 floatTotal = 0;     for (uint256 i = 0; i &lt; marketIndexes.length; i++) {       uint256 floatToMint = _calculateAccumulatedFloat(marketIndexes[i], user);   if (floatToMint &gt; 0) {     // Set the user has claimed up until now, stops them setting this forward     userIndexOfLastClaimedReward[marketIndexes[i]][user] = latestRewardIndex[marketIndexes[i]];      floatTotal += floatToMint;      emit FloatMinted(user, marketIndexes[i], floatToMint);   } } if (floatTotal &gt; 0) {   _mintFloat(user, floatTotal); }  } /*   @notice Mints outstanding float for msg.sender.   @param marketIndexes Identifiers for the markets for which to mint float.    /   function claimFloatCustom(uint32[] calldata marketIndexes) external {     ILongShort(longShort).updateSystemStateMulti(marketIndexes);     _mintAccumulatedFloatMulti(marketIndexes, msg.sender);   } /*   @notice Mints outstanding float on behalf of another user.   @param marketIndexes Identifiers for the markets for which to mint float.   @param user The address of the user.    /   function claimFloatCustomFor(uint32[] calldata marketIndexes, address user) external {     // Unbounded loop - users are responsible for paying their own gas costs on these and it doesn't effect the rest of the system.     // No need to impose limit.     ILongShort(longShort).updateSystemStateMulti(marketIndexes);     _mintAccumulatedFloatMulti(marketIndexes, user);   } /╔═══════════════════════╗     ║        STAKING        ║     ╚═══════════════════════╝/ /*   @notice A user with synthetic tokens stakes by calling stake on the token   contract which calls this function. We need to first update the   state of the LongShort contract for this market before staking to correctly calculate user rewards.   @param amount Amount to stake.   @param from Address to stake for.   /   function stakeFromUser(address from, uint256 amount) public virtual override onlyValidSynthetic((msg.sender)) {     ILongShort(longShort).updateSystemState(marketIndexOfToken[(msg.sender)]);     _stake((msg.sender), amount, from);   } /*   @dev Internal logic for staking.   @param token Address of the token for which to stake.   @param amount Amount to stake.   @param user Address to stake for.   /   function _stake(     address token,     uint256 amount,     address user   ) internal virtual {     uint32 marketIndex = marketIndexOfToken[token]; // If they already have staked and have rewards due, mint these. if (   userIndexOfLastClaimedReward[marketIndex][user] != 0 &amp;&amp;   userIndexOfLastClaimedReward[marketIndex][user] &lt; latestRewardIndex[marketIndex] ) {   _mintAccumulatedFloat(marketIndex, user); }  userAmountStaked[token][user] = userAmountStaked[token][user] + amount;  userIndexOfLastClaimedReward[marketIndex][user] = latestRewardIndex[marketIndex];  emit StakeAdded(user, address(token), amount, userIndexOfLastClaimedReward[marketIndex][user]);  } /*   @notice Allows users to shift their staked tokens from one side of the market to    the other at the next price.   @param amountSyntheticTokensToShift Amount of tokens to shift.   @param marketIndex Identifier for the market.   @param isShiftFromLong Whether the shift is from long to short or short to long.   /   function shiftTokens(     uint256 amountSyntheticTokensToShift,     uint32 marketIndex,     bool isShiftFromLong   ) external virtual {     address token = syntheticTokens[marketIndex][isShiftFromLong];     require(userAmountStaked[token][msg.sender] &gt;= amountSyntheticTokensToShift, "Not enough tokens to shift"); // If the user has outstanding token shift that have already been confirmed in the LongShort // contract, execute them first. if (   userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] != 0 &amp;&amp;   userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] &lt;   batched_stakerNextTokenShiftIndex[marketIndex] ) {   _mintAccumulatedFloat(marketIndex, msg.sender); }  if (isShiftFromLong) {   ILongShort(longShort).shiftPositionFromLongNextPrice(marketIndex, amountSyntheticTokensToShift);   userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][     msg.sender   ] += amountSyntheticTokensToShift; } else {   ILongShort(longShort).shiftPositionFromShortNextPrice(marketIndex, amountSyntheticTokensToShift);   userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][     msg.sender   ] += amountSyntheticTokensToShift; }  userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] = batched_stakerNextTokenShiftIndex[   marketIndex ];  } /╔════════════════════════════╗     ║    WITHDRAWAL &amp; MINTING    ║     ╚════════════════════════════╝/ /*   @notice Internal logic for withdrawing stakes.   @dev Mint user any outstanding float before withdrawing.   @param marketIndex Market index of token.   @param amount Amount to withdraw.   @param token Synthetic token that was staked.   /   function _withdraw(     uint32 marketIndex,     address token,     uint256 amount   ) internal virtual {     require(userAmountStaked[token][msg.sender] &gt; 0, "nothing to withdraw");     _mintAccumulatedFloat(marketIndex, msg.sender); userAmountStaked[token][msg.sender] = userAmountStaked[token][msg.sender] - amount;  uint256 amountFees = (amount * marketUnstakeFee_e18[marketIndex]) / 1e18;  IERC20(token).transfer(floatTreasury, amountFees); IERC20(token).transfer(msg.sender, amount - amountFees);  emit StakeWithdrawn(msg.sender, token, amount);  } /*   @notice Withdraw function. Allows users to unstake.   @param amount Amount to withdraw.   @param token Address of the token for which to withdraw.   /   function withdraw(address token, uint256 amount) external {     ILongShort(longShort).updateSystemState(marketIndexOfToken[token]); uint32 marketIndex = marketIndexOfToken[token];  _withdraw(marketIndex, token, amount);  if (userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] &gt; 0) {   // If they still have outstanding shifts after minting float, then check   // that they don't withdraw more than their shifts allow.   uint256 amountToShiftForThisToken = syntheticTokens[marketIndex][true] == token     ? userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][msg.sender]     : userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][msg.sender];    require(     userAmountStaked[token][msg.sender] &gt;= amountToShiftForThisToken,     "Outstanding next price stake shifts too great"   ); }  } /*   @notice Allows users to withdraw their entire stake for a token.   @param token Address of the token for which to withdraw.   /   function withdrawAll(address token) external {     ILongShort(longShort).updateSystemState(marketIndexOfToken[token]); uint32 marketIndex = marketIndexOfToken[token];  uint256 amountToShiftForThisToken = syntheticTokens[marketIndex][true] == token   ? userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][msg.sender]   : userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][msg.sender];  _withdraw(marketIndex, token, userAmountStaked[token][msg.sender] - amountToShiftForThisToken);  } } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-17-08 08:01:27 INFO] Security Analyst: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: BUSL-1.1

pragma solidity 0.8.3;

import "@openzeppelin/contracts-upgradeable/token/ERC20/presets/ERC20PresetMinterPauserUpgradeable.sol";

import "./interfaces/IFloatToken.sol";
import "./interfaces/ILongShort.sol";
import "./interfaces/IStaker.sol";
import "./interfaces/ISyntheticToken.sol";

contract Staker is IStaker, Initializable {
  /*╔═════════════════════════════╗
    ║          VARIABLES          ║
    ╚═════════════════════════════╝*/

  /* ══════ Fixed-precision constants ══════ */
  uint256 public constant FLOAT_ISSUANCE_FIXED_DECIMAL = 1e42;
  // 2^52 ~= 4.5e15
  // With an exponent of 5, the largest total liquidity possible in a market (to avoid integer overflow on exponentiation) is ~10^31 or 10 Trillion (10^13)
  // NOTE: this also means if the total market value is less than 2^52 there will be a division by zero error
  uint256 public constant safeExponentBitShifting = 52;

  /* ══════ Global state ══════ */
  address public admin;
  address public floatCapital;
  address public floatTreasury;
  uint256 public floatPercentage;

  address public longShort;
  address public floatToken;

  /* ══════ Market specific ══════ */
  mapping(uint32 => uint256) public marketLaunchIncentive_period; // seconds
  mapping(uint32 => uint256) public marketLaunchIncentive_multipliers; // e18 scale
  mapping(uint32 => uint256) public marketUnstakeFee_e18;
  mapping(uint32 => uint256) public balanceIncentiveCurve_exponent;
  mapping(uint32 => int256) public balanceIncentiveCurve_equilibriumOffset;

  mapping(uint32 => mapping(bool => address)) public syntheticTokens;

  mapping(address => uint32) public marketIndexOfToken;

  /* ══════ Reward specific ══════ */
  mapping(uint32 => uint256) public latestRewardIndex;
  mapping(uint32 => mapping(uint256 => AccumulativeIssuancePerStakedSynthSnapshot))
    public accumulativeFloatPerSyntheticTokenSnapshots;
  struct AccumulativeIssuancePerStakedSynthSnapshot {
    uint256 timestamp;
    uint256 accumulativeFloatPerSyntheticToken_long;
    uint256 accumulativeFloatPerSyntheticToken_short;
  }

  /* ══════ User specific ══════ */
  mapping(uint32 => mapping(address => uint256)) public userIndexOfLastClaimedReward;
  mapping(address => mapping(address => uint256)) public userAmountStaked;

  /* ══════ Token shift management specific ══════ */
  mapping(uint32 => uint256) public batched_stakerNextTokenShiftIndex;
  /**
  @notice Used to link a token shift to a staker state
  @dev tokenShiftIndex => accumulativeFloatIssuanceSnapshotIndex
    POSSIBLE OPTIMIZATION - could pack stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping and stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping into a struct of two uint128 for storage space optimization.
  */
  mapping(uint256 => uint256) public stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping;
  /// @notice Used to fetch the price from LongShort at that point in time
  /// @dev tokenShiftIndex => longShortMarketPriceSnapshotIndex
  mapping(uint256 => uint256) public stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping;
  /// @dev marketIndex => usersAddress => stakerTokenShiftIndex
  mapping(uint32 => mapping(address => uint256)) public userNextPrice_stakedSyntheticTokenShiftIndex;
  /// @dev marketIndex => usersAddress => amountUserRequestedToShiftAwayFromLongOnNextUpdate
  mapping(uint32 => mapping(address => uint256)) public userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long;
  /// @dev marketIndex => usersAddress => amountUserRequestedToShiftAwayFromShortOnNextUpdate
  mapping(uint32 => mapping(address => uint256)) public userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short;

  /*╔════════════════════════════╗
    ║           EVENTS           ║
    ╚════════════════════════════╝*/

  event StakerV1(
    address admin,
    address floatTreasury,
    address floatCapital,
    address floatToken,
    uint256 floatPercentage
  );

  event MarketAddedToStaker(
    uint32 marketIndex,
    uint256 exitFee_e18,
    uint256 period,
    uint256 multiplier,
    uint256 balanceIncentiveExponent,
    int256 balanceIncentiveEquilibriumOffset
  );

  event AccumulativeIssuancePerStakedSynthSnapshotCreated(
    uint32 marketIndex,
    uint256 accumulativeFloatIssuanceSnapshotIndex,
    uint256 accumulativeLong,
    uint256 accumulativeShort
  );

  event StakeAdded(address user, address token, uint256 amount, uint256 lastMintIndex);

  event StakeWithdrawn(address user, address token, uint256 amount);

  // Note: the `amountFloatMinted` isn't strictly needed by the graph, but it is good to add it to validate calculations are accurate.
  event FloatMinted(address user, uint32 marketIndex, uint256 amountFloatMinted);

  event MarketLaunchIncentiveParametersChanges(uint32 marketIndex, uint256 period, uint256 multiplier);

  event StakeWithdrawalFeeUpdated(uint32 marketIndex, uint256 stakeWithdralFee);

  event BalanceIncentiveExponentUpdated(uint32 marketIndex, uint256 balanceIncentiveExponent);

  event BalanceIncentiveEquilibriumOffsetUpdated(uint32 marketIndex, int256 balanceIncentiveEquilibriumOffset);

  event FloatPercentageUpdated(uint256 floatPercentage);

  event SyntheticTokensShifted();

  event ChangeAdmin(address newAdmin);

  /*╔═════════════════════════════╗
    ║          MODIFIERS          ║
    ╚═════════════════════════════╝*/

  function onlyAdminModifierLogic() internal virtual {
    require(msg.sender == admin, "not admin");
  }

  modifier onlyAdmin() {
    onlyAdminModifierLogic();
    _;
  }

  function onlyValidSyntheticModifierLogic(address _synth) internal virtual {
    require(marketIndexOfToken[_synth] != 0, "not valid synth");
  }

  modifier onlyValidSynthetic(address _synth) {
    onlyValidSyntheticModifierLogic(_synth);
    _;
  }

  function onlyValidMarketModifierLogic(uint32 marketIndex) internal virtual {
    require(address(syntheticTokens[marketIndex][true]) != address(0), "not valid market");
  }

  modifier onlyValidMarket(uint32 marketIndex) {
    onlyValidMarketModifierLogic(marketIndex);
    _;
  }

  function onlyLongShortModifierLogic() internal virtual {
    require(msg.sender == address(longShort), "not long short");
  }

  modifier onlyLongShort() {
    onlyLongShortModifierLogic();
    _;
  }

  /*╔═════════════════════════════╗
    ║       CONTRACT SET-UP       ║
    ╚═════════════════════════════╝*/

  /**
  @notice Initializes the contract.
  @dev Calls OpenZeppelin's initializer modifier.
  @param _admin Address of the admin role.
  @param _longShort Address of the LongShort contract, a deployed LongShort.sol
  @param _floatToken Address of the Float token earned by staking.
  @param _floatTreasury Address of the treasury contract for managing fees.
  @param _floatCapital Address of the contract which earns a fixed percentage of Float.
  @param _floatPercentage Determines the float percentage that gets minted for Float Capital, base 1e18.
  */
  function initialize(
    address _admin,
    address _longShort,
    address _floatToken,
    address _floatTreasury,
    address _floatCapital,
    uint256 _floatPercentage
  ) external virtual initializer {
    admin = _admin;
    floatCapital = _floatCapital;
    floatTreasury = _floatTreasury;
    longShort = _longShort;
    floatToken = _floatToken;

    _changeFloatPercentage(_floatPercentage);

    emit StakerV1(_admin, _floatTreasury, _floatCapital, _floatToken, _floatPercentage);
  }

  /*╔═══════════════════╗
    ║       ADMIN       ║
    ╚═══════════════════╝*/

  /** 
  @notice Changes admin for the contract
  @param _admin The address of the new admin.
  */
  function changeAdmin(address _admin) external onlyAdmin {
    admin = _admin;
    emit ChangeAdmin(_admin);
  }

  /// @dev Logic for changeFloatPercentage
  function _changeFloatPercentage(uint256 newFloatPercentage) internal virtual {
    require(newFloatPercentage <= 1e18 && newFloatPercentage > 0); // less than or equal to 100% and greater than 0%
    floatPercentage = newFloatPercentage;
  }

  /**
  @notice Changes percentage of float that is minted for float capital.
  @param newFloatPercentage The new float percentage in base 1e18.
  */
  function changeFloatPercentage(uint256 newFloatPercentage) external onlyAdmin {
    _changeFloatPercentage(newFloatPercentage);
    emit FloatPercentageUpdated(newFloatPercentage);
  }

  /// @dev Logic for changeUnstakeFee
  function _changeUnstakeFee(uint32 marketIndex, uint256 newMarketUnstakeFee_e18) internal virtual {
    require(newMarketUnstakeFee_e18 <= 5e16); // Explicitely stating 5% fee as the max fee possible.
    marketUnstakeFee_e18[marketIndex] = newMarketUnstakeFee_e18;
  }

  /**
  @notice Changes unstake fee for a market
  @param marketIndex Identifies the market.
  @param newMarketUnstakeFee_e18 The new unstake fee.
  */
  function changeUnstakeFee(uint32 marketIndex, uint256 newMarketUnstakeFee_e18) external onlyAdmin {
    _changeUnstakeFee(marketIndex, newMarketUnstakeFee_e18);
    emit StakeWithdrawalFeeUpdated(marketIndex, newMarketUnstakeFee_e18);
  }

  /// @dev Logic for changeMarketLaunchIncentiveParameters
  function _changeMarketLaunchIncentiveParameters(
    uint32 marketIndex,
    uint256 period,
    uint256 initialMultiplier
  ) internal virtual {
    require(initialMultiplier >= 1e18, "marketLaunchIncentiveMultiplier must be >= 1e18");

    marketLaunchIncentive_period[marketIndex] = period;
    marketLaunchIncentive_multipliers[marketIndex] = initialMultiplier;
  }

  /**
  @notice Changes the market launch incentive parameters for a market
  @param marketIndex Identifies the market.
  @param period The new period for which float token generation should be boosted.
  @param initialMultiplier The new multiplier on Float generation.
  */
  function changeMarketLaunchIncentiveParameters(
    uint32 marketIndex,
    uint256 period,
    uint256 initialMultiplier
  ) external onlyAdmin {
    _changeMarketLaunchIncentiveParameters(marketIndex, period, initialMultiplier);

    emit MarketLaunchIncentiveParametersChanges(marketIndex, period, initialMultiplier);
  }

  /// @dev Logic for changeBalanceIncentiveExponent
  function _changeBalanceIncentiveExponent(uint32 marketIndex, uint256 _balanceIncentiveCurve_exponent)
    internal
    virtual
  {
    require(
      // The exponent has to be less than 5 in these versions of the contracts.
      _balanceIncentiveCurve_exponent > 0 && _balanceIncentiveCurve_exponent < 6,
      "balanceIncentiveCurve_exponent out of bounds"
    );

    balanceIncentiveCurve_exponent[marketIndex] = _balanceIncentiveCurve_exponent;
  }

  /** 
  @notice Changes the balance incentive exponent for a market
  @param marketIndex Identifies the market.
  @param _balanceIncentiveCurve_exponent The new exponent for the curve.
  */
  function changeBalanceIncentiveExponent(uint32 marketIndex, uint256 _balanceIncentiveCurve_exponent)
    external
    onlyAdmin
  {
    _changeBalanceIncentiveExponent(marketIndex, _balanceIncentiveCurve_exponent);

    emit BalanceIncentiveExponentUpdated(marketIndex, _balanceIncentiveCurve_exponent);
  }

  /// @dev Logic for changeBalanceIncentiveEquilibriumOffset
  function _changeBalanceIncentiveEquilibriumOffset(uint32 marketIndex, int256 _balanceIncentiveCurve_equilibriumOffset)
    internal
    virtual
  {
    // Unreasonable that we would ever shift this more than 90% either way
    require(
      _balanceIncentiveCurve_equilibriumOffset > -9e17 && _balanceIncentiveCurve_equilibriumOffset < 9e17,
      "balanceIncentiveCurve_equilibriumOffset out of bounds"
    );

    balanceIncentiveCurve_equilibriumOffset[marketIndex] = _balanceIncentiveCurve_equilibriumOffset;
  }

  /**
  @notice Changes the balance incentive curve equilibrium offset for a market
  @param marketIndex Identifies the market.
  @param _balanceIncentiveCurve_equilibriumOffset The new offset.
  */
  function changeBalanceIncentiveEquilibriumOffset(uint32 marketIndex, int256 _balanceIncentiveCurve_equilibriumOffset)
    external
    onlyAdmin
  {
    _changeBalanceIncentiveEquilibriumOffset(marketIndex, _balanceIncentiveCurve_equilibriumOffset);

    emit BalanceIncentiveEquilibriumOffsetUpdated(marketIndex, _balanceIncentiveCurve_equilibriumOffset);
  }

  /*╔═════════════════════════════╗
    ║        STAKING SETUP        ║
    ╚═════════════════════════════╝*/

  /**
  @notice Sets this contract to track staking for a market in LongShort.sol
  @param marketIndex Identifies the market.
  @param longToken Address of the long token for the market.
  @param shortToken Address of the short token for the market.
  @param kInitialMultiplier Initial boost on float generation for the market.
  @param kPeriod Period which the boost should last.
  @param unstakeFee_e18 Percentage of tokens that are levied on unstaking in base 1e18.
  @param _balanceIncentiveCurve_exponent Exponent for balance curve (see _calculateFloatPerSecond)
  @param _balanceIncentiveCurve_equilibriumOffset Offset for balance curve (see _calculateFloatPerSecond)
  */
  function addNewStakingFund(
    uint32 marketIndex,
    address longToken,
    address shortToken,
    uint256 kInitialMultiplier,
    uint256 kPeriod,
    uint256 unstakeFee_e18,
    uint256 _balanceIncentiveCurve_exponent,
    int256 _balanceIncentiveCurve_equilibriumOffset
  ) external override onlyLongShort {
    marketIndexOfToken[longToken] = marketIndex;
    marketIndexOfToken[shortToken] = marketIndex;

    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].timestamp = block.timestamp;
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].accumulativeFloatPerSyntheticToken_long = 0;
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].accumulativeFloatPerSyntheticToken_short = 0;

    syntheticTokens[marketIndex][true] = longToken;
    syntheticTokens[marketIndex][false] = shortToken;

    _changeBalanceIncentiveExponent(marketIndex, _balanceIncentiveCurve_exponent);
    _changeBalanceIncentiveEquilibriumOffset(marketIndex, _balanceIncentiveCurve_equilibriumOffset);
    _changeMarketLaunchIncentiveParameters(marketIndex, kPeriod, kInitialMultiplier);

    _changeUnstakeFee(marketIndex, unstakeFee_e18);

    // Set this value to one initially - 0 is a null value and thus potentially bug prone.
    batched_stakerNextTokenShiftIndex[marketIndex] = 1;

    emit MarketAddedToStaker(
      marketIndex,
      unstakeFee_e18,
      kPeriod,
      kInitialMultiplier,
      _balanceIncentiveCurve_exponent,
      _balanceIncentiveCurve_equilibriumOffset
    );

    emit AccumulativeIssuancePerStakedSynthSnapshotCreated(marketIndex, 0, 0, 0);
  }

  /*╔═════════════════════════════════════════════════════════════════════════╗
    ║    GLOBAL FLT REWARD ACCUMULATION CALCULATION AND TRACKING FUNCTIONS    ║
    ╚═════════════════════════════════════════════════════════════════════════╝*/

  /**
  @notice Returns the K factor parameters for the given market with sensible
  defaults if they haven't been set yet.
  @param marketIndex The market to change the parameters for.
  @return period The period for which the k factor applies for in seconds.
  @return multiplier The multiplier on Float generation in this period.
  */
  function _getMarketLaunchIncentiveParameters(uint32 marketIndex)
    internal
    view
    virtual
    returns (uint256 period, uint256 multiplier)
  {
    period = marketLaunchIncentive_period[marketIndex];
    multiplier = marketLaunchIncentive_multipliers[marketIndex];

    if (multiplier < 1e18) {
      multiplier = 1e18; // multiplier of 1 by default
    }
  }

  /** 
  @notice Returns the extent to which a markets float generation should be adjusted
  based on the market's launch incentive parameters. Should start at multiplier
  then linearly change to 1e18 over time.
  @param marketIndex Identifies the market.
  @return k The calculated modifier for float generation.
  */
  function _getKValue(uint32 marketIndex) internal view virtual returns (uint256) {
    // Parameters controlling the float issuance multiplier.
    (uint256 kPeriod, uint256 kInitialMultiplier) = _getMarketLaunchIncentiveParameters(marketIndex);

    // Sanity check - under normal circumstances, the multipliers should
    // *never* be set to a value < 1e18, as there are guards against this.
    assert(kInitialMultiplier >= 1e18);

    uint256 initialTimestamp = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].timestamp;

    if (block.timestamp - initialTimestamp <= kPeriod) {
      return kInitialMultiplier - (((kInitialMultiplier - 1e18) * (block.timestamp - initialTimestamp)) / kPeriod);
    } else {
      return 1e18;
    }
  }

  /*
  @notice Computes the number of float tokens a user earns per second for
  every long/short synthetic token they've staked. The returned value has
  a fixed decimal scale of 1e42 (!!!) for numerical stability. The return
  values are float per second per synthetic token (hence the requirement
  to multiply by price)
  @dev to see below math in latex form see TODO add link
  to interact with the equations see https://www.desmos.com/calculator/optkaxyihr
  @param marketIndex The market referred to.
  @param longPrice Price of the synthetic long token in units of payment token
  @param shortPrice Price of the synthetic short token in units of payment token
  @param longValue Amount of payment token in the long side of the market
  @param shortValue Amount of payment token in the short side of the market
  @return longFloatPerSecond Float token per second per long synthetic token
  @return shortFloatPerSecond Float token per second per short synthetic token
   */
  function _calculateFloatPerSecond(
    uint32 marketIndex,
    uint256 longPrice,
    uint256 shortPrice,
    uint256 longValue,
    uint256 shortValue
  ) internal view virtual returns (uint256 longFloatPerSecond, uint256 shortFloatPerSecond) {
    // A float issuance multiplier that starts high and decreases linearly
    // over time to a value of 1. This incentivises users to stake early.
    uint256 k = _getKValue(marketIndex);

    uint256 totalLocked = (longValue + shortValue);

    // we need to scale this number by the totalLocked so that the offset remains consistent accross market size

    int256 equilibriumOffsetMarketScaled = (balanceIncentiveCurve_equilibriumOffset[marketIndex] *
      int256(totalLocked)) / 2e18;

    uint256 denominator = ((totalLocked >> safeExponentBitShifting)**balanceIncentiveCurve_exponent[marketIndex]);

    // Float is scaled by the percentage of the total market value held in
    // the opposite position. This incentivises users to stake on the
    // weaker position.
    if (int256(shortValue) - equilibriumOffsetMarketScaled < int256(longValue)) {
      if (equilibriumOffsetMarketScaled >= int256(shortValue)) {
        // edge case: imbalanced far past the equilibrium offset - full rewards go to short token
        //            extremeley unlikely to happen in practice
        return (0, 1e18 * k * shortPrice);
      }

      uint256 numerator = (uint256(int256(shortValue) - equilibriumOffsetMarketScaled) >>
        (safeExponentBitShifting - 1))**balanceIncentiveCurve_exponent[marketIndex];

      // NOTE: `x * 5e17` == `(x * 10e18) / 2`
      uint256 longRewardUnscaled = (numerator * 5e17) / denominator;
      uint256 shortRewardUnscaled = 1e18 - longRewardUnscaled;

      return ((longRewardUnscaled * k * longPrice) / 1e18, (shortRewardUnscaled * k * shortPrice) / 1e18);
    } else {
      if (-equilibriumOffsetMarketScaled >= int256(longValue)) {
        // edge case: imbalanced far past the equilibrium offset - full rewards go to long token
        //            extremeley unlikely to happen in practice
        return (1e18 * k * longPrice, 0);
      }

      uint256 numerator = (uint256(int256(longValue) + equilibriumOffsetMarketScaled) >>
        (safeExponentBitShifting - 1))**balanceIncentiveCurve_exponent[marketIndex];

      // NOTE: `x * 5e17` == `(x * 10e18) / 2`
      uint256 shortRewardUnscaled = (numerator * 5e17) / denominator;
      uint256 longRewardUnscaled = 1e18 - shortRewardUnscaled;

      return ((longRewardUnscaled * k * longPrice) / 1e18, (shortRewardUnscaled * k * shortPrice) / 1e18);
    }
  }

  /**
  @notice Computes the time since last accumulativeIssuancePerStakedSynthSnapshot for the given market in seconds.
  @param marketIndex The market referred to.
  @return The time difference in seconds
  */
  function _calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(uint32 marketIndex)
    internal
    view
    virtual
    returns (uint256)
  {
    return
      block.timestamp -
      accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]].timestamp;
  }

  /**
  @notice Computes new cumulative sum of 'r' value since last accumulativeIssuancePerStakedSynthSnapshot. We use
  cumulative 'r' value to avoid looping during issuance. Note that the
  cumulative sum is kept in 1e42 scale (!!!) to avoid numerical issues.
  @param shortValue The value locked in the short side of the market.
  @param longValue The value locked in the long side of the market.
  @param shortPrice The price of the short token as defined in LongShort.sol
  @param longPrice The price of the long token as defined in LongShort.sol
  @param marketIndex An identifier for the market.
  @return longCumulativeRates The long cumulative sum.
  @return shortCumulativeRates The short cumulative sum.
  */
  function _calculateNewCumulativeIssuancePerStakedSynth(
    uint32 marketIndex,
    uint256 longPrice,
    uint256 shortPrice,
    uint256 longValue,
    uint256 shortValue
  ) internal view virtual returns (uint256 longCumulativeRates, uint256 shortCumulativeRates) {
    // Compute the current 'r' value for float issuance per second.
    (uint256 longFloatPerSecond, uint256 shortFloatPerSecond) = _calculateFloatPerSecond(
      marketIndex,
      longPrice,
      shortPrice,
      longValue,
      shortValue
    );

    // Compute time since last accumulativeIssuancePerStakedSynthSnapshot for the given token.
    uint256 timeDelta = _calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(marketIndex);

    // Compute new cumulative 'r' value total.
    return (
      accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]]
      .accumulativeFloatPerSyntheticToken_long + (timeDelta * longFloatPerSecond),
      accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]]
      .accumulativeFloatPerSyntheticToken_short + (timeDelta * shortFloatPerSecond)
    );
  }

  /**
  @notice Creates a new accumulativeIssuancePerStakedSynthSnapshot for the given token and updates indexes.
  @param shortValue The value locked in the short side of the market.
  @param longValue The value locked in the long side of the market.
  @param shortPrice The price of the short token as defined in LongShort.sol
  @param longPrice The price of the long token as defined in LongShort.sol
  @param marketIndex An identifier for the market.
  */
  function _setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot(
    uint32 marketIndex,
    uint256 longPrice,
    uint256 shortPrice,
    uint256 longValue,
    uint256 shortValue
  ) internal virtual {
    (
      uint256 newLongAccumulativeValue,
      uint256 newShortAccumulativeValue
    ) = _calculateNewCumulativeIssuancePerStakedSynth(marketIndex, longPrice, shortPrice, longValue, shortValue);

    uint256 newIndex = latestRewardIndex[marketIndex] + 1;

    // Set cumulative 'r' value on new accumulativeIssuancePerStakedSynthSnapshot.
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex]
    .accumulativeFloatPerSyntheticToken_long = newLongAccumulativeValue;
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex]
    .accumulativeFloatPerSyntheticToken_short = newShortAccumulativeValue;

    // Set timestamp on new accumulativeIssuancePerStakedSynthSnapshot.
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex].timestamp = block.timestamp;

    // Update latest index to point to new accumulativeIssuancePerStakedSynthSnapshot.
    latestRewardIndex[marketIndex] = newIndex;

    emit AccumulativeIssuancePerStakedSynthSnapshotCreated(
      marketIndex,
      newIndex,
      newLongAccumulativeValue,
      newShortAccumulativeValue
    );
  }

  /**
  @notice Adds new accumulativeIssuancePerStakedSynthSnapshots for the given long/short tokens. Called by the
  ILongShort contract whenever there is a state change for a market.
  @param stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted Mapping from this contract's shifts to LongShort.sols next price snapshots.
  @param shortValue The value locked in the short side of the market.
  @param longValue The value locked in the long side of the market.
  @param shortPrice The price of the short token as defined in LongShort.sol
  @param longPrice The price of the long token as defined in LongShort.sol
  @param marketIndex An identifier for the market.
  */
  function pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(
    uint32 marketIndex,
    uint256 longPrice,
    uint256 shortPrice,
    uint256 longValue,
    uint256 shortValue,
    uint256 stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted // This value should be ALWAYS be zero if no shift occured
  ) external override onlyLongShort {
    // Only add a new accumulativeIssuancePerStakedSynthSnapshot if some time has passed.

    // the `stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted` value will be 0 if there is no staker related action in an executed batch
    if (stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted > 0) {
      stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[
        batched_stakerNextTokenShiftIndex[marketIndex]
      ] = stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted;
      stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[
        batched_stakerNextTokenShiftIndex[marketIndex]
      ] = latestRewardIndex[marketIndex] + 1;
      batched_stakerNextTokenShiftIndex[marketIndex] += 1;

      emit SyntheticTokensShifted();
    }

    // Time delta is fetched twice in below code, can pass through? Which is less gas?
    if (_calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(marketIndex) > 0) {
      _setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot(
        marketIndex,
        longPrice,
        shortPrice,
        longValue,
        shortValue
      );
    }
  }

  /*╔═══════════════════════════════════╗
    ║    USER REWARD STATE FUNCTIONS    ║
    ╚═══════════════════════════════════╝*/

  /// @dev Calculates the accumulated float in a specific range of staker snapshots
  function _calculateAccumulatedFloatInRange(
    uint32 marketIndex,
    uint256 amountStakedLong,
    uint256 amountStakedShort,
    uint256 rewardIndexFrom,
    uint256 rewardIndexTo
  ) internal view virtual returns (uint256 floatReward) {
    if (amountStakedLong > 0) {
      uint256 accumDeltaLong = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexTo]
      .accumulativeFloatPerSyntheticToken_long -
        accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexFrom]
        .accumulativeFloatPerSyntheticToken_long;
      floatReward += (accumDeltaLong * amountStakedLong) / FLOAT_ISSUANCE_FIXED_DECIMAL;
    }

    if (amountStakedShort > 0) {
      uint256 accumDeltaShort = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexTo]
      .accumulativeFloatPerSyntheticToken_short -
        accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexFrom]
        .accumulativeFloatPerSyntheticToken_short;
      floatReward += (accumDeltaShort * amountStakedShort) / FLOAT_ISSUANCE_FIXED_DECIMAL;
    }
  }

  /** 
  @notice Calculates float owed to the user since the user last minted float for a market.
  @param marketIndex Identifier for the market which the user staked in.
  @param user The address of the user.
  @return floatReward The amount of float owed.
   */
  function _calculateAccumulatedFloat(uint32 marketIndex, address user) internal virtual returns (uint256 floatReward) {
    address longToken = syntheticTokens[marketIndex][true];
    address shortToken = syntheticTokens[marketIndex][false];

    uint256 amountStakedLong = userAmountStaked[longToken][user];
    uint256 amountStakedShort = userAmountStaked[shortToken][user];

    uint256 usersLastRewardIndex = userIndexOfLastClaimedReward[marketIndex][user];

    // Don't do the calculation and return zero immediately if there is no change
    if (usersLastRewardIndex == latestRewardIndex[marketIndex]) {
      return 0;
    }

    uint256 usersShiftIndex = userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][user];
    // if there is a change in the users tokens held due to a token shift (or possibly another action in the future)
    if (usersShiftIndex > 0 && usersShiftIndex < batched_stakerNextTokenShiftIndex[marketIndex]) {
      floatReward = _calculateAccumulatedFloatInRange(
        marketIndex,
        amountStakedLong,
        amountStakedShort,
        usersLastRewardIndex,
        stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[usersShiftIndex]
      );

      // Update the users balances
      if (userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user] > 0) {
        amountStakedShort += ILongShort(longShort).getAmountSyntheticTokenToMintOnTargetSide(
          marketIndex,
          userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user],
          true,
          stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[usersShiftIndex]
        );

        amountStakedLong -= userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user];
        userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user] = 0;
      }

      if (userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user] > 0) {
        amountStakedLong += ILongShort(longShort).getAmountSyntheticTokenToMintOnTargetSide(
          marketIndex,
          userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user],
          false,
          stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[usersShiftIndex]
        );

        amountStakedShort -= userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user];
        userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user] = 0;
      }

      // Save the users updated staked amounts
      userAmountStaked[longToken][user] = amountStakedLong;
      userAmountStaked[shortToken][user] = amountStakedShort;

      floatReward += _calculateAccumulatedFloatInRange(
        marketIndex,
        amountStakedLong,
        amountStakedShort,
        stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[usersShiftIndex],
        latestRewardIndex[marketIndex]
      );

      userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][user] = 0;
    } else {
      floatReward = _calculateAccumulatedFloatInRange(
        marketIndex,
        amountStakedLong,
        amountStakedShort,
        usersLastRewardIndex,
        latestRewardIndex[marketIndex]
      );
    }
  }

  /**
  @notice Mints float for a user.
  @dev Mints a fixed percentage for Float capital.
  @param user The address of the user.
  @param floatToMint The amount of float to mint.
   */
  function _mintFloat(address user, uint256 floatToMint) internal virtual {
    IFloatToken(floatToken).mint(user, floatToMint);
    IFloatToken(floatToken).mint(floatCapital, (floatToMint * floatPercentage) / 1e18);
  }

  /**
  @notice Mints float owed to a user for a market since they last minted.
  @param marketIndex An identifier for the market.
  @param user The address of the user.
   */
  function _mintAccumulatedFloat(uint32 marketIndex, address user) internal virtual {
    uint256 floatToMint = _calculateAccumulatedFloat(marketIndex, user);

    if (floatToMint > 0) {
      // Set the user has claimed up until now, stops them setting this forward
      userIndexOfLastClaimedReward[marketIndex][user] = latestRewardIndex[marketIndex];

      _mintFloat(user, floatToMint);
      emit FloatMinted(user, marketIndex, floatToMint);
    }
  }

  /**
  @notice Mints float owed to a user for multiple markets, since they last minted for those markets.
  @param marketIndexes Identifiers for the markets.
  @param user The address of the user.
   */
  function _mintAccumulatedFloatMulti(uint32[] calldata marketIndexes, address user) internal virtual {
    uint256 floatTotal = 0;
    for (uint256 i = 0; i < marketIndexes.length; i++) {
      uint256 floatToMint = _calculateAccumulatedFloat(marketIndexes[i], user);

      if (floatToMint > 0) {
        // Set the user has claimed up until now, stops them setting this forward
        userIndexOfLastClaimedReward[marketIndexes[i]][user] = latestRewardIndex[marketIndexes[i]];

        floatTotal += floatToMint;

        emit FloatMinted(user, marketIndexes[i], floatToMint);
      }
    }
    if (floatTotal > 0) {
      _mintFloat(user, floatTotal);
    }
  }

  /**
  @notice Mints outstanding float for msg.sender.
  @param marketIndexes Identifiers for the markets for which to mint float.
   */
  function claimFloatCustom(uint32[] calldata marketIndexes) external {
    ILongShort(longShort).updateSystemStateMulti(marketIndexes);
    _mintAccumulatedFloatMulti(marketIndexes, msg.sender);
  }

  /**
  @notice Mints outstanding float on behalf of another user.
  @param marketIndexes Identifiers for the markets for which to mint float.
  @param user The address of the user.
   */
  function claimFloatCustomFor(uint32[] calldata marketIndexes, address user) external {
    // Unbounded loop - users are responsible for paying their own gas costs on these and it doesn't effect the rest of the system.
    // No need to impose limit.
    ILongShort(longShort).updateSystemStateMulti(marketIndexes);
    _mintAccumulatedFloatMulti(marketIndexes, user);
  }

  /*╔═══════════════════════╗
    ║        STAKING        ║
    ╚═══════════════════════╝*/

  /**
  @notice A user with synthetic tokens stakes by calling stake on the token
  contract which calls this function. We need to first update the
  state of the LongShort contract for this market before staking to correctly calculate user rewards.
  @param amount Amount to stake.
  @param from Address to stake for.
  */
  function stakeFromUser(address from, uint256 amount) public virtual override onlyValidSynthetic((msg.sender)) {
    ILongShort(longShort).updateSystemState(marketIndexOfToken[(msg.sender)]);
    _stake((msg.sender), amount, from);
  }

  /**
  @dev Internal logic for staking.
  @param token Address of the token for which to stake.
  @param amount Amount to stake.
  @param user Address to stake for.
  */
  function _stake(
    address token,
    uint256 amount,
    address user
  ) internal virtual {
    uint32 marketIndex = marketIndexOfToken[token];

    // If they already have staked and have rewards due, mint these.
    if (
      userIndexOfLastClaimedReward[marketIndex][user] != 0 &&
      userIndexOfLastClaimedReward[marketIndex][user] < latestRewardIndex[marketIndex]
    ) {
      _mintAccumulatedFloat(marketIndex, user);
    }

    userAmountStaked[token][user] = userAmountStaked[token][user] + amount;

    userIndexOfLastClaimedReward[marketIndex][user] = latestRewardIndex[marketIndex];

    emit StakeAdded(user, address(token), amount, userIndexOfLastClaimedReward[marketIndex][user]);
  }

  /**
  @notice Allows users to shift their staked tokens from one side of the market to 
  the other at the next price.
  @param amountSyntheticTokensToShift Amount of tokens to shift.
  @param marketIndex Identifier for the market.
  @param isShiftFromLong Whether the shift is from long to short or short to long.
  */
  function shiftTokens(
    uint256 amountSyntheticTokensToShift,
    uint32 marketIndex,
    bool isShiftFromLong
  ) external virtual {
    address token = syntheticTokens[marketIndex][isShiftFromLong];
    require(userAmountStaked[token][msg.sender] >= amountSyntheticTokensToShift, "Not enough tokens to shift");

    // If the user has outstanding token shift that have already been confirmed in the LongShort
    // contract, execute them first.
    if (
      userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] != 0 &&
      userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] <
      batched_stakerNextTokenShiftIndex[marketIndex]
    ) {
      _mintAccumulatedFloat(marketIndex, msg.sender);
    }

    if (isShiftFromLong) {
      ILongShort(longShort).shiftPositionFromLongNextPrice(marketIndex, amountSyntheticTokensToShift);
      userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][
        msg.sender
      ] += amountSyntheticTokensToShift;
    } else {
      ILongShort(longShort).shiftPositionFromShortNextPrice(marketIndex, amountSyntheticTokensToShift);
      userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][
        msg.sender
      ] += amountSyntheticTokensToShift;
    }

    userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] = batched_stakerNextTokenShiftIndex[
      marketIndex
    ];
  }

  /*╔════════════════════════════╗
    ║    WITHDRAWAL & MINTING    ║
    ╚════════════════════════════╝*/

  /**
  @notice Internal logic for withdrawing stakes.
  @dev Mint user any outstanding float before withdrawing.
  @param marketIndex Market index of token.
  @param amount Amount to withdraw.
  @param token Synthetic token that was staked.
  */
  function _withdraw(
    uint32 marketIndex,
    address token,
    uint256 amount
  ) internal virtual {
    require(userAmountStaked[token][msg.sender] > 0, "nothing to withdraw");
    _mintAccumulatedFloat(marketIndex, msg.sender);

    userAmountStaked[token][msg.sender] = userAmountStaked[token][msg.sender] - amount;

    uint256 amountFees = (amount * marketUnstakeFee_e18[marketIndex]) / 1e18;

    IERC20(token).transfer(floatTreasury, amountFees);
    IERC20(token).transfer(msg.sender, amount - amountFees);

    emit StakeWithdrawn(msg.sender, token, amount);
  }

  /**
  @notice Withdraw function. Allows users to unstake.
  @param amount Amount to withdraw.
  @param token Address of the token for which to withdraw.
  */
  function withdraw(address token, uint256 amount) external {
    ILongShort(longShort).updateSystemState(marketIndexOfToken[token]);

    uint32 marketIndex = marketIndexOfToken[token];

    _withdraw(marketIndex, token, amount);

    if (userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] > 0) {
      // If they still have outstanding shifts after minting float, then check
      // that they don't withdraw more than their shifts allow.
      uint256 amountToShiftForThisToken = syntheticTokens[marketIndex][true] == token
        ? userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][msg.sender]
        : userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][msg.sender];

      require(
        userAmountStaked[token][msg.sender] >= amountToShiftForThisToken,
        "Outstanding next price stake shifts too great"
      );
    }
  }

  /**
  @notice Allows users to withdraw their entire stake for a token.
  @param token Address of the token for which to withdraw.
  */
  function withdrawAll(address token) external {
    ILongShort(longShort).updateSystemState(marketIndexOfToken[token]);

    uint32 marketIndex = marketIndexOfToken[token];

    uint256 amountToShiftForThisToken = syntheticTokens[marketIndex][true] == token
      ? userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][msg.sender]
      : userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][msg.sender];

    _withdraw(marketIndex, token, userAmountStaked[token][msg.sender] - amountToShiftForThisToken);
  }
}
.]

Below are the details of our smart contract codes and their corresponding analysis reports:
Task: "".
As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report.

[2024-17-08 08:01:40 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-17-08 08:01:40 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 9868
completion_tokens: 843
total_tokens: 10711
cost: $-1.000000


[2024-17-08 08:01:40 INFO] Solidity Programming Expert: **Solidity Programming Expert<->Security Analyst on : BugsSummary, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: BUSL-1.1

pragma solidity 0.8.3;

import "@openzeppelin/contracts-upgradeable/token/ERC20/presets/ERC20PresetMinterPauserUpgradeable.sol";

import "./interfaces/IFloatToken.sol";
import "./interfaces/ILongShort.sol";
import "./interfaces/IStaker.sol";
import "./interfaces/ISyntheticToken.sol";

contract Staker is IStaker, Initializable {
  /*╔═════════════════════════════╗
    ║          VARIABLES          ║
    ╚═════════════════════════════╝*/

  /* ══════ Fixed-precision constants ══════ */
  uint256 public constant FLOAT_ISSUANCE_FIXED_DECIMAL = 1e42;
  // 2^52 ~= 4.5e15
  // With an exponent of 5, the largest total liquidity possible in a market (to avoid integer overflow on exponentiation) is ~10^31 or 10 Trillion (10^13)
  // NOTE: this also means if the total market value is less than 2^52 there will be a division by zero error
  uint256 public constant safeExponentBitShifting = 52;

  /* ══════ Global state ══════ */
  address public admin;
  address public floatCapital;
  address public floatTreasury;
  uint256 public floatPercentage;

  address public longShort;
  address public floatToken;

  /* ══════ Market specific ══════ */
  mapping(uint32 => uint256) public marketLaunchIncentive_period; // seconds
  mapping(uint32 => uint256) public marketLaunchIncentive_multipliers; // e18 scale
  mapping(uint32 => uint256) public marketUnstakeFee_e18;
  mapping(uint32 => uint256) public balanceIncentiveCurve_exponent;
  mapping(uint32 => int256) public balanceIncentiveCurve_equilibriumOffset;

  mapping(uint32 => mapping(bool => address)) public syntheticTokens;

  mapping(address => uint32) public marketIndexOfToken;

  /* ══════ Reward specific ══════ */
  mapping(uint32 => uint256) public latestRewardIndex;
  mapping(uint32 => mapping(uint256 => AccumulativeIssuancePerStakedSynthSnapshot))
    public accumulativeFloatPerSyntheticTokenSnapshots;
  struct AccumulativeIssuancePerStakedSynthSnapshot {
    uint256 timestamp;
    uint256 accumulativeFloatPerSyntheticToken_long;
    uint256 accumulativeFloatPerSyntheticToken_short;
  }

  /* ══════ User specific ══════ */
  mapping(uint32 => mapping(address => uint256)) public userIndexOfLastClaimedReward;
  mapping(address => mapping(address => uint256)) public userAmountStaked;

  /* ══════ Token shift management specific ══════ */
  mapping(uint32 => uint256) public batched_stakerNextTokenShiftIndex;
  /**
  @notice Used to link a token shift to a staker state
  @dev tokenShiftIndex => accumulativeFloatIssuanceSnapshotIndex
    POSSIBLE OPTIMIZATION - could pack stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping and stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping into a struct of two uint128 for storage space optimization.
  */
  mapping(uint256 => uint256) public stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping;
  /// @notice Used to fetch the price from LongShort at that point in time
  /// @dev tokenShiftIndex => longShortMarketPriceSnapshotIndex
  mapping(uint256 => uint256) public stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping;
  /// @dev marketIndex => usersAddress => stakerTokenShiftIndex
  mapping(uint32 => mapping(address => uint256)) public userNextPrice_stakedSyntheticTokenShiftIndex;
  /// @dev marketIndex => usersAddress => amountUserRequestedToShiftAwayFromLongOnNextUpdate
  mapping(uint32 => mapping(address => uint256)) public userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long;
  /// @dev marketIndex => usersAddress => amountUserRequestedToShiftAwayFromShortOnNextUpdate
  mapping(uint32 => mapping(address => uint256)) public userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short;

  /*╔════════════════════════════╗
    ║           EVENTS           ║
    ╚════════════════════════════╝*/

  event StakerV1(
    address admin,
    address floatTreasury,
    address floatCapital,
    address floatToken,
    uint256 floatPercentage
  );

  event MarketAddedToStaker(
    uint32 marketIndex,
    uint256 exitFee_e18,
    uint256 period,
    uint256 multiplier,
    uint256 balanceIncentiveExponent,
    int256 balanceIncentiveEquilibriumOffset
  );

  event AccumulativeIssuancePerStakedSynthSnapshotCreated(
    uint32 marketIndex,
    uint256 accumulativeFloatIssuanceSnapshotIndex,
    uint256 accumulativeLong,
    uint256 accumulativeShort
  );

  event StakeAdded(address user, address token, uint256 amount, uint256 lastMintIndex);

  event StakeWithdrawn(address user, address token, uint256 amount);

  // Note: the `amountFloatMinted` isn't strictly needed by the graph, but it is good to add it to validate calculations are accurate.
  event FloatMinted(address user, uint32 marketIndex, uint256 amountFloatMinted);

  event MarketLaunchIncentiveParametersChanges(uint32 marketIndex, uint256 period, uint256 multiplier);

  event StakeWithdrawalFeeUpdated(uint32 marketIndex, uint256 stakeWithdralFee);

  event BalanceIncentiveExponentUpdated(uint32 marketIndex, uint256 balanceIncentiveExponent);

  event BalanceIncentiveEquilibriumOffsetUpdated(uint32 marketIndex, int256 balanceIncentiveEquilibriumOffset);

  event FloatPercentageUpdated(uint256 floatPercentage);

  event SyntheticTokensShifted();

  event ChangeAdmin(address newAdmin);

  /*╔═════════════════════════════╗
    ║          MODIFIERS          ║
    ╚═════════════════════════════╝*/

  function onlyAdminModifierLogic() internal virtual {
    require(msg.sender == admin, "not admin");
  }

  modifier onlyAdmin() {
    onlyAdminModifierLogic();
    _;
  }

  function onlyValidSyntheticModifierLogic(address _synth) internal virtual {
    require(marketIndexOfToken[_synth] != 0, "not valid synth");
  }

  modifier onlyValidSynthetic(address _synth) {
    onlyValidSyntheticModifierLogic(_synth);
    _;
  }

  function onlyValidMarketModifierLogic(uint32 marketIndex) internal virtual {
    require(address(syntheticTokens[marketIndex][true]) != address(0), "not valid market");
  }

  modifier onlyValidMarket(uint32 marketIndex) {
    onlyValidMarketModifierLogic(marketIndex);
    _;
  }

  function onlyLongShortModifierLogic() internal virtual {
    require(msg.sender == address(longShort), "not long short");
  }

  modifier onlyLongShort() {
    onlyLongShortModifierLogic();
    _;
  }

  /*╔═════════════════════════════╗
    ║       CONTRACT SET-UP       ║
    ╚═════════════════════════════╝*/

  /**
  @notice Initializes the contract.
  @dev Calls OpenZeppelin's initializer modifier.
  @param _admin Address of the admin role.
  @param _longShort Address of the LongShort contract, a deployed LongShort.sol
  @param _floatToken Address of the Float token earned by staking.
  @param _floatTreasury Address of the treasury contract for managing fees.
  @param _floatCapital Address of the contract which earns a fixed percentage of Float.
  @param _floatPercentage Determines the float percentage that gets minted for Float Capital, base 1e18.
  */
  function initialize(
    address _admin,
    address _longShort,
    address _floatToken,
    address _floatTreasury,
    address _floatCapital,
    uint256 _floatPercentage
  ) external virtual initializer {
    admin = _admin;
    floatCapital = _floatCapital;
    floatTreasury = _floatTreasury;
    longShort = _longShort;
    floatToken = _floatToken;

    _changeFloatPercentage(_floatPercentage);

    emit StakerV1(_admin, _floatTreasury, _floatCapital, _floatToken, _floatPercentage);
  }

  /*╔═══════════════════╗
    ║       ADMIN       ║
    ╚═══════════════════╝*/

  /** 
  @notice Changes admin for the contract
  @param _admin The address of the new admin.
  */
  function changeAdmin(address _admin) external onlyAdmin {
    admin = _admin;
    emit ChangeAdmin(_admin);
  }

  /// @dev Logic for changeFloatPercentage
  function _changeFloatPercentage(uint256 newFloatPercentage) internal virtual {
    require(newFloatPercentage <= 1e18 && newFloatPercentage > 0); // less than or equal to 100% and greater than 0%
    floatPercentage = newFloatPercentage;
  }

  /**
  @notice Changes percentage of float that is minted for float capital.
  @param newFloatPercentage The new float percentage in base 1e18.
  */
  function changeFloatPercentage(uint256 newFloatPercentage) external onlyAdmin {
    _changeFloatPercentage(newFloatPercentage);
    emit FloatPercentageUpdated(newFloatPercentage);
  }

  /// @dev Logic for changeUnstakeFee
  function _changeUnstakeFee(uint32 marketIndex, uint256 newMarketUnstakeFee_e18) internal virtual {
    require(newMarketUnstakeFee_e18 <= 5e16); // Explicitely stating 5% fee as the max fee possible.
    marketUnstakeFee_e18[marketIndex] = newMarketUnstakeFee_e18;
  }

  /**
  @notice Changes unstake fee for a market
  @param marketIndex Identifies the market.
  @param newMarketUnstakeFee_e18 The new unstake fee.
  */
  function changeUnstakeFee(uint32 marketIndex, uint256 newMarketUnstakeFee_e18) external onlyAdmin {
    _changeUnstakeFee(marketIndex, newMarketUnstakeFee_e18);
    emit StakeWithdrawalFeeUpdated(marketIndex, newMarketUnstakeFee_e18);
  }

  /// @dev Logic for changeMarketLaunchIncentiveParameters
  function _changeMarketLaunchIncentiveParameters(
    uint32 marketIndex,
    uint256 period,
    uint256 initialMultiplier
  ) internal virtual {
    require(initialMultiplier >= 1e18, "marketLaunchIncentiveMultiplier must be >= 1e18");

    marketLaunchIncentive_period[marketIndex] = period;
    marketLaunchIncentive_multipliers[marketIndex] = initialMultiplier;
  }

  /**
  @notice Changes the market launch incentive parameters for a market
  @param marketIndex Identifies the market.
  @param period The new period for which float token generation should be boosted.
  @param initialMultiplier The new multiplier on Float generation.
  */
  function changeMarketLaunchIncentiveParameters(
    uint32 marketIndex,
    uint256 period,
    uint256 initialMultiplier
  ) external onlyAdmin {
    _changeMarketLaunchIncentiveParameters(marketIndex, period, initialMultiplier);

    emit MarketLaunchIncentiveParametersChanges(marketIndex, period, initialMultiplier);
  }

  /// @dev Logic for changeBalanceIncentiveExponent
  function _changeBalanceIncentiveExponent(uint32 marketIndex, uint256 _balanceIncentiveCurve_exponent)
    internal
    virtual
  {
    require(
      // The exponent has to be less than 5 in these versions of the contracts.
      _balanceIncentiveCurve_exponent > 0 && _balanceIncentiveCurve_exponent < 6,
      "balanceIncentiveCurve_exponent out of bounds"
    );

    balanceIncentiveCurve_exponent[marketIndex] = _balanceIncentiveCurve_exponent;
  }

  /** 
  @notice Changes the balance incentive exponent for a market
  @param marketIndex Identifies the market.
  @param _balanceIncentiveCurve_exponent The new exponent for the curve.
  */
  function changeBalanceIncentiveExponent(uint32 marketIndex, uint256 _balanceIncentiveCurve_exponent)
    external
    onlyAdmin
  {
    _changeBalanceIncentiveExponent(marketIndex, _balanceIncentiveCurve_exponent);

    emit BalanceIncentiveExponentUpdated(marketIndex, _balanceIncentiveCurve_exponent);
  }

  /// @dev Logic for changeBalanceIncentiveEquilibriumOffset
  function _changeBalanceIncentiveEquilibriumOffset(uint32 marketIndex, int256 _balanceIncentiveCurve_equilibriumOffset)
    internal
    virtual
  {
    // Unreasonable that we would ever shift this more than 90% either way
    require(
      _balanceIncentiveCurve_equilibriumOffset > -9e17 && _balanceIncentiveCurve_equilibriumOffset < 9e17,
      "balanceIncentiveCurve_equilibriumOffset out of bounds"
    );

    balanceIncentiveCurve_equilibriumOffset[marketIndex] = _balanceIncentiveCurve_equilibriumOffset;
  }

  /**
  @notice Changes the balance incentive curve equilibrium offset for a market
  @param marketIndex Identifies the market.
  @param _balanceIncentiveCurve_equilibriumOffset The new offset.
  */
  function changeBalanceIncentiveEquilibriumOffset(uint32 marketIndex, int256 _balanceIncentiveCurve_equilibriumOffset)
    external
    onlyAdmin
  {
    _changeBalanceIncentiveEquilibriumOffset(marketIndex, _balanceIncentiveCurve_equilibriumOffset);

    emit BalanceIncentiveEquilibriumOffsetUpdated(marketIndex, _balanceIncentiveCurve_equilibriumOffset);
  }

  /*╔═════════════════════════════╗
    ║        STAKING SETUP        ║
    ╚═════════════════════════════╝*/

  /**
  @notice Sets this contract to track staking for a market in LongShort.sol
  @param marketIndex Identifies the market.
  @param longToken Address of the long token for the market.
  @param shortToken Address of the short token for the market.
  @param kInitialMultiplier Initial boost on float generation for the market.
  @param kPeriod Period which the boost should last.
  @param unstakeFee_e18 Percentage of tokens that are levied on unstaking in base 1e18.
  @param _balanceIncentiveCurve_exponent Exponent for balance curve (see _calculateFloatPerSecond)
  @param _balanceIncentiveCurve_equilibriumOffset Offset for balance curve (see _calculateFloatPerSecond)
  */
  function addNewStakingFund(
    uint32 marketIndex,
    address longToken,
    address shortToken,
    uint256 kInitialMultiplier,
    uint256 kPeriod,
    uint256 unstakeFee_e18,
    uint256 _balanceIncentiveCurve_exponent,
    int256 _balanceIncentiveCurve_equilibriumOffset
  ) external override onlyLongShort {
    marketIndexOfToken[longToken] = marketIndex;
    marketIndexOfToken[shortToken] = marketIndex;

    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].timestamp = block.timestamp;
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].accumulativeFloatPerSyntheticToken_long = 0;
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].accumulativeFloatPerSyntheticToken_short = 0;

    syntheticTokens[marketIndex][true] = longToken;
    syntheticTokens[marketIndex][false] = shortToken;

    _changeBalanceIncentiveExponent(marketIndex, _balanceIncentiveCurve_exponent);
    _changeBalanceIncentiveEquilibriumOffset(marketIndex, _balanceIncentiveCurve_equilibriumOffset);
    _changeMarketLaunchIncentiveParameters(marketIndex, kPeriod, kInitialMultiplier);

    _changeUnstakeFee(marketIndex, unstakeFee_e18);

    // Set this value to one initially - 0 is a null value and thus potentially bug prone.
    batched_stakerNextTokenShiftIndex[marketIndex] = 1;

    emit MarketAddedToStaker(
      marketIndex,
      unstakeFee_e18,
      kPeriod,
      kInitialMultiplier,
      _balanceIncentiveCurve_exponent,
      _balanceIncentiveCurve_equilibriumOffset
    );

    emit AccumulativeIssuancePerStakedSynthSnapshotCreated(marketIndex, 0, 0, 0);
  }

  /*╔═════════════════════════════════════════════════════════════════════════╗
    ║    GLOBAL FLT REWARD ACCUMULATION CALCULATION AND TRACKING FUNCTIONS    ║
    ╚═════════════════════════════════════════════════════════════════════════╝*/

  /**
  @notice Returns the K factor parameters for the given market with sensible
  defaults if they haven't been set yet.
  @param marketIndex The market to change the parameters for.
  @return period The period for which the k factor applies for in seconds.
  @return multiplier The multiplier on Float generation in this period.
  */
  function _getMarketLaunchIncentiveParameters(uint32 marketIndex)
    internal
    view
    virtual
    returns (uint256 period, uint256 multiplier)
  {
    period = marketLaunchIncentive_period[marketIndex];
    multiplier = marketLaunchIncentive_multipliers[marketIndex];

    if (multiplier < 1e18) {
      multiplier = 1e18; // multiplier of 1 by default
    }
  }

  /** 
  @notice Returns the extent to which a markets float generation should be adjusted
  based on the market's launch incentive parameters. Should start at multiplier
  then linearly change to 1e18 over time.
  @param marketIndex Identifies the market.
  @return k The calculated modifier for float generation.
  */
  function _getKValue(uint32 marketIndex) internal view virtual returns (uint256) {
    // Parameters controlling the float issuance multiplier.
    (uint256 kPeriod, uint256 kInitialMultiplier) = _getMarketLaunchIncentiveParameters(marketIndex);

    // Sanity check - under normal circumstances, the multipliers should
    // *never* be set to a value < 1e18, as there are guards against this.
    assert(kInitialMultiplier >= 1e18);

    uint256 initialTimestamp = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].timestamp;

    if (block.timestamp - initialTimestamp <= kPeriod) {
      return kInitialMultiplier - (((kInitialMultiplier - 1e18) * (block.timestamp - initialTimestamp)) / kPeriod);
    } else {
      return 1e18;
    }
  }

  /*
  @notice Computes the number of float tokens a user earns per second for
  every long/short synthetic token they've staked. The returned value has
  a fixed decimal scale of 1e42 (!!!) for numerical stability. The return
  values are float per second per synthetic token (hence the requirement
  to multiply by price)
  @dev to see below math in latex form see TODO add link
  to interact with the equations see https://www.desmos.com/calculator/optkaxyihr
  @param marketIndex The market referred to.
  @param longPrice Price of the synthetic long token in units of payment token
  @param shortPrice Price of the synthetic short token in units of payment token
  @param longValue Amount of payment token in the long side of the market
  @param shortValue Amount of payment token in the short side of the market
  @return longFloatPerSecond Float token per second per long synthetic token
  @return shortFloatPerSecond Float token per second per short synthetic token
   */
  function _calculateFloatPerSecond(
    uint32 marketIndex,
    uint256 longPrice,
    uint256 shortPrice,
    uint256 longValue,
    uint256 shortValue
  ) internal view virtual returns (uint256 longFloatPerSecond, uint256 shortFloatPerSecond) {
    // A float issuance multiplier that starts high and decreases linearly
    // over time to a value of 1. This incentivises users to stake early.
    uint256 k = _getKValue(marketIndex);

    uint256 totalLocked = (longValue + shortValue);

    // we need to scale this number by the totalLocked so that the offset remains consistent accross market size

    int256 equilibriumOffsetMarketScaled = (balanceIncentiveCurve_equilibriumOffset[marketIndex] *
      int256(totalLocked)) / 2e18;

    uint256 denominator = ((totalLocked >> safeExponentBitShifting)**balanceIncentiveCurve_exponent[marketIndex]);

    // Float is scaled by the percentage of the total market value held in
    // the opposite position. This incentivises users to stake on the
    // weaker position.
    if (int256(shortValue) - equilibriumOffsetMarketScaled < int256(longValue)) {
      if (equilibriumOffsetMarketScaled >= int256(shortValue)) {
        // edge case: imbalanced far past the equilibrium offset - full rewards go to short token
        //            extremeley unlikely to happen in practice
        return (0, 1e18 * k * shortPrice);
      }

      uint256 numerator = (uint256(int256(shortValue) - equilibriumOffsetMarketScaled) >>
        (safeExponentBitShifting - 1))**balanceIncentiveCurve_exponent[marketIndex];

      // NOTE: `x * 5e17` == `(x * 10e18) / 2`
      uint256 longRewardUnscaled = (numerator * 5e17) / denominator;
      uint256 shortRewardUnscaled = 1e18 - longRewardUnscaled;

      return ((longRewardUnscaled * k * longPrice) / 1e18, (shortRewardUnscaled * k * shortPrice) / 1e18);
    } else {
      if (-equilibriumOffsetMarketScaled >= int256(longValue)) {
        // edge case: imbalanced far past the equilibrium offset - full rewards go to long token
        //            extremeley unlikely to happen in practice
        return (1e18 * k * longPrice, 0);
      }

      uint256 numerator = (uint256(int256(longValue) + equilibriumOffsetMarketScaled) >>
        (safeExponentBitShifting - 1))**balanceIncentiveCurve_exponent[marketIndex];

      // NOTE: `x * 5e17` == `(x * 10e18) / 2`
      uint256 shortRewardUnscaled = (numerator * 5e17) / denominator;
      uint256 longRewardUnscaled = 1e18 - shortRewardUnscaled;

      return ((longRewardUnscaled * k * longPrice) / 1e18, (shortRewardUnscaled * k * shortPrice) / 1e18);
    }
  }

  /**
  @notice Computes the time since last accumulativeIssuancePerStakedSynthSnapshot for the given market in seconds.
  @param marketIndex The market referred to.
  @return The time difference in seconds
  */
  function _calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(uint32 marketIndex)
    internal
    view
    virtual
    returns (uint256)
  {
    return
      block.timestamp -
      accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]].timestamp;
  }

  /**
  @notice Computes new cumulative sum of 'r' value since last accumulativeIssuancePerStakedSynthSnapshot. We use
  cumulative 'r' value to avoid looping during issuance. Note that the
  cumulative sum is kept in 1e42 scale (!!!) to avoid numerical issues.
  @param shortValue The value locked in the short side of the market.
  @param longValue The value locked in the long side of the market.
  @param shortPrice The price of the short token as defined in LongShort.sol
  @param longPrice The price of the long token as defined in LongShort.sol
  @param marketIndex An identifier for the market.
  @return longCumulativeRates The long cumulative sum.
  @return shortCumulativeRates The short cumulative sum.
  */
  function _calculateNewCumulativeIssuancePerStakedSynth(
    uint32 marketIndex,
    uint256 longPrice,
    uint256 shortPrice,
    uint256 longValue,
    uint256 shortValue
  ) internal view virtual returns (uint256 longCumulativeRates, uint256 shortCumulativeRates) {
    // Compute the current 'r' value for float issuance per second.
    (uint256 longFloatPerSecond, uint256 shortFloatPerSecond) = _calculateFloatPerSecond(
      marketIndex,
      longPrice,
      shortPrice,
      longValue,
      shortValue
    );

    // Compute time since last accumulativeIssuancePerStakedSynthSnapshot for the given token.
    uint256 timeDelta = _calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(marketIndex);

    // Compute new cumulative 'r' value total.
    return (
      accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]]
      .accumulativeFloatPerSyntheticToken_long + (timeDelta * longFloatPerSecond),
      accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]]
      .accumulativeFloatPerSyntheticToken_short + (timeDelta * shortFloatPerSecond)
    );
  }

  /**
  @notice Creates a new accumulativeIssuancePerStakedSynthSnapshot for the given token and updates indexes.
  @param shortValue The value locked in the short side of the market.
  @param longValue The value locked in the long side of the market.
  @param shortPrice The price of the short token as defined in LongShort.sol
  @param longPrice The price of the long token as defined in LongShort.sol
  @param marketIndex An identifier for the market.
  */
  function _setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot(
    uint32 marketIndex,
    uint256 longPrice,
    uint256 shortPrice,
    uint256 longValue,
    uint256 shortValue
  ) internal virtual {
    (
      uint256 newLongAccumulativeValue,
      uint256 newShortAccumulativeValue
    ) = _calculateNewCumulativeIssuancePerStakedSynth(marketIndex, longPrice, shortPrice, longValue, shortValue);

    uint256 newIndex = latestRewardIndex[marketIndex] + 1;

    // Set cumulative 'r' value on new accumulativeIssuancePerStakedSynthSnapshot.
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex]
    .accumulativeFloatPerSyntheticToken_long = newLongAccumulativeValue;
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex]
    .accumulativeFloatPerSyntheticToken_short = newShortAccumulativeValue;

    // Set timestamp on new accumulativeIssuancePerStakedSynthSnapshot.
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex].timestamp = block.timestamp;

    // Update latest index to point to new accumulativeIssuancePerStakedSynthSnapshot.
    latestRewardIndex[marketIndex] = newIndex;

    emit AccumulativeIssuancePerStakedSynthSnapshotCreated(
      marketIndex,
      newIndex,
      newLongAccumulativeValue,
      newShortAccumulativeValue
    );
  }

  /**
  @notice Adds new accumulativeIssuancePerStakedSynthSnapshots for the given long/short tokens. Called by the
  ILongShort contract whenever there is a state change for a market.
  @param stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted Mapping from this contract's shifts to LongShort.sols next price snapshots.
  @param shortValue The value locked in the short side of the market.
  @param longValue The value locked in the long side of the market.
  @param shortPrice The price of the short token as defined in LongShort.sol
  @param longPrice The price of the long token as defined in LongShort.sol
  @param marketIndex An identifier for the market.
  */
  function pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(
    uint32 marketIndex,
    uint256 longPrice,
    uint256 shortPrice,
    uint256 longValue,
    uint256 shortValue,
    uint256 stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted // This value should be ALWAYS be zero if no shift occured
  ) external override onlyLongShort {
    // Only add a new accumulativeIssuancePerStakedSynthSnapshot if some time has passed.

    // the `stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted` value will be 0 if there is no staker related action in an executed batch
    if (stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted > 0) {
      stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[
        batched_stakerNextTokenShiftIndex[marketIndex]
      ] = stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted;
      stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[
        batched_stakerNextTokenShiftIndex[marketIndex]
      ] = latestRewardIndex[marketIndex] + 1;
      batched_stakerNextTokenShiftIndex[marketIndex] += 1;

      emit SyntheticTokensShifted();
    }

    // Time delta is fetched twice in below code, can pass through? Which is less gas?
    if (_calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(marketIndex) > 0) {
      _setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot(
        marketIndex,
        longPrice,
        shortPrice,
        longValue,
        shortValue
      );
    }
  }

  /*╔═══════════════════════════════════╗
    ║    USER REWARD STATE FUNCTIONS    ║
    ╚═══════════════════════════════════╝*/

  /// @dev Calculates the accumulated float in a specific range of staker snapshots
  function _calculateAccumulatedFloatInRange(
    uint32 marketIndex,
    uint256 amountStakedLong,
    uint256 amountStakedShort,
    uint256 rewardIndexFrom,
    uint256 rewardIndexTo
  ) internal view virtual returns (uint256 floatReward) {
    if (amountStakedLong > 0) {
      uint256 accumDeltaLong = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexTo]
      .accumulativeFloatPerSyntheticToken_long -
        accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexFrom]
        .accumulativeFloatPerSyntheticToken_long;
      floatReward += (accumDeltaLong * amountStakedLong) / FLOAT_ISSUANCE_FIXED_DECIMAL;
    }

    if (amountStakedShort > 0) {
      uint256 accumDeltaShort = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexTo]
      .accumulativeFloatPerSyntheticToken_short -
        accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexFrom]
        .accumulativeFloatPerSyntheticToken_short;
      floatReward += (accumDeltaShort * amountStakedShort) / FLOAT_ISSUANCE_FIXED_DECIMAL;
    }
  }

  /** 
  @notice Calculates float owed to the user since the user last minted float for a market.
  @param marketIndex Identifier for the market which the user staked in.
  @param user The address of the user.
  @return floatReward The amount of float owed.
   */
  function _calculateAccumulatedFloat(uint32 marketIndex, address user) internal virtual returns (uint256 floatReward) {
    address longToken = syntheticTokens[marketIndex][true];
    address shortToken = syntheticTokens[marketIndex][false];

    uint256 amountStakedLong = userAmountStaked[longToken][user];
    uint256 amountStakedShort = userAmountStaked[shortToken][user];

    uint256 usersLastRewardIndex = userIndexOfLastClaimedReward[marketIndex][user];

    // Don't do the calculation and return zero immediately if there is no change
    if (usersLastRewardIndex == latestRewardIndex[marketIndex]) {
      return 0;
    }

    uint256 usersShiftIndex = userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][user];
    // if there is a change in the users tokens held due to a token shift (or possibly another action in the future)
    if (usersShiftIndex > 0 && usersShiftIndex < batched_stakerNextTokenShiftIndex[marketIndex]) {
      floatReward = _calculateAccumulatedFloatInRange(
        marketIndex,
        amountStakedLong,
        amountStakedShort,
        usersLastRewardIndex,
        stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[usersShiftIndex]
      );

      // Update the users balances
      if (userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user] > 0) {
        amountStakedShort += ILongShort(longShort).getAmountSyntheticTokenToMintOnTargetSide(
          marketIndex,
          userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user],
          true,
          stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[usersShiftIndex]
        );

        amountStakedLong -= userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user];
        userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user] = 0;
      }

      if (userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user] > 0) {
        amountStakedLong += ILongShort(longShort).getAmountSyntheticTokenToMintOnTargetSide(
          marketIndex,
          userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user],
          false,
          stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[usersShiftIndex]
        );

        amountStakedShort -= userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user];
        userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user] = 0;
      }

      // Save the users updated staked amounts
      userAmountStaked[longToken][user] = amountStakedLong;
      userAmountStaked[shortToken][user] = amountStakedShort;

      floatReward += _calculateAccumulatedFloatInRange(
        marketIndex,
        amountStakedLong,
        amountStakedShort,
        stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[usersShiftIndex],
        latestRewardIndex[marketIndex]
      );

      userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][user] = 0;
    } else {
      floatReward = _calculateAccumulatedFloatInRange(
        marketIndex,
        amountStakedLong,
        amountStakedShort,
        usersLastRewardIndex,
        latestRewardIndex[marketIndex]
      );
    }
  }

  /**
  @notice Mints float for a user.
  @dev Mints a fixed percentage for Float capital.
  @param user The address of the user.
  @param floatToMint The amount of float to mint.
   */
  function _mintFloat(address user, uint256 floatToMint) internal virtual {
    IFloatToken(floatToken).mint(user, floatToMint);
    IFloatToken(floatToken).mint(floatCapital, (floatToMint * floatPercentage) / 1e18);
  }

  /**
  @notice Mints float owed to a user for a market since they last minted.
  @param marketIndex An identifier for the market.
  @param user The address of the user.
   */
  function _mintAccumulatedFloat(uint32 marketIndex, address user) internal virtual {
    uint256 floatToMint = _calculateAccumulatedFloat(marketIndex, user);

    if (floatToMint > 0) {
      // Set the user has claimed up until now, stops them setting this forward
      userIndexOfLastClaimedReward[marketIndex][user] = latestRewardIndex[marketIndex];

      _mintFloat(user, floatToMint);
      emit FloatMinted(user, marketIndex, floatToMint);
    }
  }

  /**
  @notice Mints float owed to a user for multiple markets, since they last minted for those markets.
  @param marketIndexes Identifiers for the markets.
  @param user The address of the user.
   */
  function _mintAccumulatedFloatMulti(uint32[] calldata marketIndexes, address user) internal virtual {
    uint256 floatTotal = 0;
    for (uint256 i = 0; i < marketIndexes.length; i++) {
      uint256 floatToMint = _calculateAccumulatedFloat(marketIndexes[i], user);

      if (floatToMint > 0) {
        // Set the user has claimed up until now, stops them setting this forward
        userIndexOfLastClaimedReward[marketIndexes[i]][user] = latestRewardIndex[marketIndexes[i]];

        floatTotal += floatToMint;

        emit FloatMinted(user, marketIndexes[i], floatToMint);
      }
    }
    if (floatTotal > 0) {
      _mintFloat(user, floatTotal);
    }
  }

  /**
  @notice Mints outstanding float for msg.sender.
  @param marketIndexes Identifiers for the markets for which to mint float.
   */
  function claimFloatCustom(uint32[] calldata marketIndexes) external {
    ILongShort(longShort).updateSystemStateMulti(marketIndexes);
    _mintAccumulatedFloatMulti(marketIndexes, msg.sender);
  }

  /**
  @notice Mints outstanding float on behalf of another user.
  @param marketIndexes Identifiers for the markets for which to mint float.
  @param user The address of the user.
   */
  function claimFloatCustomFor(uint32[] calldata marketIndexes, address user) external {
    // Unbounded loop - users are responsible for paying their own gas costs on these and it doesn't effect the rest of the system.
    // No need to impose limit.
    ILongShort(longShort).updateSystemStateMulti(marketIndexes);
    _mintAccumulatedFloatMulti(marketIndexes, user);
  }

  /*╔═══════════════════════╗
    ║        STAKING        ║
    ╚═══════════════════════╝*/

  /**
  @notice A user with synthetic tokens stakes by calling stake on the token
  contract which calls this function. We need to first update the
  state of the LongShort contract for this market before staking to correctly calculate user rewards.
  @param amount Amount to stake.
  @param from Address to stake for.
  */
  function stakeFromUser(address from, uint256 amount) public virtual override onlyValidSynthetic((msg.sender)) {
    ILongShort(longShort).updateSystemState(marketIndexOfToken[(msg.sender)]);
    _stake((msg.sender), amount, from);
  }

  /**
  @dev Internal logic for staking.
  @param token Address of the token for which to stake.
  @param amount Amount to stake.
  @param user Address to stake for.
  */
  function _stake(
    address token,
    uint256 amount,
    address user
  ) internal virtual {
    uint32 marketIndex = marketIndexOfToken[token];

    // If they already have staked and have rewards due, mint these.
    if (
      userIndexOfLastClaimedReward[marketIndex][user] != 0 &&
      userIndexOfLastClaimedReward[marketIndex][user] < latestRewardIndex[marketIndex]
    ) {
      _mintAccumulatedFloat(marketIndex, user);
    }

    userAmountStaked[token][user] = userAmountStaked[token][user] + amount;

    userIndexOfLastClaimedReward[marketIndex][user] = latestRewardIndex[marketIndex];

    emit StakeAdded(user, address(token), amount, userIndexOfLastClaimedReward[marketIndex][user]);
  }

  /**
  @notice Allows users to shift their staked tokens from one side of the market to 
  the other at the next price.
  @param amountSyntheticTokensToShift Amount of tokens to shift.
  @param marketIndex Identifier for the market.
  @param isShiftFromLong Whether the shift is from long to short or short to long.
  */
  function shiftTokens(
    uint256 amountSyntheticTokensToShift,
    uint32 marketIndex,
    bool isShiftFromLong
  ) external virtual {
    address token = syntheticTokens[marketIndex][isShiftFromLong];
    require(userAmountStaked[token][msg.sender] >= amountSyntheticTokensToShift, "Not enough tokens to shift");

    // If the user has outstanding token shift that have already been confirmed in the LongShort
    // contract, execute them first.
    if (
      userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] != 0 &&
      userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] <
      batched_stakerNextTokenShiftIndex[marketIndex]
    ) {
      _mintAccumulatedFloat(marketIndex, msg.sender);
    }

    if (isShiftFromLong) {
      ILongShort(longShort).shiftPositionFromLongNextPrice(marketIndex, amountSyntheticTokensToShift);
      userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][
        msg.sender
      ] += amountSyntheticTokensToShift;
    } else {
      ILongShort(longShort).shiftPositionFromShortNextPrice(marketIndex, amountSyntheticTokensToShift);
      userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][
        msg.sender
      ] += amountSyntheticTokensToShift;
    }

    userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] = batched_stakerNextTokenShiftIndex[
      marketIndex
    ];
  }

  /*╔════════════════════════════╗
    ║    WITHDRAWAL & MINTING    ║
    ╚════════════════════════════╝*/

  /**
  @notice Internal logic for withdrawing stakes.
  @dev Mint user any outstanding float before withdrawing.
  @param marketIndex Market index of token.
  @param amount Amount to withdraw.
  @param token Synthetic token that was staked.
  */
  function _withdraw(
    uint32 marketIndex,
    address token,
    uint256 amount
  ) internal virtual {
    require(userAmountStaked[token][msg.sender] > 0, "nothing to withdraw");
    _mintAccumulatedFloat(marketIndex, msg.sender);

    userAmountStaked[token][msg.sender] = userAmountStaked[token][msg.sender] - amount;

    uint256 amountFees = (amount * marketUnstakeFee_e18[marketIndex]) / 1e18;

    IERC20(token).transfer(floatTreasury, amountFees);
    IERC20(token).transfer(msg.sender, amount - amountFees);

    emit StakeWithdrawn(msg.sender, token, amount);
  }

  /**
  @notice Withdraw function. Allows users to unstake.
  @param amount Amount to withdraw.
  @param token Address of the token for which to withdraw.
  */
  function withdraw(address token, uint256 amount) external {
    ILongShort(longShort).updateSystemState(marketIndexOfToken[token]);

    uint32 marketIndex = marketIndexOfToken[token];

    _withdraw(marketIndex, token, amount);

    if (userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] > 0) {
      // If they still have outstanding shifts after minting float, then check
      // that they don't withdraw more than their shifts allow.
      uint256 amountToShiftForThisToken = syntheticTokens[marketIndex][true] == token
        ? userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][msg.sender]
        : userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][msg.sender];

      require(
        userAmountStaked[token][msg.sender] >= amountToShiftForThisToken,
        "Outstanding next price stake shifts too great"
      );
    }
  }

  /**
  @notice Allows users to withdraw their entire stake for a token.
  @param token Address of the token for which to withdraw.
  */
  function withdrawAll(address token) external {
    ILongShort(longShort).updateSystemState(marketIndexOfToken[token]);

    uint32 marketIndex = marketIndexOfToken[token];

    uint256 amountToShiftForThisToken = syntheticTokens[marketIndex][true] == token
      ? userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][msg.sender]
      : userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][msg.sender];

    _withdraw(marketIndex, token, userAmountStaked[token][msg.sender] - amountToShiftForThisToken);
  }
}
.]

Based on the provided Solidity smart contract code for the `Staker` contract, here is a summary of potential security vulnerabilities and issues identified:

### Summary of Security Vulnerabilities:

1. **Reentrancy Risk**:
   - The contract allows users to withdraw their stakes and mint rewards. If an external contract is called during these operations, it could lead to reentrancy attacks. The use of `transfer` and external calls without proper checks can expose the contract to this risk.

2. **Integer Overflow/Underflow**:
   - Although Solidity 0.8.x has built-in overflow and underflow checks, any arithmetic operations that involve user inputs or external data should be carefully validated to prevent unexpected behavior.

3. **Access Control**:
   - The `onlyAdmin` modifier is used to restrict access to certain functions. If the admin's address is compromised, the attacker could change critical parameters or withdraw funds. The contract should implement a more robust access control mechanism, such as a multi-signature wallet for admin functions.

4. **Gas Limit and Loops**:
   - Functions that iterate over mappings or arrays (e.g., `_mintAccumulatedFloatMulti`) could potentially run into gas limit issues if the number of markets or users grows significantly. This could lead to denial of service.

5. **Unbounded Loops**:
   - The `claimFloatCustomFor` function contains an unbounded loop that could lead to excessive gas consumption. Users are responsible for their gas costs, but this could still lead to a poor user experience or failed transactions.

6. **Lack of Input Validation**:
   - Some functions do not validate inputs thoroughly. For example, in `_changeUnstakeFee`, there is a check for the maximum fee but no check for minimum values or valid market indices.

7. **Potential for Denial of Service**:
   - If a user calls functions that depend on external contracts (like `ILongShort`), and those contracts are not functioning correctly or are malicious, it could lead to denial of service for users trying to stake or withdraw.

8. **Event Emission**:
   - While events are emitted for significant state changes, there could be additional events for critical actions (like changing admin or parameters) to enhance transparency and traceability.

9. **Market Index Validity**:
   - The contract assumes that market indices are valid without thorough checks in some functions. If an invalid index is used, it could lead to unexpected behavior or state corruption.

10. **Floating Point Precision**:
    - The contract uses fixed-point arithmetic with large constants (e.g., `1e42`). While this is intended for precision, it can lead to rounding errors if not handled correctly, especially in calculations involving user rewards.

### Comprehensive Analysis Report:

The `Staker` contract is a complex implementation that facilitates staking and reward distribution for synthetic tokens. While it incorporates several best practices, such as using OpenZeppelin's contracts and modifiers for access control, there are notable vulnerabilities that need to be addressed.

1. **Reentrancy Protection**: Implement checks-effects-interactions pattern or use a reentrancy guard to mitigate the risk of reentrancy attacks.

2. **Access Control Enhancements**: Consider implementing a multi-signature wallet for admin functions to reduce the risk associated with a single compromised admin account.

3. **Input Validation**: Strengthen input validation across all functions to ensure that only valid data is processed, particularly for user inputs and external contract calls.

4. **Gas Optimization**: Review functions for potential gas limit issues, especially those involving loops or extensive state changes. Consider implementing pagination or limits on the number of iterations.

5. **Event Logging**: Enhance event logging to include critical state changes, which will improve transparency and facilitate easier debugging and monitoring.

6. **Testing and Auditing**: Conduct thorough testing, including unit tests and integration tests, to identify edge cases and potential vulnerabilities. Additionally, consider a third-party audit for an external perspective on security.

By addressing these vulnerabilities, the `Staker` contract can enhance its security posture and provide a more robust and reliable staking mechanism for users.

[2024-17-08 08:01:40 INFO] **[Seminar Conclusion]**:

 Based on the provided Solidity smart contract code for the `Staker` contract, here is a summary of potential security vulnerabilities and issues identified:

### Summary of Security Vulnerabilities:

1. **Reentrancy Risk**:
   - The contract allows users to withdraw their stakes and mint rewards. If an external contract is called during these operations, it could lead to reentrancy attacks. The use of `transfer` and external calls without proper checks can expose the contract to this risk.

2. **Integer Overflow/Underflow**:
   - Although Solidity 0.8.x has built-in overflow and underflow checks, any arithmetic operations that involve user inputs or external data should be carefully validated to prevent unexpected behavior.

3. **Access Control**:
   - The `onlyAdmin` modifier is used to restrict access to certain functions. If the admin's address is compromised, the attacker could change critical parameters or withdraw funds. The contract should implement a more robust access control mechanism, such as a multi-signature wallet for admin functions.

4. **Gas Limit and Loops**:
   - Functions that iterate over mappings or arrays (e.g., `_mintAccumulatedFloatMulti`) could potentially run into gas limit issues if the number of markets or users grows significantly. This could lead to denial of service.

5. **Unbounded Loops**:
   - The `claimFloatCustomFor` function contains an unbounded loop that could lead to excessive gas consumption. Users are responsible for their gas costs, but this could still lead to a poor user experience or failed transactions.

6. **Lack of Input Validation**:
   - Some functions do not validate inputs thoroughly. For example, in `_changeUnstakeFee`, there is a check for the maximum fee but no check for minimum values or valid market indices.

7. **Potential for Denial of Service**:
   - If a user calls functions that depend on external contracts (like `ILongShort`), and those contracts are not functioning correctly or are malicious, it could lead to denial of service for users trying to stake or withdraw.

8. **Event Emission**:
   - While events are emitted for significant state changes, there could be additional events for critical actions (like changing admin or parameters) to enhance transparency and traceability.

9. **Market Index Validity**:
   - The contract assumes that market indices are valid without thorough checks in some functions. If an invalid index is used, it could lead to unexpected behavior or state corruption.

10. **Floating Point Precision**:
    - The contract uses fixed-point arithmetic with large constants (e.g., `1e42`). While this is intended for precision, it can lead to rounding errors if not handled correctly, especially in calculations involving user rewards.

### Comprehensive Analysis Report:

The `Staker` contract is a complex implementation that facilitates staking and reward distribution for synthetic tokens. While it incorporates several best practices, such as using OpenZeppelin's contracts and modifiers for access control, there are notable vulnerabilities that need to be addressed.

1. **Reentrancy Protection**: Implement checks-effects-interactions pattern or use a reentrancy guard to mitigate the risk of reentrancy attacks.

2. **Access Control Enhancements**: Consider implementing a multi-signature wallet for admin functions to reduce the risk associated with a single compromised admin account.

3. **Input Validation**: Strengthen input validation across all functions to ensure that only valid data is processed, particularly for user inputs and external contract calls.

4. **Gas Optimization**: Review functions for potential gas limit issues, especially those involving loops or extensive state changes. Consider implementing pagination or limits on the number of iterations.

5. **Event Logging**: Enhance event logging to include critical state changes, which will improve transparency and facilitate easier debugging and monitoring.

6. **Testing and Auditing**: Conduct thorough testing, including unit tests and integration tests, to identify edge cases and potential vulnerabilities. Additionally, consider a third-party audit for an external perspective on security.

By addressing these vulnerabilities, the `Staker` contract can enhance its security posture and provide a more robust and reliable staking mechanism for users.

[2024-17-08 08:01:40 INFO] **[Execute Detail]**

execute SimplePhase:[ContractReviewComment] in ComposedPhase:[CodeReview], cycle 2

[2024-17-08 08:01:40 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: BUSL-1.1 pragma solidity 0.8.3; import "@openzeppelin/contracts-upgradeable/token/ERC20/presets/ERC20PresetMinterPauserUpgradeable.sol"; import "./interfaces/IFloatToken.sol"; import "./interfaces/ILongShort.sol"; import "./interfaces/IStaker.sol"; import "./interfaces/ISyntheticToken.sol"; contract Staker is IStaker, Initializable {   /╔═════════════════════════════╗     ║          VARIABLES          ║     ╚═════════════════════════════╝/ / ══════ Fixed-precision constants ══════ /   uint256 public constant FLOAT_ISSUANCE_FIXED_DECIMAL = 1e42;   // 2^52 ~= 4.5e15   // With an exponent of 5, the largest total liquidity possible in a market (to avoid integer overflow on exponentiation) is ~10^31 or 10 Trillion (10^13)   // NOTE: this also means if the total market value is less than 2^52 there will be a division by zero error   uint256 public constant safeExponentBitShifting = 52; / ══════ Global state ══════ /   address public admin;   address public floatCapital;   address public floatTreasury;   uint256 public floatPercentage; address public longShort;   address public floatToken; / ══════ Market specific ══════ /   mapping(uint32 =&gt; uint256) public marketLaunchIncentive_period; // seconds   mapping(uint32 =&gt; uint256) public marketLaunchIncentive_multipliers; // e18 scale   mapping(uint32 =&gt; uint256) public marketUnstakeFee_e18;   mapping(uint32 =&gt; uint256) public balanceIncentiveCurve_exponent;   mapping(uint32 =&gt; int256) public balanceIncentiveCurve_equilibriumOffset; mapping(uint32 =&gt; mapping(bool =&gt; address)) public syntheticTokens; mapping(address =&gt; uint32) public marketIndexOfToken; / ══════ Reward specific ══════ /   mapping(uint32 =&gt; uint256) public latestRewardIndex;   mapping(uint32 =&gt; mapping(uint256 =&gt; AccumulativeIssuancePerStakedSynthSnapshot))     public accumulativeFloatPerSyntheticTokenSnapshots;   struct AccumulativeIssuancePerStakedSynthSnapshot {     uint256 timestamp;     uint256 accumulativeFloatPerSyntheticToken_long;     uint256 accumulativeFloatPerSyntheticToken_short;   } / ══════ User specific ══════ /   mapping(uint32 =&gt; mapping(address =&gt; uint256)) public userIndexOfLastClaimedReward;   mapping(address =&gt; mapping(address =&gt; uint256)) public userAmountStaked; / ══════ Token shift management specific ══════ /   mapping(uint32 =&gt; uint256) public batched_stakerNextTokenShiftIndex;   /*   @notice Used to link a token shift to a staker state   @dev tokenShiftIndex =&gt; accumulativeFloatIssuanceSnapshotIndex     POSSIBLE OPTIMIZATION - could pack stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping and stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping into a struct of two uint128 for storage space optimization.   /   mapping(uint256 =&gt; uint256) public stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping;   /// @notice Used to fetch the price from LongShort at that point in time   /// @dev tokenShiftIndex =&gt; longShortMarketPriceSnapshotIndex   mapping(uint256 =&gt; uint256) public stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping;   /// @dev marketIndex =&gt; usersAddress =&gt; stakerTokenShiftIndex   mapping(uint32 =&gt; mapping(address =&gt; uint256)) public userNextPrice_stakedSyntheticTokenShiftIndex;   /// @dev marketIndex =&gt; usersAddress =&gt; amountUserRequestedToShiftAwayFromLongOnNextUpdate   mapping(uint32 =&gt; mapping(address =&gt; uint256)) public userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long;   /// @dev marketIndex =&gt; usersAddress =&gt; amountUserRequestedToShiftAwayFromShortOnNextUpdate   mapping(uint32 =&gt; mapping(address =&gt; uint256)) public userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short; /╔════════════════════════════╗     ║           EVENTS           ║     ╚════════════════════════════╝/ event StakerV1(     address admin,     address floatTreasury,     address floatCapital,     address floatToken,     uint256 floatPercentage   ); event MarketAddedToStaker(     uint32 marketIndex,     uint256 exitFee_e18,     uint256 period,     uint256 multiplier,     uint256 balanceIncentiveExponent,     int256 balanceIncentiveEquilibriumOffset   ); event AccumulativeIssuancePerStakedSynthSnapshotCreated(     uint32 marketIndex,     uint256 accumulativeFloatIssuanceSnapshotIndex,     uint256 accumulativeLong,     uint256 accumulativeShort   ); event StakeAdded(address user, address token, uint256 amount, uint256 lastMintIndex); event StakeWithdrawn(address user, address token, uint256 amount); // Note: the amountFloatMinted isn't strictly needed by the graph, but it is good to add it to validate calculations are accurate.   event FloatMinted(address user, uint32 marketIndex, uint256 amountFloatMinted); event MarketLaunchIncentiveParametersChanges(uint32 marketIndex, uint256 period, uint256 multiplier); event StakeWithdrawalFeeUpdated(uint32 marketIndex, uint256 stakeWithdralFee); event BalanceIncentiveExponentUpdated(uint32 marketIndex, uint256 balanceIncentiveExponent); event BalanceIncentiveEquilibriumOffsetUpdated(uint32 marketIndex, int256 balanceIncentiveEquilibriumOffset); event FloatPercentageUpdated(uint256 floatPercentage); event SyntheticTokensShifted(); event ChangeAdmin(address newAdmin); /╔═════════════════════════════╗     ║          MODIFIERS          ║     ╚═════════════════════════════╝/ function onlyAdminModifierLogic() internal virtual {     require(msg.sender == admin, "not admin");   } modifier onlyAdmin() {     onlyAdminModifierLogic();     _;   } function onlyValidSyntheticModifierLogic(address _synth) internal virtual {     require(marketIndexOfToken[_synth] != 0, "not valid synth");   } modifier onlyValidSynthetic(address synth) {     onlyValidSyntheticModifierLogic(_synth);     ;   } function onlyValidMarketModifierLogic(uint32 marketIndex) internal virtual {     require(address(syntheticTokens[marketIndex][true]) != address(0), "not valid market");   } modifier onlyValidMarket(uint32 marketIndex) {     onlyValidMarketModifierLogic(marketIndex);     _;   } function onlyLongShortModifierLogic() internal virtual {     require(msg.sender == address(longShort), "not long short");   } modifier onlyLongShort() {     onlyLongShortModifierLogic();     _;   } /╔═════════════════════════════╗     ║       CONTRACT SET-UP       ║     ╚═════════════════════════════╝/ /*   @notice Initializes the contract.   @dev Calls OpenZeppelin's initializer modifier.   @param _admin Address of the admin role.   @param _longShort Address of the LongShort contract, a deployed LongShort.sol   @param _floatToken Address of the Float token earned by staking.   @param _floatTreasury Address of the treasury contract for managing fees.   @param _floatCapital Address of the contract which earns a fixed percentage of Float.   @param _floatPercentage Determines the float percentage that gets minted for Float Capital, base 1e18.   /   function initialize(     address _admin,     address _longShort,     address _floatToken,     address _floatTreasury,     address _floatCapital,     uint256 _floatPercentage   ) external virtual initializer {     admin = _admin;     floatCapital = _floatCapital;     floatTreasury = _floatTreasury;     longShort = _longShort;     floatToken = _floatToken; _changeFloatPercentage(_floatPercentage);  emit StakerV1(_admin, _floatTreasury, _floatCapital, _floatToken, _floatPercentage);  } /╔═══════════════════╗     ║       ADMIN       ║     ╚═══════════════════╝/ /*    @notice Changes admin for the contract   @param _admin The address of the new admin.   /   function changeAdmin(address _admin) external onlyAdmin {     admin = _admin;     emit ChangeAdmin(_admin);   } /// @dev Logic for changeFloatPercentage   function _changeFloatPercentage(uint256 newFloatPercentage) internal virtual {     require(newFloatPercentage &lt;= 1e18 &amp;&amp; newFloatPercentage &gt; 0); // less than or equal to 100% and greater than 0%     floatPercentage = newFloatPercentage;   } /*   @notice Changes percentage of float that is minted for float capital.   @param newFloatPercentage The new float percentage in base 1e18.   /   function changeFloatPercentage(uint256 newFloatPercentage) external onlyAdmin {     _changeFloatPercentage(newFloatPercentage);     emit FloatPercentageUpdated(newFloatPercentage);   } /// @dev Logic for changeUnstakeFee   function _changeUnstakeFee(uint32 marketIndex, uint256 newMarketUnstakeFee_e18) internal virtual {     require(newMarketUnstakeFee_e18 &lt;= 5e16); // Explicitely stating 5% fee as the max fee possible.     marketUnstakeFee_e18[marketIndex] = newMarketUnstakeFee_e18;   } /*   @notice Changes unstake fee for a market   @param marketIndex Identifies the market.   @param newMarketUnstakeFee_e18 The new unstake fee.   /   function changeUnstakeFee(uint32 marketIndex, uint256 newMarketUnstakeFee_e18) external onlyAdmin {     _changeUnstakeFee(marketIndex, newMarketUnstakeFee_e18);     emit StakeWithdrawalFeeUpdated(marketIndex, newMarketUnstakeFee_e18);   } /// @dev Logic for changeMarketLaunchIncentiveParameters   function _changeMarketLaunchIncentiveParameters(     uint32 marketIndex,     uint256 period,     uint256 initialMultiplier   ) internal virtual {     require(initialMultiplier &gt;= 1e18, "marketLaunchIncentiveMultiplier must be &gt;= 1e18"); marketLaunchIncentive_period[marketIndex] = period; marketLaunchIncentive_multipliers[marketIndex] = initialMultiplier;  } /*   @notice Changes the market launch incentive parameters for a market   @param marketIndex Identifies the market.   @param period The new period for which float token generation should be boosted.   @param initialMultiplier The new multiplier on Float generation.   /   function changeMarketLaunchIncentiveParameters(     uint32 marketIndex,     uint256 period,     uint256 initialMultiplier   ) external onlyAdmin {     _changeMarketLaunchIncentiveParameters(marketIndex, period, initialMultiplier); emit MarketLaunchIncentiveParametersChanges(marketIndex, period, initialMultiplier);  } /// @dev Logic for changeBalanceIncentiveExponent   function _changeBalanceIncentiveExponent(uint32 marketIndex, uint256 _balanceIncentiveCurve_exponent)     internal     virtual   {     require(       // The exponent has to be less than 5 in these versions of the contracts.       _balanceIncentiveCurve_exponent &gt; 0 &amp;&amp; _balanceIncentiveCurve_exponent &lt; 6,       "balanceIncentiveCurve_exponent out of bounds"     ); balanceIncentiveCurve_exponent[marketIndex] = _balanceIncentiveCurve_exponent;  } /*    @notice Changes the balance incentive exponent for a market   @param marketIndex Identifies the market.   @param _balanceIncentiveCurve_exponent The new exponent for the curve.   /   function changeBalanceIncentiveExponent(uint32 marketIndex, uint256 _balanceIncentiveCurve_exponent)     external     onlyAdmin   {     _changeBalanceIncentiveExponent(marketIndex, _balanceIncentiveCurve_exponent); emit BalanceIncentiveExponentUpdated(marketIndex, _balanceIncentiveCurve_exponent);  } /// @dev Logic for changeBalanceIncentiveEquilibriumOffset   function _changeBalanceIncentiveEquilibriumOffset(uint32 marketIndex, int256 _balanceIncentiveCurve_equilibriumOffset)     internal     virtual   {     // Unreasonable that we would ever shift this more than 90% either way     require(       _balanceIncentiveCurve_equilibriumOffset &gt; -9e17 &amp;&amp; _balanceIncentiveCurve_equilibriumOffset &lt; 9e17,       "balanceIncentiveCurve_equilibriumOffset out of bounds"     ); balanceIncentiveCurve_equilibriumOffset[marketIndex] = _balanceIncentiveCurve_equilibriumOffset;  } /*   @notice Changes the balance incentive curve equilibrium offset for a market   @param marketIndex Identifies the market.   @param _balanceIncentiveCurve_equilibriumOffset The new offset.   /   function changeBalanceIncentiveEquilibriumOffset(uint32 marketIndex, int256 _balanceIncentiveCurve_equilibriumOffset)     external     onlyAdmin   {     _changeBalanceIncentiveEquilibriumOffset(marketIndex, _balanceIncentiveCurve_equilibriumOffset); emit BalanceIncentiveEquilibriumOffsetUpdated(marketIndex, _balanceIncentiveCurve_equilibriumOffset);  } /╔═════════════════════════════╗     ║        STAKING SETUP        ║     ╚═════════════════════════════╝/ /*   @notice Sets this contract to track staking for a market in LongShort.sol   @param marketIndex Identifies the market.   @param longToken Address of the long token for the market.   @param shortToken Address of the short token for the market.   @param kInitialMultiplier Initial boost on float generation for the market.   @param kPeriod Period which the boost should last.   @param unstakeFee_e18 Percentage of tokens that are levied on unstaking in base 1e18.   @param _balanceIncentiveCurve_exponent Exponent for balance curve (see _calculateFloatPerSecond)   @param _balanceIncentiveCurve_equilibriumOffset Offset for balance curve (see _calculateFloatPerSecond)   /   function addNewStakingFund(     uint32 marketIndex,     address longToken,     address shortToken,     uint256 kInitialMultiplier,     uint256 kPeriod,     uint256 unstakeFee_e18,     uint256 _balanceIncentiveCurve_exponent,     int256 _balanceIncentiveCurve_equilibriumOffset   ) external override onlyLongShort {     marketIndexOfToken[longToken] = marketIndex;     marketIndexOfToken[shortToken] = marketIndex; accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].timestamp = block.timestamp; accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].accumulativeFloatPerSyntheticToken_long = 0; accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].accumulativeFloatPerSyntheticToken_short = 0;  syntheticTokens[marketIndex][true] = longToken; syntheticTokens[marketIndex][false] = shortToken;  _changeBalanceIncentiveExponent(marketIndex, _balanceIncentiveCurve_exponent); _changeBalanceIncentiveEquilibriumOffset(marketIndex, _balanceIncentiveCurve_equilibriumOffset); _changeMarketLaunchIncentiveParameters(marketIndex, kPeriod, kInitialMultiplier);  _changeUnstakeFee(marketIndex, unstakeFee_e18);  // Set this value to one initially - 0 is a null value and thus potentially bug prone. batched_stakerNextTokenShiftIndex[marketIndex] = 1;  emit MarketAddedToStaker(   marketIndex,   unstakeFee_e18,   kPeriod,   kInitialMultiplier,   _balanceIncentiveCurve_exponent,   _balanceIncentiveCurve_equilibriumOffset );  emit AccumulativeIssuancePerStakedSynthSnapshotCreated(marketIndex, 0, 0, 0);  } /╔═════════════════════════════════════════════════════════════════════════╗     ║    GLOBAL FLT REWARD ACCUMULATION CALCULATION AND TRACKING FUNCTIONS    ║     ╚═════════════════════════════════════════════════════════════════════════╝/ /*   @notice Returns the K factor parameters for the given market with sensible   defaults if they haven't been set yet.   @param marketIndex The market to change the parameters for.   @return period The period for which the k factor applies for in seconds.   @return multiplier The multiplier on Float generation in this period.   /   function _getMarketLaunchIncentiveParameters(uint32 marketIndex)     internal     view     virtual     returns (uint256 period, uint256 multiplier)   {     period = marketLaunchIncentive_period[marketIndex];     multiplier = marketLaunchIncentive_multipliers[marketIndex]; if (multiplier &lt; 1e18) {   multiplier = 1e18; // multiplier of 1 by default }  } /*    @notice Returns the extent to which a markets float generation should be adjusted   based on the market's launch incentive parameters. Should start at multiplier   then linearly change to 1e18 over time.   @param marketIndex Identifies the market.   @return k The calculated modifier for float generation.   /   function _getKValue(uint32 marketIndex) internal view virtual returns (uint256) {     // Parameters controlling the float issuance multiplier.     (uint256 kPeriod, uint256 kInitialMultiplier) = _getMarketLaunchIncentiveParameters(marketIndex); // Sanity check - under normal circumstances, the multipliers should // *never* be set to a value &lt; 1e18, as there are guards against this. assert(kInitialMultiplier &gt;= 1e18);  uint256 initialTimestamp = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].timestamp;  if (block.timestamp - initialTimestamp &lt;= kPeriod) {   return kInitialMultiplier - (((kInitialMultiplier - 1e18) * (block.timestamp - initialTimestamp)) / kPeriod); } else {   return 1e18; }  } /   @notice Computes the number of float tokens a user earns per second for   every long/short synthetic token they've staked. The returned value has   a fixed decimal scale of 1e42 (!!!) for numerical stability. The return   values are float per second per synthetic token (hence the requirement   to multiply by price)   @dev to see below math in latex form see TODO add link   to interact with the equations see https://www.desmos.com/calculator/optkaxyihr   @param marketIndex The market referred to.   @param longPrice Price of the synthetic long token in units of payment token   @param shortPrice Price of the synthetic short token in units of payment token   @param longValue Amount of payment token in the long side of the market   @param shortValue Amount of payment token in the short side of the market   @return longFloatPerSecond Float token per second per long synthetic token   @return shortFloatPerSecond Float token per second per short synthetic token    /   function _calculateFloatPerSecond(     uint32 marketIndex,     uint256 longPrice,     uint256 shortPrice,     uint256 longValue,     uint256 shortValue   ) internal view virtual returns (uint256 longFloatPerSecond, uint256 shortFloatPerSecond) {     // A float issuance multiplier that starts high and decreases linearly     // over time to a value of 1. This incentivises users to stake early.     uint256 k = _getKValue(marketIndex); uint256 totalLocked = (longValue + shortValue);  // we need to scale this number by the totalLocked so that the offset remains consistent accross market size  int256 equilibriumOffsetMarketScaled = (balanceIncentiveCurve_equilibriumOffset[marketIndex] *   int256(totalLocked)) / 2e18;  uint256 denominator = ((totalLocked &gt;&gt; safeExponentBitShifting)**balanceIncentiveCurve_exponent[marketIndex]);  // Float is scaled by the percentage of the total market value held in // the opposite position. This incentivises users to stake on the // weaker position. if (int256(shortValue) - equilibriumOffsetMarketScaled &lt; int256(longValue)) {   if (equilibriumOffsetMarketScaled &gt;= int256(shortValue)) {     // edge case: imbalanced far past the equilibrium offset - full rewards go to short token     //            extremeley unlikely to happen in practice     return (0, 1e18 * k * shortPrice);   }    uint256 numerator = (uint256(int256(shortValue) - equilibriumOffsetMarketScaled) &gt;&gt;     (safeExponentBitShifting - 1))**balanceIncentiveCurve_exponent[marketIndex];    // NOTE: `x * 5e17` == `(x * 10e18) / 2`   uint256 longRewardUnscaled = (numerator * 5e17) / denominator;   uint256 shortRewardUnscaled = 1e18 - longRewardUnscaled;    return ((longRewardUnscaled * k * longPrice) / 1e18, (shortRewardUnscaled * k * shortPrice) / 1e18); } else {   if (-equilibriumOffsetMarketScaled &gt;= int256(longValue)) {     // edge case: imbalanced far past the equilibrium offset - full rewards go to long token     //            extremeley unlikely to happen in practice     return (1e18 * k * longPrice, 0);   }    uint256 numerator = (uint256(int256(longValue) + equilibriumOffsetMarketScaled) &gt;&gt;     (safeExponentBitShifting - 1))**balanceIncentiveCurve_exponent[marketIndex];    // NOTE: `x * 5e17` == `(x * 10e18) / 2`   uint256 shortRewardUnscaled = (numerator * 5e17) / denominator;   uint256 longRewardUnscaled = 1e18 - shortRewardUnscaled;    return ((longRewardUnscaled * k * longPrice) / 1e18, (shortRewardUnscaled * k * shortPrice) / 1e18); }  } /*   @notice Computes the time since last accumulativeIssuancePerStakedSynthSnapshot for the given market in seconds.   @param marketIndex The market referred to.   @return The time difference in seconds   /   function _calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(uint32 marketIndex)     internal     view     virtual     returns (uint256)   {     return       block.timestamp -       accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]].timestamp;   } /*   @notice Computes new cumulative sum of 'r' value since last accumulativeIssuancePerStakedSynthSnapshot. We use   cumulative 'r' value to avoid looping during issuance. Note that the   cumulative sum is kept in 1e42 scale (!!!) to avoid numerical issues.   @param shortValue The value locked in the short side of the market.   @param longValue The value locked in the long side of the market.   @param shortPrice The price of the short token as defined in LongShort.sol   @param longPrice The price of the long token as defined in LongShort.sol   @param marketIndex An identifier for the market.   @return longCumulativeRates The long cumulative sum.   @return shortCumulativeRates The short cumulative sum.   /   function _calculateNewCumulativeIssuancePerStakedSynth(     uint32 marketIndex,     uint256 longPrice,     uint256 shortPrice,     uint256 longValue,     uint256 shortValue   ) internal view virtual returns (uint256 longCumulativeRates, uint256 shortCumulativeRates) {     // Compute the current 'r' value for float issuance per second.     (uint256 longFloatPerSecond, uint256 shortFloatPerSecond) = _calculateFloatPerSecond(       marketIndex,       longPrice,       shortPrice,       longValue,       shortValue     ); // Compute time since last accumulativeIssuancePerStakedSynthSnapshot for the given token. uint256 timeDelta = _calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(marketIndex);  // Compute new cumulative 'r' value total. return (   accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]]   .accumulativeFloatPerSyntheticToken_long + (timeDelta * longFloatPerSecond),   accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]]   .accumulativeFloatPerSyntheticToken_short + (timeDelta * shortFloatPerSecond) );  } /*   @notice Creates a new accumulativeIssuancePerStakedSynthSnapshot for the given token and updates indexes.   @param shortValue The value locked in the short side of the market.   @param longValue The value locked in the long side of the market.   @param shortPrice The price of the short token as defined in LongShort.sol   @param longPrice The price of the long token as defined in LongShort.sol   @param marketIndex An identifier for the market.   /   function _setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot(     uint32 marketIndex,     uint256 longPrice,     uint256 shortPrice,     uint256 longValue,     uint256 shortValue   ) internal virtual {     (       uint256 newLongAccumulativeValue,       uint256 newShortAccumulativeValue     ) = _calculateNewCumulativeIssuancePerStakedSynth(marketIndex, longPrice, shortPrice, longValue, shortValue); uint256 newIndex = latestRewardIndex[marketIndex] + 1;  // Set cumulative 'r' value on new accumulativeIssuancePerStakedSynthSnapshot. accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex] .accumulativeFloatPerSyntheticToken_long = newLongAccumulativeValue; accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex] .accumulativeFloatPerSyntheticToken_short = newShortAccumulativeValue;  // Set timestamp on new accumulativeIssuancePerStakedSynthSnapshot. accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex].timestamp = block.timestamp;  // Update latest index to point to new accumulativeIssuancePerStakedSynthSnapshot. latestRewardIndex[marketIndex] = newIndex;  emit AccumulativeIssuancePerStakedSynthSnapshotCreated(   marketIndex,   newIndex,   newLongAccumulativeValue,   newShortAccumulativeValue );  } /*   @notice Adds new accumulativeIssuancePerStakedSynthSnapshots for the given long/short tokens. Called by the   ILongShort contract whenever there is a state change for a market.   @param stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted Mapping from this contract's shifts to LongShort.sols next price snapshots.   @param shortValue The value locked in the short side of the market.   @param longValue The value locked in the long side of the market.   @param shortPrice The price of the short token as defined in LongShort.sol   @param longPrice The price of the long token as defined in LongShort.sol   @param marketIndex An identifier for the market.   /   function pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(     uint32 marketIndex,     uint256 longPrice,     uint256 shortPrice,     uint256 longValue,     uint256 shortValue,     uint256 stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted // This value should be ALWAYS be zero if no shift occured   ) external override onlyLongShort {     // Only add a new accumulativeIssuancePerStakedSynthSnapshot if some time has passed. // the `stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted` value will be 0 if there is no staker related action in an executed batch if (stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted &gt; 0) {   stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[     batched_stakerNextTokenShiftIndex[marketIndex]   ] = stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted;   stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[     batched_stakerNextTokenShiftIndex[marketIndex]   ] = latestRewardIndex[marketIndex] + 1;   batched_stakerNextTokenShiftIndex[marketIndex] += 1;    emit SyntheticTokensShifted(); }  // Time delta is fetched twice in below code, can pass through? Which is less gas? if (_calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(marketIndex) &gt; 0) {   _setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot(     marketIndex,     longPrice,     shortPrice,     longValue,     shortValue   ); }  } /╔═══════════════════════════════════╗     ║    USER REWARD STATE FUNCTIONS    ║     ╚═══════════════════════════════════╝/ /// @dev Calculates the accumulated float in a specific range of staker snapshots   function _calculateAccumulatedFloatInRange(     uint32 marketIndex,     uint256 amountStakedLong,     uint256 amountStakedShort,     uint256 rewardIndexFrom,     uint256 rewardIndexTo   ) internal view virtual returns (uint256 floatReward) {     if (amountStakedLong &gt; 0) {       uint256 accumDeltaLong = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexTo]       .accumulativeFloatPerSyntheticToken_long -         accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexFrom]         .accumulativeFloatPerSyntheticToken_long;       floatReward += (accumDeltaLong * amountStakedLong) / FLOAT_ISSUANCE_FIXED_DECIMAL;     } if (amountStakedShort &gt; 0) {   uint256 accumDeltaShort = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexTo]   .accumulativeFloatPerSyntheticToken_short -     accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexFrom]     .accumulativeFloatPerSyntheticToken_short;   floatReward += (accumDeltaShort * amountStakedShort) / FLOAT_ISSUANCE_FIXED_DECIMAL; }  } /*    @notice Calculates float owed to the user since the user last minted float for a market.   @param marketIndex Identifier for the market which the user staked in.   @param user The address of the user.   @return floatReward The amount of float owed.    /   function _calculateAccumulatedFloat(uint32 marketIndex, address user) internal virtual returns (uint256 floatReward) {     address longToken = syntheticTokens[marketIndex][true];     address shortToken = syntheticTokens[marketIndex][false]; uint256 amountStakedLong = userAmountStaked[longToken][user]; uint256 amountStakedShort = userAmountStaked[shortToken][user];  uint256 usersLastRewardIndex = userIndexOfLastClaimedReward[marketIndex][user];  // Don't do the calculation and return zero immediately if there is no change if (usersLastRewardIndex == latestRewardIndex[marketIndex]) {   return 0; }  uint256 usersShiftIndex = userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][user]; // if there is a change in the users tokens held due to a token shift (or possibly another action in the future) if (usersShiftIndex &gt; 0 &amp;&amp; usersShiftIndex &lt; batched_stakerNextTokenShiftIndex[marketIndex]) {   floatReward = _calculateAccumulatedFloatInRange(     marketIndex,     amountStakedLong,     amountStakedShort,     usersLastRewardIndex,     stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[usersShiftIndex]   );    // Update the users balances   if (userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user] &gt; 0) {     amountStakedShort += ILongShort(longShort).getAmountSyntheticTokenToMintOnTargetSide(       marketIndex,       userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user],       true,       stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[usersShiftIndex]     );      amountStakedLong -= userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user];     userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user] = 0;   }    if (userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user] &gt; 0) {     amountStakedLong += ILongShort(longShort).getAmountSyntheticTokenToMintOnTargetSide(       marketIndex,       userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user],       false,       stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[usersShiftIndex]     );      amountStakedShort -= userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user];     userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user] = 0;   }    // Save the users updated staked amounts   userAmountStaked[longToken][user] = amountStakedLong;   userAmountStaked[shortToken][user] = amountStakedShort;    floatReward += _calculateAccumulatedFloatInRange(     marketIndex,     amountStakedLong,     amountStakedShort,     stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[usersShiftIndex],     latestRewardIndex[marketIndex]   );    userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][user] = 0; } else {   floatReward = _calculateAccumulatedFloatInRange(     marketIndex,     amountStakedLong,     amountStakedShort,     usersLastRewardIndex,     latestRewardIndex[marketIndex]   ); }  } /*   @notice Mints float for a user.   @dev Mints a fixed percentage for Float capital.   @param user The address of the user.   @param floatToMint The amount of float to mint.    /   function _mintFloat(address user, uint256 floatToMint) internal virtual {     IFloatToken(floatToken).mint(user, floatToMint);     IFloatToken(floatToken).mint(floatCapital, (floatToMint * floatPercentage) / 1e18);   } /*   @notice Mints float owed to a user for a market since they last minted.   @param marketIndex An identifier for the market.   @param user The address of the user.    /   function _mintAccumulatedFloat(uint32 marketIndex, address user) internal virtual {     uint256 floatToMint = _calculateAccumulatedFloat(marketIndex, user); if (floatToMint &gt; 0) {   // Set the user has claimed up until now, stops them setting this forward   userIndexOfLastClaimedReward[marketIndex][user] = latestRewardIndex[marketIndex];    _mintFloat(user, floatToMint);   emit FloatMinted(user, marketIndex, floatToMint); }  } /*   @notice Mints float owed to a user for multiple markets, since they last minted for those markets.   @param marketIndexes Identifiers for the markets.   @param user The address of the user.    /   function _mintAccumulatedFloatMulti(uint32[] calldata marketIndexes, address user) internal virtual {     uint256 floatTotal = 0;     for (uint256 i = 0; i &lt; marketIndexes.length; i++) {       uint256 floatToMint = _calculateAccumulatedFloat(marketIndexes[i], user);   if (floatToMint &gt; 0) {     // Set the user has claimed up until now, stops them setting this forward     userIndexOfLastClaimedReward[marketIndexes[i]][user] = latestRewardIndex[marketIndexes[i]];      floatTotal += floatToMint;      emit FloatMinted(user, marketIndexes[i], floatToMint);   } } if (floatTotal &gt; 0) {   _mintFloat(user, floatTotal); }  } /*   @notice Mints outstanding float for msg.sender.   @param marketIndexes Identifiers for the markets for which to mint float.    /   function claimFloatCustom(uint32[] calldata marketIndexes) external {     ILongShort(longShort).updateSystemStateMulti(marketIndexes);     _mintAccumulatedFloatMulti(marketIndexes, msg.sender);   } /*   @notice Mints outstanding float on behalf of another user.   @param marketIndexes Identifiers for the markets for which to mint float.   @param user The address of the user.    /   function claimFloatCustomFor(uint32[] calldata marketIndexes, address user) external {     // Unbounded loop - users are responsible for paying their own gas costs on these and it doesn't effect the rest of the system.     // No need to impose limit.     ILongShort(longShort).updateSystemStateMulti(marketIndexes);     _mintAccumulatedFloatMulti(marketIndexes, user);   } /╔═══════════════════════╗     ║        STAKING        ║     ╚═══════════════════════╝/ /*   @notice A user with synthetic tokens stakes by calling stake on the token   contract which calls this function. We need to first update the   state of the LongShort contract for this market before staking to correctly calculate user rewards.   @param amount Amount to stake.   @param from Address to stake for.   /   function stakeFromUser(address from, uint256 amount) public virtual override onlyValidSynthetic((msg.sender)) {     ILongShort(longShort).updateSystemState(marketIndexOfToken[(msg.sender)]);     _stake((msg.sender), amount, from);   } /*   @dev Internal logic for staking.   @param token Address of the token for which to stake.   @param amount Amount to stake.   @param user Address to stake for.   /   function _stake(     address token,     uint256 amount,     address user   ) internal virtual {     uint32 marketIndex = marketIndexOfToken[token]; // If they already have staked and have rewards due, mint these. if (   userIndexOfLastClaimedReward[marketIndex][user] != 0 &amp;&amp;   userIndexOfLastClaimedReward[marketIndex][user] &lt; latestRewardIndex[marketIndex] ) {   _mintAccumulatedFloat(marketIndex, user); }  userAmountStaked[token][user] = userAmountStaked[token][user] + amount;  userIndexOfLastClaimedReward[marketIndex][user] = latestRewardIndex[marketIndex];  emit StakeAdded(user, address(token), amount, userIndexOfLastClaimedReward[marketIndex][user]);  } /*   @notice Allows users to shift their staked tokens from one side of the market to    the other at the next price.   @param amountSyntheticTokensToShift Amount of tokens to shift.   @param marketIndex Identifier for the market.   @param isShiftFromLong Whether the shift is from long to short or short to long.   /   function shiftTokens(     uint256 amountSyntheticTokensToShift,     uint32 marketIndex,     bool isShiftFromLong   ) external virtual {     address token = syntheticTokens[marketIndex][isShiftFromLong];     require(userAmountStaked[token][msg.sender] &gt;= amountSyntheticTokensToShift, "Not enough tokens to shift"); // If the user has outstanding token shift that have already been confirmed in the LongShort // contract, execute them first. if (   userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] != 0 &amp;&amp;   userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] &lt;   batched_stakerNextTokenShiftIndex[marketIndex] ) {   _mintAccumulatedFloat(marketIndex, msg.sender); }  if (isShiftFromLong) {   ILongShort(longShort).shiftPositionFromLongNextPrice(marketIndex, amountSyntheticTokensToShift);   userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][     msg.sender   ] += amountSyntheticTokensToShift; } else {   ILongShort(longShort).shiftPositionFromShortNextPrice(marketIndex, amountSyntheticTokensToShift);   userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][     msg.sender   ] += amountSyntheticTokensToShift; }  userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] = batched_stakerNextTokenShiftIndex[   marketIndex ];  } /╔════════════════════════════╗     ║    WITHDRAWAL &amp; MINTING    ║     ╚════════════════════════════╝/ /*   @notice Internal logic for withdrawing stakes.   @dev Mint user any outstanding float before withdrawing.   @param marketIndex Market index of token.   @param amount Amount to withdraw.   @param token Synthetic token that was staked.   /   function _withdraw(     uint32 marketIndex,     address token,     uint256 amount   ) internal virtual {     require(userAmountStaked[token][msg.sender] &gt; 0, "nothing to withdraw");     _mintAccumulatedFloat(marketIndex, msg.sender); userAmountStaked[token][msg.sender] = userAmountStaked[token][msg.sender] - amount;  uint256 amountFees = (amount * marketUnstakeFee_e18[marketIndex]) / 1e18;  IERC20(token).transfer(floatTreasury, amountFees); IERC20(token).transfer(msg.sender, amount - amountFees);  emit StakeWithdrawn(msg.sender, token, amount);  } /*   @notice Withdraw function. Allows users to unstake.   @param amount Amount to withdraw.   @param token Address of the token for which to withdraw.   /   function withdraw(address token, uint256 amount) external {     ILongShort(longShort).updateSystemState(marketIndexOfToken[token]); uint32 marketIndex = marketIndexOfToken[token];  _withdraw(marketIndex, token, amount);  if (userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] &gt; 0) {   // If they still have outstanding shifts after minting float, then check   // that they don't withdraw more than their shifts allow.   uint256 amountToShiftForThisToken = syntheticTokens[marketIndex][true] == token     ? userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][msg.sender]     : userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][msg.sender];    require(     userAmountStaked[token][msg.sender] &gt;= amountToShiftForThisToken,     "Outstanding next price stake shifts too great"   ); }  } /*   @notice Allows users to withdraw their entire stake for a token.   @param token Address of the token for which to withdraw.   /   function withdrawAll(address token) external {     ILongShort(longShort).updateSystemState(marketIndexOfToken[token]); uint32 marketIndex = marketIndexOfToken[token];  uint256 amountToShiftForThisToken = syntheticTokens[marketIndex][true] == token   ? userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][msg.sender]   : userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][msg.sender];  _withdraw(marketIndex, token, userAmountStaked[token][msg.sender] - amountToShiftForThisToken);  } } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: "{task}". Ideas: "{ideas}". As the {assistant_role}, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability. For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix. Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: " Analysis Complete." |
| **phase_name** | ContractReviewComment |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 2, 'task': '// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.3;\n\nimport "@openzeppelin/contracts-upgradeable/token/ERC20/presets/ERC20PresetMinterPauserUpgradeable.sol";\n\nimport "./interfaces/IFloatToken.sol";\nimport "./interfaces/ILongShort.sol";\nimport "./interfaces/IStaker.sol";\nimport "./interfaces/ISyntheticToken.sol";\n\ncontract Staker is IStaker, Initializable {\n  /╔═════════════════════════════╗\n    ║          VARIABLES          ║\n    ╚═════════════════════════════╝/\n\n  / ══════ Fixed-precision constants ══════ /\n  uint256 public constant FLOAT_ISSUANCE_FIXED_DECIMAL = 1e42;\n  // 2^52 ~= 4.5e15\n  // With an exponent of 5, the largest total liquidity possible in a market (to avoid integer overflow on exponentiation) is ~10^31 or 10 Trillion (10^13)\n  // NOTE: this also means if the total market value is less than 2^52 there will be a division by zero error\n  uint256 public constant safeExponentBitShifting = 52;\n\n  / ══════ Global state ══════ /\n  address public admin;\n  address public floatCapital;\n  address public floatTreasury;\n  uint256 public floatPercentage;\n\n  address public longShort;\n  address public floatToken;\n\n  / ══════ Market specific ══════ /\n  mapping(uint32 =&gt; uint256) public marketLaunchIncentive_period; // seconds\n  mapping(uint32 =&gt; uint256) public marketLaunchIncentive_multipliers; // e18 scale\n  mapping(uint32 =&gt; uint256) public marketUnstakeFee_e18;\n  mapping(uint32 =&gt; uint256) public balanceIncentiveCurve_exponent;\n  mapping(uint32 =&gt; int256) public balanceIncentiveCurve_equilibriumOffset;\n\n  mapping(uint32 =&gt; mapping(bool =&gt; address)) public syntheticTokens;\n\n  mapping(address =&gt; uint32) public marketIndexOfToken;\n\n  / ══════ Reward specific ══════ /\n  mapping(uint32 =&gt; uint256) public latestRewardIndex;\n  mapping(uint32 =&gt; mapping(uint256 =&gt; AccumulativeIssuancePerStakedSynthSnapshot))\n    public accumulativeFloatPerSyntheticTokenSnapshots;\n  struct AccumulativeIssuancePerStakedSynthSnapshot {\n    uint256 timestamp;\n    uint256 accumulativeFloatPerSyntheticToken_long;\n    uint256 accumulativeFloatPerSyntheticToken_short;\n  }\n\n  / ══════ User specific ══════ /\n  mapping(uint32 =&gt; mapping(address =&gt; uint256)) public userIndexOfLastClaimedReward;\n  mapping(address =&gt; mapping(address =&gt; uint256)) public userAmountStaked;\n\n  / ══════ Token shift management specific ══════ /\n  mapping(uint32 =&gt; uint256) public batched_stakerNextTokenShiftIndex;\n  /\n  @notice Used to link a token shift to a staker state\n  @dev tokenShiftIndex =&gt; accumulativeFloatIssuanceSnapshotIndex\n    POSSIBLE OPTIMIZATION - could pack stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping and stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping into a struct of two uint128 for storage space optimization.\n  /\n  mapping(uint256 =&gt; uint256) public stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping;\n  /// @notice Used to fetch the price from LongShort at that point in time\n  /// @dev tokenShiftIndex =&gt; longShortMarketPriceSnapshotIndex\n  mapping(uint256 =&gt; uint256) public stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping;\n  /// @dev marketIndex =&gt; usersAddress =&gt; stakerTokenShiftIndex\n  mapping(uint32 =&gt; mapping(address =&gt; uint256)) public userNextPrice_stakedSyntheticTokenShiftIndex;\n  /// @dev marketIndex =&gt; usersAddress =&gt; amountUserRequestedToShiftAwayFromLongOnNextUpdate\n  mapping(uint32 =&gt; mapping(address =&gt; uint256)) public userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long;\n  /// @dev marketIndex =&gt; usersAddress =&gt; amountUserRequestedToShiftAwayFromShortOnNextUpdate\n  mapping(uint32 =&gt; mapping(address =&gt; uint256)) public userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short;\n\n  /╔════════════════════════════╗\n    ║           EVENTS           ║\n    ╚════════════════════════════╝/\n\n  event StakerV1(\n    address admin,\n    address floatTreasury,\n    address floatCapital,\n    address floatToken,\n    uint256 floatPercentage\n  );\n\n  event MarketAddedToStaker(\n    uint32 marketIndex,\n    uint256 exitFee_e18,\n    uint256 period,\n    uint256 multiplier,\n    uint256 balanceIncentiveExponent,\n    int256 balanceIncentiveEquilibriumOffset\n  );\n\n  event AccumulativeIssuancePerStakedSynthSnapshotCreated(\n    uint32 marketIndex,\n    uint256 accumulativeFloatIssuanceSnapshotIndex,\n    uint256 accumulativeLong,\n    uint256 accumulativeShort\n  );\n\n  event StakeAdded(address user, address token, uint256 amount, uint256 lastMintIndex);\n\n  event StakeWithdrawn(address user, address token, uint256 amount);\n\n  // Note: the amountFloatMinted isn\'t strictly needed by the graph, but it is good to add it to validate calculations are accurate.\n  event FloatMinted(address user, uint32 marketIndex, uint256 amountFloatMinted);\n\n  event MarketLaunchIncentiveParametersChanges(uint32 marketIndex, uint256 period, uint256 multiplier);\n\n  event StakeWithdrawalFeeUpdated(uint32 marketIndex, uint256 stakeWithdralFee);\n\n  event BalanceIncentiveExponentUpdated(uint32 marketIndex, uint256 balanceIncentiveExponent);\n\n  event BalanceIncentiveEquilibriumOffsetUpdated(uint32 marketIndex, int256 balanceIncentiveEquilibriumOffset);\n\n  event FloatPercentageUpdated(uint256 floatPercentage);\n\n  event SyntheticTokensShifted();\n\n  event ChangeAdmin(address newAdmin);\n\n  /╔═════════════════════════════╗\n    ║          MODIFIERS          ║\n    ╚═════════════════════════════╝/\n\n  function onlyAdminModifierLogic() internal virtual {\n    require(msg.sender == admin, "not admin");\n  }\n\n  modifier onlyAdmin() {\n    onlyAdminModifierLogic();\n    ;\n  }\n\n  function onlyValidSyntheticModifierLogic(address _synth) internal virtual {\n    require(marketIndexOfToken[_synth] != 0, "not valid synth");\n  }\n\n  modifier onlyValidSynthetic(address _synth) {\n    onlyValidSyntheticModifierLogic(_synth);\n    ;\n  }\n\n  function onlyValidMarketModifierLogic(uint32 marketIndex) internal virtual {\n    require(address(syntheticTokens[marketIndex][true]) != address(0), "not valid market");\n  }\n\n  modifier onlyValidMarket(uint32 marketIndex) {\n    onlyValidMarketModifierLogic(marketIndex);\n    ;\n  }\n\n  function onlyLongShortModifierLogic() internal virtual {\n    require(msg.sender == address(longShort), "not long short");\n  }\n\n  modifier onlyLongShort() {\n    onlyLongShortModifierLogic();\n    ;\n  }\n\n  /╔═════════════════════════════╗\n    ║       CONTRACT SET-UP       ║\n    ╚═════════════════════════════╝*/\n\n  /\n  @notice Initializes the contract.\n  @dev Calls OpenZeppelin\'s initializer modifier.\n  @param _admin Address of the admin role.\n  @param _longShort Address of the LongShort contract, a deployed LongShort.sol\n  @param _floatToken Address of the Float token earned by staking.\n  @param _floatTreasury Address of the treasury contract for managing fees.\n  @param _floatCapital Address of the contract which earns a fixed percentage of Float.\n  @param _floatPercentage Determines the float percentage that gets minted for Float Capital, base 1e18.\n  /\n  function initialize(\n    address _admin,\n    address _longShort,\n    address _floatToken,\n    address _floatTreasury,\n    address _floatCapital,\n    uint256 _floatPercentage\n  ) external virtual initializer {\n    admin = _admin;\n    floatCapital = _floatCapital;\n    floatTreasury = _floatTreasury;\n    longShort = _longShort;\n    floatToken = _floatToken;\n\n    _changeFloatPercentage(_floatPercentage);\n\n    emit StakerV1(_admin, _floatTreasury, _floatCapital, _floatToken, _floatPercentage);\n  }\n\n  /╔═══════════════════╗\n    ║       ADMIN       ║\n    ╚═══════════════════╝/\n\n  / \n  @notice Changes admin for the contract\n  @param _admin The address of the new admin.\n  /\n  function changeAdmin(address _admin) external onlyAdmin {\n    admin = _admin;\n    emit ChangeAdmin(_admin);\n  }\n\n  /// @dev Logic for changeFloatPercentage\n  function _changeFloatPercentage(uint256 newFloatPercentage) internal virtual {\n    require(newFloatPercentage &lt;= 1e18 &amp;&amp; newFloatPercentage &gt; 0); // less than or equal to 100% and greater than 0%\n    floatPercentage = newFloatPercentage;\n  }\n\n  /\n  @notice Changes percentage of float that is minted for float capital.\n  @param newFloatPercentage The new float percentage in base 1e18.\n  */\n  function changeFloatPercentage(uint256 newFloatPercentage) external onlyAdmin {\n    _changeFloatPercentage(newFloatPercentage);\n    emit FloatPercentageUpdated(newFloatPercentage);\n  }\n\n  /// @dev Logic for changeUnstakeFee\n  function _changeUnstakeFee(uint32 marketIndex, uint256 newMarketUnstakeFee_e18) internal virtual {\n    require(newMarketUnstakeFee_e18 &lt;= 5e16); // Explicitely stating 5% fee as the max fee possible.\n    marketUnstakeFee_e18[marketIndex] = newMarketUnstakeFee_e18;\n  }\n\n  /\n  @notice Changes unstake fee for a market\n  @param marketIndex Identifies the market.\n  @param newMarketUnstakeFee_e18 The new unstake fee.\n  /\n  function changeUnstakeFee(uint32 marketIndex, uint256 newMarketUnstakeFee_e18) external onlyAdmin {\n    _changeUnstakeFee(marketIndex, newMarketUnstakeFee_e18);\n    emit StakeWithdrawalFeeUpdated(marketIndex, newMarketUnstakeFee_e18);\n  }\n\n  /// @dev Logic for changeMarketLaunchIncentiveParameters\n  function _changeMarketLaunchIncentiveParameters(\n    uint32 marketIndex,\n    uint256 period,\n    uint256 initialMultiplier\n  ) internal virtual {\n    require(initialMultiplier &gt;= 1e18, "marketLaunchIncentiveMultiplier must be &gt;= 1e18");\n\n    marketLaunchIncentive_period[marketIndex] = period;\n    marketLaunchIncentive_multipliers[marketIndex] = initialMultiplier;\n  }\n\n  /\n  @notice Changes the market launch incentive parameters for a market\n  @param marketIndex Identifies the market.\n  @param period The new period for which float token generation should be boosted.\n  @param initialMultiplier The new multiplier on Float generation.\n  /\n  function changeMarketLaunchIncentiveParameters(\n    uint32 marketIndex,\n    uint256 period,\n    uint256 initialMultiplier\n  ) external onlyAdmin {\n    _changeMarketLaunchIncentiveParameters(marketIndex, period, initialMultiplier);\n\n    emit MarketLaunchIncentiveParametersChanges(marketIndex, period, initialMultiplier);\n  }\n\n  /// @dev Logic for changeBalanceIncentiveExponent\n  function _changeBalanceIncentiveExponent(uint32 marketIndex, uint256 _balanceIncentiveCurve_exponent)\n    internal\n    virtual\n  {\n    require(\n      // The exponent has to be less than 5 in these versions of the contracts.\n      _balanceIncentiveCurve_exponent &gt; 0 &amp;&amp; _balanceIncentiveCurve_exponent &lt; 6,\n      "balanceIncentiveCurve_exponent out of bounds"\n    );\n\n    balanceIncentiveCurve_exponent[marketIndex] = _balanceIncentiveCurve_exponent;\n  }\n\n  / \n  @notice Changes the balance incentive exponent for a market\n  @param marketIndex Identifies the market.\n  @param _balanceIncentiveCurve_exponent The new exponent for the curve.\n  */\n  function changeBalanceIncentiveExponent(uint32 marketIndex, uint256 _balanceIncentiveCurve_exponent)\n    external\n    onlyAdmin\n  {\n    _changeBalanceIncentiveExponent(marketIndex, _balanceIncentiveCurve_exponent);\n\n    emit BalanceIncentiveExponentUpdated(marketIndex, _balanceIncentiveCurve_exponent);\n  }\n\n  /// @dev Logic for changeBalanceIncentiveEquilibriumOffset\n  function _changeBalanceIncentiveEquilibriumOffset(uint32 marketIndex, int256 _balanceIncentiveCurve_equilibriumOffset)\n    internal\n    virtual\n  {\n    // Unreasonable that we would ever shift this more than 90% either way\n    require(\n      _balanceIncentiveCurve_equilibriumOffset &gt; -9e17 &amp;&amp; _balanceIncentiveCurve_equilibriumOffset &lt; 9e17,\n      "balanceIncentiveCurve_equilibriumOffset out of bounds"\n    );\n\n    balanceIncentiveCurve_equilibriumOffset[marketIndex] = _balanceIncentiveCurve_equilibriumOffset;\n  }\n\n  /\n  @notice Changes the balance incentive curve equilibrium offset for a market\n  @param marketIndex Identifies the market.\n  @param _balanceIncentiveCurve_equilibriumOffset The new offset.\n  /\n  function changeBalanceIncentiveEquilibriumOffset(uint32 marketIndex, int256 _balanceIncentiveCurve_equilibriumOffset)\n    external\n    onlyAdmin\n  {\n    _changeBalanceIncentiveEquilibriumOffset(marketIndex, _balanceIncentiveCurve_equilibriumOffset);\n\n    emit BalanceIncentiveEquilibriumOffsetUpdated(marketIndex, _balanceIncentiveCurve_equilibriumOffset);\n  }\n\n  /╔═════════════════════════════╗\n    ║        STAKING SETUP        ║\n    ╚═════════════════════════════╝/\n\n  /\n  @notice Sets this contract to track staking for a market in LongShort.sol\n  @param marketIndex Identifies the market.\n  @param longToken Address of the long token for the market.\n  @param shortToken Address of the short token for the market.\n  @param kInitialMultiplier Initial boost on float generation for the market.\n  @param kPeriod Period which the boost should last.\n  @param unstakeFee_e18 Percentage of tokens that are levied on unstaking in base 1e18.\n  @param _balanceIncentiveCurve_exponent Exponent for balance curve (see _calculateFloatPerSecond)\n  @param _balanceIncentiveCurve_equilibriumOffset Offset for balance curve (see _calculateFloatPerSecond)\n  /\n  function addNewStakingFund(\n    uint32 marketIndex,\n    address longToken,\n    address shortToken,\n    uint256 kInitialMultiplier,\n    uint256 kPeriod,\n    uint256 unstakeFee_e18,\n    uint256 _balanceIncentiveCurve_exponent,\n    int256 _balanceIncentiveCurve_equilibriumOffset\n  ) external override onlyLongShort {\n    marketIndexOfToken[longToken] = marketIndex;\n    marketIndexOfToken[shortToken] = marketIndex;\n\n    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].timestamp = block.timestamp;\n    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].accumulativeFloatPerSyntheticToken_long = 0;\n    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].accumulativeFloatPerSyntheticToken_short = 0;\n\n    syntheticTokens[marketIndex][true] = longToken;\n    syntheticTokens[marketIndex][false] = shortToken;\n\n    _changeBalanceIncentiveExponent(marketIndex, _balanceIncentiveCurve_exponent);\n    _changeBalanceIncentiveEquilibriumOffset(marketIndex, _balanceIncentiveCurve_equilibriumOffset);\n    _changeMarketLaunchIncentiveParameters(marketIndex, kPeriod, kInitialMultiplier);\n\n    _changeUnstakeFee(marketIndex, unstakeFee_e18);\n\n    // Set this value to one initially - 0 is a null value and thus potentially bug prone.\n    batched_stakerNextTokenShiftIndex[marketIndex] = 1;\n\n    emit MarketAddedToStaker(\n      marketIndex,\n      unstakeFee_e18,\n      kPeriod,\n      kInitialMultiplier,\n      _balanceIncentiveCurve_exponent,\n      _balanceIncentiveCurve_equilibriumOffset\n    );\n\n    emit AccumulativeIssuancePerStakedSynthSnapshotCreated(marketIndex, 0, 0, 0);\n  }\n\n  /╔═════════════════════════════════════════════════════════════════════════╗\n    ║    GLOBAL FLT REWARD ACCUMULATION CALCULATION AND TRACKING FUNCTIONS    ║\n    ╚═════════════════════════════════════════════════════════════════════════╝/\n\n  /\n  @notice Returns the K factor parameters for the given market with sensible\n  defaults if they haven\'t been set yet.\n  @param marketIndex The market to change the parameters for.\n  @return period The period for which the k factor applies for in seconds.\n  @return multiplier The multiplier on Float generation in this period.\n  */\n  function _getMarketLaunchIncentiveParameters(uint32 marketIndex)\n    internal\n    view\n    virtual\n    returns (uint256 period, uint256 multiplier)\n  {\n    period = marketLaunchIncentive_period[marketIndex];\n    multiplier = marketLaunchIncentive_multipliers[marketIndex];\n\n    if (multiplier &lt; 1e18) {\n      multiplier = 1e18; // multiplier of 1 by default\n    }\n  }\n\n  / \n  @notice Returns the extent to which a markets float generation should be adjusted\n  based on the market\'s launch incentive parameters. Should start at multiplier\n  then linearly change to 1e18 over time.\n  @param marketIndex Identifies the market.\n  @return k The calculated modifier for float generation.\n  /\n  function _getKValue(uint32 marketIndex) internal view virtual returns (uint256) {\n    // Parameters controlling the float issuance multiplier.\n    (uint256 kPeriod, uint256 kInitialMultiplier) = _getMarketLaunchIncentiveParameters(marketIndex);\n\n    // Sanity check - under normal circumstances, the multipliers should\n    // never be set to a value &lt; 1e18, as there are guards against this.\n    assert(kInitialMultiplier &gt;= 1e18);\n\n    uint256 initialTimestamp = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].timestamp;\n\n    if (block.timestamp - initialTimestamp &lt;= kPeriod) {\n      return kInitialMultiplier - (((kInitialMultiplier - 1e18) * (block.timestamp - initialTimestamp)) / kPeriod);\n    } else {\n      return 1e18;\n    }\n  }\n\n  /\n  @notice Computes the number of float tokens a user earns per second for\n  every long/short synthetic token they\'ve staked. The returned value has\n  a fixed decimal scale of 1e42 (!!!) for numerical stability. The return\n  values are float per second per synthetic token (hence the requirement\n  to multiply by price)\n  @dev to see below math in latex form see TODO add link\n  to interact with the equations see https://www.desmos.com/calculator/optkaxyihr\n  @param marketIndex The market referred to.\n  @param longPrice Price of the synthetic long token in units of payment token\n  @param shortPrice Price of the synthetic short token in units of payment token\n  @param longValue Amount of payment token in the long side of the market\n  @param shortValue Amount of payment token in the short side of the market\n  @return longFloatPerSecond Float token per second per long synthetic token\n  @return shortFloatPerSecond Float token per second per short synthetic token\n   /\n  function _calculateFloatPerSecond(\n    uint32 marketIndex,\n    uint256 longPrice,\n    uint256 shortPrice,\n    uint256 longValue,\n    uint256 shortValue\n  ) internal view virtual returns (uint256 longFloatPerSecond, uint256 shortFloatPerSecond) {\n    // A float issuance multiplier that starts high and decreases linearly\n    // over time to a value of 1. This incentivises users to stake early.\n    uint256 k = _getKValue(marketIndex);\n\n    uint256 totalLocked = (longValue + shortValue);\n\n    // we need to scale this number by the totalLocked so that the offset remains consistent accross market size\n\n    int256 equilibriumOffsetMarketScaled = (balanceIncentiveCurve_equilibriumOffset[marketIndex] \n      int256(totalLocked)) / 2e18;\n\n    uint256 denominator = ((totalLocked &gt;&gt; safeExponentBitShifting)balanceIncentiveCurve_exponent[marketIndex]);\n\n    // Float is scaled by the percentage of the total market value held in\n    // the opposite position. This incentivises users to stake on the\n    // weaker position.\n    if (int256(shortValue) - equilibriumOffsetMarketScaled &lt; int256(longValue)) {\n      if (equilibriumOffsetMarketScaled &gt;= int256(shortValue)) {\n        // edge case: imbalanced far past the equilibrium offset - full rewards go to short token\n        //            extremeley unlikely to happen in practice\n        return (0, 1e18 * k * shortPrice);\n      }\n\n      uint256 numerator = (uint256(int256(shortValue) - equilibriumOffsetMarketScaled) &gt;&gt;\n        (safeExponentBitShifting - 1))balanceIncentiveCurve_exponent[marketIndex];\n\n      // NOTE: x * 5e17 == (x * 10e18) / 2\n      uint256 longRewardUnscaled = (numerator * 5e17) / denominator;\n      uint256 shortRewardUnscaled = 1e18 - longRewardUnscaled;\n\n      return ((longRewardUnscaled * k * longPrice) / 1e18, (shortRewardUnscaled * k * shortPrice) / 1e18);\n    } else {\n      if (-equilibriumOffsetMarketScaled &gt;= int256(longValue)) {\n        // edge case: imbalanced far past the equilibrium offset - full rewards go to long token\n        //            extremeley unlikely to happen in practice\n        return (1e18 * k * longPrice, 0);\n      }\n\n      uint256 numerator = (uint256(int256(longValue) + equilibriumOffsetMarketScaled) &gt;&gt;\n        (safeExponentBitShifting - 1))balanceIncentiveCurve_exponent[marketIndex];\n\n      // NOTE: x * 5e17 == (x * 10e18) / 2\n      uint256 shortRewardUnscaled = (numerator * 5e17) / denominator;\n      uint256 longRewardUnscaled = 1e18 - shortRewardUnscaled;\n\n      return ((longRewardUnscaled * k * longPrice) / 1e18, (shortRewardUnscaled * k * shortPrice) / 1e18);\n    }\n  }\n\n  /\n  @notice Computes the time since last accumulativeIssuancePerStakedSynthSnapshot for the given market in seconds.\n  @param marketIndex The market referred to.\n  @return The time difference in seconds\n  /\n  function _calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(uint32 marketIndex)\n    internal\n    view\n    virtual\n    returns (uint256)\n  {\n    return\n      block.timestamp -\n      accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]].timestamp;\n  }\n\n  /\n  @notice Computes new cumulative sum of \'r\' value since last accumulativeIssuancePerStakedSynthSnapshot. We use\n  cumulative \'r\' value to avoid looping during issuance. Note that the\n  cumulative sum is kept in 1e42 scale (!!!) to avoid numerical issues.\n  @param shortValue The value locked in the short side of the market.\n  @param longValue The value locked in the long side of the market.\n  @param shortPrice The price of the short token as defined in LongShort.sol\n  @param longPrice The price of the long token as defined in LongShort.sol\n  @param marketIndex An identifier for the market.\n  @return longCumulativeRates The long cumulative sum.\n  @return shortCumulativeRates The short cumulative sum.\n  /\n  function _calculateNewCumulativeIssuancePerStakedSynth(\n    uint32 marketIndex,\n    uint256 longPrice,\n    uint256 shortPrice,\n    uint256 longValue,\n    uint256 shortValue\n  ) internal view virtual returns (uint256 longCumulativeRates, uint256 shortCumulativeRates) {\n    // Compute the current \'r\' value for float issuance per second.\n    (uint256 longFloatPerSecond, uint256 shortFloatPerSecond) = _calculateFloatPerSecond(\n      marketIndex,\n      longPrice,\n      shortPrice,\n      longValue,\n      shortValue\n    );\n\n    // Compute time since last accumulativeIssuancePerStakedSynthSnapshot for the given token.\n    uint256 timeDelta = _calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(marketIndex);\n\n    // Compute new cumulative \'r\' value total.\n    return (\n      accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]]\n      .accumulativeFloatPerSyntheticToken_long + (timeDelta * longFloatPerSecond),\n      accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]]\n      .accumulativeFloatPerSyntheticToken_short + (timeDelta * shortFloatPerSecond)\n    );\n  }\n\n  /\n  @notice Creates a new accumulativeIssuancePerStakedSynthSnapshot for the given token and updates indexes.\n  @param shortValue The value locked in the short side of the market.\n  @param longValue The value locked in the long side of the market.\n  @param shortPrice The price of the short token as defined in LongShort.sol\n  @param longPrice The price of the long token as defined in LongShort.sol\n  @param marketIndex An identifier for the market.\n  */\n  function _setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot(\n    uint32 marketIndex,\n    uint256 longPrice,\n    uint256 shortPrice,\n    uint256 longValue,\n    uint256 shortValue\n  ) internal virtual {\n    (\n      uint256 newLongAccumulativeValue,\n      uint256 newShortAccumulativeValue\n    ) = _calculateNewCumulativeIssuancePerStakedSynth(marketIndex, longPrice, shortPrice, longValue, shortValue);\n\n    uint256 newIndex = latestRewardIndex[marketIndex] + 1;\n\n    // Set cumulative \'r\' value on new accumulativeIssuancePerStakedSynthSnapshot.\n    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex]\n    .accumulativeFloatPerSyntheticToken_long = newLongAccumulativeValue;\n    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex]\n    .accumulativeFloatPerSyntheticToken_short = newShortAccumulativeValue;\n\n    // Set timestamp on new accumulativeIssuancePerStakedSynthSnapshot.\n    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex].timestamp = block.timestamp;\n\n    // Update latest index to point to new accumulativeIssuancePerStakedSynthSnapshot.\n    latestRewardIndex[marketIndex] = newIndex;\n\n    emit AccumulativeIssuancePerStakedSynthSnapshotCreated(\n      marketIndex,\n      newIndex,\n      newLongAccumulativeValue,\n      newShortAccumulativeValue\n    );\n  }\n\n  /\n  @notice Adds new accumulativeIssuancePerStakedSynthSnapshots for the given long/short tokens. Called by the\n  ILongShort contract whenever there is a state change for a market.\n  @param stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted Mapping from this contract\'s shifts to LongShort.sols next price snapshots.\n  @param shortValue The value locked in the short side of the market.\n  @param longValue The value locked in the long side of the market.\n  @param shortPrice The price of the short token as defined in LongShort.sol\n  @param longPrice The price of the long token as defined in LongShort.sol\n  @param marketIndex An identifier for the market.\n  /\n  function pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(\n    uint32 marketIndex,\n    uint256 longPrice,\n    uint256 shortPrice,\n    uint256 longValue,\n    uint256 shortValue,\n    uint256 stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted // This value should be ALWAYS be zero if no shift occured\n  ) external override onlyLongShort {\n    // Only add a new accumulativeIssuancePerStakedSynthSnapshot if some time has passed.\n\n    // the stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted value will be 0 if there is no staker related action in an executed batch\n    if (stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted &gt; 0) {\n      stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[\n        batched_stakerNextTokenShiftIndex[marketIndex]\n      ] = stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted;\n      stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[\n        batched_stakerNextTokenShiftIndex[marketIndex]\n      ] = latestRewardIndex[marketIndex] + 1;\n      batched_stakerNextTokenShiftIndex[marketIndex] += 1;\n\n      emit SyntheticTokensShifted();\n    }\n\n    // Time delta is fetched twice in below code, can pass through? Which is less gas?\n    if (_calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(marketIndex) &gt; 0) {\n      _setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot(\n        marketIndex,\n        longPrice,\n        shortPrice,\n        longValue,\n        shortValue\n      );\n    }\n  }\n\n  /╔═══════════════════════════════════╗\n    ║    USER REWARD STATE FUNCTIONS    ║\n    ╚═══════════════════════════════════╝/\n\n  /// @dev Calculates the accumulated float in a specific range of staker snapshots\n  function _calculateAccumulatedFloatInRange(\n    uint32 marketIndex,\n    uint256 amountStakedLong,\n    uint256 amountStakedShort,\n    uint256 rewardIndexFrom,\n    uint256 rewardIndexTo\n  ) internal view virtual returns (uint256 floatReward) {\n    if (amountStakedLong &gt; 0) {\n      uint256 accumDeltaLong = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexTo]\n      .accumulativeFloatPerSyntheticToken_long -\n        accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexFrom]\n        .accumulativeFloatPerSyntheticToken_long;\n      floatReward += (accumDeltaLong * amountStakedLong) / FLOAT_ISSUANCE_FIXED_DECIMAL;\n    }\n\n    if (amountStakedShort &gt; 0) {\n      uint256 accumDeltaShort = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexTo]\n      .accumulativeFloatPerSyntheticToken_short -\n        accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexFrom]\n        .accumulativeFloatPerSyntheticToken_short;\n      floatReward += (accumDeltaShort * amountStakedShort) / FLOAT_ISSUANCE_FIXED_DECIMAL;\n    }\n  }\n\n  / \n  @notice Calculates float owed to the user since the user last minted float for a market.\n  @param marketIndex Identifier for the market which the user staked in.\n  @param user The address of the user.\n  @return floatReward The amount of float owed.\n   /\n  function _calculateAccumulatedFloat(uint32 marketIndex, address user) internal virtual returns (uint256 floatReward) {\n    address longToken = syntheticTokens[marketIndex][true];\n    address shortToken = syntheticTokens[marketIndex][false];\n\n    uint256 amountStakedLong = userAmountStaked[longToken][user];\n    uint256 amountStakedShort = userAmountStaked[shortToken][user];\n\n    uint256 usersLastRewardIndex = userIndexOfLastClaimedReward[marketIndex][user];\n\n    // Don\'t do the calculation and return zero immediately if there is no change\n    if (usersLastRewardIndex == latestRewardIndex[marketIndex]) {\n      return 0;\n    }\n\n    uint256 usersShiftIndex = userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][user];\n    // if there is a change in the users tokens held due to a token shift (or possibly another action in the future)\n    if (usersShiftIndex &gt; 0 &amp;&amp; usersShiftIndex &lt; batched_stakerNextTokenShiftIndex[marketIndex]) {\n      floatReward = _calculateAccumulatedFloatInRange(\n        marketIndex,\n        amountStakedLong,\n        amountStakedShort,\n        usersLastRewardIndex,\n        stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[usersShiftIndex]\n      );\n\n      // Update the users balances\n      if (userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user] &gt; 0) {\n        amountStakedShort += ILongShort(longShort).getAmountSyntheticTokenToMintOnTargetSide(\n          marketIndex,\n          userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user],\n          true,\n          stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[usersShiftIndex]\n        );\n\n        amountStakedLong -= userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user];\n        userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user] = 0;\n      }\n\n      if (userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user] &gt; 0) {\n        amountStakedLong += ILongShort(longShort).getAmountSyntheticTokenToMintOnTargetSide(\n          marketIndex,\n          userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user],\n          false,\n          stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[usersShiftIndex]\n        );\n\n        amountStakedShort -= userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user];\n        userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user] = 0;\n      }\n\n      // Save the users updated staked amounts\n      userAmountStaked[longToken][user] = amountStakedLong;\n      userAmountStaked[shortToken][user] = amountStakedShort;\n\n      floatReward += _calculateAccumulatedFloatInRange(\n        marketIndex,\n        amountStakedLong,\n        amountStakedShort,\n        stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[usersShiftIndex],\n        latestRewardIndex[marketIndex]\n      );\n\n      userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][user] = 0;\n    } else {\n      floatReward = _calculateAccumulatedFloatInRange(\n        marketIndex,\n        amountStakedLong,\n        amountStakedShort,\n        usersLastRewardIndex,\n        latestRewardIndex[marketIndex]\n      );\n    }\n  }\n\n  /\n  @notice Mints float for a user.\n  @dev Mints a fixed percentage for Float capital.\n  @param user The address of the user.\n  @param floatToMint The amount of float to mint.\n   */\n  function _mintFloat(address user, uint256 floatToMint) internal virtual {\n    IFloatToken(floatToken).mint(user, floatToMint);\n    IFloatToken(floatToken).mint(floatCapital, (floatToMint * floatPercentage) / 1e18);\n  }\n\n  /\n  @notice Mints float owed to a user for a market since they last minted.\n  @param marketIndex An identifier for the market.\n  @param user The address of the user.\n   /\n  function _mintAccumulatedFloat(uint32 marketIndex, address user) internal virtual {\n    uint256 floatToMint = _calculateAccumulatedFloat(marketIndex, user);\n\n    if (floatToMint &gt; 0) {\n      // Set the user has claimed up until now, stops them setting this forward\n      userIndexOfLastClaimedReward[marketIndex][user] = latestRewardIndex[marketIndex];\n\n      _mintFloat(user, floatToMint);\n      emit FloatMinted(user, marketIndex, floatToMint);\n    }\n  }\n\n  /\n  @notice Mints float owed to a user for multiple markets, since they last minted for those markets.\n  @param marketIndexes Identifiers for the markets.\n  @param user The address of the user.\n   /\n  function _mintAccumulatedFloatMulti(uint32[] calldata marketIndexes, address user) internal virtual {\n    uint256 floatTotal = 0;\n    for (uint256 i = 0; i &lt; marketIndexes.length; i++) {\n      uint256 floatToMint = _calculateAccumulatedFloat(marketIndexes[i], user);\n\n      if (floatToMint &gt; 0) {\n        // Set the user has claimed up until now, stops them setting this forward\n        userIndexOfLastClaimedReward[marketIndexes[i]][user] = latestRewardIndex[marketIndexes[i]];\n\n        floatTotal += floatToMint;\n\n        emit FloatMinted(user, marketIndexes[i], floatToMint);\n      }\n    }\n    if (floatTotal &gt; 0) {\n      _mintFloat(user, floatTotal);\n    }\n  }\n\n  /\n  @notice Mints outstanding float for msg.sender.\n  @param marketIndexes Identifiers for the markets for which to mint float.\n   */\n  function claimFloatCustom(uint32[] calldata marketIndexes) external {\n    ILongShort(longShort).updateSystemStateMulti(marketIndexes);\n    _mintAccumulatedFloatMulti(marketIndexes, msg.sender);\n  }\n\n  /\n  @notice Mints outstanding float on behalf of another user.\n  @param marketIndexes Identifiers for the markets for which to mint float.\n  @param user The address of the user.\n   /\n  function claimFloatCustomFor(uint32[] calldata marketIndexes, address user) external {\n    // Unbounded loop - users are responsible for paying their own gas costs on these and it doesn\'t effect the rest of the system.\n    // No need to impose limit.\n    ILongShort(longShort).updateSystemStateMulti(marketIndexes);\n    _mintAccumulatedFloatMulti(marketIndexes, user);\n  }\n\n  /╔═══════════════════════╗\n    ║        STAKING        ║\n    ╚═══════════════════════╝/\n\n  /\n  @notice A user with synthetic tokens stakes by calling stake on the token\n  contract which calls this function. We need to first update the\n  state of the LongShort contract for this market before staking to correctly calculate user rewards.\n  @param amount Amount to stake.\n  @param from Address to stake for.\n  /\n  function stakeFromUser(address from, uint256 amount) public virtual override onlyValidSynthetic((msg.sender)) {\n    ILongShort(longShort).updateSystemState(marketIndexOfToken[(msg.sender)]);\n    _stake((msg.sender), amount, from);\n  }\n\n  /\n  @dev Internal logic for staking.\n  @param token Address of the token for which to stake.\n  @param amount Amount to stake.\n  @param user Address to stake for.\n  */\n  function _stake(\n    address token,\n    uint256 amount,\n    address user\n  ) internal virtual {\n    uint32 marketIndex = marketIndexOfToken[token];\n\n    // If they already have staked and have rewards due, mint these.\n    if (\n      userIndexOfLastClaimedReward[marketIndex][user] != 0 &amp;&amp;\n      userIndexOfLastClaimedReward[marketIndex][user] &lt; latestRewardIndex[marketIndex]\n    ) {\n      _mintAccumulatedFloat(marketIndex, user);\n    }\n\n    userAmountStaked[token][user] = userAmountStaked[token][user] + amount;\n\n    userIndexOfLastClaimedReward[marketIndex][user] = latestRewardIndex[marketIndex];\n\n    emit StakeAdded(user, address(token), amount, userIndexOfLastClaimedReward[marketIndex][user]);\n  }\n\n  /\n  @notice Allows users to shift their staked tokens from one side of the market to \n  the other at the next price.\n  @param amountSyntheticTokensToShift Amount of tokens to shift.\n  @param marketIndex Identifier for the market.\n  @param isShiftFromLong Whether the shift is from long to short or short to long.\n  /\n  function shiftTokens(\n    uint256 amountSyntheticTokensToShift,\n    uint32 marketIndex,\n    bool isShiftFromLong\n  ) external virtual {\n    address token = syntheticTokens[marketIndex][isShiftFromLong];\n    require(userAmountStaked[token][msg.sender] &gt;= amountSyntheticTokensToShift, "Not enough tokens to shift");\n\n    // If the user has outstanding token shift that have already been confirmed in the LongShort\n    // contract, execute them first.\n    if (\n      userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] != 0 &amp;&amp;\n      userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] &lt;\n      batched_stakerNextTokenShiftIndex[marketIndex]\n    ) {\n      _mintAccumulatedFloat(marketIndex, msg.sender);\n    }\n\n    if (isShiftFromLong) {\n      ILongShort(longShort).shiftPositionFromLongNextPrice(marketIndex, amountSyntheticTokensToShift);\n      userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][\n        msg.sender\n      ] += amountSyntheticTokensToShift;\n    } else {\n      ILongShort(longShort).shiftPositionFromShortNextPrice(marketIndex, amountSyntheticTokensToShift);\n      userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][\n        msg.sender\n      ] += amountSyntheticTokensToShift;\n    }\n\n    userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] = batched_stakerNextTokenShiftIndex[\n      marketIndex\n    ];\n  }\n\n  /╔════════════════════════════╗\n    ║    WITHDRAWAL &amp; MINTING    ║\n    ╚════════════════════════════╝/\n\n  /\n  @notice Internal logic for withdrawing stakes.\n  @dev Mint user any outstanding float before withdrawing.\n  @param marketIndex Market index of token.\n  @param amount Amount to withdraw.\n  @param token Synthetic token that was staked.\n  /\n  function _withdraw(\n    uint32 marketIndex,\n    address token,\n    uint256 amount\n  ) internal virtual {\n    require(userAmountStaked[token][msg.sender] &gt; 0, "nothing to withdraw");\n    _mintAccumulatedFloat(marketIndex, msg.sender);\n\n    userAmountStaked[token][msg.sender] = userAmountStaked[token][msg.sender] - amount;\n\n    uint256 amountFees = (amount * marketUnstakeFee_e18[marketIndex]) / 1e18;\n\n    IERC20(token).transfer(floatTreasury, amountFees);\n    IERC20(token).transfer(msg.sender, amount - amountFees);\n\n    emit StakeWithdrawn(msg.sender, token, amount);\n  }\n\n  /\n  @notice Withdraw function. Allows users to unstake.\n  @param amount Amount to withdraw.\n  @param token Address of the token for which to withdraw.\n  */\n  function withdraw(address token, uint256 amount) external {\n    ILongShort(longShort).updateSystemState(marketIndexOfToken[token]);\n\n    uint32 marketIndex = marketIndexOfToken[token];\n\n    _withdraw(marketIndex, token, amount);\n\n    if (userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] &gt; 0) {\n      // If they still have outstanding shifts after minting float, then check\n      // that they don\'t withdraw more than their shifts allow.\n      uint256 amountToShiftForThisToken = syntheticTokens[marketIndex][true] == token\n        ? userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][msg.sender]\n        : userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][msg.sender];\n\n      require(\n        userAmountStaked[token][msg.sender] &gt;= amountToShiftForThisToken,\n        "Outstanding next price stake shifts too great"\n      );\n    }\n  }\n\n  /\n  @notice Allows users to withdraw their entire stake for a token.\n  @param token Address of the token for which to withdraw.\n  */\n  function withdrawAll(address token) external {\n    ILongShort(longShort).updateSystemState(marketIndexOfToken[token]);\n\n    uint32 marketIndex = marketIndexOfToken[token];\n\n    uint256 amountToShiftForThisToken = syntheticTokens[marketIndex][true] == token\n      ? userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][msg.sender]\n      : userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][msg.sender];\n\n    _withdraw(marketIndex, token, userAmountStaked[token][msg.sender] - amountToShiftForThisToken);\n  }\n}\n', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-17-08 08:01:40 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: BUSL-1.1 pragma solidity 0.8.3; import "@openzeppelin/contracts-upgradeable/token/ERC20/presets/ERC20PresetMinterPauserUpgradeable.sol"; import "./interfaces/IFloatToken.sol"; import "./interfaces/ILongShort.sol"; import "./interfaces/IStaker.sol"; import "./interfaces/ISyntheticToken.sol"; contract Staker is IStaker, Initializable {   /╔═════════════════════════════╗     ║          VARIABLES          ║     ╚═════════════════════════════╝/ / ══════ Fixed-precision constants ══════ /   uint256 public constant FLOAT_ISSUANCE_FIXED_DECIMAL = 1e42;   // 2^52 ~= 4.5e15   // With an exponent of 5, the largest total liquidity possible in a market (to avoid integer overflow on exponentiation) is ~10^31 or 10 Trillion (10^13)   // NOTE: this also means if the total market value is less than 2^52 there will be a division by zero error   uint256 public constant safeExponentBitShifting = 52; / ══════ Global state ══════ /   address public admin;   address public floatCapital;   address public floatTreasury;   uint256 public floatPercentage; address public longShort;   address public floatToken; / ══════ Market specific ══════ /   mapping(uint32 =&gt; uint256) public marketLaunchIncentive_period; // seconds   mapping(uint32 =&gt; uint256) public marketLaunchIncentive_multipliers; // e18 scale   mapping(uint32 =&gt; uint256) public marketUnstakeFee_e18;   mapping(uint32 =&gt; uint256) public balanceIncentiveCurve_exponent;   mapping(uint32 =&gt; int256) public balanceIncentiveCurve_equilibriumOffset; mapping(uint32 =&gt; mapping(bool =&gt; address)) public syntheticTokens; mapping(address =&gt; uint32) public marketIndexOfToken; / ══════ Reward specific ══════ /   mapping(uint32 =&gt; uint256) public latestRewardIndex;   mapping(uint32 =&gt; mapping(uint256 =&gt; AccumulativeIssuancePerStakedSynthSnapshot))     public accumulativeFloatPerSyntheticTokenSnapshots;   struct AccumulativeIssuancePerStakedSynthSnapshot {     uint256 timestamp;     uint256 accumulativeFloatPerSyntheticToken_long;     uint256 accumulativeFloatPerSyntheticToken_short;   } / ══════ User specific ══════ /   mapping(uint32 =&gt; mapping(address =&gt; uint256)) public userIndexOfLastClaimedReward;   mapping(address =&gt; mapping(address =&gt; uint256)) public userAmountStaked; / ══════ Token shift management specific ══════ /   mapping(uint32 =&gt; uint256) public batched_stakerNextTokenShiftIndex;   /*   @notice Used to link a token shift to a staker state   @dev tokenShiftIndex =&gt; accumulativeFloatIssuanceSnapshotIndex     POSSIBLE OPTIMIZATION - could pack stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping and stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping into a struct of two uint128 for storage space optimization.   /   mapping(uint256 =&gt; uint256) public stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping;   /// @notice Used to fetch the price from LongShort at that point in time   /// @dev tokenShiftIndex =&gt; longShortMarketPriceSnapshotIndex   mapping(uint256 =&gt; uint256) public stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping;   /// @dev marketIndex =&gt; usersAddress =&gt; stakerTokenShiftIndex   mapping(uint32 =&gt; mapping(address =&gt; uint256)) public userNextPrice_stakedSyntheticTokenShiftIndex;   /// @dev marketIndex =&gt; usersAddress =&gt; amountUserRequestedToShiftAwayFromLongOnNextUpdate   mapping(uint32 =&gt; mapping(address =&gt; uint256)) public userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long;   /// @dev marketIndex =&gt; usersAddress =&gt; amountUserRequestedToShiftAwayFromShortOnNextUpdate   mapping(uint32 =&gt; mapping(address =&gt; uint256)) public userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short; /╔════════════════════════════╗     ║           EVENTS           ║     ╚════════════════════════════╝/ event StakerV1(     address admin,     address floatTreasury,     address floatCapital,     address floatToken,     uint256 floatPercentage   ); event MarketAddedToStaker(     uint32 marketIndex,     uint256 exitFee_e18,     uint256 period,     uint256 multiplier,     uint256 balanceIncentiveExponent,     int256 balanceIncentiveEquilibriumOffset   ); event AccumulativeIssuancePerStakedSynthSnapshotCreated(     uint32 marketIndex,     uint256 accumulativeFloatIssuanceSnapshotIndex,     uint256 accumulativeLong,     uint256 accumulativeShort   ); event StakeAdded(address user, address token, uint256 amount, uint256 lastMintIndex); event StakeWithdrawn(address user, address token, uint256 amount); // Note: the amountFloatMinted isn't strictly needed by the graph, but it is good to add it to validate calculations are accurate.   event FloatMinted(address user, uint32 marketIndex, uint256 amountFloatMinted); event MarketLaunchIncentiveParametersChanges(uint32 marketIndex, uint256 period, uint256 multiplier); event StakeWithdrawalFeeUpdated(uint32 marketIndex, uint256 stakeWithdralFee); event BalanceIncentiveExponentUpdated(uint32 marketIndex, uint256 balanceIncentiveExponent); event BalanceIncentiveEquilibriumOffsetUpdated(uint32 marketIndex, int256 balanceIncentiveEquilibriumOffset); event FloatPercentageUpdated(uint256 floatPercentage); event SyntheticTokensShifted(); event ChangeAdmin(address newAdmin); /╔═════════════════════════════╗     ║          MODIFIERS          ║     ╚═════════════════════════════╝/ function onlyAdminModifierLogic() internal virtual {     require(msg.sender == admin, "not admin");   } modifier onlyAdmin() {     onlyAdminModifierLogic();     _;   } function onlyValidSyntheticModifierLogic(address _synth) internal virtual {     require(marketIndexOfToken[_synth] != 0, "not valid synth");   } modifier onlyValidSynthetic(address synth) {     onlyValidSyntheticModifierLogic(_synth);     ;   } function onlyValidMarketModifierLogic(uint32 marketIndex) internal virtual {     require(address(syntheticTokens[marketIndex][true]) != address(0), "not valid market");   } modifier onlyValidMarket(uint32 marketIndex) {     onlyValidMarketModifierLogic(marketIndex);     _;   } function onlyLongShortModifierLogic() internal virtual {     require(msg.sender == address(longShort), "not long short");   } modifier onlyLongShort() {     onlyLongShortModifierLogic();     _;   } /╔═════════════════════════════╗     ║       CONTRACT SET-UP       ║     ╚═════════════════════════════╝/ /*   @notice Initializes the contract.   @dev Calls OpenZeppelin's initializer modifier.   @param _admin Address of the admin role.   @param _longShort Address of the LongShort contract, a deployed LongShort.sol   @param _floatToken Address of the Float token earned by staking.   @param _floatTreasury Address of the treasury contract for managing fees.   @param _floatCapital Address of the contract which earns a fixed percentage of Float.   @param _floatPercentage Determines the float percentage that gets minted for Float Capital, base 1e18.   /   function initialize(     address _admin,     address _longShort,     address _floatToken,     address _floatTreasury,     address _floatCapital,     uint256 _floatPercentage   ) external virtual initializer {     admin = _admin;     floatCapital = _floatCapital;     floatTreasury = _floatTreasury;     longShort = _longShort;     floatToken = _floatToken; _changeFloatPercentage(_floatPercentage);  emit StakerV1(_admin, _floatTreasury, _floatCapital, _floatToken, _floatPercentage);  } /╔═══════════════════╗     ║       ADMIN       ║     ╚═══════════════════╝/ /*    @notice Changes admin for the contract   @param _admin The address of the new admin.   /   function changeAdmin(address _admin) external onlyAdmin {     admin = _admin;     emit ChangeAdmin(_admin);   } /// @dev Logic for changeFloatPercentage   function _changeFloatPercentage(uint256 newFloatPercentage) internal virtual {     require(newFloatPercentage &lt;= 1e18 &amp;&amp; newFloatPercentage &gt; 0); // less than or equal to 100% and greater than 0%     floatPercentage = newFloatPercentage;   } /*   @notice Changes percentage of float that is minted for float capital.   @param newFloatPercentage The new float percentage in base 1e18.   /   function changeFloatPercentage(uint256 newFloatPercentage) external onlyAdmin {     _changeFloatPercentage(newFloatPercentage);     emit FloatPercentageUpdated(newFloatPercentage);   } /// @dev Logic for changeUnstakeFee   function _changeUnstakeFee(uint32 marketIndex, uint256 newMarketUnstakeFee_e18) internal virtual {     require(newMarketUnstakeFee_e18 &lt;= 5e16); // Explicitely stating 5% fee as the max fee possible.     marketUnstakeFee_e18[marketIndex] = newMarketUnstakeFee_e18;   } /*   @notice Changes unstake fee for a market   @param marketIndex Identifies the market.   @param newMarketUnstakeFee_e18 The new unstake fee.   /   function changeUnstakeFee(uint32 marketIndex, uint256 newMarketUnstakeFee_e18) external onlyAdmin {     _changeUnstakeFee(marketIndex, newMarketUnstakeFee_e18);     emit StakeWithdrawalFeeUpdated(marketIndex, newMarketUnstakeFee_e18);   } /// @dev Logic for changeMarketLaunchIncentiveParameters   function _changeMarketLaunchIncentiveParameters(     uint32 marketIndex,     uint256 period,     uint256 initialMultiplier   ) internal virtual {     require(initialMultiplier &gt;= 1e18, "marketLaunchIncentiveMultiplier must be &gt;= 1e18"); marketLaunchIncentive_period[marketIndex] = period; marketLaunchIncentive_multipliers[marketIndex] = initialMultiplier;  } /*   @notice Changes the market launch incentive parameters for a market   @param marketIndex Identifies the market.   @param period The new period for which float token generation should be boosted.   @param initialMultiplier The new multiplier on Float generation.   /   function changeMarketLaunchIncentiveParameters(     uint32 marketIndex,     uint256 period,     uint256 initialMultiplier   ) external onlyAdmin {     _changeMarketLaunchIncentiveParameters(marketIndex, period, initialMultiplier); emit MarketLaunchIncentiveParametersChanges(marketIndex, period, initialMultiplier);  } /// @dev Logic for changeBalanceIncentiveExponent   function _changeBalanceIncentiveExponent(uint32 marketIndex, uint256 _balanceIncentiveCurve_exponent)     internal     virtual   {     require(       // The exponent has to be less than 5 in these versions of the contracts.       _balanceIncentiveCurve_exponent &gt; 0 &amp;&amp; _balanceIncentiveCurve_exponent &lt; 6,       "balanceIncentiveCurve_exponent out of bounds"     ); balanceIncentiveCurve_exponent[marketIndex] = _balanceIncentiveCurve_exponent;  } /*    @notice Changes the balance incentive exponent for a market   @param marketIndex Identifies the market.   @param _balanceIncentiveCurve_exponent The new exponent for the curve.   /   function changeBalanceIncentiveExponent(uint32 marketIndex, uint256 _balanceIncentiveCurve_exponent)     external     onlyAdmin   {     _changeBalanceIncentiveExponent(marketIndex, _balanceIncentiveCurve_exponent); emit BalanceIncentiveExponentUpdated(marketIndex, _balanceIncentiveCurve_exponent);  } /// @dev Logic for changeBalanceIncentiveEquilibriumOffset   function _changeBalanceIncentiveEquilibriumOffset(uint32 marketIndex, int256 _balanceIncentiveCurve_equilibriumOffset)     internal     virtual   {     // Unreasonable that we would ever shift this more than 90% either way     require(       _balanceIncentiveCurve_equilibriumOffset &gt; -9e17 &amp;&amp; _balanceIncentiveCurve_equilibriumOffset &lt; 9e17,       "balanceIncentiveCurve_equilibriumOffset out of bounds"     ); balanceIncentiveCurve_equilibriumOffset[marketIndex] = _balanceIncentiveCurve_equilibriumOffset;  } /*   @notice Changes the balance incentive curve equilibrium offset for a market   @param marketIndex Identifies the market.   @param _balanceIncentiveCurve_equilibriumOffset The new offset.   /   function changeBalanceIncentiveEquilibriumOffset(uint32 marketIndex, int256 _balanceIncentiveCurve_equilibriumOffset)     external     onlyAdmin   {     _changeBalanceIncentiveEquilibriumOffset(marketIndex, _balanceIncentiveCurve_equilibriumOffset); emit BalanceIncentiveEquilibriumOffsetUpdated(marketIndex, _balanceIncentiveCurve_equilibriumOffset);  } /╔═════════════════════════════╗     ║        STAKING SETUP        ║     ╚═════════════════════════════╝/ /*   @notice Sets this contract to track staking for a market in LongShort.sol   @param marketIndex Identifies the market.   @param longToken Address of the long token for the market.   @param shortToken Address of the short token for the market.   @param kInitialMultiplier Initial boost on float generation for the market.   @param kPeriod Period which the boost should last.   @param unstakeFee_e18 Percentage of tokens that are levied on unstaking in base 1e18.   @param _balanceIncentiveCurve_exponent Exponent for balance curve (see _calculateFloatPerSecond)   @param _balanceIncentiveCurve_equilibriumOffset Offset for balance curve (see _calculateFloatPerSecond)   /   function addNewStakingFund(     uint32 marketIndex,     address longToken,     address shortToken,     uint256 kInitialMultiplier,     uint256 kPeriod,     uint256 unstakeFee_e18,     uint256 _balanceIncentiveCurve_exponent,     int256 _balanceIncentiveCurve_equilibriumOffset   ) external override onlyLongShort {     marketIndexOfToken[longToken] = marketIndex;     marketIndexOfToken[shortToken] = marketIndex; accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].timestamp = block.timestamp; accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].accumulativeFloatPerSyntheticToken_long = 0; accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].accumulativeFloatPerSyntheticToken_short = 0;  syntheticTokens[marketIndex][true] = longToken; syntheticTokens[marketIndex][false] = shortToken;  _changeBalanceIncentiveExponent(marketIndex, _balanceIncentiveCurve_exponent); _changeBalanceIncentiveEquilibriumOffset(marketIndex, _balanceIncentiveCurve_equilibriumOffset); _changeMarketLaunchIncentiveParameters(marketIndex, kPeriod, kInitialMultiplier);  _changeUnstakeFee(marketIndex, unstakeFee_e18);  // Set this value to one initially - 0 is a null value and thus potentially bug prone. batched_stakerNextTokenShiftIndex[marketIndex] = 1;  emit MarketAddedToStaker(   marketIndex,   unstakeFee_e18,   kPeriod,   kInitialMultiplier,   _balanceIncentiveCurve_exponent,   _balanceIncentiveCurve_equilibriumOffset );  emit AccumulativeIssuancePerStakedSynthSnapshotCreated(marketIndex, 0, 0, 0);  } /╔═════════════════════════════════════════════════════════════════════════╗     ║    GLOBAL FLT REWARD ACCUMULATION CALCULATION AND TRACKING FUNCTIONS    ║     ╚═════════════════════════════════════════════════════════════════════════╝/ /*   @notice Returns the K factor parameters for the given market with sensible   defaults if they haven't been set yet.   @param marketIndex The market to change the parameters for.   @return period The period for which the k factor applies for in seconds.   @return multiplier The multiplier on Float generation in this period.   /   function _getMarketLaunchIncentiveParameters(uint32 marketIndex)     internal     view     virtual     returns (uint256 period, uint256 multiplier)   {     period = marketLaunchIncentive_period[marketIndex];     multiplier = marketLaunchIncentive_multipliers[marketIndex]; if (multiplier &lt; 1e18) {   multiplier = 1e18; // multiplier of 1 by default }  } /*    @notice Returns the extent to which a markets float generation should be adjusted   based on the market's launch incentive parameters. Should start at multiplier   then linearly change to 1e18 over time.   @param marketIndex Identifies the market.   @return k The calculated modifier for float generation.   /   function _getKValue(uint32 marketIndex) internal view virtual returns (uint256) {     // Parameters controlling the float issuance multiplier.     (uint256 kPeriod, uint256 kInitialMultiplier) = _getMarketLaunchIncentiveParameters(marketIndex); // Sanity check - under normal circumstances, the multipliers should // *never* be set to a value &lt; 1e18, as there are guards against this. assert(kInitialMultiplier &gt;= 1e18);  uint256 initialTimestamp = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].timestamp;  if (block.timestamp - initialTimestamp &lt;= kPeriod) {   return kInitialMultiplier - (((kInitialMultiplier - 1e18) * (block.timestamp - initialTimestamp)) / kPeriod); } else {   return 1e18; }  } /   @notice Computes the number of float tokens a user earns per second for   every long/short synthetic token they've staked. The returned value has   a fixed decimal scale of 1e42 (!!!) for numerical stability. The return   values are float per second per synthetic token (hence the requirement   to multiply by price)   @dev to see below math in latex form see TODO add link   to interact with the equations see https://www.desmos.com/calculator/optkaxyihr   @param marketIndex The market referred to.   @param longPrice Price of the synthetic long token in units of payment token   @param shortPrice Price of the synthetic short token in units of payment token   @param longValue Amount of payment token in the long side of the market   @param shortValue Amount of payment token in the short side of the market   @return longFloatPerSecond Float token per second per long synthetic token   @return shortFloatPerSecond Float token per second per short synthetic token    /   function _calculateFloatPerSecond(     uint32 marketIndex,     uint256 longPrice,     uint256 shortPrice,     uint256 longValue,     uint256 shortValue   ) internal view virtual returns (uint256 longFloatPerSecond, uint256 shortFloatPerSecond) {     // A float issuance multiplier that starts high and decreases linearly     // over time to a value of 1. This incentivises users to stake early.     uint256 k = _getKValue(marketIndex); uint256 totalLocked = (longValue + shortValue);  // we need to scale this number by the totalLocked so that the offset remains consistent accross market size  int256 equilibriumOffsetMarketScaled = (balanceIncentiveCurve_equilibriumOffset[marketIndex] *   int256(totalLocked)) / 2e18;  uint256 denominator = ((totalLocked &gt;&gt; safeExponentBitShifting)**balanceIncentiveCurve_exponent[marketIndex]);  // Float is scaled by the percentage of the total market value held in // the opposite position. This incentivises users to stake on the // weaker position. if (int256(shortValue) - equilibriumOffsetMarketScaled &lt; int256(longValue)) {   if (equilibriumOffsetMarketScaled &gt;= int256(shortValue)) {     // edge case: imbalanced far past the equilibrium offset - full rewards go to short token     //            extremeley unlikely to happen in practice     return (0, 1e18 * k * shortPrice);   }    uint256 numerator = (uint256(int256(shortValue) - equilibriumOffsetMarketScaled) &gt;&gt;     (safeExponentBitShifting - 1))**balanceIncentiveCurve_exponent[marketIndex];    // NOTE: `x * 5e17` == `(x * 10e18) / 2`   uint256 longRewardUnscaled = (numerator * 5e17) / denominator;   uint256 shortRewardUnscaled = 1e18 - longRewardUnscaled;    return ((longRewardUnscaled * k * longPrice) / 1e18, (shortRewardUnscaled * k * shortPrice) / 1e18); } else {   if (-equilibriumOffsetMarketScaled &gt;= int256(longValue)) {     // edge case: imbalanced far past the equilibrium offset - full rewards go to long token     //            extremeley unlikely to happen in practice     return (1e18 * k * longPrice, 0);   }    uint256 numerator = (uint256(int256(longValue) + equilibriumOffsetMarketScaled) &gt;&gt;     (safeExponentBitShifting - 1))**balanceIncentiveCurve_exponent[marketIndex];    // NOTE: `x * 5e17` == `(x * 10e18) / 2`   uint256 shortRewardUnscaled = (numerator * 5e17) / denominator;   uint256 longRewardUnscaled = 1e18 - shortRewardUnscaled;    return ((longRewardUnscaled * k * longPrice) / 1e18, (shortRewardUnscaled * k * shortPrice) / 1e18); }  } /*   @notice Computes the time since last accumulativeIssuancePerStakedSynthSnapshot for the given market in seconds.   @param marketIndex The market referred to.   @return The time difference in seconds   /   function _calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(uint32 marketIndex)     internal     view     virtual     returns (uint256)   {     return       block.timestamp -       accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]].timestamp;   } /*   @notice Computes new cumulative sum of 'r' value since last accumulativeIssuancePerStakedSynthSnapshot. We use   cumulative 'r' value to avoid looping during issuance. Note that the   cumulative sum is kept in 1e42 scale (!!!) to avoid numerical issues.   @param shortValue The value locked in the short side of the market.   @param longValue The value locked in the long side of the market.   @param shortPrice The price of the short token as defined in LongShort.sol   @param longPrice The price of the long token as defined in LongShort.sol   @param marketIndex An identifier for the market.   @return longCumulativeRates The long cumulative sum.   @return shortCumulativeRates The short cumulative sum.   /   function _calculateNewCumulativeIssuancePerStakedSynth(     uint32 marketIndex,     uint256 longPrice,     uint256 shortPrice,     uint256 longValue,     uint256 shortValue   ) internal view virtual returns (uint256 longCumulativeRates, uint256 shortCumulativeRates) {     // Compute the current 'r' value for float issuance per second.     (uint256 longFloatPerSecond, uint256 shortFloatPerSecond) = _calculateFloatPerSecond(       marketIndex,       longPrice,       shortPrice,       longValue,       shortValue     ); // Compute time since last accumulativeIssuancePerStakedSynthSnapshot for the given token. uint256 timeDelta = _calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(marketIndex);  // Compute new cumulative 'r' value total. return (   accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]]   .accumulativeFloatPerSyntheticToken_long + (timeDelta * longFloatPerSecond),   accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]]   .accumulativeFloatPerSyntheticToken_short + (timeDelta * shortFloatPerSecond) );  } /*   @notice Creates a new accumulativeIssuancePerStakedSynthSnapshot for the given token and updates indexes.   @param shortValue The value locked in the short side of the market.   @param longValue The value locked in the long side of the market.   @param shortPrice The price of the short token as defined in LongShort.sol   @param longPrice The price of the long token as defined in LongShort.sol   @param marketIndex An identifier for the market.   /   function _setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot(     uint32 marketIndex,     uint256 longPrice,     uint256 shortPrice,     uint256 longValue,     uint256 shortValue   ) internal virtual {     (       uint256 newLongAccumulativeValue,       uint256 newShortAccumulativeValue     ) = _calculateNewCumulativeIssuancePerStakedSynth(marketIndex, longPrice, shortPrice, longValue, shortValue); uint256 newIndex = latestRewardIndex[marketIndex] + 1;  // Set cumulative 'r' value on new accumulativeIssuancePerStakedSynthSnapshot. accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex] .accumulativeFloatPerSyntheticToken_long = newLongAccumulativeValue; accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex] .accumulativeFloatPerSyntheticToken_short = newShortAccumulativeValue;  // Set timestamp on new accumulativeIssuancePerStakedSynthSnapshot. accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex].timestamp = block.timestamp;  // Update latest index to point to new accumulativeIssuancePerStakedSynthSnapshot. latestRewardIndex[marketIndex] = newIndex;  emit AccumulativeIssuancePerStakedSynthSnapshotCreated(   marketIndex,   newIndex,   newLongAccumulativeValue,   newShortAccumulativeValue );  } /*   @notice Adds new accumulativeIssuancePerStakedSynthSnapshots for the given long/short tokens. Called by the   ILongShort contract whenever there is a state change for a market.   @param stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted Mapping from this contract's shifts to LongShort.sols next price snapshots.   @param shortValue The value locked in the short side of the market.   @param longValue The value locked in the long side of the market.   @param shortPrice The price of the short token as defined in LongShort.sol   @param longPrice The price of the long token as defined in LongShort.sol   @param marketIndex An identifier for the market.   /   function pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(     uint32 marketIndex,     uint256 longPrice,     uint256 shortPrice,     uint256 longValue,     uint256 shortValue,     uint256 stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted // This value should be ALWAYS be zero if no shift occured   ) external override onlyLongShort {     // Only add a new accumulativeIssuancePerStakedSynthSnapshot if some time has passed. // the `stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted` value will be 0 if there is no staker related action in an executed batch if (stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted &gt; 0) {   stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[     batched_stakerNextTokenShiftIndex[marketIndex]   ] = stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted;   stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[     batched_stakerNextTokenShiftIndex[marketIndex]   ] = latestRewardIndex[marketIndex] + 1;   batched_stakerNextTokenShiftIndex[marketIndex] += 1;    emit SyntheticTokensShifted(); }  // Time delta is fetched twice in below code, can pass through? Which is less gas? if (_calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(marketIndex) &gt; 0) {   _setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot(     marketIndex,     longPrice,     shortPrice,     longValue,     shortValue   ); }  } /╔═══════════════════════════════════╗     ║    USER REWARD STATE FUNCTIONS    ║     ╚═══════════════════════════════════╝/ /// @dev Calculates the accumulated float in a specific range of staker snapshots   function _calculateAccumulatedFloatInRange(     uint32 marketIndex,     uint256 amountStakedLong,     uint256 amountStakedShort,     uint256 rewardIndexFrom,     uint256 rewardIndexTo   ) internal view virtual returns (uint256 floatReward) {     if (amountStakedLong &gt; 0) {       uint256 accumDeltaLong = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexTo]       .accumulativeFloatPerSyntheticToken_long -         accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexFrom]         .accumulativeFloatPerSyntheticToken_long;       floatReward += (accumDeltaLong * amountStakedLong) / FLOAT_ISSUANCE_FIXED_DECIMAL;     } if (amountStakedShort &gt; 0) {   uint256 accumDeltaShort = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexTo]   .accumulativeFloatPerSyntheticToken_short -     accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexFrom]     .accumulativeFloatPerSyntheticToken_short;   floatReward += (accumDeltaShort * amountStakedShort) / FLOAT_ISSUANCE_FIXED_DECIMAL; }  } /*    @notice Calculates float owed to the user since the user last minted float for a market.   @param marketIndex Identifier for the market which the user staked in.   @param user The address of the user.   @return floatReward The amount of float owed.    /   function _calculateAccumulatedFloat(uint32 marketIndex, address user) internal virtual returns (uint256 floatReward) {     address longToken = syntheticTokens[marketIndex][true];     address shortToken = syntheticTokens[marketIndex][false]; uint256 amountStakedLong = userAmountStaked[longToken][user]; uint256 amountStakedShort = userAmountStaked[shortToken][user];  uint256 usersLastRewardIndex = userIndexOfLastClaimedReward[marketIndex][user];  // Don't do the calculation and return zero immediately if there is no change if (usersLastRewardIndex == latestRewardIndex[marketIndex]) {   return 0; }  uint256 usersShiftIndex = userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][user]; // if there is a change in the users tokens held due to a token shift (or possibly another action in the future) if (usersShiftIndex &gt; 0 &amp;&amp; usersShiftIndex &lt; batched_stakerNextTokenShiftIndex[marketIndex]) {   floatReward = _calculateAccumulatedFloatInRange(     marketIndex,     amountStakedLong,     amountStakedShort,     usersLastRewardIndex,     stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[usersShiftIndex]   );    // Update the users balances   if (userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user] &gt; 0) {     amountStakedShort += ILongShort(longShort).getAmountSyntheticTokenToMintOnTargetSide(       marketIndex,       userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user],       true,       stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[usersShiftIndex]     );      amountStakedLong -= userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user];     userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user] = 0;   }    if (userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user] &gt; 0) {     amountStakedLong += ILongShort(longShort).getAmountSyntheticTokenToMintOnTargetSide(       marketIndex,       userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user],       false,       stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[usersShiftIndex]     );      amountStakedShort -= userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user];     userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user] = 0;   }    // Save the users updated staked amounts   userAmountStaked[longToken][user] = amountStakedLong;   userAmountStaked[shortToken][user] = amountStakedShort;    floatReward += _calculateAccumulatedFloatInRange(     marketIndex,     amountStakedLong,     amountStakedShort,     stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[usersShiftIndex],     latestRewardIndex[marketIndex]   );    userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][user] = 0; } else {   floatReward = _calculateAccumulatedFloatInRange(     marketIndex,     amountStakedLong,     amountStakedShort,     usersLastRewardIndex,     latestRewardIndex[marketIndex]   ); }  } /*   @notice Mints float for a user.   @dev Mints a fixed percentage for Float capital.   @param user The address of the user.   @param floatToMint The amount of float to mint.    /   function _mintFloat(address user, uint256 floatToMint) internal virtual {     IFloatToken(floatToken).mint(user, floatToMint);     IFloatToken(floatToken).mint(floatCapital, (floatToMint * floatPercentage) / 1e18);   } /*   @notice Mints float owed to a user for a market since they last minted.   @param marketIndex An identifier for the market.   @param user The address of the user.    /   function _mintAccumulatedFloat(uint32 marketIndex, address user) internal virtual {     uint256 floatToMint = _calculateAccumulatedFloat(marketIndex, user); if (floatToMint &gt; 0) {   // Set the user has claimed up until now, stops them setting this forward   userIndexOfLastClaimedReward[marketIndex][user] = latestRewardIndex[marketIndex];    _mintFloat(user, floatToMint);   emit FloatMinted(user, marketIndex, floatToMint); }  } /*   @notice Mints float owed to a user for multiple markets, since they last minted for those markets.   @param marketIndexes Identifiers for the markets.   @param user The address of the user.    /   function _mintAccumulatedFloatMulti(uint32[] calldata marketIndexes, address user) internal virtual {     uint256 floatTotal = 0;     for (uint256 i = 0; i &lt; marketIndexes.length; i++) {       uint256 floatToMint = _calculateAccumulatedFloat(marketIndexes[i], user);   if (floatToMint &gt; 0) {     // Set the user has claimed up until now, stops them setting this forward     userIndexOfLastClaimedReward[marketIndexes[i]][user] = latestRewardIndex[marketIndexes[i]];      floatTotal += floatToMint;      emit FloatMinted(user, marketIndexes[i], floatToMint);   } } if (floatTotal &gt; 0) {   _mintFloat(user, floatTotal); }  } /*   @notice Mints outstanding float for msg.sender.   @param marketIndexes Identifiers for the markets for which to mint float.    /   function claimFloatCustom(uint32[] calldata marketIndexes) external {     ILongShort(longShort).updateSystemStateMulti(marketIndexes);     _mintAccumulatedFloatMulti(marketIndexes, msg.sender);   } /*   @notice Mints outstanding float on behalf of another user.   @param marketIndexes Identifiers for the markets for which to mint float.   @param user The address of the user.    /   function claimFloatCustomFor(uint32[] calldata marketIndexes, address user) external {     // Unbounded loop - users are responsible for paying their own gas costs on these and it doesn't effect the rest of the system.     // No need to impose limit.     ILongShort(longShort).updateSystemStateMulti(marketIndexes);     _mintAccumulatedFloatMulti(marketIndexes, user);   } /╔═══════════════════════╗     ║        STAKING        ║     ╚═══════════════════════╝/ /*   @notice A user with synthetic tokens stakes by calling stake on the token   contract which calls this function. We need to first update the   state of the LongShort contract for this market before staking to correctly calculate user rewards.   @param amount Amount to stake.   @param from Address to stake for.   /   function stakeFromUser(address from, uint256 amount) public virtual override onlyValidSynthetic((msg.sender)) {     ILongShort(longShort).updateSystemState(marketIndexOfToken[(msg.sender)]);     _stake((msg.sender), amount, from);   } /*   @dev Internal logic for staking.   @param token Address of the token for which to stake.   @param amount Amount to stake.   @param user Address to stake for.   /   function _stake(     address token,     uint256 amount,     address user   ) internal virtual {     uint32 marketIndex = marketIndexOfToken[token]; // If they already have staked and have rewards due, mint these. if (   userIndexOfLastClaimedReward[marketIndex][user] != 0 &amp;&amp;   userIndexOfLastClaimedReward[marketIndex][user] &lt; latestRewardIndex[marketIndex] ) {   _mintAccumulatedFloat(marketIndex, user); }  userAmountStaked[token][user] = userAmountStaked[token][user] + amount;  userIndexOfLastClaimedReward[marketIndex][user] = latestRewardIndex[marketIndex];  emit StakeAdded(user, address(token), amount, userIndexOfLastClaimedReward[marketIndex][user]);  } /*   @notice Allows users to shift their staked tokens from one side of the market to    the other at the next price.   @param amountSyntheticTokensToShift Amount of tokens to shift.   @param marketIndex Identifier for the market.   @param isShiftFromLong Whether the shift is from long to short or short to long.   /   function shiftTokens(     uint256 amountSyntheticTokensToShift,     uint32 marketIndex,     bool isShiftFromLong   ) external virtual {     address token = syntheticTokens[marketIndex][isShiftFromLong];     require(userAmountStaked[token][msg.sender] &gt;= amountSyntheticTokensToShift, "Not enough tokens to shift"); // If the user has outstanding token shift that have already been confirmed in the LongShort // contract, execute them first. if (   userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] != 0 &amp;&amp;   userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] &lt;   batched_stakerNextTokenShiftIndex[marketIndex] ) {   _mintAccumulatedFloat(marketIndex, msg.sender); }  if (isShiftFromLong) {   ILongShort(longShort).shiftPositionFromLongNextPrice(marketIndex, amountSyntheticTokensToShift);   userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][     msg.sender   ] += amountSyntheticTokensToShift; } else {   ILongShort(longShort).shiftPositionFromShortNextPrice(marketIndex, amountSyntheticTokensToShift);   userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][     msg.sender   ] += amountSyntheticTokensToShift; }  userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] = batched_stakerNextTokenShiftIndex[   marketIndex ];  } /╔════════════════════════════╗     ║    WITHDRAWAL &amp; MINTING    ║     ╚════════════════════════════╝/ /*   @notice Internal logic for withdrawing stakes.   @dev Mint user any outstanding float before withdrawing.   @param marketIndex Market index of token.   @param amount Amount to withdraw.   @param token Synthetic token that was staked.   /   function _withdraw(     uint32 marketIndex,     address token,     uint256 amount   ) internal virtual {     require(userAmountStaked[token][msg.sender] &gt; 0, "nothing to withdraw");     _mintAccumulatedFloat(marketIndex, msg.sender); userAmountStaked[token][msg.sender] = userAmountStaked[token][msg.sender] - amount;  uint256 amountFees = (amount * marketUnstakeFee_e18[marketIndex]) / 1e18;  IERC20(token).transfer(floatTreasury, amountFees); IERC20(token).transfer(msg.sender, amount - amountFees);  emit StakeWithdrawn(msg.sender, token, amount);  } /*   @notice Withdraw function. Allows users to unstake.   @param amount Amount to withdraw.   @param token Address of the token for which to withdraw.   /   function withdraw(address token, uint256 amount) external {     ILongShort(longShort).updateSystemState(marketIndexOfToken[token]); uint32 marketIndex = marketIndexOfToken[token];  _withdraw(marketIndex, token, amount);  if (userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] &gt; 0) {   // If they still have outstanding shifts after minting float, then check   // that they don't withdraw more than their shifts allow.   uint256 amountToShiftForThisToken = syntheticTokens[marketIndex][true] == token     ? userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][msg.sender]     : userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][msg.sender];    require(     userAmountStaked[token][msg.sender] &gt;= amountToShiftForThisToken,     "Outstanding next price stake shifts too great"   ); }  } /*   @notice Allows users to withdraw their entire stake for a token.   @param token Address of the token for which to withdraw.   /   function withdrawAll(address token) external {     ILongShort(longShort).updateSystemState(marketIndexOfToken[token]); uint32 marketIndex = marketIndexOfToken[token];  uint256 amountToShiftForThisToken = syntheticTokens[marketIndex][true] == token   ? userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][msg.sender]   : userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][msg.sender];  _withdraw(marketIndex, token, userAmountStaked[token][msg.sender] - amountToShiftForThisToken);  } } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-17-08 08:01:40 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: BUSL-1.1

pragma solidity 0.8.3;

import "@openzeppelin/contracts-upgradeable/token/ERC20/presets/ERC20PresetMinterPauserUpgradeable.sol";

import "./interfaces/IFloatToken.sol";
import "./interfaces/ILongShort.sol";
import "./interfaces/IStaker.sol";
import "./interfaces/ISyntheticToken.sol";

contract Staker is IStaker, Initializable {
  /*╔═════════════════════════════╗
    ║          VARIABLES          ║
    ╚═════════════════════════════╝*/

  /* ══════ Fixed-precision constants ══════ */
  uint256 public constant FLOAT_ISSUANCE_FIXED_DECIMAL = 1e42;
  // 2^52 ~= 4.5e15
  // With an exponent of 5, the largest total liquidity possible in a market (to avoid integer overflow on exponentiation) is ~10^31 or 10 Trillion (10^13)
  // NOTE: this also means if the total market value is less than 2^52 there will be a division by zero error
  uint256 public constant safeExponentBitShifting = 52;

  /* ══════ Global state ══════ */
  address public admin;
  address public floatCapital;
  address public floatTreasury;
  uint256 public floatPercentage;

  address public longShort;
  address public floatToken;

  /* ══════ Market specific ══════ */
  mapping(uint32 => uint256) public marketLaunchIncentive_period; // seconds
  mapping(uint32 => uint256) public marketLaunchIncentive_multipliers; // e18 scale
  mapping(uint32 => uint256) public marketUnstakeFee_e18;
  mapping(uint32 => uint256) public balanceIncentiveCurve_exponent;
  mapping(uint32 => int256) public balanceIncentiveCurve_equilibriumOffset;

  mapping(uint32 => mapping(bool => address)) public syntheticTokens;

  mapping(address => uint32) public marketIndexOfToken;

  /* ══════ Reward specific ══════ */
  mapping(uint32 => uint256) public latestRewardIndex;
  mapping(uint32 => mapping(uint256 => AccumulativeIssuancePerStakedSynthSnapshot))
    public accumulativeFloatPerSyntheticTokenSnapshots;
  struct AccumulativeIssuancePerStakedSynthSnapshot {
    uint256 timestamp;
    uint256 accumulativeFloatPerSyntheticToken_long;
    uint256 accumulativeFloatPerSyntheticToken_short;
  }

  /* ══════ User specific ══════ */
  mapping(uint32 => mapping(address => uint256)) public userIndexOfLastClaimedReward;
  mapping(address => mapping(address => uint256)) public userAmountStaked;

  /* ══════ Token shift management specific ══════ */
  mapping(uint32 => uint256) public batched_stakerNextTokenShiftIndex;
  /**
  @notice Used to link a token shift to a staker state
  @dev tokenShiftIndex => accumulativeFloatIssuanceSnapshotIndex
    POSSIBLE OPTIMIZATION - could pack stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping and stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping into a struct of two uint128 for storage space optimization.
  */
  mapping(uint256 => uint256) public stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping;
  /// @notice Used to fetch the price from LongShort at that point in time
  /// @dev tokenShiftIndex => longShortMarketPriceSnapshotIndex
  mapping(uint256 => uint256) public stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping;
  /// @dev marketIndex => usersAddress => stakerTokenShiftIndex
  mapping(uint32 => mapping(address => uint256)) public userNextPrice_stakedSyntheticTokenShiftIndex;
  /// @dev marketIndex => usersAddress => amountUserRequestedToShiftAwayFromLongOnNextUpdate
  mapping(uint32 => mapping(address => uint256)) public userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long;
  /// @dev marketIndex => usersAddress => amountUserRequestedToShiftAwayFromShortOnNextUpdate
  mapping(uint32 => mapping(address => uint256)) public userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short;

  /*╔════════════════════════════╗
    ║           EVENTS           ║
    ╚════════════════════════════╝*/

  event StakerV1(
    address admin,
    address floatTreasury,
    address floatCapital,
    address floatToken,
    uint256 floatPercentage
  );

  event MarketAddedToStaker(
    uint32 marketIndex,
    uint256 exitFee_e18,
    uint256 period,
    uint256 multiplier,
    uint256 balanceIncentiveExponent,
    int256 balanceIncentiveEquilibriumOffset
  );

  event AccumulativeIssuancePerStakedSynthSnapshotCreated(
    uint32 marketIndex,
    uint256 accumulativeFloatIssuanceSnapshotIndex,
    uint256 accumulativeLong,
    uint256 accumulativeShort
  );

  event StakeAdded(address user, address token, uint256 amount, uint256 lastMintIndex);

  event StakeWithdrawn(address user, address token, uint256 amount);

  // Note: the `amountFloatMinted` isn't strictly needed by the graph, but it is good to add it to validate calculations are accurate.
  event FloatMinted(address user, uint32 marketIndex, uint256 amountFloatMinted);

  event MarketLaunchIncentiveParametersChanges(uint32 marketIndex, uint256 period, uint256 multiplier);

  event StakeWithdrawalFeeUpdated(uint32 marketIndex, uint256 stakeWithdralFee);

  event BalanceIncentiveExponentUpdated(uint32 marketIndex, uint256 balanceIncentiveExponent);

  event BalanceIncentiveEquilibriumOffsetUpdated(uint32 marketIndex, int256 balanceIncentiveEquilibriumOffset);

  event FloatPercentageUpdated(uint256 floatPercentage);

  event SyntheticTokensShifted();

  event ChangeAdmin(address newAdmin);

  /*╔═════════════════════════════╗
    ║          MODIFIERS          ║
    ╚═════════════════════════════╝*/

  function onlyAdminModifierLogic() internal virtual {
    require(msg.sender == admin, "not admin");
  }

  modifier onlyAdmin() {
    onlyAdminModifierLogic();
    _;
  }

  function onlyValidSyntheticModifierLogic(address _synth) internal virtual {
    require(marketIndexOfToken[_synth] != 0, "not valid synth");
  }

  modifier onlyValidSynthetic(address _synth) {
    onlyValidSyntheticModifierLogic(_synth);
    _;
  }

  function onlyValidMarketModifierLogic(uint32 marketIndex) internal virtual {
    require(address(syntheticTokens[marketIndex][true]) != address(0), "not valid market");
  }

  modifier onlyValidMarket(uint32 marketIndex) {
    onlyValidMarketModifierLogic(marketIndex);
    _;
  }

  function onlyLongShortModifierLogic() internal virtual {
    require(msg.sender == address(longShort), "not long short");
  }

  modifier onlyLongShort() {
    onlyLongShortModifierLogic();
    _;
  }

  /*╔═════════════════════════════╗
    ║       CONTRACT SET-UP       ║
    ╚═════════════════════════════╝*/

  /**
  @notice Initializes the contract.
  @dev Calls OpenZeppelin's initializer modifier.
  @param _admin Address of the admin role.
  @param _longShort Address of the LongShort contract, a deployed LongShort.sol
  @param _floatToken Address of the Float token earned by staking.
  @param _floatTreasury Address of the treasury contract for managing fees.
  @param _floatCapital Address of the contract which earns a fixed percentage of Float.
  @param _floatPercentage Determines the float percentage that gets minted for Float Capital, base 1e18.
  */
  function initialize(
    address _admin,
    address _longShort,
    address _floatToken,
    address _floatTreasury,
    address _floatCapital,
    uint256 _floatPercentage
  ) external virtual initializer {
    admin = _admin;
    floatCapital = _floatCapital;
    floatTreasury = _floatTreasury;
    longShort = _longShort;
    floatToken = _floatToken;

    _changeFloatPercentage(_floatPercentage);

    emit StakerV1(_admin, _floatTreasury, _floatCapital, _floatToken, _floatPercentage);
  }

  /*╔═══════════════════╗
    ║       ADMIN       ║
    ╚═══════════════════╝*/

  /** 
  @notice Changes admin for the contract
  @param _admin The address of the new admin.
  */
  function changeAdmin(address _admin) external onlyAdmin {
    admin = _admin;
    emit ChangeAdmin(_admin);
  }

  /// @dev Logic for changeFloatPercentage
  function _changeFloatPercentage(uint256 newFloatPercentage) internal virtual {
    require(newFloatPercentage <= 1e18 && newFloatPercentage > 0); // less than or equal to 100% and greater than 0%
    floatPercentage = newFloatPercentage;
  }

  /**
  @notice Changes percentage of float that is minted for float capital.
  @param newFloatPercentage The new float percentage in base 1e18.
  */
  function changeFloatPercentage(uint256 newFloatPercentage) external onlyAdmin {
    _changeFloatPercentage(newFloatPercentage);
    emit FloatPercentageUpdated(newFloatPercentage);
  }

  /// @dev Logic for changeUnstakeFee
  function _changeUnstakeFee(uint32 marketIndex, uint256 newMarketUnstakeFee_e18) internal virtual {
    require(newMarketUnstakeFee_e18 <= 5e16); // Explicitely stating 5% fee as the max fee possible.
    marketUnstakeFee_e18[marketIndex] = newMarketUnstakeFee_e18;
  }

  /**
  @notice Changes unstake fee for a market
  @param marketIndex Identifies the market.
  @param newMarketUnstakeFee_e18 The new unstake fee.
  */
  function changeUnstakeFee(uint32 marketIndex, uint256 newMarketUnstakeFee_e18) external onlyAdmin {
    _changeUnstakeFee(marketIndex, newMarketUnstakeFee_e18);
    emit StakeWithdrawalFeeUpdated(marketIndex, newMarketUnstakeFee_e18);
  }

  /// @dev Logic for changeMarketLaunchIncentiveParameters
  function _changeMarketLaunchIncentiveParameters(
    uint32 marketIndex,
    uint256 period,
    uint256 initialMultiplier
  ) internal virtual {
    require(initialMultiplier >= 1e18, "marketLaunchIncentiveMultiplier must be >= 1e18");

    marketLaunchIncentive_period[marketIndex] = period;
    marketLaunchIncentive_multipliers[marketIndex] = initialMultiplier;
  }

  /**
  @notice Changes the market launch incentive parameters for a market
  @param marketIndex Identifies the market.
  @param period The new period for which float token generation should be boosted.
  @param initialMultiplier The new multiplier on Float generation.
  */
  function changeMarketLaunchIncentiveParameters(
    uint32 marketIndex,
    uint256 period,
    uint256 initialMultiplier
  ) external onlyAdmin {
    _changeMarketLaunchIncentiveParameters(marketIndex, period, initialMultiplier);

    emit MarketLaunchIncentiveParametersChanges(marketIndex, period, initialMultiplier);
  }

  /// @dev Logic for changeBalanceIncentiveExponent
  function _changeBalanceIncentiveExponent(uint32 marketIndex, uint256 _balanceIncentiveCurve_exponent)
    internal
    virtual
  {
    require(
      // The exponent has to be less than 5 in these versions of the contracts.
      _balanceIncentiveCurve_exponent > 0 && _balanceIncentiveCurve_exponent < 6,
      "balanceIncentiveCurve_exponent out of bounds"
    );

    balanceIncentiveCurve_exponent[marketIndex] = _balanceIncentiveCurve_exponent;
  }

  /** 
  @notice Changes the balance incentive exponent for a market
  @param marketIndex Identifies the market.
  @param _balanceIncentiveCurve_exponent The new exponent for the curve.
  */
  function changeBalanceIncentiveExponent(uint32 marketIndex, uint256 _balanceIncentiveCurve_exponent)
    external
    onlyAdmin
  {
    _changeBalanceIncentiveExponent(marketIndex, _balanceIncentiveCurve_exponent);

    emit BalanceIncentiveExponentUpdated(marketIndex, _balanceIncentiveCurve_exponent);
  }

  /// @dev Logic for changeBalanceIncentiveEquilibriumOffset
  function _changeBalanceIncentiveEquilibriumOffset(uint32 marketIndex, int256 _balanceIncentiveCurve_equilibriumOffset)
    internal
    virtual
  {
    // Unreasonable that we would ever shift this more than 90% either way
    require(
      _balanceIncentiveCurve_equilibriumOffset > -9e17 && _balanceIncentiveCurve_equilibriumOffset < 9e17,
      "balanceIncentiveCurve_equilibriumOffset out of bounds"
    );

    balanceIncentiveCurve_equilibriumOffset[marketIndex] = _balanceIncentiveCurve_equilibriumOffset;
  }

  /**
  @notice Changes the balance incentive curve equilibrium offset for a market
  @param marketIndex Identifies the market.
  @param _balanceIncentiveCurve_equilibriumOffset The new offset.
  */
  function changeBalanceIncentiveEquilibriumOffset(uint32 marketIndex, int256 _balanceIncentiveCurve_equilibriumOffset)
    external
    onlyAdmin
  {
    _changeBalanceIncentiveEquilibriumOffset(marketIndex, _balanceIncentiveCurve_equilibriumOffset);

    emit BalanceIncentiveEquilibriumOffsetUpdated(marketIndex, _balanceIncentiveCurve_equilibriumOffset);
  }

  /*╔═════════════════════════════╗
    ║        STAKING SETUP        ║
    ╚═════════════════════════════╝*/

  /**
  @notice Sets this contract to track staking for a market in LongShort.sol
  @param marketIndex Identifies the market.
  @param longToken Address of the long token for the market.
  @param shortToken Address of the short token for the market.
  @param kInitialMultiplier Initial boost on float generation for the market.
  @param kPeriod Period which the boost should last.
  @param unstakeFee_e18 Percentage of tokens that are levied on unstaking in base 1e18.
  @param _balanceIncentiveCurve_exponent Exponent for balance curve (see _calculateFloatPerSecond)
  @param _balanceIncentiveCurve_equilibriumOffset Offset for balance curve (see _calculateFloatPerSecond)
  */
  function addNewStakingFund(
    uint32 marketIndex,
    address longToken,
    address shortToken,
    uint256 kInitialMultiplier,
    uint256 kPeriod,
    uint256 unstakeFee_e18,
    uint256 _balanceIncentiveCurve_exponent,
    int256 _balanceIncentiveCurve_equilibriumOffset
  ) external override onlyLongShort {
    marketIndexOfToken[longToken] = marketIndex;
    marketIndexOfToken[shortToken] = marketIndex;

    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].timestamp = block.timestamp;
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].accumulativeFloatPerSyntheticToken_long = 0;
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].accumulativeFloatPerSyntheticToken_short = 0;

    syntheticTokens[marketIndex][true] = longToken;
    syntheticTokens[marketIndex][false] = shortToken;

    _changeBalanceIncentiveExponent(marketIndex, _balanceIncentiveCurve_exponent);
    _changeBalanceIncentiveEquilibriumOffset(marketIndex, _balanceIncentiveCurve_equilibriumOffset);
    _changeMarketLaunchIncentiveParameters(marketIndex, kPeriod, kInitialMultiplier);

    _changeUnstakeFee(marketIndex, unstakeFee_e18);

    // Set this value to one initially - 0 is a null value and thus potentially bug prone.
    batched_stakerNextTokenShiftIndex[marketIndex] = 1;

    emit MarketAddedToStaker(
      marketIndex,
      unstakeFee_e18,
      kPeriod,
      kInitialMultiplier,
      _balanceIncentiveCurve_exponent,
      _balanceIncentiveCurve_equilibriumOffset
    );

    emit AccumulativeIssuancePerStakedSynthSnapshotCreated(marketIndex, 0, 0, 0);
  }

  /*╔═════════════════════════════════════════════════════════════════════════╗
    ║    GLOBAL FLT REWARD ACCUMULATION CALCULATION AND TRACKING FUNCTIONS    ║
    ╚═════════════════════════════════════════════════════════════════════════╝*/

  /**
  @notice Returns the K factor parameters for the given market with sensible
  defaults if they haven't been set yet.
  @param marketIndex The market to change the parameters for.
  @return period The period for which the k factor applies for in seconds.
  @return multiplier The multiplier on Float generation in this period.
  */
  function _getMarketLaunchIncentiveParameters(uint32 marketIndex)
    internal
    view
    virtual
    returns (uint256 period, uint256 multiplier)
  {
    period = marketLaunchIncentive_period[marketIndex];
    multiplier = marketLaunchIncentive_multipliers[marketIndex];

    if (multiplier < 1e18) {
      multiplier = 1e18; // multiplier of 1 by default
    }
  }

  /** 
  @notice Returns the extent to which a markets float generation should be adjusted
  based on the market's launch incentive parameters. Should start at multiplier
  then linearly change to 1e18 over time.
  @param marketIndex Identifies the market.
  @return k The calculated modifier for float generation.
  */
  function _getKValue(uint32 marketIndex) internal view virtual returns (uint256) {
    // Parameters controlling the float issuance multiplier.
    (uint256 kPeriod, uint256 kInitialMultiplier) = _getMarketLaunchIncentiveParameters(marketIndex);

    // Sanity check - under normal circumstances, the multipliers should
    // *never* be set to a value < 1e18, as there are guards against this.
    assert(kInitialMultiplier >= 1e18);

    uint256 initialTimestamp = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].timestamp;

    if (block.timestamp - initialTimestamp <= kPeriod) {
      return kInitialMultiplier - (((kInitialMultiplier - 1e18) * (block.timestamp - initialTimestamp)) / kPeriod);
    } else {
      return 1e18;
    }
  }

  /*
  @notice Computes the number of float tokens a user earns per second for
  every long/short synthetic token they've staked. The returned value has
  a fixed decimal scale of 1e42 (!!!) for numerical stability. The return
  values are float per second per synthetic token (hence the requirement
  to multiply by price)
  @dev to see below math in latex form see TODO add link
  to interact with the equations see https://www.desmos.com/calculator/optkaxyihr
  @param marketIndex The market referred to.
  @param longPrice Price of the synthetic long token in units of payment token
  @param shortPrice Price of the synthetic short token in units of payment token
  @param longValue Amount of payment token in the long side of the market
  @param shortValue Amount of payment token in the short side of the market
  @return longFloatPerSecond Float token per second per long synthetic token
  @return shortFloatPerSecond Float token per second per short synthetic token
   */
  function _calculateFloatPerSecond(
    uint32 marketIndex,
    uint256 longPrice,
    uint256 shortPrice,
    uint256 longValue,
    uint256 shortValue
  ) internal view virtual returns (uint256 longFloatPerSecond, uint256 shortFloatPerSecond) {
    // A float issuance multiplier that starts high and decreases linearly
    // over time to a value of 1. This incentivises users to stake early.
    uint256 k = _getKValue(marketIndex);

    uint256 totalLocked = (longValue + shortValue);

    // we need to scale this number by the totalLocked so that the offset remains consistent accross market size

    int256 equilibriumOffsetMarketScaled = (balanceIncentiveCurve_equilibriumOffset[marketIndex] *
      int256(totalLocked)) / 2e18;

    uint256 denominator = ((totalLocked >> safeExponentBitShifting)**balanceIncentiveCurve_exponent[marketIndex]);

    // Float is scaled by the percentage of the total market value held in
    // the opposite position. This incentivises users to stake on the
    // weaker position.
    if (int256(shortValue) - equilibriumOffsetMarketScaled < int256(longValue)) {
      if (equilibriumOffsetMarketScaled >= int256(shortValue)) {
        // edge case: imbalanced far past the equilibrium offset - full rewards go to short token
        //            extremeley unlikely to happen in practice
        return (0, 1e18 * k * shortPrice);
      }

      uint256 numerator = (uint256(int256(shortValue) - equilibriumOffsetMarketScaled) >>
        (safeExponentBitShifting - 1))**balanceIncentiveCurve_exponent[marketIndex];

      // NOTE: `x * 5e17` == `(x * 10e18) / 2`
      uint256 longRewardUnscaled = (numerator * 5e17) / denominator;
      uint256 shortRewardUnscaled = 1e18 - longRewardUnscaled;

      return ((longRewardUnscaled * k * longPrice) / 1e18, (shortRewardUnscaled * k * shortPrice) / 1e18);
    } else {
      if (-equilibriumOffsetMarketScaled >= int256(longValue)) {
        // edge case: imbalanced far past the equilibrium offset - full rewards go to long token
        //            extremeley unlikely to happen in practice
        return (1e18 * k * longPrice, 0);
      }

      uint256 numerator = (uint256(int256(longValue) + equilibriumOffsetMarketScaled) >>
        (safeExponentBitShifting - 1))**balanceIncentiveCurve_exponent[marketIndex];

      // NOTE: `x * 5e17` == `(x * 10e18) / 2`
      uint256 shortRewardUnscaled = (numerator * 5e17) / denominator;
      uint256 longRewardUnscaled = 1e18 - shortRewardUnscaled;

      return ((longRewardUnscaled * k * longPrice) / 1e18, (shortRewardUnscaled * k * shortPrice) / 1e18);
    }
  }

  /**
  @notice Computes the time since last accumulativeIssuancePerStakedSynthSnapshot for the given market in seconds.
  @param marketIndex The market referred to.
  @return The time difference in seconds
  */
  function _calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(uint32 marketIndex)
    internal
    view
    virtual
    returns (uint256)
  {
    return
      block.timestamp -
      accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]].timestamp;
  }

  /**
  @notice Computes new cumulative sum of 'r' value since last accumulativeIssuancePerStakedSynthSnapshot. We use
  cumulative 'r' value to avoid looping during issuance. Note that the
  cumulative sum is kept in 1e42 scale (!!!) to avoid numerical issues.
  @param shortValue The value locked in the short side of the market.
  @param longValue The value locked in the long side of the market.
  @param shortPrice The price of the short token as defined in LongShort.sol
  @param longPrice The price of the long token as defined in LongShort.sol
  @param marketIndex An identifier for the market.
  @return longCumulativeRates The long cumulative sum.
  @return shortCumulativeRates The short cumulative sum.
  */
  function _calculateNewCumulativeIssuancePerStakedSynth(
    uint32 marketIndex,
    uint256 longPrice,
    uint256 shortPrice,
    uint256 longValue,
    uint256 shortValue
  ) internal view virtual returns (uint256 longCumulativeRates, uint256 shortCumulativeRates) {
    // Compute the current 'r' value for float issuance per second.
    (uint256 longFloatPerSecond, uint256 shortFloatPerSecond) = _calculateFloatPerSecond(
      marketIndex,
      longPrice,
      shortPrice,
      longValue,
      shortValue
    );

    // Compute time since last accumulativeIssuancePerStakedSynthSnapshot for the given token.
    uint256 timeDelta = _calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(marketIndex);

    // Compute new cumulative 'r' value total.
    return (
      accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]]
      .accumulativeFloatPerSyntheticToken_long + (timeDelta * longFloatPerSecond),
      accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]]
      .accumulativeFloatPerSyntheticToken_short + (timeDelta * shortFloatPerSecond)
    );
  }

  /**
  @notice Creates a new accumulativeIssuancePerStakedSynthSnapshot for the given token and updates indexes.
  @param shortValue The value locked in the short side of the market.
  @param longValue The value locked in the long side of the market.
  @param shortPrice The price of the short token as defined in LongShort.sol
  @param longPrice The price of the long token as defined in LongShort.sol
  @param marketIndex An identifier for the market.
  */
  function _setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot(
    uint32 marketIndex,
    uint256 longPrice,
    uint256 shortPrice,
    uint256 longValue,
    uint256 shortValue
  ) internal virtual {
    (
      uint256 newLongAccumulativeValue,
      uint256 newShortAccumulativeValue
    ) = _calculateNewCumulativeIssuancePerStakedSynth(marketIndex, longPrice, shortPrice, longValue, shortValue);

    uint256 newIndex = latestRewardIndex[marketIndex] + 1;

    // Set cumulative 'r' value on new accumulativeIssuancePerStakedSynthSnapshot.
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex]
    .accumulativeFloatPerSyntheticToken_long = newLongAccumulativeValue;
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex]
    .accumulativeFloatPerSyntheticToken_short = newShortAccumulativeValue;

    // Set timestamp on new accumulativeIssuancePerStakedSynthSnapshot.
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex].timestamp = block.timestamp;

    // Update latest index to point to new accumulativeIssuancePerStakedSynthSnapshot.
    latestRewardIndex[marketIndex] = newIndex;

    emit AccumulativeIssuancePerStakedSynthSnapshotCreated(
      marketIndex,
      newIndex,
      newLongAccumulativeValue,
      newShortAccumulativeValue
    );
  }

  /**
  @notice Adds new accumulativeIssuancePerStakedSynthSnapshots for the given long/short tokens. Called by the
  ILongShort contract whenever there is a state change for a market.
  @param stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted Mapping from this contract's shifts to LongShort.sols next price snapshots.
  @param shortValue The value locked in the short side of the market.
  @param longValue The value locked in the long side of the market.
  @param shortPrice The price of the short token as defined in LongShort.sol
  @param longPrice The price of the long token as defined in LongShort.sol
  @param marketIndex An identifier for the market.
  */
  function pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(
    uint32 marketIndex,
    uint256 longPrice,
    uint256 shortPrice,
    uint256 longValue,
    uint256 shortValue,
    uint256 stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted // This value should be ALWAYS be zero if no shift occured
  ) external override onlyLongShort {
    // Only add a new accumulativeIssuancePerStakedSynthSnapshot if some time has passed.

    // the `stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted` value will be 0 if there is no staker related action in an executed batch
    if (stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted > 0) {
      stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[
        batched_stakerNextTokenShiftIndex[marketIndex]
      ] = stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted;
      stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[
        batched_stakerNextTokenShiftIndex[marketIndex]
      ] = latestRewardIndex[marketIndex] + 1;
      batched_stakerNextTokenShiftIndex[marketIndex] += 1;

      emit SyntheticTokensShifted();
    }

    // Time delta is fetched twice in below code, can pass through? Which is less gas?
    if (_calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(marketIndex) > 0) {
      _setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot(
        marketIndex,
        longPrice,
        shortPrice,
        longValue,
        shortValue
      );
    }
  }

  /*╔═══════════════════════════════════╗
    ║    USER REWARD STATE FUNCTIONS    ║
    ╚═══════════════════════════════════╝*/

  /// @dev Calculates the accumulated float in a specific range of staker snapshots
  function _calculateAccumulatedFloatInRange(
    uint32 marketIndex,
    uint256 amountStakedLong,
    uint256 amountStakedShort,
    uint256 rewardIndexFrom,
    uint256 rewardIndexTo
  ) internal view virtual returns (uint256 floatReward) {
    if (amountStakedLong > 0) {
      uint256 accumDeltaLong = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexTo]
      .accumulativeFloatPerSyntheticToken_long -
        accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexFrom]
        .accumulativeFloatPerSyntheticToken_long;
      floatReward += (accumDeltaLong * amountStakedLong) / FLOAT_ISSUANCE_FIXED_DECIMAL;
    }

    if (amountStakedShort > 0) {
      uint256 accumDeltaShort = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexTo]
      .accumulativeFloatPerSyntheticToken_short -
        accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexFrom]
        .accumulativeFloatPerSyntheticToken_short;
      floatReward += (accumDeltaShort * amountStakedShort) / FLOAT_ISSUANCE_FIXED_DECIMAL;
    }
  }

  /** 
  @notice Calculates float owed to the user since the user last minted float for a market.
  @param marketIndex Identifier for the market which the user staked in.
  @param user The address of the user.
  @return floatReward The amount of float owed.
   */
  function _calculateAccumulatedFloat(uint32 marketIndex, address user) internal virtual returns (uint256 floatReward) {
    address longToken = syntheticTokens[marketIndex][true];
    address shortToken = syntheticTokens[marketIndex][false];

    uint256 amountStakedLong = userAmountStaked[longToken][user];
    uint256 amountStakedShort = userAmountStaked[shortToken][user];

    uint256 usersLastRewardIndex = userIndexOfLastClaimedReward[marketIndex][user];

    // Don't do the calculation and return zero immediately if there is no change
    if (usersLastRewardIndex == latestRewardIndex[marketIndex]) {
      return 0;
    }

    uint256 usersShiftIndex = userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][user];
    // if there is a change in the users tokens held due to a token shift (or possibly another action in the future)
    if (usersShiftIndex > 0 && usersShiftIndex < batched_stakerNextTokenShiftIndex[marketIndex]) {
      floatReward = _calculateAccumulatedFloatInRange(
        marketIndex,
        amountStakedLong,
        amountStakedShort,
        usersLastRewardIndex,
        stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[usersShiftIndex]
      );

      // Update the users balances
      if (userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user] > 0) {
        amountStakedShort += ILongShort(longShort).getAmountSyntheticTokenToMintOnTargetSide(
          marketIndex,
          userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user],
          true,
          stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[usersShiftIndex]
        );

        amountStakedLong -= userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user];
        userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user] = 0;
      }

      if (userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user] > 0) {
        amountStakedLong += ILongShort(longShort).getAmountSyntheticTokenToMintOnTargetSide(
          marketIndex,
          userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user],
          false,
          stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[usersShiftIndex]
        );

        amountStakedShort -= userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user];
        userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user] = 0;
      }

      // Save the users updated staked amounts
      userAmountStaked[longToken][user] = amountStakedLong;
      userAmountStaked[shortToken][user] = amountStakedShort;

      floatReward += _calculateAccumulatedFloatInRange(
        marketIndex,
        amountStakedLong,
        amountStakedShort,
        stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[usersShiftIndex],
        latestRewardIndex[marketIndex]
      );

      userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][user] = 0;
    } else {
      floatReward = _calculateAccumulatedFloatInRange(
        marketIndex,
        amountStakedLong,
        amountStakedShort,
        usersLastRewardIndex,
        latestRewardIndex[marketIndex]
      );
    }
  }

  /**
  @notice Mints float for a user.
  @dev Mints a fixed percentage for Float capital.
  @param user The address of the user.
  @param floatToMint The amount of float to mint.
   */
  function _mintFloat(address user, uint256 floatToMint) internal virtual {
    IFloatToken(floatToken).mint(user, floatToMint);
    IFloatToken(floatToken).mint(floatCapital, (floatToMint * floatPercentage) / 1e18);
  }

  /**
  @notice Mints float owed to a user for a market since they last minted.
  @param marketIndex An identifier for the market.
  @param user The address of the user.
   */
  function _mintAccumulatedFloat(uint32 marketIndex, address user) internal virtual {
    uint256 floatToMint = _calculateAccumulatedFloat(marketIndex, user);

    if (floatToMint > 0) {
      // Set the user has claimed up until now, stops them setting this forward
      userIndexOfLastClaimedReward[marketIndex][user] = latestRewardIndex[marketIndex];

      _mintFloat(user, floatToMint);
      emit FloatMinted(user, marketIndex, floatToMint);
    }
  }

  /**
  @notice Mints float owed to a user for multiple markets, since they last minted for those markets.
  @param marketIndexes Identifiers for the markets.
  @param user The address of the user.
   */
  function _mintAccumulatedFloatMulti(uint32[] calldata marketIndexes, address user) internal virtual {
    uint256 floatTotal = 0;
    for (uint256 i = 0; i < marketIndexes.length; i++) {
      uint256 floatToMint = _calculateAccumulatedFloat(marketIndexes[i], user);

      if (floatToMint > 0) {
        // Set the user has claimed up until now, stops them setting this forward
        userIndexOfLastClaimedReward[marketIndexes[i]][user] = latestRewardIndex[marketIndexes[i]];

        floatTotal += floatToMint;

        emit FloatMinted(user, marketIndexes[i], floatToMint);
      }
    }
    if (floatTotal > 0) {
      _mintFloat(user, floatTotal);
    }
  }

  /**
  @notice Mints outstanding float for msg.sender.
  @param marketIndexes Identifiers for the markets for which to mint float.
   */
  function claimFloatCustom(uint32[] calldata marketIndexes) external {
    ILongShort(longShort).updateSystemStateMulti(marketIndexes);
    _mintAccumulatedFloatMulti(marketIndexes, msg.sender);
  }

  /**
  @notice Mints outstanding float on behalf of another user.
  @param marketIndexes Identifiers for the markets for which to mint float.
  @param user The address of the user.
   */
  function claimFloatCustomFor(uint32[] calldata marketIndexes, address user) external {
    // Unbounded loop - users are responsible for paying their own gas costs on these and it doesn't effect the rest of the system.
    // No need to impose limit.
    ILongShort(longShort).updateSystemStateMulti(marketIndexes);
    _mintAccumulatedFloatMulti(marketIndexes, user);
  }

  /*╔═══════════════════════╗
    ║        STAKING        ║
    ╚═══════════════════════╝*/

  /**
  @notice A user with synthetic tokens stakes by calling stake on the token
  contract which calls this function. We need to first update the
  state of the LongShort contract for this market before staking to correctly calculate user rewards.
  @param amount Amount to stake.
  @param from Address to stake for.
  */
  function stakeFromUser(address from, uint256 amount) public virtual override onlyValidSynthetic((msg.sender)) {
    ILongShort(longShort).updateSystemState(marketIndexOfToken[(msg.sender)]);
    _stake((msg.sender), amount, from);
  }

  /**
  @dev Internal logic for staking.
  @param token Address of the token for which to stake.
  @param amount Amount to stake.
  @param user Address to stake for.
  */
  function _stake(
    address token,
    uint256 amount,
    address user
  ) internal virtual {
    uint32 marketIndex = marketIndexOfToken[token];

    // If they already have staked and have rewards due, mint these.
    if (
      userIndexOfLastClaimedReward[marketIndex][user] != 0 &&
      userIndexOfLastClaimedReward[marketIndex][user] < latestRewardIndex[marketIndex]
    ) {
      _mintAccumulatedFloat(marketIndex, user);
    }

    userAmountStaked[token][user] = userAmountStaked[token][user] + amount;

    userIndexOfLastClaimedReward[marketIndex][user] = latestRewardIndex[marketIndex];

    emit StakeAdded(user, address(token), amount, userIndexOfLastClaimedReward[marketIndex][user]);
  }

  /**
  @notice Allows users to shift their staked tokens from one side of the market to 
  the other at the next price.
  @param amountSyntheticTokensToShift Amount of tokens to shift.
  @param marketIndex Identifier for the market.
  @param isShiftFromLong Whether the shift is from long to short or short to long.
  */
  function shiftTokens(
    uint256 amountSyntheticTokensToShift,
    uint32 marketIndex,
    bool isShiftFromLong
  ) external virtual {
    address token = syntheticTokens[marketIndex][isShiftFromLong];
    require(userAmountStaked[token][msg.sender] >= amountSyntheticTokensToShift, "Not enough tokens to shift");

    // If the user has outstanding token shift that have already been confirmed in the LongShort
    // contract, execute them first.
    if (
      userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] != 0 &&
      userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] <
      batched_stakerNextTokenShiftIndex[marketIndex]
    ) {
      _mintAccumulatedFloat(marketIndex, msg.sender);
    }

    if (isShiftFromLong) {
      ILongShort(longShort).shiftPositionFromLongNextPrice(marketIndex, amountSyntheticTokensToShift);
      userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][
        msg.sender
      ] += amountSyntheticTokensToShift;
    } else {
      ILongShort(longShort).shiftPositionFromShortNextPrice(marketIndex, amountSyntheticTokensToShift);
      userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][
        msg.sender
      ] += amountSyntheticTokensToShift;
    }

    userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] = batched_stakerNextTokenShiftIndex[
      marketIndex
    ];
  }

  /*╔════════════════════════════╗
    ║    WITHDRAWAL & MINTING    ║
    ╚════════════════════════════╝*/

  /**
  @notice Internal logic for withdrawing stakes.
  @dev Mint user any outstanding float before withdrawing.
  @param marketIndex Market index of token.
  @param amount Amount to withdraw.
  @param token Synthetic token that was staked.
  */
  function _withdraw(
    uint32 marketIndex,
    address token,
    uint256 amount
  ) internal virtual {
    require(userAmountStaked[token][msg.sender] > 0, "nothing to withdraw");
    _mintAccumulatedFloat(marketIndex, msg.sender);

    userAmountStaked[token][msg.sender] = userAmountStaked[token][msg.sender] - amount;

    uint256 amountFees = (amount * marketUnstakeFee_e18[marketIndex]) / 1e18;

    IERC20(token).transfer(floatTreasury, amountFees);
    IERC20(token).transfer(msg.sender, amount - amountFees);

    emit StakeWithdrawn(msg.sender, token, amount);
  }

  /**
  @notice Withdraw function. Allows users to unstake.
  @param amount Amount to withdraw.
  @param token Address of the token for which to withdraw.
  */
  function withdraw(address token, uint256 amount) external {
    ILongShort(longShort).updateSystemState(marketIndexOfToken[token]);

    uint32 marketIndex = marketIndexOfToken[token];

    _withdraw(marketIndex, token, amount);

    if (userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] > 0) {
      // If they still have outstanding shifts after minting float, then check
      // that they don't withdraw more than their shifts allow.
      uint256 amountToShiftForThisToken = syntheticTokens[marketIndex][true] == token
        ? userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][msg.sender]
        : userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][msg.sender];

      require(
        userAmountStaked[token][msg.sender] >= amountToShiftForThisToken,
        "Outstanding next price stake shifts too great"
      );
    }
  }

  /**
  @notice Allows users to withdraw their entire stake for a token.
  @param token Address of the token for which to withdraw.
  */
  function withdrawAll(address token) external {
    ILongShort(longShort).updateSystemState(marketIndexOfToken[token]);

    uint32 marketIndex = marketIndexOfToken[token];

    uint256 amountToShiftForThisToken = syntheticTokens[marketIndex][true] == token
      ? userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][msg.sender]
      : userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][msg.sender];

    _withdraw(marketIndex, token, userAmountStaked[token][msg.sender] - amountToShiftForThisToken);
  }
}
.]

Given the user's task and the brainstorming ideas provided:
Task: "// SPDX-License-Identifier: BUSL-1.1

pragma solidity 0.8.3;

import "@openzeppelin/contracts-upgradeable/token/ERC20/presets/ERC20PresetMinterPauserUpgradeable.sol";

import "./interfaces/IFloatToken.sol";
import "./interfaces/ILongShort.sol";
import "./interfaces/IStaker.sol";
import "./interfaces/ISyntheticToken.sol";

contract Staker is IStaker, Initializable {
  /*╔═════════════════════════════╗
    ║          VARIABLES          ║
    ╚═════════════════════════════╝*/

  /* ══════ Fixed-precision constants ══════ */
  uint256 public constant FLOAT_ISSUANCE_FIXED_DECIMAL = 1e42;
  // 2^52 ~= 4.5e15
  // With an exponent of 5, the largest total liquidity possible in a market (to avoid integer overflow on exponentiation) is ~10^31 or 10 Trillion (10^13)
  // NOTE: this also means if the total market value is less than 2^52 there will be a division by zero error
  uint256 public constant safeExponentBitShifting = 52;

  /* ══════ Global state ══════ */
  address public admin;
  address public floatCapital;
  address public floatTreasury;
  uint256 public floatPercentage;

  address public longShort;
  address public floatToken;

  /* ══════ Market specific ══════ */
  mapping(uint32 => uint256) public marketLaunchIncentive_period; // seconds
  mapping(uint32 => uint256) public marketLaunchIncentive_multipliers; // e18 scale
  mapping(uint32 => uint256) public marketUnstakeFee_e18;
  mapping(uint32 => uint256) public balanceIncentiveCurve_exponent;
  mapping(uint32 => int256) public balanceIncentiveCurve_equilibriumOffset;

  mapping(uint32 => mapping(bool => address)) public syntheticTokens;

  mapping(address => uint32) public marketIndexOfToken;

  /* ══════ Reward specific ══════ */
  mapping(uint32 => uint256) public latestRewardIndex;
  mapping(uint32 => mapping(uint256 => AccumulativeIssuancePerStakedSynthSnapshot))
    public accumulativeFloatPerSyntheticTokenSnapshots;
  struct AccumulativeIssuancePerStakedSynthSnapshot {
    uint256 timestamp;
    uint256 accumulativeFloatPerSyntheticToken_long;
    uint256 accumulativeFloatPerSyntheticToken_short;
  }

  /* ══════ User specific ══════ */
  mapping(uint32 => mapping(address => uint256)) public userIndexOfLastClaimedReward;
  mapping(address => mapping(address => uint256)) public userAmountStaked;

  /* ══════ Token shift management specific ══════ */
  mapping(uint32 => uint256) public batched_stakerNextTokenShiftIndex;
  /**
  @notice Used to link a token shift to a staker state
  @dev tokenShiftIndex => accumulativeFloatIssuanceSnapshotIndex
    POSSIBLE OPTIMIZATION - could pack stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping and stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping into a struct of two uint128 for storage space optimization.
  */
  mapping(uint256 => uint256) public stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping;
  /// @notice Used to fetch the price from LongShort at that point in time
  /// @dev tokenShiftIndex => longShortMarketPriceSnapshotIndex
  mapping(uint256 => uint256) public stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping;
  /// @dev marketIndex => usersAddress => stakerTokenShiftIndex
  mapping(uint32 => mapping(address => uint256)) public userNextPrice_stakedSyntheticTokenShiftIndex;
  /// @dev marketIndex => usersAddress => amountUserRequestedToShiftAwayFromLongOnNextUpdate
  mapping(uint32 => mapping(address => uint256)) public userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long;
  /// @dev marketIndex => usersAddress => amountUserRequestedToShiftAwayFromShortOnNextUpdate
  mapping(uint32 => mapping(address => uint256)) public userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short;

  /*╔════════════════════════════╗
    ║           EVENTS           ║
    ╚════════════════════════════╝*/

  event StakerV1(
    address admin,
    address floatTreasury,
    address floatCapital,
    address floatToken,
    uint256 floatPercentage
  );

  event MarketAddedToStaker(
    uint32 marketIndex,
    uint256 exitFee_e18,
    uint256 period,
    uint256 multiplier,
    uint256 balanceIncentiveExponent,
    int256 balanceIncentiveEquilibriumOffset
  );

  event AccumulativeIssuancePerStakedSynthSnapshotCreated(
    uint32 marketIndex,
    uint256 accumulativeFloatIssuanceSnapshotIndex,
    uint256 accumulativeLong,
    uint256 accumulativeShort
  );

  event StakeAdded(address user, address token, uint256 amount, uint256 lastMintIndex);

  event StakeWithdrawn(address user, address token, uint256 amount);

  // Note: the `amountFloatMinted` isn't strictly needed by the graph, but it is good to add it to validate calculations are accurate.
  event FloatMinted(address user, uint32 marketIndex, uint256 amountFloatMinted);

  event MarketLaunchIncentiveParametersChanges(uint32 marketIndex, uint256 period, uint256 multiplier);

  event StakeWithdrawalFeeUpdated(uint32 marketIndex, uint256 stakeWithdralFee);

  event BalanceIncentiveExponentUpdated(uint32 marketIndex, uint256 balanceIncentiveExponent);

  event BalanceIncentiveEquilibriumOffsetUpdated(uint32 marketIndex, int256 balanceIncentiveEquilibriumOffset);

  event FloatPercentageUpdated(uint256 floatPercentage);

  event SyntheticTokensShifted();

  event ChangeAdmin(address newAdmin);

  /*╔═════════════════════════════╗
    ║          MODIFIERS          ║
    ╚═════════════════════════════╝*/

  function onlyAdminModifierLogic() internal virtual {
    require(msg.sender == admin, "not admin");
  }

  modifier onlyAdmin() {
    onlyAdminModifierLogic();
    _;
  }

  function onlyValidSyntheticModifierLogic(address _synth) internal virtual {
    require(marketIndexOfToken[_synth] != 0, "not valid synth");
  }

  modifier onlyValidSynthetic(address _synth) {
    onlyValidSyntheticModifierLogic(_synth);
    _;
  }

  function onlyValidMarketModifierLogic(uint32 marketIndex) internal virtual {
    require(address(syntheticTokens[marketIndex][true]) != address(0), "not valid market");
  }

  modifier onlyValidMarket(uint32 marketIndex) {
    onlyValidMarketModifierLogic(marketIndex);
    _;
  }

  function onlyLongShortModifierLogic() internal virtual {
    require(msg.sender == address(longShort), "not long short");
  }

  modifier onlyLongShort() {
    onlyLongShortModifierLogic();
    _;
  }

  /*╔═════════════════════════════╗
    ║       CONTRACT SET-UP       ║
    ╚═════════════════════════════╝*/

  /**
  @notice Initializes the contract.
  @dev Calls OpenZeppelin's initializer modifier.
  @param _admin Address of the admin role.
  @param _longShort Address of the LongShort contract, a deployed LongShort.sol
  @param _floatToken Address of the Float token earned by staking.
  @param _floatTreasury Address of the treasury contract for managing fees.
  @param _floatCapital Address of the contract which earns a fixed percentage of Float.
  @param _floatPercentage Determines the float percentage that gets minted for Float Capital, base 1e18.
  */
  function initialize(
    address _admin,
    address _longShort,
    address _floatToken,
    address _floatTreasury,
    address _floatCapital,
    uint256 _floatPercentage
  ) external virtual initializer {
    admin = _admin;
    floatCapital = _floatCapital;
    floatTreasury = _floatTreasury;
    longShort = _longShort;
    floatToken = _floatToken;

    _changeFloatPercentage(_floatPercentage);

    emit StakerV1(_admin, _floatTreasury, _floatCapital, _floatToken, _floatPercentage);
  }

  /*╔═══════════════════╗
    ║       ADMIN       ║
    ╚═══════════════════╝*/

  /** 
  @notice Changes admin for the contract
  @param _admin The address of the new admin.
  */
  function changeAdmin(address _admin) external onlyAdmin {
    admin = _admin;
    emit ChangeAdmin(_admin);
  }

  /// @dev Logic for changeFloatPercentage
  function _changeFloatPercentage(uint256 newFloatPercentage) internal virtual {
    require(newFloatPercentage <= 1e18 && newFloatPercentage > 0); // less than or equal to 100% and greater than 0%
    floatPercentage = newFloatPercentage;
  }

  /**
  @notice Changes percentage of float that is minted for float capital.
  @param newFloatPercentage The new float percentage in base 1e18.
  */
  function changeFloatPercentage(uint256 newFloatPercentage) external onlyAdmin {
    _changeFloatPercentage(newFloatPercentage);
    emit FloatPercentageUpdated(newFloatPercentage);
  }

  /// @dev Logic for changeUnstakeFee
  function _changeUnstakeFee(uint32 marketIndex, uint256 newMarketUnstakeFee_e18) internal virtual {
    require(newMarketUnstakeFee_e18 <= 5e16); // Explicitely stating 5% fee as the max fee possible.
    marketUnstakeFee_e18[marketIndex] = newMarketUnstakeFee_e18;
  }

  /**
  @notice Changes unstake fee for a market
  @param marketIndex Identifies the market.
  @param newMarketUnstakeFee_e18 The new unstake fee.
  */
  function changeUnstakeFee(uint32 marketIndex, uint256 newMarketUnstakeFee_e18) external onlyAdmin {
    _changeUnstakeFee(marketIndex, newMarketUnstakeFee_e18);
    emit StakeWithdrawalFeeUpdated(marketIndex, newMarketUnstakeFee_e18);
  }

  /// @dev Logic for changeMarketLaunchIncentiveParameters
  function _changeMarketLaunchIncentiveParameters(
    uint32 marketIndex,
    uint256 period,
    uint256 initialMultiplier
  ) internal virtual {
    require(initialMultiplier >= 1e18, "marketLaunchIncentiveMultiplier must be >= 1e18");

    marketLaunchIncentive_period[marketIndex] = period;
    marketLaunchIncentive_multipliers[marketIndex] = initialMultiplier;
  }

  /**
  @notice Changes the market launch incentive parameters for a market
  @param marketIndex Identifies the market.
  @param period The new period for which float token generation should be boosted.
  @param initialMultiplier The new multiplier on Float generation.
  */
  function changeMarketLaunchIncentiveParameters(
    uint32 marketIndex,
    uint256 period,
    uint256 initialMultiplier
  ) external onlyAdmin {
    _changeMarketLaunchIncentiveParameters(marketIndex, period, initialMultiplier);

    emit MarketLaunchIncentiveParametersChanges(marketIndex, period, initialMultiplier);
  }

  /// @dev Logic for changeBalanceIncentiveExponent
  function _changeBalanceIncentiveExponent(uint32 marketIndex, uint256 _balanceIncentiveCurve_exponent)
    internal
    virtual
  {
    require(
      // The exponent has to be less than 5 in these versions of the contracts.
      _balanceIncentiveCurve_exponent > 0 && _balanceIncentiveCurve_exponent < 6,
      "balanceIncentiveCurve_exponent out of bounds"
    );

    balanceIncentiveCurve_exponent[marketIndex] = _balanceIncentiveCurve_exponent;
  }

  /** 
  @notice Changes the balance incentive exponent for a market
  @param marketIndex Identifies the market.
  @param _balanceIncentiveCurve_exponent The new exponent for the curve.
  */
  function changeBalanceIncentiveExponent(uint32 marketIndex, uint256 _balanceIncentiveCurve_exponent)
    external
    onlyAdmin
  {
    _changeBalanceIncentiveExponent(marketIndex, _balanceIncentiveCurve_exponent);

    emit BalanceIncentiveExponentUpdated(marketIndex, _balanceIncentiveCurve_exponent);
  }

  /// @dev Logic for changeBalanceIncentiveEquilibriumOffset
  function _changeBalanceIncentiveEquilibriumOffset(uint32 marketIndex, int256 _balanceIncentiveCurve_equilibriumOffset)
    internal
    virtual
  {
    // Unreasonable that we would ever shift this more than 90% either way
    require(
      _balanceIncentiveCurve_equilibriumOffset > -9e17 && _balanceIncentiveCurve_equilibriumOffset < 9e17,
      "balanceIncentiveCurve_equilibriumOffset out of bounds"
    );

    balanceIncentiveCurve_equilibriumOffset[marketIndex] = _balanceIncentiveCurve_equilibriumOffset;
  }

  /**
  @notice Changes the balance incentive curve equilibrium offset for a market
  @param marketIndex Identifies the market.
  @param _balanceIncentiveCurve_equilibriumOffset The new offset.
  */
  function changeBalanceIncentiveEquilibriumOffset(uint32 marketIndex, int256 _balanceIncentiveCurve_equilibriumOffset)
    external
    onlyAdmin
  {
    _changeBalanceIncentiveEquilibriumOffset(marketIndex, _balanceIncentiveCurve_equilibriumOffset);

    emit BalanceIncentiveEquilibriumOffsetUpdated(marketIndex, _balanceIncentiveCurve_equilibriumOffset);
  }

  /*╔═════════════════════════════╗
    ║        STAKING SETUP        ║
    ╚═════════════════════════════╝*/

  /**
  @notice Sets this contract to track staking for a market in LongShort.sol
  @param marketIndex Identifies the market.
  @param longToken Address of the long token for the market.
  @param shortToken Address of the short token for the market.
  @param kInitialMultiplier Initial boost on float generation for the market.
  @param kPeriod Period which the boost should last.
  @param unstakeFee_e18 Percentage of tokens that are levied on unstaking in base 1e18.
  @param _balanceIncentiveCurve_exponent Exponent for balance curve (see _calculateFloatPerSecond)
  @param _balanceIncentiveCurve_equilibriumOffset Offset for balance curve (see _calculateFloatPerSecond)
  */
  function addNewStakingFund(
    uint32 marketIndex,
    address longToken,
    address shortToken,
    uint256 kInitialMultiplier,
    uint256 kPeriod,
    uint256 unstakeFee_e18,
    uint256 _balanceIncentiveCurve_exponent,
    int256 _balanceIncentiveCurve_equilibriumOffset
  ) external override onlyLongShort {
    marketIndexOfToken[longToken] = marketIndex;
    marketIndexOfToken[shortToken] = marketIndex;

    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].timestamp = block.timestamp;
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].accumulativeFloatPerSyntheticToken_long = 0;
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].accumulativeFloatPerSyntheticToken_short = 0;

    syntheticTokens[marketIndex][true] = longToken;
    syntheticTokens[marketIndex][false] = shortToken;

    _changeBalanceIncentiveExponent(marketIndex, _balanceIncentiveCurve_exponent);
    _changeBalanceIncentiveEquilibriumOffset(marketIndex, _balanceIncentiveCurve_equilibriumOffset);
    _changeMarketLaunchIncentiveParameters(marketIndex, kPeriod, kInitialMultiplier);

    _changeUnstakeFee(marketIndex, unstakeFee_e18);

    // Set this value to one initially - 0 is a null value and thus potentially bug prone.
    batched_stakerNextTokenShiftIndex[marketIndex] = 1;

    emit MarketAddedToStaker(
      marketIndex,
      unstakeFee_e18,
      kPeriod,
      kInitialMultiplier,
      _balanceIncentiveCurve_exponent,
      _balanceIncentiveCurve_equilibriumOffset
    );

    emit AccumulativeIssuancePerStakedSynthSnapshotCreated(marketIndex, 0, 0, 0);
  }

  /*╔═════════════════════════════════════════════════════════════════════════╗
    ║    GLOBAL FLT REWARD ACCUMULATION CALCULATION AND TRACKING FUNCTIONS    ║
    ╚═════════════════════════════════════════════════════════════════════════╝*/

  /**
  @notice Returns the K factor parameters for the given market with sensible
  defaults if they haven't been set yet.
  @param marketIndex The market to change the parameters for.
  @return period The period for which the k factor applies for in seconds.
  @return multiplier The multiplier on Float generation in this period.
  */
  function _getMarketLaunchIncentiveParameters(uint32 marketIndex)
    internal
    view
    virtual
    returns (uint256 period, uint256 multiplier)
  {
    period = marketLaunchIncentive_period[marketIndex];
    multiplier = marketLaunchIncentive_multipliers[marketIndex];

    if (multiplier < 1e18) {
      multiplier = 1e18; // multiplier of 1 by default
    }
  }

  /** 
  @notice Returns the extent to which a markets float generation should be adjusted
  based on the market's launch incentive parameters. Should start at multiplier
  then linearly change to 1e18 over time.
  @param marketIndex Identifies the market.
  @return k The calculated modifier for float generation.
  */
  function _getKValue(uint32 marketIndex) internal view virtual returns (uint256) {
    // Parameters controlling the float issuance multiplier.
    (uint256 kPeriod, uint256 kInitialMultiplier) = _getMarketLaunchIncentiveParameters(marketIndex);

    // Sanity check - under normal circumstances, the multipliers should
    // *never* be set to a value < 1e18, as there are guards against this.
    assert(kInitialMultiplier >= 1e18);

    uint256 initialTimestamp = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].timestamp;

    if (block.timestamp - initialTimestamp <= kPeriod) {
      return kInitialMultiplier - (((kInitialMultiplier - 1e18) * (block.timestamp - initialTimestamp)) / kPeriod);
    } else {
      return 1e18;
    }
  }

  /*
  @notice Computes the number of float tokens a user earns per second for
  every long/short synthetic token they've staked. The returned value has
  a fixed decimal scale of 1e42 (!!!) for numerical stability. The return
  values are float per second per synthetic token (hence the requirement
  to multiply by price)
  @dev to see below math in latex form see TODO add link
  to interact with the equations see https://www.desmos.com/calculator/optkaxyihr
  @param marketIndex The market referred to.
  @param longPrice Price of the synthetic long token in units of payment token
  @param shortPrice Price of the synthetic short token in units of payment token
  @param longValue Amount of payment token in the long side of the market
  @param shortValue Amount of payment token in the short side of the market
  @return longFloatPerSecond Float token per second per long synthetic token
  @return shortFloatPerSecond Float token per second per short synthetic token
   */
  function _calculateFloatPerSecond(
    uint32 marketIndex,
    uint256 longPrice,
    uint256 shortPrice,
    uint256 longValue,
    uint256 shortValue
  ) internal view virtual returns (uint256 longFloatPerSecond, uint256 shortFloatPerSecond) {
    // A float issuance multiplier that starts high and decreases linearly
    // over time to a value of 1. This incentivises users to stake early.
    uint256 k = _getKValue(marketIndex);

    uint256 totalLocked = (longValue + shortValue);

    // we need to scale this number by the totalLocked so that the offset remains consistent accross market size

    int256 equilibriumOffsetMarketScaled = (balanceIncentiveCurve_equilibriumOffset[marketIndex] *
      int256(totalLocked)) / 2e18;

    uint256 denominator = ((totalLocked >> safeExponentBitShifting)**balanceIncentiveCurve_exponent[marketIndex]);

    // Float is scaled by the percentage of the total market value held in
    // the opposite position. This incentivises users to stake on the
    // weaker position.
    if (int256(shortValue) - equilibriumOffsetMarketScaled < int256(longValue)) {
      if (equilibriumOffsetMarketScaled >= int256(shortValue)) {
        // edge case: imbalanced far past the equilibrium offset - full rewards go to short token
        //            extremeley unlikely to happen in practice
        return (0, 1e18 * k * shortPrice);
      }

      uint256 numerator = (uint256(int256(shortValue) - equilibriumOffsetMarketScaled) >>
        (safeExponentBitShifting - 1))**balanceIncentiveCurve_exponent[marketIndex];

      // NOTE: `x * 5e17` == `(x * 10e18) / 2`
      uint256 longRewardUnscaled = (numerator * 5e17) / denominator;
      uint256 shortRewardUnscaled = 1e18 - longRewardUnscaled;

      return ((longRewardUnscaled * k * longPrice) / 1e18, (shortRewardUnscaled * k * shortPrice) / 1e18);
    } else {
      if (-equilibriumOffsetMarketScaled >= int256(longValue)) {
        // edge case: imbalanced far past the equilibrium offset - full rewards go to long token
        //            extremeley unlikely to happen in practice
        return (1e18 * k * longPrice, 0);
      }

      uint256 numerator = (uint256(int256(longValue) + equilibriumOffsetMarketScaled) >>
        (safeExponentBitShifting - 1))**balanceIncentiveCurve_exponent[marketIndex];

      // NOTE: `x * 5e17` == `(x * 10e18) / 2`
      uint256 shortRewardUnscaled = (numerator * 5e17) / denominator;
      uint256 longRewardUnscaled = 1e18 - shortRewardUnscaled;

      return ((longRewardUnscaled * k * longPrice) / 1e18, (shortRewardUnscaled * k * shortPrice) / 1e18);
    }
  }

  /**
  @notice Computes the time since last accumulativeIssuancePerStakedSynthSnapshot for the given market in seconds.
  @param marketIndex The market referred to.
  @return The time difference in seconds
  */
  function _calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(uint32 marketIndex)
    internal
    view
    virtual
    returns (uint256)
  {
    return
      block.timestamp -
      accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]].timestamp;
  }

  /**
  @notice Computes new cumulative sum of 'r' value since last accumulativeIssuancePerStakedSynthSnapshot. We use
  cumulative 'r' value to avoid looping during issuance. Note that the
  cumulative sum is kept in 1e42 scale (!!!) to avoid numerical issues.
  @param shortValue The value locked in the short side of the market.
  @param longValue The value locked in the long side of the market.
  @param shortPrice The price of the short token as defined in LongShort.sol
  @param longPrice The price of the long token as defined in LongShort.sol
  @param marketIndex An identifier for the market.
  @return longCumulativeRates The long cumulative sum.
  @return shortCumulativeRates The short cumulative sum.
  */
  function _calculateNewCumulativeIssuancePerStakedSynth(
    uint32 marketIndex,
    uint256 longPrice,
    uint256 shortPrice,
    uint256 longValue,
    uint256 shortValue
  ) internal view virtual returns (uint256 longCumulativeRates, uint256 shortCumulativeRates) {
    // Compute the current 'r' value for float issuance per second.
    (uint256 longFloatPerSecond, uint256 shortFloatPerSecond) = _calculateFloatPerSecond(
      marketIndex,
      longPrice,
      shortPrice,
      longValue,
      shortValue
    );

    // Compute time since last accumulativeIssuancePerStakedSynthSnapshot for the given token.
    uint256 timeDelta = _calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(marketIndex);

    // Compute new cumulative 'r' value total.
    return (
      accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]]
      .accumulativeFloatPerSyntheticToken_long + (timeDelta * longFloatPerSecond),
      accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]]
      .accumulativeFloatPerSyntheticToken_short + (timeDelta * shortFloatPerSecond)
    );
  }

  /**
  @notice Creates a new accumulativeIssuancePerStakedSynthSnapshot for the given token and updates indexes.
  @param shortValue The value locked in the short side of the market.
  @param longValue The value locked in the long side of the market.
  @param shortPrice The price of the short token as defined in LongShort.sol
  @param longPrice The price of the long token as defined in LongShort.sol
  @param marketIndex An identifier for the market.
  */
  function _setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot(
    uint32 marketIndex,
    uint256 longPrice,
    uint256 shortPrice,
    uint256 longValue,
    uint256 shortValue
  ) internal virtual {
    (
      uint256 newLongAccumulativeValue,
      uint256 newShortAccumulativeValue
    ) = _calculateNewCumulativeIssuancePerStakedSynth(marketIndex, longPrice, shortPrice, longValue, shortValue);

    uint256 newIndex = latestRewardIndex[marketIndex] + 1;

    // Set cumulative 'r' value on new accumulativeIssuancePerStakedSynthSnapshot.
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex]
    .accumulativeFloatPerSyntheticToken_long = newLongAccumulativeValue;
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex]
    .accumulativeFloatPerSyntheticToken_short = newShortAccumulativeValue;

    // Set timestamp on new accumulativeIssuancePerStakedSynthSnapshot.
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex].timestamp = block.timestamp;

    // Update latest index to point to new accumulativeIssuancePerStakedSynthSnapshot.
    latestRewardIndex[marketIndex] = newIndex;

    emit AccumulativeIssuancePerStakedSynthSnapshotCreated(
      marketIndex,
      newIndex,
      newLongAccumulativeValue,
      newShortAccumulativeValue
    );
  }

  /**
  @notice Adds new accumulativeIssuancePerStakedSynthSnapshots for the given long/short tokens. Called by the
  ILongShort contract whenever there is a state change for a market.
  @param stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted Mapping from this contract's shifts to LongShort.sols next price snapshots.
  @param shortValue The value locked in the short side of the market.
  @param longValue The value locked in the long side of the market.
  @param shortPrice The price of the short token as defined in LongShort.sol
  @param longPrice The price of the long token as defined in LongShort.sol
  @param marketIndex An identifier for the market.
  */
  function pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(
    uint32 marketIndex,
    uint256 longPrice,
    uint256 shortPrice,
    uint256 longValue,
    uint256 shortValue,
    uint256 stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted // This value should be ALWAYS be zero if no shift occured
  ) external override onlyLongShort {
    // Only add a new accumulativeIssuancePerStakedSynthSnapshot if some time has passed.

    // the `stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted` value will be 0 if there is no staker related action in an executed batch
    if (stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted > 0) {
      stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[
        batched_stakerNextTokenShiftIndex[marketIndex]
      ] = stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted;
      stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[
        batched_stakerNextTokenShiftIndex[marketIndex]
      ] = latestRewardIndex[marketIndex] + 1;
      batched_stakerNextTokenShiftIndex[marketIndex] += 1;

      emit SyntheticTokensShifted();
    }

    // Time delta is fetched twice in below code, can pass through? Which is less gas?
    if (_calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(marketIndex) > 0) {
      _setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot(
        marketIndex,
        longPrice,
        shortPrice,
        longValue,
        shortValue
      );
    }
  }

  /*╔═══════════════════════════════════╗
    ║    USER REWARD STATE FUNCTIONS    ║
    ╚═══════════════════════════════════╝*/

  /// @dev Calculates the accumulated float in a specific range of staker snapshots
  function _calculateAccumulatedFloatInRange(
    uint32 marketIndex,
    uint256 amountStakedLong,
    uint256 amountStakedShort,
    uint256 rewardIndexFrom,
    uint256 rewardIndexTo
  ) internal view virtual returns (uint256 floatReward) {
    if (amountStakedLong > 0) {
      uint256 accumDeltaLong = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexTo]
      .accumulativeFloatPerSyntheticToken_long -
        accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexFrom]
        .accumulativeFloatPerSyntheticToken_long;
      floatReward += (accumDeltaLong * amountStakedLong) / FLOAT_ISSUANCE_FIXED_DECIMAL;
    }

    if (amountStakedShort > 0) {
      uint256 accumDeltaShort = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexTo]
      .accumulativeFloatPerSyntheticToken_short -
        accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexFrom]
        .accumulativeFloatPerSyntheticToken_short;
      floatReward += (accumDeltaShort * amountStakedShort) / FLOAT_ISSUANCE_FIXED_DECIMAL;
    }
  }

  /** 
  @notice Calculates float owed to the user since the user last minted float for a market.
  @param marketIndex Identifier for the market which the user staked in.
  @param user The address of the user.
  @return floatReward The amount of float owed.
   */
  function _calculateAccumulatedFloat(uint32 marketIndex, address user) internal virtual returns (uint256 floatReward) {
    address longToken = syntheticTokens[marketIndex][true];
    address shortToken = syntheticTokens[marketIndex][false];

    uint256 amountStakedLong = userAmountStaked[longToken][user];
    uint256 amountStakedShort = userAmountStaked[shortToken][user];

    uint256 usersLastRewardIndex = userIndexOfLastClaimedReward[marketIndex][user];

    // Don't do the calculation and return zero immediately if there is no change
    if (usersLastRewardIndex == latestRewardIndex[marketIndex]) {
      return 0;
    }

    uint256 usersShiftIndex = userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][user];
    // if there is a change in the users tokens held due to a token shift (or possibly another action in the future)
    if (usersShiftIndex > 0 && usersShiftIndex < batched_stakerNextTokenShiftIndex[marketIndex]) {
      floatReward = _calculateAccumulatedFloatInRange(
        marketIndex,
        amountStakedLong,
        amountStakedShort,
        usersLastRewardIndex,
        stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[usersShiftIndex]
      );

      // Update the users balances
      if (userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user] > 0) {
        amountStakedShort += ILongShort(longShort).getAmountSyntheticTokenToMintOnTargetSide(
          marketIndex,
          userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user],
          true,
          stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[usersShiftIndex]
        );

        amountStakedLong -= userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user];
        userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user] = 0;
      }

      if (userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user] > 0) {
        amountStakedLong += ILongShort(longShort).getAmountSyntheticTokenToMintOnTargetSide(
          marketIndex,
          userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user],
          false,
          stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[usersShiftIndex]
        );

        amountStakedShort -= userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user];
        userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user] = 0;
      }

      // Save the users updated staked amounts
      userAmountStaked[longToken][user] = amountStakedLong;
      userAmountStaked[shortToken][user] = amountStakedShort;

      floatReward += _calculateAccumulatedFloatInRange(
        marketIndex,
        amountStakedLong,
        amountStakedShort,
        stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[usersShiftIndex],
        latestRewardIndex[marketIndex]
      );

      userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][user] = 0;
    } else {
      floatReward = _calculateAccumulatedFloatInRange(
        marketIndex,
        amountStakedLong,
        amountStakedShort,
        usersLastRewardIndex,
        latestRewardIndex[marketIndex]
      );
    }
  }

  /**
  @notice Mints float for a user.
  @dev Mints a fixed percentage for Float capital.
  @param user The address of the user.
  @param floatToMint The amount of float to mint.
   */
  function _mintFloat(address user, uint256 floatToMint) internal virtual {
    IFloatToken(floatToken).mint(user, floatToMint);
    IFloatToken(floatToken).mint(floatCapital, (floatToMint * floatPercentage) / 1e18);
  }

  /**
  @notice Mints float owed to a user for a market since they last minted.
  @param marketIndex An identifier for the market.
  @param user The address of the user.
   */
  function _mintAccumulatedFloat(uint32 marketIndex, address user) internal virtual {
    uint256 floatToMint = _calculateAccumulatedFloat(marketIndex, user);

    if (floatToMint > 0) {
      // Set the user has claimed up until now, stops them setting this forward
      userIndexOfLastClaimedReward[marketIndex][user] = latestRewardIndex[marketIndex];

      _mintFloat(user, floatToMint);
      emit FloatMinted(user, marketIndex, floatToMint);
    }
  }

  /**
  @notice Mints float owed to a user for multiple markets, since they last minted for those markets.
  @param marketIndexes Identifiers for the markets.
  @param user The address of the user.
   */
  function _mintAccumulatedFloatMulti(uint32[] calldata marketIndexes, address user) internal virtual {
    uint256 floatTotal = 0;
    for (uint256 i = 0; i < marketIndexes.length; i++) {
      uint256 floatToMint = _calculateAccumulatedFloat(marketIndexes[i], user);

      if (floatToMint > 0) {
        // Set the user has claimed up until now, stops them setting this forward
        userIndexOfLastClaimedReward[marketIndexes[i]][user] = latestRewardIndex[marketIndexes[i]];

        floatTotal += floatToMint;

        emit FloatMinted(user, marketIndexes[i], floatToMint);
      }
    }
    if (floatTotal > 0) {
      _mintFloat(user, floatTotal);
    }
  }

  /**
  @notice Mints outstanding float for msg.sender.
  @param marketIndexes Identifiers for the markets for which to mint float.
   */
  function claimFloatCustom(uint32[] calldata marketIndexes) external {
    ILongShort(longShort).updateSystemStateMulti(marketIndexes);
    _mintAccumulatedFloatMulti(marketIndexes, msg.sender);
  }

  /**
  @notice Mints outstanding float on behalf of another user.
  @param marketIndexes Identifiers for the markets for which to mint float.
  @param user The address of the user.
   */
  function claimFloatCustomFor(uint32[] calldata marketIndexes, address user) external {
    // Unbounded loop - users are responsible for paying their own gas costs on these and it doesn't effect the rest of the system.
    // No need to impose limit.
    ILongShort(longShort).updateSystemStateMulti(marketIndexes);
    _mintAccumulatedFloatMulti(marketIndexes, user);
  }

  /*╔═══════════════════════╗
    ║        STAKING        ║
    ╚═══════════════════════╝*/

  /**
  @notice A user with synthetic tokens stakes by calling stake on the token
  contract which calls this function. We need to first update the
  state of the LongShort contract for this market before staking to correctly calculate user rewards.
  @param amount Amount to stake.
  @param from Address to stake for.
  */
  function stakeFromUser(address from, uint256 amount) public virtual override onlyValidSynthetic((msg.sender)) {
    ILongShort(longShort).updateSystemState(marketIndexOfToken[(msg.sender)]);
    _stake((msg.sender), amount, from);
  }

  /**
  @dev Internal logic for staking.
  @param token Address of the token for which to stake.
  @param amount Amount to stake.
  @param user Address to stake for.
  */
  function _stake(
    address token,
    uint256 amount,
    address user
  ) internal virtual {
    uint32 marketIndex = marketIndexOfToken[token];

    // If they already have staked and have rewards due, mint these.
    if (
      userIndexOfLastClaimedReward[marketIndex][user] != 0 &&
      userIndexOfLastClaimedReward[marketIndex][user] < latestRewardIndex[marketIndex]
    ) {
      _mintAccumulatedFloat(marketIndex, user);
    }

    userAmountStaked[token][user] = userAmountStaked[token][user] + amount;

    userIndexOfLastClaimedReward[marketIndex][user] = latestRewardIndex[marketIndex];

    emit StakeAdded(user, address(token), amount, userIndexOfLastClaimedReward[marketIndex][user]);
  }

  /**
  @notice Allows users to shift their staked tokens from one side of the market to 
  the other at the next price.
  @param amountSyntheticTokensToShift Amount of tokens to shift.
  @param marketIndex Identifier for the market.
  @param isShiftFromLong Whether the shift is from long to short or short to long.
  */
  function shiftTokens(
    uint256 amountSyntheticTokensToShift,
    uint32 marketIndex,
    bool isShiftFromLong
  ) external virtual {
    address token = syntheticTokens[marketIndex][isShiftFromLong];
    require(userAmountStaked[token][msg.sender] >= amountSyntheticTokensToShift, "Not enough tokens to shift");

    // If the user has outstanding token shift that have already been confirmed in the LongShort
    // contract, execute them first.
    if (
      userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] != 0 &&
      userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] <
      batched_stakerNextTokenShiftIndex[marketIndex]
    ) {
      _mintAccumulatedFloat(marketIndex, msg.sender);
    }

    if (isShiftFromLong) {
      ILongShort(longShort).shiftPositionFromLongNextPrice(marketIndex, amountSyntheticTokensToShift);
      userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][
        msg.sender
      ] += amountSyntheticTokensToShift;
    } else {
      ILongShort(longShort).shiftPositionFromShortNextPrice(marketIndex, amountSyntheticTokensToShift);
      userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][
        msg.sender
      ] += amountSyntheticTokensToShift;
    }

    userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] = batched_stakerNextTokenShiftIndex[
      marketIndex
    ];
  }

  /*╔════════════════════════════╗
    ║    WITHDRAWAL & MINTING    ║
    ╚════════════════════════════╝*/

  /**
  @notice Internal logic for withdrawing stakes.
  @dev Mint user any outstanding float before withdrawing.
  @param marketIndex Market index of token.
  @param amount Amount to withdraw.
  @param token Synthetic token that was staked.
  */
  function _withdraw(
    uint32 marketIndex,
    address token,
    uint256 amount
  ) internal virtual {
    require(userAmountStaked[token][msg.sender] > 0, "nothing to withdraw");
    _mintAccumulatedFloat(marketIndex, msg.sender);

    userAmountStaked[token][msg.sender] = userAmountStaked[token][msg.sender] - amount;

    uint256 amountFees = (amount * marketUnstakeFee_e18[marketIndex]) / 1e18;

    IERC20(token).transfer(floatTreasury, amountFees);
    IERC20(token).transfer(msg.sender, amount - amountFees);

    emit StakeWithdrawn(msg.sender, token, amount);
  }

  /**
  @notice Withdraw function. Allows users to unstake.
  @param amount Amount to withdraw.
  @param token Address of the token for which to withdraw.
  */
  function withdraw(address token, uint256 amount) external {
    ILongShort(longShort).updateSystemState(marketIndexOfToken[token]);

    uint32 marketIndex = marketIndexOfToken[token];

    _withdraw(marketIndex, token, amount);

    if (userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] > 0) {
      // If they still have outstanding shifts after minting float, then check
      // that they don't withdraw more than their shifts allow.
      uint256 amountToShiftForThisToken = syntheticTokens[marketIndex][true] == token
        ? userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][msg.sender]
        : userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][msg.sender];

      require(
        userAmountStaked[token][msg.sender] >= amountToShiftForThisToken,
        "Outstanding next price stake shifts too great"
      );
    }
  }

  /**
  @notice Allows users to withdraw their entire stake for a token.
  @param token Address of the token for which to withdraw.
  */
  function withdrawAll(address token) external {
    ILongShort(longShort).updateSystemState(marketIndexOfToken[token]);

    uint32 marketIndex = marketIndexOfToken[token];

    uint256 amountToShiftForThisToken = syntheticTokens[marketIndex][true] == token
      ? userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][msg.sender]
      : userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][msg.sender];

    _withdraw(marketIndex, token, userAmountStaked[token][msg.sender] - amountToShiftForThisToken);
  }
}
".
Ideas: " Security".
As the Security Analyst, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability.
For each vulnerability identified, use the following format:
VULNERABILITY NAME or TYPE
```
DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix.
```
Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: "<INFO> Analysis Complete."

[2024-17-08 08:01:43 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-17-08 08:01:43 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 19617
completion_tokens: 1
total_tokens: 19618
cost: $-1.000000


[2024-17-08 08:01:43 INFO] Security Analyst: **Security Analyst<->Solidity Programming Expert on : ContractReviewComment, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: BUSL-1.1

pragma solidity 0.8.3;

import "@openzeppelin/contracts-upgradeable/token/ERC20/presets/ERC20PresetMinterPauserUpgradeable.sol";

import "./interfaces/IFloatToken.sol";
import "./interfaces/ILongShort.sol";
import "./interfaces/IStaker.sol";
import "./interfaces/ISyntheticToken.sol";

contract Staker is IStaker, Initializable {
  /*╔═════════════════════════════╗
    ║          VARIABLES          ║
    ╚═════════════════════════════╝*/

  /* ══════ Fixed-precision constants ══════ */
  uint256 public constant FLOAT_ISSUANCE_FIXED_DECIMAL = 1e42;
  // 2^52 ~= 4.5e15
  // With an exponent of 5, the largest total liquidity possible in a market (to avoid integer overflow on exponentiation) is ~10^31 or 10 Trillion (10^13)
  // NOTE: this also means if the total market value is less than 2^52 there will be a division by zero error
  uint256 public constant safeExponentBitShifting = 52;

  /* ══════ Global state ══════ */
  address public admin;
  address public floatCapital;
  address public floatTreasury;
  uint256 public floatPercentage;

  address public longShort;
  address public floatToken;

  /* ══════ Market specific ══════ */
  mapping(uint32 => uint256) public marketLaunchIncentive_period; // seconds
  mapping(uint32 => uint256) public marketLaunchIncentive_multipliers; // e18 scale
  mapping(uint32 => uint256) public marketUnstakeFee_e18;
  mapping(uint32 => uint256) public balanceIncentiveCurve_exponent;
  mapping(uint32 => int256) public balanceIncentiveCurve_equilibriumOffset;

  mapping(uint32 => mapping(bool => address)) public syntheticTokens;

  mapping(address => uint32) public marketIndexOfToken;

  /* ══════ Reward specific ══════ */
  mapping(uint32 => uint256) public latestRewardIndex;
  mapping(uint32 => mapping(uint256 => AccumulativeIssuancePerStakedSynthSnapshot))
    public accumulativeFloatPerSyntheticTokenSnapshots;
  struct AccumulativeIssuancePerStakedSynthSnapshot {
    uint256 timestamp;
    uint256 accumulativeFloatPerSyntheticToken_long;
    uint256 accumulativeFloatPerSyntheticToken_short;
  }

  /* ══════ User specific ══════ */
  mapping(uint32 => mapping(address => uint256)) public userIndexOfLastClaimedReward;
  mapping(address => mapping(address => uint256)) public userAmountStaked;

  /* ══════ Token shift management specific ══════ */
  mapping(uint32 => uint256) public batched_stakerNextTokenShiftIndex;
  /**
  @notice Used to link a token shift to a staker state
  @dev tokenShiftIndex => accumulativeFloatIssuanceSnapshotIndex
    POSSIBLE OPTIMIZATION - could pack stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping and stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping into a struct of two uint128 for storage space optimization.
  */
  mapping(uint256 => uint256) public stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping;
  /// @notice Used to fetch the price from LongShort at that point in time
  /// @dev tokenShiftIndex => longShortMarketPriceSnapshotIndex
  mapping(uint256 => uint256) public stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping;
  /// @dev marketIndex => usersAddress => stakerTokenShiftIndex
  mapping(uint32 => mapping(address => uint256)) public userNextPrice_stakedSyntheticTokenShiftIndex;
  /// @dev marketIndex => usersAddress => amountUserRequestedToShiftAwayFromLongOnNextUpdate
  mapping(uint32 => mapping(address => uint256)) public userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long;
  /// @dev marketIndex => usersAddress => amountUserRequestedToShiftAwayFromShortOnNextUpdate
  mapping(uint32 => mapping(address => uint256)) public userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short;

  /*╔════════════════════════════╗
    ║           EVENTS           ║
    ╚════════════════════════════╝*/

  event StakerV1(
    address admin,
    address floatTreasury,
    address floatCapital,
    address floatToken,
    uint256 floatPercentage
  );

  event MarketAddedToStaker(
    uint32 marketIndex,
    uint256 exitFee_e18,
    uint256 period,
    uint256 multiplier,
    uint256 balanceIncentiveExponent,
    int256 balanceIncentiveEquilibriumOffset
  );

  event AccumulativeIssuancePerStakedSynthSnapshotCreated(
    uint32 marketIndex,
    uint256 accumulativeFloatIssuanceSnapshotIndex,
    uint256 accumulativeLong,
    uint256 accumulativeShort
  );

  event StakeAdded(address user, address token, uint256 amount, uint256 lastMintIndex);

  event StakeWithdrawn(address user, address token, uint256 amount);

  // Note: the `amountFloatMinted` isn't strictly needed by the graph, but it is good to add it to validate calculations are accurate.
  event FloatMinted(address user, uint32 marketIndex, uint256 amountFloatMinted);

  event MarketLaunchIncentiveParametersChanges(uint32 marketIndex, uint256 period, uint256 multiplier);

  event StakeWithdrawalFeeUpdated(uint32 marketIndex, uint256 stakeWithdralFee);

  event BalanceIncentiveExponentUpdated(uint32 marketIndex, uint256 balanceIncentiveExponent);

  event BalanceIncentiveEquilibriumOffsetUpdated(uint32 marketIndex, int256 balanceIncentiveEquilibriumOffset);

  event FloatPercentageUpdated(uint256 floatPercentage);

  event SyntheticTokensShifted();

  event ChangeAdmin(address newAdmin);

  /*╔═════════════════════════════╗
    ║          MODIFIERS          ║
    ╚═════════════════════════════╝*/

  function onlyAdminModifierLogic() internal virtual {
    require(msg.sender == admin, "not admin");
  }

  modifier onlyAdmin() {
    onlyAdminModifierLogic();
    _;
  }

  function onlyValidSyntheticModifierLogic(address _synth) internal virtual {
    require(marketIndexOfToken[_synth] != 0, "not valid synth");
  }

  modifier onlyValidSynthetic(address _synth) {
    onlyValidSyntheticModifierLogic(_synth);
    _;
  }

  function onlyValidMarketModifierLogic(uint32 marketIndex) internal virtual {
    require(address(syntheticTokens[marketIndex][true]) != address(0), "not valid market");
  }

  modifier onlyValidMarket(uint32 marketIndex) {
    onlyValidMarketModifierLogic(marketIndex);
    _;
  }

  function onlyLongShortModifierLogic() internal virtual {
    require(msg.sender == address(longShort), "not long short");
  }

  modifier onlyLongShort() {
    onlyLongShortModifierLogic();
    _;
  }

  /*╔═════════════════════════════╗
    ║       CONTRACT SET-UP       ║
    ╚═════════════════════════════╝*/

  /**
  @notice Initializes the contract.
  @dev Calls OpenZeppelin's initializer modifier.
  @param _admin Address of the admin role.
  @param _longShort Address of the LongShort contract, a deployed LongShort.sol
  @param _floatToken Address of the Float token earned by staking.
  @param _floatTreasury Address of the treasury contract for managing fees.
  @param _floatCapital Address of the contract which earns a fixed percentage of Float.
  @param _floatPercentage Determines the float percentage that gets minted for Float Capital, base 1e18.
  */
  function initialize(
    address _admin,
    address _longShort,
    address _floatToken,
    address _floatTreasury,
    address _floatCapital,
    uint256 _floatPercentage
  ) external virtual initializer {
    admin = _admin;
    floatCapital = _floatCapital;
    floatTreasury = _floatTreasury;
    longShort = _longShort;
    floatToken = _floatToken;

    _changeFloatPercentage(_floatPercentage);

    emit StakerV1(_admin, _floatTreasury, _floatCapital, _floatToken, _floatPercentage);
  }

  /*╔═══════════════════╗
    ║       ADMIN       ║
    ╚═══════════════════╝*/

  /** 
  @notice Changes admin for the contract
  @param _admin The address of the new admin.
  */
  function changeAdmin(address _admin) external onlyAdmin {
    admin = _admin;
    emit ChangeAdmin(_admin);
  }

  /// @dev Logic for changeFloatPercentage
  function _changeFloatPercentage(uint256 newFloatPercentage) internal virtual {
    require(newFloatPercentage <= 1e18 && newFloatPercentage > 0); // less than or equal to 100% and greater than 0%
    floatPercentage = newFloatPercentage;
  }

  /**
  @notice Changes percentage of float that is minted for float capital.
  @param newFloatPercentage The new float percentage in base 1e18.
  */
  function changeFloatPercentage(uint256 newFloatPercentage) external onlyAdmin {
    _changeFloatPercentage(newFloatPercentage);
    emit FloatPercentageUpdated(newFloatPercentage);
  }

  /// @dev Logic for changeUnstakeFee
  function _changeUnstakeFee(uint32 marketIndex, uint256 newMarketUnstakeFee_e18) internal virtual {
    require(newMarketUnstakeFee_e18 <= 5e16); // Explicitely stating 5% fee as the max fee possible.
    marketUnstakeFee_e18[marketIndex] = newMarketUnstakeFee_e18;
  }

  /**
  @notice Changes unstake fee for a market
  @param marketIndex Identifies the market.
  @param newMarketUnstakeFee_e18 The new unstake fee.
  */
  function changeUnstakeFee(uint32 marketIndex, uint256 newMarketUnstakeFee_e18) external onlyAdmin {
    _changeUnstakeFee(marketIndex, newMarketUnstakeFee_e18);
    emit StakeWithdrawalFeeUpdated(marketIndex, newMarketUnstakeFee_e18);
  }

  /// @dev Logic for changeMarketLaunchIncentiveParameters
  function _changeMarketLaunchIncentiveParameters(
    uint32 marketIndex,
    uint256 period,
    uint256 initialMultiplier
  ) internal virtual {
    require(initialMultiplier >= 1e18, "marketLaunchIncentiveMultiplier must be >= 1e18");

    marketLaunchIncentive_period[marketIndex] = period;
    marketLaunchIncentive_multipliers[marketIndex] = initialMultiplier;
  }

  /**
  @notice Changes the market launch incentive parameters for a market
  @param marketIndex Identifies the market.
  @param period The new period for which float token generation should be boosted.
  @param initialMultiplier The new multiplier on Float generation.
  */
  function changeMarketLaunchIncentiveParameters(
    uint32 marketIndex,
    uint256 period,
    uint256 initialMultiplier
  ) external onlyAdmin {
    _changeMarketLaunchIncentiveParameters(marketIndex, period, initialMultiplier);

    emit MarketLaunchIncentiveParametersChanges(marketIndex, period, initialMultiplier);
  }

  /// @dev Logic for changeBalanceIncentiveExponent
  function _changeBalanceIncentiveExponent(uint32 marketIndex, uint256 _balanceIncentiveCurve_exponent)
    internal
    virtual
  {
    require(
      // The exponent has to be less than 5 in these versions of the contracts.
      _balanceIncentiveCurve_exponent > 0 && _balanceIncentiveCurve_exponent < 6,
      "balanceIncentiveCurve_exponent out of bounds"
    );

    balanceIncentiveCurve_exponent[marketIndex] = _balanceIncentiveCurve_exponent;
  }

  /** 
  @notice Changes the balance incentive exponent for a market
  @param marketIndex Identifies the market.
  @param _balanceIncentiveCurve_exponent The new exponent for the curve.
  */
  function changeBalanceIncentiveExponent(uint32 marketIndex, uint256 _balanceIncentiveCurve_exponent)
    external
    onlyAdmin
  {
    _changeBalanceIncentiveExponent(marketIndex, _balanceIncentiveCurve_exponent);

    emit BalanceIncentiveExponentUpdated(marketIndex, _balanceIncentiveCurve_exponent);
  }

  /// @dev Logic for changeBalanceIncentiveEquilibriumOffset
  function _changeBalanceIncentiveEquilibriumOffset(uint32 marketIndex, int256 _balanceIncentiveCurve_equilibriumOffset)
    internal
    virtual
  {
    // Unreasonable that we would ever shift this more than 90% either way
    require(
      _balanceIncentiveCurve_equilibriumOffset > -9e17 && _balanceIncentiveCurve_equilibriumOffset < 9e17,
      "balanceIncentiveCurve_equilibriumOffset out of bounds"
    );

    balanceIncentiveCurve_equilibriumOffset[marketIndex] = _balanceIncentiveCurve_equilibriumOffset;
  }

  /**
  @notice Changes the balance incentive curve equilibrium offset for a market
  @param marketIndex Identifies the market.
  @param _balanceIncentiveCurve_equilibriumOffset The new offset.
  */
  function changeBalanceIncentiveEquilibriumOffset(uint32 marketIndex, int256 _balanceIncentiveCurve_equilibriumOffset)
    external
    onlyAdmin
  {
    _changeBalanceIncentiveEquilibriumOffset(marketIndex, _balanceIncentiveCurve_equilibriumOffset);

    emit BalanceIncentiveEquilibriumOffsetUpdated(marketIndex, _balanceIncentiveCurve_equilibriumOffset);
  }

  /*╔═════════════════════════════╗
    ║        STAKING SETUP        ║
    ╚═════════════════════════════╝*/

  /**
  @notice Sets this contract to track staking for a market in LongShort.sol
  @param marketIndex Identifies the market.
  @param longToken Address of the long token for the market.
  @param shortToken Address of the short token for the market.
  @param kInitialMultiplier Initial boost on float generation for the market.
  @param kPeriod Period which the boost should last.
  @param unstakeFee_e18 Percentage of tokens that are levied on unstaking in base 1e18.
  @param _balanceIncentiveCurve_exponent Exponent for balance curve (see _calculateFloatPerSecond)
  @param _balanceIncentiveCurve_equilibriumOffset Offset for balance curve (see _calculateFloatPerSecond)
  */
  function addNewStakingFund(
    uint32 marketIndex,
    address longToken,
    address shortToken,
    uint256 kInitialMultiplier,
    uint256 kPeriod,
    uint256 unstakeFee_e18,
    uint256 _balanceIncentiveCurve_exponent,
    int256 _balanceIncentiveCurve_equilibriumOffset
  ) external override onlyLongShort {
    marketIndexOfToken[longToken] = marketIndex;
    marketIndexOfToken[shortToken] = marketIndex;

    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].timestamp = block.timestamp;
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].accumulativeFloatPerSyntheticToken_long = 0;
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].accumulativeFloatPerSyntheticToken_short = 0;

    syntheticTokens[marketIndex][true] = longToken;
    syntheticTokens[marketIndex][false] = shortToken;

    _changeBalanceIncentiveExponent(marketIndex, _balanceIncentiveCurve_exponent);
    _changeBalanceIncentiveEquilibriumOffset(marketIndex, _balanceIncentiveCurve_equilibriumOffset);
    _changeMarketLaunchIncentiveParameters(marketIndex, kPeriod, kInitialMultiplier);

    _changeUnstakeFee(marketIndex, unstakeFee_e18);

    // Set this value to one initially - 0 is a null value and thus potentially bug prone.
    batched_stakerNextTokenShiftIndex[marketIndex] = 1;

    emit MarketAddedToStaker(
      marketIndex,
      unstakeFee_e18,
      kPeriod,
      kInitialMultiplier,
      _balanceIncentiveCurve_exponent,
      _balanceIncentiveCurve_equilibriumOffset
    );

    emit AccumulativeIssuancePerStakedSynthSnapshotCreated(marketIndex, 0, 0, 0);
  }

  /*╔═════════════════════════════════════════════════════════════════════════╗
    ║    GLOBAL FLT REWARD ACCUMULATION CALCULATION AND TRACKING FUNCTIONS    ║
    ╚═════════════════════════════════════════════════════════════════════════╝*/

  /**
  @notice Returns the K factor parameters for the given market with sensible
  defaults if they haven't been set yet.
  @param marketIndex The market to change the parameters for.
  @return period The period for which the k factor applies for in seconds.
  @return multiplier The multiplier on Float generation in this period.
  */
  function _getMarketLaunchIncentiveParameters(uint32 marketIndex)
    internal
    view
    virtual
    returns (uint256 period, uint256 multiplier)
  {
    period = marketLaunchIncentive_period[marketIndex];
    multiplier = marketLaunchIncentive_multipliers[marketIndex];

    if (multiplier < 1e18) {
      multiplier = 1e18; // multiplier of 1 by default
    }
  }

  /** 
  @notice Returns the extent to which a markets float generation should be adjusted
  based on the market's launch incentive parameters. Should start at multiplier
  then linearly change to 1e18 over time.
  @param marketIndex Identifies the market.
  @return k The calculated modifier for float generation.
  */
  function _getKValue(uint32 marketIndex) internal view virtual returns (uint256) {
    // Parameters controlling the float issuance multiplier.
    (uint256 kPeriod, uint256 kInitialMultiplier) = _getMarketLaunchIncentiveParameters(marketIndex);

    // Sanity check - under normal circumstances, the multipliers should
    // *never* be set to a value < 1e18, as there are guards against this.
    assert(kInitialMultiplier >= 1e18);

    uint256 initialTimestamp = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].timestamp;

    if (block.timestamp - initialTimestamp <= kPeriod) {
      return kInitialMultiplier - (((kInitialMultiplier - 1e18) * (block.timestamp - initialTimestamp)) / kPeriod);
    } else {
      return 1e18;
    }
  }

  /*
  @notice Computes the number of float tokens a user earns per second for
  every long/short synthetic token they've staked. The returned value has
  a fixed decimal scale of 1e42 (!!!) for numerical stability. The return
  values are float per second per synthetic token (hence the requirement
  to multiply by price)
  @dev to see below math in latex form see TODO add link
  to interact with the equations see https://www.desmos.com/calculator/optkaxyihr
  @param marketIndex The market referred to.
  @param longPrice Price of the synthetic long token in units of payment token
  @param shortPrice Price of the synthetic short token in units of payment token
  @param longValue Amount of payment token in the long side of the market
  @param shortValue Amount of payment token in the short side of the market
  @return longFloatPerSecond Float token per second per long synthetic token
  @return shortFloatPerSecond Float token per second per short synthetic token
   */
  function _calculateFloatPerSecond(
    uint32 marketIndex,
    uint256 longPrice,
    uint256 shortPrice,
    uint256 longValue,
    uint256 shortValue
  ) internal view virtual returns (uint256 longFloatPerSecond, uint256 shortFloatPerSecond) {
    // A float issuance multiplier that starts high and decreases linearly
    // over time to a value of 1. This incentivises users to stake early.
    uint256 k = _getKValue(marketIndex);

    uint256 totalLocked = (longValue + shortValue);

    // we need to scale this number by the totalLocked so that the offset remains consistent accross market size

    int256 equilibriumOffsetMarketScaled = (balanceIncentiveCurve_equilibriumOffset[marketIndex] *
      int256(totalLocked)) / 2e18;

    uint256 denominator = ((totalLocked >> safeExponentBitShifting)**balanceIncentiveCurve_exponent[marketIndex]);

    // Float is scaled by the percentage of the total market value held in
    // the opposite position. This incentivises users to stake on the
    // weaker position.
    if (int256(shortValue) - equilibriumOffsetMarketScaled < int256(longValue)) {
      if (equilibriumOffsetMarketScaled >= int256(shortValue)) {
        // edge case: imbalanced far past the equilibrium offset - full rewards go to short token
        //            extremeley unlikely to happen in practice
        return (0, 1e18 * k * shortPrice);
      }

      uint256 numerator = (uint256(int256(shortValue) - equilibriumOffsetMarketScaled) >>
        (safeExponentBitShifting - 1))**balanceIncentiveCurve_exponent[marketIndex];

      // NOTE: `x * 5e17` == `(x * 10e18) / 2`
      uint256 longRewardUnscaled = (numerator * 5e17) / denominator;
      uint256 shortRewardUnscaled = 1e18 - longRewardUnscaled;

      return ((longRewardUnscaled * k * longPrice) / 1e18, (shortRewardUnscaled * k * shortPrice) / 1e18);
    } else {
      if (-equilibriumOffsetMarketScaled >= int256(longValue)) {
        // edge case: imbalanced far past the equilibrium offset - full rewards go to long token
        //            extremeley unlikely to happen in practice
        return (1e18 * k * longPrice, 0);
      }

      uint256 numerator = (uint256(int256(longValue) + equilibriumOffsetMarketScaled) >>
        (safeExponentBitShifting - 1))**balanceIncentiveCurve_exponent[marketIndex];

      // NOTE: `x * 5e17` == `(x * 10e18) / 2`
      uint256 shortRewardUnscaled = (numerator * 5e17) / denominator;
      uint256 longRewardUnscaled = 1e18 - shortRewardUnscaled;

      return ((longRewardUnscaled * k * longPrice) / 1e18, (shortRewardUnscaled * k * shortPrice) / 1e18);
    }
  }

  /**
  @notice Computes the time since last accumulativeIssuancePerStakedSynthSnapshot for the given market in seconds.
  @param marketIndex The market referred to.
  @return The time difference in seconds
  */
  function _calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(uint32 marketIndex)
    internal
    view
    virtual
    returns (uint256)
  {
    return
      block.timestamp -
      accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]].timestamp;
  }

  /**
  @notice Computes new cumulative sum of 'r' value since last accumulativeIssuancePerStakedSynthSnapshot. We use
  cumulative 'r' value to avoid looping during issuance. Note that the
  cumulative sum is kept in 1e42 scale (!!!) to avoid numerical issues.
  @param shortValue The value locked in the short side of the market.
  @param longValue The value locked in the long side of the market.
  @param shortPrice The price of the short token as defined in LongShort.sol
  @param longPrice The price of the long token as defined in LongShort.sol
  @param marketIndex An identifier for the market.
  @return longCumulativeRates The long cumulative sum.
  @return shortCumulativeRates The short cumulative sum.
  */
  function _calculateNewCumulativeIssuancePerStakedSynth(
    uint32 marketIndex,
    uint256 longPrice,
    uint256 shortPrice,
    uint256 longValue,
    uint256 shortValue
  ) internal view virtual returns (uint256 longCumulativeRates, uint256 shortCumulativeRates) {
    // Compute the current 'r' value for float issuance per second.
    (uint256 longFloatPerSecond, uint256 shortFloatPerSecond) = _calculateFloatPerSecond(
      marketIndex,
      longPrice,
      shortPrice,
      longValue,
      shortValue
    );

    // Compute time since last accumulativeIssuancePerStakedSynthSnapshot for the given token.
    uint256 timeDelta = _calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(marketIndex);

    // Compute new cumulative 'r' value total.
    return (
      accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]]
      .accumulativeFloatPerSyntheticToken_long + (timeDelta * longFloatPerSecond),
      accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]]
      .accumulativeFloatPerSyntheticToken_short + (timeDelta * shortFloatPerSecond)
    );
  }

  /**
  @notice Creates a new accumulativeIssuancePerStakedSynthSnapshot for the given token and updates indexes.
  @param shortValue The value locked in the short side of the market.
  @param longValue The value locked in the long side of the market.
  @param shortPrice The price of the short token as defined in LongShort.sol
  @param longPrice The price of the long token as defined in LongShort.sol
  @param marketIndex An identifier for the market.
  */
  function _setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot(
    uint32 marketIndex,
    uint256 longPrice,
    uint256 shortPrice,
    uint256 longValue,
    uint256 shortValue
  ) internal virtual {
    (
      uint256 newLongAccumulativeValue,
      uint256 newShortAccumulativeValue
    ) = _calculateNewCumulativeIssuancePerStakedSynth(marketIndex, longPrice, shortPrice, longValue, shortValue);

    uint256 newIndex = latestRewardIndex[marketIndex] + 1;

    // Set cumulative 'r' value on new accumulativeIssuancePerStakedSynthSnapshot.
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex]
    .accumulativeFloatPerSyntheticToken_long = newLongAccumulativeValue;
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex]
    .accumulativeFloatPerSyntheticToken_short = newShortAccumulativeValue;

    // Set timestamp on new accumulativeIssuancePerStakedSynthSnapshot.
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex].timestamp = block.timestamp;

    // Update latest index to point to new accumulativeIssuancePerStakedSynthSnapshot.
    latestRewardIndex[marketIndex] = newIndex;

    emit AccumulativeIssuancePerStakedSynthSnapshotCreated(
      marketIndex,
      newIndex,
      newLongAccumulativeValue,
      newShortAccumulativeValue
    );
  }

  /**
  @notice Adds new accumulativeIssuancePerStakedSynthSnapshots for the given long/short tokens. Called by the
  ILongShort contract whenever there is a state change for a market.
  @param stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted Mapping from this contract's shifts to LongShort.sols next price snapshots.
  @param shortValue The value locked in the short side of the market.
  @param longValue The value locked in the long side of the market.
  @param shortPrice The price of the short token as defined in LongShort.sol
  @param longPrice The price of the long token as defined in LongShort.sol
  @param marketIndex An identifier for the market.
  */
  function pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(
    uint32 marketIndex,
    uint256 longPrice,
    uint256 shortPrice,
    uint256 longValue,
    uint256 shortValue,
    uint256 stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted // This value should be ALWAYS be zero if no shift occured
  ) external override onlyLongShort {
    // Only add a new accumulativeIssuancePerStakedSynthSnapshot if some time has passed.

    // the `stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted` value will be 0 if there is no staker related action in an executed batch
    if (stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted > 0) {
      stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[
        batched_stakerNextTokenShiftIndex[marketIndex]
      ] = stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted;
      stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[
        batched_stakerNextTokenShiftIndex[marketIndex]
      ] = latestRewardIndex[marketIndex] + 1;
      batched_stakerNextTokenShiftIndex[marketIndex] += 1;

      emit SyntheticTokensShifted();
    }

    // Time delta is fetched twice in below code, can pass through? Which is less gas?
    if (_calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(marketIndex) > 0) {
      _setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot(
        marketIndex,
        longPrice,
        shortPrice,
        longValue,
        shortValue
      );
    }
  }

  /*╔═══════════════════════════════════╗
    ║    USER REWARD STATE FUNCTIONS    ║
    ╚═══════════════════════════════════╝*/

  /// @dev Calculates the accumulated float in a specific range of staker snapshots
  function _calculateAccumulatedFloatInRange(
    uint32 marketIndex,
    uint256 amountStakedLong,
    uint256 amountStakedShort,
    uint256 rewardIndexFrom,
    uint256 rewardIndexTo
  ) internal view virtual returns (uint256 floatReward) {
    if (amountStakedLong > 0) {
      uint256 accumDeltaLong = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexTo]
      .accumulativeFloatPerSyntheticToken_long -
        accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexFrom]
        .accumulativeFloatPerSyntheticToken_long;
      floatReward += (accumDeltaLong * amountStakedLong) / FLOAT_ISSUANCE_FIXED_DECIMAL;
    }

    if (amountStakedShort > 0) {
      uint256 accumDeltaShort = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexTo]
      .accumulativeFloatPerSyntheticToken_short -
        accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexFrom]
        .accumulativeFloatPerSyntheticToken_short;
      floatReward += (accumDeltaShort * amountStakedShort) / FLOAT_ISSUANCE_FIXED_DECIMAL;
    }
  }

  /** 
  @notice Calculates float owed to the user since the user last minted float for a market.
  @param marketIndex Identifier for the market which the user staked in.
  @param user The address of the user.
  @return floatReward The amount of float owed.
   */
  function _calculateAccumulatedFloat(uint32 marketIndex, address user) internal virtual returns (uint256 floatReward) {
    address longToken = syntheticTokens[marketIndex][true];
    address shortToken = syntheticTokens[marketIndex][false];

    uint256 amountStakedLong = userAmountStaked[longToken][user];
    uint256 amountStakedShort = userAmountStaked[shortToken][user];

    uint256 usersLastRewardIndex = userIndexOfLastClaimedReward[marketIndex][user];

    // Don't do the calculation and return zero immediately if there is no change
    if (usersLastRewardIndex == latestRewardIndex[marketIndex]) {
      return 0;
    }

    uint256 usersShiftIndex = userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][user];
    // if there is a change in the users tokens held due to a token shift (or possibly another action in the future)
    if (usersShiftIndex > 0 && usersShiftIndex < batched_stakerNextTokenShiftIndex[marketIndex]) {
      floatReward = _calculateAccumulatedFloatInRange(
        marketIndex,
        amountStakedLong,
        amountStakedShort,
        usersLastRewardIndex,
        stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[usersShiftIndex]
      );

      // Update the users balances
      if (userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user] > 0) {
        amountStakedShort += ILongShort(longShort).getAmountSyntheticTokenToMintOnTargetSide(
          marketIndex,
          userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user],
          true,
          stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[usersShiftIndex]
        );

        amountStakedLong -= userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user];
        userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user] = 0;
      }

      if (userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user] > 0) {
        amountStakedLong += ILongShort(longShort).getAmountSyntheticTokenToMintOnTargetSide(
          marketIndex,
          userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user],
          false,
          stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[usersShiftIndex]
        );

        amountStakedShort -= userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user];
        userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user] = 0;
      }

      // Save the users updated staked amounts
      userAmountStaked[longToken][user] = amountStakedLong;
      userAmountStaked[shortToken][user] = amountStakedShort;

      floatReward += _calculateAccumulatedFloatInRange(
        marketIndex,
        amountStakedLong,
        amountStakedShort,
        stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[usersShiftIndex],
        latestRewardIndex[marketIndex]
      );

      userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][user] = 0;
    } else {
      floatReward = _calculateAccumulatedFloatInRange(
        marketIndex,
        amountStakedLong,
        amountStakedShort,
        usersLastRewardIndex,
        latestRewardIndex[marketIndex]
      );
    }
  }

  /**
  @notice Mints float for a user.
  @dev Mints a fixed percentage for Float capital.
  @param user The address of the user.
  @param floatToMint The amount of float to mint.
   */
  function _mintFloat(address user, uint256 floatToMint) internal virtual {
    IFloatToken(floatToken).mint(user, floatToMint);
    IFloatToken(floatToken).mint(floatCapital, (floatToMint * floatPercentage) / 1e18);
  }

  /**
  @notice Mints float owed to a user for a market since they last minted.
  @param marketIndex An identifier for the market.
  @param user The address of the user.
   */
  function _mintAccumulatedFloat(uint32 marketIndex, address user) internal virtual {
    uint256 floatToMint = _calculateAccumulatedFloat(marketIndex, user);

    if (floatToMint > 0) {
      // Set the user has claimed up until now, stops them setting this forward
      userIndexOfLastClaimedReward[marketIndex][user] = latestRewardIndex[marketIndex];

      _mintFloat(user, floatToMint);
      emit FloatMinted(user, marketIndex, floatToMint);
    }
  }

  /**
  @notice Mints float owed to a user for multiple markets, since they last minted for those markets.
  @param marketIndexes Identifiers for the markets.
  @param user The address of the user.
   */
  function _mintAccumulatedFloatMulti(uint32[] calldata marketIndexes, address user) internal virtual {
    uint256 floatTotal = 0;
    for (uint256 i = 0; i < marketIndexes.length; i++) {
      uint256 floatToMint = _calculateAccumulatedFloat(marketIndexes[i], user);

      if (floatToMint > 0) {
        // Set the user has claimed up until now, stops them setting this forward
        userIndexOfLastClaimedReward[marketIndexes[i]][user] = latestRewardIndex[marketIndexes[i]];

        floatTotal += floatToMint;

        emit FloatMinted(user, marketIndexes[i], floatToMint);
      }
    }
    if (floatTotal > 0) {
      _mintFloat(user, floatTotal);
    }
  }

  /**
  @notice Mints outstanding float for msg.sender.
  @param marketIndexes Identifiers for the markets for which to mint float.
   */
  function claimFloatCustom(uint32[] calldata marketIndexes) external {
    ILongShort(longShort).updateSystemStateMulti(marketIndexes);
    _mintAccumulatedFloatMulti(marketIndexes, msg.sender);
  }

  /**
  @notice Mints outstanding float on behalf of another user.
  @param marketIndexes Identifiers for the markets for which to mint float.
  @param user The address of the user.
   */
  function claimFloatCustomFor(uint32[] calldata marketIndexes, address user) external {
    // Unbounded loop - users are responsible for paying their own gas costs on these and it doesn't effect the rest of the system.
    // No need to impose limit.
    ILongShort(longShort).updateSystemStateMulti(marketIndexes);
    _mintAccumulatedFloatMulti(marketIndexes, user);
  }

  /*╔═══════════════════════╗
    ║        STAKING        ║
    ╚═══════════════════════╝*/

  /**
  @notice A user with synthetic tokens stakes by calling stake on the token
  contract which calls this function. We need to first update the
  state of the LongShort contract for this market before staking to correctly calculate user rewards.
  @param amount Amount to stake.
  @param from Address to stake for.
  */
  function stakeFromUser(address from, uint256 amount) public virtual override onlyValidSynthetic((msg.sender)) {
    ILongShort(longShort).updateSystemState(marketIndexOfToken[(msg.sender)]);
    _stake((msg.sender), amount, from);
  }

  /**
  @dev Internal logic for staking.
  @param token Address of the token for which to stake.
  @param amount Amount to stake.
  @param user Address to stake for.
  */
  function _stake(
    address token,
    uint256 amount,
    address user
  ) internal virtual {
    uint32 marketIndex = marketIndexOfToken[token];

    // If they already have staked and have rewards due, mint these.
    if (
      userIndexOfLastClaimedReward[marketIndex][user] != 0 &&
      userIndexOfLastClaimedReward[marketIndex][user] < latestRewardIndex[marketIndex]
    ) {
      _mintAccumulatedFloat(marketIndex, user);
    }

    userAmountStaked[token][user] = userAmountStaked[token][user] + amount;

    userIndexOfLastClaimedReward[marketIndex][user] = latestRewardIndex[marketIndex];

    emit StakeAdded(user, address(token), amount, userIndexOfLastClaimedReward[marketIndex][user]);
  }

  /**
  @notice Allows users to shift their staked tokens from one side of the market to 
  the other at the next price.
  @param amountSyntheticTokensToShift Amount of tokens to shift.
  @param marketIndex Identifier for the market.
  @param isShiftFromLong Whether the shift is from long to short or short to long.
  */
  function shiftTokens(
    uint256 amountSyntheticTokensToShift,
    uint32 marketIndex,
    bool isShiftFromLong
  ) external virtual {
    address token = syntheticTokens[marketIndex][isShiftFromLong];
    require(userAmountStaked[token][msg.sender] >= amountSyntheticTokensToShift, "Not enough tokens to shift");

    // If the user has outstanding token shift that have already been confirmed in the LongShort
    // contract, execute them first.
    if (
      userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] != 0 &&
      userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] <
      batched_stakerNextTokenShiftIndex[marketIndex]
    ) {
      _mintAccumulatedFloat(marketIndex, msg.sender);
    }

    if (isShiftFromLong) {
      ILongShort(longShort).shiftPositionFromLongNextPrice(marketIndex, amountSyntheticTokensToShift);
      userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][
        msg.sender
      ] += amountSyntheticTokensToShift;
    } else {
      ILongShort(longShort).shiftPositionFromShortNextPrice(marketIndex, amountSyntheticTokensToShift);
      userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][
        msg.sender
      ] += amountSyntheticTokensToShift;
    }

    userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] = batched_stakerNextTokenShiftIndex[
      marketIndex
    ];
  }

  /*╔════════════════════════════╗
    ║    WITHDRAWAL & MINTING    ║
    ╚════════════════════════════╝*/

  /**
  @notice Internal logic for withdrawing stakes.
  @dev Mint user any outstanding float before withdrawing.
  @param marketIndex Market index of token.
  @param amount Amount to withdraw.
  @param token Synthetic token that was staked.
  */
  function _withdraw(
    uint32 marketIndex,
    address token,
    uint256 amount
  ) internal virtual {
    require(userAmountStaked[token][msg.sender] > 0, "nothing to withdraw");
    _mintAccumulatedFloat(marketIndex, msg.sender);

    userAmountStaked[token][msg.sender] = userAmountStaked[token][msg.sender] - amount;

    uint256 amountFees = (amount * marketUnstakeFee_e18[marketIndex]) / 1e18;

    IERC20(token).transfer(floatTreasury, amountFees);
    IERC20(token).transfer(msg.sender, amount - amountFees);

    emit StakeWithdrawn(msg.sender, token, amount);
  }

  /**
  @notice Withdraw function. Allows users to unstake.
  @param amount Amount to withdraw.
  @param token Address of the token for which to withdraw.
  */
  function withdraw(address token, uint256 amount) external {
    ILongShort(longShort).updateSystemState(marketIndexOfToken[token]);

    uint32 marketIndex = marketIndexOfToken[token];

    _withdraw(marketIndex, token, amount);

    if (userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] > 0) {
      // If they still have outstanding shifts after minting float, then check
      // that they don't withdraw more than their shifts allow.
      uint256 amountToShiftForThisToken = syntheticTokens[marketIndex][true] == token
        ? userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][msg.sender]
        : userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][msg.sender];

      require(
        userAmountStaked[token][msg.sender] >= amountToShiftForThisToken,
        "Outstanding next price stake shifts too great"
      );
    }
  }

  /**
  @notice Allows users to withdraw their entire stake for a token.
  @param token Address of the token for which to withdraw.
  */
  function withdrawAll(address token) external {
    ILongShort(longShort).updateSystemState(marketIndexOfToken[token]);

    uint32 marketIndex = marketIndexOfToken[token];

    uint256 amountToShiftForThisToken = syntheticTokens[marketIndex][true] == token
      ? userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][msg.sender]
      : userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][msg.sender];

    _withdraw(marketIndex, token, userAmountStaked[token][msg.sender] - amountToShiftForThisToken);
  }
}
.]

###

[2024-17-08 08:01:43 INFO] **[Seminar Conclusion]**:

 ###

[2024-17-08 08:01:43 INFO] **[Execute Detail]**

execute SimplePhase:[BugsSummary] in ComposedPhase:[CodeReview], cycle 2

[2024-17-08 08:01:43 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: BUSL-1.1 pragma solidity 0.8.3; import "@openzeppelin/contracts-upgradeable/token/ERC20/presets/ERC20PresetMinterPauserUpgradeable.sol"; import "./interfaces/IFloatToken.sol"; import "./interfaces/ILongShort.sol"; import "./interfaces/IStaker.sol"; import "./interfaces/ISyntheticToken.sol"; contract Staker is IStaker, Initializable {   /╔═════════════════════════════╗     ║          VARIABLES          ║     ╚═════════════════════════════╝/ / ══════ Fixed-precision constants ══════ /   uint256 public constant FLOAT_ISSUANCE_FIXED_DECIMAL = 1e42;   // 2^52 ~= 4.5e15   // With an exponent of 5, the largest total liquidity possible in a market (to avoid integer overflow on exponentiation) is ~10^31 or 10 Trillion (10^13)   // NOTE: this also means if the total market value is less than 2^52 there will be a division by zero error   uint256 public constant safeExponentBitShifting = 52; / ══════ Global state ══════ /   address public admin;   address public floatCapital;   address public floatTreasury;   uint256 public floatPercentage; address public longShort;   address public floatToken; / ══════ Market specific ══════ /   mapping(uint32 =&gt; uint256) public marketLaunchIncentive_period; // seconds   mapping(uint32 =&gt; uint256) public marketLaunchIncentive_multipliers; // e18 scale   mapping(uint32 =&gt; uint256) public marketUnstakeFee_e18;   mapping(uint32 =&gt; uint256) public balanceIncentiveCurve_exponent;   mapping(uint32 =&gt; int256) public balanceIncentiveCurve_equilibriumOffset; mapping(uint32 =&gt; mapping(bool =&gt; address)) public syntheticTokens; mapping(address =&gt; uint32) public marketIndexOfToken; / ══════ Reward specific ══════ /   mapping(uint32 =&gt; uint256) public latestRewardIndex;   mapping(uint32 =&gt; mapping(uint256 =&gt; AccumulativeIssuancePerStakedSynthSnapshot))     public accumulativeFloatPerSyntheticTokenSnapshots;   struct AccumulativeIssuancePerStakedSynthSnapshot {     uint256 timestamp;     uint256 accumulativeFloatPerSyntheticToken_long;     uint256 accumulativeFloatPerSyntheticToken_short;   } / ══════ User specific ══════ /   mapping(uint32 =&gt; mapping(address =&gt; uint256)) public userIndexOfLastClaimedReward;   mapping(address =&gt; mapping(address =&gt; uint256)) public userAmountStaked; / ══════ Token shift management specific ══════ /   mapping(uint32 =&gt; uint256) public batched_stakerNextTokenShiftIndex;   /*   @notice Used to link a token shift to a staker state   @dev tokenShiftIndex =&gt; accumulativeFloatIssuanceSnapshotIndex     POSSIBLE OPTIMIZATION - could pack stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping and stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping into a struct of two uint128 for storage space optimization.   /   mapping(uint256 =&gt; uint256) public stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping;   /// @notice Used to fetch the price from LongShort at that point in time   /// @dev tokenShiftIndex =&gt; longShortMarketPriceSnapshotIndex   mapping(uint256 =&gt; uint256) public stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping;   /// @dev marketIndex =&gt; usersAddress =&gt; stakerTokenShiftIndex   mapping(uint32 =&gt; mapping(address =&gt; uint256)) public userNextPrice_stakedSyntheticTokenShiftIndex;   /// @dev marketIndex =&gt; usersAddress =&gt; amountUserRequestedToShiftAwayFromLongOnNextUpdate   mapping(uint32 =&gt; mapping(address =&gt; uint256)) public userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long;   /// @dev marketIndex =&gt; usersAddress =&gt; amountUserRequestedToShiftAwayFromShortOnNextUpdate   mapping(uint32 =&gt; mapping(address =&gt; uint256)) public userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short; /╔════════════════════════════╗     ║           EVENTS           ║     ╚════════════════════════════╝/ event StakerV1(     address admin,     address floatTreasury,     address floatCapital,     address floatToken,     uint256 floatPercentage   ); event MarketAddedToStaker(     uint32 marketIndex,     uint256 exitFee_e18,     uint256 period,     uint256 multiplier,     uint256 balanceIncentiveExponent,     int256 balanceIncentiveEquilibriumOffset   ); event AccumulativeIssuancePerStakedSynthSnapshotCreated(     uint32 marketIndex,     uint256 accumulativeFloatIssuanceSnapshotIndex,     uint256 accumulativeLong,     uint256 accumulativeShort   ); event StakeAdded(address user, address token, uint256 amount, uint256 lastMintIndex); event StakeWithdrawn(address user, address token, uint256 amount); // Note: the amountFloatMinted isn't strictly needed by the graph, but it is good to add it to validate calculations are accurate.   event FloatMinted(address user, uint32 marketIndex, uint256 amountFloatMinted); event MarketLaunchIncentiveParametersChanges(uint32 marketIndex, uint256 period, uint256 multiplier); event StakeWithdrawalFeeUpdated(uint32 marketIndex, uint256 stakeWithdralFee); event BalanceIncentiveExponentUpdated(uint32 marketIndex, uint256 balanceIncentiveExponent); event BalanceIncentiveEquilibriumOffsetUpdated(uint32 marketIndex, int256 balanceIncentiveEquilibriumOffset); event FloatPercentageUpdated(uint256 floatPercentage); event SyntheticTokensShifted(); event ChangeAdmin(address newAdmin); /╔═════════════════════════════╗     ║          MODIFIERS          ║     ╚═════════════════════════════╝/ function onlyAdminModifierLogic() internal virtual {     require(msg.sender == admin, "not admin");   } modifier onlyAdmin() {     onlyAdminModifierLogic();     _;   } function onlyValidSyntheticModifierLogic(address _synth) internal virtual {     require(marketIndexOfToken[_synth] != 0, "not valid synth");   } modifier onlyValidSynthetic(address synth) {     onlyValidSyntheticModifierLogic(_synth);     ;   } function onlyValidMarketModifierLogic(uint32 marketIndex) internal virtual {     require(address(syntheticTokens[marketIndex][true]) != address(0), "not valid market");   } modifier onlyValidMarket(uint32 marketIndex) {     onlyValidMarketModifierLogic(marketIndex);     _;   } function onlyLongShortModifierLogic() internal virtual {     require(msg.sender == address(longShort), "not long short");   } modifier onlyLongShort() {     onlyLongShortModifierLogic();     _;   } /╔═════════════════════════════╗     ║       CONTRACT SET-UP       ║     ╚═════════════════════════════╝/ /*   @notice Initializes the contract.   @dev Calls OpenZeppelin's initializer modifier.   @param _admin Address of the admin role.   @param _longShort Address of the LongShort contract, a deployed LongShort.sol   @param _floatToken Address of the Float token earned by staking.   @param _floatTreasury Address of the treasury contract for managing fees.   @param _floatCapital Address of the contract which earns a fixed percentage of Float.   @param _floatPercentage Determines the float percentage that gets minted for Float Capital, base 1e18.   /   function initialize(     address _admin,     address _longShort,     address _floatToken,     address _floatTreasury,     address _floatCapital,     uint256 _floatPercentage   ) external virtual initializer {     admin = _admin;     floatCapital = _floatCapital;     floatTreasury = _floatTreasury;     longShort = _longShort;     floatToken = _floatToken; _changeFloatPercentage(_floatPercentage);  emit StakerV1(_admin, _floatTreasury, _floatCapital, _floatToken, _floatPercentage);  } /╔═══════════════════╗     ║       ADMIN       ║     ╚═══════════════════╝/ /*    @notice Changes admin for the contract   @param _admin The address of the new admin.   /   function changeAdmin(address _admin) external onlyAdmin {     admin = _admin;     emit ChangeAdmin(_admin);   } /// @dev Logic for changeFloatPercentage   function _changeFloatPercentage(uint256 newFloatPercentage) internal virtual {     require(newFloatPercentage &lt;= 1e18 &amp;&amp; newFloatPercentage &gt; 0); // less than or equal to 100% and greater than 0%     floatPercentage = newFloatPercentage;   } /*   @notice Changes percentage of float that is minted for float capital.   @param newFloatPercentage The new float percentage in base 1e18.   /   function changeFloatPercentage(uint256 newFloatPercentage) external onlyAdmin {     _changeFloatPercentage(newFloatPercentage);     emit FloatPercentageUpdated(newFloatPercentage);   } /// @dev Logic for changeUnstakeFee   function _changeUnstakeFee(uint32 marketIndex, uint256 newMarketUnstakeFee_e18) internal virtual {     require(newMarketUnstakeFee_e18 &lt;= 5e16); // Explicitely stating 5% fee as the max fee possible.     marketUnstakeFee_e18[marketIndex] = newMarketUnstakeFee_e18;   } /*   @notice Changes unstake fee for a market   @param marketIndex Identifies the market.   @param newMarketUnstakeFee_e18 The new unstake fee.   /   function changeUnstakeFee(uint32 marketIndex, uint256 newMarketUnstakeFee_e18) external onlyAdmin {     _changeUnstakeFee(marketIndex, newMarketUnstakeFee_e18);     emit StakeWithdrawalFeeUpdated(marketIndex, newMarketUnstakeFee_e18);   } /// @dev Logic for changeMarketLaunchIncentiveParameters   function _changeMarketLaunchIncentiveParameters(     uint32 marketIndex,     uint256 period,     uint256 initialMultiplier   ) internal virtual {     require(initialMultiplier &gt;= 1e18, "marketLaunchIncentiveMultiplier must be &gt;= 1e18"); marketLaunchIncentive_period[marketIndex] = period; marketLaunchIncentive_multipliers[marketIndex] = initialMultiplier;  } /*   @notice Changes the market launch incentive parameters for a market   @param marketIndex Identifies the market.   @param period The new period for which float token generation should be boosted.   @param initialMultiplier The new multiplier on Float generation.   /   function changeMarketLaunchIncentiveParameters(     uint32 marketIndex,     uint256 period,     uint256 initialMultiplier   ) external onlyAdmin {     _changeMarketLaunchIncentiveParameters(marketIndex, period, initialMultiplier); emit MarketLaunchIncentiveParametersChanges(marketIndex, period, initialMultiplier);  } /// @dev Logic for changeBalanceIncentiveExponent   function _changeBalanceIncentiveExponent(uint32 marketIndex, uint256 _balanceIncentiveCurve_exponent)     internal     virtual   {     require(       // The exponent has to be less than 5 in these versions of the contracts.       _balanceIncentiveCurve_exponent &gt; 0 &amp;&amp; _balanceIncentiveCurve_exponent &lt; 6,       "balanceIncentiveCurve_exponent out of bounds"     ); balanceIncentiveCurve_exponent[marketIndex] = _balanceIncentiveCurve_exponent;  } /*    @notice Changes the balance incentive exponent for a market   @param marketIndex Identifies the market.   @param _balanceIncentiveCurve_exponent The new exponent for the curve.   /   function changeBalanceIncentiveExponent(uint32 marketIndex, uint256 _balanceIncentiveCurve_exponent)     external     onlyAdmin   {     _changeBalanceIncentiveExponent(marketIndex, _balanceIncentiveCurve_exponent); emit BalanceIncentiveExponentUpdated(marketIndex, _balanceIncentiveCurve_exponent);  } /// @dev Logic for changeBalanceIncentiveEquilibriumOffset   function _changeBalanceIncentiveEquilibriumOffset(uint32 marketIndex, int256 _balanceIncentiveCurve_equilibriumOffset)     internal     virtual   {     // Unreasonable that we would ever shift this more than 90% either way     require(       _balanceIncentiveCurve_equilibriumOffset &gt; -9e17 &amp;&amp; _balanceIncentiveCurve_equilibriumOffset &lt; 9e17,       "balanceIncentiveCurve_equilibriumOffset out of bounds"     ); balanceIncentiveCurve_equilibriumOffset[marketIndex] = _balanceIncentiveCurve_equilibriumOffset;  } /*   @notice Changes the balance incentive curve equilibrium offset for a market   @param marketIndex Identifies the market.   @param _balanceIncentiveCurve_equilibriumOffset The new offset.   /   function changeBalanceIncentiveEquilibriumOffset(uint32 marketIndex, int256 _balanceIncentiveCurve_equilibriumOffset)     external     onlyAdmin   {     _changeBalanceIncentiveEquilibriumOffset(marketIndex, _balanceIncentiveCurve_equilibriumOffset); emit BalanceIncentiveEquilibriumOffsetUpdated(marketIndex, _balanceIncentiveCurve_equilibriumOffset);  } /╔═════════════════════════════╗     ║        STAKING SETUP        ║     ╚═════════════════════════════╝/ /*   @notice Sets this contract to track staking for a market in LongShort.sol   @param marketIndex Identifies the market.   @param longToken Address of the long token for the market.   @param shortToken Address of the short token for the market.   @param kInitialMultiplier Initial boost on float generation for the market.   @param kPeriod Period which the boost should last.   @param unstakeFee_e18 Percentage of tokens that are levied on unstaking in base 1e18.   @param _balanceIncentiveCurve_exponent Exponent for balance curve (see _calculateFloatPerSecond)   @param _balanceIncentiveCurve_equilibriumOffset Offset for balance curve (see _calculateFloatPerSecond)   /   function addNewStakingFund(     uint32 marketIndex,     address longToken,     address shortToken,     uint256 kInitialMultiplier,     uint256 kPeriod,     uint256 unstakeFee_e18,     uint256 _balanceIncentiveCurve_exponent,     int256 _balanceIncentiveCurve_equilibriumOffset   ) external override onlyLongShort {     marketIndexOfToken[longToken] = marketIndex;     marketIndexOfToken[shortToken] = marketIndex; accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].timestamp = block.timestamp; accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].accumulativeFloatPerSyntheticToken_long = 0; accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].accumulativeFloatPerSyntheticToken_short = 0;  syntheticTokens[marketIndex][true] = longToken; syntheticTokens[marketIndex][false] = shortToken;  _changeBalanceIncentiveExponent(marketIndex, _balanceIncentiveCurve_exponent); _changeBalanceIncentiveEquilibriumOffset(marketIndex, _balanceIncentiveCurve_equilibriumOffset); _changeMarketLaunchIncentiveParameters(marketIndex, kPeriod, kInitialMultiplier);  _changeUnstakeFee(marketIndex, unstakeFee_e18);  // Set this value to one initially - 0 is a null value and thus potentially bug prone. batched_stakerNextTokenShiftIndex[marketIndex] = 1;  emit MarketAddedToStaker(   marketIndex,   unstakeFee_e18,   kPeriod,   kInitialMultiplier,   _balanceIncentiveCurve_exponent,   _balanceIncentiveCurve_equilibriumOffset );  emit AccumulativeIssuancePerStakedSynthSnapshotCreated(marketIndex, 0, 0, 0);  } /╔═════════════════════════════════════════════════════════════════════════╗     ║    GLOBAL FLT REWARD ACCUMULATION CALCULATION AND TRACKING FUNCTIONS    ║     ╚═════════════════════════════════════════════════════════════════════════╝/ /*   @notice Returns the K factor parameters for the given market with sensible   defaults if they haven't been set yet.   @param marketIndex The market to change the parameters for.   @return period The period for which the k factor applies for in seconds.   @return multiplier The multiplier on Float generation in this period.   /   function _getMarketLaunchIncentiveParameters(uint32 marketIndex)     internal     view     virtual     returns (uint256 period, uint256 multiplier)   {     period = marketLaunchIncentive_period[marketIndex];     multiplier = marketLaunchIncentive_multipliers[marketIndex]; if (multiplier &lt; 1e18) {   multiplier = 1e18; // multiplier of 1 by default }  } /*    @notice Returns the extent to which a markets float generation should be adjusted   based on the market's launch incentive parameters. Should start at multiplier   then linearly change to 1e18 over time.   @param marketIndex Identifies the market.   @return k The calculated modifier for float generation.   /   function _getKValue(uint32 marketIndex) internal view virtual returns (uint256) {     // Parameters controlling the float issuance multiplier.     (uint256 kPeriod, uint256 kInitialMultiplier) = _getMarketLaunchIncentiveParameters(marketIndex); // Sanity check - under normal circumstances, the multipliers should // *never* be set to a value &lt; 1e18, as there are guards against this. assert(kInitialMultiplier &gt;= 1e18);  uint256 initialTimestamp = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].timestamp;  if (block.timestamp - initialTimestamp &lt;= kPeriod) {   return kInitialMultiplier - (((kInitialMultiplier - 1e18) * (block.timestamp - initialTimestamp)) / kPeriod); } else {   return 1e18; }  } /   @notice Computes the number of float tokens a user earns per second for   every long/short synthetic token they've staked. The returned value has   a fixed decimal scale of 1e42 (!!!) for numerical stability. The return   values are float per second per synthetic token (hence the requirement   to multiply by price)   @dev to see below math in latex form see TODO add link   to interact with the equations see https://www.desmos.com/calculator/optkaxyihr   @param marketIndex The market referred to.   @param longPrice Price of the synthetic long token in units of payment token   @param shortPrice Price of the synthetic short token in units of payment token   @param longValue Amount of payment token in the long side of the market   @param shortValue Amount of payment token in the short side of the market   @return longFloatPerSecond Float token per second per long synthetic token   @return shortFloatPerSecond Float token per second per short synthetic token    /   function _calculateFloatPerSecond(     uint32 marketIndex,     uint256 longPrice,     uint256 shortPrice,     uint256 longValue,     uint256 shortValue   ) internal view virtual returns (uint256 longFloatPerSecond, uint256 shortFloatPerSecond) {     // A float issuance multiplier that starts high and decreases linearly     // over time to a value of 1. This incentivises users to stake early.     uint256 k = _getKValue(marketIndex); uint256 totalLocked = (longValue + shortValue);  // we need to scale this number by the totalLocked so that the offset remains consistent accross market size  int256 equilibriumOffsetMarketScaled = (balanceIncentiveCurve_equilibriumOffset[marketIndex] *   int256(totalLocked)) / 2e18;  uint256 denominator = ((totalLocked &gt;&gt; safeExponentBitShifting)**balanceIncentiveCurve_exponent[marketIndex]);  // Float is scaled by the percentage of the total market value held in // the opposite position. This incentivises users to stake on the // weaker position. if (int256(shortValue) - equilibriumOffsetMarketScaled &lt; int256(longValue)) {   if (equilibriumOffsetMarketScaled &gt;= int256(shortValue)) {     // edge case: imbalanced far past the equilibrium offset - full rewards go to short token     //            extremeley unlikely to happen in practice     return (0, 1e18 * k * shortPrice);   }    uint256 numerator = (uint256(int256(shortValue) - equilibriumOffsetMarketScaled) &gt;&gt;     (safeExponentBitShifting - 1))**balanceIncentiveCurve_exponent[marketIndex];    // NOTE: `x * 5e17` == `(x * 10e18) / 2`   uint256 longRewardUnscaled = (numerator * 5e17) / denominator;   uint256 shortRewardUnscaled = 1e18 - longRewardUnscaled;    return ((longRewardUnscaled * k * longPrice) / 1e18, (shortRewardUnscaled * k * shortPrice) / 1e18); } else {   if (-equilibriumOffsetMarketScaled &gt;= int256(longValue)) {     // edge case: imbalanced far past the equilibrium offset - full rewards go to long token     //            extremeley unlikely to happen in practice     return (1e18 * k * longPrice, 0);   }    uint256 numerator = (uint256(int256(longValue) + equilibriumOffsetMarketScaled) &gt;&gt;     (safeExponentBitShifting - 1))**balanceIncentiveCurve_exponent[marketIndex];    // NOTE: `x * 5e17` == `(x * 10e18) / 2`   uint256 shortRewardUnscaled = (numerator * 5e17) / denominator;   uint256 longRewardUnscaled = 1e18 - shortRewardUnscaled;    return ((longRewardUnscaled * k * longPrice) / 1e18, (shortRewardUnscaled * k * shortPrice) / 1e18); }  } /*   @notice Computes the time since last accumulativeIssuancePerStakedSynthSnapshot for the given market in seconds.   @param marketIndex The market referred to.   @return The time difference in seconds   /   function _calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(uint32 marketIndex)     internal     view     virtual     returns (uint256)   {     return       block.timestamp -       accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]].timestamp;   } /*   @notice Computes new cumulative sum of 'r' value since last accumulativeIssuancePerStakedSynthSnapshot. We use   cumulative 'r' value to avoid looping during issuance. Note that the   cumulative sum is kept in 1e42 scale (!!!) to avoid numerical issues.   @param shortValue The value locked in the short side of the market.   @param longValue The value locked in the long side of the market.   @param shortPrice The price of the short token as defined in LongShort.sol   @param longPrice The price of the long token as defined in LongShort.sol   @param marketIndex An identifier for the market.   @return longCumulativeRates The long cumulative sum.   @return shortCumulativeRates The short cumulative sum.   /   function _calculateNewCumulativeIssuancePerStakedSynth(     uint32 marketIndex,     uint256 longPrice,     uint256 shortPrice,     uint256 longValue,     uint256 shortValue   ) internal view virtual returns (uint256 longCumulativeRates, uint256 shortCumulativeRates) {     // Compute the current 'r' value for float issuance per second.     (uint256 longFloatPerSecond, uint256 shortFloatPerSecond) = _calculateFloatPerSecond(       marketIndex,       longPrice,       shortPrice,       longValue,       shortValue     ); // Compute time since last accumulativeIssuancePerStakedSynthSnapshot for the given token. uint256 timeDelta = _calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(marketIndex);  // Compute new cumulative 'r' value total. return (   accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]]   .accumulativeFloatPerSyntheticToken_long + (timeDelta * longFloatPerSecond),   accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]]   .accumulativeFloatPerSyntheticToken_short + (timeDelta * shortFloatPerSecond) );  } /*   @notice Creates a new accumulativeIssuancePerStakedSynthSnapshot for the given token and updates indexes.   @param shortValue The value locked in the short side of the market.   @param longValue The value locked in the long side of the market.   @param shortPrice The price of the short token as defined in LongShort.sol   @param longPrice The price of the long token as defined in LongShort.sol   @param marketIndex An identifier for the market.   /   function _setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot(     uint32 marketIndex,     uint256 longPrice,     uint256 shortPrice,     uint256 longValue,     uint256 shortValue   ) internal virtual {     (       uint256 newLongAccumulativeValue,       uint256 newShortAccumulativeValue     ) = _calculateNewCumulativeIssuancePerStakedSynth(marketIndex, longPrice, shortPrice, longValue, shortValue); uint256 newIndex = latestRewardIndex[marketIndex] + 1;  // Set cumulative 'r' value on new accumulativeIssuancePerStakedSynthSnapshot. accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex] .accumulativeFloatPerSyntheticToken_long = newLongAccumulativeValue; accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex] .accumulativeFloatPerSyntheticToken_short = newShortAccumulativeValue;  // Set timestamp on new accumulativeIssuancePerStakedSynthSnapshot. accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex].timestamp = block.timestamp;  // Update latest index to point to new accumulativeIssuancePerStakedSynthSnapshot. latestRewardIndex[marketIndex] = newIndex;  emit AccumulativeIssuancePerStakedSynthSnapshotCreated(   marketIndex,   newIndex,   newLongAccumulativeValue,   newShortAccumulativeValue );  } /*   @notice Adds new accumulativeIssuancePerStakedSynthSnapshots for the given long/short tokens. Called by the   ILongShort contract whenever there is a state change for a market.   @param stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted Mapping from this contract's shifts to LongShort.sols next price snapshots.   @param shortValue The value locked in the short side of the market.   @param longValue The value locked in the long side of the market.   @param shortPrice The price of the short token as defined in LongShort.sol   @param longPrice The price of the long token as defined in LongShort.sol   @param marketIndex An identifier for the market.   /   function pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(     uint32 marketIndex,     uint256 longPrice,     uint256 shortPrice,     uint256 longValue,     uint256 shortValue,     uint256 stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted // This value should be ALWAYS be zero if no shift occured   ) external override onlyLongShort {     // Only add a new accumulativeIssuancePerStakedSynthSnapshot if some time has passed. // the `stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted` value will be 0 if there is no staker related action in an executed batch if (stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted &gt; 0) {   stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[     batched_stakerNextTokenShiftIndex[marketIndex]   ] = stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted;   stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[     batched_stakerNextTokenShiftIndex[marketIndex]   ] = latestRewardIndex[marketIndex] + 1;   batched_stakerNextTokenShiftIndex[marketIndex] += 1;    emit SyntheticTokensShifted(); }  // Time delta is fetched twice in below code, can pass through? Which is less gas? if (_calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(marketIndex) &gt; 0) {   _setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot(     marketIndex,     longPrice,     shortPrice,     longValue,     shortValue   ); }  } /╔═══════════════════════════════════╗     ║    USER REWARD STATE FUNCTIONS    ║     ╚═══════════════════════════════════╝/ /// @dev Calculates the accumulated float in a specific range of staker snapshots   function _calculateAccumulatedFloatInRange(     uint32 marketIndex,     uint256 amountStakedLong,     uint256 amountStakedShort,     uint256 rewardIndexFrom,     uint256 rewardIndexTo   ) internal view virtual returns (uint256 floatReward) {     if (amountStakedLong &gt; 0) {       uint256 accumDeltaLong = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexTo]       .accumulativeFloatPerSyntheticToken_long -         accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexFrom]         .accumulativeFloatPerSyntheticToken_long;       floatReward += (accumDeltaLong * amountStakedLong) / FLOAT_ISSUANCE_FIXED_DECIMAL;     } if (amountStakedShort &gt; 0) {   uint256 accumDeltaShort = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexTo]   .accumulativeFloatPerSyntheticToken_short -     accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexFrom]     .accumulativeFloatPerSyntheticToken_short;   floatReward += (accumDeltaShort * amountStakedShort) / FLOAT_ISSUANCE_FIXED_DECIMAL; }  } /*    @notice Calculates float owed to the user since the user last minted float for a market.   @param marketIndex Identifier for the market which the user staked in.   @param user The address of the user.   @return floatReward The amount of float owed.    /   function _calculateAccumulatedFloat(uint32 marketIndex, address user) internal virtual returns (uint256 floatReward) {     address longToken = syntheticTokens[marketIndex][true];     address shortToken = syntheticTokens[marketIndex][false]; uint256 amountStakedLong = userAmountStaked[longToken][user]; uint256 amountStakedShort = userAmountStaked[shortToken][user];  uint256 usersLastRewardIndex = userIndexOfLastClaimedReward[marketIndex][user];  // Don't do the calculation and return zero immediately if there is no change if (usersLastRewardIndex == latestRewardIndex[marketIndex]) {   return 0; }  uint256 usersShiftIndex = userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][user]; // if there is a change in the users tokens held due to a token shift (or possibly another action in the future) if (usersShiftIndex &gt; 0 &amp;&amp; usersShiftIndex &lt; batched_stakerNextTokenShiftIndex[marketIndex]) {   floatReward = _calculateAccumulatedFloatInRange(     marketIndex,     amountStakedLong,     amountStakedShort,     usersLastRewardIndex,     stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[usersShiftIndex]   );    // Update the users balances   if (userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user] &gt; 0) {     amountStakedShort += ILongShort(longShort).getAmountSyntheticTokenToMintOnTargetSide(       marketIndex,       userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user],       true,       stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[usersShiftIndex]     );      amountStakedLong -= userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user];     userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user] = 0;   }    if (userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user] &gt; 0) {     amountStakedLong += ILongShort(longShort).getAmountSyntheticTokenToMintOnTargetSide(       marketIndex,       userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user],       false,       stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[usersShiftIndex]     );      amountStakedShort -= userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user];     userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user] = 0;   }    // Save the users updated staked amounts   userAmountStaked[longToken][user] = amountStakedLong;   userAmountStaked[shortToken][user] = amountStakedShort;    floatReward += _calculateAccumulatedFloatInRange(     marketIndex,     amountStakedLong,     amountStakedShort,     stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[usersShiftIndex],     latestRewardIndex[marketIndex]   );    userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][user] = 0; } else {   floatReward = _calculateAccumulatedFloatInRange(     marketIndex,     amountStakedLong,     amountStakedShort,     usersLastRewardIndex,     latestRewardIndex[marketIndex]   ); }  } /*   @notice Mints float for a user.   @dev Mints a fixed percentage for Float capital.   @param user The address of the user.   @param floatToMint The amount of float to mint.    /   function _mintFloat(address user, uint256 floatToMint) internal virtual {     IFloatToken(floatToken).mint(user, floatToMint);     IFloatToken(floatToken).mint(floatCapital, (floatToMint * floatPercentage) / 1e18);   } /*   @notice Mints float owed to a user for a market since they last minted.   @param marketIndex An identifier for the market.   @param user The address of the user.    /   function _mintAccumulatedFloat(uint32 marketIndex, address user) internal virtual {     uint256 floatToMint = _calculateAccumulatedFloat(marketIndex, user); if (floatToMint &gt; 0) {   // Set the user has claimed up until now, stops them setting this forward   userIndexOfLastClaimedReward[marketIndex][user] = latestRewardIndex[marketIndex];    _mintFloat(user, floatToMint);   emit FloatMinted(user, marketIndex, floatToMint); }  } /*   @notice Mints float owed to a user for multiple markets, since they last minted for those markets.   @param marketIndexes Identifiers for the markets.   @param user The address of the user.    /   function _mintAccumulatedFloatMulti(uint32[] calldata marketIndexes, address user) internal virtual {     uint256 floatTotal = 0;     for (uint256 i = 0; i &lt; marketIndexes.length; i++) {       uint256 floatToMint = _calculateAccumulatedFloat(marketIndexes[i], user);   if (floatToMint &gt; 0) {     // Set the user has claimed up until now, stops them setting this forward     userIndexOfLastClaimedReward[marketIndexes[i]][user] = latestRewardIndex[marketIndexes[i]];      floatTotal += floatToMint;      emit FloatMinted(user, marketIndexes[i], floatToMint);   } } if (floatTotal &gt; 0) {   _mintFloat(user, floatTotal); }  } /*   @notice Mints outstanding float for msg.sender.   @param marketIndexes Identifiers for the markets for which to mint float.    /   function claimFloatCustom(uint32[] calldata marketIndexes) external {     ILongShort(longShort).updateSystemStateMulti(marketIndexes);     _mintAccumulatedFloatMulti(marketIndexes, msg.sender);   } /*   @notice Mints outstanding float on behalf of another user.   @param marketIndexes Identifiers for the markets for which to mint float.   @param user The address of the user.    /   function claimFloatCustomFor(uint32[] calldata marketIndexes, address user) external {     // Unbounded loop - users are responsible for paying their own gas costs on these and it doesn't effect the rest of the system.     // No need to impose limit.     ILongShort(longShort).updateSystemStateMulti(marketIndexes);     _mintAccumulatedFloatMulti(marketIndexes, user);   } /╔═══════════════════════╗     ║        STAKING        ║     ╚═══════════════════════╝/ /*   @notice A user with synthetic tokens stakes by calling stake on the token   contract which calls this function. We need to first update the   state of the LongShort contract for this market before staking to correctly calculate user rewards.   @param amount Amount to stake.   @param from Address to stake for.   /   function stakeFromUser(address from, uint256 amount) public virtual override onlyValidSynthetic((msg.sender)) {     ILongShort(longShort).updateSystemState(marketIndexOfToken[(msg.sender)]);     _stake((msg.sender), amount, from);   } /*   @dev Internal logic for staking.   @param token Address of the token for which to stake.   @param amount Amount to stake.   @param user Address to stake for.   /   function _stake(     address token,     uint256 amount,     address user   ) internal virtual {     uint32 marketIndex = marketIndexOfToken[token]; // If they already have staked and have rewards due, mint these. if (   userIndexOfLastClaimedReward[marketIndex][user] != 0 &amp;&amp;   userIndexOfLastClaimedReward[marketIndex][user] &lt; latestRewardIndex[marketIndex] ) {   _mintAccumulatedFloat(marketIndex, user); }  userAmountStaked[token][user] = userAmountStaked[token][user] + amount;  userIndexOfLastClaimedReward[marketIndex][user] = latestRewardIndex[marketIndex];  emit StakeAdded(user, address(token), amount, userIndexOfLastClaimedReward[marketIndex][user]);  } /*   @notice Allows users to shift their staked tokens from one side of the market to    the other at the next price.   @param amountSyntheticTokensToShift Amount of tokens to shift.   @param marketIndex Identifier for the market.   @param isShiftFromLong Whether the shift is from long to short or short to long.   /   function shiftTokens(     uint256 amountSyntheticTokensToShift,     uint32 marketIndex,     bool isShiftFromLong   ) external virtual {     address token = syntheticTokens[marketIndex][isShiftFromLong];     require(userAmountStaked[token][msg.sender] &gt;= amountSyntheticTokensToShift, "Not enough tokens to shift"); // If the user has outstanding token shift that have already been confirmed in the LongShort // contract, execute them first. if (   userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] != 0 &amp;&amp;   userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] &lt;   batched_stakerNextTokenShiftIndex[marketIndex] ) {   _mintAccumulatedFloat(marketIndex, msg.sender); }  if (isShiftFromLong) {   ILongShort(longShort).shiftPositionFromLongNextPrice(marketIndex, amountSyntheticTokensToShift);   userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][     msg.sender   ] += amountSyntheticTokensToShift; } else {   ILongShort(longShort).shiftPositionFromShortNextPrice(marketIndex, amountSyntheticTokensToShift);   userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][     msg.sender   ] += amountSyntheticTokensToShift; }  userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] = batched_stakerNextTokenShiftIndex[   marketIndex ];  } /╔════════════════════════════╗     ║    WITHDRAWAL &amp; MINTING    ║     ╚════════════════════════════╝/ /*   @notice Internal logic for withdrawing stakes.   @dev Mint user any outstanding float before withdrawing.   @param marketIndex Market index of token.   @param amount Amount to withdraw.   @param token Synthetic token that was staked.   /   function _withdraw(     uint32 marketIndex,     address token,     uint256 amount   ) internal virtual {     require(userAmountStaked[token][msg.sender] &gt; 0, "nothing to withdraw");     _mintAccumulatedFloat(marketIndex, msg.sender); userAmountStaked[token][msg.sender] = userAmountStaked[token][msg.sender] - amount;  uint256 amountFees = (amount * marketUnstakeFee_e18[marketIndex]) / 1e18;  IERC20(token).transfer(floatTreasury, amountFees); IERC20(token).transfer(msg.sender, amount - amountFees);  emit StakeWithdrawn(msg.sender, token, amount);  } /*   @notice Withdraw function. Allows users to unstake.   @param amount Amount to withdraw.   @param token Address of the token for which to withdraw.   /   function withdraw(address token, uint256 amount) external {     ILongShort(longShort).updateSystemState(marketIndexOfToken[token]); uint32 marketIndex = marketIndexOfToken[token];  _withdraw(marketIndex, token, amount);  if (userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] &gt; 0) {   // If they still have outstanding shifts after minting float, then check   // that they don't withdraw more than their shifts allow.   uint256 amountToShiftForThisToken = syntheticTokens[marketIndex][true] == token     ? userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][msg.sender]     : userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][msg.sender];    require(     userAmountStaked[token][msg.sender] &gt;= amountToShiftForThisToken,     "Outstanding next price stake shifts too great"   ); }  } /*   @notice Allows users to withdraw their entire stake for a token.   @param token Address of the token for which to withdraw.   /   function withdrawAll(address token) external {     ILongShort(longShort).updateSystemState(marketIndexOfToken[token]); uint32 marketIndex = marketIndexOfToken[token];  uint256 amountToShiftForThisToken = syntheticTokens[marketIndex][true] == token   ? userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][msg.sender]   : userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][msg.sender];  _withdraw(marketIndex, token, userAmountStaked[token][msg.sender] - amountToShiftForThisToken);  } } |
| **need_reflect** | False |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **phase_prompt** | Below are the details of our smart contract codes and their corresponding analysis reports: Task: "{task}". As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report. |
| **phase_name** | BugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 2, 'task': '', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-17-08 08:01:43 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: BUSL-1.1 pragma solidity 0.8.3; import "@openzeppelin/contracts-upgradeable/token/ERC20/presets/ERC20PresetMinterPauserUpgradeable.sol"; import "./interfaces/IFloatToken.sol"; import "./interfaces/ILongShort.sol"; import "./interfaces/IStaker.sol"; import "./interfaces/ISyntheticToken.sol"; contract Staker is IStaker, Initializable {   /╔═════════════════════════════╗     ║          VARIABLES          ║     ╚═════════════════════════════╝/ / ══════ Fixed-precision constants ══════ /   uint256 public constant FLOAT_ISSUANCE_FIXED_DECIMAL = 1e42;   // 2^52 ~= 4.5e15   // With an exponent of 5, the largest total liquidity possible in a market (to avoid integer overflow on exponentiation) is ~10^31 or 10 Trillion (10^13)   // NOTE: this also means if the total market value is less than 2^52 there will be a division by zero error   uint256 public constant safeExponentBitShifting = 52; / ══════ Global state ══════ /   address public admin;   address public floatCapital;   address public floatTreasury;   uint256 public floatPercentage; address public longShort;   address public floatToken; / ══════ Market specific ══════ /   mapping(uint32 =&gt; uint256) public marketLaunchIncentive_period; // seconds   mapping(uint32 =&gt; uint256) public marketLaunchIncentive_multipliers; // e18 scale   mapping(uint32 =&gt; uint256) public marketUnstakeFee_e18;   mapping(uint32 =&gt; uint256) public balanceIncentiveCurve_exponent;   mapping(uint32 =&gt; int256) public balanceIncentiveCurve_equilibriumOffset; mapping(uint32 =&gt; mapping(bool =&gt; address)) public syntheticTokens; mapping(address =&gt; uint32) public marketIndexOfToken; / ══════ Reward specific ══════ /   mapping(uint32 =&gt; uint256) public latestRewardIndex;   mapping(uint32 =&gt; mapping(uint256 =&gt; AccumulativeIssuancePerStakedSynthSnapshot))     public accumulativeFloatPerSyntheticTokenSnapshots;   struct AccumulativeIssuancePerStakedSynthSnapshot {     uint256 timestamp;     uint256 accumulativeFloatPerSyntheticToken_long;     uint256 accumulativeFloatPerSyntheticToken_short;   } / ══════ User specific ══════ /   mapping(uint32 =&gt; mapping(address =&gt; uint256)) public userIndexOfLastClaimedReward;   mapping(address =&gt; mapping(address =&gt; uint256)) public userAmountStaked; / ══════ Token shift management specific ══════ /   mapping(uint32 =&gt; uint256) public batched_stakerNextTokenShiftIndex;   /*   @notice Used to link a token shift to a staker state   @dev tokenShiftIndex =&gt; accumulativeFloatIssuanceSnapshotIndex     POSSIBLE OPTIMIZATION - could pack stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping and stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping into a struct of two uint128 for storage space optimization.   /   mapping(uint256 =&gt; uint256) public stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping;   /// @notice Used to fetch the price from LongShort at that point in time   /// @dev tokenShiftIndex =&gt; longShortMarketPriceSnapshotIndex   mapping(uint256 =&gt; uint256) public stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping;   /// @dev marketIndex =&gt; usersAddress =&gt; stakerTokenShiftIndex   mapping(uint32 =&gt; mapping(address =&gt; uint256)) public userNextPrice_stakedSyntheticTokenShiftIndex;   /// @dev marketIndex =&gt; usersAddress =&gt; amountUserRequestedToShiftAwayFromLongOnNextUpdate   mapping(uint32 =&gt; mapping(address =&gt; uint256)) public userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long;   /// @dev marketIndex =&gt; usersAddress =&gt; amountUserRequestedToShiftAwayFromShortOnNextUpdate   mapping(uint32 =&gt; mapping(address =&gt; uint256)) public userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short; /╔════════════════════════════╗     ║           EVENTS           ║     ╚════════════════════════════╝/ event StakerV1(     address admin,     address floatTreasury,     address floatCapital,     address floatToken,     uint256 floatPercentage   ); event MarketAddedToStaker(     uint32 marketIndex,     uint256 exitFee_e18,     uint256 period,     uint256 multiplier,     uint256 balanceIncentiveExponent,     int256 balanceIncentiveEquilibriumOffset   ); event AccumulativeIssuancePerStakedSynthSnapshotCreated(     uint32 marketIndex,     uint256 accumulativeFloatIssuanceSnapshotIndex,     uint256 accumulativeLong,     uint256 accumulativeShort   ); event StakeAdded(address user, address token, uint256 amount, uint256 lastMintIndex); event StakeWithdrawn(address user, address token, uint256 amount); // Note: the amountFloatMinted isn't strictly needed by the graph, but it is good to add it to validate calculations are accurate.   event FloatMinted(address user, uint32 marketIndex, uint256 amountFloatMinted); event MarketLaunchIncentiveParametersChanges(uint32 marketIndex, uint256 period, uint256 multiplier); event StakeWithdrawalFeeUpdated(uint32 marketIndex, uint256 stakeWithdralFee); event BalanceIncentiveExponentUpdated(uint32 marketIndex, uint256 balanceIncentiveExponent); event BalanceIncentiveEquilibriumOffsetUpdated(uint32 marketIndex, int256 balanceIncentiveEquilibriumOffset); event FloatPercentageUpdated(uint256 floatPercentage); event SyntheticTokensShifted(); event ChangeAdmin(address newAdmin); /╔═════════════════════════════╗     ║          MODIFIERS          ║     ╚═════════════════════════════╝/ function onlyAdminModifierLogic() internal virtual {     require(msg.sender == admin, "not admin");   } modifier onlyAdmin() {     onlyAdminModifierLogic();     _;   } function onlyValidSyntheticModifierLogic(address _synth) internal virtual {     require(marketIndexOfToken[_synth] != 0, "not valid synth");   } modifier onlyValidSynthetic(address synth) {     onlyValidSyntheticModifierLogic(_synth);     ;   } function onlyValidMarketModifierLogic(uint32 marketIndex) internal virtual {     require(address(syntheticTokens[marketIndex][true]) != address(0), "not valid market");   } modifier onlyValidMarket(uint32 marketIndex) {     onlyValidMarketModifierLogic(marketIndex);     _;   } function onlyLongShortModifierLogic() internal virtual {     require(msg.sender == address(longShort), "not long short");   } modifier onlyLongShort() {     onlyLongShortModifierLogic();     _;   } /╔═════════════════════════════╗     ║       CONTRACT SET-UP       ║     ╚═════════════════════════════╝/ /*   @notice Initializes the contract.   @dev Calls OpenZeppelin's initializer modifier.   @param _admin Address of the admin role.   @param _longShort Address of the LongShort contract, a deployed LongShort.sol   @param _floatToken Address of the Float token earned by staking.   @param _floatTreasury Address of the treasury contract for managing fees.   @param _floatCapital Address of the contract which earns a fixed percentage of Float.   @param _floatPercentage Determines the float percentage that gets minted for Float Capital, base 1e18.   /   function initialize(     address _admin,     address _longShort,     address _floatToken,     address _floatTreasury,     address _floatCapital,     uint256 _floatPercentage   ) external virtual initializer {     admin = _admin;     floatCapital = _floatCapital;     floatTreasury = _floatTreasury;     longShort = _longShort;     floatToken = _floatToken; _changeFloatPercentage(_floatPercentage);  emit StakerV1(_admin, _floatTreasury, _floatCapital, _floatToken, _floatPercentage);  } /╔═══════════════════╗     ║       ADMIN       ║     ╚═══════════════════╝/ /*    @notice Changes admin for the contract   @param _admin The address of the new admin.   /   function changeAdmin(address _admin) external onlyAdmin {     admin = _admin;     emit ChangeAdmin(_admin);   } /// @dev Logic for changeFloatPercentage   function _changeFloatPercentage(uint256 newFloatPercentage) internal virtual {     require(newFloatPercentage &lt;= 1e18 &amp;&amp; newFloatPercentage &gt; 0); // less than or equal to 100% and greater than 0%     floatPercentage = newFloatPercentage;   } /*   @notice Changes percentage of float that is minted for float capital.   @param newFloatPercentage The new float percentage in base 1e18.   /   function changeFloatPercentage(uint256 newFloatPercentage) external onlyAdmin {     _changeFloatPercentage(newFloatPercentage);     emit FloatPercentageUpdated(newFloatPercentage);   } /// @dev Logic for changeUnstakeFee   function _changeUnstakeFee(uint32 marketIndex, uint256 newMarketUnstakeFee_e18) internal virtual {     require(newMarketUnstakeFee_e18 &lt;= 5e16); // Explicitely stating 5% fee as the max fee possible.     marketUnstakeFee_e18[marketIndex] = newMarketUnstakeFee_e18;   } /*   @notice Changes unstake fee for a market   @param marketIndex Identifies the market.   @param newMarketUnstakeFee_e18 The new unstake fee.   /   function changeUnstakeFee(uint32 marketIndex, uint256 newMarketUnstakeFee_e18) external onlyAdmin {     _changeUnstakeFee(marketIndex, newMarketUnstakeFee_e18);     emit StakeWithdrawalFeeUpdated(marketIndex, newMarketUnstakeFee_e18);   } /// @dev Logic for changeMarketLaunchIncentiveParameters   function _changeMarketLaunchIncentiveParameters(     uint32 marketIndex,     uint256 period,     uint256 initialMultiplier   ) internal virtual {     require(initialMultiplier &gt;= 1e18, "marketLaunchIncentiveMultiplier must be &gt;= 1e18"); marketLaunchIncentive_period[marketIndex] = period; marketLaunchIncentive_multipliers[marketIndex] = initialMultiplier;  } /*   @notice Changes the market launch incentive parameters for a market   @param marketIndex Identifies the market.   @param period The new period for which float token generation should be boosted.   @param initialMultiplier The new multiplier on Float generation.   /   function changeMarketLaunchIncentiveParameters(     uint32 marketIndex,     uint256 period,     uint256 initialMultiplier   ) external onlyAdmin {     _changeMarketLaunchIncentiveParameters(marketIndex, period, initialMultiplier); emit MarketLaunchIncentiveParametersChanges(marketIndex, period, initialMultiplier);  } /// @dev Logic for changeBalanceIncentiveExponent   function _changeBalanceIncentiveExponent(uint32 marketIndex, uint256 _balanceIncentiveCurve_exponent)     internal     virtual   {     require(       // The exponent has to be less than 5 in these versions of the contracts.       _balanceIncentiveCurve_exponent &gt; 0 &amp;&amp; _balanceIncentiveCurve_exponent &lt; 6,       "balanceIncentiveCurve_exponent out of bounds"     ); balanceIncentiveCurve_exponent[marketIndex] = _balanceIncentiveCurve_exponent;  } /*    @notice Changes the balance incentive exponent for a market   @param marketIndex Identifies the market.   @param _balanceIncentiveCurve_exponent The new exponent for the curve.   /   function changeBalanceIncentiveExponent(uint32 marketIndex, uint256 _balanceIncentiveCurve_exponent)     external     onlyAdmin   {     _changeBalanceIncentiveExponent(marketIndex, _balanceIncentiveCurve_exponent); emit BalanceIncentiveExponentUpdated(marketIndex, _balanceIncentiveCurve_exponent);  } /// @dev Logic for changeBalanceIncentiveEquilibriumOffset   function _changeBalanceIncentiveEquilibriumOffset(uint32 marketIndex, int256 _balanceIncentiveCurve_equilibriumOffset)     internal     virtual   {     // Unreasonable that we would ever shift this more than 90% either way     require(       _balanceIncentiveCurve_equilibriumOffset &gt; -9e17 &amp;&amp; _balanceIncentiveCurve_equilibriumOffset &lt; 9e17,       "balanceIncentiveCurve_equilibriumOffset out of bounds"     ); balanceIncentiveCurve_equilibriumOffset[marketIndex] = _balanceIncentiveCurve_equilibriumOffset;  } /*   @notice Changes the balance incentive curve equilibrium offset for a market   @param marketIndex Identifies the market.   @param _balanceIncentiveCurve_equilibriumOffset The new offset.   /   function changeBalanceIncentiveEquilibriumOffset(uint32 marketIndex, int256 _balanceIncentiveCurve_equilibriumOffset)     external     onlyAdmin   {     _changeBalanceIncentiveEquilibriumOffset(marketIndex, _balanceIncentiveCurve_equilibriumOffset); emit BalanceIncentiveEquilibriumOffsetUpdated(marketIndex, _balanceIncentiveCurve_equilibriumOffset);  } /╔═════════════════════════════╗     ║        STAKING SETUP        ║     ╚═════════════════════════════╝/ /*   @notice Sets this contract to track staking for a market in LongShort.sol   @param marketIndex Identifies the market.   @param longToken Address of the long token for the market.   @param shortToken Address of the short token for the market.   @param kInitialMultiplier Initial boost on float generation for the market.   @param kPeriod Period which the boost should last.   @param unstakeFee_e18 Percentage of tokens that are levied on unstaking in base 1e18.   @param _balanceIncentiveCurve_exponent Exponent for balance curve (see _calculateFloatPerSecond)   @param _balanceIncentiveCurve_equilibriumOffset Offset for balance curve (see _calculateFloatPerSecond)   /   function addNewStakingFund(     uint32 marketIndex,     address longToken,     address shortToken,     uint256 kInitialMultiplier,     uint256 kPeriod,     uint256 unstakeFee_e18,     uint256 _balanceIncentiveCurve_exponent,     int256 _balanceIncentiveCurve_equilibriumOffset   ) external override onlyLongShort {     marketIndexOfToken[longToken] = marketIndex;     marketIndexOfToken[shortToken] = marketIndex; accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].timestamp = block.timestamp; accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].accumulativeFloatPerSyntheticToken_long = 0; accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].accumulativeFloatPerSyntheticToken_short = 0;  syntheticTokens[marketIndex][true] = longToken; syntheticTokens[marketIndex][false] = shortToken;  _changeBalanceIncentiveExponent(marketIndex, _balanceIncentiveCurve_exponent); _changeBalanceIncentiveEquilibriumOffset(marketIndex, _balanceIncentiveCurve_equilibriumOffset); _changeMarketLaunchIncentiveParameters(marketIndex, kPeriod, kInitialMultiplier);  _changeUnstakeFee(marketIndex, unstakeFee_e18);  // Set this value to one initially - 0 is a null value and thus potentially bug prone. batched_stakerNextTokenShiftIndex[marketIndex] = 1;  emit MarketAddedToStaker(   marketIndex,   unstakeFee_e18,   kPeriod,   kInitialMultiplier,   _balanceIncentiveCurve_exponent,   _balanceIncentiveCurve_equilibriumOffset );  emit AccumulativeIssuancePerStakedSynthSnapshotCreated(marketIndex, 0, 0, 0);  } /╔═════════════════════════════════════════════════════════════════════════╗     ║    GLOBAL FLT REWARD ACCUMULATION CALCULATION AND TRACKING FUNCTIONS    ║     ╚═════════════════════════════════════════════════════════════════════════╝/ /*   @notice Returns the K factor parameters for the given market with sensible   defaults if they haven't been set yet.   @param marketIndex The market to change the parameters for.   @return period The period for which the k factor applies for in seconds.   @return multiplier The multiplier on Float generation in this period.   /   function _getMarketLaunchIncentiveParameters(uint32 marketIndex)     internal     view     virtual     returns (uint256 period, uint256 multiplier)   {     period = marketLaunchIncentive_period[marketIndex];     multiplier = marketLaunchIncentive_multipliers[marketIndex]; if (multiplier &lt; 1e18) {   multiplier = 1e18; // multiplier of 1 by default }  } /*    @notice Returns the extent to which a markets float generation should be adjusted   based on the market's launch incentive parameters. Should start at multiplier   then linearly change to 1e18 over time.   @param marketIndex Identifies the market.   @return k The calculated modifier for float generation.   /   function _getKValue(uint32 marketIndex) internal view virtual returns (uint256) {     // Parameters controlling the float issuance multiplier.     (uint256 kPeriod, uint256 kInitialMultiplier) = _getMarketLaunchIncentiveParameters(marketIndex); // Sanity check - under normal circumstances, the multipliers should // *never* be set to a value &lt; 1e18, as there are guards against this. assert(kInitialMultiplier &gt;= 1e18);  uint256 initialTimestamp = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].timestamp;  if (block.timestamp - initialTimestamp &lt;= kPeriod) {   return kInitialMultiplier - (((kInitialMultiplier - 1e18) * (block.timestamp - initialTimestamp)) / kPeriod); } else {   return 1e18; }  } /   @notice Computes the number of float tokens a user earns per second for   every long/short synthetic token they've staked. The returned value has   a fixed decimal scale of 1e42 (!!!) for numerical stability. The return   values are float per second per synthetic token (hence the requirement   to multiply by price)   @dev to see below math in latex form see TODO add link   to interact with the equations see https://www.desmos.com/calculator/optkaxyihr   @param marketIndex The market referred to.   @param longPrice Price of the synthetic long token in units of payment token   @param shortPrice Price of the synthetic short token in units of payment token   @param longValue Amount of payment token in the long side of the market   @param shortValue Amount of payment token in the short side of the market   @return longFloatPerSecond Float token per second per long synthetic token   @return shortFloatPerSecond Float token per second per short synthetic token    /   function _calculateFloatPerSecond(     uint32 marketIndex,     uint256 longPrice,     uint256 shortPrice,     uint256 longValue,     uint256 shortValue   ) internal view virtual returns (uint256 longFloatPerSecond, uint256 shortFloatPerSecond) {     // A float issuance multiplier that starts high and decreases linearly     // over time to a value of 1. This incentivises users to stake early.     uint256 k = _getKValue(marketIndex); uint256 totalLocked = (longValue + shortValue);  // we need to scale this number by the totalLocked so that the offset remains consistent accross market size  int256 equilibriumOffsetMarketScaled = (balanceIncentiveCurve_equilibriumOffset[marketIndex] *   int256(totalLocked)) / 2e18;  uint256 denominator = ((totalLocked &gt;&gt; safeExponentBitShifting)**balanceIncentiveCurve_exponent[marketIndex]);  // Float is scaled by the percentage of the total market value held in // the opposite position. This incentivises users to stake on the // weaker position. if (int256(shortValue) - equilibriumOffsetMarketScaled &lt; int256(longValue)) {   if (equilibriumOffsetMarketScaled &gt;= int256(shortValue)) {     // edge case: imbalanced far past the equilibrium offset - full rewards go to short token     //            extremeley unlikely to happen in practice     return (0, 1e18 * k * shortPrice);   }    uint256 numerator = (uint256(int256(shortValue) - equilibriumOffsetMarketScaled) &gt;&gt;     (safeExponentBitShifting - 1))**balanceIncentiveCurve_exponent[marketIndex];    // NOTE: `x * 5e17` == `(x * 10e18) / 2`   uint256 longRewardUnscaled = (numerator * 5e17) / denominator;   uint256 shortRewardUnscaled = 1e18 - longRewardUnscaled;    return ((longRewardUnscaled * k * longPrice) / 1e18, (shortRewardUnscaled * k * shortPrice) / 1e18); } else {   if (-equilibriumOffsetMarketScaled &gt;= int256(longValue)) {     // edge case: imbalanced far past the equilibrium offset - full rewards go to long token     //            extremeley unlikely to happen in practice     return (1e18 * k * longPrice, 0);   }    uint256 numerator = (uint256(int256(longValue) + equilibriumOffsetMarketScaled) &gt;&gt;     (safeExponentBitShifting - 1))**balanceIncentiveCurve_exponent[marketIndex];    // NOTE: `x * 5e17` == `(x * 10e18) / 2`   uint256 shortRewardUnscaled = (numerator * 5e17) / denominator;   uint256 longRewardUnscaled = 1e18 - shortRewardUnscaled;    return ((longRewardUnscaled * k * longPrice) / 1e18, (shortRewardUnscaled * k * shortPrice) / 1e18); }  } /*   @notice Computes the time since last accumulativeIssuancePerStakedSynthSnapshot for the given market in seconds.   @param marketIndex The market referred to.   @return The time difference in seconds   /   function _calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(uint32 marketIndex)     internal     view     virtual     returns (uint256)   {     return       block.timestamp -       accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]].timestamp;   } /*   @notice Computes new cumulative sum of 'r' value since last accumulativeIssuancePerStakedSynthSnapshot. We use   cumulative 'r' value to avoid looping during issuance. Note that the   cumulative sum is kept in 1e42 scale (!!!) to avoid numerical issues.   @param shortValue The value locked in the short side of the market.   @param longValue The value locked in the long side of the market.   @param shortPrice The price of the short token as defined in LongShort.sol   @param longPrice The price of the long token as defined in LongShort.sol   @param marketIndex An identifier for the market.   @return longCumulativeRates The long cumulative sum.   @return shortCumulativeRates The short cumulative sum.   /   function _calculateNewCumulativeIssuancePerStakedSynth(     uint32 marketIndex,     uint256 longPrice,     uint256 shortPrice,     uint256 longValue,     uint256 shortValue   ) internal view virtual returns (uint256 longCumulativeRates, uint256 shortCumulativeRates) {     // Compute the current 'r' value for float issuance per second.     (uint256 longFloatPerSecond, uint256 shortFloatPerSecond) = _calculateFloatPerSecond(       marketIndex,       longPrice,       shortPrice,       longValue,       shortValue     ); // Compute time since last accumulativeIssuancePerStakedSynthSnapshot for the given token. uint256 timeDelta = _calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(marketIndex);  // Compute new cumulative 'r' value total. return (   accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]]   .accumulativeFloatPerSyntheticToken_long + (timeDelta * longFloatPerSecond),   accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]]   .accumulativeFloatPerSyntheticToken_short + (timeDelta * shortFloatPerSecond) );  } /*   @notice Creates a new accumulativeIssuancePerStakedSynthSnapshot for the given token and updates indexes.   @param shortValue The value locked in the short side of the market.   @param longValue The value locked in the long side of the market.   @param shortPrice The price of the short token as defined in LongShort.sol   @param longPrice The price of the long token as defined in LongShort.sol   @param marketIndex An identifier for the market.   /   function _setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot(     uint32 marketIndex,     uint256 longPrice,     uint256 shortPrice,     uint256 longValue,     uint256 shortValue   ) internal virtual {     (       uint256 newLongAccumulativeValue,       uint256 newShortAccumulativeValue     ) = _calculateNewCumulativeIssuancePerStakedSynth(marketIndex, longPrice, shortPrice, longValue, shortValue); uint256 newIndex = latestRewardIndex[marketIndex] + 1;  // Set cumulative 'r' value on new accumulativeIssuancePerStakedSynthSnapshot. accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex] .accumulativeFloatPerSyntheticToken_long = newLongAccumulativeValue; accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex] .accumulativeFloatPerSyntheticToken_short = newShortAccumulativeValue;  // Set timestamp on new accumulativeIssuancePerStakedSynthSnapshot. accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex].timestamp = block.timestamp;  // Update latest index to point to new accumulativeIssuancePerStakedSynthSnapshot. latestRewardIndex[marketIndex] = newIndex;  emit AccumulativeIssuancePerStakedSynthSnapshotCreated(   marketIndex,   newIndex,   newLongAccumulativeValue,   newShortAccumulativeValue );  } /*   @notice Adds new accumulativeIssuancePerStakedSynthSnapshots for the given long/short tokens. Called by the   ILongShort contract whenever there is a state change for a market.   @param stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted Mapping from this contract's shifts to LongShort.sols next price snapshots.   @param shortValue The value locked in the short side of the market.   @param longValue The value locked in the long side of the market.   @param shortPrice The price of the short token as defined in LongShort.sol   @param longPrice The price of the long token as defined in LongShort.sol   @param marketIndex An identifier for the market.   /   function pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(     uint32 marketIndex,     uint256 longPrice,     uint256 shortPrice,     uint256 longValue,     uint256 shortValue,     uint256 stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted // This value should be ALWAYS be zero if no shift occured   ) external override onlyLongShort {     // Only add a new accumulativeIssuancePerStakedSynthSnapshot if some time has passed. // the `stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted` value will be 0 if there is no staker related action in an executed batch if (stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted &gt; 0) {   stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[     batched_stakerNextTokenShiftIndex[marketIndex]   ] = stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted;   stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[     batched_stakerNextTokenShiftIndex[marketIndex]   ] = latestRewardIndex[marketIndex] + 1;   batched_stakerNextTokenShiftIndex[marketIndex] += 1;    emit SyntheticTokensShifted(); }  // Time delta is fetched twice in below code, can pass through? Which is less gas? if (_calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(marketIndex) &gt; 0) {   _setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot(     marketIndex,     longPrice,     shortPrice,     longValue,     shortValue   ); }  } /╔═══════════════════════════════════╗     ║    USER REWARD STATE FUNCTIONS    ║     ╚═══════════════════════════════════╝/ /// @dev Calculates the accumulated float in a specific range of staker snapshots   function _calculateAccumulatedFloatInRange(     uint32 marketIndex,     uint256 amountStakedLong,     uint256 amountStakedShort,     uint256 rewardIndexFrom,     uint256 rewardIndexTo   ) internal view virtual returns (uint256 floatReward) {     if (amountStakedLong &gt; 0) {       uint256 accumDeltaLong = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexTo]       .accumulativeFloatPerSyntheticToken_long -         accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexFrom]         .accumulativeFloatPerSyntheticToken_long;       floatReward += (accumDeltaLong * amountStakedLong) / FLOAT_ISSUANCE_FIXED_DECIMAL;     } if (amountStakedShort &gt; 0) {   uint256 accumDeltaShort = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexTo]   .accumulativeFloatPerSyntheticToken_short -     accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexFrom]     .accumulativeFloatPerSyntheticToken_short;   floatReward += (accumDeltaShort * amountStakedShort) / FLOAT_ISSUANCE_FIXED_DECIMAL; }  } /*    @notice Calculates float owed to the user since the user last minted float for a market.   @param marketIndex Identifier for the market which the user staked in.   @param user The address of the user.   @return floatReward The amount of float owed.    /   function _calculateAccumulatedFloat(uint32 marketIndex, address user) internal virtual returns (uint256 floatReward) {     address longToken = syntheticTokens[marketIndex][true];     address shortToken = syntheticTokens[marketIndex][false]; uint256 amountStakedLong = userAmountStaked[longToken][user]; uint256 amountStakedShort = userAmountStaked[shortToken][user];  uint256 usersLastRewardIndex = userIndexOfLastClaimedReward[marketIndex][user];  // Don't do the calculation and return zero immediately if there is no change if (usersLastRewardIndex == latestRewardIndex[marketIndex]) {   return 0; }  uint256 usersShiftIndex = userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][user]; // if there is a change in the users tokens held due to a token shift (or possibly another action in the future) if (usersShiftIndex &gt; 0 &amp;&amp; usersShiftIndex &lt; batched_stakerNextTokenShiftIndex[marketIndex]) {   floatReward = _calculateAccumulatedFloatInRange(     marketIndex,     amountStakedLong,     amountStakedShort,     usersLastRewardIndex,     stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[usersShiftIndex]   );    // Update the users balances   if (userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user] &gt; 0) {     amountStakedShort += ILongShort(longShort).getAmountSyntheticTokenToMintOnTargetSide(       marketIndex,       userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user],       true,       stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[usersShiftIndex]     );      amountStakedLong -= userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user];     userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user] = 0;   }    if (userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user] &gt; 0) {     amountStakedLong += ILongShort(longShort).getAmountSyntheticTokenToMintOnTargetSide(       marketIndex,       userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user],       false,       stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[usersShiftIndex]     );      amountStakedShort -= userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user];     userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user] = 0;   }    // Save the users updated staked amounts   userAmountStaked[longToken][user] = amountStakedLong;   userAmountStaked[shortToken][user] = amountStakedShort;    floatReward += _calculateAccumulatedFloatInRange(     marketIndex,     amountStakedLong,     amountStakedShort,     stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[usersShiftIndex],     latestRewardIndex[marketIndex]   );    userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][user] = 0; } else {   floatReward = _calculateAccumulatedFloatInRange(     marketIndex,     amountStakedLong,     amountStakedShort,     usersLastRewardIndex,     latestRewardIndex[marketIndex]   ); }  } /*   @notice Mints float for a user.   @dev Mints a fixed percentage for Float capital.   @param user The address of the user.   @param floatToMint The amount of float to mint.    /   function _mintFloat(address user, uint256 floatToMint) internal virtual {     IFloatToken(floatToken).mint(user, floatToMint);     IFloatToken(floatToken).mint(floatCapital, (floatToMint * floatPercentage) / 1e18);   } /*   @notice Mints float owed to a user for a market since they last minted.   @param marketIndex An identifier for the market.   @param user The address of the user.    /   function _mintAccumulatedFloat(uint32 marketIndex, address user) internal virtual {     uint256 floatToMint = _calculateAccumulatedFloat(marketIndex, user); if (floatToMint &gt; 0) {   // Set the user has claimed up until now, stops them setting this forward   userIndexOfLastClaimedReward[marketIndex][user] = latestRewardIndex[marketIndex];    _mintFloat(user, floatToMint);   emit FloatMinted(user, marketIndex, floatToMint); }  } /*   @notice Mints float owed to a user for multiple markets, since they last minted for those markets.   @param marketIndexes Identifiers for the markets.   @param user The address of the user.    /   function _mintAccumulatedFloatMulti(uint32[] calldata marketIndexes, address user) internal virtual {     uint256 floatTotal = 0;     for (uint256 i = 0; i &lt; marketIndexes.length; i++) {       uint256 floatToMint = _calculateAccumulatedFloat(marketIndexes[i], user);   if (floatToMint &gt; 0) {     // Set the user has claimed up until now, stops them setting this forward     userIndexOfLastClaimedReward[marketIndexes[i]][user] = latestRewardIndex[marketIndexes[i]];      floatTotal += floatToMint;      emit FloatMinted(user, marketIndexes[i], floatToMint);   } } if (floatTotal &gt; 0) {   _mintFloat(user, floatTotal); }  } /*   @notice Mints outstanding float for msg.sender.   @param marketIndexes Identifiers for the markets for which to mint float.    /   function claimFloatCustom(uint32[] calldata marketIndexes) external {     ILongShort(longShort).updateSystemStateMulti(marketIndexes);     _mintAccumulatedFloatMulti(marketIndexes, msg.sender);   } /*   @notice Mints outstanding float on behalf of another user.   @param marketIndexes Identifiers for the markets for which to mint float.   @param user The address of the user.    /   function claimFloatCustomFor(uint32[] calldata marketIndexes, address user) external {     // Unbounded loop - users are responsible for paying their own gas costs on these and it doesn't effect the rest of the system.     // No need to impose limit.     ILongShort(longShort).updateSystemStateMulti(marketIndexes);     _mintAccumulatedFloatMulti(marketIndexes, user);   } /╔═══════════════════════╗     ║        STAKING        ║     ╚═══════════════════════╝/ /*   @notice A user with synthetic tokens stakes by calling stake on the token   contract which calls this function. We need to first update the   state of the LongShort contract for this market before staking to correctly calculate user rewards.   @param amount Amount to stake.   @param from Address to stake for.   /   function stakeFromUser(address from, uint256 amount) public virtual override onlyValidSynthetic((msg.sender)) {     ILongShort(longShort).updateSystemState(marketIndexOfToken[(msg.sender)]);     _stake((msg.sender), amount, from);   } /*   @dev Internal logic for staking.   @param token Address of the token for which to stake.   @param amount Amount to stake.   @param user Address to stake for.   /   function _stake(     address token,     uint256 amount,     address user   ) internal virtual {     uint32 marketIndex = marketIndexOfToken[token]; // If they already have staked and have rewards due, mint these. if (   userIndexOfLastClaimedReward[marketIndex][user] != 0 &amp;&amp;   userIndexOfLastClaimedReward[marketIndex][user] &lt; latestRewardIndex[marketIndex] ) {   _mintAccumulatedFloat(marketIndex, user); }  userAmountStaked[token][user] = userAmountStaked[token][user] + amount;  userIndexOfLastClaimedReward[marketIndex][user] = latestRewardIndex[marketIndex];  emit StakeAdded(user, address(token), amount, userIndexOfLastClaimedReward[marketIndex][user]);  } /*   @notice Allows users to shift their staked tokens from one side of the market to    the other at the next price.   @param amountSyntheticTokensToShift Amount of tokens to shift.   @param marketIndex Identifier for the market.   @param isShiftFromLong Whether the shift is from long to short or short to long.   /   function shiftTokens(     uint256 amountSyntheticTokensToShift,     uint32 marketIndex,     bool isShiftFromLong   ) external virtual {     address token = syntheticTokens[marketIndex][isShiftFromLong];     require(userAmountStaked[token][msg.sender] &gt;= amountSyntheticTokensToShift, "Not enough tokens to shift"); // If the user has outstanding token shift that have already been confirmed in the LongShort // contract, execute them first. if (   userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] != 0 &amp;&amp;   userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] &lt;   batched_stakerNextTokenShiftIndex[marketIndex] ) {   _mintAccumulatedFloat(marketIndex, msg.sender); }  if (isShiftFromLong) {   ILongShort(longShort).shiftPositionFromLongNextPrice(marketIndex, amountSyntheticTokensToShift);   userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][     msg.sender   ] += amountSyntheticTokensToShift; } else {   ILongShort(longShort).shiftPositionFromShortNextPrice(marketIndex, amountSyntheticTokensToShift);   userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][     msg.sender   ] += amountSyntheticTokensToShift; }  userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] = batched_stakerNextTokenShiftIndex[   marketIndex ];  } /╔════════════════════════════╗     ║    WITHDRAWAL &amp; MINTING    ║     ╚════════════════════════════╝/ /*   @notice Internal logic for withdrawing stakes.   @dev Mint user any outstanding float before withdrawing.   @param marketIndex Market index of token.   @param amount Amount to withdraw.   @param token Synthetic token that was staked.   /   function _withdraw(     uint32 marketIndex,     address token,     uint256 amount   ) internal virtual {     require(userAmountStaked[token][msg.sender] &gt; 0, "nothing to withdraw");     _mintAccumulatedFloat(marketIndex, msg.sender); userAmountStaked[token][msg.sender] = userAmountStaked[token][msg.sender] - amount;  uint256 amountFees = (amount * marketUnstakeFee_e18[marketIndex]) / 1e18;  IERC20(token).transfer(floatTreasury, amountFees); IERC20(token).transfer(msg.sender, amount - amountFees);  emit StakeWithdrawn(msg.sender, token, amount);  } /*   @notice Withdraw function. Allows users to unstake.   @param amount Amount to withdraw.   @param token Address of the token for which to withdraw.   /   function withdraw(address token, uint256 amount) external {     ILongShort(longShort).updateSystemState(marketIndexOfToken[token]); uint32 marketIndex = marketIndexOfToken[token];  _withdraw(marketIndex, token, amount);  if (userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] &gt; 0) {   // If they still have outstanding shifts after minting float, then check   // that they don't withdraw more than their shifts allow.   uint256 amountToShiftForThisToken = syntheticTokens[marketIndex][true] == token     ? userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][msg.sender]     : userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][msg.sender];    require(     userAmountStaked[token][msg.sender] &gt;= amountToShiftForThisToken,     "Outstanding next price stake shifts too great"   ); }  } /*   @notice Allows users to withdraw their entire stake for a token.   @param token Address of the token for which to withdraw.   /   function withdrawAll(address token) external {     ILongShort(longShort).updateSystemState(marketIndexOfToken[token]); uint32 marketIndex = marketIndexOfToken[token];  uint256 amountToShiftForThisToken = syntheticTokens[marketIndex][true] == token   ? userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][msg.sender]   : userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][msg.sender];  _withdraw(marketIndex, token, userAmountStaked[token][msg.sender] - amountToShiftForThisToken);  } } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-17-08 08:01:43 INFO] Security Analyst: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: BUSL-1.1

pragma solidity 0.8.3;

import "@openzeppelin/contracts-upgradeable/token/ERC20/presets/ERC20PresetMinterPauserUpgradeable.sol";

import "./interfaces/IFloatToken.sol";
import "./interfaces/ILongShort.sol";
import "./interfaces/IStaker.sol";
import "./interfaces/ISyntheticToken.sol";

contract Staker is IStaker, Initializable {
  /*╔═════════════════════════════╗
    ║          VARIABLES          ║
    ╚═════════════════════════════╝*/

  /* ══════ Fixed-precision constants ══════ */
  uint256 public constant FLOAT_ISSUANCE_FIXED_DECIMAL = 1e42;
  // 2^52 ~= 4.5e15
  // With an exponent of 5, the largest total liquidity possible in a market (to avoid integer overflow on exponentiation) is ~10^31 or 10 Trillion (10^13)
  // NOTE: this also means if the total market value is less than 2^52 there will be a division by zero error
  uint256 public constant safeExponentBitShifting = 52;

  /* ══════ Global state ══════ */
  address public admin;
  address public floatCapital;
  address public floatTreasury;
  uint256 public floatPercentage;

  address public longShort;
  address public floatToken;

  /* ══════ Market specific ══════ */
  mapping(uint32 => uint256) public marketLaunchIncentive_period; // seconds
  mapping(uint32 => uint256) public marketLaunchIncentive_multipliers; // e18 scale
  mapping(uint32 => uint256) public marketUnstakeFee_e18;
  mapping(uint32 => uint256) public balanceIncentiveCurve_exponent;
  mapping(uint32 => int256) public balanceIncentiveCurve_equilibriumOffset;

  mapping(uint32 => mapping(bool => address)) public syntheticTokens;

  mapping(address => uint32) public marketIndexOfToken;

  /* ══════ Reward specific ══════ */
  mapping(uint32 => uint256) public latestRewardIndex;
  mapping(uint32 => mapping(uint256 => AccumulativeIssuancePerStakedSynthSnapshot))
    public accumulativeFloatPerSyntheticTokenSnapshots;
  struct AccumulativeIssuancePerStakedSynthSnapshot {
    uint256 timestamp;
    uint256 accumulativeFloatPerSyntheticToken_long;
    uint256 accumulativeFloatPerSyntheticToken_short;
  }

  /* ══════ User specific ══════ */
  mapping(uint32 => mapping(address => uint256)) public userIndexOfLastClaimedReward;
  mapping(address => mapping(address => uint256)) public userAmountStaked;

  /* ══════ Token shift management specific ══════ */
  mapping(uint32 => uint256) public batched_stakerNextTokenShiftIndex;
  /**
  @notice Used to link a token shift to a staker state
  @dev tokenShiftIndex => accumulativeFloatIssuanceSnapshotIndex
    POSSIBLE OPTIMIZATION - could pack stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping and stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping into a struct of two uint128 for storage space optimization.
  */
  mapping(uint256 => uint256) public stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping;
  /// @notice Used to fetch the price from LongShort at that point in time
  /// @dev tokenShiftIndex => longShortMarketPriceSnapshotIndex
  mapping(uint256 => uint256) public stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping;
  /// @dev marketIndex => usersAddress => stakerTokenShiftIndex
  mapping(uint32 => mapping(address => uint256)) public userNextPrice_stakedSyntheticTokenShiftIndex;
  /// @dev marketIndex => usersAddress => amountUserRequestedToShiftAwayFromLongOnNextUpdate
  mapping(uint32 => mapping(address => uint256)) public userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long;
  /// @dev marketIndex => usersAddress => amountUserRequestedToShiftAwayFromShortOnNextUpdate
  mapping(uint32 => mapping(address => uint256)) public userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short;

  /*╔════════════════════════════╗
    ║           EVENTS           ║
    ╚════════════════════════════╝*/

  event StakerV1(
    address admin,
    address floatTreasury,
    address floatCapital,
    address floatToken,
    uint256 floatPercentage
  );

  event MarketAddedToStaker(
    uint32 marketIndex,
    uint256 exitFee_e18,
    uint256 period,
    uint256 multiplier,
    uint256 balanceIncentiveExponent,
    int256 balanceIncentiveEquilibriumOffset
  );

  event AccumulativeIssuancePerStakedSynthSnapshotCreated(
    uint32 marketIndex,
    uint256 accumulativeFloatIssuanceSnapshotIndex,
    uint256 accumulativeLong,
    uint256 accumulativeShort
  );

  event StakeAdded(address user, address token, uint256 amount, uint256 lastMintIndex);

  event StakeWithdrawn(address user, address token, uint256 amount);

  // Note: the `amountFloatMinted` isn't strictly needed by the graph, but it is good to add it to validate calculations are accurate.
  event FloatMinted(address user, uint32 marketIndex, uint256 amountFloatMinted);

  event MarketLaunchIncentiveParametersChanges(uint32 marketIndex, uint256 period, uint256 multiplier);

  event StakeWithdrawalFeeUpdated(uint32 marketIndex, uint256 stakeWithdralFee);

  event BalanceIncentiveExponentUpdated(uint32 marketIndex, uint256 balanceIncentiveExponent);

  event BalanceIncentiveEquilibriumOffsetUpdated(uint32 marketIndex, int256 balanceIncentiveEquilibriumOffset);

  event FloatPercentageUpdated(uint256 floatPercentage);

  event SyntheticTokensShifted();

  event ChangeAdmin(address newAdmin);

  /*╔═════════════════════════════╗
    ║          MODIFIERS          ║
    ╚═════════════════════════════╝*/

  function onlyAdminModifierLogic() internal virtual {
    require(msg.sender == admin, "not admin");
  }

  modifier onlyAdmin() {
    onlyAdminModifierLogic();
    _;
  }

  function onlyValidSyntheticModifierLogic(address _synth) internal virtual {
    require(marketIndexOfToken[_synth] != 0, "not valid synth");
  }

  modifier onlyValidSynthetic(address _synth) {
    onlyValidSyntheticModifierLogic(_synth);
    _;
  }

  function onlyValidMarketModifierLogic(uint32 marketIndex) internal virtual {
    require(address(syntheticTokens[marketIndex][true]) != address(0), "not valid market");
  }

  modifier onlyValidMarket(uint32 marketIndex) {
    onlyValidMarketModifierLogic(marketIndex);
    _;
  }

  function onlyLongShortModifierLogic() internal virtual {
    require(msg.sender == address(longShort), "not long short");
  }

  modifier onlyLongShort() {
    onlyLongShortModifierLogic();
    _;
  }

  /*╔═════════════════════════════╗
    ║       CONTRACT SET-UP       ║
    ╚═════════════════════════════╝*/

  /**
  @notice Initializes the contract.
  @dev Calls OpenZeppelin's initializer modifier.
  @param _admin Address of the admin role.
  @param _longShort Address of the LongShort contract, a deployed LongShort.sol
  @param _floatToken Address of the Float token earned by staking.
  @param _floatTreasury Address of the treasury contract for managing fees.
  @param _floatCapital Address of the contract which earns a fixed percentage of Float.
  @param _floatPercentage Determines the float percentage that gets minted for Float Capital, base 1e18.
  */
  function initialize(
    address _admin,
    address _longShort,
    address _floatToken,
    address _floatTreasury,
    address _floatCapital,
    uint256 _floatPercentage
  ) external virtual initializer {
    admin = _admin;
    floatCapital = _floatCapital;
    floatTreasury = _floatTreasury;
    longShort = _longShort;
    floatToken = _floatToken;

    _changeFloatPercentage(_floatPercentage);

    emit StakerV1(_admin, _floatTreasury, _floatCapital, _floatToken, _floatPercentage);
  }

  /*╔═══════════════════╗
    ║       ADMIN       ║
    ╚═══════════════════╝*/

  /** 
  @notice Changes admin for the contract
  @param _admin The address of the new admin.
  */
  function changeAdmin(address _admin) external onlyAdmin {
    admin = _admin;
    emit ChangeAdmin(_admin);
  }

  /// @dev Logic for changeFloatPercentage
  function _changeFloatPercentage(uint256 newFloatPercentage) internal virtual {
    require(newFloatPercentage <= 1e18 && newFloatPercentage > 0); // less than or equal to 100% and greater than 0%
    floatPercentage = newFloatPercentage;
  }

  /**
  @notice Changes percentage of float that is minted for float capital.
  @param newFloatPercentage The new float percentage in base 1e18.
  */
  function changeFloatPercentage(uint256 newFloatPercentage) external onlyAdmin {
    _changeFloatPercentage(newFloatPercentage);
    emit FloatPercentageUpdated(newFloatPercentage);
  }

  /// @dev Logic for changeUnstakeFee
  function _changeUnstakeFee(uint32 marketIndex, uint256 newMarketUnstakeFee_e18) internal virtual {
    require(newMarketUnstakeFee_e18 <= 5e16); // Explicitely stating 5% fee as the max fee possible.
    marketUnstakeFee_e18[marketIndex] = newMarketUnstakeFee_e18;
  }

  /**
  @notice Changes unstake fee for a market
  @param marketIndex Identifies the market.
  @param newMarketUnstakeFee_e18 The new unstake fee.
  */
  function changeUnstakeFee(uint32 marketIndex, uint256 newMarketUnstakeFee_e18) external onlyAdmin {
    _changeUnstakeFee(marketIndex, newMarketUnstakeFee_e18);
    emit StakeWithdrawalFeeUpdated(marketIndex, newMarketUnstakeFee_e18);
  }

  /// @dev Logic for changeMarketLaunchIncentiveParameters
  function _changeMarketLaunchIncentiveParameters(
    uint32 marketIndex,
    uint256 period,
    uint256 initialMultiplier
  ) internal virtual {
    require(initialMultiplier >= 1e18, "marketLaunchIncentiveMultiplier must be >= 1e18");

    marketLaunchIncentive_period[marketIndex] = period;
    marketLaunchIncentive_multipliers[marketIndex] = initialMultiplier;
  }

  /**
  @notice Changes the market launch incentive parameters for a market
  @param marketIndex Identifies the market.
  @param period The new period for which float token generation should be boosted.
  @param initialMultiplier The new multiplier on Float generation.
  */
  function changeMarketLaunchIncentiveParameters(
    uint32 marketIndex,
    uint256 period,
    uint256 initialMultiplier
  ) external onlyAdmin {
    _changeMarketLaunchIncentiveParameters(marketIndex, period, initialMultiplier);

    emit MarketLaunchIncentiveParametersChanges(marketIndex, period, initialMultiplier);
  }

  /// @dev Logic for changeBalanceIncentiveExponent
  function _changeBalanceIncentiveExponent(uint32 marketIndex, uint256 _balanceIncentiveCurve_exponent)
    internal
    virtual
  {
    require(
      // The exponent has to be less than 5 in these versions of the contracts.
      _balanceIncentiveCurve_exponent > 0 && _balanceIncentiveCurve_exponent < 6,
      "balanceIncentiveCurve_exponent out of bounds"
    );

    balanceIncentiveCurve_exponent[marketIndex] = _balanceIncentiveCurve_exponent;
  }

  /** 
  @notice Changes the balance incentive exponent for a market
  @param marketIndex Identifies the market.
  @param _balanceIncentiveCurve_exponent The new exponent for the curve.
  */
  function changeBalanceIncentiveExponent(uint32 marketIndex, uint256 _balanceIncentiveCurve_exponent)
    external
    onlyAdmin
  {
    _changeBalanceIncentiveExponent(marketIndex, _balanceIncentiveCurve_exponent);

    emit BalanceIncentiveExponentUpdated(marketIndex, _balanceIncentiveCurve_exponent);
  }

  /// @dev Logic for changeBalanceIncentiveEquilibriumOffset
  function _changeBalanceIncentiveEquilibriumOffset(uint32 marketIndex, int256 _balanceIncentiveCurve_equilibriumOffset)
    internal
    virtual
  {
    // Unreasonable that we would ever shift this more than 90% either way
    require(
      _balanceIncentiveCurve_equilibriumOffset > -9e17 && _balanceIncentiveCurve_equilibriumOffset < 9e17,
      "balanceIncentiveCurve_equilibriumOffset out of bounds"
    );

    balanceIncentiveCurve_equilibriumOffset[marketIndex] = _balanceIncentiveCurve_equilibriumOffset;
  }

  /**
  @notice Changes the balance incentive curve equilibrium offset for a market
  @param marketIndex Identifies the market.
  @param _balanceIncentiveCurve_equilibriumOffset The new offset.
  */
  function changeBalanceIncentiveEquilibriumOffset(uint32 marketIndex, int256 _balanceIncentiveCurve_equilibriumOffset)
    external
    onlyAdmin
  {
    _changeBalanceIncentiveEquilibriumOffset(marketIndex, _balanceIncentiveCurve_equilibriumOffset);

    emit BalanceIncentiveEquilibriumOffsetUpdated(marketIndex, _balanceIncentiveCurve_equilibriumOffset);
  }

  /*╔═════════════════════════════╗
    ║        STAKING SETUP        ║
    ╚═════════════════════════════╝*/

  /**
  @notice Sets this contract to track staking for a market in LongShort.sol
  @param marketIndex Identifies the market.
  @param longToken Address of the long token for the market.
  @param shortToken Address of the short token for the market.
  @param kInitialMultiplier Initial boost on float generation for the market.
  @param kPeriod Period which the boost should last.
  @param unstakeFee_e18 Percentage of tokens that are levied on unstaking in base 1e18.
  @param _balanceIncentiveCurve_exponent Exponent for balance curve (see _calculateFloatPerSecond)
  @param _balanceIncentiveCurve_equilibriumOffset Offset for balance curve (see _calculateFloatPerSecond)
  */
  function addNewStakingFund(
    uint32 marketIndex,
    address longToken,
    address shortToken,
    uint256 kInitialMultiplier,
    uint256 kPeriod,
    uint256 unstakeFee_e18,
    uint256 _balanceIncentiveCurve_exponent,
    int256 _balanceIncentiveCurve_equilibriumOffset
  ) external override onlyLongShort {
    marketIndexOfToken[longToken] = marketIndex;
    marketIndexOfToken[shortToken] = marketIndex;

    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].timestamp = block.timestamp;
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].accumulativeFloatPerSyntheticToken_long = 0;
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].accumulativeFloatPerSyntheticToken_short = 0;

    syntheticTokens[marketIndex][true] = longToken;
    syntheticTokens[marketIndex][false] = shortToken;

    _changeBalanceIncentiveExponent(marketIndex, _balanceIncentiveCurve_exponent);
    _changeBalanceIncentiveEquilibriumOffset(marketIndex, _balanceIncentiveCurve_equilibriumOffset);
    _changeMarketLaunchIncentiveParameters(marketIndex, kPeriod, kInitialMultiplier);

    _changeUnstakeFee(marketIndex, unstakeFee_e18);

    // Set this value to one initially - 0 is a null value and thus potentially bug prone.
    batched_stakerNextTokenShiftIndex[marketIndex] = 1;

    emit MarketAddedToStaker(
      marketIndex,
      unstakeFee_e18,
      kPeriod,
      kInitialMultiplier,
      _balanceIncentiveCurve_exponent,
      _balanceIncentiveCurve_equilibriumOffset
    );

    emit AccumulativeIssuancePerStakedSynthSnapshotCreated(marketIndex, 0, 0, 0);
  }

  /*╔═════════════════════════════════════════════════════════════════════════╗
    ║    GLOBAL FLT REWARD ACCUMULATION CALCULATION AND TRACKING FUNCTIONS    ║
    ╚═════════════════════════════════════════════════════════════════════════╝*/

  /**
  @notice Returns the K factor parameters for the given market with sensible
  defaults if they haven't been set yet.
  @param marketIndex The market to change the parameters for.
  @return period The period for which the k factor applies for in seconds.
  @return multiplier The multiplier on Float generation in this period.
  */
  function _getMarketLaunchIncentiveParameters(uint32 marketIndex)
    internal
    view
    virtual
    returns (uint256 period, uint256 multiplier)
  {
    period = marketLaunchIncentive_period[marketIndex];
    multiplier = marketLaunchIncentive_multipliers[marketIndex];

    if (multiplier < 1e18) {
      multiplier = 1e18; // multiplier of 1 by default
    }
  }

  /** 
  @notice Returns the extent to which a markets float generation should be adjusted
  based on the market's launch incentive parameters. Should start at multiplier
  then linearly change to 1e18 over time.
  @param marketIndex Identifies the market.
  @return k The calculated modifier for float generation.
  */
  function _getKValue(uint32 marketIndex) internal view virtual returns (uint256) {
    // Parameters controlling the float issuance multiplier.
    (uint256 kPeriod, uint256 kInitialMultiplier) = _getMarketLaunchIncentiveParameters(marketIndex);

    // Sanity check - under normal circumstances, the multipliers should
    // *never* be set to a value < 1e18, as there are guards against this.
    assert(kInitialMultiplier >= 1e18);

    uint256 initialTimestamp = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].timestamp;

    if (block.timestamp - initialTimestamp <= kPeriod) {
      return kInitialMultiplier - (((kInitialMultiplier - 1e18) * (block.timestamp - initialTimestamp)) / kPeriod);
    } else {
      return 1e18;
    }
  }

  /*
  @notice Computes the number of float tokens a user earns per second for
  every long/short synthetic token they've staked. The returned value has
  a fixed decimal scale of 1e42 (!!!) for numerical stability. The return
  values are float per second per synthetic token (hence the requirement
  to multiply by price)
  @dev to see below math in latex form see TODO add link
  to interact with the equations see https://www.desmos.com/calculator/optkaxyihr
  @param marketIndex The market referred to.
  @param longPrice Price of the synthetic long token in units of payment token
  @param shortPrice Price of the synthetic short token in units of payment token
  @param longValue Amount of payment token in the long side of the market
  @param shortValue Amount of payment token in the short side of the market
  @return longFloatPerSecond Float token per second per long synthetic token
  @return shortFloatPerSecond Float token per second per short synthetic token
   */
  function _calculateFloatPerSecond(
    uint32 marketIndex,
    uint256 longPrice,
    uint256 shortPrice,
    uint256 longValue,
    uint256 shortValue
  ) internal view virtual returns (uint256 longFloatPerSecond, uint256 shortFloatPerSecond) {
    // A float issuance multiplier that starts high and decreases linearly
    // over time to a value of 1. This incentivises users to stake early.
    uint256 k = _getKValue(marketIndex);

    uint256 totalLocked = (longValue + shortValue);

    // we need to scale this number by the totalLocked so that the offset remains consistent accross market size

    int256 equilibriumOffsetMarketScaled = (balanceIncentiveCurve_equilibriumOffset[marketIndex] *
      int256(totalLocked)) / 2e18;

    uint256 denominator = ((totalLocked >> safeExponentBitShifting)**balanceIncentiveCurve_exponent[marketIndex]);

    // Float is scaled by the percentage of the total market value held in
    // the opposite position. This incentivises users to stake on the
    // weaker position.
    if (int256(shortValue) - equilibriumOffsetMarketScaled < int256(longValue)) {
      if (equilibriumOffsetMarketScaled >= int256(shortValue)) {
        // edge case: imbalanced far past the equilibrium offset - full rewards go to short token
        //            extremeley unlikely to happen in practice
        return (0, 1e18 * k * shortPrice);
      }

      uint256 numerator = (uint256(int256(shortValue) - equilibriumOffsetMarketScaled) >>
        (safeExponentBitShifting - 1))**balanceIncentiveCurve_exponent[marketIndex];

      // NOTE: `x * 5e17` == `(x * 10e18) / 2`
      uint256 longRewardUnscaled = (numerator * 5e17) / denominator;
      uint256 shortRewardUnscaled = 1e18 - longRewardUnscaled;

      return ((longRewardUnscaled * k * longPrice) / 1e18, (shortRewardUnscaled * k * shortPrice) / 1e18);
    } else {
      if (-equilibriumOffsetMarketScaled >= int256(longValue)) {
        // edge case: imbalanced far past the equilibrium offset - full rewards go to long token
        //            extremeley unlikely to happen in practice
        return (1e18 * k * longPrice, 0);
      }

      uint256 numerator = (uint256(int256(longValue) + equilibriumOffsetMarketScaled) >>
        (safeExponentBitShifting - 1))**balanceIncentiveCurve_exponent[marketIndex];

      // NOTE: `x * 5e17` == `(x * 10e18) / 2`
      uint256 shortRewardUnscaled = (numerator * 5e17) / denominator;
      uint256 longRewardUnscaled = 1e18 - shortRewardUnscaled;

      return ((longRewardUnscaled * k * longPrice) / 1e18, (shortRewardUnscaled * k * shortPrice) / 1e18);
    }
  }

  /**
  @notice Computes the time since last accumulativeIssuancePerStakedSynthSnapshot for the given market in seconds.
  @param marketIndex The market referred to.
  @return The time difference in seconds
  */
  function _calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(uint32 marketIndex)
    internal
    view
    virtual
    returns (uint256)
  {
    return
      block.timestamp -
      accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]].timestamp;
  }

  /**
  @notice Computes new cumulative sum of 'r' value since last accumulativeIssuancePerStakedSynthSnapshot. We use
  cumulative 'r' value to avoid looping during issuance. Note that the
  cumulative sum is kept in 1e42 scale (!!!) to avoid numerical issues.
  @param shortValue The value locked in the short side of the market.
  @param longValue The value locked in the long side of the market.
  @param shortPrice The price of the short token as defined in LongShort.sol
  @param longPrice The price of the long token as defined in LongShort.sol
  @param marketIndex An identifier for the market.
  @return longCumulativeRates The long cumulative sum.
  @return shortCumulativeRates The short cumulative sum.
  */
  function _calculateNewCumulativeIssuancePerStakedSynth(
    uint32 marketIndex,
    uint256 longPrice,
    uint256 shortPrice,
    uint256 longValue,
    uint256 shortValue
  ) internal view virtual returns (uint256 longCumulativeRates, uint256 shortCumulativeRates) {
    // Compute the current 'r' value for float issuance per second.
    (uint256 longFloatPerSecond, uint256 shortFloatPerSecond) = _calculateFloatPerSecond(
      marketIndex,
      longPrice,
      shortPrice,
      longValue,
      shortValue
    );

    // Compute time since last accumulativeIssuancePerStakedSynthSnapshot for the given token.
    uint256 timeDelta = _calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(marketIndex);

    // Compute new cumulative 'r' value total.
    return (
      accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]]
      .accumulativeFloatPerSyntheticToken_long + (timeDelta * longFloatPerSecond),
      accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]]
      .accumulativeFloatPerSyntheticToken_short + (timeDelta * shortFloatPerSecond)
    );
  }

  /**
  @notice Creates a new accumulativeIssuancePerStakedSynthSnapshot for the given token and updates indexes.
  @param shortValue The value locked in the short side of the market.
  @param longValue The value locked in the long side of the market.
  @param shortPrice The price of the short token as defined in LongShort.sol
  @param longPrice The price of the long token as defined in LongShort.sol
  @param marketIndex An identifier for the market.
  */
  function _setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot(
    uint32 marketIndex,
    uint256 longPrice,
    uint256 shortPrice,
    uint256 longValue,
    uint256 shortValue
  ) internal virtual {
    (
      uint256 newLongAccumulativeValue,
      uint256 newShortAccumulativeValue
    ) = _calculateNewCumulativeIssuancePerStakedSynth(marketIndex, longPrice, shortPrice, longValue, shortValue);

    uint256 newIndex = latestRewardIndex[marketIndex] + 1;

    // Set cumulative 'r' value on new accumulativeIssuancePerStakedSynthSnapshot.
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex]
    .accumulativeFloatPerSyntheticToken_long = newLongAccumulativeValue;
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex]
    .accumulativeFloatPerSyntheticToken_short = newShortAccumulativeValue;

    // Set timestamp on new accumulativeIssuancePerStakedSynthSnapshot.
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex].timestamp = block.timestamp;

    // Update latest index to point to new accumulativeIssuancePerStakedSynthSnapshot.
    latestRewardIndex[marketIndex] = newIndex;

    emit AccumulativeIssuancePerStakedSynthSnapshotCreated(
      marketIndex,
      newIndex,
      newLongAccumulativeValue,
      newShortAccumulativeValue
    );
  }

  /**
  @notice Adds new accumulativeIssuancePerStakedSynthSnapshots for the given long/short tokens. Called by the
  ILongShort contract whenever there is a state change for a market.
  @param stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted Mapping from this contract's shifts to LongShort.sols next price snapshots.
  @param shortValue The value locked in the short side of the market.
  @param longValue The value locked in the long side of the market.
  @param shortPrice The price of the short token as defined in LongShort.sol
  @param longPrice The price of the long token as defined in LongShort.sol
  @param marketIndex An identifier for the market.
  */
  function pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(
    uint32 marketIndex,
    uint256 longPrice,
    uint256 shortPrice,
    uint256 longValue,
    uint256 shortValue,
    uint256 stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted // This value should be ALWAYS be zero if no shift occured
  ) external override onlyLongShort {
    // Only add a new accumulativeIssuancePerStakedSynthSnapshot if some time has passed.

    // the `stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted` value will be 0 if there is no staker related action in an executed batch
    if (stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted > 0) {
      stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[
        batched_stakerNextTokenShiftIndex[marketIndex]
      ] = stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted;
      stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[
        batched_stakerNextTokenShiftIndex[marketIndex]
      ] = latestRewardIndex[marketIndex] + 1;
      batched_stakerNextTokenShiftIndex[marketIndex] += 1;

      emit SyntheticTokensShifted();
    }

    // Time delta is fetched twice in below code, can pass through? Which is less gas?
    if (_calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(marketIndex) > 0) {
      _setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot(
        marketIndex,
        longPrice,
        shortPrice,
        longValue,
        shortValue
      );
    }
  }

  /*╔═══════════════════════════════════╗
    ║    USER REWARD STATE FUNCTIONS    ║
    ╚═══════════════════════════════════╝*/

  /// @dev Calculates the accumulated float in a specific range of staker snapshots
  function _calculateAccumulatedFloatInRange(
    uint32 marketIndex,
    uint256 amountStakedLong,
    uint256 amountStakedShort,
    uint256 rewardIndexFrom,
    uint256 rewardIndexTo
  ) internal view virtual returns (uint256 floatReward) {
    if (amountStakedLong > 0) {
      uint256 accumDeltaLong = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexTo]
      .accumulativeFloatPerSyntheticToken_long -
        accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexFrom]
        .accumulativeFloatPerSyntheticToken_long;
      floatReward += (accumDeltaLong * amountStakedLong) / FLOAT_ISSUANCE_FIXED_DECIMAL;
    }

    if (amountStakedShort > 0) {
      uint256 accumDeltaShort = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexTo]
      .accumulativeFloatPerSyntheticToken_short -
        accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexFrom]
        .accumulativeFloatPerSyntheticToken_short;
      floatReward += (accumDeltaShort * amountStakedShort) / FLOAT_ISSUANCE_FIXED_DECIMAL;
    }
  }

  /** 
  @notice Calculates float owed to the user since the user last minted float for a market.
  @param marketIndex Identifier for the market which the user staked in.
  @param user The address of the user.
  @return floatReward The amount of float owed.
   */
  function _calculateAccumulatedFloat(uint32 marketIndex, address user) internal virtual returns (uint256 floatReward) {
    address longToken = syntheticTokens[marketIndex][true];
    address shortToken = syntheticTokens[marketIndex][false];

    uint256 amountStakedLong = userAmountStaked[longToken][user];
    uint256 amountStakedShort = userAmountStaked[shortToken][user];

    uint256 usersLastRewardIndex = userIndexOfLastClaimedReward[marketIndex][user];

    // Don't do the calculation and return zero immediately if there is no change
    if (usersLastRewardIndex == latestRewardIndex[marketIndex]) {
      return 0;
    }

    uint256 usersShiftIndex = userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][user];
    // if there is a change in the users tokens held due to a token shift (or possibly another action in the future)
    if (usersShiftIndex > 0 && usersShiftIndex < batched_stakerNextTokenShiftIndex[marketIndex]) {
      floatReward = _calculateAccumulatedFloatInRange(
        marketIndex,
        amountStakedLong,
        amountStakedShort,
        usersLastRewardIndex,
        stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[usersShiftIndex]
      );

      // Update the users balances
      if (userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user] > 0) {
        amountStakedShort += ILongShort(longShort).getAmountSyntheticTokenToMintOnTargetSide(
          marketIndex,
          userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user],
          true,
          stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[usersShiftIndex]
        );

        amountStakedLong -= userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user];
        userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user] = 0;
      }

      if (userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user] > 0) {
        amountStakedLong += ILongShort(longShort).getAmountSyntheticTokenToMintOnTargetSide(
          marketIndex,
          userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user],
          false,
          stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[usersShiftIndex]
        );

        amountStakedShort -= userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user];
        userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user] = 0;
      }

      // Save the users updated staked amounts
      userAmountStaked[longToken][user] = amountStakedLong;
      userAmountStaked[shortToken][user] = amountStakedShort;

      floatReward += _calculateAccumulatedFloatInRange(
        marketIndex,
        amountStakedLong,
        amountStakedShort,
        stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[usersShiftIndex],
        latestRewardIndex[marketIndex]
      );

      userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][user] = 0;
    } else {
      floatReward = _calculateAccumulatedFloatInRange(
        marketIndex,
        amountStakedLong,
        amountStakedShort,
        usersLastRewardIndex,
        latestRewardIndex[marketIndex]
      );
    }
  }

  /**
  @notice Mints float for a user.
  @dev Mints a fixed percentage for Float capital.
  @param user The address of the user.
  @param floatToMint The amount of float to mint.
   */
  function _mintFloat(address user, uint256 floatToMint) internal virtual {
    IFloatToken(floatToken).mint(user, floatToMint);
    IFloatToken(floatToken).mint(floatCapital, (floatToMint * floatPercentage) / 1e18);
  }

  /**
  @notice Mints float owed to a user for a market since they last minted.
  @param marketIndex An identifier for the market.
  @param user The address of the user.
   */
  function _mintAccumulatedFloat(uint32 marketIndex, address user) internal virtual {
    uint256 floatToMint = _calculateAccumulatedFloat(marketIndex, user);

    if (floatToMint > 0) {
      // Set the user has claimed up until now, stops them setting this forward
      userIndexOfLastClaimedReward[marketIndex][user] = latestRewardIndex[marketIndex];

      _mintFloat(user, floatToMint);
      emit FloatMinted(user, marketIndex, floatToMint);
    }
  }

  /**
  @notice Mints float owed to a user for multiple markets, since they last minted for those markets.
  @param marketIndexes Identifiers for the markets.
  @param user The address of the user.
   */
  function _mintAccumulatedFloatMulti(uint32[] calldata marketIndexes, address user) internal virtual {
    uint256 floatTotal = 0;
    for (uint256 i = 0; i < marketIndexes.length; i++) {
      uint256 floatToMint = _calculateAccumulatedFloat(marketIndexes[i], user);

      if (floatToMint > 0) {
        // Set the user has claimed up until now, stops them setting this forward
        userIndexOfLastClaimedReward[marketIndexes[i]][user] = latestRewardIndex[marketIndexes[i]];

        floatTotal += floatToMint;

        emit FloatMinted(user, marketIndexes[i], floatToMint);
      }
    }
    if (floatTotal > 0) {
      _mintFloat(user, floatTotal);
    }
  }

  /**
  @notice Mints outstanding float for msg.sender.
  @param marketIndexes Identifiers for the markets for which to mint float.
   */
  function claimFloatCustom(uint32[] calldata marketIndexes) external {
    ILongShort(longShort).updateSystemStateMulti(marketIndexes);
    _mintAccumulatedFloatMulti(marketIndexes, msg.sender);
  }

  /**
  @notice Mints outstanding float on behalf of another user.
  @param marketIndexes Identifiers for the markets for which to mint float.
  @param user The address of the user.
   */
  function claimFloatCustomFor(uint32[] calldata marketIndexes, address user) external {
    // Unbounded loop - users are responsible for paying their own gas costs on these and it doesn't effect the rest of the system.
    // No need to impose limit.
    ILongShort(longShort).updateSystemStateMulti(marketIndexes);
    _mintAccumulatedFloatMulti(marketIndexes, user);
  }

  /*╔═══════════════════════╗
    ║        STAKING        ║
    ╚═══════════════════════╝*/

  /**
  @notice A user with synthetic tokens stakes by calling stake on the token
  contract which calls this function. We need to first update the
  state of the LongShort contract for this market before staking to correctly calculate user rewards.
  @param amount Amount to stake.
  @param from Address to stake for.
  */
  function stakeFromUser(address from, uint256 amount) public virtual override onlyValidSynthetic((msg.sender)) {
    ILongShort(longShort).updateSystemState(marketIndexOfToken[(msg.sender)]);
    _stake((msg.sender), amount, from);
  }

  /**
  @dev Internal logic for staking.
  @param token Address of the token for which to stake.
  @param amount Amount to stake.
  @param user Address to stake for.
  */
  function _stake(
    address token,
    uint256 amount,
    address user
  ) internal virtual {
    uint32 marketIndex = marketIndexOfToken[token];

    // If they already have staked and have rewards due, mint these.
    if (
      userIndexOfLastClaimedReward[marketIndex][user] != 0 &&
      userIndexOfLastClaimedReward[marketIndex][user] < latestRewardIndex[marketIndex]
    ) {
      _mintAccumulatedFloat(marketIndex, user);
    }

    userAmountStaked[token][user] = userAmountStaked[token][user] + amount;

    userIndexOfLastClaimedReward[marketIndex][user] = latestRewardIndex[marketIndex];

    emit StakeAdded(user, address(token), amount, userIndexOfLastClaimedReward[marketIndex][user]);
  }

  /**
  @notice Allows users to shift their staked tokens from one side of the market to 
  the other at the next price.
  @param amountSyntheticTokensToShift Amount of tokens to shift.
  @param marketIndex Identifier for the market.
  @param isShiftFromLong Whether the shift is from long to short or short to long.
  */
  function shiftTokens(
    uint256 amountSyntheticTokensToShift,
    uint32 marketIndex,
    bool isShiftFromLong
  ) external virtual {
    address token = syntheticTokens[marketIndex][isShiftFromLong];
    require(userAmountStaked[token][msg.sender] >= amountSyntheticTokensToShift, "Not enough tokens to shift");

    // If the user has outstanding token shift that have already been confirmed in the LongShort
    // contract, execute them first.
    if (
      userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] != 0 &&
      userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] <
      batched_stakerNextTokenShiftIndex[marketIndex]
    ) {
      _mintAccumulatedFloat(marketIndex, msg.sender);
    }

    if (isShiftFromLong) {
      ILongShort(longShort).shiftPositionFromLongNextPrice(marketIndex, amountSyntheticTokensToShift);
      userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][
        msg.sender
      ] += amountSyntheticTokensToShift;
    } else {
      ILongShort(longShort).shiftPositionFromShortNextPrice(marketIndex, amountSyntheticTokensToShift);
      userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][
        msg.sender
      ] += amountSyntheticTokensToShift;
    }

    userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] = batched_stakerNextTokenShiftIndex[
      marketIndex
    ];
  }

  /*╔════════════════════════════╗
    ║    WITHDRAWAL & MINTING    ║
    ╚════════════════════════════╝*/

  /**
  @notice Internal logic for withdrawing stakes.
  @dev Mint user any outstanding float before withdrawing.
  @param marketIndex Market index of token.
  @param amount Amount to withdraw.
  @param token Synthetic token that was staked.
  */
  function _withdraw(
    uint32 marketIndex,
    address token,
    uint256 amount
  ) internal virtual {
    require(userAmountStaked[token][msg.sender] > 0, "nothing to withdraw");
    _mintAccumulatedFloat(marketIndex, msg.sender);

    userAmountStaked[token][msg.sender] = userAmountStaked[token][msg.sender] - amount;

    uint256 amountFees = (amount * marketUnstakeFee_e18[marketIndex]) / 1e18;

    IERC20(token).transfer(floatTreasury, amountFees);
    IERC20(token).transfer(msg.sender, amount - amountFees);

    emit StakeWithdrawn(msg.sender, token, amount);
  }

  /**
  @notice Withdraw function. Allows users to unstake.
  @param amount Amount to withdraw.
  @param token Address of the token for which to withdraw.
  */
  function withdraw(address token, uint256 amount) external {
    ILongShort(longShort).updateSystemState(marketIndexOfToken[token]);

    uint32 marketIndex = marketIndexOfToken[token];

    _withdraw(marketIndex, token, amount);

    if (userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] > 0) {
      // If they still have outstanding shifts after minting float, then check
      // that they don't withdraw more than their shifts allow.
      uint256 amountToShiftForThisToken = syntheticTokens[marketIndex][true] == token
        ? userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][msg.sender]
        : userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][msg.sender];

      require(
        userAmountStaked[token][msg.sender] >= amountToShiftForThisToken,
        "Outstanding next price stake shifts too great"
      );
    }
  }

  /**
  @notice Allows users to withdraw their entire stake for a token.
  @param token Address of the token for which to withdraw.
  */
  function withdrawAll(address token) external {
    ILongShort(longShort).updateSystemState(marketIndexOfToken[token]);

    uint32 marketIndex = marketIndexOfToken[token];

    uint256 amountToShiftForThisToken = syntheticTokens[marketIndex][true] == token
      ? userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][msg.sender]
      : userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][msg.sender];

    _withdraw(marketIndex, token, userAmountStaked[token][msg.sender] - amountToShiftForThisToken);
  }
}
.]

Below are the details of our smart contract codes and their corresponding analysis reports:
Task: "".
As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report.

[2024-17-08 08:01:54 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-17-08 08:01:54 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 9868
completion_tokens: 720
total_tokens: 10588
cost: $-1.000000


[2024-17-08 08:01:54 INFO] Solidity Programming Expert: **Solidity Programming Expert<->Security Analyst on : BugsSummary, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: BUSL-1.1

pragma solidity 0.8.3;

import "@openzeppelin/contracts-upgradeable/token/ERC20/presets/ERC20PresetMinterPauserUpgradeable.sol";

import "./interfaces/IFloatToken.sol";
import "./interfaces/ILongShort.sol";
import "./interfaces/IStaker.sol";
import "./interfaces/ISyntheticToken.sol";

contract Staker is IStaker, Initializable {
  /*╔═════════════════════════════╗
    ║          VARIABLES          ║
    ╚═════════════════════════════╝*/

  /* ══════ Fixed-precision constants ══════ */
  uint256 public constant FLOAT_ISSUANCE_FIXED_DECIMAL = 1e42;
  // 2^52 ~= 4.5e15
  // With an exponent of 5, the largest total liquidity possible in a market (to avoid integer overflow on exponentiation) is ~10^31 or 10 Trillion (10^13)
  // NOTE: this also means if the total market value is less than 2^52 there will be a division by zero error
  uint256 public constant safeExponentBitShifting = 52;

  /* ══════ Global state ══════ */
  address public admin;
  address public floatCapital;
  address public floatTreasury;
  uint256 public floatPercentage;

  address public longShort;
  address public floatToken;

  /* ══════ Market specific ══════ */
  mapping(uint32 => uint256) public marketLaunchIncentive_period; // seconds
  mapping(uint32 => uint256) public marketLaunchIncentive_multipliers; // e18 scale
  mapping(uint32 => uint256) public marketUnstakeFee_e18;
  mapping(uint32 => uint256) public balanceIncentiveCurve_exponent;
  mapping(uint32 => int256) public balanceIncentiveCurve_equilibriumOffset;

  mapping(uint32 => mapping(bool => address)) public syntheticTokens;

  mapping(address => uint32) public marketIndexOfToken;

  /* ══════ Reward specific ══════ */
  mapping(uint32 => uint256) public latestRewardIndex;
  mapping(uint32 => mapping(uint256 => AccumulativeIssuancePerStakedSynthSnapshot))
    public accumulativeFloatPerSyntheticTokenSnapshots;
  struct AccumulativeIssuancePerStakedSynthSnapshot {
    uint256 timestamp;
    uint256 accumulativeFloatPerSyntheticToken_long;
    uint256 accumulativeFloatPerSyntheticToken_short;
  }

  /* ══════ User specific ══════ */
  mapping(uint32 => mapping(address => uint256)) public userIndexOfLastClaimedReward;
  mapping(address => mapping(address => uint256)) public userAmountStaked;

  /* ══════ Token shift management specific ══════ */
  mapping(uint32 => uint256) public batched_stakerNextTokenShiftIndex;
  /**
  @notice Used to link a token shift to a staker state
  @dev tokenShiftIndex => accumulativeFloatIssuanceSnapshotIndex
    POSSIBLE OPTIMIZATION - could pack stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping and stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping into a struct of two uint128 for storage space optimization.
  */
  mapping(uint256 => uint256) public stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping;
  /// @notice Used to fetch the price from LongShort at that point in time
  /// @dev tokenShiftIndex => longShortMarketPriceSnapshotIndex
  mapping(uint256 => uint256) public stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping;
  /// @dev marketIndex => usersAddress => stakerTokenShiftIndex
  mapping(uint32 => mapping(address => uint256)) public userNextPrice_stakedSyntheticTokenShiftIndex;
  /// @dev marketIndex => usersAddress => amountUserRequestedToShiftAwayFromLongOnNextUpdate
  mapping(uint32 => mapping(address => uint256)) public userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long;
  /// @dev marketIndex => usersAddress => amountUserRequestedToShiftAwayFromShortOnNextUpdate
  mapping(uint32 => mapping(address => uint256)) public userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short;

  /*╔════════════════════════════╗
    ║           EVENTS           ║
    ╚════════════════════════════╝*/

  event StakerV1(
    address admin,
    address floatTreasury,
    address floatCapital,
    address floatToken,
    uint256 floatPercentage
  );

  event MarketAddedToStaker(
    uint32 marketIndex,
    uint256 exitFee_e18,
    uint256 period,
    uint256 multiplier,
    uint256 balanceIncentiveExponent,
    int256 balanceIncentiveEquilibriumOffset
  );

  event AccumulativeIssuancePerStakedSynthSnapshotCreated(
    uint32 marketIndex,
    uint256 accumulativeFloatIssuanceSnapshotIndex,
    uint256 accumulativeLong,
    uint256 accumulativeShort
  );

  event StakeAdded(address user, address token, uint256 amount, uint256 lastMintIndex);

  event StakeWithdrawn(address user, address token, uint256 amount);

  // Note: the `amountFloatMinted` isn't strictly needed by the graph, but it is good to add it to validate calculations are accurate.
  event FloatMinted(address user, uint32 marketIndex, uint256 amountFloatMinted);

  event MarketLaunchIncentiveParametersChanges(uint32 marketIndex, uint256 period, uint256 multiplier);

  event StakeWithdrawalFeeUpdated(uint32 marketIndex, uint256 stakeWithdralFee);

  event BalanceIncentiveExponentUpdated(uint32 marketIndex, uint256 balanceIncentiveExponent);

  event BalanceIncentiveEquilibriumOffsetUpdated(uint32 marketIndex, int256 balanceIncentiveEquilibriumOffset);

  event FloatPercentageUpdated(uint256 floatPercentage);

  event SyntheticTokensShifted();

  event ChangeAdmin(address newAdmin);

  /*╔═════════════════════════════╗
    ║          MODIFIERS          ║
    ╚═════════════════════════════╝*/

  function onlyAdminModifierLogic() internal virtual {
    require(msg.sender == admin, "not admin");
  }

  modifier onlyAdmin() {
    onlyAdminModifierLogic();
    _;
  }

  function onlyValidSyntheticModifierLogic(address _synth) internal virtual {
    require(marketIndexOfToken[_synth] != 0, "not valid synth");
  }

  modifier onlyValidSynthetic(address _synth) {
    onlyValidSyntheticModifierLogic(_synth);
    _;
  }

  function onlyValidMarketModifierLogic(uint32 marketIndex) internal virtual {
    require(address(syntheticTokens[marketIndex][true]) != address(0), "not valid market");
  }

  modifier onlyValidMarket(uint32 marketIndex) {
    onlyValidMarketModifierLogic(marketIndex);
    _;
  }

  function onlyLongShortModifierLogic() internal virtual {
    require(msg.sender == address(longShort), "not long short");
  }

  modifier onlyLongShort() {
    onlyLongShortModifierLogic();
    _;
  }

  /*╔═════════════════════════════╗
    ║       CONTRACT SET-UP       ║
    ╚═════════════════════════════╝*/

  /**
  @notice Initializes the contract.
  @dev Calls OpenZeppelin's initializer modifier.
  @param _admin Address of the admin role.
  @param _longShort Address of the LongShort contract, a deployed LongShort.sol
  @param _floatToken Address of the Float token earned by staking.
  @param _floatTreasury Address of the treasury contract for managing fees.
  @param _floatCapital Address of the contract which earns a fixed percentage of Float.
  @param _floatPercentage Determines the float percentage that gets minted for Float Capital, base 1e18.
  */
  function initialize(
    address _admin,
    address _longShort,
    address _floatToken,
    address _floatTreasury,
    address _floatCapital,
    uint256 _floatPercentage
  ) external virtual initializer {
    admin = _admin;
    floatCapital = _floatCapital;
    floatTreasury = _floatTreasury;
    longShort = _longShort;
    floatToken = _floatToken;

    _changeFloatPercentage(_floatPercentage);

    emit StakerV1(_admin, _floatTreasury, _floatCapital, _floatToken, _floatPercentage);
  }

  /*╔═══════════════════╗
    ║       ADMIN       ║
    ╚═══════════════════╝*/

  /** 
  @notice Changes admin for the contract
  @param _admin The address of the new admin.
  */
  function changeAdmin(address _admin) external onlyAdmin {
    admin = _admin;
    emit ChangeAdmin(_admin);
  }

  /// @dev Logic for changeFloatPercentage
  function _changeFloatPercentage(uint256 newFloatPercentage) internal virtual {
    require(newFloatPercentage <= 1e18 && newFloatPercentage > 0); // less than or equal to 100% and greater than 0%
    floatPercentage = newFloatPercentage;
  }

  /**
  @notice Changes percentage of float that is minted for float capital.
  @param newFloatPercentage The new float percentage in base 1e18.
  */
  function changeFloatPercentage(uint256 newFloatPercentage) external onlyAdmin {
    _changeFloatPercentage(newFloatPercentage);
    emit FloatPercentageUpdated(newFloatPercentage);
  }

  /// @dev Logic for changeUnstakeFee
  function _changeUnstakeFee(uint32 marketIndex, uint256 newMarketUnstakeFee_e18) internal virtual {
    require(newMarketUnstakeFee_e18 <= 5e16); // Explicitely stating 5% fee as the max fee possible.
    marketUnstakeFee_e18[marketIndex] = newMarketUnstakeFee_e18;
  }

  /**
  @notice Changes unstake fee for a market
  @param marketIndex Identifies the market.
  @param newMarketUnstakeFee_e18 The new unstake fee.
  */
  function changeUnstakeFee(uint32 marketIndex, uint256 newMarketUnstakeFee_e18) external onlyAdmin {
    _changeUnstakeFee(marketIndex, newMarketUnstakeFee_e18);
    emit StakeWithdrawalFeeUpdated(marketIndex, newMarketUnstakeFee_e18);
  }

  /// @dev Logic for changeMarketLaunchIncentiveParameters
  function _changeMarketLaunchIncentiveParameters(
    uint32 marketIndex,
    uint256 period,
    uint256 initialMultiplier
  ) internal virtual {
    require(initialMultiplier >= 1e18, "marketLaunchIncentiveMultiplier must be >= 1e18");

    marketLaunchIncentive_period[marketIndex] = period;
    marketLaunchIncentive_multipliers[marketIndex] = initialMultiplier;
  }

  /**
  @notice Changes the market launch incentive parameters for a market
  @param marketIndex Identifies the market.
  @param period The new period for which float token generation should be boosted.
  @param initialMultiplier The new multiplier on Float generation.
  */
  function changeMarketLaunchIncentiveParameters(
    uint32 marketIndex,
    uint256 period,
    uint256 initialMultiplier
  ) external onlyAdmin {
    _changeMarketLaunchIncentiveParameters(marketIndex, period, initialMultiplier);

    emit MarketLaunchIncentiveParametersChanges(marketIndex, period, initialMultiplier);
  }

  /// @dev Logic for changeBalanceIncentiveExponent
  function _changeBalanceIncentiveExponent(uint32 marketIndex, uint256 _balanceIncentiveCurve_exponent)
    internal
    virtual
  {
    require(
      // The exponent has to be less than 5 in these versions of the contracts.
      _balanceIncentiveCurve_exponent > 0 && _balanceIncentiveCurve_exponent < 6,
      "balanceIncentiveCurve_exponent out of bounds"
    );

    balanceIncentiveCurve_exponent[marketIndex] = _balanceIncentiveCurve_exponent;
  }

  /** 
  @notice Changes the balance incentive exponent for a market
  @param marketIndex Identifies the market.
  @param _balanceIncentiveCurve_exponent The new exponent for the curve.
  */
  function changeBalanceIncentiveExponent(uint32 marketIndex, uint256 _balanceIncentiveCurve_exponent)
    external
    onlyAdmin
  {
    _changeBalanceIncentiveExponent(marketIndex, _balanceIncentiveCurve_exponent);

    emit BalanceIncentiveExponentUpdated(marketIndex, _balanceIncentiveCurve_exponent);
  }

  /// @dev Logic for changeBalanceIncentiveEquilibriumOffset
  function _changeBalanceIncentiveEquilibriumOffset(uint32 marketIndex, int256 _balanceIncentiveCurve_equilibriumOffset)
    internal
    virtual
  {
    // Unreasonable that we would ever shift this more than 90% either way
    require(
      _balanceIncentiveCurve_equilibriumOffset > -9e17 && _balanceIncentiveCurve_equilibriumOffset < 9e17,
      "balanceIncentiveCurve_equilibriumOffset out of bounds"
    );

    balanceIncentiveCurve_equilibriumOffset[marketIndex] = _balanceIncentiveCurve_equilibriumOffset;
  }

  /**
  @notice Changes the balance incentive curve equilibrium offset for a market
  @param marketIndex Identifies the market.
  @param _balanceIncentiveCurve_equilibriumOffset The new offset.
  */
  function changeBalanceIncentiveEquilibriumOffset(uint32 marketIndex, int256 _balanceIncentiveCurve_equilibriumOffset)
    external
    onlyAdmin
  {
    _changeBalanceIncentiveEquilibriumOffset(marketIndex, _balanceIncentiveCurve_equilibriumOffset);

    emit BalanceIncentiveEquilibriumOffsetUpdated(marketIndex, _balanceIncentiveCurve_equilibriumOffset);
  }

  /*╔═════════════════════════════╗
    ║        STAKING SETUP        ║
    ╚═════════════════════════════╝*/

  /**
  @notice Sets this contract to track staking for a market in LongShort.sol
  @param marketIndex Identifies the market.
  @param longToken Address of the long token for the market.
  @param shortToken Address of the short token for the market.
  @param kInitialMultiplier Initial boost on float generation for the market.
  @param kPeriod Period which the boost should last.
  @param unstakeFee_e18 Percentage of tokens that are levied on unstaking in base 1e18.
  @param _balanceIncentiveCurve_exponent Exponent for balance curve (see _calculateFloatPerSecond)
  @param _balanceIncentiveCurve_equilibriumOffset Offset for balance curve (see _calculateFloatPerSecond)
  */
  function addNewStakingFund(
    uint32 marketIndex,
    address longToken,
    address shortToken,
    uint256 kInitialMultiplier,
    uint256 kPeriod,
    uint256 unstakeFee_e18,
    uint256 _balanceIncentiveCurve_exponent,
    int256 _balanceIncentiveCurve_equilibriumOffset
  ) external override onlyLongShort {
    marketIndexOfToken[longToken] = marketIndex;
    marketIndexOfToken[shortToken] = marketIndex;

    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].timestamp = block.timestamp;
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].accumulativeFloatPerSyntheticToken_long = 0;
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].accumulativeFloatPerSyntheticToken_short = 0;

    syntheticTokens[marketIndex][true] = longToken;
    syntheticTokens[marketIndex][false] = shortToken;

    _changeBalanceIncentiveExponent(marketIndex, _balanceIncentiveCurve_exponent);
    _changeBalanceIncentiveEquilibriumOffset(marketIndex, _balanceIncentiveCurve_equilibriumOffset);
    _changeMarketLaunchIncentiveParameters(marketIndex, kPeriod, kInitialMultiplier);

    _changeUnstakeFee(marketIndex, unstakeFee_e18);

    // Set this value to one initially - 0 is a null value and thus potentially bug prone.
    batched_stakerNextTokenShiftIndex[marketIndex] = 1;

    emit MarketAddedToStaker(
      marketIndex,
      unstakeFee_e18,
      kPeriod,
      kInitialMultiplier,
      _balanceIncentiveCurve_exponent,
      _balanceIncentiveCurve_equilibriumOffset
    );

    emit AccumulativeIssuancePerStakedSynthSnapshotCreated(marketIndex, 0, 0, 0);
  }

  /*╔═════════════════════════════════════════════════════════════════════════╗
    ║    GLOBAL FLT REWARD ACCUMULATION CALCULATION AND TRACKING FUNCTIONS    ║
    ╚═════════════════════════════════════════════════════════════════════════╝*/

  /**
  @notice Returns the K factor parameters for the given market with sensible
  defaults if they haven't been set yet.
  @param marketIndex The market to change the parameters for.
  @return period The period for which the k factor applies for in seconds.
  @return multiplier The multiplier on Float generation in this period.
  */
  function _getMarketLaunchIncentiveParameters(uint32 marketIndex)
    internal
    view
    virtual
    returns (uint256 period, uint256 multiplier)
  {
    period = marketLaunchIncentive_period[marketIndex];
    multiplier = marketLaunchIncentive_multipliers[marketIndex];

    if (multiplier < 1e18) {
      multiplier = 1e18; // multiplier of 1 by default
    }
  }

  /** 
  @notice Returns the extent to which a markets float generation should be adjusted
  based on the market's launch incentive parameters. Should start at multiplier
  then linearly change to 1e18 over time.
  @param marketIndex Identifies the market.
  @return k The calculated modifier for float generation.
  */
  function _getKValue(uint32 marketIndex) internal view virtual returns (uint256) {
    // Parameters controlling the float issuance multiplier.
    (uint256 kPeriod, uint256 kInitialMultiplier) = _getMarketLaunchIncentiveParameters(marketIndex);

    // Sanity check - under normal circumstances, the multipliers should
    // *never* be set to a value < 1e18, as there are guards against this.
    assert(kInitialMultiplier >= 1e18);

    uint256 initialTimestamp = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].timestamp;

    if (block.timestamp - initialTimestamp <= kPeriod) {
      return kInitialMultiplier - (((kInitialMultiplier - 1e18) * (block.timestamp - initialTimestamp)) / kPeriod);
    } else {
      return 1e18;
    }
  }

  /*
  @notice Computes the number of float tokens a user earns per second for
  every long/short synthetic token they've staked. The returned value has
  a fixed decimal scale of 1e42 (!!!) for numerical stability. The return
  values are float per second per synthetic token (hence the requirement
  to multiply by price)
  @dev to see below math in latex form see TODO add link
  to interact with the equations see https://www.desmos.com/calculator/optkaxyihr
  @param marketIndex The market referred to.
  @param longPrice Price of the synthetic long token in units of payment token
  @param shortPrice Price of the synthetic short token in units of payment token
  @param longValue Amount of payment token in the long side of the market
  @param shortValue Amount of payment token in the short side of the market
  @return longFloatPerSecond Float token per second per long synthetic token
  @return shortFloatPerSecond Float token per second per short synthetic token
   */
  function _calculateFloatPerSecond(
    uint32 marketIndex,
    uint256 longPrice,
    uint256 shortPrice,
    uint256 longValue,
    uint256 shortValue
  ) internal view virtual returns (uint256 longFloatPerSecond, uint256 shortFloatPerSecond) {
    // A float issuance multiplier that starts high and decreases linearly
    // over time to a value of 1. This incentivises users to stake early.
    uint256 k = _getKValue(marketIndex);

    uint256 totalLocked = (longValue + shortValue);

    // we need to scale this number by the totalLocked so that the offset remains consistent accross market size

    int256 equilibriumOffsetMarketScaled = (balanceIncentiveCurve_equilibriumOffset[marketIndex] *
      int256(totalLocked)) / 2e18;

    uint256 denominator = ((totalLocked >> safeExponentBitShifting)**balanceIncentiveCurve_exponent[marketIndex]);

    // Float is scaled by the percentage of the total market value held in
    // the opposite position. This incentivises users to stake on the
    // weaker position.
    if (int256(shortValue) - equilibriumOffsetMarketScaled < int256(longValue)) {
      if (equilibriumOffsetMarketScaled >= int256(shortValue)) {
        // edge case: imbalanced far past the equilibrium offset - full rewards go to short token
        //            extremeley unlikely to happen in practice
        return (0, 1e18 * k * shortPrice);
      }

      uint256 numerator = (uint256(int256(shortValue) - equilibriumOffsetMarketScaled) >>
        (safeExponentBitShifting - 1))**balanceIncentiveCurve_exponent[marketIndex];

      // NOTE: `x * 5e17` == `(x * 10e18) / 2`
      uint256 longRewardUnscaled = (numerator * 5e17) / denominator;
      uint256 shortRewardUnscaled = 1e18 - longRewardUnscaled;

      return ((longRewardUnscaled * k * longPrice) / 1e18, (shortRewardUnscaled * k * shortPrice) / 1e18);
    } else {
      if (-equilibriumOffsetMarketScaled >= int256(longValue)) {
        // edge case: imbalanced far past the equilibrium offset - full rewards go to long token
        //            extremeley unlikely to happen in practice
        return (1e18 * k * longPrice, 0);
      }

      uint256 numerator = (uint256(int256(longValue) + equilibriumOffsetMarketScaled) >>
        (safeExponentBitShifting - 1))**balanceIncentiveCurve_exponent[marketIndex];

      // NOTE: `x * 5e17` == `(x * 10e18) / 2`
      uint256 shortRewardUnscaled = (numerator * 5e17) / denominator;
      uint256 longRewardUnscaled = 1e18 - shortRewardUnscaled;

      return ((longRewardUnscaled * k * longPrice) / 1e18, (shortRewardUnscaled * k * shortPrice) / 1e18);
    }
  }

  /**
  @notice Computes the time since last accumulativeIssuancePerStakedSynthSnapshot for the given market in seconds.
  @param marketIndex The market referred to.
  @return The time difference in seconds
  */
  function _calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(uint32 marketIndex)
    internal
    view
    virtual
    returns (uint256)
  {
    return
      block.timestamp -
      accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]].timestamp;
  }

  /**
  @notice Computes new cumulative sum of 'r' value since last accumulativeIssuancePerStakedSynthSnapshot. We use
  cumulative 'r' value to avoid looping during issuance. Note that the
  cumulative sum is kept in 1e42 scale (!!!) to avoid numerical issues.
  @param shortValue The value locked in the short side of the market.
  @param longValue The value locked in the long side of the market.
  @param shortPrice The price of the short token as defined in LongShort.sol
  @param longPrice The price of the long token as defined in LongShort.sol
  @param marketIndex An identifier for the market.
  @return longCumulativeRates The long cumulative sum.
  @return shortCumulativeRates The short cumulative sum.
  */
  function _calculateNewCumulativeIssuancePerStakedSynth(
    uint32 marketIndex,
    uint256 longPrice,
    uint256 shortPrice,
    uint256 longValue,
    uint256 shortValue
  ) internal view virtual returns (uint256 longCumulativeRates, uint256 shortCumulativeRates) {
    // Compute the current 'r' value for float issuance per second.
    (uint256 longFloatPerSecond, uint256 shortFloatPerSecond) = _calculateFloatPerSecond(
      marketIndex,
      longPrice,
      shortPrice,
      longValue,
      shortValue
    );

    // Compute time since last accumulativeIssuancePerStakedSynthSnapshot for the given token.
    uint256 timeDelta = _calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(marketIndex);

    // Compute new cumulative 'r' value total.
    return (
      accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]]
      .accumulativeFloatPerSyntheticToken_long + (timeDelta * longFloatPerSecond),
      accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]]
      .accumulativeFloatPerSyntheticToken_short + (timeDelta * shortFloatPerSecond)
    );
  }

  /**
  @notice Creates a new accumulativeIssuancePerStakedSynthSnapshot for the given token and updates indexes.
  @param shortValue The value locked in the short side of the market.
  @param longValue The value locked in the long side of the market.
  @param shortPrice The price of the short token as defined in LongShort.sol
  @param longPrice The price of the long token as defined in LongShort.sol
  @param marketIndex An identifier for the market.
  */
  function _setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot(
    uint32 marketIndex,
    uint256 longPrice,
    uint256 shortPrice,
    uint256 longValue,
    uint256 shortValue
  ) internal virtual {
    (
      uint256 newLongAccumulativeValue,
      uint256 newShortAccumulativeValue
    ) = _calculateNewCumulativeIssuancePerStakedSynth(marketIndex, longPrice, shortPrice, longValue, shortValue);

    uint256 newIndex = latestRewardIndex[marketIndex] + 1;

    // Set cumulative 'r' value on new accumulativeIssuancePerStakedSynthSnapshot.
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex]
    .accumulativeFloatPerSyntheticToken_long = newLongAccumulativeValue;
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex]
    .accumulativeFloatPerSyntheticToken_short = newShortAccumulativeValue;

    // Set timestamp on new accumulativeIssuancePerStakedSynthSnapshot.
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex].timestamp = block.timestamp;

    // Update latest index to point to new accumulativeIssuancePerStakedSynthSnapshot.
    latestRewardIndex[marketIndex] = newIndex;

    emit AccumulativeIssuancePerStakedSynthSnapshotCreated(
      marketIndex,
      newIndex,
      newLongAccumulativeValue,
      newShortAccumulativeValue
    );
  }

  /**
  @notice Adds new accumulativeIssuancePerStakedSynthSnapshots for the given long/short tokens. Called by the
  ILongShort contract whenever there is a state change for a market.
  @param stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted Mapping from this contract's shifts to LongShort.sols next price snapshots.
  @param shortValue The value locked in the short side of the market.
  @param longValue The value locked in the long side of the market.
  @param shortPrice The price of the short token as defined in LongShort.sol
  @param longPrice The price of the long token as defined in LongShort.sol
  @param marketIndex An identifier for the market.
  */
  function pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(
    uint32 marketIndex,
    uint256 longPrice,
    uint256 shortPrice,
    uint256 longValue,
    uint256 shortValue,
    uint256 stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted // This value should be ALWAYS be zero if no shift occured
  ) external override onlyLongShort {
    // Only add a new accumulativeIssuancePerStakedSynthSnapshot if some time has passed.

    // the `stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted` value will be 0 if there is no staker related action in an executed batch
    if (stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted > 0) {
      stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[
        batched_stakerNextTokenShiftIndex[marketIndex]
      ] = stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted;
      stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[
        batched_stakerNextTokenShiftIndex[marketIndex]
      ] = latestRewardIndex[marketIndex] + 1;
      batched_stakerNextTokenShiftIndex[marketIndex] += 1;

      emit SyntheticTokensShifted();
    }

    // Time delta is fetched twice in below code, can pass through? Which is less gas?
    if (_calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(marketIndex) > 0) {
      _setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot(
        marketIndex,
        longPrice,
        shortPrice,
        longValue,
        shortValue
      );
    }
  }

  /*╔═══════════════════════════════════╗
    ║    USER REWARD STATE FUNCTIONS    ║
    ╚═══════════════════════════════════╝*/

  /// @dev Calculates the accumulated float in a specific range of staker snapshots
  function _calculateAccumulatedFloatInRange(
    uint32 marketIndex,
    uint256 amountStakedLong,
    uint256 amountStakedShort,
    uint256 rewardIndexFrom,
    uint256 rewardIndexTo
  ) internal view virtual returns (uint256 floatReward) {
    if (amountStakedLong > 0) {
      uint256 accumDeltaLong = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexTo]
      .accumulativeFloatPerSyntheticToken_long -
        accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexFrom]
        .accumulativeFloatPerSyntheticToken_long;
      floatReward += (accumDeltaLong * amountStakedLong) / FLOAT_ISSUANCE_FIXED_DECIMAL;
    }

    if (amountStakedShort > 0) {
      uint256 accumDeltaShort = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexTo]
      .accumulativeFloatPerSyntheticToken_short -
        accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexFrom]
        .accumulativeFloatPerSyntheticToken_short;
      floatReward += (accumDeltaShort * amountStakedShort) / FLOAT_ISSUANCE_FIXED_DECIMAL;
    }
  }

  /** 
  @notice Calculates float owed to the user since the user last minted float for a market.
  @param marketIndex Identifier for the market which the user staked in.
  @param user The address of the user.
  @return floatReward The amount of float owed.
   */
  function _calculateAccumulatedFloat(uint32 marketIndex, address user) internal virtual returns (uint256 floatReward) {
    address longToken = syntheticTokens[marketIndex][true];
    address shortToken = syntheticTokens[marketIndex][false];

    uint256 amountStakedLong = userAmountStaked[longToken][user];
    uint256 amountStakedShort = userAmountStaked[shortToken][user];

    uint256 usersLastRewardIndex = userIndexOfLastClaimedReward[marketIndex][user];

    // Don't do the calculation and return zero immediately if there is no change
    if (usersLastRewardIndex == latestRewardIndex[marketIndex]) {
      return 0;
    }

    uint256 usersShiftIndex = userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][user];
    // if there is a change in the users tokens held due to a token shift (or possibly another action in the future)
    if (usersShiftIndex > 0 && usersShiftIndex < batched_stakerNextTokenShiftIndex[marketIndex]) {
      floatReward = _calculateAccumulatedFloatInRange(
        marketIndex,
        amountStakedLong,
        amountStakedShort,
        usersLastRewardIndex,
        stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[usersShiftIndex]
      );

      // Update the users balances
      if (userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user] > 0) {
        amountStakedShort += ILongShort(longShort).getAmountSyntheticTokenToMintOnTargetSide(
          marketIndex,
          userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user],
          true,
          stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[usersShiftIndex]
        );

        amountStakedLong -= userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user];
        userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user] = 0;
      }

      if (userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user] > 0) {
        amountStakedLong += ILongShort(longShort).getAmountSyntheticTokenToMintOnTargetSide(
          marketIndex,
          userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user],
          false,
          stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[usersShiftIndex]
        );

        amountStakedShort -= userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user];
        userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user] = 0;
      }

      // Save the users updated staked amounts
      userAmountStaked[longToken][user] = amountStakedLong;
      userAmountStaked[shortToken][user] = amountStakedShort;

      floatReward += _calculateAccumulatedFloatInRange(
        marketIndex,
        amountStakedLong,
        amountStakedShort,
        stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[usersShiftIndex],
        latestRewardIndex[marketIndex]
      );

      userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][user] = 0;
    } else {
      floatReward = _calculateAccumulatedFloatInRange(
        marketIndex,
        amountStakedLong,
        amountStakedShort,
        usersLastRewardIndex,
        latestRewardIndex[marketIndex]
      );
    }
  }

  /**
  @notice Mints float for a user.
  @dev Mints a fixed percentage for Float capital.
  @param user The address of the user.
  @param floatToMint The amount of float to mint.
   */
  function _mintFloat(address user, uint256 floatToMint) internal virtual {
    IFloatToken(floatToken).mint(user, floatToMint);
    IFloatToken(floatToken).mint(floatCapital, (floatToMint * floatPercentage) / 1e18);
  }

  /**
  @notice Mints float owed to a user for a market since they last minted.
  @param marketIndex An identifier for the market.
  @param user The address of the user.
   */
  function _mintAccumulatedFloat(uint32 marketIndex, address user) internal virtual {
    uint256 floatToMint = _calculateAccumulatedFloat(marketIndex, user);

    if (floatToMint > 0) {
      // Set the user has claimed up until now, stops them setting this forward
      userIndexOfLastClaimedReward[marketIndex][user] = latestRewardIndex[marketIndex];

      _mintFloat(user, floatToMint);
      emit FloatMinted(user, marketIndex, floatToMint);
    }
  }

  /**
  @notice Mints float owed to a user for multiple markets, since they last minted for those markets.
  @param marketIndexes Identifiers for the markets.
  @param user The address of the user.
   */
  function _mintAccumulatedFloatMulti(uint32[] calldata marketIndexes, address user) internal virtual {
    uint256 floatTotal = 0;
    for (uint256 i = 0; i < marketIndexes.length; i++) {
      uint256 floatToMint = _calculateAccumulatedFloat(marketIndexes[i], user);

      if (floatToMint > 0) {
        // Set the user has claimed up until now, stops them setting this forward
        userIndexOfLastClaimedReward[marketIndexes[i]][user] = latestRewardIndex[marketIndexes[i]];

        floatTotal += floatToMint;

        emit FloatMinted(user, marketIndexes[i], floatToMint);
      }
    }
    if (floatTotal > 0) {
      _mintFloat(user, floatTotal);
    }
  }

  /**
  @notice Mints outstanding float for msg.sender.
  @param marketIndexes Identifiers for the markets for which to mint float.
   */
  function claimFloatCustom(uint32[] calldata marketIndexes) external {
    ILongShort(longShort).updateSystemStateMulti(marketIndexes);
    _mintAccumulatedFloatMulti(marketIndexes, msg.sender);
  }

  /**
  @notice Mints outstanding float on behalf of another user.
  @param marketIndexes Identifiers for the markets for which to mint float.
  @param user The address of the user.
   */
  function claimFloatCustomFor(uint32[] calldata marketIndexes, address user) external {
    // Unbounded loop - users are responsible for paying their own gas costs on these and it doesn't effect the rest of the system.
    // No need to impose limit.
    ILongShort(longShort).updateSystemStateMulti(marketIndexes);
    _mintAccumulatedFloatMulti(marketIndexes, user);
  }

  /*╔═══════════════════════╗
    ║        STAKING        ║
    ╚═══════════════════════╝*/

  /**
  @notice A user with synthetic tokens stakes by calling stake on the token
  contract which calls this function. We need to first update the
  state of the LongShort contract for this market before staking to correctly calculate user rewards.
  @param amount Amount to stake.
  @param from Address to stake for.
  */
  function stakeFromUser(address from, uint256 amount) public virtual override onlyValidSynthetic((msg.sender)) {
    ILongShort(longShort).updateSystemState(marketIndexOfToken[(msg.sender)]);
    _stake((msg.sender), amount, from);
  }

  /**
  @dev Internal logic for staking.
  @param token Address of the token for which to stake.
  @param amount Amount to stake.
  @param user Address to stake for.
  */
  function _stake(
    address token,
    uint256 amount,
    address user
  ) internal virtual {
    uint32 marketIndex = marketIndexOfToken[token];

    // If they already have staked and have rewards due, mint these.
    if (
      userIndexOfLastClaimedReward[marketIndex][user] != 0 &&
      userIndexOfLastClaimedReward[marketIndex][user] < latestRewardIndex[marketIndex]
    ) {
      _mintAccumulatedFloat(marketIndex, user);
    }

    userAmountStaked[token][user] = userAmountStaked[token][user] + amount;

    userIndexOfLastClaimedReward[marketIndex][user] = latestRewardIndex[marketIndex];

    emit StakeAdded(user, address(token), amount, userIndexOfLastClaimedReward[marketIndex][user]);
  }

  /**
  @notice Allows users to shift their staked tokens from one side of the market to 
  the other at the next price.
  @param amountSyntheticTokensToShift Amount of tokens to shift.
  @param marketIndex Identifier for the market.
  @param isShiftFromLong Whether the shift is from long to short or short to long.
  */
  function shiftTokens(
    uint256 amountSyntheticTokensToShift,
    uint32 marketIndex,
    bool isShiftFromLong
  ) external virtual {
    address token = syntheticTokens[marketIndex][isShiftFromLong];
    require(userAmountStaked[token][msg.sender] >= amountSyntheticTokensToShift, "Not enough tokens to shift");

    // If the user has outstanding token shift that have already been confirmed in the LongShort
    // contract, execute them first.
    if (
      userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] != 0 &&
      userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] <
      batched_stakerNextTokenShiftIndex[marketIndex]
    ) {
      _mintAccumulatedFloat(marketIndex, msg.sender);
    }

    if (isShiftFromLong) {
      ILongShort(longShort).shiftPositionFromLongNextPrice(marketIndex, amountSyntheticTokensToShift);
      userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][
        msg.sender
      ] += amountSyntheticTokensToShift;
    } else {
      ILongShort(longShort).shiftPositionFromShortNextPrice(marketIndex, amountSyntheticTokensToShift);
      userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][
        msg.sender
      ] += amountSyntheticTokensToShift;
    }

    userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] = batched_stakerNextTokenShiftIndex[
      marketIndex
    ];
  }

  /*╔════════════════════════════╗
    ║    WITHDRAWAL & MINTING    ║
    ╚════════════════════════════╝*/

  /**
  @notice Internal logic for withdrawing stakes.
  @dev Mint user any outstanding float before withdrawing.
  @param marketIndex Market index of token.
  @param amount Amount to withdraw.
  @param token Synthetic token that was staked.
  */
  function _withdraw(
    uint32 marketIndex,
    address token,
    uint256 amount
  ) internal virtual {
    require(userAmountStaked[token][msg.sender] > 0, "nothing to withdraw");
    _mintAccumulatedFloat(marketIndex, msg.sender);

    userAmountStaked[token][msg.sender] = userAmountStaked[token][msg.sender] - amount;

    uint256 amountFees = (amount * marketUnstakeFee_e18[marketIndex]) / 1e18;

    IERC20(token).transfer(floatTreasury, amountFees);
    IERC20(token).transfer(msg.sender, amount - amountFees);

    emit StakeWithdrawn(msg.sender, token, amount);
  }

  /**
  @notice Withdraw function. Allows users to unstake.
  @param amount Amount to withdraw.
  @param token Address of the token for which to withdraw.
  */
  function withdraw(address token, uint256 amount) external {
    ILongShort(longShort).updateSystemState(marketIndexOfToken[token]);

    uint32 marketIndex = marketIndexOfToken[token];

    _withdraw(marketIndex, token, amount);

    if (userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] > 0) {
      // If they still have outstanding shifts after minting float, then check
      // that they don't withdraw more than their shifts allow.
      uint256 amountToShiftForThisToken = syntheticTokens[marketIndex][true] == token
        ? userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][msg.sender]
        : userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][msg.sender];

      require(
        userAmountStaked[token][msg.sender] >= amountToShiftForThisToken,
        "Outstanding next price stake shifts too great"
      );
    }
  }

  /**
  @notice Allows users to withdraw their entire stake for a token.
  @param token Address of the token for which to withdraw.
  */
  function withdrawAll(address token) external {
    ILongShort(longShort).updateSystemState(marketIndexOfToken[token]);

    uint32 marketIndex = marketIndexOfToken[token];

    uint256 amountToShiftForThisToken = syntheticTokens[marketIndex][true] == token
      ? userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][msg.sender]
      : userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][msg.sender];

    _withdraw(marketIndex, token, userAmountStaked[token][msg.sender] - amountToShiftForThisToken);
  }
}
.]

Based on the provided Solidity smart contract code for the `Staker` contract, here is a summary of the potential security vulnerabilities identified:

### Summary of Security Vulnerabilities

1. **Reentrancy Vulnerability**:
   - The contract does not implement any reentrancy guards, particularly in functions that involve transferring tokens or updating user balances. This could allow an attacker to exploit the contract by recursively calling functions that modify state or transfer funds.

2. **Integer Overflow/Underflow**:
   - Although Solidity 0.8.x has built-in overflow and underflow checks, it is essential to ensure that all mathematical operations are correctly handled, especially when dealing with user balances and rewards calculations.

3. **Access Control Issues**:
   - The `onlyAdmin` modifier is used to restrict access to certain functions, but there is no mechanism to ensure that the `admin` address is valid or that it cannot be changed to a malicious address. This could lead to unauthorized access if the `admin` key is compromised.

4. **Gas Limit and Loops**:
   - Functions like `_mintAccumulatedFloatMulti` involve unbounded loops, which could lead to exceeding gas limits if called with a large number of market indexes. This could prevent users from executing critical functions.

5. **Lack of Input Validation**:
   - Some functions do not validate inputs thoroughly. For example, the `stakeFromUser` function does not check if the `amount` is greater than zero before proceeding with the staking logic.

6. **Potential for Denial of Service (DoS)**:
   - If any external contract (like `ILongShort`) fails or reverts during a call, it could prevent the execution of critical functions, leading to a denial of service for users trying to stake or withdraw.

7. **Uncontrolled Token Shifts**:
   - The logic for shifting tokens does not adequately handle cases where the user may not have sufficient tokens to shift, leading to potential inconsistencies in user balances.

8. **Event Emission**:
   - While events are emitted for significant state changes, there may be cases where events are not emitted for all critical actions, which could hinder tracking and auditing of contract activity.

### Comprehensive Analysis Report

The `Staker` contract exhibits several security vulnerabilities that could be exploited by malicious actors. The absence of reentrancy guards poses a significant risk, especially in functions that involve external calls or state changes. Access control mechanisms need to be reinforced to prevent unauthorized access, and input validation should be implemented to ensure that all user inputs are within expected ranges.

Moreover, the potential for gas limit issues due to unbounded loops could lead to user frustration and loss of functionality. It is crucial to implement checks to prevent denial of service scenarios, particularly when interacting with external contracts.

To enhance the security posture of the `Staker` contract, the following recommendations are suggested:

- Implement reentrancy guards in functions that transfer tokens or modify user balances.
- Ensure thorough input validation across all functions to prevent invalid operations.
- Introduce checks to handle potential gas limit issues, especially in functions with loops.
- Strengthen access control mechanisms to ensure that only authorized addresses can execute sensitive functions.
- Consider implementing a fallback mechanism to handle failures in external contract calls gracefully.
- Regularly audit the contract and its dependencies to identify and mitigate any emerging vulnerabilities.

By addressing these vulnerabilities and implementing the recommended changes, the security and reliability of the `Staker` contract can be significantly improved, thereby safeguarding user funds and enhancing overall trust in the system.

[2024-17-08 08:01:54 INFO] **[Seminar Conclusion]**:

 Based on the provided Solidity smart contract code for the `Staker` contract, here is a summary of the potential security vulnerabilities identified:

### Summary of Security Vulnerabilities

1. **Reentrancy Vulnerability**:
   - The contract does not implement any reentrancy guards, particularly in functions that involve transferring tokens or updating user balances. This could allow an attacker to exploit the contract by recursively calling functions that modify state or transfer funds.

2. **Integer Overflow/Underflow**:
   - Although Solidity 0.8.x has built-in overflow and underflow checks, it is essential to ensure that all mathematical operations are correctly handled, especially when dealing with user balances and rewards calculations.

3. **Access Control Issues**:
   - The `onlyAdmin` modifier is used to restrict access to certain functions, but there is no mechanism to ensure that the `admin` address is valid or that it cannot be changed to a malicious address. This could lead to unauthorized access if the `admin` key is compromised.

4. **Gas Limit and Loops**:
   - Functions like `_mintAccumulatedFloatMulti` involve unbounded loops, which could lead to exceeding gas limits if called with a large number of market indexes. This could prevent users from executing critical functions.

5. **Lack of Input Validation**:
   - Some functions do not validate inputs thoroughly. For example, the `stakeFromUser` function does not check if the `amount` is greater than zero before proceeding with the staking logic.

6. **Potential for Denial of Service (DoS)**:
   - If any external contract (like `ILongShort`) fails or reverts during a call, it could prevent the execution of critical functions, leading to a denial of service for users trying to stake or withdraw.

7. **Uncontrolled Token Shifts**:
   - The logic for shifting tokens does not adequately handle cases where the user may not have sufficient tokens to shift, leading to potential inconsistencies in user balances.

8. **Event Emission**:
   - While events are emitted for significant state changes, there may be cases where events are not emitted for all critical actions, which could hinder tracking and auditing of contract activity.

### Comprehensive Analysis Report

The `Staker` contract exhibits several security vulnerabilities that could be exploited by malicious actors. The absence of reentrancy guards poses a significant risk, especially in functions that involve external calls or state changes. Access control mechanisms need to be reinforced to prevent unauthorized access, and input validation should be implemented to ensure that all user inputs are within expected ranges.

Moreover, the potential for gas limit issues due to unbounded loops could lead to user frustration and loss of functionality. It is crucial to implement checks to prevent denial of service scenarios, particularly when interacting with external contracts.

To enhance the security posture of the `Staker` contract, the following recommendations are suggested:

- Implement reentrancy guards in functions that transfer tokens or modify user balances.
- Ensure thorough input validation across all functions to prevent invalid operations.
- Introduce checks to handle potential gas limit issues, especially in functions with loops.
- Strengthen access control mechanisms to ensure that only authorized addresses can execute sensitive functions.
- Consider implementing a fallback mechanism to handle failures in external contract calls gracefully.
- Regularly audit the contract and its dependencies to identify and mitigate any emerging vulnerabilities.

By addressing these vulnerabilities and implementing the recommended changes, the security and reliability of the `Staker` contract can be significantly improved, thereby safeguarding user funds and enhancing overall trust in the system.

[2024-17-08 08:01:54 INFO] **[Execute Detail]**

execute SimplePhase:[ContractReviewComment] in ComposedPhase:[CodeReview], cycle 3

[2024-17-08 08:01:54 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: BUSL-1.1 pragma solidity 0.8.3; import "@openzeppelin/contracts-upgradeable/token/ERC20/presets/ERC20PresetMinterPauserUpgradeable.sol"; import "./interfaces/IFloatToken.sol"; import "./interfaces/ILongShort.sol"; import "./interfaces/IStaker.sol"; import "./interfaces/ISyntheticToken.sol"; contract Staker is IStaker, Initializable {   /╔═════════════════════════════╗     ║          VARIABLES          ║     ╚═════════════════════════════╝/ / ══════ Fixed-precision constants ══════ /   uint256 public constant FLOAT_ISSUANCE_FIXED_DECIMAL = 1e42;   // 2^52 ~= 4.5e15   // With an exponent of 5, the largest total liquidity possible in a market (to avoid integer overflow on exponentiation) is ~10^31 or 10 Trillion (10^13)   // NOTE: this also means if the total market value is less than 2^52 there will be a division by zero error   uint256 public constant safeExponentBitShifting = 52; / ══════ Global state ══════ /   address public admin;   address public floatCapital;   address public floatTreasury;   uint256 public floatPercentage; address public longShort;   address public floatToken; / ══════ Market specific ══════ /   mapping(uint32 =&gt; uint256) public marketLaunchIncentive_period; // seconds   mapping(uint32 =&gt; uint256) public marketLaunchIncentive_multipliers; // e18 scale   mapping(uint32 =&gt; uint256) public marketUnstakeFee_e18;   mapping(uint32 =&gt; uint256) public balanceIncentiveCurve_exponent;   mapping(uint32 =&gt; int256) public balanceIncentiveCurve_equilibriumOffset; mapping(uint32 =&gt; mapping(bool =&gt; address)) public syntheticTokens; mapping(address =&gt; uint32) public marketIndexOfToken; / ══════ Reward specific ══════ /   mapping(uint32 =&gt; uint256) public latestRewardIndex;   mapping(uint32 =&gt; mapping(uint256 =&gt; AccumulativeIssuancePerStakedSynthSnapshot))     public accumulativeFloatPerSyntheticTokenSnapshots;   struct AccumulativeIssuancePerStakedSynthSnapshot {     uint256 timestamp;     uint256 accumulativeFloatPerSyntheticToken_long;     uint256 accumulativeFloatPerSyntheticToken_short;   } / ══════ User specific ══════ /   mapping(uint32 =&gt; mapping(address =&gt; uint256)) public userIndexOfLastClaimedReward;   mapping(address =&gt; mapping(address =&gt; uint256)) public userAmountStaked; / ══════ Token shift management specific ══════ /   mapping(uint32 =&gt; uint256) public batched_stakerNextTokenShiftIndex;   /*   @notice Used to link a token shift to a staker state   @dev tokenShiftIndex =&gt; accumulativeFloatIssuanceSnapshotIndex     POSSIBLE OPTIMIZATION - could pack stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping and stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping into a struct of two uint128 for storage space optimization.   /   mapping(uint256 =&gt; uint256) public stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping;   /// @notice Used to fetch the price from LongShort at that point in time   /// @dev tokenShiftIndex =&gt; longShortMarketPriceSnapshotIndex   mapping(uint256 =&gt; uint256) public stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping;   /// @dev marketIndex =&gt; usersAddress =&gt; stakerTokenShiftIndex   mapping(uint32 =&gt; mapping(address =&gt; uint256)) public userNextPrice_stakedSyntheticTokenShiftIndex;   /// @dev marketIndex =&gt; usersAddress =&gt; amountUserRequestedToShiftAwayFromLongOnNextUpdate   mapping(uint32 =&gt; mapping(address =&gt; uint256)) public userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long;   /// @dev marketIndex =&gt; usersAddress =&gt; amountUserRequestedToShiftAwayFromShortOnNextUpdate   mapping(uint32 =&gt; mapping(address =&gt; uint256)) public userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short; /╔════════════════════════════╗     ║           EVENTS           ║     ╚════════════════════════════╝/ event StakerV1(     address admin,     address floatTreasury,     address floatCapital,     address floatToken,     uint256 floatPercentage   ); event MarketAddedToStaker(     uint32 marketIndex,     uint256 exitFee_e18,     uint256 period,     uint256 multiplier,     uint256 balanceIncentiveExponent,     int256 balanceIncentiveEquilibriumOffset   ); event AccumulativeIssuancePerStakedSynthSnapshotCreated(     uint32 marketIndex,     uint256 accumulativeFloatIssuanceSnapshotIndex,     uint256 accumulativeLong,     uint256 accumulativeShort   ); event StakeAdded(address user, address token, uint256 amount, uint256 lastMintIndex); event StakeWithdrawn(address user, address token, uint256 amount); // Note: the amountFloatMinted isn't strictly needed by the graph, but it is good to add it to validate calculations are accurate.   event FloatMinted(address user, uint32 marketIndex, uint256 amountFloatMinted); event MarketLaunchIncentiveParametersChanges(uint32 marketIndex, uint256 period, uint256 multiplier); event StakeWithdrawalFeeUpdated(uint32 marketIndex, uint256 stakeWithdralFee); event BalanceIncentiveExponentUpdated(uint32 marketIndex, uint256 balanceIncentiveExponent); event BalanceIncentiveEquilibriumOffsetUpdated(uint32 marketIndex, int256 balanceIncentiveEquilibriumOffset); event FloatPercentageUpdated(uint256 floatPercentage); event SyntheticTokensShifted(); event ChangeAdmin(address newAdmin); /╔═════════════════════════════╗     ║          MODIFIERS          ║     ╚═════════════════════════════╝/ function onlyAdminModifierLogic() internal virtual {     require(msg.sender == admin, "not admin");   } modifier onlyAdmin() {     onlyAdminModifierLogic();     _;   } function onlyValidSyntheticModifierLogic(address _synth) internal virtual {     require(marketIndexOfToken[_synth] != 0, "not valid synth");   } modifier onlyValidSynthetic(address synth) {     onlyValidSyntheticModifierLogic(_synth);     ;   } function onlyValidMarketModifierLogic(uint32 marketIndex) internal virtual {     require(address(syntheticTokens[marketIndex][true]) != address(0), "not valid market");   } modifier onlyValidMarket(uint32 marketIndex) {     onlyValidMarketModifierLogic(marketIndex);     _;   } function onlyLongShortModifierLogic() internal virtual {     require(msg.sender == address(longShort), "not long short");   } modifier onlyLongShort() {     onlyLongShortModifierLogic();     _;   } /╔═════════════════════════════╗     ║       CONTRACT SET-UP       ║     ╚═════════════════════════════╝/ /*   @notice Initializes the contract.   @dev Calls OpenZeppelin's initializer modifier.   @param _admin Address of the admin role.   @param _longShort Address of the LongShort contract, a deployed LongShort.sol   @param _floatToken Address of the Float token earned by staking.   @param _floatTreasury Address of the treasury contract for managing fees.   @param _floatCapital Address of the contract which earns a fixed percentage of Float.   @param _floatPercentage Determines the float percentage that gets minted for Float Capital, base 1e18.   /   function initialize(     address _admin,     address _longShort,     address _floatToken,     address _floatTreasury,     address _floatCapital,     uint256 _floatPercentage   ) external virtual initializer {     admin = _admin;     floatCapital = _floatCapital;     floatTreasury = _floatTreasury;     longShort = _longShort;     floatToken = _floatToken; _changeFloatPercentage(_floatPercentage);  emit StakerV1(_admin, _floatTreasury, _floatCapital, _floatToken, _floatPercentage);  } /╔═══════════════════╗     ║       ADMIN       ║     ╚═══════════════════╝/ /*    @notice Changes admin for the contract   @param _admin The address of the new admin.   /   function changeAdmin(address _admin) external onlyAdmin {     admin = _admin;     emit ChangeAdmin(_admin);   } /// @dev Logic for changeFloatPercentage   function _changeFloatPercentage(uint256 newFloatPercentage) internal virtual {     require(newFloatPercentage &lt;= 1e18 &amp;&amp; newFloatPercentage &gt; 0); // less than or equal to 100% and greater than 0%     floatPercentage = newFloatPercentage;   } /*   @notice Changes percentage of float that is minted for float capital.   @param newFloatPercentage The new float percentage in base 1e18.   /   function changeFloatPercentage(uint256 newFloatPercentage) external onlyAdmin {     _changeFloatPercentage(newFloatPercentage);     emit FloatPercentageUpdated(newFloatPercentage);   } /// @dev Logic for changeUnstakeFee   function _changeUnstakeFee(uint32 marketIndex, uint256 newMarketUnstakeFee_e18) internal virtual {     require(newMarketUnstakeFee_e18 &lt;= 5e16); // Explicitely stating 5% fee as the max fee possible.     marketUnstakeFee_e18[marketIndex] = newMarketUnstakeFee_e18;   } /*   @notice Changes unstake fee for a market   @param marketIndex Identifies the market.   @param newMarketUnstakeFee_e18 The new unstake fee.   /   function changeUnstakeFee(uint32 marketIndex, uint256 newMarketUnstakeFee_e18) external onlyAdmin {     _changeUnstakeFee(marketIndex, newMarketUnstakeFee_e18);     emit StakeWithdrawalFeeUpdated(marketIndex, newMarketUnstakeFee_e18);   } /// @dev Logic for changeMarketLaunchIncentiveParameters   function _changeMarketLaunchIncentiveParameters(     uint32 marketIndex,     uint256 period,     uint256 initialMultiplier   ) internal virtual {     require(initialMultiplier &gt;= 1e18, "marketLaunchIncentiveMultiplier must be &gt;= 1e18"); marketLaunchIncentive_period[marketIndex] = period; marketLaunchIncentive_multipliers[marketIndex] = initialMultiplier;  } /*   @notice Changes the market launch incentive parameters for a market   @param marketIndex Identifies the market.   @param period The new period for which float token generation should be boosted.   @param initialMultiplier The new multiplier on Float generation.   /   function changeMarketLaunchIncentiveParameters(     uint32 marketIndex,     uint256 period,     uint256 initialMultiplier   ) external onlyAdmin {     _changeMarketLaunchIncentiveParameters(marketIndex, period, initialMultiplier); emit MarketLaunchIncentiveParametersChanges(marketIndex, period, initialMultiplier);  } /// @dev Logic for changeBalanceIncentiveExponent   function _changeBalanceIncentiveExponent(uint32 marketIndex, uint256 _balanceIncentiveCurve_exponent)     internal     virtual   {     require(       // The exponent has to be less than 5 in these versions of the contracts.       _balanceIncentiveCurve_exponent &gt; 0 &amp;&amp; _balanceIncentiveCurve_exponent &lt; 6,       "balanceIncentiveCurve_exponent out of bounds"     ); balanceIncentiveCurve_exponent[marketIndex] = _balanceIncentiveCurve_exponent;  } /*    @notice Changes the balance incentive exponent for a market   @param marketIndex Identifies the market.   @param _balanceIncentiveCurve_exponent The new exponent for the curve.   /   function changeBalanceIncentiveExponent(uint32 marketIndex, uint256 _balanceIncentiveCurve_exponent)     external     onlyAdmin   {     _changeBalanceIncentiveExponent(marketIndex, _balanceIncentiveCurve_exponent); emit BalanceIncentiveExponentUpdated(marketIndex, _balanceIncentiveCurve_exponent);  } /// @dev Logic for changeBalanceIncentiveEquilibriumOffset   function _changeBalanceIncentiveEquilibriumOffset(uint32 marketIndex, int256 _balanceIncentiveCurve_equilibriumOffset)     internal     virtual   {     // Unreasonable that we would ever shift this more than 90% either way     require(       _balanceIncentiveCurve_equilibriumOffset &gt; -9e17 &amp;&amp; _balanceIncentiveCurve_equilibriumOffset &lt; 9e17,       "balanceIncentiveCurve_equilibriumOffset out of bounds"     ); balanceIncentiveCurve_equilibriumOffset[marketIndex] = _balanceIncentiveCurve_equilibriumOffset;  } /*   @notice Changes the balance incentive curve equilibrium offset for a market   @param marketIndex Identifies the market.   @param _balanceIncentiveCurve_equilibriumOffset The new offset.   /   function changeBalanceIncentiveEquilibriumOffset(uint32 marketIndex, int256 _balanceIncentiveCurve_equilibriumOffset)     external     onlyAdmin   {     _changeBalanceIncentiveEquilibriumOffset(marketIndex, _balanceIncentiveCurve_equilibriumOffset); emit BalanceIncentiveEquilibriumOffsetUpdated(marketIndex, _balanceIncentiveCurve_equilibriumOffset);  } /╔═════════════════════════════╗     ║        STAKING SETUP        ║     ╚═════════════════════════════╝/ /*   @notice Sets this contract to track staking for a market in LongShort.sol   @param marketIndex Identifies the market.   @param longToken Address of the long token for the market.   @param shortToken Address of the short token for the market.   @param kInitialMultiplier Initial boost on float generation for the market.   @param kPeriod Period which the boost should last.   @param unstakeFee_e18 Percentage of tokens that are levied on unstaking in base 1e18.   @param _balanceIncentiveCurve_exponent Exponent for balance curve (see _calculateFloatPerSecond)   @param _balanceIncentiveCurve_equilibriumOffset Offset for balance curve (see _calculateFloatPerSecond)   /   function addNewStakingFund(     uint32 marketIndex,     address longToken,     address shortToken,     uint256 kInitialMultiplier,     uint256 kPeriod,     uint256 unstakeFee_e18,     uint256 _balanceIncentiveCurve_exponent,     int256 _balanceIncentiveCurve_equilibriumOffset   ) external override onlyLongShort {     marketIndexOfToken[longToken] = marketIndex;     marketIndexOfToken[shortToken] = marketIndex; accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].timestamp = block.timestamp; accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].accumulativeFloatPerSyntheticToken_long = 0; accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].accumulativeFloatPerSyntheticToken_short = 0;  syntheticTokens[marketIndex][true] = longToken; syntheticTokens[marketIndex][false] = shortToken;  _changeBalanceIncentiveExponent(marketIndex, _balanceIncentiveCurve_exponent); _changeBalanceIncentiveEquilibriumOffset(marketIndex, _balanceIncentiveCurve_equilibriumOffset); _changeMarketLaunchIncentiveParameters(marketIndex, kPeriod, kInitialMultiplier);  _changeUnstakeFee(marketIndex, unstakeFee_e18);  // Set this value to one initially - 0 is a null value and thus potentially bug prone. batched_stakerNextTokenShiftIndex[marketIndex] = 1;  emit MarketAddedToStaker(   marketIndex,   unstakeFee_e18,   kPeriod,   kInitialMultiplier,   _balanceIncentiveCurve_exponent,   _balanceIncentiveCurve_equilibriumOffset );  emit AccumulativeIssuancePerStakedSynthSnapshotCreated(marketIndex, 0, 0, 0);  } /╔═════════════════════════════════════════════════════════════════════════╗     ║    GLOBAL FLT REWARD ACCUMULATION CALCULATION AND TRACKING FUNCTIONS    ║     ╚═════════════════════════════════════════════════════════════════════════╝/ /*   @notice Returns the K factor parameters for the given market with sensible   defaults if they haven't been set yet.   @param marketIndex The market to change the parameters for.   @return period The period for which the k factor applies for in seconds.   @return multiplier The multiplier on Float generation in this period.   /   function _getMarketLaunchIncentiveParameters(uint32 marketIndex)     internal     view     virtual     returns (uint256 period, uint256 multiplier)   {     period = marketLaunchIncentive_period[marketIndex];     multiplier = marketLaunchIncentive_multipliers[marketIndex]; if (multiplier &lt; 1e18) {   multiplier = 1e18; // multiplier of 1 by default }  } /*    @notice Returns the extent to which a markets float generation should be adjusted   based on the market's launch incentive parameters. Should start at multiplier   then linearly change to 1e18 over time.   @param marketIndex Identifies the market.   @return k The calculated modifier for float generation.   /   function _getKValue(uint32 marketIndex) internal view virtual returns (uint256) {     // Parameters controlling the float issuance multiplier.     (uint256 kPeriod, uint256 kInitialMultiplier) = _getMarketLaunchIncentiveParameters(marketIndex); // Sanity check - under normal circumstances, the multipliers should // *never* be set to a value &lt; 1e18, as there are guards against this. assert(kInitialMultiplier &gt;= 1e18);  uint256 initialTimestamp = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].timestamp;  if (block.timestamp - initialTimestamp &lt;= kPeriod) {   return kInitialMultiplier - (((kInitialMultiplier - 1e18) * (block.timestamp - initialTimestamp)) / kPeriod); } else {   return 1e18; }  } /   @notice Computes the number of float tokens a user earns per second for   every long/short synthetic token they've staked. The returned value has   a fixed decimal scale of 1e42 (!!!) for numerical stability. The return   values are float per second per synthetic token (hence the requirement   to multiply by price)   @dev to see below math in latex form see TODO add link   to interact with the equations see https://www.desmos.com/calculator/optkaxyihr   @param marketIndex The market referred to.   @param longPrice Price of the synthetic long token in units of payment token   @param shortPrice Price of the synthetic short token in units of payment token   @param longValue Amount of payment token in the long side of the market   @param shortValue Amount of payment token in the short side of the market   @return longFloatPerSecond Float token per second per long synthetic token   @return shortFloatPerSecond Float token per second per short synthetic token    /   function _calculateFloatPerSecond(     uint32 marketIndex,     uint256 longPrice,     uint256 shortPrice,     uint256 longValue,     uint256 shortValue   ) internal view virtual returns (uint256 longFloatPerSecond, uint256 shortFloatPerSecond) {     // A float issuance multiplier that starts high and decreases linearly     // over time to a value of 1. This incentivises users to stake early.     uint256 k = _getKValue(marketIndex); uint256 totalLocked = (longValue + shortValue);  // we need to scale this number by the totalLocked so that the offset remains consistent accross market size  int256 equilibriumOffsetMarketScaled = (balanceIncentiveCurve_equilibriumOffset[marketIndex] *   int256(totalLocked)) / 2e18;  uint256 denominator = ((totalLocked &gt;&gt; safeExponentBitShifting)**balanceIncentiveCurve_exponent[marketIndex]);  // Float is scaled by the percentage of the total market value held in // the opposite position. This incentivises users to stake on the // weaker position. if (int256(shortValue) - equilibriumOffsetMarketScaled &lt; int256(longValue)) {   if (equilibriumOffsetMarketScaled &gt;= int256(shortValue)) {     // edge case: imbalanced far past the equilibrium offset - full rewards go to short token     //            extremeley unlikely to happen in practice     return (0, 1e18 * k * shortPrice);   }    uint256 numerator = (uint256(int256(shortValue) - equilibriumOffsetMarketScaled) &gt;&gt;     (safeExponentBitShifting - 1))**balanceIncentiveCurve_exponent[marketIndex];    // NOTE: `x * 5e17` == `(x * 10e18) / 2`   uint256 longRewardUnscaled = (numerator * 5e17) / denominator;   uint256 shortRewardUnscaled = 1e18 - longRewardUnscaled;    return ((longRewardUnscaled * k * longPrice) / 1e18, (shortRewardUnscaled * k * shortPrice) / 1e18); } else {   if (-equilibriumOffsetMarketScaled &gt;= int256(longValue)) {     // edge case: imbalanced far past the equilibrium offset - full rewards go to long token     //            extremeley unlikely to happen in practice     return (1e18 * k * longPrice, 0);   }    uint256 numerator = (uint256(int256(longValue) + equilibriumOffsetMarketScaled) &gt;&gt;     (safeExponentBitShifting - 1))**balanceIncentiveCurve_exponent[marketIndex];    // NOTE: `x * 5e17` == `(x * 10e18) / 2`   uint256 shortRewardUnscaled = (numerator * 5e17) / denominator;   uint256 longRewardUnscaled = 1e18 - shortRewardUnscaled;    return ((longRewardUnscaled * k * longPrice) / 1e18, (shortRewardUnscaled * k * shortPrice) / 1e18); }  } /*   @notice Computes the time since last accumulativeIssuancePerStakedSynthSnapshot for the given market in seconds.   @param marketIndex The market referred to.   @return The time difference in seconds   /   function _calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(uint32 marketIndex)     internal     view     virtual     returns (uint256)   {     return       block.timestamp -       accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]].timestamp;   } /*   @notice Computes new cumulative sum of 'r' value since last accumulativeIssuancePerStakedSynthSnapshot. We use   cumulative 'r' value to avoid looping during issuance. Note that the   cumulative sum is kept in 1e42 scale (!!!) to avoid numerical issues.   @param shortValue The value locked in the short side of the market.   @param longValue The value locked in the long side of the market.   @param shortPrice The price of the short token as defined in LongShort.sol   @param longPrice The price of the long token as defined in LongShort.sol   @param marketIndex An identifier for the market.   @return longCumulativeRates The long cumulative sum.   @return shortCumulativeRates The short cumulative sum.   /   function _calculateNewCumulativeIssuancePerStakedSynth(     uint32 marketIndex,     uint256 longPrice,     uint256 shortPrice,     uint256 longValue,     uint256 shortValue   ) internal view virtual returns (uint256 longCumulativeRates, uint256 shortCumulativeRates) {     // Compute the current 'r' value for float issuance per second.     (uint256 longFloatPerSecond, uint256 shortFloatPerSecond) = _calculateFloatPerSecond(       marketIndex,       longPrice,       shortPrice,       longValue,       shortValue     ); // Compute time since last accumulativeIssuancePerStakedSynthSnapshot for the given token. uint256 timeDelta = _calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(marketIndex);  // Compute new cumulative 'r' value total. return (   accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]]   .accumulativeFloatPerSyntheticToken_long + (timeDelta * longFloatPerSecond),   accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]]   .accumulativeFloatPerSyntheticToken_short + (timeDelta * shortFloatPerSecond) );  } /*   @notice Creates a new accumulativeIssuancePerStakedSynthSnapshot for the given token and updates indexes.   @param shortValue The value locked in the short side of the market.   @param longValue The value locked in the long side of the market.   @param shortPrice The price of the short token as defined in LongShort.sol   @param longPrice The price of the long token as defined in LongShort.sol   @param marketIndex An identifier for the market.   /   function _setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot(     uint32 marketIndex,     uint256 longPrice,     uint256 shortPrice,     uint256 longValue,     uint256 shortValue   ) internal virtual {     (       uint256 newLongAccumulativeValue,       uint256 newShortAccumulativeValue     ) = _calculateNewCumulativeIssuancePerStakedSynth(marketIndex, longPrice, shortPrice, longValue, shortValue); uint256 newIndex = latestRewardIndex[marketIndex] + 1;  // Set cumulative 'r' value on new accumulativeIssuancePerStakedSynthSnapshot. accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex] .accumulativeFloatPerSyntheticToken_long = newLongAccumulativeValue; accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex] .accumulativeFloatPerSyntheticToken_short = newShortAccumulativeValue;  // Set timestamp on new accumulativeIssuancePerStakedSynthSnapshot. accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex].timestamp = block.timestamp;  // Update latest index to point to new accumulativeIssuancePerStakedSynthSnapshot. latestRewardIndex[marketIndex] = newIndex;  emit AccumulativeIssuancePerStakedSynthSnapshotCreated(   marketIndex,   newIndex,   newLongAccumulativeValue,   newShortAccumulativeValue );  } /*   @notice Adds new accumulativeIssuancePerStakedSynthSnapshots for the given long/short tokens. Called by the   ILongShort contract whenever there is a state change for a market.   @param stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted Mapping from this contract's shifts to LongShort.sols next price snapshots.   @param shortValue The value locked in the short side of the market.   @param longValue The value locked in the long side of the market.   @param shortPrice The price of the short token as defined in LongShort.sol   @param longPrice The price of the long token as defined in LongShort.sol   @param marketIndex An identifier for the market.   /   function pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(     uint32 marketIndex,     uint256 longPrice,     uint256 shortPrice,     uint256 longValue,     uint256 shortValue,     uint256 stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted // This value should be ALWAYS be zero if no shift occured   ) external override onlyLongShort {     // Only add a new accumulativeIssuancePerStakedSynthSnapshot if some time has passed. // the `stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted` value will be 0 if there is no staker related action in an executed batch if (stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted &gt; 0) {   stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[     batched_stakerNextTokenShiftIndex[marketIndex]   ] = stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted;   stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[     batched_stakerNextTokenShiftIndex[marketIndex]   ] = latestRewardIndex[marketIndex] + 1;   batched_stakerNextTokenShiftIndex[marketIndex] += 1;    emit SyntheticTokensShifted(); }  // Time delta is fetched twice in below code, can pass through? Which is less gas? if (_calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(marketIndex) &gt; 0) {   _setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot(     marketIndex,     longPrice,     shortPrice,     longValue,     shortValue   ); }  } /╔═══════════════════════════════════╗     ║    USER REWARD STATE FUNCTIONS    ║     ╚═══════════════════════════════════╝/ /// @dev Calculates the accumulated float in a specific range of staker snapshots   function _calculateAccumulatedFloatInRange(     uint32 marketIndex,     uint256 amountStakedLong,     uint256 amountStakedShort,     uint256 rewardIndexFrom,     uint256 rewardIndexTo   ) internal view virtual returns (uint256 floatReward) {     if (amountStakedLong &gt; 0) {       uint256 accumDeltaLong = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexTo]       .accumulativeFloatPerSyntheticToken_long -         accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexFrom]         .accumulativeFloatPerSyntheticToken_long;       floatReward += (accumDeltaLong * amountStakedLong) / FLOAT_ISSUANCE_FIXED_DECIMAL;     } if (amountStakedShort &gt; 0) {   uint256 accumDeltaShort = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexTo]   .accumulativeFloatPerSyntheticToken_short -     accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexFrom]     .accumulativeFloatPerSyntheticToken_short;   floatReward += (accumDeltaShort * amountStakedShort) / FLOAT_ISSUANCE_FIXED_DECIMAL; }  } /*    @notice Calculates float owed to the user since the user last minted float for a market.   @param marketIndex Identifier for the market which the user staked in.   @param user The address of the user.   @return floatReward The amount of float owed.    /   function _calculateAccumulatedFloat(uint32 marketIndex, address user) internal virtual returns (uint256 floatReward) {     address longToken = syntheticTokens[marketIndex][true];     address shortToken = syntheticTokens[marketIndex][false]; uint256 amountStakedLong = userAmountStaked[longToken][user]; uint256 amountStakedShort = userAmountStaked[shortToken][user];  uint256 usersLastRewardIndex = userIndexOfLastClaimedReward[marketIndex][user];  // Don't do the calculation and return zero immediately if there is no change if (usersLastRewardIndex == latestRewardIndex[marketIndex]) {   return 0; }  uint256 usersShiftIndex = userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][user]; // if there is a change in the users tokens held due to a token shift (or possibly another action in the future) if (usersShiftIndex &gt; 0 &amp;&amp; usersShiftIndex &lt; batched_stakerNextTokenShiftIndex[marketIndex]) {   floatReward = _calculateAccumulatedFloatInRange(     marketIndex,     amountStakedLong,     amountStakedShort,     usersLastRewardIndex,     stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[usersShiftIndex]   );    // Update the users balances   if (userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user] &gt; 0) {     amountStakedShort += ILongShort(longShort).getAmountSyntheticTokenToMintOnTargetSide(       marketIndex,       userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user],       true,       stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[usersShiftIndex]     );      amountStakedLong -= userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user];     userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user] = 0;   }    if (userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user] &gt; 0) {     amountStakedLong += ILongShort(longShort).getAmountSyntheticTokenToMintOnTargetSide(       marketIndex,       userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user],       false,       stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[usersShiftIndex]     );      amountStakedShort -= userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user];     userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user] = 0;   }    // Save the users updated staked amounts   userAmountStaked[longToken][user] = amountStakedLong;   userAmountStaked[shortToken][user] = amountStakedShort;    floatReward += _calculateAccumulatedFloatInRange(     marketIndex,     amountStakedLong,     amountStakedShort,     stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[usersShiftIndex],     latestRewardIndex[marketIndex]   );    userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][user] = 0; } else {   floatReward = _calculateAccumulatedFloatInRange(     marketIndex,     amountStakedLong,     amountStakedShort,     usersLastRewardIndex,     latestRewardIndex[marketIndex]   ); }  } /*   @notice Mints float for a user.   @dev Mints a fixed percentage for Float capital.   @param user The address of the user.   @param floatToMint The amount of float to mint.    /   function _mintFloat(address user, uint256 floatToMint) internal virtual {     IFloatToken(floatToken).mint(user, floatToMint);     IFloatToken(floatToken).mint(floatCapital, (floatToMint * floatPercentage) / 1e18);   } /*   @notice Mints float owed to a user for a market since they last minted.   @param marketIndex An identifier for the market.   @param user The address of the user.    /   function _mintAccumulatedFloat(uint32 marketIndex, address user) internal virtual {     uint256 floatToMint = _calculateAccumulatedFloat(marketIndex, user); if (floatToMint &gt; 0) {   // Set the user has claimed up until now, stops them setting this forward   userIndexOfLastClaimedReward[marketIndex][user] = latestRewardIndex[marketIndex];    _mintFloat(user, floatToMint);   emit FloatMinted(user, marketIndex, floatToMint); }  } /*   @notice Mints float owed to a user for multiple markets, since they last minted for those markets.   @param marketIndexes Identifiers for the markets.   @param user The address of the user.    /   function _mintAccumulatedFloatMulti(uint32[] calldata marketIndexes, address user) internal virtual {     uint256 floatTotal = 0;     for (uint256 i = 0; i &lt; marketIndexes.length; i++) {       uint256 floatToMint = _calculateAccumulatedFloat(marketIndexes[i], user);   if (floatToMint &gt; 0) {     // Set the user has claimed up until now, stops them setting this forward     userIndexOfLastClaimedReward[marketIndexes[i]][user] = latestRewardIndex[marketIndexes[i]];      floatTotal += floatToMint;      emit FloatMinted(user, marketIndexes[i], floatToMint);   } } if (floatTotal &gt; 0) {   _mintFloat(user, floatTotal); }  } /*   @notice Mints outstanding float for msg.sender.   @param marketIndexes Identifiers for the markets for which to mint float.    /   function claimFloatCustom(uint32[] calldata marketIndexes) external {     ILongShort(longShort).updateSystemStateMulti(marketIndexes);     _mintAccumulatedFloatMulti(marketIndexes, msg.sender);   } /*   @notice Mints outstanding float on behalf of another user.   @param marketIndexes Identifiers for the markets for which to mint float.   @param user The address of the user.    /   function claimFloatCustomFor(uint32[] calldata marketIndexes, address user) external {     // Unbounded loop - users are responsible for paying their own gas costs on these and it doesn't effect the rest of the system.     // No need to impose limit.     ILongShort(longShort).updateSystemStateMulti(marketIndexes);     _mintAccumulatedFloatMulti(marketIndexes, user);   } /╔═══════════════════════╗     ║        STAKING        ║     ╚═══════════════════════╝/ /*   @notice A user with synthetic tokens stakes by calling stake on the token   contract which calls this function. We need to first update the   state of the LongShort contract for this market before staking to correctly calculate user rewards.   @param amount Amount to stake.   @param from Address to stake for.   /   function stakeFromUser(address from, uint256 amount) public virtual override onlyValidSynthetic((msg.sender)) {     ILongShort(longShort).updateSystemState(marketIndexOfToken[(msg.sender)]);     _stake((msg.sender), amount, from);   } /*   @dev Internal logic for staking.   @param token Address of the token for which to stake.   @param amount Amount to stake.   @param user Address to stake for.   /   function _stake(     address token,     uint256 amount,     address user   ) internal virtual {     uint32 marketIndex = marketIndexOfToken[token]; // If they already have staked and have rewards due, mint these. if (   userIndexOfLastClaimedReward[marketIndex][user] != 0 &amp;&amp;   userIndexOfLastClaimedReward[marketIndex][user] &lt; latestRewardIndex[marketIndex] ) {   _mintAccumulatedFloat(marketIndex, user); }  userAmountStaked[token][user] = userAmountStaked[token][user] + amount;  userIndexOfLastClaimedReward[marketIndex][user] = latestRewardIndex[marketIndex];  emit StakeAdded(user, address(token), amount, userIndexOfLastClaimedReward[marketIndex][user]);  } /*   @notice Allows users to shift their staked tokens from one side of the market to    the other at the next price.   @param amountSyntheticTokensToShift Amount of tokens to shift.   @param marketIndex Identifier for the market.   @param isShiftFromLong Whether the shift is from long to short or short to long.   /   function shiftTokens(     uint256 amountSyntheticTokensToShift,     uint32 marketIndex,     bool isShiftFromLong   ) external virtual {     address token = syntheticTokens[marketIndex][isShiftFromLong];     require(userAmountStaked[token][msg.sender] &gt;= amountSyntheticTokensToShift, "Not enough tokens to shift"); // If the user has outstanding token shift that have already been confirmed in the LongShort // contract, execute them first. if (   userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] != 0 &amp;&amp;   userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] &lt;   batched_stakerNextTokenShiftIndex[marketIndex] ) {   _mintAccumulatedFloat(marketIndex, msg.sender); }  if (isShiftFromLong) {   ILongShort(longShort).shiftPositionFromLongNextPrice(marketIndex, amountSyntheticTokensToShift);   userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][     msg.sender   ] += amountSyntheticTokensToShift; } else {   ILongShort(longShort).shiftPositionFromShortNextPrice(marketIndex, amountSyntheticTokensToShift);   userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][     msg.sender   ] += amountSyntheticTokensToShift; }  userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] = batched_stakerNextTokenShiftIndex[   marketIndex ];  } /╔════════════════════════════╗     ║    WITHDRAWAL &amp; MINTING    ║     ╚════════════════════════════╝/ /*   @notice Internal logic for withdrawing stakes.   @dev Mint user any outstanding float before withdrawing.   @param marketIndex Market index of token.   @param amount Amount to withdraw.   @param token Synthetic token that was staked.   /   function _withdraw(     uint32 marketIndex,     address token,     uint256 amount   ) internal virtual {     require(userAmountStaked[token][msg.sender] &gt; 0, "nothing to withdraw");     _mintAccumulatedFloat(marketIndex, msg.sender); userAmountStaked[token][msg.sender] = userAmountStaked[token][msg.sender] - amount;  uint256 amountFees = (amount * marketUnstakeFee_e18[marketIndex]) / 1e18;  IERC20(token).transfer(floatTreasury, amountFees); IERC20(token).transfer(msg.sender, amount - amountFees);  emit StakeWithdrawn(msg.sender, token, amount);  } /*   @notice Withdraw function. Allows users to unstake.   @param amount Amount to withdraw.   @param token Address of the token for which to withdraw.   /   function withdraw(address token, uint256 amount) external {     ILongShort(longShort).updateSystemState(marketIndexOfToken[token]); uint32 marketIndex = marketIndexOfToken[token];  _withdraw(marketIndex, token, amount);  if (userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] &gt; 0) {   // If they still have outstanding shifts after minting float, then check   // that they don't withdraw more than their shifts allow.   uint256 amountToShiftForThisToken = syntheticTokens[marketIndex][true] == token     ? userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][msg.sender]     : userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][msg.sender];    require(     userAmountStaked[token][msg.sender] &gt;= amountToShiftForThisToken,     "Outstanding next price stake shifts too great"   ); }  } /*   @notice Allows users to withdraw their entire stake for a token.   @param token Address of the token for which to withdraw.   /   function withdrawAll(address token) external {     ILongShort(longShort).updateSystemState(marketIndexOfToken[token]); uint32 marketIndex = marketIndexOfToken[token];  uint256 amountToShiftForThisToken = syntheticTokens[marketIndex][true] == token   ? userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][msg.sender]   : userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][msg.sender];  _withdraw(marketIndex, token, userAmountStaked[token][msg.sender] - amountToShiftForThisToken);  } } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: "{task}". Ideas: "{ideas}". As the {assistant_role}, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability. For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix. Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: " Analysis Complete." |
| **phase_name** | ContractReviewComment |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 3, 'task': '// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.3;\n\nimport "@openzeppelin/contracts-upgradeable/token/ERC20/presets/ERC20PresetMinterPauserUpgradeable.sol";\n\nimport "./interfaces/IFloatToken.sol";\nimport "./interfaces/ILongShort.sol";\nimport "./interfaces/IStaker.sol";\nimport "./interfaces/ISyntheticToken.sol";\n\ncontract Staker is IStaker, Initializable {\n  /╔═════════════════════════════╗\n    ║          VARIABLES          ║\n    ╚═════════════════════════════╝/\n\n  / ══════ Fixed-precision constants ══════ /\n  uint256 public constant FLOAT_ISSUANCE_FIXED_DECIMAL = 1e42;\n  // 2^52 ~= 4.5e15\n  // With an exponent of 5, the largest total liquidity possible in a market (to avoid integer overflow on exponentiation) is ~10^31 or 10 Trillion (10^13)\n  // NOTE: this also means if the total market value is less than 2^52 there will be a division by zero error\n  uint256 public constant safeExponentBitShifting = 52;\n\n  / ══════ Global state ══════ /\n  address public admin;\n  address public floatCapital;\n  address public floatTreasury;\n  uint256 public floatPercentage;\n\n  address public longShort;\n  address public floatToken;\n\n  / ══════ Market specific ══════ /\n  mapping(uint32 =&gt; uint256) public marketLaunchIncentive_period; // seconds\n  mapping(uint32 =&gt; uint256) public marketLaunchIncentive_multipliers; // e18 scale\n  mapping(uint32 =&gt; uint256) public marketUnstakeFee_e18;\n  mapping(uint32 =&gt; uint256) public balanceIncentiveCurve_exponent;\n  mapping(uint32 =&gt; int256) public balanceIncentiveCurve_equilibriumOffset;\n\n  mapping(uint32 =&gt; mapping(bool =&gt; address)) public syntheticTokens;\n\n  mapping(address =&gt; uint32) public marketIndexOfToken;\n\n  / ══════ Reward specific ══════ /\n  mapping(uint32 =&gt; uint256) public latestRewardIndex;\n  mapping(uint32 =&gt; mapping(uint256 =&gt; AccumulativeIssuancePerStakedSynthSnapshot))\n    public accumulativeFloatPerSyntheticTokenSnapshots;\n  struct AccumulativeIssuancePerStakedSynthSnapshot {\n    uint256 timestamp;\n    uint256 accumulativeFloatPerSyntheticToken_long;\n    uint256 accumulativeFloatPerSyntheticToken_short;\n  }\n\n  / ══════ User specific ══════ /\n  mapping(uint32 =&gt; mapping(address =&gt; uint256)) public userIndexOfLastClaimedReward;\n  mapping(address =&gt; mapping(address =&gt; uint256)) public userAmountStaked;\n\n  / ══════ Token shift management specific ══════ /\n  mapping(uint32 =&gt; uint256) public batched_stakerNextTokenShiftIndex;\n  /\n  @notice Used to link a token shift to a staker state\n  @dev tokenShiftIndex =&gt; accumulativeFloatIssuanceSnapshotIndex\n    POSSIBLE OPTIMIZATION - could pack stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping and stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping into a struct of two uint128 for storage space optimization.\n  /\n  mapping(uint256 =&gt; uint256) public stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping;\n  /// @notice Used to fetch the price from LongShort at that point in time\n  /// @dev tokenShiftIndex =&gt; longShortMarketPriceSnapshotIndex\n  mapping(uint256 =&gt; uint256) public stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping;\n  /// @dev marketIndex =&gt; usersAddress =&gt; stakerTokenShiftIndex\n  mapping(uint32 =&gt; mapping(address =&gt; uint256)) public userNextPrice_stakedSyntheticTokenShiftIndex;\n  /// @dev marketIndex =&gt; usersAddress =&gt; amountUserRequestedToShiftAwayFromLongOnNextUpdate\n  mapping(uint32 =&gt; mapping(address =&gt; uint256)) public userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long;\n  /// @dev marketIndex =&gt; usersAddress =&gt; amountUserRequestedToShiftAwayFromShortOnNextUpdate\n  mapping(uint32 =&gt; mapping(address =&gt; uint256)) public userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short;\n\n  /╔════════════════════════════╗\n    ║           EVENTS           ║\n    ╚════════════════════════════╝/\n\n  event StakerV1(\n    address admin,\n    address floatTreasury,\n    address floatCapital,\n    address floatToken,\n    uint256 floatPercentage\n  );\n\n  event MarketAddedToStaker(\n    uint32 marketIndex,\n    uint256 exitFee_e18,\n    uint256 period,\n    uint256 multiplier,\n    uint256 balanceIncentiveExponent,\n    int256 balanceIncentiveEquilibriumOffset\n  );\n\n  event AccumulativeIssuancePerStakedSynthSnapshotCreated(\n    uint32 marketIndex,\n    uint256 accumulativeFloatIssuanceSnapshotIndex,\n    uint256 accumulativeLong,\n    uint256 accumulativeShort\n  );\n\n  event StakeAdded(address user, address token, uint256 amount, uint256 lastMintIndex);\n\n  event StakeWithdrawn(address user, address token, uint256 amount);\n\n  // Note: the amountFloatMinted isn\'t strictly needed by the graph, but it is good to add it to validate calculations are accurate.\n  event FloatMinted(address user, uint32 marketIndex, uint256 amountFloatMinted);\n\n  event MarketLaunchIncentiveParametersChanges(uint32 marketIndex, uint256 period, uint256 multiplier);\n\n  event StakeWithdrawalFeeUpdated(uint32 marketIndex, uint256 stakeWithdralFee);\n\n  event BalanceIncentiveExponentUpdated(uint32 marketIndex, uint256 balanceIncentiveExponent);\n\n  event BalanceIncentiveEquilibriumOffsetUpdated(uint32 marketIndex, int256 balanceIncentiveEquilibriumOffset);\n\n  event FloatPercentageUpdated(uint256 floatPercentage);\n\n  event SyntheticTokensShifted();\n\n  event ChangeAdmin(address newAdmin);\n\n  /╔═════════════════════════════╗\n    ║          MODIFIERS          ║\n    ╚═════════════════════════════╝/\n\n  function onlyAdminModifierLogic() internal virtual {\n    require(msg.sender == admin, "not admin");\n  }\n\n  modifier onlyAdmin() {\n    onlyAdminModifierLogic();\n    ;\n  }\n\n  function onlyValidSyntheticModifierLogic(address _synth) internal virtual {\n    require(marketIndexOfToken[_synth] != 0, "not valid synth");\n  }\n\n  modifier onlyValidSynthetic(address _synth) {\n    onlyValidSyntheticModifierLogic(_synth);\n    ;\n  }\n\n  function onlyValidMarketModifierLogic(uint32 marketIndex) internal virtual {\n    require(address(syntheticTokens[marketIndex][true]) != address(0), "not valid market");\n  }\n\n  modifier onlyValidMarket(uint32 marketIndex) {\n    onlyValidMarketModifierLogic(marketIndex);\n    ;\n  }\n\n  function onlyLongShortModifierLogic() internal virtual {\n    require(msg.sender == address(longShort), "not long short");\n  }\n\n  modifier onlyLongShort() {\n    onlyLongShortModifierLogic();\n    ;\n  }\n\n  /╔═════════════════════════════╗\n    ║       CONTRACT SET-UP       ║\n    ╚═════════════════════════════╝*/\n\n  /\n  @notice Initializes the contract.\n  @dev Calls OpenZeppelin\'s initializer modifier.\n  @param _admin Address of the admin role.\n  @param _longShort Address of the LongShort contract, a deployed LongShort.sol\n  @param _floatToken Address of the Float token earned by staking.\n  @param _floatTreasury Address of the treasury contract for managing fees.\n  @param _floatCapital Address of the contract which earns a fixed percentage of Float.\n  @param _floatPercentage Determines the float percentage that gets minted for Float Capital, base 1e18.\n  /\n  function initialize(\n    address _admin,\n    address _longShort,\n    address _floatToken,\n    address _floatTreasury,\n    address _floatCapital,\n    uint256 _floatPercentage\n  ) external virtual initializer {\n    admin = _admin;\n    floatCapital = _floatCapital;\n    floatTreasury = _floatTreasury;\n    longShort = _longShort;\n    floatToken = _floatToken;\n\n    _changeFloatPercentage(_floatPercentage);\n\n    emit StakerV1(_admin, _floatTreasury, _floatCapital, _floatToken, _floatPercentage);\n  }\n\n  /╔═══════════════════╗\n    ║       ADMIN       ║\n    ╚═══════════════════╝/\n\n  / \n  @notice Changes admin for the contract\n  @param _admin The address of the new admin.\n  /\n  function changeAdmin(address _admin) external onlyAdmin {\n    admin = _admin;\n    emit ChangeAdmin(_admin);\n  }\n\n  /// @dev Logic for changeFloatPercentage\n  function _changeFloatPercentage(uint256 newFloatPercentage) internal virtual {\n    require(newFloatPercentage &lt;= 1e18 &amp;&amp; newFloatPercentage &gt; 0); // less than or equal to 100% and greater than 0%\n    floatPercentage = newFloatPercentage;\n  }\n\n  /\n  @notice Changes percentage of float that is minted for float capital.\n  @param newFloatPercentage The new float percentage in base 1e18.\n  */\n  function changeFloatPercentage(uint256 newFloatPercentage) external onlyAdmin {\n    _changeFloatPercentage(newFloatPercentage);\n    emit FloatPercentageUpdated(newFloatPercentage);\n  }\n\n  /// @dev Logic for changeUnstakeFee\n  function _changeUnstakeFee(uint32 marketIndex, uint256 newMarketUnstakeFee_e18) internal virtual {\n    require(newMarketUnstakeFee_e18 &lt;= 5e16); // Explicitely stating 5% fee as the max fee possible.\n    marketUnstakeFee_e18[marketIndex] = newMarketUnstakeFee_e18;\n  }\n\n  /\n  @notice Changes unstake fee for a market\n  @param marketIndex Identifies the market.\n  @param newMarketUnstakeFee_e18 The new unstake fee.\n  /\n  function changeUnstakeFee(uint32 marketIndex, uint256 newMarketUnstakeFee_e18) external onlyAdmin {\n    _changeUnstakeFee(marketIndex, newMarketUnstakeFee_e18);\n    emit StakeWithdrawalFeeUpdated(marketIndex, newMarketUnstakeFee_e18);\n  }\n\n  /// @dev Logic for changeMarketLaunchIncentiveParameters\n  function _changeMarketLaunchIncentiveParameters(\n    uint32 marketIndex,\n    uint256 period,\n    uint256 initialMultiplier\n  ) internal virtual {\n    require(initialMultiplier &gt;= 1e18, "marketLaunchIncentiveMultiplier must be &gt;= 1e18");\n\n    marketLaunchIncentive_period[marketIndex] = period;\n    marketLaunchIncentive_multipliers[marketIndex] = initialMultiplier;\n  }\n\n  /\n  @notice Changes the market launch incentive parameters for a market\n  @param marketIndex Identifies the market.\n  @param period The new period for which float token generation should be boosted.\n  @param initialMultiplier The new multiplier on Float generation.\n  /\n  function changeMarketLaunchIncentiveParameters(\n    uint32 marketIndex,\n    uint256 period,\n    uint256 initialMultiplier\n  ) external onlyAdmin {\n    _changeMarketLaunchIncentiveParameters(marketIndex, period, initialMultiplier);\n\n    emit MarketLaunchIncentiveParametersChanges(marketIndex, period, initialMultiplier);\n  }\n\n  /// @dev Logic for changeBalanceIncentiveExponent\n  function _changeBalanceIncentiveExponent(uint32 marketIndex, uint256 _balanceIncentiveCurve_exponent)\n    internal\n    virtual\n  {\n    require(\n      // The exponent has to be less than 5 in these versions of the contracts.\n      _balanceIncentiveCurve_exponent &gt; 0 &amp;&amp; _balanceIncentiveCurve_exponent &lt; 6,\n      "balanceIncentiveCurve_exponent out of bounds"\n    );\n\n    balanceIncentiveCurve_exponent[marketIndex] = _balanceIncentiveCurve_exponent;\n  }\n\n  / \n  @notice Changes the balance incentive exponent for a market\n  @param marketIndex Identifies the market.\n  @param _balanceIncentiveCurve_exponent The new exponent for the curve.\n  */\n  function changeBalanceIncentiveExponent(uint32 marketIndex, uint256 _balanceIncentiveCurve_exponent)\n    external\n    onlyAdmin\n  {\n    _changeBalanceIncentiveExponent(marketIndex, _balanceIncentiveCurve_exponent);\n\n    emit BalanceIncentiveExponentUpdated(marketIndex, _balanceIncentiveCurve_exponent);\n  }\n\n  /// @dev Logic for changeBalanceIncentiveEquilibriumOffset\n  function _changeBalanceIncentiveEquilibriumOffset(uint32 marketIndex, int256 _balanceIncentiveCurve_equilibriumOffset)\n    internal\n    virtual\n  {\n    // Unreasonable that we would ever shift this more than 90% either way\n    require(\n      _balanceIncentiveCurve_equilibriumOffset &gt; -9e17 &amp;&amp; _balanceIncentiveCurve_equilibriumOffset &lt; 9e17,\n      "balanceIncentiveCurve_equilibriumOffset out of bounds"\n    );\n\n    balanceIncentiveCurve_equilibriumOffset[marketIndex] = _balanceIncentiveCurve_equilibriumOffset;\n  }\n\n  /\n  @notice Changes the balance incentive curve equilibrium offset for a market\n  @param marketIndex Identifies the market.\n  @param _balanceIncentiveCurve_equilibriumOffset The new offset.\n  /\n  function changeBalanceIncentiveEquilibriumOffset(uint32 marketIndex, int256 _balanceIncentiveCurve_equilibriumOffset)\n    external\n    onlyAdmin\n  {\n    _changeBalanceIncentiveEquilibriumOffset(marketIndex, _balanceIncentiveCurve_equilibriumOffset);\n\n    emit BalanceIncentiveEquilibriumOffsetUpdated(marketIndex, _balanceIncentiveCurve_equilibriumOffset);\n  }\n\n  /╔═════════════════════════════╗\n    ║        STAKING SETUP        ║\n    ╚═════════════════════════════╝/\n\n  /\n  @notice Sets this contract to track staking for a market in LongShort.sol\n  @param marketIndex Identifies the market.\n  @param longToken Address of the long token for the market.\n  @param shortToken Address of the short token for the market.\n  @param kInitialMultiplier Initial boost on float generation for the market.\n  @param kPeriod Period which the boost should last.\n  @param unstakeFee_e18 Percentage of tokens that are levied on unstaking in base 1e18.\n  @param _balanceIncentiveCurve_exponent Exponent for balance curve (see _calculateFloatPerSecond)\n  @param _balanceIncentiveCurve_equilibriumOffset Offset for balance curve (see _calculateFloatPerSecond)\n  /\n  function addNewStakingFund(\n    uint32 marketIndex,\n    address longToken,\n    address shortToken,\n    uint256 kInitialMultiplier,\n    uint256 kPeriod,\n    uint256 unstakeFee_e18,\n    uint256 _balanceIncentiveCurve_exponent,\n    int256 _balanceIncentiveCurve_equilibriumOffset\n  ) external override onlyLongShort {\n    marketIndexOfToken[longToken] = marketIndex;\n    marketIndexOfToken[shortToken] = marketIndex;\n\n    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].timestamp = block.timestamp;\n    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].accumulativeFloatPerSyntheticToken_long = 0;\n    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].accumulativeFloatPerSyntheticToken_short = 0;\n\n    syntheticTokens[marketIndex][true] = longToken;\n    syntheticTokens[marketIndex][false] = shortToken;\n\n    _changeBalanceIncentiveExponent(marketIndex, _balanceIncentiveCurve_exponent);\n    _changeBalanceIncentiveEquilibriumOffset(marketIndex, _balanceIncentiveCurve_equilibriumOffset);\n    _changeMarketLaunchIncentiveParameters(marketIndex, kPeriod, kInitialMultiplier);\n\n    _changeUnstakeFee(marketIndex, unstakeFee_e18);\n\n    // Set this value to one initially - 0 is a null value and thus potentially bug prone.\n    batched_stakerNextTokenShiftIndex[marketIndex] = 1;\n\n    emit MarketAddedToStaker(\n      marketIndex,\n      unstakeFee_e18,\n      kPeriod,\n      kInitialMultiplier,\n      _balanceIncentiveCurve_exponent,\n      _balanceIncentiveCurve_equilibriumOffset\n    );\n\n    emit AccumulativeIssuancePerStakedSynthSnapshotCreated(marketIndex, 0, 0, 0);\n  }\n\n  /╔═════════════════════════════════════════════════════════════════════════╗\n    ║    GLOBAL FLT REWARD ACCUMULATION CALCULATION AND TRACKING FUNCTIONS    ║\n    ╚═════════════════════════════════════════════════════════════════════════╝/\n\n  /\n  @notice Returns the K factor parameters for the given market with sensible\n  defaults if they haven\'t been set yet.\n  @param marketIndex The market to change the parameters for.\n  @return period The period for which the k factor applies for in seconds.\n  @return multiplier The multiplier on Float generation in this period.\n  */\n  function _getMarketLaunchIncentiveParameters(uint32 marketIndex)\n    internal\n    view\n    virtual\n    returns (uint256 period, uint256 multiplier)\n  {\n    period = marketLaunchIncentive_period[marketIndex];\n    multiplier = marketLaunchIncentive_multipliers[marketIndex];\n\n    if (multiplier &lt; 1e18) {\n      multiplier = 1e18; // multiplier of 1 by default\n    }\n  }\n\n  / \n  @notice Returns the extent to which a markets float generation should be adjusted\n  based on the market\'s launch incentive parameters. Should start at multiplier\n  then linearly change to 1e18 over time.\n  @param marketIndex Identifies the market.\n  @return k The calculated modifier for float generation.\n  /\n  function _getKValue(uint32 marketIndex) internal view virtual returns (uint256) {\n    // Parameters controlling the float issuance multiplier.\n    (uint256 kPeriod, uint256 kInitialMultiplier) = _getMarketLaunchIncentiveParameters(marketIndex);\n\n    // Sanity check - under normal circumstances, the multipliers should\n    // never be set to a value &lt; 1e18, as there are guards against this.\n    assert(kInitialMultiplier &gt;= 1e18);\n\n    uint256 initialTimestamp = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].timestamp;\n\n    if (block.timestamp - initialTimestamp &lt;= kPeriod) {\n      return kInitialMultiplier - (((kInitialMultiplier - 1e18) * (block.timestamp - initialTimestamp)) / kPeriod);\n    } else {\n      return 1e18;\n    }\n  }\n\n  /\n  @notice Computes the number of float tokens a user earns per second for\n  every long/short synthetic token they\'ve staked. The returned value has\n  a fixed decimal scale of 1e42 (!!!) for numerical stability. The return\n  values are float per second per synthetic token (hence the requirement\n  to multiply by price)\n  @dev to see below math in latex form see TODO add link\n  to interact with the equations see https://www.desmos.com/calculator/optkaxyihr\n  @param marketIndex The market referred to.\n  @param longPrice Price of the synthetic long token in units of payment token\n  @param shortPrice Price of the synthetic short token in units of payment token\n  @param longValue Amount of payment token in the long side of the market\n  @param shortValue Amount of payment token in the short side of the market\n  @return longFloatPerSecond Float token per second per long synthetic token\n  @return shortFloatPerSecond Float token per second per short synthetic token\n   /\n  function _calculateFloatPerSecond(\n    uint32 marketIndex,\n    uint256 longPrice,\n    uint256 shortPrice,\n    uint256 longValue,\n    uint256 shortValue\n  ) internal view virtual returns (uint256 longFloatPerSecond, uint256 shortFloatPerSecond) {\n    // A float issuance multiplier that starts high and decreases linearly\n    // over time to a value of 1. This incentivises users to stake early.\n    uint256 k = _getKValue(marketIndex);\n\n    uint256 totalLocked = (longValue + shortValue);\n\n    // we need to scale this number by the totalLocked so that the offset remains consistent accross market size\n\n    int256 equilibriumOffsetMarketScaled = (balanceIncentiveCurve_equilibriumOffset[marketIndex] \n      int256(totalLocked)) / 2e18;\n\n    uint256 denominator = ((totalLocked &gt;&gt; safeExponentBitShifting)balanceIncentiveCurve_exponent[marketIndex]);\n\n    // Float is scaled by the percentage of the total market value held in\n    // the opposite position. This incentivises users to stake on the\n    // weaker position.\n    if (int256(shortValue) - equilibriumOffsetMarketScaled &lt; int256(longValue)) {\n      if (equilibriumOffsetMarketScaled &gt;= int256(shortValue)) {\n        // edge case: imbalanced far past the equilibrium offset - full rewards go to short token\n        //            extremeley unlikely to happen in practice\n        return (0, 1e18 * k * shortPrice);\n      }\n\n      uint256 numerator = (uint256(int256(shortValue) - equilibriumOffsetMarketScaled) &gt;&gt;\n        (safeExponentBitShifting - 1))balanceIncentiveCurve_exponent[marketIndex];\n\n      // NOTE: x * 5e17 == (x * 10e18) / 2\n      uint256 longRewardUnscaled = (numerator * 5e17) / denominator;\n      uint256 shortRewardUnscaled = 1e18 - longRewardUnscaled;\n\n      return ((longRewardUnscaled * k * longPrice) / 1e18, (shortRewardUnscaled * k * shortPrice) / 1e18);\n    } else {\n      if (-equilibriumOffsetMarketScaled &gt;= int256(longValue)) {\n        // edge case: imbalanced far past the equilibrium offset - full rewards go to long token\n        //            extremeley unlikely to happen in practice\n        return (1e18 * k * longPrice, 0);\n      }\n\n      uint256 numerator = (uint256(int256(longValue) + equilibriumOffsetMarketScaled) &gt;&gt;\n        (safeExponentBitShifting - 1))balanceIncentiveCurve_exponent[marketIndex];\n\n      // NOTE: x * 5e17 == (x * 10e18) / 2\n      uint256 shortRewardUnscaled = (numerator * 5e17) / denominator;\n      uint256 longRewardUnscaled = 1e18 - shortRewardUnscaled;\n\n      return ((longRewardUnscaled * k * longPrice) / 1e18, (shortRewardUnscaled * k * shortPrice) / 1e18);\n    }\n  }\n\n  /\n  @notice Computes the time since last accumulativeIssuancePerStakedSynthSnapshot for the given market in seconds.\n  @param marketIndex The market referred to.\n  @return The time difference in seconds\n  /\n  function _calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(uint32 marketIndex)\n    internal\n    view\n    virtual\n    returns (uint256)\n  {\n    return\n      block.timestamp -\n      accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]].timestamp;\n  }\n\n  /\n  @notice Computes new cumulative sum of \'r\' value since last accumulativeIssuancePerStakedSynthSnapshot. We use\n  cumulative \'r\' value to avoid looping during issuance. Note that the\n  cumulative sum is kept in 1e42 scale (!!!) to avoid numerical issues.\n  @param shortValue The value locked in the short side of the market.\n  @param longValue The value locked in the long side of the market.\n  @param shortPrice The price of the short token as defined in LongShort.sol\n  @param longPrice The price of the long token as defined in LongShort.sol\n  @param marketIndex An identifier for the market.\n  @return longCumulativeRates The long cumulative sum.\n  @return shortCumulativeRates The short cumulative sum.\n  /\n  function _calculateNewCumulativeIssuancePerStakedSynth(\n    uint32 marketIndex,\n    uint256 longPrice,\n    uint256 shortPrice,\n    uint256 longValue,\n    uint256 shortValue\n  ) internal view virtual returns (uint256 longCumulativeRates, uint256 shortCumulativeRates) {\n    // Compute the current \'r\' value for float issuance per second.\n    (uint256 longFloatPerSecond, uint256 shortFloatPerSecond) = _calculateFloatPerSecond(\n      marketIndex,\n      longPrice,\n      shortPrice,\n      longValue,\n      shortValue\n    );\n\n    // Compute time since last accumulativeIssuancePerStakedSynthSnapshot for the given token.\n    uint256 timeDelta = _calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(marketIndex);\n\n    // Compute new cumulative \'r\' value total.\n    return (\n      accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]]\n      .accumulativeFloatPerSyntheticToken_long + (timeDelta * longFloatPerSecond),\n      accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]]\n      .accumulativeFloatPerSyntheticToken_short + (timeDelta * shortFloatPerSecond)\n    );\n  }\n\n  /\n  @notice Creates a new accumulativeIssuancePerStakedSynthSnapshot for the given token and updates indexes.\n  @param shortValue The value locked in the short side of the market.\n  @param longValue The value locked in the long side of the market.\n  @param shortPrice The price of the short token as defined in LongShort.sol\n  @param longPrice The price of the long token as defined in LongShort.sol\n  @param marketIndex An identifier for the market.\n  */\n  function _setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot(\n    uint32 marketIndex,\n    uint256 longPrice,\n    uint256 shortPrice,\n    uint256 longValue,\n    uint256 shortValue\n  ) internal virtual {\n    (\n      uint256 newLongAccumulativeValue,\n      uint256 newShortAccumulativeValue\n    ) = _calculateNewCumulativeIssuancePerStakedSynth(marketIndex, longPrice, shortPrice, longValue, shortValue);\n\n    uint256 newIndex = latestRewardIndex[marketIndex] + 1;\n\n    // Set cumulative \'r\' value on new accumulativeIssuancePerStakedSynthSnapshot.\n    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex]\n    .accumulativeFloatPerSyntheticToken_long = newLongAccumulativeValue;\n    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex]\n    .accumulativeFloatPerSyntheticToken_short = newShortAccumulativeValue;\n\n    // Set timestamp on new accumulativeIssuancePerStakedSynthSnapshot.\n    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex].timestamp = block.timestamp;\n\n    // Update latest index to point to new accumulativeIssuancePerStakedSynthSnapshot.\n    latestRewardIndex[marketIndex] = newIndex;\n\n    emit AccumulativeIssuancePerStakedSynthSnapshotCreated(\n      marketIndex,\n      newIndex,\n      newLongAccumulativeValue,\n      newShortAccumulativeValue\n    );\n  }\n\n  /\n  @notice Adds new accumulativeIssuancePerStakedSynthSnapshots for the given long/short tokens. Called by the\n  ILongShort contract whenever there is a state change for a market.\n  @param stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted Mapping from this contract\'s shifts to LongShort.sols next price snapshots.\n  @param shortValue The value locked in the short side of the market.\n  @param longValue The value locked in the long side of the market.\n  @param shortPrice The price of the short token as defined in LongShort.sol\n  @param longPrice The price of the long token as defined in LongShort.sol\n  @param marketIndex An identifier for the market.\n  /\n  function pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(\n    uint32 marketIndex,\n    uint256 longPrice,\n    uint256 shortPrice,\n    uint256 longValue,\n    uint256 shortValue,\n    uint256 stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted // This value should be ALWAYS be zero if no shift occured\n  ) external override onlyLongShort {\n    // Only add a new accumulativeIssuancePerStakedSynthSnapshot if some time has passed.\n\n    // the stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted value will be 0 if there is no staker related action in an executed batch\n    if (stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted &gt; 0) {\n      stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[\n        batched_stakerNextTokenShiftIndex[marketIndex]\n      ] = stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted;\n      stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[\n        batched_stakerNextTokenShiftIndex[marketIndex]\n      ] = latestRewardIndex[marketIndex] + 1;\n      batched_stakerNextTokenShiftIndex[marketIndex] += 1;\n\n      emit SyntheticTokensShifted();\n    }\n\n    // Time delta is fetched twice in below code, can pass through? Which is less gas?\n    if (_calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(marketIndex) &gt; 0) {\n      _setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot(\n        marketIndex,\n        longPrice,\n        shortPrice,\n        longValue,\n        shortValue\n      );\n    }\n  }\n\n  /╔═══════════════════════════════════╗\n    ║    USER REWARD STATE FUNCTIONS    ║\n    ╚═══════════════════════════════════╝/\n\n  /// @dev Calculates the accumulated float in a specific range of staker snapshots\n  function _calculateAccumulatedFloatInRange(\n    uint32 marketIndex,\n    uint256 amountStakedLong,\n    uint256 amountStakedShort,\n    uint256 rewardIndexFrom,\n    uint256 rewardIndexTo\n  ) internal view virtual returns (uint256 floatReward) {\n    if (amountStakedLong &gt; 0) {\n      uint256 accumDeltaLong = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexTo]\n      .accumulativeFloatPerSyntheticToken_long -\n        accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexFrom]\n        .accumulativeFloatPerSyntheticToken_long;\n      floatReward += (accumDeltaLong * amountStakedLong) / FLOAT_ISSUANCE_FIXED_DECIMAL;\n    }\n\n    if (amountStakedShort &gt; 0) {\n      uint256 accumDeltaShort = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexTo]\n      .accumulativeFloatPerSyntheticToken_short -\n        accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexFrom]\n        .accumulativeFloatPerSyntheticToken_short;\n      floatReward += (accumDeltaShort * amountStakedShort) / FLOAT_ISSUANCE_FIXED_DECIMAL;\n    }\n  }\n\n  / \n  @notice Calculates float owed to the user since the user last minted float for a market.\n  @param marketIndex Identifier for the market which the user staked in.\n  @param user The address of the user.\n  @return floatReward The amount of float owed.\n   /\n  function _calculateAccumulatedFloat(uint32 marketIndex, address user) internal virtual returns (uint256 floatReward) {\n    address longToken = syntheticTokens[marketIndex][true];\n    address shortToken = syntheticTokens[marketIndex][false];\n\n    uint256 amountStakedLong = userAmountStaked[longToken][user];\n    uint256 amountStakedShort = userAmountStaked[shortToken][user];\n\n    uint256 usersLastRewardIndex = userIndexOfLastClaimedReward[marketIndex][user];\n\n    // Don\'t do the calculation and return zero immediately if there is no change\n    if (usersLastRewardIndex == latestRewardIndex[marketIndex]) {\n      return 0;\n    }\n\n    uint256 usersShiftIndex = userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][user];\n    // if there is a change in the users tokens held due to a token shift (or possibly another action in the future)\n    if (usersShiftIndex &gt; 0 &amp;&amp; usersShiftIndex &lt; batched_stakerNextTokenShiftIndex[marketIndex]) {\n      floatReward = _calculateAccumulatedFloatInRange(\n        marketIndex,\n        amountStakedLong,\n        amountStakedShort,\n        usersLastRewardIndex,\n        stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[usersShiftIndex]\n      );\n\n      // Update the users balances\n      if (userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user] &gt; 0) {\n        amountStakedShort += ILongShort(longShort).getAmountSyntheticTokenToMintOnTargetSide(\n          marketIndex,\n          userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user],\n          true,\n          stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[usersShiftIndex]\n        );\n\n        amountStakedLong -= userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user];\n        userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user] = 0;\n      }\n\n      if (userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user] &gt; 0) {\n        amountStakedLong += ILongShort(longShort).getAmountSyntheticTokenToMintOnTargetSide(\n          marketIndex,\n          userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user],\n          false,\n          stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[usersShiftIndex]\n        );\n\n        amountStakedShort -= userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user];\n        userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user] = 0;\n      }\n\n      // Save the users updated staked amounts\n      userAmountStaked[longToken][user] = amountStakedLong;\n      userAmountStaked[shortToken][user] = amountStakedShort;\n\n      floatReward += _calculateAccumulatedFloatInRange(\n        marketIndex,\n        amountStakedLong,\n        amountStakedShort,\n        stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[usersShiftIndex],\n        latestRewardIndex[marketIndex]\n      );\n\n      userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][user] = 0;\n    } else {\n      floatReward = _calculateAccumulatedFloatInRange(\n        marketIndex,\n        amountStakedLong,\n        amountStakedShort,\n        usersLastRewardIndex,\n        latestRewardIndex[marketIndex]\n      );\n    }\n  }\n\n  /\n  @notice Mints float for a user.\n  @dev Mints a fixed percentage for Float capital.\n  @param user The address of the user.\n  @param floatToMint The amount of float to mint.\n   */\n  function _mintFloat(address user, uint256 floatToMint) internal virtual {\n    IFloatToken(floatToken).mint(user, floatToMint);\n    IFloatToken(floatToken).mint(floatCapital, (floatToMint * floatPercentage) / 1e18);\n  }\n\n  /\n  @notice Mints float owed to a user for a market since they last minted.\n  @param marketIndex An identifier for the market.\n  @param user The address of the user.\n   /\n  function _mintAccumulatedFloat(uint32 marketIndex, address user) internal virtual {\n    uint256 floatToMint = _calculateAccumulatedFloat(marketIndex, user);\n\n    if (floatToMint &gt; 0) {\n      // Set the user has claimed up until now, stops them setting this forward\n      userIndexOfLastClaimedReward[marketIndex][user] = latestRewardIndex[marketIndex];\n\n      _mintFloat(user, floatToMint);\n      emit FloatMinted(user, marketIndex, floatToMint);\n    }\n  }\n\n  /\n  @notice Mints float owed to a user for multiple markets, since they last minted for those markets.\n  @param marketIndexes Identifiers for the markets.\n  @param user The address of the user.\n   /\n  function _mintAccumulatedFloatMulti(uint32[] calldata marketIndexes, address user) internal virtual {\n    uint256 floatTotal = 0;\n    for (uint256 i = 0; i &lt; marketIndexes.length; i++) {\n      uint256 floatToMint = _calculateAccumulatedFloat(marketIndexes[i], user);\n\n      if (floatToMint &gt; 0) {\n        // Set the user has claimed up until now, stops them setting this forward\n        userIndexOfLastClaimedReward[marketIndexes[i]][user] = latestRewardIndex[marketIndexes[i]];\n\n        floatTotal += floatToMint;\n\n        emit FloatMinted(user, marketIndexes[i], floatToMint);\n      }\n    }\n    if (floatTotal &gt; 0) {\n      _mintFloat(user, floatTotal);\n    }\n  }\n\n  /\n  @notice Mints outstanding float for msg.sender.\n  @param marketIndexes Identifiers for the markets for which to mint float.\n   */\n  function claimFloatCustom(uint32[] calldata marketIndexes) external {\n    ILongShort(longShort).updateSystemStateMulti(marketIndexes);\n    _mintAccumulatedFloatMulti(marketIndexes, msg.sender);\n  }\n\n  /\n  @notice Mints outstanding float on behalf of another user.\n  @param marketIndexes Identifiers for the markets for which to mint float.\n  @param user The address of the user.\n   /\n  function claimFloatCustomFor(uint32[] calldata marketIndexes, address user) external {\n    // Unbounded loop - users are responsible for paying their own gas costs on these and it doesn\'t effect the rest of the system.\n    // No need to impose limit.\n    ILongShort(longShort).updateSystemStateMulti(marketIndexes);\n    _mintAccumulatedFloatMulti(marketIndexes, user);\n  }\n\n  /╔═══════════════════════╗\n    ║        STAKING        ║\n    ╚═══════════════════════╝/\n\n  /\n  @notice A user with synthetic tokens stakes by calling stake on the token\n  contract which calls this function. We need to first update the\n  state of the LongShort contract for this market before staking to correctly calculate user rewards.\n  @param amount Amount to stake.\n  @param from Address to stake for.\n  /\n  function stakeFromUser(address from, uint256 amount) public virtual override onlyValidSynthetic((msg.sender)) {\n    ILongShort(longShort).updateSystemState(marketIndexOfToken[(msg.sender)]);\n    _stake((msg.sender), amount, from);\n  }\n\n  /\n  @dev Internal logic for staking.\n  @param token Address of the token for which to stake.\n  @param amount Amount to stake.\n  @param user Address to stake for.\n  */\n  function _stake(\n    address token,\n    uint256 amount,\n    address user\n  ) internal virtual {\n    uint32 marketIndex = marketIndexOfToken[token];\n\n    // If they already have staked and have rewards due, mint these.\n    if (\n      userIndexOfLastClaimedReward[marketIndex][user] != 0 &amp;&amp;\n      userIndexOfLastClaimedReward[marketIndex][user] &lt; latestRewardIndex[marketIndex]\n    ) {\n      _mintAccumulatedFloat(marketIndex, user);\n    }\n\n    userAmountStaked[token][user] = userAmountStaked[token][user] + amount;\n\n    userIndexOfLastClaimedReward[marketIndex][user] = latestRewardIndex[marketIndex];\n\n    emit StakeAdded(user, address(token), amount, userIndexOfLastClaimedReward[marketIndex][user]);\n  }\n\n  /\n  @notice Allows users to shift their staked tokens from one side of the market to \n  the other at the next price.\n  @param amountSyntheticTokensToShift Amount of tokens to shift.\n  @param marketIndex Identifier for the market.\n  @param isShiftFromLong Whether the shift is from long to short or short to long.\n  /\n  function shiftTokens(\n    uint256 amountSyntheticTokensToShift,\n    uint32 marketIndex,\n    bool isShiftFromLong\n  ) external virtual {\n    address token = syntheticTokens[marketIndex][isShiftFromLong];\n    require(userAmountStaked[token][msg.sender] &gt;= amountSyntheticTokensToShift, "Not enough tokens to shift");\n\n    // If the user has outstanding token shift that have already been confirmed in the LongShort\n    // contract, execute them first.\n    if (\n      userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] != 0 &amp;&amp;\n      userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] &lt;\n      batched_stakerNextTokenShiftIndex[marketIndex]\n    ) {\n      _mintAccumulatedFloat(marketIndex, msg.sender);\n    }\n\n    if (isShiftFromLong) {\n      ILongShort(longShort).shiftPositionFromLongNextPrice(marketIndex, amountSyntheticTokensToShift);\n      userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][\n        msg.sender\n      ] += amountSyntheticTokensToShift;\n    } else {\n      ILongShort(longShort).shiftPositionFromShortNextPrice(marketIndex, amountSyntheticTokensToShift);\n      userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][\n        msg.sender\n      ] += amountSyntheticTokensToShift;\n    }\n\n    userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] = batched_stakerNextTokenShiftIndex[\n      marketIndex\n    ];\n  }\n\n  /╔════════════════════════════╗\n    ║    WITHDRAWAL &amp; MINTING    ║\n    ╚════════════════════════════╝/\n\n  /\n  @notice Internal logic for withdrawing stakes.\n  @dev Mint user any outstanding float before withdrawing.\n  @param marketIndex Market index of token.\n  @param amount Amount to withdraw.\n  @param token Synthetic token that was staked.\n  /\n  function _withdraw(\n    uint32 marketIndex,\n    address token,\n    uint256 amount\n  ) internal virtual {\n    require(userAmountStaked[token][msg.sender] &gt; 0, "nothing to withdraw");\n    _mintAccumulatedFloat(marketIndex, msg.sender);\n\n    userAmountStaked[token][msg.sender] = userAmountStaked[token][msg.sender] - amount;\n\n    uint256 amountFees = (amount * marketUnstakeFee_e18[marketIndex]) / 1e18;\n\n    IERC20(token).transfer(floatTreasury, amountFees);\n    IERC20(token).transfer(msg.sender, amount - amountFees);\n\n    emit StakeWithdrawn(msg.sender, token, amount);\n  }\n\n  /\n  @notice Withdraw function. Allows users to unstake.\n  @param amount Amount to withdraw.\n  @param token Address of the token for which to withdraw.\n  */\n  function withdraw(address token, uint256 amount) external {\n    ILongShort(longShort).updateSystemState(marketIndexOfToken[token]);\n\n    uint32 marketIndex = marketIndexOfToken[token];\n\n    _withdraw(marketIndex, token, amount);\n\n    if (userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] &gt; 0) {\n      // If they still have outstanding shifts after minting float, then check\n      // that they don\'t withdraw more than their shifts allow.\n      uint256 amountToShiftForThisToken = syntheticTokens[marketIndex][true] == token\n        ? userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][msg.sender]\n        : userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][msg.sender];\n\n      require(\n        userAmountStaked[token][msg.sender] &gt;= amountToShiftForThisToken,\n        "Outstanding next price stake shifts too great"\n      );\n    }\n  }\n\n  /\n  @notice Allows users to withdraw their entire stake for a token.\n  @param token Address of the token for which to withdraw.\n  */\n  function withdrawAll(address token) external {\n    ILongShort(longShort).updateSystemState(marketIndexOfToken[token]);\n\n    uint32 marketIndex = marketIndexOfToken[token];\n\n    uint256 amountToShiftForThisToken = syntheticTokens[marketIndex][true] == token\n      ? userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][msg.sender]\n      : userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][msg.sender];\n\n    _withdraw(marketIndex, token, userAmountStaked[token][msg.sender] - amountToShiftForThisToken);\n  }\n}\n', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-17-08 08:01:54 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: BUSL-1.1 pragma solidity 0.8.3; import "@openzeppelin/contracts-upgradeable/token/ERC20/presets/ERC20PresetMinterPauserUpgradeable.sol"; import "./interfaces/IFloatToken.sol"; import "./interfaces/ILongShort.sol"; import "./interfaces/IStaker.sol"; import "./interfaces/ISyntheticToken.sol"; contract Staker is IStaker, Initializable {   /╔═════════════════════════════╗     ║          VARIABLES          ║     ╚═════════════════════════════╝/ / ══════ Fixed-precision constants ══════ /   uint256 public constant FLOAT_ISSUANCE_FIXED_DECIMAL = 1e42;   // 2^52 ~= 4.5e15   // With an exponent of 5, the largest total liquidity possible in a market (to avoid integer overflow on exponentiation) is ~10^31 or 10 Trillion (10^13)   // NOTE: this also means if the total market value is less than 2^52 there will be a division by zero error   uint256 public constant safeExponentBitShifting = 52; / ══════ Global state ══════ /   address public admin;   address public floatCapital;   address public floatTreasury;   uint256 public floatPercentage; address public longShort;   address public floatToken; / ══════ Market specific ══════ /   mapping(uint32 =&gt; uint256) public marketLaunchIncentive_period; // seconds   mapping(uint32 =&gt; uint256) public marketLaunchIncentive_multipliers; // e18 scale   mapping(uint32 =&gt; uint256) public marketUnstakeFee_e18;   mapping(uint32 =&gt; uint256) public balanceIncentiveCurve_exponent;   mapping(uint32 =&gt; int256) public balanceIncentiveCurve_equilibriumOffset; mapping(uint32 =&gt; mapping(bool =&gt; address)) public syntheticTokens; mapping(address =&gt; uint32) public marketIndexOfToken; / ══════ Reward specific ══════ /   mapping(uint32 =&gt; uint256) public latestRewardIndex;   mapping(uint32 =&gt; mapping(uint256 =&gt; AccumulativeIssuancePerStakedSynthSnapshot))     public accumulativeFloatPerSyntheticTokenSnapshots;   struct AccumulativeIssuancePerStakedSynthSnapshot {     uint256 timestamp;     uint256 accumulativeFloatPerSyntheticToken_long;     uint256 accumulativeFloatPerSyntheticToken_short;   } / ══════ User specific ══════ /   mapping(uint32 =&gt; mapping(address =&gt; uint256)) public userIndexOfLastClaimedReward;   mapping(address =&gt; mapping(address =&gt; uint256)) public userAmountStaked; / ══════ Token shift management specific ══════ /   mapping(uint32 =&gt; uint256) public batched_stakerNextTokenShiftIndex;   /*   @notice Used to link a token shift to a staker state   @dev tokenShiftIndex =&gt; accumulativeFloatIssuanceSnapshotIndex     POSSIBLE OPTIMIZATION - could pack stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping and stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping into a struct of two uint128 for storage space optimization.   /   mapping(uint256 =&gt; uint256) public stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping;   /// @notice Used to fetch the price from LongShort at that point in time   /// @dev tokenShiftIndex =&gt; longShortMarketPriceSnapshotIndex   mapping(uint256 =&gt; uint256) public stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping;   /// @dev marketIndex =&gt; usersAddress =&gt; stakerTokenShiftIndex   mapping(uint32 =&gt; mapping(address =&gt; uint256)) public userNextPrice_stakedSyntheticTokenShiftIndex;   /// @dev marketIndex =&gt; usersAddress =&gt; amountUserRequestedToShiftAwayFromLongOnNextUpdate   mapping(uint32 =&gt; mapping(address =&gt; uint256)) public userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long;   /// @dev marketIndex =&gt; usersAddress =&gt; amountUserRequestedToShiftAwayFromShortOnNextUpdate   mapping(uint32 =&gt; mapping(address =&gt; uint256)) public userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short; /╔════════════════════════════╗     ║           EVENTS           ║     ╚════════════════════════════╝/ event StakerV1(     address admin,     address floatTreasury,     address floatCapital,     address floatToken,     uint256 floatPercentage   ); event MarketAddedToStaker(     uint32 marketIndex,     uint256 exitFee_e18,     uint256 period,     uint256 multiplier,     uint256 balanceIncentiveExponent,     int256 balanceIncentiveEquilibriumOffset   ); event AccumulativeIssuancePerStakedSynthSnapshotCreated(     uint32 marketIndex,     uint256 accumulativeFloatIssuanceSnapshotIndex,     uint256 accumulativeLong,     uint256 accumulativeShort   ); event StakeAdded(address user, address token, uint256 amount, uint256 lastMintIndex); event StakeWithdrawn(address user, address token, uint256 amount); // Note: the amountFloatMinted isn't strictly needed by the graph, but it is good to add it to validate calculations are accurate.   event FloatMinted(address user, uint32 marketIndex, uint256 amountFloatMinted); event MarketLaunchIncentiveParametersChanges(uint32 marketIndex, uint256 period, uint256 multiplier); event StakeWithdrawalFeeUpdated(uint32 marketIndex, uint256 stakeWithdralFee); event BalanceIncentiveExponentUpdated(uint32 marketIndex, uint256 balanceIncentiveExponent); event BalanceIncentiveEquilibriumOffsetUpdated(uint32 marketIndex, int256 balanceIncentiveEquilibriumOffset); event FloatPercentageUpdated(uint256 floatPercentage); event SyntheticTokensShifted(); event ChangeAdmin(address newAdmin); /╔═════════════════════════════╗     ║          MODIFIERS          ║     ╚═════════════════════════════╝/ function onlyAdminModifierLogic() internal virtual {     require(msg.sender == admin, "not admin");   } modifier onlyAdmin() {     onlyAdminModifierLogic();     _;   } function onlyValidSyntheticModifierLogic(address _synth) internal virtual {     require(marketIndexOfToken[_synth] != 0, "not valid synth");   } modifier onlyValidSynthetic(address synth) {     onlyValidSyntheticModifierLogic(_synth);     ;   } function onlyValidMarketModifierLogic(uint32 marketIndex) internal virtual {     require(address(syntheticTokens[marketIndex][true]) != address(0), "not valid market");   } modifier onlyValidMarket(uint32 marketIndex) {     onlyValidMarketModifierLogic(marketIndex);     _;   } function onlyLongShortModifierLogic() internal virtual {     require(msg.sender == address(longShort), "not long short");   } modifier onlyLongShort() {     onlyLongShortModifierLogic();     _;   } /╔═════════════════════════════╗     ║       CONTRACT SET-UP       ║     ╚═════════════════════════════╝/ /*   @notice Initializes the contract.   @dev Calls OpenZeppelin's initializer modifier.   @param _admin Address of the admin role.   @param _longShort Address of the LongShort contract, a deployed LongShort.sol   @param _floatToken Address of the Float token earned by staking.   @param _floatTreasury Address of the treasury contract for managing fees.   @param _floatCapital Address of the contract which earns a fixed percentage of Float.   @param _floatPercentage Determines the float percentage that gets minted for Float Capital, base 1e18.   /   function initialize(     address _admin,     address _longShort,     address _floatToken,     address _floatTreasury,     address _floatCapital,     uint256 _floatPercentage   ) external virtual initializer {     admin = _admin;     floatCapital = _floatCapital;     floatTreasury = _floatTreasury;     longShort = _longShort;     floatToken = _floatToken; _changeFloatPercentage(_floatPercentage);  emit StakerV1(_admin, _floatTreasury, _floatCapital, _floatToken, _floatPercentage);  } /╔═══════════════════╗     ║       ADMIN       ║     ╚═══════════════════╝/ /*    @notice Changes admin for the contract   @param _admin The address of the new admin.   /   function changeAdmin(address _admin) external onlyAdmin {     admin = _admin;     emit ChangeAdmin(_admin);   } /// @dev Logic for changeFloatPercentage   function _changeFloatPercentage(uint256 newFloatPercentage) internal virtual {     require(newFloatPercentage &lt;= 1e18 &amp;&amp; newFloatPercentage &gt; 0); // less than or equal to 100% and greater than 0%     floatPercentage = newFloatPercentage;   } /*   @notice Changes percentage of float that is minted for float capital.   @param newFloatPercentage The new float percentage in base 1e18.   /   function changeFloatPercentage(uint256 newFloatPercentage) external onlyAdmin {     _changeFloatPercentage(newFloatPercentage);     emit FloatPercentageUpdated(newFloatPercentage);   } /// @dev Logic for changeUnstakeFee   function _changeUnstakeFee(uint32 marketIndex, uint256 newMarketUnstakeFee_e18) internal virtual {     require(newMarketUnstakeFee_e18 &lt;= 5e16); // Explicitely stating 5% fee as the max fee possible.     marketUnstakeFee_e18[marketIndex] = newMarketUnstakeFee_e18;   } /*   @notice Changes unstake fee for a market   @param marketIndex Identifies the market.   @param newMarketUnstakeFee_e18 The new unstake fee.   /   function changeUnstakeFee(uint32 marketIndex, uint256 newMarketUnstakeFee_e18) external onlyAdmin {     _changeUnstakeFee(marketIndex, newMarketUnstakeFee_e18);     emit StakeWithdrawalFeeUpdated(marketIndex, newMarketUnstakeFee_e18);   } /// @dev Logic for changeMarketLaunchIncentiveParameters   function _changeMarketLaunchIncentiveParameters(     uint32 marketIndex,     uint256 period,     uint256 initialMultiplier   ) internal virtual {     require(initialMultiplier &gt;= 1e18, "marketLaunchIncentiveMultiplier must be &gt;= 1e18"); marketLaunchIncentive_period[marketIndex] = period; marketLaunchIncentive_multipliers[marketIndex] = initialMultiplier;  } /*   @notice Changes the market launch incentive parameters for a market   @param marketIndex Identifies the market.   @param period The new period for which float token generation should be boosted.   @param initialMultiplier The new multiplier on Float generation.   /   function changeMarketLaunchIncentiveParameters(     uint32 marketIndex,     uint256 period,     uint256 initialMultiplier   ) external onlyAdmin {     _changeMarketLaunchIncentiveParameters(marketIndex, period, initialMultiplier); emit MarketLaunchIncentiveParametersChanges(marketIndex, period, initialMultiplier);  } /// @dev Logic for changeBalanceIncentiveExponent   function _changeBalanceIncentiveExponent(uint32 marketIndex, uint256 _balanceIncentiveCurve_exponent)     internal     virtual   {     require(       // The exponent has to be less than 5 in these versions of the contracts.       _balanceIncentiveCurve_exponent &gt; 0 &amp;&amp; _balanceIncentiveCurve_exponent &lt; 6,       "balanceIncentiveCurve_exponent out of bounds"     ); balanceIncentiveCurve_exponent[marketIndex] = _balanceIncentiveCurve_exponent;  } /*    @notice Changes the balance incentive exponent for a market   @param marketIndex Identifies the market.   @param _balanceIncentiveCurve_exponent The new exponent for the curve.   /   function changeBalanceIncentiveExponent(uint32 marketIndex, uint256 _balanceIncentiveCurve_exponent)     external     onlyAdmin   {     _changeBalanceIncentiveExponent(marketIndex, _balanceIncentiveCurve_exponent); emit BalanceIncentiveExponentUpdated(marketIndex, _balanceIncentiveCurve_exponent);  } /// @dev Logic for changeBalanceIncentiveEquilibriumOffset   function _changeBalanceIncentiveEquilibriumOffset(uint32 marketIndex, int256 _balanceIncentiveCurve_equilibriumOffset)     internal     virtual   {     // Unreasonable that we would ever shift this more than 90% either way     require(       _balanceIncentiveCurve_equilibriumOffset &gt; -9e17 &amp;&amp; _balanceIncentiveCurve_equilibriumOffset &lt; 9e17,       "balanceIncentiveCurve_equilibriumOffset out of bounds"     ); balanceIncentiveCurve_equilibriumOffset[marketIndex] = _balanceIncentiveCurve_equilibriumOffset;  } /*   @notice Changes the balance incentive curve equilibrium offset for a market   @param marketIndex Identifies the market.   @param _balanceIncentiveCurve_equilibriumOffset The new offset.   /   function changeBalanceIncentiveEquilibriumOffset(uint32 marketIndex, int256 _balanceIncentiveCurve_equilibriumOffset)     external     onlyAdmin   {     _changeBalanceIncentiveEquilibriumOffset(marketIndex, _balanceIncentiveCurve_equilibriumOffset); emit BalanceIncentiveEquilibriumOffsetUpdated(marketIndex, _balanceIncentiveCurve_equilibriumOffset);  } /╔═════════════════════════════╗     ║        STAKING SETUP        ║     ╚═════════════════════════════╝/ /*   @notice Sets this contract to track staking for a market in LongShort.sol   @param marketIndex Identifies the market.   @param longToken Address of the long token for the market.   @param shortToken Address of the short token for the market.   @param kInitialMultiplier Initial boost on float generation for the market.   @param kPeriod Period which the boost should last.   @param unstakeFee_e18 Percentage of tokens that are levied on unstaking in base 1e18.   @param _balanceIncentiveCurve_exponent Exponent for balance curve (see _calculateFloatPerSecond)   @param _balanceIncentiveCurve_equilibriumOffset Offset for balance curve (see _calculateFloatPerSecond)   /   function addNewStakingFund(     uint32 marketIndex,     address longToken,     address shortToken,     uint256 kInitialMultiplier,     uint256 kPeriod,     uint256 unstakeFee_e18,     uint256 _balanceIncentiveCurve_exponent,     int256 _balanceIncentiveCurve_equilibriumOffset   ) external override onlyLongShort {     marketIndexOfToken[longToken] = marketIndex;     marketIndexOfToken[shortToken] = marketIndex; accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].timestamp = block.timestamp; accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].accumulativeFloatPerSyntheticToken_long = 0; accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].accumulativeFloatPerSyntheticToken_short = 0;  syntheticTokens[marketIndex][true] = longToken; syntheticTokens[marketIndex][false] = shortToken;  _changeBalanceIncentiveExponent(marketIndex, _balanceIncentiveCurve_exponent); _changeBalanceIncentiveEquilibriumOffset(marketIndex, _balanceIncentiveCurve_equilibriumOffset); _changeMarketLaunchIncentiveParameters(marketIndex, kPeriod, kInitialMultiplier);  _changeUnstakeFee(marketIndex, unstakeFee_e18);  // Set this value to one initially - 0 is a null value and thus potentially bug prone. batched_stakerNextTokenShiftIndex[marketIndex] = 1;  emit MarketAddedToStaker(   marketIndex,   unstakeFee_e18,   kPeriod,   kInitialMultiplier,   _balanceIncentiveCurve_exponent,   _balanceIncentiveCurve_equilibriumOffset );  emit AccumulativeIssuancePerStakedSynthSnapshotCreated(marketIndex, 0, 0, 0);  } /╔═════════════════════════════════════════════════════════════════════════╗     ║    GLOBAL FLT REWARD ACCUMULATION CALCULATION AND TRACKING FUNCTIONS    ║     ╚═════════════════════════════════════════════════════════════════════════╝/ /*   @notice Returns the K factor parameters for the given market with sensible   defaults if they haven't been set yet.   @param marketIndex The market to change the parameters for.   @return period The period for which the k factor applies for in seconds.   @return multiplier The multiplier on Float generation in this period.   /   function _getMarketLaunchIncentiveParameters(uint32 marketIndex)     internal     view     virtual     returns (uint256 period, uint256 multiplier)   {     period = marketLaunchIncentive_period[marketIndex];     multiplier = marketLaunchIncentive_multipliers[marketIndex]; if (multiplier &lt; 1e18) {   multiplier = 1e18; // multiplier of 1 by default }  } /*    @notice Returns the extent to which a markets float generation should be adjusted   based on the market's launch incentive parameters. Should start at multiplier   then linearly change to 1e18 over time.   @param marketIndex Identifies the market.   @return k The calculated modifier for float generation.   /   function _getKValue(uint32 marketIndex) internal view virtual returns (uint256) {     // Parameters controlling the float issuance multiplier.     (uint256 kPeriod, uint256 kInitialMultiplier) = _getMarketLaunchIncentiveParameters(marketIndex); // Sanity check - under normal circumstances, the multipliers should // *never* be set to a value &lt; 1e18, as there are guards against this. assert(kInitialMultiplier &gt;= 1e18);  uint256 initialTimestamp = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].timestamp;  if (block.timestamp - initialTimestamp &lt;= kPeriod) {   return kInitialMultiplier - (((kInitialMultiplier - 1e18) * (block.timestamp - initialTimestamp)) / kPeriod); } else {   return 1e18; }  } /   @notice Computes the number of float tokens a user earns per second for   every long/short synthetic token they've staked. The returned value has   a fixed decimal scale of 1e42 (!!!) for numerical stability. The return   values are float per second per synthetic token (hence the requirement   to multiply by price)   @dev to see below math in latex form see TODO add link   to interact with the equations see https://www.desmos.com/calculator/optkaxyihr   @param marketIndex The market referred to.   @param longPrice Price of the synthetic long token in units of payment token   @param shortPrice Price of the synthetic short token in units of payment token   @param longValue Amount of payment token in the long side of the market   @param shortValue Amount of payment token in the short side of the market   @return longFloatPerSecond Float token per second per long synthetic token   @return shortFloatPerSecond Float token per second per short synthetic token    /   function _calculateFloatPerSecond(     uint32 marketIndex,     uint256 longPrice,     uint256 shortPrice,     uint256 longValue,     uint256 shortValue   ) internal view virtual returns (uint256 longFloatPerSecond, uint256 shortFloatPerSecond) {     // A float issuance multiplier that starts high and decreases linearly     // over time to a value of 1. This incentivises users to stake early.     uint256 k = _getKValue(marketIndex); uint256 totalLocked = (longValue + shortValue);  // we need to scale this number by the totalLocked so that the offset remains consistent accross market size  int256 equilibriumOffsetMarketScaled = (balanceIncentiveCurve_equilibriumOffset[marketIndex] *   int256(totalLocked)) / 2e18;  uint256 denominator = ((totalLocked &gt;&gt; safeExponentBitShifting)**balanceIncentiveCurve_exponent[marketIndex]);  // Float is scaled by the percentage of the total market value held in // the opposite position. This incentivises users to stake on the // weaker position. if (int256(shortValue) - equilibriumOffsetMarketScaled &lt; int256(longValue)) {   if (equilibriumOffsetMarketScaled &gt;= int256(shortValue)) {     // edge case: imbalanced far past the equilibrium offset - full rewards go to short token     //            extremeley unlikely to happen in practice     return (0, 1e18 * k * shortPrice);   }    uint256 numerator = (uint256(int256(shortValue) - equilibriumOffsetMarketScaled) &gt;&gt;     (safeExponentBitShifting - 1))**balanceIncentiveCurve_exponent[marketIndex];    // NOTE: `x * 5e17` == `(x * 10e18) / 2`   uint256 longRewardUnscaled = (numerator * 5e17) / denominator;   uint256 shortRewardUnscaled = 1e18 - longRewardUnscaled;    return ((longRewardUnscaled * k * longPrice) / 1e18, (shortRewardUnscaled * k * shortPrice) / 1e18); } else {   if (-equilibriumOffsetMarketScaled &gt;= int256(longValue)) {     // edge case: imbalanced far past the equilibrium offset - full rewards go to long token     //            extremeley unlikely to happen in practice     return (1e18 * k * longPrice, 0);   }    uint256 numerator = (uint256(int256(longValue) + equilibriumOffsetMarketScaled) &gt;&gt;     (safeExponentBitShifting - 1))**balanceIncentiveCurve_exponent[marketIndex];    // NOTE: `x * 5e17` == `(x * 10e18) / 2`   uint256 shortRewardUnscaled = (numerator * 5e17) / denominator;   uint256 longRewardUnscaled = 1e18 - shortRewardUnscaled;    return ((longRewardUnscaled * k * longPrice) / 1e18, (shortRewardUnscaled * k * shortPrice) / 1e18); }  } /*   @notice Computes the time since last accumulativeIssuancePerStakedSynthSnapshot for the given market in seconds.   @param marketIndex The market referred to.   @return The time difference in seconds   /   function _calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(uint32 marketIndex)     internal     view     virtual     returns (uint256)   {     return       block.timestamp -       accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]].timestamp;   } /*   @notice Computes new cumulative sum of 'r' value since last accumulativeIssuancePerStakedSynthSnapshot. We use   cumulative 'r' value to avoid looping during issuance. Note that the   cumulative sum is kept in 1e42 scale (!!!) to avoid numerical issues.   @param shortValue The value locked in the short side of the market.   @param longValue The value locked in the long side of the market.   @param shortPrice The price of the short token as defined in LongShort.sol   @param longPrice The price of the long token as defined in LongShort.sol   @param marketIndex An identifier for the market.   @return longCumulativeRates The long cumulative sum.   @return shortCumulativeRates The short cumulative sum.   /   function _calculateNewCumulativeIssuancePerStakedSynth(     uint32 marketIndex,     uint256 longPrice,     uint256 shortPrice,     uint256 longValue,     uint256 shortValue   ) internal view virtual returns (uint256 longCumulativeRates, uint256 shortCumulativeRates) {     // Compute the current 'r' value for float issuance per second.     (uint256 longFloatPerSecond, uint256 shortFloatPerSecond) = _calculateFloatPerSecond(       marketIndex,       longPrice,       shortPrice,       longValue,       shortValue     ); // Compute time since last accumulativeIssuancePerStakedSynthSnapshot for the given token. uint256 timeDelta = _calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(marketIndex);  // Compute new cumulative 'r' value total. return (   accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]]   .accumulativeFloatPerSyntheticToken_long + (timeDelta * longFloatPerSecond),   accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]]   .accumulativeFloatPerSyntheticToken_short + (timeDelta * shortFloatPerSecond) );  } /*   @notice Creates a new accumulativeIssuancePerStakedSynthSnapshot for the given token and updates indexes.   @param shortValue The value locked in the short side of the market.   @param longValue The value locked in the long side of the market.   @param shortPrice The price of the short token as defined in LongShort.sol   @param longPrice The price of the long token as defined in LongShort.sol   @param marketIndex An identifier for the market.   /   function _setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot(     uint32 marketIndex,     uint256 longPrice,     uint256 shortPrice,     uint256 longValue,     uint256 shortValue   ) internal virtual {     (       uint256 newLongAccumulativeValue,       uint256 newShortAccumulativeValue     ) = _calculateNewCumulativeIssuancePerStakedSynth(marketIndex, longPrice, shortPrice, longValue, shortValue); uint256 newIndex = latestRewardIndex[marketIndex] + 1;  // Set cumulative 'r' value on new accumulativeIssuancePerStakedSynthSnapshot. accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex] .accumulativeFloatPerSyntheticToken_long = newLongAccumulativeValue; accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex] .accumulativeFloatPerSyntheticToken_short = newShortAccumulativeValue;  // Set timestamp on new accumulativeIssuancePerStakedSynthSnapshot. accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex].timestamp = block.timestamp;  // Update latest index to point to new accumulativeIssuancePerStakedSynthSnapshot. latestRewardIndex[marketIndex] = newIndex;  emit AccumulativeIssuancePerStakedSynthSnapshotCreated(   marketIndex,   newIndex,   newLongAccumulativeValue,   newShortAccumulativeValue );  } /*   @notice Adds new accumulativeIssuancePerStakedSynthSnapshots for the given long/short tokens. Called by the   ILongShort contract whenever there is a state change for a market.   @param stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted Mapping from this contract's shifts to LongShort.sols next price snapshots.   @param shortValue The value locked in the short side of the market.   @param longValue The value locked in the long side of the market.   @param shortPrice The price of the short token as defined in LongShort.sol   @param longPrice The price of the long token as defined in LongShort.sol   @param marketIndex An identifier for the market.   /   function pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(     uint32 marketIndex,     uint256 longPrice,     uint256 shortPrice,     uint256 longValue,     uint256 shortValue,     uint256 stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted // This value should be ALWAYS be zero if no shift occured   ) external override onlyLongShort {     // Only add a new accumulativeIssuancePerStakedSynthSnapshot if some time has passed. // the `stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted` value will be 0 if there is no staker related action in an executed batch if (stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted &gt; 0) {   stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[     batched_stakerNextTokenShiftIndex[marketIndex]   ] = stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted;   stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[     batched_stakerNextTokenShiftIndex[marketIndex]   ] = latestRewardIndex[marketIndex] + 1;   batched_stakerNextTokenShiftIndex[marketIndex] += 1;    emit SyntheticTokensShifted(); }  // Time delta is fetched twice in below code, can pass through? Which is less gas? if (_calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(marketIndex) &gt; 0) {   _setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot(     marketIndex,     longPrice,     shortPrice,     longValue,     shortValue   ); }  } /╔═══════════════════════════════════╗     ║    USER REWARD STATE FUNCTIONS    ║     ╚═══════════════════════════════════╝/ /// @dev Calculates the accumulated float in a specific range of staker snapshots   function _calculateAccumulatedFloatInRange(     uint32 marketIndex,     uint256 amountStakedLong,     uint256 amountStakedShort,     uint256 rewardIndexFrom,     uint256 rewardIndexTo   ) internal view virtual returns (uint256 floatReward) {     if (amountStakedLong &gt; 0) {       uint256 accumDeltaLong = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexTo]       .accumulativeFloatPerSyntheticToken_long -         accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexFrom]         .accumulativeFloatPerSyntheticToken_long;       floatReward += (accumDeltaLong * amountStakedLong) / FLOAT_ISSUANCE_FIXED_DECIMAL;     } if (amountStakedShort &gt; 0) {   uint256 accumDeltaShort = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexTo]   .accumulativeFloatPerSyntheticToken_short -     accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexFrom]     .accumulativeFloatPerSyntheticToken_short;   floatReward += (accumDeltaShort * amountStakedShort) / FLOAT_ISSUANCE_FIXED_DECIMAL; }  } /*    @notice Calculates float owed to the user since the user last minted float for a market.   @param marketIndex Identifier for the market which the user staked in.   @param user The address of the user.   @return floatReward The amount of float owed.    /   function _calculateAccumulatedFloat(uint32 marketIndex, address user) internal virtual returns (uint256 floatReward) {     address longToken = syntheticTokens[marketIndex][true];     address shortToken = syntheticTokens[marketIndex][false]; uint256 amountStakedLong = userAmountStaked[longToken][user]; uint256 amountStakedShort = userAmountStaked[shortToken][user];  uint256 usersLastRewardIndex = userIndexOfLastClaimedReward[marketIndex][user];  // Don't do the calculation and return zero immediately if there is no change if (usersLastRewardIndex == latestRewardIndex[marketIndex]) {   return 0; }  uint256 usersShiftIndex = userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][user]; // if there is a change in the users tokens held due to a token shift (or possibly another action in the future) if (usersShiftIndex &gt; 0 &amp;&amp; usersShiftIndex &lt; batched_stakerNextTokenShiftIndex[marketIndex]) {   floatReward = _calculateAccumulatedFloatInRange(     marketIndex,     amountStakedLong,     amountStakedShort,     usersLastRewardIndex,     stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[usersShiftIndex]   );    // Update the users balances   if (userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user] &gt; 0) {     amountStakedShort += ILongShort(longShort).getAmountSyntheticTokenToMintOnTargetSide(       marketIndex,       userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user],       true,       stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[usersShiftIndex]     );      amountStakedLong -= userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user];     userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user] = 0;   }    if (userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user] &gt; 0) {     amountStakedLong += ILongShort(longShort).getAmountSyntheticTokenToMintOnTargetSide(       marketIndex,       userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user],       false,       stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[usersShiftIndex]     );      amountStakedShort -= userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user];     userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user] = 0;   }    // Save the users updated staked amounts   userAmountStaked[longToken][user] = amountStakedLong;   userAmountStaked[shortToken][user] = amountStakedShort;    floatReward += _calculateAccumulatedFloatInRange(     marketIndex,     amountStakedLong,     amountStakedShort,     stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[usersShiftIndex],     latestRewardIndex[marketIndex]   );    userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][user] = 0; } else {   floatReward = _calculateAccumulatedFloatInRange(     marketIndex,     amountStakedLong,     amountStakedShort,     usersLastRewardIndex,     latestRewardIndex[marketIndex]   ); }  } /*   @notice Mints float for a user.   @dev Mints a fixed percentage for Float capital.   @param user The address of the user.   @param floatToMint The amount of float to mint.    /   function _mintFloat(address user, uint256 floatToMint) internal virtual {     IFloatToken(floatToken).mint(user, floatToMint);     IFloatToken(floatToken).mint(floatCapital, (floatToMint * floatPercentage) / 1e18);   } /*   @notice Mints float owed to a user for a market since they last minted.   @param marketIndex An identifier for the market.   @param user The address of the user.    /   function _mintAccumulatedFloat(uint32 marketIndex, address user) internal virtual {     uint256 floatToMint = _calculateAccumulatedFloat(marketIndex, user); if (floatToMint &gt; 0) {   // Set the user has claimed up until now, stops them setting this forward   userIndexOfLastClaimedReward[marketIndex][user] = latestRewardIndex[marketIndex];    _mintFloat(user, floatToMint);   emit FloatMinted(user, marketIndex, floatToMint); }  } /*   @notice Mints float owed to a user for multiple markets, since they last minted for those markets.   @param marketIndexes Identifiers for the markets.   @param user The address of the user.    /   function _mintAccumulatedFloatMulti(uint32[] calldata marketIndexes, address user) internal virtual {     uint256 floatTotal = 0;     for (uint256 i = 0; i &lt; marketIndexes.length; i++) {       uint256 floatToMint = _calculateAccumulatedFloat(marketIndexes[i], user);   if (floatToMint &gt; 0) {     // Set the user has claimed up until now, stops them setting this forward     userIndexOfLastClaimedReward[marketIndexes[i]][user] = latestRewardIndex[marketIndexes[i]];      floatTotal += floatToMint;      emit FloatMinted(user, marketIndexes[i], floatToMint);   } } if (floatTotal &gt; 0) {   _mintFloat(user, floatTotal); }  } /*   @notice Mints outstanding float for msg.sender.   @param marketIndexes Identifiers for the markets for which to mint float.    /   function claimFloatCustom(uint32[] calldata marketIndexes) external {     ILongShort(longShort).updateSystemStateMulti(marketIndexes);     _mintAccumulatedFloatMulti(marketIndexes, msg.sender);   } /*   @notice Mints outstanding float on behalf of another user.   @param marketIndexes Identifiers for the markets for which to mint float.   @param user The address of the user.    /   function claimFloatCustomFor(uint32[] calldata marketIndexes, address user) external {     // Unbounded loop - users are responsible for paying their own gas costs on these and it doesn't effect the rest of the system.     // No need to impose limit.     ILongShort(longShort).updateSystemStateMulti(marketIndexes);     _mintAccumulatedFloatMulti(marketIndexes, user);   } /╔═══════════════════════╗     ║        STAKING        ║     ╚═══════════════════════╝/ /*   @notice A user with synthetic tokens stakes by calling stake on the token   contract which calls this function. We need to first update the   state of the LongShort contract for this market before staking to correctly calculate user rewards.   @param amount Amount to stake.   @param from Address to stake for.   /   function stakeFromUser(address from, uint256 amount) public virtual override onlyValidSynthetic((msg.sender)) {     ILongShort(longShort).updateSystemState(marketIndexOfToken[(msg.sender)]);     _stake((msg.sender), amount, from);   } /*   @dev Internal logic for staking.   @param token Address of the token for which to stake.   @param amount Amount to stake.   @param user Address to stake for.   /   function _stake(     address token,     uint256 amount,     address user   ) internal virtual {     uint32 marketIndex = marketIndexOfToken[token]; // If they already have staked and have rewards due, mint these. if (   userIndexOfLastClaimedReward[marketIndex][user] != 0 &amp;&amp;   userIndexOfLastClaimedReward[marketIndex][user] &lt; latestRewardIndex[marketIndex] ) {   _mintAccumulatedFloat(marketIndex, user); }  userAmountStaked[token][user] = userAmountStaked[token][user] + amount;  userIndexOfLastClaimedReward[marketIndex][user] = latestRewardIndex[marketIndex];  emit StakeAdded(user, address(token), amount, userIndexOfLastClaimedReward[marketIndex][user]);  } /*   @notice Allows users to shift their staked tokens from one side of the market to    the other at the next price.   @param amountSyntheticTokensToShift Amount of tokens to shift.   @param marketIndex Identifier for the market.   @param isShiftFromLong Whether the shift is from long to short or short to long.   /   function shiftTokens(     uint256 amountSyntheticTokensToShift,     uint32 marketIndex,     bool isShiftFromLong   ) external virtual {     address token = syntheticTokens[marketIndex][isShiftFromLong];     require(userAmountStaked[token][msg.sender] &gt;= amountSyntheticTokensToShift, "Not enough tokens to shift"); // If the user has outstanding token shift that have already been confirmed in the LongShort // contract, execute them first. if (   userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] != 0 &amp;&amp;   userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] &lt;   batched_stakerNextTokenShiftIndex[marketIndex] ) {   _mintAccumulatedFloat(marketIndex, msg.sender); }  if (isShiftFromLong) {   ILongShort(longShort).shiftPositionFromLongNextPrice(marketIndex, amountSyntheticTokensToShift);   userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][     msg.sender   ] += amountSyntheticTokensToShift; } else {   ILongShort(longShort).shiftPositionFromShortNextPrice(marketIndex, amountSyntheticTokensToShift);   userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][     msg.sender   ] += amountSyntheticTokensToShift; }  userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] = batched_stakerNextTokenShiftIndex[   marketIndex ];  } /╔════════════════════════════╗     ║    WITHDRAWAL &amp; MINTING    ║     ╚════════════════════════════╝/ /*   @notice Internal logic for withdrawing stakes.   @dev Mint user any outstanding float before withdrawing.   @param marketIndex Market index of token.   @param amount Amount to withdraw.   @param token Synthetic token that was staked.   /   function _withdraw(     uint32 marketIndex,     address token,     uint256 amount   ) internal virtual {     require(userAmountStaked[token][msg.sender] &gt; 0, "nothing to withdraw");     _mintAccumulatedFloat(marketIndex, msg.sender); userAmountStaked[token][msg.sender] = userAmountStaked[token][msg.sender] - amount;  uint256 amountFees = (amount * marketUnstakeFee_e18[marketIndex]) / 1e18;  IERC20(token).transfer(floatTreasury, amountFees); IERC20(token).transfer(msg.sender, amount - amountFees);  emit StakeWithdrawn(msg.sender, token, amount);  } /*   @notice Withdraw function. Allows users to unstake.   @param amount Amount to withdraw.   @param token Address of the token for which to withdraw.   /   function withdraw(address token, uint256 amount) external {     ILongShort(longShort).updateSystemState(marketIndexOfToken[token]); uint32 marketIndex = marketIndexOfToken[token];  _withdraw(marketIndex, token, amount);  if (userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] &gt; 0) {   // If they still have outstanding shifts after minting float, then check   // that they don't withdraw more than their shifts allow.   uint256 amountToShiftForThisToken = syntheticTokens[marketIndex][true] == token     ? userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][msg.sender]     : userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][msg.sender];    require(     userAmountStaked[token][msg.sender] &gt;= amountToShiftForThisToken,     "Outstanding next price stake shifts too great"   ); }  } /*   @notice Allows users to withdraw their entire stake for a token.   @param token Address of the token for which to withdraw.   /   function withdrawAll(address token) external {     ILongShort(longShort).updateSystemState(marketIndexOfToken[token]); uint32 marketIndex = marketIndexOfToken[token];  uint256 amountToShiftForThisToken = syntheticTokens[marketIndex][true] == token   ? userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][msg.sender]   : userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][msg.sender];  _withdraw(marketIndex, token, userAmountStaked[token][msg.sender] - amountToShiftForThisToken);  } } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-17-08 08:01:54 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: BUSL-1.1

pragma solidity 0.8.3;

import "@openzeppelin/contracts-upgradeable/token/ERC20/presets/ERC20PresetMinterPauserUpgradeable.sol";

import "./interfaces/IFloatToken.sol";
import "./interfaces/ILongShort.sol";
import "./interfaces/IStaker.sol";
import "./interfaces/ISyntheticToken.sol";

contract Staker is IStaker, Initializable {
  /*╔═════════════════════════════╗
    ║          VARIABLES          ║
    ╚═════════════════════════════╝*/

  /* ══════ Fixed-precision constants ══════ */
  uint256 public constant FLOAT_ISSUANCE_FIXED_DECIMAL = 1e42;
  // 2^52 ~= 4.5e15
  // With an exponent of 5, the largest total liquidity possible in a market (to avoid integer overflow on exponentiation) is ~10^31 or 10 Trillion (10^13)
  // NOTE: this also means if the total market value is less than 2^52 there will be a division by zero error
  uint256 public constant safeExponentBitShifting = 52;

  /* ══════ Global state ══════ */
  address public admin;
  address public floatCapital;
  address public floatTreasury;
  uint256 public floatPercentage;

  address public longShort;
  address public floatToken;

  /* ══════ Market specific ══════ */
  mapping(uint32 => uint256) public marketLaunchIncentive_period; // seconds
  mapping(uint32 => uint256) public marketLaunchIncentive_multipliers; // e18 scale
  mapping(uint32 => uint256) public marketUnstakeFee_e18;
  mapping(uint32 => uint256) public balanceIncentiveCurve_exponent;
  mapping(uint32 => int256) public balanceIncentiveCurve_equilibriumOffset;

  mapping(uint32 => mapping(bool => address)) public syntheticTokens;

  mapping(address => uint32) public marketIndexOfToken;

  /* ══════ Reward specific ══════ */
  mapping(uint32 => uint256) public latestRewardIndex;
  mapping(uint32 => mapping(uint256 => AccumulativeIssuancePerStakedSynthSnapshot))
    public accumulativeFloatPerSyntheticTokenSnapshots;
  struct AccumulativeIssuancePerStakedSynthSnapshot {
    uint256 timestamp;
    uint256 accumulativeFloatPerSyntheticToken_long;
    uint256 accumulativeFloatPerSyntheticToken_short;
  }

  /* ══════ User specific ══════ */
  mapping(uint32 => mapping(address => uint256)) public userIndexOfLastClaimedReward;
  mapping(address => mapping(address => uint256)) public userAmountStaked;

  /* ══════ Token shift management specific ══════ */
  mapping(uint32 => uint256) public batched_stakerNextTokenShiftIndex;
  /**
  @notice Used to link a token shift to a staker state
  @dev tokenShiftIndex => accumulativeFloatIssuanceSnapshotIndex
    POSSIBLE OPTIMIZATION - could pack stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping and stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping into a struct of two uint128 for storage space optimization.
  */
  mapping(uint256 => uint256) public stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping;
  /// @notice Used to fetch the price from LongShort at that point in time
  /// @dev tokenShiftIndex => longShortMarketPriceSnapshotIndex
  mapping(uint256 => uint256) public stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping;
  /// @dev marketIndex => usersAddress => stakerTokenShiftIndex
  mapping(uint32 => mapping(address => uint256)) public userNextPrice_stakedSyntheticTokenShiftIndex;
  /// @dev marketIndex => usersAddress => amountUserRequestedToShiftAwayFromLongOnNextUpdate
  mapping(uint32 => mapping(address => uint256)) public userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long;
  /// @dev marketIndex => usersAddress => amountUserRequestedToShiftAwayFromShortOnNextUpdate
  mapping(uint32 => mapping(address => uint256)) public userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short;

  /*╔════════════════════════════╗
    ║           EVENTS           ║
    ╚════════════════════════════╝*/

  event StakerV1(
    address admin,
    address floatTreasury,
    address floatCapital,
    address floatToken,
    uint256 floatPercentage
  );

  event MarketAddedToStaker(
    uint32 marketIndex,
    uint256 exitFee_e18,
    uint256 period,
    uint256 multiplier,
    uint256 balanceIncentiveExponent,
    int256 balanceIncentiveEquilibriumOffset
  );

  event AccumulativeIssuancePerStakedSynthSnapshotCreated(
    uint32 marketIndex,
    uint256 accumulativeFloatIssuanceSnapshotIndex,
    uint256 accumulativeLong,
    uint256 accumulativeShort
  );

  event StakeAdded(address user, address token, uint256 amount, uint256 lastMintIndex);

  event StakeWithdrawn(address user, address token, uint256 amount);

  // Note: the `amountFloatMinted` isn't strictly needed by the graph, but it is good to add it to validate calculations are accurate.
  event FloatMinted(address user, uint32 marketIndex, uint256 amountFloatMinted);

  event MarketLaunchIncentiveParametersChanges(uint32 marketIndex, uint256 period, uint256 multiplier);

  event StakeWithdrawalFeeUpdated(uint32 marketIndex, uint256 stakeWithdralFee);

  event BalanceIncentiveExponentUpdated(uint32 marketIndex, uint256 balanceIncentiveExponent);

  event BalanceIncentiveEquilibriumOffsetUpdated(uint32 marketIndex, int256 balanceIncentiveEquilibriumOffset);

  event FloatPercentageUpdated(uint256 floatPercentage);

  event SyntheticTokensShifted();

  event ChangeAdmin(address newAdmin);

  /*╔═════════════════════════════╗
    ║          MODIFIERS          ║
    ╚═════════════════════════════╝*/

  function onlyAdminModifierLogic() internal virtual {
    require(msg.sender == admin, "not admin");
  }

  modifier onlyAdmin() {
    onlyAdminModifierLogic();
    _;
  }

  function onlyValidSyntheticModifierLogic(address _synth) internal virtual {
    require(marketIndexOfToken[_synth] != 0, "not valid synth");
  }

  modifier onlyValidSynthetic(address _synth) {
    onlyValidSyntheticModifierLogic(_synth);
    _;
  }

  function onlyValidMarketModifierLogic(uint32 marketIndex) internal virtual {
    require(address(syntheticTokens[marketIndex][true]) != address(0), "not valid market");
  }

  modifier onlyValidMarket(uint32 marketIndex) {
    onlyValidMarketModifierLogic(marketIndex);
    _;
  }

  function onlyLongShortModifierLogic() internal virtual {
    require(msg.sender == address(longShort), "not long short");
  }

  modifier onlyLongShort() {
    onlyLongShortModifierLogic();
    _;
  }

  /*╔═════════════════════════════╗
    ║       CONTRACT SET-UP       ║
    ╚═════════════════════════════╝*/

  /**
  @notice Initializes the contract.
  @dev Calls OpenZeppelin's initializer modifier.
  @param _admin Address of the admin role.
  @param _longShort Address of the LongShort contract, a deployed LongShort.sol
  @param _floatToken Address of the Float token earned by staking.
  @param _floatTreasury Address of the treasury contract for managing fees.
  @param _floatCapital Address of the contract which earns a fixed percentage of Float.
  @param _floatPercentage Determines the float percentage that gets minted for Float Capital, base 1e18.
  */
  function initialize(
    address _admin,
    address _longShort,
    address _floatToken,
    address _floatTreasury,
    address _floatCapital,
    uint256 _floatPercentage
  ) external virtual initializer {
    admin = _admin;
    floatCapital = _floatCapital;
    floatTreasury = _floatTreasury;
    longShort = _longShort;
    floatToken = _floatToken;

    _changeFloatPercentage(_floatPercentage);

    emit StakerV1(_admin, _floatTreasury, _floatCapital, _floatToken, _floatPercentage);
  }

  /*╔═══════════════════╗
    ║       ADMIN       ║
    ╚═══════════════════╝*/

  /** 
  @notice Changes admin for the contract
  @param _admin The address of the new admin.
  */
  function changeAdmin(address _admin) external onlyAdmin {
    admin = _admin;
    emit ChangeAdmin(_admin);
  }

  /// @dev Logic for changeFloatPercentage
  function _changeFloatPercentage(uint256 newFloatPercentage) internal virtual {
    require(newFloatPercentage <= 1e18 && newFloatPercentage > 0); // less than or equal to 100% and greater than 0%
    floatPercentage = newFloatPercentage;
  }

  /**
  @notice Changes percentage of float that is minted for float capital.
  @param newFloatPercentage The new float percentage in base 1e18.
  */
  function changeFloatPercentage(uint256 newFloatPercentage) external onlyAdmin {
    _changeFloatPercentage(newFloatPercentage);
    emit FloatPercentageUpdated(newFloatPercentage);
  }

  /// @dev Logic for changeUnstakeFee
  function _changeUnstakeFee(uint32 marketIndex, uint256 newMarketUnstakeFee_e18) internal virtual {
    require(newMarketUnstakeFee_e18 <= 5e16); // Explicitely stating 5% fee as the max fee possible.
    marketUnstakeFee_e18[marketIndex] = newMarketUnstakeFee_e18;
  }

  /**
  @notice Changes unstake fee for a market
  @param marketIndex Identifies the market.
  @param newMarketUnstakeFee_e18 The new unstake fee.
  */
  function changeUnstakeFee(uint32 marketIndex, uint256 newMarketUnstakeFee_e18) external onlyAdmin {
    _changeUnstakeFee(marketIndex, newMarketUnstakeFee_e18);
    emit StakeWithdrawalFeeUpdated(marketIndex, newMarketUnstakeFee_e18);
  }

  /// @dev Logic for changeMarketLaunchIncentiveParameters
  function _changeMarketLaunchIncentiveParameters(
    uint32 marketIndex,
    uint256 period,
    uint256 initialMultiplier
  ) internal virtual {
    require(initialMultiplier >= 1e18, "marketLaunchIncentiveMultiplier must be >= 1e18");

    marketLaunchIncentive_period[marketIndex] = period;
    marketLaunchIncentive_multipliers[marketIndex] = initialMultiplier;
  }

  /**
  @notice Changes the market launch incentive parameters for a market
  @param marketIndex Identifies the market.
  @param period The new period for which float token generation should be boosted.
  @param initialMultiplier The new multiplier on Float generation.
  */
  function changeMarketLaunchIncentiveParameters(
    uint32 marketIndex,
    uint256 period,
    uint256 initialMultiplier
  ) external onlyAdmin {
    _changeMarketLaunchIncentiveParameters(marketIndex, period, initialMultiplier);

    emit MarketLaunchIncentiveParametersChanges(marketIndex, period, initialMultiplier);
  }

  /// @dev Logic for changeBalanceIncentiveExponent
  function _changeBalanceIncentiveExponent(uint32 marketIndex, uint256 _balanceIncentiveCurve_exponent)
    internal
    virtual
  {
    require(
      // The exponent has to be less than 5 in these versions of the contracts.
      _balanceIncentiveCurve_exponent > 0 && _balanceIncentiveCurve_exponent < 6,
      "balanceIncentiveCurve_exponent out of bounds"
    );

    balanceIncentiveCurve_exponent[marketIndex] = _balanceIncentiveCurve_exponent;
  }

  /** 
  @notice Changes the balance incentive exponent for a market
  @param marketIndex Identifies the market.
  @param _balanceIncentiveCurve_exponent The new exponent for the curve.
  */
  function changeBalanceIncentiveExponent(uint32 marketIndex, uint256 _balanceIncentiveCurve_exponent)
    external
    onlyAdmin
  {
    _changeBalanceIncentiveExponent(marketIndex, _balanceIncentiveCurve_exponent);

    emit BalanceIncentiveExponentUpdated(marketIndex, _balanceIncentiveCurve_exponent);
  }

  /// @dev Logic for changeBalanceIncentiveEquilibriumOffset
  function _changeBalanceIncentiveEquilibriumOffset(uint32 marketIndex, int256 _balanceIncentiveCurve_equilibriumOffset)
    internal
    virtual
  {
    // Unreasonable that we would ever shift this more than 90% either way
    require(
      _balanceIncentiveCurve_equilibriumOffset > -9e17 && _balanceIncentiveCurve_equilibriumOffset < 9e17,
      "balanceIncentiveCurve_equilibriumOffset out of bounds"
    );

    balanceIncentiveCurve_equilibriumOffset[marketIndex] = _balanceIncentiveCurve_equilibriumOffset;
  }

  /**
  @notice Changes the balance incentive curve equilibrium offset for a market
  @param marketIndex Identifies the market.
  @param _balanceIncentiveCurve_equilibriumOffset The new offset.
  */
  function changeBalanceIncentiveEquilibriumOffset(uint32 marketIndex, int256 _balanceIncentiveCurve_equilibriumOffset)
    external
    onlyAdmin
  {
    _changeBalanceIncentiveEquilibriumOffset(marketIndex, _balanceIncentiveCurve_equilibriumOffset);

    emit BalanceIncentiveEquilibriumOffsetUpdated(marketIndex, _balanceIncentiveCurve_equilibriumOffset);
  }

  /*╔═════════════════════════════╗
    ║        STAKING SETUP        ║
    ╚═════════════════════════════╝*/

  /**
  @notice Sets this contract to track staking for a market in LongShort.sol
  @param marketIndex Identifies the market.
  @param longToken Address of the long token for the market.
  @param shortToken Address of the short token for the market.
  @param kInitialMultiplier Initial boost on float generation for the market.
  @param kPeriod Period which the boost should last.
  @param unstakeFee_e18 Percentage of tokens that are levied on unstaking in base 1e18.
  @param _balanceIncentiveCurve_exponent Exponent for balance curve (see _calculateFloatPerSecond)
  @param _balanceIncentiveCurve_equilibriumOffset Offset for balance curve (see _calculateFloatPerSecond)
  */
  function addNewStakingFund(
    uint32 marketIndex,
    address longToken,
    address shortToken,
    uint256 kInitialMultiplier,
    uint256 kPeriod,
    uint256 unstakeFee_e18,
    uint256 _balanceIncentiveCurve_exponent,
    int256 _balanceIncentiveCurve_equilibriumOffset
  ) external override onlyLongShort {
    marketIndexOfToken[longToken] = marketIndex;
    marketIndexOfToken[shortToken] = marketIndex;

    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].timestamp = block.timestamp;
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].accumulativeFloatPerSyntheticToken_long = 0;
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].accumulativeFloatPerSyntheticToken_short = 0;

    syntheticTokens[marketIndex][true] = longToken;
    syntheticTokens[marketIndex][false] = shortToken;

    _changeBalanceIncentiveExponent(marketIndex, _balanceIncentiveCurve_exponent);
    _changeBalanceIncentiveEquilibriumOffset(marketIndex, _balanceIncentiveCurve_equilibriumOffset);
    _changeMarketLaunchIncentiveParameters(marketIndex, kPeriod, kInitialMultiplier);

    _changeUnstakeFee(marketIndex, unstakeFee_e18);

    // Set this value to one initially - 0 is a null value and thus potentially bug prone.
    batched_stakerNextTokenShiftIndex[marketIndex] = 1;

    emit MarketAddedToStaker(
      marketIndex,
      unstakeFee_e18,
      kPeriod,
      kInitialMultiplier,
      _balanceIncentiveCurve_exponent,
      _balanceIncentiveCurve_equilibriumOffset
    );

    emit AccumulativeIssuancePerStakedSynthSnapshotCreated(marketIndex, 0, 0, 0);
  }

  /*╔═════════════════════════════════════════════════════════════════════════╗
    ║    GLOBAL FLT REWARD ACCUMULATION CALCULATION AND TRACKING FUNCTIONS    ║
    ╚═════════════════════════════════════════════════════════════════════════╝*/

  /**
  @notice Returns the K factor parameters for the given market with sensible
  defaults if they haven't been set yet.
  @param marketIndex The market to change the parameters for.
  @return period The period for which the k factor applies for in seconds.
  @return multiplier The multiplier on Float generation in this period.
  */
  function _getMarketLaunchIncentiveParameters(uint32 marketIndex)
    internal
    view
    virtual
    returns (uint256 period, uint256 multiplier)
  {
    period = marketLaunchIncentive_period[marketIndex];
    multiplier = marketLaunchIncentive_multipliers[marketIndex];

    if (multiplier < 1e18) {
      multiplier = 1e18; // multiplier of 1 by default
    }
  }

  /** 
  @notice Returns the extent to which a markets float generation should be adjusted
  based on the market's launch incentive parameters. Should start at multiplier
  then linearly change to 1e18 over time.
  @param marketIndex Identifies the market.
  @return k The calculated modifier for float generation.
  */
  function _getKValue(uint32 marketIndex) internal view virtual returns (uint256) {
    // Parameters controlling the float issuance multiplier.
    (uint256 kPeriod, uint256 kInitialMultiplier) = _getMarketLaunchIncentiveParameters(marketIndex);

    // Sanity check - under normal circumstances, the multipliers should
    // *never* be set to a value < 1e18, as there are guards against this.
    assert(kInitialMultiplier >= 1e18);

    uint256 initialTimestamp = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].timestamp;

    if (block.timestamp - initialTimestamp <= kPeriod) {
      return kInitialMultiplier - (((kInitialMultiplier - 1e18) * (block.timestamp - initialTimestamp)) / kPeriod);
    } else {
      return 1e18;
    }
  }

  /*
  @notice Computes the number of float tokens a user earns per second for
  every long/short synthetic token they've staked. The returned value has
  a fixed decimal scale of 1e42 (!!!) for numerical stability. The return
  values are float per second per synthetic token (hence the requirement
  to multiply by price)
  @dev to see below math in latex form see TODO add link
  to interact with the equations see https://www.desmos.com/calculator/optkaxyihr
  @param marketIndex The market referred to.
  @param longPrice Price of the synthetic long token in units of payment token
  @param shortPrice Price of the synthetic short token in units of payment token
  @param longValue Amount of payment token in the long side of the market
  @param shortValue Amount of payment token in the short side of the market
  @return longFloatPerSecond Float token per second per long synthetic token
  @return shortFloatPerSecond Float token per second per short synthetic token
   */
  function _calculateFloatPerSecond(
    uint32 marketIndex,
    uint256 longPrice,
    uint256 shortPrice,
    uint256 longValue,
    uint256 shortValue
  ) internal view virtual returns (uint256 longFloatPerSecond, uint256 shortFloatPerSecond) {
    // A float issuance multiplier that starts high and decreases linearly
    // over time to a value of 1. This incentivises users to stake early.
    uint256 k = _getKValue(marketIndex);

    uint256 totalLocked = (longValue + shortValue);

    // we need to scale this number by the totalLocked so that the offset remains consistent accross market size

    int256 equilibriumOffsetMarketScaled = (balanceIncentiveCurve_equilibriumOffset[marketIndex] *
      int256(totalLocked)) / 2e18;

    uint256 denominator = ((totalLocked >> safeExponentBitShifting)**balanceIncentiveCurve_exponent[marketIndex]);

    // Float is scaled by the percentage of the total market value held in
    // the opposite position. This incentivises users to stake on the
    // weaker position.
    if (int256(shortValue) - equilibriumOffsetMarketScaled < int256(longValue)) {
      if (equilibriumOffsetMarketScaled >= int256(shortValue)) {
        // edge case: imbalanced far past the equilibrium offset - full rewards go to short token
        //            extremeley unlikely to happen in practice
        return (0, 1e18 * k * shortPrice);
      }

      uint256 numerator = (uint256(int256(shortValue) - equilibriumOffsetMarketScaled) >>
        (safeExponentBitShifting - 1))**balanceIncentiveCurve_exponent[marketIndex];

      // NOTE: `x * 5e17` == `(x * 10e18) / 2`
      uint256 longRewardUnscaled = (numerator * 5e17) / denominator;
      uint256 shortRewardUnscaled = 1e18 - longRewardUnscaled;

      return ((longRewardUnscaled * k * longPrice) / 1e18, (shortRewardUnscaled * k * shortPrice) / 1e18);
    } else {
      if (-equilibriumOffsetMarketScaled >= int256(longValue)) {
        // edge case: imbalanced far past the equilibrium offset - full rewards go to long token
        //            extremeley unlikely to happen in practice
        return (1e18 * k * longPrice, 0);
      }

      uint256 numerator = (uint256(int256(longValue) + equilibriumOffsetMarketScaled) >>
        (safeExponentBitShifting - 1))**balanceIncentiveCurve_exponent[marketIndex];

      // NOTE: `x * 5e17` == `(x * 10e18) / 2`
      uint256 shortRewardUnscaled = (numerator * 5e17) / denominator;
      uint256 longRewardUnscaled = 1e18 - shortRewardUnscaled;

      return ((longRewardUnscaled * k * longPrice) / 1e18, (shortRewardUnscaled * k * shortPrice) / 1e18);
    }
  }

  /**
  @notice Computes the time since last accumulativeIssuancePerStakedSynthSnapshot for the given market in seconds.
  @param marketIndex The market referred to.
  @return The time difference in seconds
  */
  function _calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(uint32 marketIndex)
    internal
    view
    virtual
    returns (uint256)
  {
    return
      block.timestamp -
      accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]].timestamp;
  }

  /**
  @notice Computes new cumulative sum of 'r' value since last accumulativeIssuancePerStakedSynthSnapshot. We use
  cumulative 'r' value to avoid looping during issuance. Note that the
  cumulative sum is kept in 1e42 scale (!!!) to avoid numerical issues.
  @param shortValue The value locked in the short side of the market.
  @param longValue The value locked in the long side of the market.
  @param shortPrice The price of the short token as defined in LongShort.sol
  @param longPrice The price of the long token as defined in LongShort.sol
  @param marketIndex An identifier for the market.
  @return longCumulativeRates The long cumulative sum.
  @return shortCumulativeRates The short cumulative sum.
  */
  function _calculateNewCumulativeIssuancePerStakedSynth(
    uint32 marketIndex,
    uint256 longPrice,
    uint256 shortPrice,
    uint256 longValue,
    uint256 shortValue
  ) internal view virtual returns (uint256 longCumulativeRates, uint256 shortCumulativeRates) {
    // Compute the current 'r' value for float issuance per second.
    (uint256 longFloatPerSecond, uint256 shortFloatPerSecond) = _calculateFloatPerSecond(
      marketIndex,
      longPrice,
      shortPrice,
      longValue,
      shortValue
    );

    // Compute time since last accumulativeIssuancePerStakedSynthSnapshot for the given token.
    uint256 timeDelta = _calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(marketIndex);

    // Compute new cumulative 'r' value total.
    return (
      accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]]
      .accumulativeFloatPerSyntheticToken_long + (timeDelta * longFloatPerSecond),
      accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]]
      .accumulativeFloatPerSyntheticToken_short + (timeDelta * shortFloatPerSecond)
    );
  }

  /**
  @notice Creates a new accumulativeIssuancePerStakedSynthSnapshot for the given token and updates indexes.
  @param shortValue The value locked in the short side of the market.
  @param longValue The value locked in the long side of the market.
  @param shortPrice The price of the short token as defined in LongShort.sol
  @param longPrice The price of the long token as defined in LongShort.sol
  @param marketIndex An identifier for the market.
  */
  function _setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot(
    uint32 marketIndex,
    uint256 longPrice,
    uint256 shortPrice,
    uint256 longValue,
    uint256 shortValue
  ) internal virtual {
    (
      uint256 newLongAccumulativeValue,
      uint256 newShortAccumulativeValue
    ) = _calculateNewCumulativeIssuancePerStakedSynth(marketIndex, longPrice, shortPrice, longValue, shortValue);

    uint256 newIndex = latestRewardIndex[marketIndex] + 1;

    // Set cumulative 'r' value on new accumulativeIssuancePerStakedSynthSnapshot.
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex]
    .accumulativeFloatPerSyntheticToken_long = newLongAccumulativeValue;
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex]
    .accumulativeFloatPerSyntheticToken_short = newShortAccumulativeValue;

    // Set timestamp on new accumulativeIssuancePerStakedSynthSnapshot.
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex].timestamp = block.timestamp;

    // Update latest index to point to new accumulativeIssuancePerStakedSynthSnapshot.
    latestRewardIndex[marketIndex] = newIndex;

    emit AccumulativeIssuancePerStakedSynthSnapshotCreated(
      marketIndex,
      newIndex,
      newLongAccumulativeValue,
      newShortAccumulativeValue
    );
  }

  /**
  @notice Adds new accumulativeIssuancePerStakedSynthSnapshots for the given long/short tokens. Called by the
  ILongShort contract whenever there is a state change for a market.
  @param stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted Mapping from this contract's shifts to LongShort.sols next price snapshots.
  @param shortValue The value locked in the short side of the market.
  @param longValue The value locked in the long side of the market.
  @param shortPrice The price of the short token as defined in LongShort.sol
  @param longPrice The price of the long token as defined in LongShort.sol
  @param marketIndex An identifier for the market.
  */
  function pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(
    uint32 marketIndex,
    uint256 longPrice,
    uint256 shortPrice,
    uint256 longValue,
    uint256 shortValue,
    uint256 stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted // This value should be ALWAYS be zero if no shift occured
  ) external override onlyLongShort {
    // Only add a new accumulativeIssuancePerStakedSynthSnapshot if some time has passed.

    // the `stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted` value will be 0 if there is no staker related action in an executed batch
    if (stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted > 0) {
      stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[
        batched_stakerNextTokenShiftIndex[marketIndex]
      ] = stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted;
      stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[
        batched_stakerNextTokenShiftIndex[marketIndex]
      ] = latestRewardIndex[marketIndex] + 1;
      batched_stakerNextTokenShiftIndex[marketIndex] += 1;

      emit SyntheticTokensShifted();
    }

    // Time delta is fetched twice in below code, can pass through? Which is less gas?
    if (_calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(marketIndex) > 0) {
      _setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot(
        marketIndex,
        longPrice,
        shortPrice,
        longValue,
        shortValue
      );
    }
  }

  /*╔═══════════════════════════════════╗
    ║    USER REWARD STATE FUNCTIONS    ║
    ╚═══════════════════════════════════╝*/

  /// @dev Calculates the accumulated float in a specific range of staker snapshots
  function _calculateAccumulatedFloatInRange(
    uint32 marketIndex,
    uint256 amountStakedLong,
    uint256 amountStakedShort,
    uint256 rewardIndexFrom,
    uint256 rewardIndexTo
  ) internal view virtual returns (uint256 floatReward) {
    if (amountStakedLong > 0) {
      uint256 accumDeltaLong = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexTo]
      .accumulativeFloatPerSyntheticToken_long -
        accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexFrom]
        .accumulativeFloatPerSyntheticToken_long;
      floatReward += (accumDeltaLong * amountStakedLong) / FLOAT_ISSUANCE_FIXED_DECIMAL;
    }

    if (amountStakedShort > 0) {
      uint256 accumDeltaShort = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexTo]
      .accumulativeFloatPerSyntheticToken_short -
        accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexFrom]
        .accumulativeFloatPerSyntheticToken_short;
      floatReward += (accumDeltaShort * amountStakedShort) / FLOAT_ISSUANCE_FIXED_DECIMAL;
    }
  }

  /** 
  @notice Calculates float owed to the user since the user last minted float for a market.
  @param marketIndex Identifier for the market which the user staked in.
  @param user The address of the user.
  @return floatReward The amount of float owed.
   */
  function _calculateAccumulatedFloat(uint32 marketIndex, address user) internal virtual returns (uint256 floatReward) {
    address longToken = syntheticTokens[marketIndex][true];
    address shortToken = syntheticTokens[marketIndex][false];

    uint256 amountStakedLong = userAmountStaked[longToken][user];
    uint256 amountStakedShort = userAmountStaked[shortToken][user];

    uint256 usersLastRewardIndex = userIndexOfLastClaimedReward[marketIndex][user];

    // Don't do the calculation and return zero immediately if there is no change
    if (usersLastRewardIndex == latestRewardIndex[marketIndex]) {
      return 0;
    }

    uint256 usersShiftIndex = userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][user];
    // if there is a change in the users tokens held due to a token shift (or possibly another action in the future)
    if (usersShiftIndex > 0 && usersShiftIndex < batched_stakerNextTokenShiftIndex[marketIndex]) {
      floatReward = _calculateAccumulatedFloatInRange(
        marketIndex,
        amountStakedLong,
        amountStakedShort,
        usersLastRewardIndex,
        stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[usersShiftIndex]
      );

      // Update the users balances
      if (userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user] > 0) {
        amountStakedShort += ILongShort(longShort).getAmountSyntheticTokenToMintOnTargetSide(
          marketIndex,
          userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user],
          true,
          stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[usersShiftIndex]
        );

        amountStakedLong -= userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user];
        userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user] = 0;
      }

      if (userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user] > 0) {
        amountStakedLong += ILongShort(longShort).getAmountSyntheticTokenToMintOnTargetSide(
          marketIndex,
          userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user],
          false,
          stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[usersShiftIndex]
        );

        amountStakedShort -= userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user];
        userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user] = 0;
      }

      // Save the users updated staked amounts
      userAmountStaked[longToken][user] = amountStakedLong;
      userAmountStaked[shortToken][user] = amountStakedShort;

      floatReward += _calculateAccumulatedFloatInRange(
        marketIndex,
        amountStakedLong,
        amountStakedShort,
        stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[usersShiftIndex],
        latestRewardIndex[marketIndex]
      );

      userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][user] = 0;
    } else {
      floatReward = _calculateAccumulatedFloatInRange(
        marketIndex,
        amountStakedLong,
        amountStakedShort,
        usersLastRewardIndex,
        latestRewardIndex[marketIndex]
      );
    }
  }

  /**
  @notice Mints float for a user.
  @dev Mints a fixed percentage for Float capital.
  @param user The address of the user.
  @param floatToMint The amount of float to mint.
   */
  function _mintFloat(address user, uint256 floatToMint) internal virtual {
    IFloatToken(floatToken).mint(user, floatToMint);
    IFloatToken(floatToken).mint(floatCapital, (floatToMint * floatPercentage) / 1e18);
  }

  /**
  @notice Mints float owed to a user for a market since they last minted.
  @param marketIndex An identifier for the market.
  @param user The address of the user.
   */
  function _mintAccumulatedFloat(uint32 marketIndex, address user) internal virtual {
    uint256 floatToMint = _calculateAccumulatedFloat(marketIndex, user);

    if (floatToMint > 0) {
      // Set the user has claimed up until now, stops them setting this forward
      userIndexOfLastClaimedReward[marketIndex][user] = latestRewardIndex[marketIndex];

      _mintFloat(user, floatToMint);
      emit FloatMinted(user, marketIndex, floatToMint);
    }
  }

  /**
  @notice Mints float owed to a user for multiple markets, since they last minted for those markets.
  @param marketIndexes Identifiers for the markets.
  @param user The address of the user.
   */
  function _mintAccumulatedFloatMulti(uint32[] calldata marketIndexes, address user) internal virtual {
    uint256 floatTotal = 0;
    for (uint256 i = 0; i < marketIndexes.length; i++) {
      uint256 floatToMint = _calculateAccumulatedFloat(marketIndexes[i], user);

      if (floatToMint > 0) {
        // Set the user has claimed up until now, stops them setting this forward
        userIndexOfLastClaimedReward[marketIndexes[i]][user] = latestRewardIndex[marketIndexes[i]];

        floatTotal += floatToMint;

        emit FloatMinted(user, marketIndexes[i], floatToMint);
      }
    }
    if (floatTotal > 0) {
      _mintFloat(user, floatTotal);
    }
  }

  /**
  @notice Mints outstanding float for msg.sender.
  @param marketIndexes Identifiers for the markets for which to mint float.
   */
  function claimFloatCustom(uint32[] calldata marketIndexes) external {
    ILongShort(longShort).updateSystemStateMulti(marketIndexes);
    _mintAccumulatedFloatMulti(marketIndexes, msg.sender);
  }

  /**
  @notice Mints outstanding float on behalf of another user.
  @param marketIndexes Identifiers for the markets for which to mint float.
  @param user The address of the user.
   */
  function claimFloatCustomFor(uint32[] calldata marketIndexes, address user) external {
    // Unbounded loop - users are responsible for paying their own gas costs on these and it doesn't effect the rest of the system.
    // No need to impose limit.
    ILongShort(longShort).updateSystemStateMulti(marketIndexes);
    _mintAccumulatedFloatMulti(marketIndexes, user);
  }

  /*╔═══════════════════════╗
    ║        STAKING        ║
    ╚═══════════════════════╝*/

  /**
  @notice A user with synthetic tokens stakes by calling stake on the token
  contract which calls this function. We need to first update the
  state of the LongShort contract for this market before staking to correctly calculate user rewards.
  @param amount Amount to stake.
  @param from Address to stake for.
  */
  function stakeFromUser(address from, uint256 amount) public virtual override onlyValidSynthetic((msg.sender)) {
    ILongShort(longShort).updateSystemState(marketIndexOfToken[(msg.sender)]);
    _stake((msg.sender), amount, from);
  }

  /**
  @dev Internal logic for staking.
  @param token Address of the token for which to stake.
  @param amount Amount to stake.
  @param user Address to stake for.
  */
  function _stake(
    address token,
    uint256 amount,
    address user
  ) internal virtual {
    uint32 marketIndex = marketIndexOfToken[token];

    // If they already have staked and have rewards due, mint these.
    if (
      userIndexOfLastClaimedReward[marketIndex][user] != 0 &&
      userIndexOfLastClaimedReward[marketIndex][user] < latestRewardIndex[marketIndex]
    ) {
      _mintAccumulatedFloat(marketIndex, user);
    }

    userAmountStaked[token][user] = userAmountStaked[token][user] + amount;

    userIndexOfLastClaimedReward[marketIndex][user] = latestRewardIndex[marketIndex];

    emit StakeAdded(user, address(token), amount, userIndexOfLastClaimedReward[marketIndex][user]);
  }

  /**
  @notice Allows users to shift their staked tokens from one side of the market to 
  the other at the next price.
  @param amountSyntheticTokensToShift Amount of tokens to shift.
  @param marketIndex Identifier for the market.
  @param isShiftFromLong Whether the shift is from long to short or short to long.
  */
  function shiftTokens(
    uint256 amountSyntheticTokensToShift,
    uint32 marketIndex,
    bool isShiftFromLong
  ) external virtual {
    address token = syntheticTokens[marketIndex][isShiftFromLong];
    require(userAmountStaked[token][msg.sender] >= amountSyntheticTokensToShift, "Not enough tokens to shift");

    // If the user has outstanding token shift that have already been confirmed in the LongShort
    // contract, execute them first.
    if (
      userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] != 0 &&
      userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] <
      batched_stakerNextTokenShiftIndex[marketIndex]
    ) {
      _mintAccumulatedFloat(marketIndex, msg.sender);
    }

    if (isShiftFromLong) {
      ILongShort(longShort).shiftPositionFromLongNextPrice(marketIndex, amountSyntheticTokensToShift);
      userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][
        msg.sender
      ] += amountSyntheticTokensToShift;
    } else {
      ILongShort(longShort).shiftPositionFromShortNextPrice(marketIndex, amountSyntheticTokensToShift);
      userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][
        msg.sender
      ] += amountSyntheticTokensToShift;
    }

    userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] = batched_stakerNextTokenShiftIndex[
      marketIndex
    ];
  }

  /*╔════════════════════════════╗
    ║    WITHDRAWAL & MINTING    ║
    ╚════════════════════════════╝*/

  /**
  @notice Internal logic for withdrawing stakes.
  @dev Mint user any outstanding float before withdrawing.
  @param marketIndex Market index of token.
  @param amount Amount to withdraw.
  @param token Synthetic token that was staked.
  */
  function _withdraw(
    uint32 marketIndex,
    address token,
    uint256 amount
  ) internal virtual {
    require(userAmountStaked[token][msg.sender] > 0, "nothing to withdraw");
    _mintAccumulatedFloat(marketIndex, msg.sender);

    userAmountStaked[token][msg.sender] = userAmountStaked[token][msg.sender] - amount;

    uint256 amountFees = (amount * marketUnstakeFee_e18[marketIndex]) / 1e18;

    IERC20(token).transfer(floatTreasury, amountFees);
    IERC20(token).transfer(msg.sender, amount - amountFees);

    emit StakeWithdrawn(msg.sender, token, amount);
  }

  /**
  @notice Withdraw function. Allows users to unstake.
  @param amount Amount to withdraw.
  @param token Address of the token for which to withdraw.
  */
  function withdraw(address token, uint256 amount) external {
    ILongShort(longShort).updateSystemState(marketIndexOfToken[token]);

    uint32 marketIndex = marketIndexOfToken[token];

    _withdraw(marketIndex, token, amount);

    if (userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] > 0) {
      // If they still have outstanding shifts after minting float, then check
      // that they don't withdraw more than their shifts allow.
      uint256 amountToShiftForThisToken = syntheticTokens[marketIndex][true] == token
        ? userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][msg.sender]
        : userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][msg.sender];

      require(
        userAmountStaked[token][msg.sender] >= amountToShiftForThisToken,
        "Outstanding next price stake shifts too great"
      );
    }
  }

  /**
  @notice Allows users to withdraw their entire stake for a token.
  @param token Address of the token for which to withdraw.
  */
  function withdrawAll(address token) external {
    ILongShort(longShort).updateSystemState(marketIndexOfToken[token]);

    uint32 marketIndex = marketIndexOfToken[token];

    uint256 amountToShiftForThisToken = syntheticTokens[marketIndex][true] == token
      ? userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][msg.sender]
      : userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][msg.sender];

    _withdraw(marketIndex, token, userAmountStaked[token][msg.sender] - amountToShiftForThisToken);
  }
}
.]

Given the user's task and the brainstorming ideas provided:
Task: "// SPDX-License-Identifier: BUSL-1.1

pragma solidity 0.8.3;

import "@openzeppelin/contracts-upgradeable/token/ERC20/presets/ERC20PresetMinterPauserUpgradeable.sol";

import "./interfaces/IFloatToken.sol";
import "./interfaces/ILongShort.sol";
import "./interfaces/IStaker.sol";
import "./interfaces/ISyntheticToken.sol";

contract Staker is IStaker, Initializable {
  /*╔═════════════════════════════╗
    ║          VARIABLES          ║
    ╚═════════════════════════════╝*/

  /* ══════ Fixed-precision constants ══════ */
  uint256 public constant FLOAT_ISSUANCE_FIXED_DECIMAL = 1e42;
  // 2^52 ~= 4.5e15
  // With an exponent of 5, the largest total liquidity possible in a market (to avoid integer overflow on exponentiation) is ~10^31 or 10 Trillion (10^13)
  // NOTE: this also means if the total market value is less than 2^52 there will be a division by zero error
  uint256 public constant safeExponentBitShifting = 52;

  /* ══════ Global state ══════ */
  address public admin;
  address public floatCapital;
  address public floatTreasury;
  uint256 public floatPercentage;

  address public longShort;
  address public floatToken;

  /* ══════ Market specific ══════ */
  mapping(uint32 => uint256) public marketLaunchIncentive_period; // seconds
  mapping(uint32 => uint256) public marketLaunchIncentive_multipliers; // e18 scale
  mapping(uint32 => uint256) public marketUnstakeFee_e18;
  mapping(uint32 => uint256) public balanceIncentiveCurve_exponent;
  mapping(uint32 => int256) public balanceIncentiveCurve_equilibriumOffset;

  mapping(uint32 => mapping(bool => address)) public syntheticTokens;

  mapping(address => uint32) public marketIndexOfToken;

  /* ══════ Reward specific ══════ */
  mapping(uint32 => uint256) public latestRewardIndex;
  mapping(uint32 => mapping(uint256 => AccumulativeIssuancePerStakedSynthSnapshot))
    public accumulativeFloatPerSyntheticTokenSnapshots;
  struct AccumulativeIssuancePerStakedSynthSnapshot {
    uint256 timestamp;
    uint256 accumulativeFloatPerSyntheticToken_long;
    uint256 accumulativeFloatPerSyntheticToken_short;
  }

  /* ══════ User specific ══════ */
  mapping(uint32 => mapping(address => uint256)) public userIndexOfLastClaimedReward;
  mapping(address => mapping(address => uint256)) public userAmountStaked;

  /* ══════ Token shift management specific ══════ */
  mapping(uint32 => uint256) public batched_stakerNextTokenShiftIndex;
  /**
  @notice Used to link a token shift to a staker state
  @dev tokenShiftIndex => accumulativeFloatIssuanceSnapshotIndex
    POSSIBLE OPTIMIZATION - could pack stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping and stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping into a struct of two uint128 for storage space optimization.
  */
  mapping(uint256 => uint256) public stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping;
  /// @notice Used to fetch the price from LongShort at that point in time
  /// @dev tokenShiftIndex => longShortMarketPriceSnapshotIndex
  mapping(uint256 => uint256) public stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping;
  /// @dev marketIndex => usersAddress => stakerTokenShiftIndex
  mapping(uint32 => mapping(address => uint256)) public userNextPrice_stakedSyntheticTokenShiftIndex;
  /// @dev marketIndex => usersAddress => amountUserRequestedToShiftAwayFromLongOnNextUpdate
  mapping(uint32 => mapping(address => uint256)) public userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long;
  /// @dev marketIndex => usersAddress => amountUserRequestedToShiftAwayFromShortOnNextUpdate
  mapping(uint32 => mapping(address => uint256)) public userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short;

  /*╔════════════════════════════╗
    ║           EVENTS           ║
    ╚════════════════════════════╝*/

  event StakerV1(
    address admin,
    address floatTreasury,
    address floatCapital,
    address floatToken,
    uint256 floatPercentage
  );

  event MarketAddedToStaker(
    uint32 marketIndex,
    uint256 exitFee_e18,
    uint256 period,
    uint256 multiplier,
    uint256 balanceIncentiveExponent,
    int256 balanceIncentiveEquilibriumOffset
  );

  event AccumulativeIssuancePerStakedSynthSnapshotCreated(
    uint32 marketIndex,
    uint256 accumulativeFloatIssuanceSnapshotIndex,
    uint256 accumulativeLong,
    uint256 accumulativeShort
  );

  event StakeAdded(address user, address token, uint256 amount, uint256 lastMintIndex);

  event StakeWithdrawn(address user, address token, uint256 amount);

  // Note: the `amountFloatMinted` isn't strictly needed by the graph, but it is good to add it to validate calculations are accurate.
  event FloatMinted(address user, uint32 marketIndex, uint256 amountFloatMinted);

  event MarketLaunchIncentiveParametersChanges(uint32 marketIndex, uint256 period, uint256 multiplier);

  event StakeWithdrawalFeeUpdated(uint32 marketIndex, uint256 stakeWithdralFee);

  event BalanceIncentiveExponentUpdated(uint32 marketIndex, uint256 balanceIncentiveExponent);

  event BalanceIncentiveEquilibriumOffsetUpdated(uint32 marketIndex, int256 balanceIncentiveEquilibriumOffset);

  event FloatPercentageUpdated(uint256 floatPercentage);

  event SyntheticTokensShifted();

  event ChangeAdmin(address newAdmin);

  /*╔═════════════════════════════╗
    ║          MODIFIERS          ║
    ╚═════════════════════════════╝*/

  function onlyAdminModifierLogic() internal virtual {
    require(msg.sender == admin, "not admin");
  }

  modifier onlyAdmin() {
    onlyAdminModifierLogic();
    _;
  }

  function onlyValidSyntheticModifierLogic(address _synth) internal virtual {
    require(marketIndexOfToken[_synth] != 0, "not valid synth");
  }

  modifier onlyValidSynthetic(address _synth) {
    onlyValidSyntheticModifierLogic(_synth);
    _;
  }

  function onlyValidMarketModifierLogic(uint32 marketIndex) internal virtual {
    require(address(syntheticTokens[marketIndex][true]) != address(0), "not valid market");
  }

  modifier onlyValidMarket(uint32 marketIndex) {
    onlyValidMarketModifierLogic(marketIndex);
    _;
  }

  function onlyLongShortModifierLogic() internal virtual {
    require(msg.sender == address(longShort), "not long short");
  }

  modifier onlyLongShort() {
    onlyLongShortModifierLogic();
    _;
  }

  /*╔═════════════════════════════╗
    ║       CONTRACT SET-UP       ║
    ╚═════════════════════════════╝*/

  /**
  @notice Initializes the contract.
  @dev Calls OpenZeppelin's initializer modifier.
  @param _admin Address of the admin role.
  @param _longShort Address of the LongShort contract, a deployed LongShort.sol
  @param _floatToken Address of the Float token earned by staking.
  @param _floatTreasury Address of the treasury contract for managing fees.
  @param _floatCapital Address of the contract which earns a fixed percentage of Float.
  @param _floatPercentage Determines the float percentage that gets minted for Float Capital, base 1e18.
  */
  function initialize(
    address _admin,
    address _longShort,
    address _floatToken,
    address _floatTreasury,
    address _floatCapital,
    uint256 _floatPercentage
  ) external virtual initializer {
    admin = _admin;
    floatCapital = _floatCapital;
    floatTreasury = _floatTreasury;
    longShort = _longShort;
    floatToken = _floatToken;

    _changeFloatPercentage(_floatPercentage);

    emit StakerV1(_admin, _floatTreasury, _floatCapital, _floatToken, _floatPercentage);
  }

  /*╔═══════════════════╗
    ║       ADMIN       ║
    ╚═══════════════════╝*/

  /** 
  @notice Changes admin for the contract
  @param _admin The address of the new admin.
  */
  function changeAdmin(address _admin) external onlyAdmin {
    admin = _admin;
    emit ChangeAdmin(_admin);
  }

  /// @dev Logic for changeFloatPercentage
  function _changeFloatPercentage(uint256 newFloatPercentage) internal virtual {
    require(newFloatPercentage <= 1e18 && newFloatPercentage > 0); // less than or equal to 100% and greater than 0%
    floatPercentage = newFloatPercentage;
  }

  /**
  @notice Changes percentage of float that is minted for float capital.
  @param newFloatPercentage The new float percentage in base 1e18.
  */
  function changeFloatPercentage(uint256 newFloatPercentage) external onlyAdmin {
    _changeFloatPercentage(newFloatPercentage);
    emit FloatPercentageUpdated(newFloatPercentage);
  }

  /// @dev Logic for changeUnstakeFee
  function _changeUnstakeFee(uint32 marketIndex, uint256 newMarketUnstakeFee_e18) internal virtual {
    require(newMarketUnstakeFee_e18 <= 5e16); // Explicitely stating 5% fee as the max fee possible.
    marketUnstakeFee_e18[marketIndex] = newMarketUnstakeFee_e18;
  }

  /**
  @notice Changes unstake fee for a market
  @param marketIndex Identifies the market.
  @param newMarketUnstakeFee_e18 The new unstake fee.
  */
  function changeUnstakeFee(uint32 marketIndex, uint256 newMarketUnstakeFee_e18) external onlyAdmin {
    _changeUnstakeFee(marketIndex, newMarketUnstakeFee_e18);
    emit StakeWithdrawalFeeUpdated(marketIndex, newMarketUnstakeFee_e18);
  }

  /// @dev Logic for changeMarketLaunchIncentiveParameters
  function _changeMarketLaunchIncentiveParameters(
    uint32 marketIndex,
    uint256 period,
    uint256 initialMultiplier
  ) internal virtual {
    require(initialMultiplier >= 1e18, "marketLaunchIncentiveMultiplier must be >= 1e18");

    marketLaunchIncentive_period[marketIndex] = period;
    marketLaunchIncentive_multipliers[marketIndex] = initialMultiplier;
  }

  /**
  @notice Changes the market launch incentive parameters for a market
  @param marketIndex Identifies the market.
  @param period The new period for which float token generation should be boosted.
  @param initialMultiplier The new multiplier on Float generation.
  */
  function changeMarketLaunchIncentiveParameters(
    uint32 marketIndex,
    uint256 period,
    uint256 initialMultiplier
  ) external onlyAdmin {
    _changeMarketLaunchIncentiveParameters(marketIndex, period, initialMultiplier);

    emit MarketLaunchIncentiveParametersChanges(marketIndex, period, initialMultiplier);
  }

  /// @dev Logic for changeBalanceIncentiveExponent
  function _changeBalanceIncentiveExponent(uint32 marketIndex, uint256 _balanceIncentiveCurve_exponent)
    internal
    virtual
  {
    require(
      // The exponent has to be less than 5 in these versions of the contracts.
      _balanceIncentiveCurve_exponent > 0 && _balanceIncentiveCurve_exponent < 6,
      "balanceIncentiveCurve_exponent out of bounds"
    );

    balanceIncentiveCurve_exponent[marketIndex] = _balanceIncentiveCurve_exponent;
  }

  /** 
  @notice Changes the balance incentive exponent for a market
  @param marketIndex Identifies the market.
  @param _balanceIncentiveCurve_exponent The new exponent for the curve.
  */
  function changeBalanceIncentiveExponent(uint32 marketIndex, uint256 _balanceIncentiveCurve_exponent)
    external
    onlyAdmin
  {
    _changeBalanceIncentiveExponent(marketIndex, _balanceIncentiveCurve_exponent);

    emit BalanceIncentiveExponentUpdated(marketIndex, _balanceIncentiveCurve_exponent);
  }

  /// @dev Logic for changeBalanceIncentiveEquilibriumOffset
  function _changeBalanceIncentiveEquilibriumOffset(uint32 marketIndex, int256 _balanceIncentiveCurve_equilibriumOffset)
    internal
    virtual
  {
    // Unreasonable that we would ever shift this more than 90% either way
    require(
      _balanceIncentiveCurve_equilibriumOffset > -9e17 && _balanceIncentiveCurve_equilibriumOffset < 9e17,
      "balanceIncentiveCurve_equilibriumOffset out of bounds"
    );

    balanceIncentiveCurve_equilibriumOffset[marketIndex] = _balanceIncentiveCurve_equilibriumOffset;
  }

  /**
  @notice Changes the balance incentive curve equilibrium offset for a market
  @param marketIndex Identifies the market.
  @param _balanceIncentiveCurve_equilibriumOffset The new offset.
  */
  function changeBalanceIncentiveEquilibriumOffset(uint32 marketIndex, int256 _balanceIncentiveCurve_equilibriumOffset)
    external
    onlyAdmin
  {
    _changeBalanceIncentiveEquilibriumOffset(marketIndex, _balanceIncentiveCurve_equilibriumOffset);

    emit BalanceIncentiveEquilibriumOffsetUpdated(marketIndex, _balanceIncentiveCurve_equilibriumOffset);
  }

  /*╔═════════════════════════════╗
    ║        STAKING SETUP        ║
    ╚═════════════════════════════╝*/

  /**
  @notice Sets this contract to track staking for a market in LongShort.sol
  @param marketIndex Identifies the market.
  @param longToken Address of the long token for the market.
  @param shortToken Address of the short token for the market.
  @param kInitialMultiplier Initial boost on float generation for the market.
  @param kPeriod Period which the boost should last.
  @param unstakeFee_e18 Percentage of tokens that are levied on unstaking in base 1e18.
  @param _balanceIncentiveCurve_exponent Exponent for balance curve (see _calculateFloatPerSecond)
  @param _balanceIncentiveCurve_equilibriumOffset Offset for balance curve (see _calculateFloatPerSecond)
  */
  function addNewStakingFund(
    uint32 marketIndex,
    address longToken,
    address shortToken,
    uint256 kInitialMultiplier,
    uint256 kPeriod,
    uint256 unstakeFee_e18,
    uint256 _balanceIncentiveCurve_exponent,
    int256 _balanceIncentiveCurve_equilibriumOffset
  ) external override onlyLongShort {
    marketIndexOfToken[longToken] = marketIndex;
    marketIndexOfToken[shortToken] = marketIndex;

    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].timestamp = block.timestamp;
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].accumulativeFloatPerSyntheticToken_long = 0;
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].accumulativeFloatPerSyntheticToken_short = 0;

    syntheticTokens[marketIndex][true] = longToken;
    syntheticTokens[marketIndex][false] = shortToken;

    _changeBalanceIncentiveExponent(marketIndex, _balanceIncentiveCurve_exponent);
    _changeBalanceIncentiveEquilibriumOffset(marketIndex, _balanceIncentiveCurve_equilibriumOffset);
    _changeMarketLaunchIncentiveParameters(marketIndex, kPeriod, kInitialMultiplier);

    _changeUnstakeFee(marketIndex, unstakeFee_e18);

    // Set this value to one initially - 0 is a null value and thus potentially bug prone.
    batched_stakerNextTokenShiftIndex[marketIndex] = 1;

    emit MarketAddedToStaker(
      marketIndex,
      unstakeFee_e18,
      kPeriod,
      kInitialMultiplier,
      _balanceIncentiveCurve_exponent,
      _balanceIncentiveCurve_equilibriumOffset
    );

    emit AccumulativeIssuancePerStakedSynthSnapshotCreated(marketIndex, 0, 0, 0);
  }

  /*╔═════════════════════════════════════════════════════════════════════════╗
    ║    GLOBAL FLT REWARD ACCUMULATION CALCULATION AND TRACKING FUNCTIONS    ║
    ╚═════════════════════════════════════════════════════════════════════════╝*/

  /**
  @notice Returns the K factor parameters for the given market with sensible
  defaults if they haven't been set yet.
  @param marketIndex The market to change the parameters for.
  @return period The period for which the k factor applies for in seconds.
  @return multiplier The multiplier on Float generation in this period.
  */
  function _getMarketLaunchIncentiveParameters(uint32 marketIndex)
    internal
    view
    virtual
    returns (uint256 period, uint256 multiplier)
  {
    period = marketLaunchIncentive_period[marketIndex];
    multiplier = marketLaunchIncentive_multipliers[marketIndex];

    if (multiplier < 1e18) {
      multiplier = 1e18; // multiplier of 1 by default
    }
  }

  /** 
  @notice Returns the extent to which a markets float generation should be adjusted
  based on the market's launch incentive parameters. Should start at multiplier
  then linearly change to 1e18 over time.
  @param marketIndex Identifies the market.
  @return k The calculated modifier for float generation.
  */
  function _getKValue(uint32 marketIndex) internal view virtual returns (uint256) {
    // Parameters controlling the float issuance multiplier.
    (uint256 kPeriod, uint256 kInitialMultiplier) = _getMarketLaunchIncentiveParameters(marketIndex);

    // Sanity check - under normal circumstances, the multipliers should
    // *never* be set to a value < 1e18, as there are guards against this.
    assert(kInitialMultiplier >= 1e18);

    uint256 initialTimestamp = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].timestamp;

    if (block.timestamp - initialTimestamp <= kPeriod) {
      return kInitialMultiplier - (((kInitialMultiplier - 1e18) * (block.timestamp - initialTimestamp)) / kPeriod);
    } else {
      return 1e18;
    }
  }

  /*
  @notice Computes the number of float tokens a user earns per second for
  every long/short synthetic token they've staked. The returned value has
  a fixed decimal scale of 1e42 (!!!) for numerical stability. The return
  values are float per second per synthetic token (hence the requirement
  to multiply by price)
  @dev to see below math in latex form see TODO add link
  to interact with the equations see https://www.desmos.com/calculator/optkaxyihr
  @param marketIndex The market referred to.
  @param longPrice Price of the synthetic long token in units of payment token
  @param shortPrice Price of the synthetic short token in units of payment token
  @param longValue Amount of payment token in the long side of the market
  @param shortValue Amount of payment token in the short side of the market
  @return longFloatPerSecond Float token per second per long synthetic token
  @return shortFloatPerSecond Float token per second per short synthetic token
   */
  function _calculateFloatPerSecond(
    uint32 marketIndex,
    uint256 longPrice,
    uint256 shortPrice,
    uint256 longValue,
    uint256 shortValue
  ) internal view virtual returns (uint256 longFloatPerSecond, uint256 shortFloatPerSecond) {
    // A float issuance multiplier that starts high and decreases linearly
    // over time to a value of 1. This incentivises users to stake early.
    uint256 k = _getKValue(marketIndex);

    uint256 totalLocked = (longValue + shortValue);

    // we need to scale this number by the totalLocked so that the offset remains consistent accross market size

    int256 equilibriumOffsetMarketScaled = (balanceIncentiveCurve_equilibriumOffset[marketIndex] *
      int256(totalLocked)) / 2e18;

    uint256 denominator = ((totalLocked >> safeExponentBitShifting)**balanceIncentiveCurve_exponent[marketIndex]);

    // Float is scaled by the percentage of the total market value held in
    // the opposite position. This incentivises users to stake on the
    // weaker position.
    if (int256(shortValue) - equilibriumOffsetMarketScaled < int256(longValue)) {
      if (equilibriumOffsetMarketScaled >= int256(shortValue)) {
        // edge case: imbalanced far past the equilibrium offset - full rewards go to short token
        //            extremeley unlikely to happen in practice
        return (0, 1e18 * k * shortPrice);
      }

      uint256 numerator = (uint256(int256(shortValue) - equilibriumOffsetMarketScaled) >>
        (safeExponentBitShifting - 1))**balanceIncentiveCurve_exponent[marketIndex];

      // NOTE: `x * 5e17` == `(x * 10e18) / 2`
      uint256 longRewardUnscaled = (numerator * 5e17) / denominator;
      uint256 shortRewardUnscaled = 1e18 - longRewardUnscaled;

      return ((longRewardUnscaled * k * longPrice) / 1e18, (shortRewardUnscaled * k * shortPrice) / 1e18);
    } else {
      if (-equilibriumOffsetMarketScaled >= int256(longValue)) {
        // edge case: imbalanced far past the equilibrium offset - full rewards go to long token
        //            extremeley unlikely to happen in practice
        return (1e18 * k * longPrice, 0);
      }

      uint256 numerator = (uint256(int256(longValue) + equilibriumOffsetMarketScaled) >>
        (safeExponentBitShifting - 1))**balanceIncentiveCurve_exponent[marketIndex];

      // NOTE: `x * 5e17` == `(x * 10e18) / 2`
      uint256 shortRewardUnscaled = (numerator * 5e17) / denominator;
      uint256 longRewardUnscaled = 1e18 - shortRewardUnscaled;

      return ((longRewardUnscaled * k * longPrice) / 1e18, (shortRewardUnscaled * k * shortPrice) / 1e18);
    }
  }

  /**
  @notice Computes the time since last accumulativeIssuancePerStakedSynthSnapshot for the given market in seconds.
  @param marketIndex The market referred to.
  @return The time difference in seconds
  */
  function _calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(uint32 marketIndex)
    internal
    view
    virtual
    returns (uint256)
  {
    return
      block.timestamp -
      accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]].timestamp;
  }

  /**
  @notice Computes new cumulative sum of 'r' value since last accumulativeIssuancePerStakedSynthSnapshot. We use
  cumulative 'r' value to avoid looping during issuance. Note that the
  cumulative sum is kept in 1e42 scale (!!!) to avoid numerical issues.
  @param shortValue The value locked in the short side of the market.
  @param longValue The value locked in the long side of the market.
  @param shortPrice The price of the short token as defined in LongShort.sol
  @param longPrice The price of the long token as defined in LongShort.sol
  @param marketIndex An identifier for the market.
  @return longCumulativeRates The long cumulative sum.
  @return shortCumulativeRates The short cumulative sum.
  */
  function _calculateNewCumulativeIssuancePerStakedSynth(
    uint32 marketIndex,
    uint256 longPrice,
    uint256 shortPrice,
    uint256 longValue,
    uint256 shortValue
  ) internal view virtual returns (uint256 longCumulativeRates, uint256 shortCumulativeRates) {
    // Compute the current 'r' value for float issuance per second.
    (uint256 longFloatPerSecond, uint256 shortFloatPerSecond) = _calculateFloatPerSecond(
      marketIndex,
      longPrice,
      shortPrice,
      longValue,
      shortValue
    );

    // Compute time since last accumulativeIssuancePerStakedSynthSnapshot for the given token.
    uint256 timeDelta = _calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(marketIndex);

    // Compute new cumulative 'r' value total.
    return (
      accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]]
      .accumulativeFloatPerSyntheticToken_long + (timeDelta * longFloatPerSecond),
      accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]]
      .accumulativeFloatPerSyntheticToken_short + (timeDelta * shortFloatPerSecond)
    );
  }

  /**
  @notice Creates a new accumulativeIssuancePerStakedSynthSnapshot for the given token and updates indexes.
  @param shortValue The value locked in the short side of the market.
  @param longValue The value locked in the long side of the market.
  @param shortPrice The price of the short token as defined in LongShort.sol
  @param longPrice The price of the long token as defined in LongShort.sol
  @param marketIndex An identifier for the market.
  */
  function _setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot(
    uint32 marketIndex,
    uint256 longPrice,
    uint256 shortPrice,
    uint256 longValue,
    uint256 shortValue
  ) internal virtual {
    (
      uint256 newLongAccumulativeValue,
      uint256 newShortAccumulativeValue
    ) = _calculateNewCumulativeIssuancePerStakedSynth(marketIndex, longPrice, shortPrice, longValue, shortValue);

    uint256 newIndex = latestRewardIndex[marketIndex] + 1;

    // Set cumulative 'r' value on new accumulativeIssuancePerStakedSynthSnapshot.
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex]
    .accumulativeFloatPerSyntheticToken_long = newLongAccumulativeValue;
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex]
    .accumulativeFloatPerSyntheticToken_short = newShortAccumulativeValue;

    // Set timestamp on new accumulativeIssuancePerStakedSynthSnapshot.
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex].timestamp = block.timestamp;

    // Update latest index to point to new accumulativeIssuancePerStakedSynthSnapshot.
    latestRewardIndex[marketIndex] = newIndex;

    emit AccumulativeIssuancePerStakedSynthSnapshotCreated(
      marketIndex,
      newIndex,
      newLongAccumulativeValue,
      newShortAccumulativeValue
    );
  }

  /**
  @notice Adds new accumulativeIssuancePerStakedSynthSnapshots for the given long/short tokens. Called by the
  ILongShort contract whenever there is a state change for a market.
  @param stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted Mapping from this contract's shifts to LongShort.sols next price snapshots.
  @param shortValue The value locked in the short side of the market.
  @param longValue The value locked in the long side of the market.
  @param shortPrice The price of the short token as defined in LongShort.sol
  @param longPrice The price of the long token as defined in LongShort.sol
  @param marketIndex An identifier for the market.
  */
  function pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(
    uint32 marketIndex,
    uint256 longPrice,
    uint256 shortPrice,
    uint256 longValue,
    uint256 shortValue,
    uint256 stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted // This value should be ALWAYS be zero if no shift occured
  ) external override onlyLongShort {
    // Only add a new accumulativeIssuancePerStakedSynthSnapshot if some time has passed.

    // the `stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted` value will be 0 if there is no staker related action in an executed batch
    if (stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted > 0) {
      stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[
        batched_stakerNextTokenShiftIndex[marketIndex]
      ] = stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted;
      stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[
        batched_stakerNextTokenShiftIndex[marketIndex]
      ] = latestRewardIndex[marketIndex] + 1;
      batched_stakerNextTokenShiftIndex[marketIndex] += 1;

      emit SyntheticTokensShifted();
    }

    // Time delta is fetched twice in below code, can pass through? Which is less gas?
    if (_calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(marketIndex) > 0) {
      _setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot(
        marketIndex,
        longPrice,
        shortPrice,
        longValue,
        shortValue
      );
    }
  }

  /*╔═══════════════════════════════════╗
    ║    USER REWARD STATE FUNCTIONS    ║
    ╚═══════════════════════════════════╝*/

  /// @dev Calculates the accumulated float in a specific range of staker snapshots
  function _calculateAccumulatedFloatInRange(
    uint32 marketIndex,
    uint256 amountStakedLong,
    uint256 amountStakedShort,
    uint256 rewardIndexFrom,
    uint256 rewardIndexTo
  ) internal view virtual returns (uint256 floatReward) {
    if (amountStakedLong > 0) {
      uint256 accumDeltaLong = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexTo]
      .accumulativeFloatPerSyntheticToken_long -
        accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexFrom]
        .accumulativeFloatPerSyntheticToken_long;
      floatReward += (accumDeltaLong * amountStakedLong) / FLOAT_ISSUANCE_FIXED_DECIMAL;
    }

    if (amountStakedShort > 0) {
      uint256 accumDeltaShort = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexTo]
      .accumulativeFloatPerSyntheticToken_short -
        accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexFrom]
        .accumulativeFloatPerSyntheticToken_short;
      floatReward += (accumDeltaShort * amountStakedShort) / FLOAT_ISSUANCE_FIXED_DECIMAL;
    }
  }

  /** 
  @notice Calculates float owed to the user since the user last minted float for a market.
  @param marketIndex Identifier for the market which the user staked in.
  @param user The address of the user.
  @return floatReward The amount of float owed.
   */
  function _calculateAccumulatedFloat(uint32 marketIndex, address user) internal virtual returns (uint256 floatReward) {
    address longToken = syntheticTokens[marketIndex][true];
    address shortToken = syntheticTokens[marketIndex][false];

    uint256 amountStakedLong = userAmountStaked[longToken][user];
    uint256 amountStakedShort = userAmountStaked[shortToken][user];

    uint256 usersLastRewardIndex = userIndexOfLastClaimedReward[marketIndex][user];

    // Don't do the calculation and return zero immediately if there is no change
    if (usersLastRewardIndex == latestRewardIndex[marketIndex]) {
      return 0;
    }

    uint256 usersShiftIndex = userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][user];
    // if there is a change in the users tokens held due to a token shift (or possibly another action in the future)
    if (usersShiftIndex > 0 && usersShiftIndex < batched_stakerNextTokenShiftIndex[marketIndex]) {
      floatReward = _calculateAccumulatedFloatInRange(
        marketIndex,
        amountStakedLong,
        amountStakedShort,
        usersLastRewardIndex,
        stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[usersShiftIndex]
      );

      // Update the users balances
      if (userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user] > 0) {
        amountStakedShort += ILongShort(longShort).getAmountSyntheticTokenToMintOnTargetSide(
          marketIndex,
          userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user],
          true,
          stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[usersShiftIndex]
        );

        amountStakedLong -= userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user];
        userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user] = 0;
      }

      if (userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user] > 0) {
        amountStakedLong += ILongShort(longShort).getAmountSyntheticTokenToMintOnTargetSide(
          marketIndex,
          userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user],
          false,
          stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[usersShiftIndex]
        );

        amountStakedShort -= userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user];
        userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user] = 0;
      }

      // Save the users updated staked amounts
      userAmountStaked[longToken][user] = amountStakedLong;
      userAmountStaked[shortToken][user] = amountStakedShort;

      floatReward += _calculateAccumulatedFloatInRange(
        marketIndex,
        amountStakedLong,
        amountStakedShort,
        stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[usersShiftIndex],
        latestRewardIndex[marketIndex]
      );

      userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][user] = 0;
    } else {
      floatReward = _calculateAccumulatedFloatInRange(
        marketIndex,
        amountStakedLong,
        amountStakedShort,
        usersLastRewardIndex,
        latestRewardIndex[marketIndex]
      );
    }
  }

  /**
  @notice Mints float for a user.
  @dev Mints a fixed percentage for Float capital.
  @param user The address of the user.
  @param floatToMint The amount of float to mint.
   */
  function _mintFloat(address user, uint256 floatToMint) internal virtual {
    IFloatToken(floatToken).mint(user, floatToMint);
    IFloatToken(floatToken).mint(floatCapital, (floatToMint * floatPercentage) / 1e18);
  }

  /**
  @notice Mints float owed to a user for a market since they last minted.
  @param marketIndex An identifier for the market.
  @param user The address of the user.
   */
  function _mintAccumulatedFloat(uint32 marketIndex, address user) internal virtual {
    uint256 floatToMint = _calculateAccumulatedFloat(marketIndex, user);

    if (floatToMint > 0) {
      // Set the user has claimed up until now, stops them setting this forward
      userIndexOfLastClaimedReward[marketIndex][user] = latestRewardIndex[marketIndex];

      _mintFloat(user, floatToMint);
      emit FloatMinted(user, marketIndex, floatToMint);
    }
  }

  /**
  @notice Mints float owed to a user for multiple markets, since they last minted for those markets.
  @param marketIndexes Identifiers for the markets.
  @param user The address of the user.
   */
  function _mintAccumulatedFloatMulti(uint32[] calldata marketIndexes, address user) internal virtual {
    uint256 floatTotal = 0;
    for (uint256 i = 0; i < marketIndexes.length; i++) {
      uint256 floatToMint = _calculateAccumulatedFloat(marketIndexes[i], user);

      if (floatToMint > 0) {
        // Set the user has claimed up until now, stops them setting this forward
        userIndexOfLastClaimedReward[marketIndexes[i]][user] = latestRewardIndex[marketIndexes[i]];

        floatTotal += floatToMint;

        emit FloatMinted(user, marketIndexes[i], floatToMint);
      }
    }
    if (floatTotal > 0) {
      _mintFloat(user, floatTotal);
    }
  }

  /**
  @notice Mints outstanding float for msg.sender.
  @param marketIndexes Identifiers for the markets for which to mint float.
   */
  function claimFloatCustom(uint32[] calldata marketIndexes) external {
    ILongShort(longShort).updateSystemStateMulti(marketIndexes);
    _mintAccumulatedFloatMulti(marketIndexes, msg.sender);
  }

  /**
  @notice Mints outstanding float on behalf of another user.
  @param marketIndexes Identifiers for the markets for which to mint float.
  @param user The address of the user.
   */
  function claimFloatCustomFor(uint32[] calldata marketIndexes, address user) external {
    // Unbounded loop - users are responsible for paying their own gas costs on these and it doesn't effect the rest of the system.
    // No need to impose limit.
    ILongShort(longShort).updateSystemStateMulti(marketIndexes);
    _mintAccumulatedFloatMulti(marketIndexes, user);
  }

  /*╔═══════════════════════╗
    ║        STAKING        ║
    ╚═══════════════════════╝*/

  /**
  @notice A user with synthetic tokens stakes by calling stake on the token
  contract which calls this function. We need to first update the
  state of the LongShort contract for this market before staking to correctly calculate user rewards.
  @param amount Amount to stake.
  @param from Address to stake for.
  */
  function stakeFromUser(address from, uint256 amount) public virtual override onlyValidSynthetic((msg.sender)) {
    ILongShort(longShort).updateSystemState(marketIndexOfToken[(msg.sender)]);
    _stake((msg.sender), amount, from);
  }

  /**
  @dev Internal logic for staking.
  @param token Address of the token for which to stake.
  @param amount Amount to stake.
  @param user Address to stake for.
  */
  function _stake(
    address token,
    uint256 amount,
    address user
  ) internal virtual {
    uint32 marketIndex = marketIndexOfToken[token];

    // If they already have staked and have rewards due, mint these.
    if (
      userIndexOfLastClaimedReward[marketIndex][user] != 0 &&
      userIndexOfLastClaimedReward[marketIndex][user] < latestRewardIndex[marketIndex]
    ) {
      _mintAccumulatedFloat(marketIndex, user);
    }

    userAmountStaked[token][user] = userAmountStaked[token][user] + amount;

    userIndexOfLastClaimedReward[marketIndex][user] = latestRewardIndex[marketIndex];

    emit StakeAdded(user, address(token), amount, userIndexOfLastClaimedReward[marketIndex][user]);
  }

  /**
  @notice Allows users to shift their staked tokens from one side of the market to 
  the other at the next price.
  @param amountSyntheticTokensToShift Amount of tokens to shift.
  @param marketIndex Identifier for the market.
  @param isShiftFromLong Whether the shift is from long to short or short to long.
  */
  function shiftTokens(
    uint256 amountSyntheticTokensToShift,
    uint32 marketIndex,
    bool isShiftFromLong
  ) external virtual {
    address token = syntheticTokens[marketIndex][isShiftFromLong];
    require(userAmountStaked[token][msg.sender] >= amountSyntheticTokensToShift, "Not enough tokens to shift");

    // If the user has outstanding token shift that have already been confirmed in the LongShort
    // contract, execute them first.
    if (
      userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] != 0 &&
      userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] <
      batched_stakerNextTokenShiftIndex[marketIndex]
    ) {
      _mintAccumulatedFloat(marketIndex, msg.sender);
    }

    if (isShiftFromLong) {
      ILongShort(longShort).shiftPositionFromLongNextPrice(marketIndex, amountSyntheticTokensToShift);
      userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][
        msg.sender
      ] += amountSyntheticTokensToShift;
    } else {
      ILongShort(longShort).shiftPositionFromShortNextPrice(marketIndex, amountSyntheticTokensToShift);
      userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][
        msg.sender
      ] += amountSyntheticTokensToShift;
    }

    userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] = batched_stakerNextTokenShiftIndex[
      marketIndex
    ];
  }

  /*╔════════════════════════════╗
    ║    WITHDRAWAL & MINTING    ║
    ╚════════════════════════════╝*/

  /**
  @notice Internal logic for withdrawing stakes.
  @dev Mint user any outstanding float before withdrawing.
  @param marketIndex Market index of token.
  @param amount Amount to withdraw.
  @param token Synthetic token that was staked.
  */
  function _withdraw(
    uint32 marketIndex,
    address token,
    uint256 amount
  ) internal virtual {
    require(userAmountStaked[token][msg.sender] > 0, "nothing to withdraw");
    _mintAccumulatedFloat(marketIndex, msg.sender);

    userAmountStaked[token][msg.sender] = userAmountStaked[token][msg.sender] - amount;

    uint256 amountFees = (amount * marketUnstakeFee_e18[marketIndex]) / 1e18;

    IERC20(token).transfer(floatTreasury, amountFees);
    IERC20(token).transfer(msg.sender, amount - amountFees);

    emit StakeWithdrawn(msg.sender, token, amount);
  }

  /**
  @notice Withdraw function. Allows users to unstake.
  @param amount Amount to withdraw.
  @param token Address of the token for which to withdraw.
  */
  function withdraw(address token, uint256 amount) external {
    ILongShort(longShort).updateSystemState(marketIndexOfToken[token]);

    uint32 marketIndex = marketIndexOfToken[token];

    _withdraw(marketIndex, token, amount);

    if (userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] > 0) {
      // If they still have outstanding shifts after minting float, then check
      // that they don't withdraw more than their shifts allow.
      uint256 amountToShiftForThisToken = syntheticTokens[marketIndex][true] == token
        ? userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][msg.sender]
        : userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][msg.sender];

      require(
        userAmountStaked[token][msg.sender] >= amountToShiftForThisToken,
        "Outstanding next price stake shifts too great"
      );
    }
  }

  /**
  @notice Allows users to withdraw their entire stake for a token.
  @param token Address of the token for which to withdraw.
  */
  function withdrawAll(address token) external {
    ILongShort(longShort).updateSystemState(marketIndexOfToken[token]);

    uint32 marketIndex = marketIndexOfToken[token];

    uint256 amountToShiftForThisToken = syntheticTokens[marketIndex][true] == token
      ? userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][msg.sender]
      : userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][msg.sender];

    _withdraw(marketIndex, token, userAmountStaked[token][msg.sender] - amountToShiftForThisToken);
  }
}
".
Ideas: " Security".
As the Security Analyst, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability.
For each vulnerability identified, use the following format:
VULNERABILITY NAME or TYPE
```
DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix.
```
Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: "<INFO> Analysis Complete."

[2024-17-08 08:01:57 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-17-08 08:01:57 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 19617
completion_tokens: 1
total_tokens: 19618
cost: $-1.000000


[2024-17-08 08:01:57 INFO] Security Analyst: **Security Analyst<->Solidity Programming Expert on : ContractReviewComment, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: BUSL-1.1

pragma solidity 0.8.3;

import "@openzeppelin/contracts-upgradeable/token/ERC20/presets/ERC20PresetMinterPauserUpgradeable.sol";

import "./interfaces/IFloatToken.sol";
import "./interfaces/ILongShort.sol";
import "./interfaces/IStaker.sol";
import "./interfaces/ISyntheticToken.sol";

contract Staker is IStaker, Initializable {
  /*╔═════════════════════════════╗
    ║          VARIABLES          ║
    ╚═════════════════════════════╝*/

  /* ══════ Fixed-precision constants ══════ */
  uint256 public constant FLOAT_ISSUANCE_FIXED_DECIMAL = 1e42;
  // 2^52 ~= 4.5e15
  // With an exponent of 5, the largest total liquidity possible in a market (to avoid integer overflow on exponentiation) is ~10^31 or 10 Trillion (10^13)
  // NOTE: this also means if the total market value is less than 2^52 there will be a division by zero error
  uint256 public constant safeExponentBitShifting = 52;

  /* ══════ Global state ══════ */
  address public admin;
  address public floatCapital;
  address public floatTreasury;
  uint256 public floatPercentage;

  address public longShort;
  address public floatToken;

  /* ══════ Market specific ══════ */
  mapping(uint32 => uint256) public marketLaunchIncentive_period; // seconds
  mapping(uint32 => uint256) public marketLaunchIncentive_multipliers; // e18 scale
  mapping(uint32 => uint256) public marketUnstakeFee_e18;
  mapping(uint32 => uint256) public balanceIncentiveCurve_exponent;
  mapping(uint32 => int256) public balanceIncentiveCurve_equilibriumOffset;

  mapping(uint32 => mapping(bool => address)) public syntheticTokens;

  mapping(address => uint32) public marketIndexOfToken;

  /* ══════ Reward specific ══════ */
  mapping(uint32 => uint256) public latestRewardIndex;
  mapping(uint32 => mapping(uint256 => AccumulativeIssuancePerStakedSynthSnapshot))
    public accumulativeFloatPerSyntheticTokenSnapshots;
  struct AccumulativeIssuancePerStakedSynthSnapshot {
    uint256 timestamp;
    uint256 accumulativeFloatPerSyntheticToken_long;
    uint256 accumulativeFloatPerSyntheticToken_short;
  }

  /* ══════ User specific ══════ */
  mapping(uint32 => mapping(address => uint256)) public userIndexOfLastClaimedReward;
  mapping(address => mapping(address => uint256)) public userAmountStaked;

  /* ══════ Token shift management specific ══════ */
  mapping(uint32 => uint256) public batched_stakerNextTokenShiftIndex;
  /**
  @notice Used to link a token shift to a staker state
  @dev tokenShiftIndex => accumulativeFloatIssuanceSnapshotIndex
    POSSIBLE OPTIMIZATION - could pack stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping and stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping into a struct of two uint128 for storage space optimization.
  */
  mapping(uint256 => uint256) public stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping;
  /// @notice Used to fetch the price from LongShort at that point in time
  /// @dev tokenShiftIndex => longShortMarketPriceSnapshotIndex
  mapping(uint256 => uint256) public stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping;
  /// @dev marketIndex => usersAddress => stakerTokenShiftIndex
  mapping(uint32 => mapping(address => uint256)) public userNextPrice_stakedSyntheticTokenShiftIndex;
  /// @dev marketIndex => usersAddress => amountUserRequestedToShiftAwayFromLongOnNextUpdate
  mapping(uint32 => mapping(address => uint256)) public userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long;
  /// @dev marketIndex => usersAddress => amountUserRequestedToShiftAwayFromShortOnNextUpdate
  mapping(uint32 => mapping(address => uint256)) public userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short;

  /*╔════════════════════════════╗
    ║           EVENTS           ║
    ╚════════════════════════════╝*/

  event StakerV1(
    address admin,
    address floatTreasury,
    address floatCapital,
    address floatToken,
    uint256 floatPercentage
  );

  event MarketAddedToStaker(
    uint32 marketIndex,
    uint256 exitFee_e18,
    uint256 period,
    uint256 multiplier,
    uint256 balanceIncentiveExponent,
    int256 balanceIncentiveEquilibriumOffset
  );

  event AccumulativeIssuancePerStakedSynthSnapshotCreated(
    uint32 marketIndex,
    uint256 accumulativeFloatIssuanceSnapshotIndex,
    uint256 accumulativeLong,
    uint256 accumulativeShort
  );

  event StakeAdded(address user, address token, uint256 amount, uint256 lastMintIndex);

  event StakeWithdrawn(address user, address token, uint256 amount);

  // Note: the `amountFloatMinted` isn't strictly needed by the graph, but it is good to add it to validate calculations are accurate.
  event FloatMinted(address user, uint32 marketIndex, uint256 amountFloatMinted);

  event MarketLaunchIncentiveParametersChanges(uint32 marketIndex, uint256 period, uint256 multiplier);

  event StakeWithdrawalFeeUpdated(uint32 marketIndex, uint256 stakeWithdralFee);

  event BalanceIncentiveExponentUpdated(uint32 marketIndex, uint256 balanceIncentiveExponent);

  event BalanceIncentiveEquilibriumOffsetUpdated(uint32 marketIndex, int256 balanceIncentiveEquilibriumOffset);

  event FloatPercentageUpdated(uint256 floatPercentage);

  event SyntheticTokensShifted();

  event ChangeAdmin(address newAdmin);

  /*╔═════════════════════════════╗
    ║          MODIFIERS          ║
    ╚═════════════════════════════╝*/

  function onlyAdminModifierLogic() internal virtual {
    require(msg.sender == admin, "not admin");
  }

  modifier onlyAdmin() {
    onlyAdminModifierLogic();
    _;
  }

  function onlyValidSyntheticModifierLogic(address _synth) internal virtual {
    require(marketIndexOfToken[_synth] != 0, "not valid synth");
  }

  modifier onlyValidSynthetic(address _synth) {
    onlyValidSyntheticModifierLogic(_synth);
    _;
  }

  function onlyValidMarketModifierLogic(uint32 marketIndex) internal virtual {
    require(address(syntheticTokens[marketIndex][true]) != address(0), "not valid market");
  }

  modifier onlyValidMarket(uint32 marketIndex) {
    onlyValidMarketModifierLogic(marketIndex);
    _;
  }

  function onlyLongShortModifierLogic() internal virtual {
    require(msg.sender == address(longShort), "not long short");
  }

  modifier onlyLongShort() {
    onlyLongShortModifierLogic();
    _;
  }

  /*╔═════════════════════════════╗
    ║       CONTRACT SET-UP       ║
    ╚═════════════════════════════╝*/

  /**
  @notice Initializes the contract.
  @dev Calls OpenZeppelin's initializer modifier.
  @param _admin Address of the admin role.
  @param _longShort Address of the LongShort contract, a deployed LongShort.sol
  @param _floatToken Address of the Float token earned by staking.
  @param _floatTreasury Address of the treasury contract for managing fees.
  @param _floatCapital Address of the contract which earns a fixed percentage of Float.
  @param _floatPercentage Determines the float percentage that gets minted for Float Capital, base 1e18.
  */
  function initialize(
    address _admin,
    address _longShort,
    address _floatToken,
    address _floatTreasury,
    address _floatCapital,
    uint256 _floatPercentage
  ) external virtual initializer {
    admin = _admin;
    floatCapital = _floatCapital;
    floatTreasury = _floatTreasury;
    longShort = _longShort;
    floatToken = _floatToken;

    _changeFloatPercentage(_floatPercentage);

    emit StakerV1(_admin, _floatTreasury, _floatCapital, _floatToken, _floatPercentage);
  }

  /*╔═══════════════════╗
    ║       ADMIN       ║
    ╚═══════════════════╝*/

  /** 
  @notice Changes admin for the contract
  @param _admin The address of the new admin.
  */
  function changeAdmin(address _admin) external onlyAdmin {
    admin = _admin;
    emit ChangeAdmin(_admin);
  }

  /// @dev Logic for changeFloatPercentage
  function _changeFloatPercentage(uint256 newFloatPercentage) internal virtual {
    require(newFloatPercentage <= 1e18 && newFloatPercentage > 0); // less than or equal to 100% and greater than 0%
    floatPercentage = newFloatPercentage;
  }

  /**
  @notice Changes percentage of float that is minted for float capital.
  @param newFloatPercentage The new float percentage in base 1e18.
  */
  function changeFloatPercentage(uint256 newFloatPercentage) external onlyAdmin {
    _changeFloatPercentage(newFloatPercentage);
    emit FloatPercentageUpdated(newFloatPercentage);
  }

  /// @dev Logic for changeUnstakeFee
  function _changeUnstakeFee(uint32 marketIndex, uint256 newMarketUnstakeFee_e18) internal virtual {
    require(newMarketUnstakeFee_e18 <= 5e16); // Explicitely stating 5% fee as the max fee possible.
    marketUnstakeFee_e18[marketIndex] = newMarketUnstakeFee_e18;
  }

  /**
  @notice Changes unstake fee for a market
  @param marketIndex Identifies the market.
  @param newMarketUnstakeFee_e18 The new unstake fee.
  */
  function changeUnstakeFee(uint32 marketIndex, uint256 newMarketUnstakeFee_e18) external onlyAdmin {
    _changeUnstakeFee(marketIndex, newMarketUnstakeFee_e18);
    emit StakeWithdrawalFeeUpdated(marketIndex, newMarketUnstakeFee_e18);
  }

  /// @dev Logic for changeMarketLaunchIncentiveParameters
  function _changeMarketLaunchIncentiveParameters(
    uint32 marketIndex,
    uint256 period,
    uint256 initialMultiplier
  ) internal virtual {
    require(initialMultiplier >= 1e18, "marketLaunchIncentiveMultiplier must be >= 1e18");

    marketLaunchIncentive_period[marketIndex] = period;
    marketLaunchIncentive_multipliers[marketIndex] = initialMultiplier;
  }

  /**
  @notice Changes the market launch incentive parameters for a market
  @param marketIndex Identifies the market.
  @param period The new period for which float token generation should be boosted.
  @param initialMultiplier The new multiplier on Float generation.
  */
  function changeMarketLaunchIncentiveParameters(
    uint32 marketIndex,
    uint256 period,
    uint256 initialMultiplier
  ) external onlyAdmin {
    _changeMarketLaunchIncentiveParameters(marketIndex, period, initialMultiplier);

    emit MarketLaunchIncentiveParametersChanges(marketIndex, period, initialMultiplier);
  }

  /// @dev Logic for changeBalanceIncentiveExponent
  function _changeBalanceIncentiveExponent(uint32 marketIndex, uint256 _balanceIncentiveCurve_exponent)
    internal
    virtual
  {
    require(
      // The exponent has to be less than 5 in these versions of the contracts.
      _balanceIncentiveCurve_exponent > 0 && _balanceIncentiveCurve_exponent < 6,
      "balanceIncentiveCurve_exponent out of bounds"
    );

    balanceIncentiveCurve_exponent[marketIndex] = _balanceIncentiveCurve_exponent;
  }

  /** 
  @notice Changes the balance incentive exponent for a market
  @param marketIndex Identifies the market.
  @param _balanceIncentiveCurve_exponent The new exponent for the curve.
  */
  function changeBalanceIncentiveExponent(uint32 marketIndex, uint256 _balanceIncentiveCurve_exponent)
    external
    onlyAdmin
  {
    _changeBalanceIncentiveExponent(marketIndex, _balanceIncentiveCurve_exponent);

    emit BalanceIncentiveExponentUpdated(marketIndex, _balanceIncentiveCurve_exponent);
  }

  /// @dev Logic for changeBalanceIncentiveEquilibriumOffset
  function _changeBalanceIncentiveEquilibriumOffset(uint32 marketIndex, int256 _balanceIncentiveCurve_equilibriumOffset)
    internal
    virtual
  {
    // Unreasonable that we would ever shift this more than 90% either way
    require(
      _balanceIncentiveCurve_equilibriumOffset > -9e17 && _balanceIncentiveCurve_equilibriumOffset < 9e17,
      "balanceIncentiveCurve_equilibriumOffset out of bounds"
    );

    balanceIncentiveCurve_equilibriumOffset[marketIndex] = _balanceIncentiveCurve_equilibriumOffset;
  }

  /**
  @notice Changes the balance incentive curve equilibrium offset for a market
  @param marketIndex Identifies the market.
  @param _balanceIncentiveCurve_equilibriumOffset The new offset.
  */
  function changeBalanceIncentiveEquilibriumOffset(uint32 marketIndex, int256 _balanceIncentiveCurve_equilibriumOffset)
    external
    onlyAdmin
  {
    _changeBalanceIncentiveEquilibriumOffset(marketIndex, _balanceIncentiveCurve_equilibriumOffset);

    emit BalanceIncentiveEquilibriumOffsetUpdated(marketIndex, _balanceIncentiveCurve_equilibriumOffset);
  }

  /*╔═════════════════════════════╗
    ║        STAKING SETUP        ║
    ╚═════════════════════════════╝*/

  /**
  @notice Sets this contract to track staking for a market in LongShort.sol
  @param marketIndex Identifies the market.
  @param longToken Address of the long token for the market.
  @param shortToken Address of the short token for the market.
  @param kInitialMultiplier Initial boost on float generation for the market.
  @param kPeriod Period which the boost should last.
  @param unstakeFee_e18 Percentage of tokens that are levied on unstaking in base 1e18.
  @param _balanceIncentiveCurve_exponent Exponent for balance curve (see _calculateFloatPerSecond)
  @param _balanceIncentiveCurve_equilibriumOffset Offset for balance curve (see _calculateFloatPerSecond)
  */
  function addNewStakingFund(
    uint32 marketIndex,
    address longToken,
    address shortToken,
    uint256 kInitialMultiplier,
    uint256 kPeriod,
    uint256 unstakeFee_e18,
    uint256 _balanceIncentiveCurve_exponent,
    int256 _balanceIncentiveCurve_equilibriumOffset
  ) external override onlyLongShort {
    marketIndexOfToken[longToken] = marketIndex;
    marketIndexOfToken[shortToken] = marketIndex;

    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].timestamp = block.timestamp;
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].accumulativeFloatPerSyntheticToken_long = 0;
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].accumulativeFloatPerSyntheticToken_short = 0;

    syntheticTokens[marketIndex][true] = longToken;
    syntheticTokens[marketIndex][false] = shortToken;

    _changeBalanceIncentiveExponent(marketIndex, _balanceIncentiveCurve_exponent);
    _changeBalanceIncentiveEquilibriumOffset(marketIndex, _balanceIncentiveCurve_equilibriumOffset);
    _changeMarketLaunchIncentiveParameters(marketIndex, kPeriod, kInitialMultiplier);

    _changeUnstakeFee(marketIndex, unstakeFee_e18);

    // Set this value to one initially - 0 is a null value and thus potentially bug prone.
    batched_stakerNextTokenShiftIndex[marketIndex] = 1;

    emit MarketAddedToStaker(
      marketIndex,
      unstakeFee_e18,
      kPeriod,
      kInitialMultiplier,
      _balanceIncentiveCurve_exponent,
      _balanceIncentiveCurve_equilibriumOffset
    );

    emit AccumulativeIssuancePerStakedSynthSnapshotCreated(marketIndex, 0, 0, 0);
  }

  /*╔═════════════════════════════════════════════════════════════════════════╗
    ║    GLOBAL FLT REWARD ACCUMULATION CALCULATION AND TRACKING FUNCTIONS    ║
    ╚═════════════════════════════════════════════════════════════════════════╝*/

  /**
  @notice Returns the K factor parameters for the given market with sensible
  defaults if they haven't been set yet.
  @param marketIndex The market to change the parameters for.
  @return period The period for which the k factor applies for in seconds.
  @return multiplier The multiplier on Float generation in this period.
  */
  function _getMarketLaunchIncentiveParameters(uint32 marketIndex)
    internal
    view
    virtual
    returns (uint256 period, uint256 multiplier)
  {
    period = marketLaunchIncentive_period[marketIndex];
    multiplier = marketLaunchIncentive_multipliers[marketIndex];

    if (multiplier < 1e18) {
      multiplier = 1e18; // multiplier of 1 by default
    }
  }

  /** 
  @notice Returns the extent to which a markets float generation should be adjusted
  based on the market's launch incentive parameters. Should start at multiplier
  then linearly change to 1e18 over time.
  @param marketIndex Identifies the market.
  @return k The calculated modifier for float generation.
  */
  function _getKValue(uint32 marketIndex) internal view virtual returns (uint256) {
    // Parameters controlling the float issuance multiplier.
    (uint256 kPeriod, uint256 kInitialMultiplier) = _getMarketLaunchIncentiveParameters(marketIndex);

    // Sanity check - under normal circumstances, the multipliers should
    // *never* be set to a value < 1e18, as there are guards against this.
    assert(kInitialMultiplier >= 1e18);

    uint256 initialTimestamp = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].timestamp;

    if (block.timestamp - initialTimestamp <= kPeriod) {
      return kInitialMultiplier - (((kInitialMultiplier - 1e18) * (block.timestamp - initialTimestamp)) / kPeriod);
    } else {
      return 1e18;
    }
  }

  /*
  @notice Computes the number of float tokens a user earns per second for
  every long/short synthetic token they've staked. The returned value has
  a fixed decimal scale of 1e42 (!!!) for numerical stability. The return
  values are float per second per synthetic token (hence the requirement
  to multiply by price)
  @dev to see below math in latex form see TODO add link
  to interact with the equations see https://www.desmos.com/calculator/optkaxyihr
  @param marketIndex The market referred to.
  @param longPrice Price of the synthetic long token in units of payment token
  @param shortPrice Price of the synthetic short token in units of payment token
  @param longValue Amount of payment token in the long side of the market
  @param shortValue Amount of payment token in the short side of the market
  @return longFloatPerSecond Float token per second per long synthetic token
  @return shortFloatPerSecond Float token per second per short synthetic token
   */
  function _calculateFloatPerSecond(
    uint32 marketIndex,
    uint256 longPrice,
    uint256 shortPrice,
    uint256 longValue,
    uint256 shortValue
  ) internal view virtual returns (uint256 longFloatPerSecond, uint256 shortFloatPerSecond) {
    // A float issuance multiplier that starts high and decreases linearly
    // over time to a value of 1. This incentivises users to stake early.
    uint256 k = _getKValue(marketIndex);

    uint256 totalLocked = (longValue + shortValue);

    // we need to scale this number by the totalLocked so that the offset remains consistent accross market size

    int256 equilibriumOffsetMarketScaled = (balanceIncentiveCurve_equilibriumOffset[marketIndex] *
      int256(totalLocked)) / 2e18;

    uint256 denominator = ((totalLocked >> safeExponentBitShifting)**balanceIncentiveCurve_exponent[marketIndex]);

    // Float is scaled by the percentage of the total market value held in
    // the opposite position. This incentivises users to stake on the
    // weaker position.
    if (int256(shortValue) - equilibriumOffsetMarketScaled < int256(longValue)) {
      if (equilibriumOffsetMarketScaled >= int256(shortValue)) {
        // edge case: imbalanced far past the equilibrium offset - full rewards go to short token
        //            extremeley unlikely to happen in practice
        return (0, 1e18 * k * shortPrice);
      }

      uint256 numerator = (uint256(int256(shortValue) - equilibriumOffsetMarketScaled) >>
        (safeExponentBitShifting - 1))**balanceIncentiveCurve_exponent[marketIndex];

      // NOTE: `x * 5e17` == `(x * 10e18) / 2`
      uint256 longRewardUnscaled = (numerator * 5e17) / denominator;
      uint256 shortRewardUnscaled = 1e18 - longRewardUnscaled;

      return ((longRewardUnscaled * k * longPrice) / 1e18, (shortRewardUnscaled * k * shortPrice) / 1e18);
    } else {
      if (-equilibriumOffsetMarketScaled >= int256(longValue)) {
        // edge case: imbalanced far past the equilibrium offset - full rewards go to long token
        //            extremeley unlikely to happen in practice
        return (1e18 * k * longPrice, 0);
      }

      uint256 numerator = (uint256(int256(longValue) + equilibriumOffsetMarketScaled) >>
        (safeExponentBitShifting - 1))**balanceIncentiveCurve_exponent[marketIndex];

      // NOTE: `x * 5e17` == `(x * 10e18) / 2`
      uint256 shortRewardUnscaled = (numerator * 5e17) / denominator;
      uint256 longRewardUnscaled = 1e18 - shortRewardUnscaled;

      return ((longRewardUnscaled * k * longPrice) / 1e18, (shortRewardUnscaled * k * shortPrice) / 1e18);
    }
  }

  /**
  @notice Computes the time since last accumulativeIssuancePerStakedSynthSnapshot for the given market in seconds.
  @param marketIndex The market referred to.
  @return The time difference in seconds
  */
  function _calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(uint32 marketIndex)
    internal
    view
    virtual
    returns (uint256)
  {
    return
      block.timestamp -
      accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]].timestamp;
  }

  /**
  @notice Computes new cumulative sum of 'r' value since last accumulativeIssuancePerStakedSynthSnapshot. We use
  cumulative 'r' value to avoid looping during issuance. Note that the
  cumulative sum is kept in 1e42 scale (!!!) to avoid numerical issues.
  @param shortValue The value locked in the short side of the market.
  @param longValue The value locked in the long side of the market.
  @param shortPrice The price of the short token as defined in LongShort.sol
  @param longPrice The price of the long token as defined in LongShort.sol
  @param marketIndex An identifier for the market.
  @return longCumulativeRates The long cumulative sum.
  @return shortCumulativeRates The short cumulative sum.
  */
  function _calculateNewCumulativeIssuancePerStakedSynth(
    uint32 marketIndex,
    uint256 longPrice,
    uint256 shortPrice,
    uint256 longValue,
    uint256 shortValue
  ) internal view virtual returns (uint256 longCumulativeRates, uint256 shortCumulativeRates) {
    // Compute the current 'r' value for float issuance per second.
    (uint256 longFloatPerSecond, uint256 shortFloatPerSecond) = _calculateFloatPerSecond(
      marketIndex,
      longPrice,
      shortPrice,
      longValue,
      shortValue
    );

    // Compute time since last accumulativeIssuancePerStakedSynthSnapshot for the given token.
    uint256 timeDelta = _calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(marketIndex);

    // Compute new cumulative 'r' value total.
    return (
      accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]]
      .accumulativeFloatPerSyntheticToken_long + (timeDelta * longFloatPerSecond),
      accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]]
      .accumulativeFloatPerSyntheticToken_short + (timeDelta * shortFloatPerSecond)
    );
  }

  /**
  @notice Creates a new accumulativeIssuancePerStakedSynthSnapshot for the given token and updates indexes.
  @param shortValue The value locked in the short side of the market.
  @param longValue The value locked in the long side of the market.
  @param shortPrice The price of the short token as defined in LongShort.sol
  @param longPrice The price of the long token as defined in LongShort.sol
  @param marketIndex An identifier for the market.
  */
  function _setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot(
    uint32 marketIndex,
    uint256 longPrice,
    uint256 shortPrice,
    uint256 longValue,
    uint256 shortValue
  ) internal virtual {
    (
      uint256 newLongAccumulativeValue,
      uint256 newShortAccumulativeValue
    ) = _calculateNewCumulativeIssuancePerStakedSynth(marketIndex, longPrice, shortPrice, longValue, shortValue);

    uint256 newIndex = latestRewardIndex[marketIndex] + 1;

    // Set cumulative 'r' value on new accumulativeIssuancePerStakedSynthSnapshot.
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex]
    .accumulativeFloatPerSyntheticToken_long = newLongAccumulativeValue;
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex]
    .accumulativeFloatPerSyntheticToken_short = newShortAccumulativeValue;

    // Set timestamp on new accumulativeIssuancePerStakedSynthSnapshot.
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex].timestamp = block.timestamp;

    // Update latest index to point to new accumulativeIssuancePerStakedSynthSnapshot.
    latestRewardIndex[marketIndex] = newIndex;

    emit AccumulativeIssuancePerStakedSynthSnapshotCreated(
      marketIndex,
      newIndex,
      newLongAccumulativeValue,
      newShortAccumulativeValue
    );
  }

  /**
  @notice Adds new accumulativeIssuancePerStakedSynthSnapshots for the given long/short tokens. Called by the
  ILongShort contract whenever there is a state change for a market.
  @param stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted Mapping from this contract's shifts to LongShort.sols next price snapshots.
  @param shortValue The value locked in the short side of the market.
  @param longValue The value locked in the long side of the market.
  @param shortPrice The price of the short token as defined in LongShort.sol
  @param longPrice The price of the long token as defined in LongShort.sol
  @param marketIndex An identifier for the market.
  */
  function pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(
    uint32 marketIndex,
    uint256 longPrice,
    uint256 shortPrice,
    uint256 longValue,
    uint256 shortValue,
    uint256 stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted // This value should be ALWAYS be zero if no shift occured
  ) external override onlyLongShort {
    // Only add a new accumulativeIssuancePerStakedSynthSnapshot if some time has passed.

    // the `stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted` value will be 0 if there is no staker related action in an executed batch
    if (stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted > 0) {
      stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[
        batched_stakerNextTokenShiftIndex[marketIndex]
      ] = stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted;
      stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[
        batched_stakerNextTokenShiftIndex[marketIndex]
      ] = latestRewardIndex[marketIndex] + 1;
      batched_stakerNextTokenShiftIndex[marketIndex] += 1;

      emit SyntheticTokensShifted();
    }

    // Time delta is fetched twice in below code, can pass through? Which is less gas?
    if (_calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(marketIndex) > 0) {
      _setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot(
        marketIndex,
        longPrice,
        shortPrice,
        longValue,
        shortValue
      );
    }
  }

  /*╔═══════════════════════════════════╗
    ║    USER REWARD STATE FUNCTIONS    ║
    ╚═══════════════════════════════════╝*/

  /// @dev Calculates the accumulated float in a specific range of staker snapshots
  function _calculateAccumulatedFloatInRange(
    uint32 marketIndex,
    uint256 amountStakedLong,
    uint256 amountStakedShort,
    uint256 rewardIndexFrom,
    uint256 rewardIndexTo
  ) internal view virtual returns (uint256 floatReward) {
    if (amountStakedLong > 0) {
      uint256 accumDeltaLong = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexTo]
      .accumulativeFloatPerSyntheticToken_long -
        accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexFrom]
        .accumulativeFloatPerSyntheticToken_long;
      floatReward += (accumDeltaLong * amountStakedLong) / FLOAT_ISSUANCE_FIXED_DECIMAL;
    }

    if (amountStakedShort > 0) {
      uint256 accumDeltaShort = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexTo]
      .accumulativeFloatPerSyntheticToken_short -
        accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexFrom]
        .accumulativeFloatPerSyntheticToken_short;
      floatReward += (accumDeltaShort * amountStakedShort) / FLOAT_ISSUANCE_FIXED_DECIMAL;
    }
  }

  /** 
  @notice Calculates float owed to the user since the user last minted float for a market.
  @param marketIndex Identifier for the market which the user staked in.
  @param user The address of the user.
  @return floatReward The amount of float owed.
   */
  function _calculateAccumulatedFloat(uint32 marketIndex, address user) internal virtual returns (uint256 floatReward) {
    address longToken = syntheticTokens[marketIndex][true];
    address shortToken = syntheticTokens[marketIndex][false];

    uint256 amountStakedLong = userAmountStaked[longToken][user];
    uint256 amountStakedShort = userAmountStaked[shortToken][user];

    uint256 usersLastRewardIndex = userIndexOfLastClaimedReward[marketIndex][user];

    // Don't do the calculation and return zero immediately if there is no change
    if (usersLastRewardIndex == latestRewardIndex[marketIndex]) {
      return 0;
    }

    uint256 usersShiftIndex = userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][user];
    // if there is a change in the users tokens held due to a token shift (or possibly another action in the future)
    if (usersShiftIndex > 0 && usersShiftIndex < batched_stakerNextTokenShiftIndex[marketIndex]) {
      floatReward = _calculateAccumulatedFloatInRange(
        marketIndex,
        amountStakedLong,
        amountStakedShort,
        usersLastRewardIndex,
        stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[usersShiftIndex]
      );

      // Update the users balances
      if (userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user] > 0) {
        amountStakedShort += ILongShort(longShort).getAmountSyntheticTokenToMintOnTargetSide(
          marketIndex,
          userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user],
          true,
          stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[usersShiftIndex]
        );

        amountStakedLong -= userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user];
        userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user] = 0;
      }

      if (userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user] > 0) {
        amountStakedLong += ILongShort(longShort).getAmountSyntheticTokenToMintOnTargetSide(
          marketIndex,
          userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user],
          false,
          stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[usersShiftIndex]
        );

        amountStakedShort -= userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user];
        userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user] = 0;
      }

      // Save the users updated staked amounts
      userAmountStaked[longToken][user] = amountStakedLong;
      userAmountStaked[shortToken][user] = amountStakedShort;

      floatReward += _calculateAccumulatedFloatInRange(
        marketIndex,
        amountStakedLong,
        amountStakedShort,
        stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[usersShiftIndex],
        latestRewardIndex[marketIndex]
      );

      userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][user] = 0;
    } else {
      floatReward = _calculateAccumulatedFloatInRange(
        marketIndex,
        amountStakedLong,
        amountStakedShort,
        usersLastRewardIndex,
        latestRewardIndex[marketIndex]
      );
    }
  }

  /**
  @notice Mints float for a user.
  @dev Mints a fixed percentage for Float capital.
  @param user The address of the user.
  @param floatToMint The amount of float to mint.
   */
  function _mintFloat(address user, uint256 floatToMint) internal virtual {
    IFloatToken(floatToken).mint(user, floatToMint);
    IFloatToken(floatToken).mint(floatCapital, (floatToMint * floatPercentage) / 1e18);
  }

  /**
  @notice Mints float owed to a user for a market since they last minted.
  @param marketIndex An identifier for the market.
  @param user The address of the user.
   */
  function _mintAccumulatedFloat(uint32 marketIndex, address user) internal virtual {
    uint256 floatToMint = _calculateAccumulatedFloat(marketIndex, user);

    if (floatToMint > 0) {
      // Set the user has claimed up until now, stops them setting this forward
      userIndexOfLastClaimedReward[marketIndex][user] = latestRewardIndex[marketIndex];

      _mintFloat(user, floatToMint);
      emit FloatMinted(user, marketIndex, floatToMint);
    }
  }

  /**
  @notice Mints float owed to a user for multiple markets, since they last minted for those markets.
  @param marketIndexes Identifiers for the markets.
  @param user The address of the user.
   */
  function _mintAccumulatedFloatMulti(uint32[] calldata marketIndexes, address user) internal virtual {
    uint256 floatTotal = 0;
    for (uint256 i = 0; i < marketIndexes.length; i++) {
      uint256 floatToMint = _calculateAccumulatedFloat(marketIndexes[i], user);

      if (floatToMint > 0) {
        // Set the user has claimed up until now, stops them setting this forward
        userIndexOfLastClaimedReward[marketIndexes[i]][user] = latestRewardIndex[marketIndexes[i]];

        floatTotal += floatToMint;

        emit FloatMinted(user, marketIndexes[i], floatToMint);
      }
    }
    if (floatTotal > 0) {
      _mintFloat(user, floatTotal);
    }
  }

  /**
  @notice Mints outstanding float for msg.sender.
  @param marketIndexes Identifiers for the markets for which to mint float.
   */
  function claimFloatCustom(uint32[] calldata marketIndexes) external {
    ILongShort(longShort).updateSystemStateMulti(marketIndexes);
    _mintAccumulatedFloatMulti(marketIndexes, msg.sender);
  }

  /**
  @notice Mints outstanding float on behalf of another user.
  @param marketIndexes Identifiers for the markets for which to mint float.
  @param user The address of the user.
   */
  function claimFloatCustomFor(uint32[] calldata marketIndexes, address user) external {
    // Unbounded loop - users are responsible for paying their own gas costs on these and it doesn't effect the rest of the system.
    // No need to impose limit.
    ILongShort(longShort).updateSystemStateMulti(marketIndexes);
    _mintAccumulatedFloatMulti(marketIndexes, user);
  }

  /*╔═══════════════════════╗
    ║        STAKING        ║
    ╚═══════════════════════╝*/

  /**
  @notice A user with synthetic tokens stakes by calling stake on the token
  contract which calls this function. We need to first update the
  state of the LongShort contract for this market before staking to correctly calculate user rewards.
  @param amount Amount to stake.
  @param from Address to stake for.
  */
  function stakeFromUser(address from, uint256 amount) public virtual override onlyValidSynthetic((msg.sender)) {
    ILongShort(longShort).updateSystemState(marketIndexOfToken[(msg.sender)]);
    _stake((msg.sender), amount, from);
  }

  /**
  @dev Internal logic for staking.
  @param token Address of the token for which to stake.
  @param amount Amount to stake.
  @param user Address to stake for.
  */
  function _stake(
    address token,
    uint256 amount,
    address user
  ) internal virtual {
    uint32 marketIndex = marketIndexOfToken[token];

    // If they already have staked and have rewards due, mint these.
    if (
      userIndexOfLastClaimedReward[marketIndex][user] != 0 &&
      userIndexOfLastClaimedReward[marketIndex][user] < latestRewardIndex[marketIndex]
    ) {
      _mintAccumulatedFloat(marketIndex, user);
    }

    userAmountStaked[token][user] = userAmountStaked[token][user] + amount;

    userIndexOfLastClaimedReward[marketIndex][user] = latestRewardIndex[marketIndex];

    emit StakeAdded(user, address(token), amount, userIndexOfLastClaimedReward[marketIndex][user]);
  }

  /**
  @notice Allows users to shift their staked tokens from one side of the market to 
  the other at the next price.
  @param amountSyntheticTokensToShift Amount of tokens to shift.
  @param marketIndex Identifier for the market.
  @param isShiftFromLong Whether the shift is from long to short or short to long.
  */
  function shiftTokens(
    uint256 amountSyntheticTokensToShift,
    uint32 marketIndex,
    bool isShiftFromLong
  ) external virtual {
    address token = syntheticTokens[marketIndex][isShiftFromLong];
    require(userAmountStaked[token][msg.sender] >= amountSyntheticTokensToShift, "Not enough tokens to shift");

    // If the user has outstanding token shift that have already been confirmed in the LongShort
    // contract, execute them first.
    if (
      userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] != 0 &&
      userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] <
      batched_stakerNextTokenShiftIndex[marketIndex]
    ) {
      _mintAccumulatedFloat(marketIndex, msg.sender);
    }

    if (isShiftFromLong) {
      ILongShort(longShort).shiftPositionFromLongNextPrice(marketIndex, amountSyntheticTokensToShift);
      userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][
        msg.sender
      ] += amountSyntheticTokensToShift;
    } else {
      ILongShort(longShort).shiftPositionFromShortNextPrice(marketIndex, amountSyntheticTokensToShift);
      userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][
        msg.sender
      ] += amountSyntheticTokensToShift;
    }

    userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] = batched_stakerNextTokenShiftIndex[
      marketIndex
    ];
  }

  /*╔════════════════════════════╗
    ║    WITHDRAWAL & MINTING    ║
    ╚════════════════════════════╝*/

  /**
  @notice Internal logic for withdrawing stakes.
  @dev Mint user any outstanding float before withdrawing.
  @param marketIndex Market index of token.
  @param amount Amount to withdraw.
  @param token Synthetic token that was staked.
  */
  function _withdraw(
    uint32 marketIndex,
    address token,
    uint256 amount
  ) internal virtual {
    require(userAmountStaked[token][msg.sender] > 0, "nothing to withdraw");
    _mintAccumulatedFloat(marketIndex, msg.sender);

    userAmountStaked[token][msg.sender] = userAmountStaked[token][msg.sender] - amount;

    uint256 amountFees = (amount * marketUnstakeFee_e18[marketIndex]) / 1e18;

    IERC20(token).transfer(floatTreasury, amountFees);
    IERC20(token).transfer(msg.sender, amount - amountFees);

    emit StakeWithdrawn(msg.sender, token, amount);
  }

  /**
  @notice Withdraw function. Allows users to unstake.
  @param amount Amount to withdraw.
  @param token Address of the token for which to withdraw.
  */
  function withdraw(address token, uint256 amount) external {
    ILongShort(longShort).updateSystemState(marketIndexOfToken[token]);

    uint32 marketIndex = marketIndexOfToken[token];

    _withdraw(marketIndex, token, amount);

    if (userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] > 0) {
      // If they still have outstanding shifts after minting float, then check
      // that they don't withdraw more than their shifts allow.
      uint256 amountToShiftForThisToken = syntheticTokens[marketIndex][true] == token
        ? userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][msg.sender]
        : userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][msg.sender];

      require(
        userAmountStaked[token][msg.sender] >= amountToShiftForThisToken,
        "Outstanding next price stake shifts too great"
      );
    }
  }

  /**
  @notice Allows users to withdraw their entire stake for a token.
  @param token Address of the token for which to withdraw.
  */
  function withdrawAll(address token) external {
    ILongShort(longShort).updateSystemState(marketIndexOfToken[token]);

    uint32 marketIndex = marketIndexOfToken[token];

    uint256 amountToShiftForThisToken = syntheticTokens[marketIndex][true] == token
      ? userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][msg.sender]
      : userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][msg.sender];

    _withdraw(marketIndex, token, userAmountStaked[token][msg.sender] - amountToShiftForThisToken);
  }
}
.]

###

[2024-17-08 08:01:57 INFO] **[Seminar Conclusion]**:

 ###

[2024-17-08 08:01:57 INFO] **[Execute Detail]**

execute SimplePhase:[BugsSummary] in ComposedPhase:[CodeReview], cycle 3

[2024-17-08 08:01:57 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: BUSL-1.1 pragma solidity 0.8.3; import "@openzeppelin/contracts-upgradeable/token/ERC20/presets/ERC20PresetMinterPauserUpgradeable.sol"; import "./interfaces/IFloatToken.sol"; import "./interfaces/ILongShort.sol"; import "./interfaces/IStaker.sol"; import "./interfaces/ISyntheticToken.sol"; contract Staker is IStaker, Initializable {   /╔═════════════════════════════╗     ║          VARIABLES          ║     ╚═════════════════════════════╝/ / ══════ Fixed-precision constants ══════ /   uint256 public constant FLOAT_ISSUANCE_FIXED_DECIMAL = 1e42;   // 2^52 ~= 4.5e15   // With an exponent of 5, the largest total liquidity possible in a market (to avoid integer overflow on exponentiation) is ~10^31 or 10 Trillion (10^13)   // NOTE: this also means if the total market value is less than 2^52 there will be a division by zero error   uint256 public constant safeExponentBitShifting = 52; / ══════ Global state ══════ /   address public admin;   address public floatCapital;   address public floatTreasury;   uint256 public floatPercentage; address public longShort;   address public floatToken; / ══════ Market specific ══════ /   mapping(uint32 =&gt; uint256) public marketLaunchIncentive_period; // seconds   mapping(uint32 =&gt; uint256) public marketLaunchIncentive_multipliers; // e18 scale   mapping(uint32 =&gt; uint256) public marketUnstakeFee_e18;   mapping(uint32 =&gt; uint256) public balanceIncentiveCurve_exponent;   mapping(uint32 =&gt; int256) public balanceIncentiveCurve_equilibriumOffset; mapping(uint32 =&gt; mapping(bool =&gt; address)) public syntheticTokens; mapping(address =&gt; uint32) public marketIndexOfToken; / ══════ Reward specific ══════ /   mapping(uint32 =&gt; uint256) public latestRewardIndex;   mapping(uint32 =&gt; mapping(uint256 =&gt; AccumulativeIssuancePerStakedSynthSnapshot))     public accumulativeFloatPerSyntheticTokenSnapshots;   struct AccumulativeIssuancePerStakedSynthSnapshot {     uint256 timestamp;     uint256 accumulativeFloatPerSyntheticToken_long;     uint256 accumulativeFloatPerSyntheticToken_short;   } / ══════ User specific ══════ /   mapping(uint32 =&gt; mapping(address =&gt; uint256)) public userIndexOfLastClaimedReward;   mapping(address =&gt; mapping(address =&gt; uint256)) public userAmountStaked; / ══════ Token shift management specific ══════ /   mapping(uint32 =&gt; uint256) public batched_stakerNextTokenShiftIndex;   /*   @notice Used to link a token shift to a staker state   @dev tokenShiftIndex =&gt; accumulativeFloatIssuanceSnapshotIndex     POSSIBLE OPTIMIZATION - could pack stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping and stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping into a struct of two uint128 for storage space optimization.   /   mapping(uint256 =&gt; uint256) public stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping;   /// @notice Used to fetch the price from LongShort at that point in time   /// @dev tokenShiftIndex =&gt; longShortMarketPriceSnapshotIndex   mapping(uint256 =&gt; uint256) public stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping;   /// @dev marketIndex =&gt; usersAddress =&gt; stakerTokenShiftIndex   mapping(uint32 =&gt; mapping(address =&gt; uint256)) public userNextPrice_stakedSyntheticTokenShiftIndex;   /// @dev marketIndex =&gt; usersAddress =&gt; amountUserRequestedToShiftAwayFromLongOnNextUpdate   mapping(uint32 =&gt; mapping(address =&gt; uint256)) public userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long;   /// @dev marketIndex =&gt; usersAddress =&gt; amountUserRequestedToShiftAwayFromShortOnNextUpdate   mapping(uint32 =&gt; mapping(address =&gt; uint256)) public userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short; /╔════════════════════════════╗     ║           EVENTS           ║     ╚════════════════════════════╝/ event StakerV1(     address admin,     address floatTreasury,     address floatCapital,     address floatToken,     uint256 floatPercentage   ); event MarketAddedToStaker(     uint32 marketIndex,     uint256 exitFee_e18,     uint256 period,     uint256 multiplier,     uint256 balanceIncentiveExponent,     int256 balanceIncentiveEquilibriumOffset   ); event AccumulativeIssuancePerStakedSynthSnapshotCreated(     uint32 marketIndex,     uint256 accumulativeFloatIssuanceSnapshotIndex,     uint256 accumulativeLong,     uint256 accumulativeShort   ); event StakeAdded(address user, address token, uint256 amount, uint256 lastMintIndex); event StakeWithdrawn(address user, address token, uint256 amount); // Note: the amountFloatMinted isn't strictly needed by the graph, but it is good to add it to validate calculations are accurate.   event FloatMinted(address user, uint32 marketIndex, uint256 amountFloatMinted); event MarketLaunchIncentiveParametersChanges(uint32 marketIndex, uint256 period, uint256 multiplier); event StakeWithdrawalFeeUpdated(uint32 marketIndex, uint256 stakeWithdralFee); event BalanceIncentiveExponentUpdated(uint32 marketIndex, uint256 balanceIncentiveExponent); event BalanceIncentiveEquilibriumOffsetUpdated(uint32 marketIndex, int256 balanceIncentiveEquilibriumOffset); event FloatPercentageUpdated(uint256 floatPercentage); event SyntheticTokensShifted(); event ChangeAdmin(address newAdmin); /╔═════════════════════════════╗     ║          MODIFIERS          ║     ╚═════════════════════════════╝/ function onlyAdminModifierLogic() internal virtual {     require(msg.sender == admin, "not admin");   } modifier onlyAdmin() {     onlyAdminModifierLogic();     _;   } function onlyValidSyntheticModifierLogic(address _synth) internal virtual {     require(marketIndexOfToken[_synth] != 0, "not valid synth");   } modifier onlyValidSynthetic(address synth) {     onlyValidSyntheticModifierLogic(_synth);     ;   } function onlyValidMarketModifierLogic(uint32 marketIndex) internal virtual {     require(address(syntheticTokens[marketIndex][true]) != address(0), "not valid market");   } modifier onlyValidMarket(uint32 marketIndex) {     onlyValidMarketModifierLogic(marketIndex);     _;   } function onlyLongShortModifierLogic() internal virtual {     require(msg.sender == address(longShort), "not long short");   } modifier onlyLongShort() {     onlyLongShortModifierLogic();     _;   } /╔═════════════════════════════╗     ║       CONTRACT SET-UP       ║     ╚═════════════════════════════╝/ /*   @notice Initializes the contract.   @dev Calls OpenZeppelin's initializer modifier.   @param _admin Address of the admin role.   @param _longShort Address of the LongShort contract, a deployed LongShort.sol   @param _floatToken Address of the Float token earned by staking.   @param _floatTreasury Address of the treasury contract for managing fees.   @param _floatCapital Address of the contract which earns a fixed percentage of Float.   @param _floatPercentage Determines the float percentage that gets minted for Float Capital, base 1e18.   /   function initialize(     address _admin,     address _longShort,     address _floatToken,     address _floatTreasury,     address _floatCapital,     uint256 _floatPercentage   ) external virtual initializer {     admin = _admin;     floatCapital = _floatCapital;     floatTreasury = _floatTreasury;     longShort = _longShort;     floatToken = _floatToken; _changeFloatPercentage(_floatPercentage);  emit StakerV1(_admin, _floatTreasury, _floatCapital, _floatToken, _floatPercentage);  } /╔═══════════════════╗     ║       ADMIN       ║     ╚═══════════════════╝/ /*    @notice Changes admin for the contract   @param _admin The address of the new admin.   /   function changeAdmin(address _admin) external onlyAdmin {     admin = _admin;     emit ChangeAdmin(_admin);   } /// @dev Logic for changeFloatPercentage   function _changeFloatPercentage(uint256 newFloatPercentage) internal virtual {     require(newFloatPercentage &lt;= 1e18 &amp;&amp; newFloatPercentage &gt; 0); // less than or equal to 100% and greater than 0%     floatPercentage = newFloatPercentage;   } /*   @notice Changes percentage of float that is minted for float capital.   @param newFloatPercentage The new float percentage in base 1e18.   /   function changeFloatPercentage(uint256 newFloatPercentage) external onlyAdmin {     _changeFloatPercentage(newFloatPercentage);     emit FloatPercentageUpdated(newFloatPercentage);   } /// @dev Logic for changeUnstakeFee   function _changeUnstakeFee(uint32 marketIndex, uint256 newMarketUnstakeFee_e18) internal virtual {     require(newMarketUnstakeFee_e18 &lt;= 5e16); // Explicitely stating 5% fee as the max fee possible.     marketUnstakeFee_e18[marketIndex] = newMarketUnstakeFee_e18;   } /*   @notice Changes unstake fee for a market   @param marketIndex Identifies the market.   @param newMarketUnstakeFee_e18 The new unstake fee.   /   function changeUnstakeFee(uint32 marketIndex, uint256 newMarketUnstakeFee_e18) external onlyAdmin {     _changeUnstakeFee(marketIndex, newMarketUnstakeFee_e18);     emit StakeWithdrawalFeeUpdated(marketIndex, newMarketUnstakeFee_e18);   } /// @dev Logic for changeMarketLaunchIncentiveParameters   function _changeMarketLaunchIncentiveParameters(     uint32 marketIndex,     uint256 period,     uint256 initialMultiplier   ) internal virtual {     require(initialMultiplier &gt;= 1e18, "marketLaunchIncentiveMultiplier must be &gt;= 1e18"); marketLaunchIncentive_period[marketIndex] = period; marketLaunchIncentive_multipliers[marketIndex] = initialMultiplier;  } /*   @notice Changes the market launch incentive parameters for a market   @param marketIndex Identifies the market.   @param period The new period for which float token generation should be boosted.   @param initialMultiplier The new multiplier on Float generation.   /   function changeMarketLaunchIncentiveParameters(     uint32 marketIndex,     uint256 period,     uint256 initialMultiplier   ) external onlyAdmin {     _changeMarketLaunchIncentiveParameters(marketIndex, period, initialMultiplier); emit MarketLaunchIncentiveParametersChanges(marketIndex, period, initialMultiplier);  } /// @dev Logic for changeBalanceIncentiveExponent   function _changeBalanceIncentiveExponent(uint32 marketIndex, uint256 _balanceIncentiveCurve_exponent)     internal     virtual   {     require(       // The exponent has to be less than 5 in these versions of the contracts.       _balanceIncentiveCurve_exponent &gt; 0 &amp;&amp; _balanceIncentiveCurve_exponent &lt; 6,       "balanceIncentiveCurve_exponent out of bounds"     ); balanceIncentiveCurve_exponent[marketIndex] = _balanceIncentiveCurve_exponent;  } /*    @notice Changes the balance incentive exponent for a market   @param marketIndex Identifies the market.   @param _balanceIncentiveCurve_exponent The new exponent for the curve.   /   function changeBalanceIncentiveExponent(uint32 marketIndex, uint256 _balanceIncentiveCurve_exponent)     external     onlyAdmin   {     _changeBalanceIncentiveExponent(marketIndex, _balanceIncentiveCurve_exponent); emit BalanceIncentiveExponentUpdated(marketIndex, _balanceIncentiveCurve_exponent);  } /// @dev Logic for changeBalanceIncentiveEquilibriumOffset   function _changeBalanceIncentiveEquilibriumOffset(uint32 marketIndex, int256 _balanceIncentiveCurve_equilibriumOffset)     internal     virtual   {     // Unreasonable that we would ever shift this more than 90% either way     require(       _balanceIncentiveCurve_equilibriumOffset &gt; -9e17 &amp;&amp; _balanceIncentiveCurve_equilibriumOffset &lt; 9e17,       "balanceIncentiveCurve_equilibriumOffset out of bounds"     ); balanceIncentiveCurve_equilibriumOffset[marketIndex] = _balanceIncentiveCurve_equilibriumOffset;  } /*   @notice Changes the balance incentive curve equilibrium offset for a market   @param marketIndex Identifies the market.   @param _balanceIncentiveCurve_equilibriumOffset The new offset.   /   function changeBalanceIncentiveEquilibriumOffset(uint32 marketIndex, int256 _balanceIncentiveCurve_equilibriumOffset)     external     onlyAdmin   {     _changeBalanceIncentiveEquilibriumOffset(marketIndex, _balanceIncentiveCurve_equilibriumOffset); emit BalanceIncentiveEquilibriumOffsetUpdated(marketIndex, _balanceIncentiveCurve_equilibriumOffset);  } /╔═════════════════════════════╗     ║        STAKING SETUP        ║     ╚═════════════════════════════╝/ /*   @notice Sets this contract to track staking for a market in LongShort.sol   @param marketIndex Identifies the market.   @param longToken Address of the long token for the market.   @param shortToken Address of the short token for the market.   @param kInitialMultiplier Initial boost on float generation for the market.   @param kPeriod Period which the boost should last.   @param unstakeFee_e18 Percentage of tokens that are levied on unstaking in base 1e18.   @param _balanceIncentiveCurve_exponent Exponent for balance curve (see _calculateFloatPerSecond)   @param _balanceIncentiveCurve_equilibriumOffset Offset for balance curve (see _calculateFloatPerSecond)   /   function addNewStakingFund(     uint32 marketIndex,     address longToken,     address shortToken,     uint256 kInitialMultiplier,     uint256 kPeriod,     uint256 unstakeFee_e18,     uint256 _balanceIncentiveCurve_exponent,     int256 _balanceIncentiveCurve_equilibriumOffset   ) external override onlyLongShort {     marketIndexOfToken[longToken] = marketIndex;     marketIndexOfToken[shortToken] = marketIndex; accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].timestamp = block.timestamp; accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].accumulativeFloatPerSyntheticToken_long = 0; accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].accumulativeFloatPerSyntheticToken_short = 0;  syntheticTokens[marketIndex][true] = longToken; syntheticTokens[marketIndex][false] = shortToken;  _changeBalanceIncentiveExponent(marketIndex, _balanceIncentiveCurve_exponent); _changeBalanceIncentiveEquilibriumOffset(marketIndex, _balanceIncentiveCurve_equilibriumOffset); _changeMarketLaunchIncentiveParameters(marketIndex, kPeriod, kInitialMultiplier);  _changeUnstakeFee(marketIndex, unstakeFee_e18);  // Set this value to one initially - 0 is a null value and thus potentially bug prone. batched_stakerNextTokenShiftIndex[marketIndex] = 1;  emit MarketAddedToStaker(   marketIndex,   unstakeFee_e18,   kPeriod,   kInitialMultiplier,   _balanceIncentiveCurve_exponent,   _balanceIncentiveCurve_equilibriumOffset );  emit AccumulativeIssuancePerStakedSynthSnapshotCreated(marketIndex, 0, 0, 0);  } /╔═════════════════════════════════════════════════════════════════════════╗     ║    GLOBAL FLT REWARD ACCUMULATION CALCULATION AND TRACKING FUNCTIONS    ║     ╚═════════════════════════════════════════════════════════════════════════╝/ /*   @notice Returns the K factor parameters for the given market with sensible   defaults if they haven't been set yet.   @param marketIndex The market to change the parameters for.   @return period The period for which the k factor applies for in seconds.   @return multiplier The multiplier on Float generation in this period.   /   function _getMarketLaunchIncentiveParameters(uint32 marketIndex)     internal     view     virtual     returns (uint256 period, uint256 multiplier)   {     period = marketLaunchIncentive_period[marketIndex];     multiplier = marketLaunchIncentive_multipliers[marketIndex]; if (multiplier &lt; 1e18) {   multiplier = 1e18; // multiplier of 1 by default }  } /*    @notice Returns the extent to which a markets float generation should be adjusted   based on the market's launch incentive parameters. Should start at multiplier   then linearly change to 1e18 over time.   @param marketIndex Identifies the market.   @return k The calculated modifier for float generation.   /   function _getKValue(uint32 marketIndex) internal view virtual returns (uint256) {     // Parameters controlling the float issuance multiplier.     (uint256 kPeriod, uint256 kInitialMultiplier) = _getMarketLaunchIncentiveParameters(marketIndex); // Sanity check - under normal circumstances, the multipliers should // *never* be set to a value &lt; 1e18, as there are guards against this. assert(kInitialMultiplier &gt;= 1e18);  uint256 initialTimestamp = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].timestamp;  if (block.timestamp - initialTimestamp &lt;= kPeriod) {   return kInitialMultiplier - (((kInitialMultiplier - 1e18) * (block.timestamp - initialTimestamp)) / kPeriod); } else {   return 1e18; }  } /   @notice Computes the number of float tokens a user earns per second for   every long/short synthetic token they've staked. The returned value has   a fixed decimal scale of 1e42 (!!!) for numerical stability. The return   values are float per second per synthetic token (hence the requirement   to multiply by price)   @dev to see below math in latex form see TODO add link   to interact with the equations see https://www.desmos.com/calculator/optkaxyihr   @param marketIndex The market referred to.   @param longPrice Price of the synthetic long token in units of payment token   @param shortPrice Price of the synthetic short token in units of payment token   @param longValue Amount of payment token in the long side of the market   @param shortValue Amount of payment token in the short side of the market   @return longFloatPerSecond Float token per second per long synthetic token   @return shortFloatPerSecond Float token per second per short synthetic token    /   function _calculateFloatPerSecond(     uint32 marketIndex,     uint256 longPrice,     uint256 shortPrice,     uint256 longValue,     uint256 shortValue   ) internal view virtual returns (uint256 longFloatPerSecond, uint256 shortFloatPerSecond) {     // A float issuance multiplier that starts high and decreases linearly     // over time to a value of 1. This incentivises users to stake early.     uint256 k = _getKValue(marketIndex); uint256 totalLocked = (longValue + shortValue);  // we need to scale this number by the totalLocked so that the offset remains consistent accross market size  int256 equilibriumOffsetMarketScaled = (balanceIncentiveCurve_equilibriumOffset[marketIndex] *   int256(totalLocked)) / 2e18;  uint256 denominator = ((totalLocked &gt;&gt; safeExponentBitShifting)**balanceIncentiveCurve_exponent[marketIndex]);  // Float is scaled by the percentage of the total market value held in // the opposite position. This incentivises users to stake on the // weaker position. if (int256(shortValue) - equilibriumOffsetMarketScaled &lt; int256(longValue)) {   if (equilibriumOffsetMarketScaled &gt;= int256(shortValue)) {     // edge case: imbalanced far past the equilibrium offset - full rewards go to short token     //            extremeley unlikely to happen in practice     return (0, 1e18 * k * shortPrice);   }    uint256 numerator = (uint256(int256(shortValue) - equilibriumOffsetMarketScaled) &gt;&gt;     (safeExponentBitShifting - 1))**balanceIncentiveCurve_exponent[marketIndex];    // NOTE: `x * 5e17` == `(x * 10e18) / 2`   uint256 longRewardUnscaled = (numerator * 5e17) / denominator;   uint256 shortRewardUnscaled = 1e18 - longRewardUnscaled;    return ((longRewardUnscaled * k * longPrice) / 1e18, (shortRewardUnscaled * k * shortPrice) / 1e18); } else {   if (-equilibriumOffsetMarketScaled &gt;= int256(longValue)) {     // edge case: imbalanced far past the equilibrium offset - full rewards go to long token     //            extremeley unlikely to happen in practice     return (1e18 * k * longPrice, 0);   }    uint256 numerator = (uint256(int256(longValue) + equilibriumOffsetMarketScaled) &gt;&gt;     (safeExponentBitShifting - 1))**balanceIncentiveCurve_exponent[marketIndex];    // NOTE: `x * 5e17` == `(x * 10e18) / 2`   uint256 shortRewardUnscaled = (numerator * 5e17) / denominator;   uint256 longRewardUnscaled = 1e18 - shortRewardUnscaled;    return ((longRewardUnscaled * k * longPrice) / 1e18, (shortRewardUnscaled * k * shortPrice) / 1e18); }  } /*   @notice Computes the time since last accumulativeIssuancePerStakedSynthSnapshot for the given market in seconds.   @param marketIndex The market referred to.   @return The time difference in seconds   /   function _calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(uint32 marketIndex)     internal     view     virtual     returns (uint256)   {     return       block.timestamp -       accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]].timestamp;   } /*   @notice Computes new cumulative sum of 'r' value since last accumulativeIssuancePerStakedSynthSnapshot. We use   cumulative 'r' value to avoid looping during issuance. Note that the   cumulative sum is kept in 1e42 scale (!!!) to avoid numerical issues.   @param shortValue The value locked in the short side of the market.   @param longValue The value locked in the long side of the market.   @param shortPrice The price of the short token as defined in LongShort.sol   @param longPrice The price of the long token as defined in LongShort.sol   @param marketIndex An identifier for the market.   @return longCumulativeRates The long cumulative sum.   @return shortCumulativeRates The short cumulative sum.   /   function _calculateNewCumulativeIssuancePerStakedSynth(     uint32 marketIndex,     uint256 longPrice,     uint256 shortPrice,     uint256 longValue,     uint256 shortValue   ) internal view virtual returns (uint256 longCumulativeRates, uint256 shortCumulativeRates) {     // Compute the current 'r' value for float issuance per second.     (uint256 longFloatPerSecond, uint256 shortFloatPerSecond) = _calculateFloatPerSecond(       marketIndex,       longPrice,       shortPrice,       longValue,       shortValue     ); // Compute time since last accumulativeIssuancePerStakedSynthSnapshot for the given token. uint256 timeDelta = _calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(marketIndex);  // Compute new cumulative 'r' value total. return (   accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]]   .accumulativeFloatPerSyntheticToken_long + (timeDelta * longFloatPerSecond),   accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]]   .accumulativeFloatPerSyntheticToken_short + (timeDelta * shortFloatPerSecond) );  } /*   @notice Creates a new accumulativeIssuancePerStakedSynthSnapshot for the given token and updates indexes.   @param shortValue The value locked in the short side of the market.   @param longValue The value locked in the long side of the market.   @param shortPrice The price of the short token as defined in LongShort.sol   @param longPrice The price of the long token as defined in LongShort.sol   @param marketIndex An identifier for the market.   /   function _setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot(     uint32 marketIndex,     uint256 longPrice,     uint256 shortPrice,     uint256 longValue,     uint256 shortValue   ) internal virtual {     (       uint256 newLongAccumulativeValue,       uint256 newShortAccumulativeValue     ) = _calculateNewCumulativeIssuancePerStakedSynth(marketIndex, longPrice, shortPrice, longValue, shortValue); uint256 newIndex = latestRewardIndex[marketIndex] + 1;  // Set cumulative 'r' value on new accumulativeIssuancePerStakedSynthSnapshot. accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex] .accumulativeFloatPerSyntheticToken_long = newLongAccumulativeValue; accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex] .accumulativeFloatPerSyntheticToken_short = newShortAccumulativeValue;  // Set timestamp on new accumulativeIssuancePerStakedSynthSnapshot. accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex].timestamp = block.timestamp;  // Update latest index to point to new accumulativeIssuancePerStakedSynthSnapshot. latestRewardIndex[marketIndex] = newIndex;  emit AccumulativeIssuancePerStakedSynthSnapshotCreated(   marketIndex,   newIndex,   newLongAccumulativeValue,   newShortAccumulativeValue );  } /*   @notice Adds new accumulativeIssuancePerStakedSynthSnapshots for the given long/short tokens. Called by the   ILongShort contract whenever there is a state change for a market.   @param stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted Mapping from this contract's shifts to LongShort.sols next price snapshots.   @param shortValue The value locked in the short side of the market.   @param longValue The value locked in the long side of the market.   @param shortPrice The price of the short token as defined in LongShort.sol   @param longPrice The price of the long token as defined in LongShort.sol   @param marketIndex An identifier for the market.   /   function pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(     uint32 marketIndex,     uint256 longPrice,     uint256 shortPrice,     uint256 longValue,     uint256 shortValue,     uint256 stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted // This value should be ALWAYS be zero if no shift occured   ) external override onlyLongShort {     // Only add a new accumulativeIssuancePerStakedSynthSnapshot if some time has passed. // the `stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted` value will be 0 if there is no staker related action in an executed batch if (stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted &gt; 0) {   stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[     batched_stakerNextTokenShiftIndex[marketIndex]   ] = stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted;   stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[     batched_stakerNextTokenShiftIndex[marketIndex]   ] = latestRewardIndex[marketIndex] + 1;   batched_stakerNextTokenShiftIndex[marketIndex] += 1;    emit SyntheticTokensShifted(); }  // Time delta is fetched twice in below code, can pass through? Which is less gas? if (_calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(marketIndex) &gt; 0) {   _setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot(     marketIndex,     longPrice,     shortPrice,     longValue,     shortValue   ); }  } /╔═══════════════════════════════════╗     ║    USER REWARD STATE FUNCTIONS    ║     ╚═══════════════════════════════════╝/ /// @dev Calculates the accumulated float in a specific range of staker snapshots   function _calculateAccumulatedFloatInRange(     uint32 marketIndex,     uint256 amountStakedLong,     uint256 amountStakedShort,     uint256 rewardIndexFrom,     uint256 rewardIndexTo   ) internal view virtual returns (uint256 floatReward) {     if (amountStakedLong &gt; 0) {       uint256 accumDeltaLong = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexTo]       .accumulativeFloatPerSyntheticToken_long -         accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexFrom]         .accumulativeFloatPerSyntheticToken_long;       floatReward += (accumDeltaLong * amountStakedLong) / FLOAT_ISSUANCE_FIXED_DECIMAL;     } if (amountStakedShort &gt; 0) {   uint256 accumDeltaShort = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexTo]   .accumulativeFloatPerSyntheticToken_short -     accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexFrom]     .accumulativeFloatPerSyntheticToken_short;   floatReward += (accumDeltaShort * amountStakedShort) / FLOAT_ISSUANCE_FIXED_DECIMAL; }  } /*    @notice Calculates float owed to the user since the user last minted float for a market.   @param marketIndex Identifier for the market which the user staked in.   @param user The address of the user.   @return floatReward The amount of float owed.    /   function _calculateAccumulatedFloat(uint32 marketIndex, address user) internal virtual returns (uint256 floatReward) {     address longToken = syntheticTokens[marketIndex][true];     address shortToken = syntheticTokens[marketIndex][false]; uint256 amountStakedLong = userAmountStaked[longToken][user]; uint256 amountStakedShort = userAmountStaked[shortToken][user];  uint256 usersLastRewardIndex = userIndexOfLastClaimedReward[marketIndex][user];  // Don't do the calculation and return zero immediately if there is no change if (usersLastRewardIndex == latestRewardIndex[marketIndex]) {   return 0; }  uint256 usersShiftIndex = userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][user]; // if there is a change in the users tokens held due to a token shift (or possibly another action in the future) if (usersShiftIndex &gt; 0 &amp;&amp; usersShiftIndex &lt; batched_stakerNextTokenShiftIndex[marketIndex]) {   floatReward = _calculateAccumulatedFloatInRange(     marketIndex,     amountStakedLong,     amountStakedShort,     usersLastRewardIndex,     stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[usersShiftIndex]   );    // Update the users balances   if (userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user] &gt; 0) {     amountStakedShort += ILongShort(longShort).getAmountSyntheticTokenToMintOnTargetSide(       marketIndex,       userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user],       true,       stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[usersShiftIndex]     );      amountStakedLong -= userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user];     userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user] = 0;   }    if (userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user] &gt; 0) {     amountStakedLong += ILongShort(longShort).getAmountSyntheticTokenToMintOnTargetSide(       marketIndex,       userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user],       false,       stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[usersShiftIndex]     );      amountStakedShort -= userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user];     userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user] = 0;   }    // Save the users updated staked amounts   userAmountStaked[longToken][user] = amountStakedLong;   userAmountStaked[shortToken][user] = amountStakedShort;    floatReward += _calculateAccumulatedFloatInRange(     marketIndex,     amountStakedLong,     amountStakedShort,     stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[usersShiftIndex],     latestRewardIndex[marketIndex]   );    userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][user] = 0; } else {   floatReward = _calculateAccumulatedFloatInRange(     marketIndex,     amountStakedLong,     amountStakedShort,     usersLastRewardIndex,     latestRewardIndex[marketIndex]   ); }  } /*   @notice Mints float for a user.   @dev Mints a fixed percentage for Float capital.   @param user The address of the user.   @param floatToMint The amount of float to mint.    /   function _mintFloat(address user, uint256 floatToMint) internal virtual {     IFloatToken(floatToken).mint(user, floatToMint);     IFloatToken(floatToken).mint(floatCapital, (floatToMint * floatPercentage) / 1e18);   } /*   @notice Mints float owed to a user for a market since they last minted.   @param marketIndex An identifier for the market.   @param user The address of the user.    /   function _mintAccumulatedFloat(uint32 marketIndex, address user) internal virtual {     uint256 floatToMint = _calculateAccumulatedFloat(marketIndex, user); if (floatToMint &gt; 0) {   // Set the user has claimed up until now, stops them setting this forward   userIndexOfLastClaimedReward[marketIndex][user] = latestRewardIndex[marketIndex];    _mintFloat(user, floatToMint);   emit FloatMinted(user, marketIndex, floatToMint); }  } /*   @notice Mints float owed to a user for multiple markets, since they last minted for those markets.   @param marketIndexes Identifiers for the markets.   @param user The address of the user.    /   function _mintAccumulatedFloatMulti(uint32[] calldata marketIndexes, address user) internal virtual {     uint256 floatTotal = 0;     for (uint256 i = 0; i &lt; marketIndexes.length; i++) {       uint256 floatToMint = _calculateAccumulatedFloat(marketIndexes[i], user);   if (floatToMint &gt; 0) {     // Set the user has claimed up until now, stops them setting this forward     userIndexOfLastClaimedReward[marketIndexes[i]][user] = latestRewardIndex[marketIndexes[i]];      floatTotal += floatToMint;      emit FloatMinted(user, marketIndexes[i], floatToMint);   } } if (floatTotal &gt; 0) {   _mintFloat(user, floatTotal); }  } /*   @notice Mints outstanding float for msg.sender.   @param marketIndexes Identifiers for the markets for which to mint float.    /   function claimFloatCustom(uint32[] calldata marketIndexes) external {     ILongShort(longShort).updateSystemStateMulti(marketIndexes);     _mintAccumulatedFloatMulti(marketIndexes, msg.sender);   } /*   @notice Mints outstanding float on behalf of another user.   @param marketIndexes Identifiers for the markets for which to mint float.   @param user The address of the user.    /   function claimFloatCustomFor(uint32[] calldata marketIndexes, address user) external {     // Unbounded loop - users are responsible for paying their own gas costs on these and it doesn't effect the rest of the system.     // No need to impose limit.     ILongShort(longShort).updateSystemStateMulti(marketIndexes);     _mintAccumulatedFloatMulti(marketIndexes, user);   } /╔═══════════════════════╗     ║        STAKING        ║     ╚═══════════════════════╝/ /*   @notice A user with synthetic tokens stakes by calling stake on the token   contract which calls this function. We need to first update the   state of the LongShort contract for this market before staking to correctly calculate user rewards.   @param amount Amount to stake.   @param from Address to stake for.   /   function stakeFromUser(address from, uint256 amount) public virtual override onlyValidSynthetic((msg.sender)) {     ILongShort(longShort).updateSystemState(marketIndexOfToken[(msg.sender)]);     _stake((msg.sender), amount, from);   } /*   @dev Internal logic for staking.   @param token Address of the token for which to stake.   @param amount Amount to stake.   @param user Address to stake for.   /   function _stake(     address token,     uint256 amount,     address user   ) internal virtual {     uint32 marketIndex = marketIndexOfToken[token]; // If they already have staked and have rewards due, mint these. if (   userIndexOfLastClaimedReward[marketIndex][user] != 0 &amp;&amp;   userIndexOfLastClaimedReward[marketIndex][user] &lt; latestRewardIndex[marketIndex] ) {   _mintAccumulatedFloat(marketIndex, user); }  userAmountStaked[token][user] = userAmountStaked[token][user] + amount;  userIndexOfLastClaimedReward[marketIndex][user] = latestRewardIndex[marketIndex];  emit StakeAdded(user, address(token), amount, userIndexOfLastClaimedReward[marketIndex][user]);  } /*   @notice Allows users to shift their staked tokens from one side of the market to    the other at the next price.   @param amountSyntheticTokensToShift Amount of tokens to shift.   @param marketIndex Identifier for the market.   @param isShiftFromLong Whether the shift is from long to short or short to long.   /   function shiftTokens(     uint256 amountSyntheticTokensToShift,     uint32 marketIndex,     bool isShiftFromLong   ) external virtual {     address token = syntheticTokens[marketIndex][isShiftFromLong];     require(userAmountStaked[token][msg.sender] &gt;= amountSyntheticTokensToShift, "Not enough tokens to shift"); // If the user has outstanding token shift that have already been confirmed in the LongShort // contract, execute them first. if (   userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] != 0 &amp;&amp;   userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] &lt;   batched_stakerNextTokenShiftIndex[marketIndex] ) {   _mintAccumulatedFloat(marketIndex, msg.sender); }  if (isShiftFromLong) {   ILongShort(longShort).shiftPositionFromLongNextPrice(marketIndex, amountSyntheticTokensToShift);   userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][     msg.sender   ] += amountSyntheticTokensToShift; } else {   ILongShort(longShort).shiftPositionFromShortNextPrice(marketIndex, amountSyntheticTokensToShift);   userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][     msg.sender   ] += amountSyntheticTokensToShift; }  userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] = batched_stakerNextTokenShiftIndex[   marketIndex ];  } /╔════════════════════════════╗     ║    WITHDRAWAL &amp; MINTING    ║     ╚════════════════════════════╝/ /*   @notice Internal logic for withdrawing stakes.   @dev Mint user any outstanding float before withdrawing.   @param marketIndex Market index of token.   @param amount Amount to withdraw.   @param token Synthetic token that was staked.   /   function _withdraw(     uint32 marketIndex,     address token,     uint256 amount   ) internal virtual {     require(userAmountStaked[token][msg.sender] &gt; 0, "nothing to withdraw");     _mintAccumulatedFloat(marketIndex, msg.sender); userAmountStaked[token][msg.sender] = userAmountStaked[token][msg.sender] - amount;  uint256 amountFees = (amount * marketUnstakeFee_e18[marketIndex]) / 1e18;  IERC20(token).transfer(floatTreasury, amountFees); IERC20(token).transfer(msg.sender, amount - amountFees);  emit StakeWithdrawn(msg.sender, token, amount);  } /*   @notice Withdraw function. Allows users to unstake.   @param amount Amount to withdraw.   @param token Address of the token for which to withdraw.   /   function withdraw(address token, uint256 amount) external {     ILongShort(longShort).updateSystemState(marketIndexOfToken[token]); uint32 marketIndex = marketIndexOfToken[token];  _withdraw(marketIndex, token, amount);  if (userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] &gt; 0) {   // If they still have outstanding shifts after minting float, then check   // that they don't withdraw more than their shifts allow.   uint256 amountToShiftForThisToken = syntheticTokens[marketIndex][true] == token     ? userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][msg.sender]     : userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][msg.sender];    require(     userAmountStaked[token][msg.sender] &gt;= amountToShiftForThisToken,     "Outstanding next price stake shifts too great"   ); }  } /*   @notice Allows users to withdraw their entire stake for a token.   @param token Address of the token for which to withdraw.   /   function withdrawAll(address token) external {     ILongShort(longShort).updateSystemState(marketIndexOfToken[token]); uint32 marketIndex = marketIndexOfToken[token];  uint256 amountToShiftForThisToken = syntheticTokens[marketIndex][true] == token   ? userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][msg.sender]   : userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][msg.sender];  _withdraw(marketIndex, token, userAmountStaked[token][msg.sender] - amountToShiftForThisToken);  } } |
| **need_reflect** | False |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **phase_prompt** | Below are the details of our smart contract codes and their corresponding analysis reports: Task: "{task}". As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report. |
| **phase_name** | BugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 3, 'task': '', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-17-08 08:01:57 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: BUSL-1.1 pragma solidity 0.8.3; import "@openzeppelin/contracts-upgradeable/token/ERC20/presets/ERC20PresetMinterPauserUpgradeable.sol"; import "./interfaces/IFloatToken.sol"; import "./interfaces/ILongShort.sol"; import "./interfaces/IStaker.sol"; import "./interfaces/ISyntheticToken.sol"; contract Staker is IStaker, Initializable {   /╔═════════════════════════════╗     ║          VARIABLES          ║     ╚═════════════════════════════╝/ / ══════ Fixed-precision constants ══════ /   uint256 public constant FLOAT_ISSUANCE_FIXED_DECIMAL = 1e42;   // 2^52 ~= 4.5e15   // With an exponent of 5, the largest total liquidity possible in a market (to avoid integer overflow on exponentiation) is ~10^31 or 10 Trillion (10^13)   // NOTE: this also means if the total market value is less than 2^52 there will be a division by zero error   uint256 public constant safeExponentBitShifting = 52; / ══════ Global state ══════ /   address public admin;   address public floatCapital;   address public floatTreasury;   uint256 public floatPercentage; address public longShort;   address public floatToken; / ══════ Market specific ══════ /   mapping(uint32 =&gt; uint256) public marketLaunchIncentive_period; // seconds   mapping(uint32 =&gt; uint256) public marketLaunchIncentive_multipliers; // e18 scale   mapping(uint32 =&gt; uint256) public marketUnstakeFee_e18;   mapping(uint32 =&gt; uint256) public balanceIncentiveCurve_exponent;   mapping(uint32 =&gt; int256) public balanceIncentiveCurve_equilibriumOffset; mapping(uint32 =&gt; mapping(bool =&gt; address)) public syntheticTokens; mapping(address =&gt; uint32) public marketIndexOfToken; / ══════ Reward specific ══════ /   mapping(uint32 =&gt; uint256) public latestRewardIndex;   mapping(uint32 =&gt; mapping(uint256 =&gt; AccumulativeIssuancePerStakedSynthSnapshot))     public accumulativeFloatPerSyntheticTokenSnapshots;   struct AccumulativeIssuancePerStakedSynthSnapshot {     uint256 timestamp;     uint256 accumulativeFloatPerSyntheticToken_long;     uint256 accumulativeFloatPerSyntheticToken_short;   } / ══════ User specific ══════ /   mapping(uint32 =&gt; mapping(address =&gt; uint256)) public userIndexOfLastClaimedReward;   mapping(address =&gt; mapping(address =&gt; uint256)) public userAmountStaked; / ══════ Token shift management specific ══════ /   mapping(uint32 =&gt; uint256) public batched_stakerNextTokenShiftIndex;   /*   @notice Used to link a token shift to a staker state   @dev tokenShiftIndex =&gt; accumulativeFloatIssuanceSnapshotIndex     POSSIBLE OPTIMIZATION - could pack stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping and stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping into a struct of two uint128 for storage space optimization.   /   mapping(uint256 =&gt; uint256) public stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping;   /// @notice Used to fetch the price from LongShort at that point in time   /// @dev tokenShiftIndex =&gt; longShortMarketPriceSnapshotIndex   mapping(uint256 =&gt; uint256) public stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping;   /// @dev marketIndex =&gt; usersAddress =&gt; stakerTokenShiftIndex   mapping(uint32 =&gt; mapping(address =&gt; uint256)) public userNextPrice_stakedSyntheticTokenShiftIndex;   /// @dev marketIndex =&gt; usersAddress =&gt; amountUserRequestedToShiftAwayFromLongOnNextUpdate   mapping(uint32 =&gt; mapping(address =&gt; uint256)) public userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long;   /// @dev marketIndex =&gt; usersAddress =&gt; amountUserRequestedToShiftAwayFromShortOnNextUpdate   mapping(uint32 =&gt; mapping(address =&gt; uint256)) public userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short; /╔════════════════════════════╗     ║           EVENTS           ║     ╚════════════════════════════╝/ event StakerV1(     address admin,     address floatTreasury,     address floatCapital,     address floatToken,     uint256 floatPercentage   ); event MarketAddedToStaker(     uint32 marketIndex,     uint256 exitFee_e18,     uint256 period,     uint256 multiplier,     uint256 balanceIncentiveExponent,     int256 balanceIncentiveEquilibriumOffset   ); event AccumulativeIssuancePerStakedSynthSnapshotCreated(     uint32 marketIndex,     uint256 accumulativeFloatIssuanceSnapshotIndex,     uint256 accumulativeLong,     uint256 accumulativeShort   ); event StakeAdded(address user, address token, uint256 amount, uint256 lastMintIndex); event StakeWithdrawn(address user, address token, uint256 amount); // Note: the amountFloatMinted isn't strictly needed by the graph, but it is good to add it to validate calculations are accurate.   event FloatMinted(address user, uint32 marketIndex, uint256 amountFloatMinted); event MarketLaunchIncentiveParametersChanges(uint32 marketIndex, uint256 period, uint256 multiplier); event StakeWithdrawalFeeUpdated(uint32 marketIndex, uint256 stakeWithdralFee); event BalanceIncentiveExponentUpdated(uint32 marketIndex, uint256 balanceIncentiveExponent); event BalanceIncentiveEquilibriumOffsetUpdated(uint32 marketIndex, int256 balanceIncentiveEquilibriumOffset); event FloatPercentageUpdated(uint256 floatPercentage); event SyntheticTokensShifted(); event ChangeAdmin(address newAdmin); /╔═════════════════════════════╗     ║          MODIFIERS          ║     ╚═════════════════════════════╝/ function onlyAdminModifierLogic() internal virtual {     require(msg.sender == admin, "not admin");   } modifier onlyAdmin() {     onlyAdminModifierLogic();     _;   } function onlyValidSyntheticModifierLogic(address _synth) internal virtual {     require(marketIndexOfToken[_synth] != 0, "not valid synth");   } modifier onlyValidSynthetic(address synth) {     onlyValidSyntheticModifierLogic(_synth);     ;   } function onlyValidMarketModifierLogic(uint32 marketIndex) internal virtual {     require(address(syntheticTokens[marketIndex][true]) != address(0), "not valid market");   } modifier onlyValidMarket(uint32 marketIndex) {     onlyValidMarketModifierLogic(marketIndex);     _;   } function onlyLongShortModifierLogic() internal virtual {     require(msg.sender == address(longShort), "not long short");   } modifier onlyLongShort() {     onlyLongShortModifierLogic();     _;   } /╔═════════════════════════════╗     ║       CONTRACT SET-UP       ║     ╚═════════════════════════════╝/ /*   @notice Initializes the contract.   @dev Calls OpenZeppelin's initializer modifier.   @param _admin Address of the admin role.   @param _longShort Address of the LongShort contract, a deployed LongShort.sol   @param _floatToken Address of the Float token earned by staking.   @param _floatTreasury Address of the treasury contract for managing fees.   @param _floatCapital Address of the contract which earns a fixed percentage of Float.   @param _floatPercentage Determines the float percentage that gets minted for Float Capital, base 1e18.   /   function initialize(     address _admin,     address _longShort,     address _floatToken,     address _floatTreasury,     address _floatCapital,     uint256 _floatPercentage   ) external virtual initializer {     admin = _admin;     floatCapital = _floatCapital;     floatTreasury = _floatTreasury;     longShort = _longShort;     floatToken = _floatToken; _changeFloatPercentage(_floatPercentage);  emit StakerV1(_admin, _floatTreasury, _floatCapital, _floatToken, _floatPercentage);  } /╔═══════════════════╗     ║       ADMIN       ║     ╚═══════════════════╝/ /*    @notice Changes admin for the contract   @param _admin The address of the new admin.   /   function changeAdmin(address _admin) external onlyAdmin {     admin = _admin;     emit ChangeAdmin(_admin);   } /// @dev Logic for changeFloatPercentage   function _changeFloatPercentage(uint256 newFloatPercentage) internal virtual {     require(newFloatPercentage &lt;= 1e18 &amp;&amp; newFloatPercentage &gt; 0); // less than or equal to 100% and greater than 0%     floatPercentage = newFloatPercentage;   } /*   @notice Changes percentage of float that is minted for float capital.   @param newFloatPercentage The new float percentage in base 1e18.   /   function changeFloatPercentage(uint256 newFloatPercentage) external onlyAdmin {     _changeFloatPercentage(newFloatPercentage);     emit FloatPercentageUpdated(newFloatPercentage);   } /// @dev Logic for changeUnstakeFee   function _changeUnstakeFee(uint32 marketIndex, uint256 newMarketUnstakeFee_e18) internal virtual {     require(newMarketUnstakeFee_e18 &lt;= 5e16); // Explicitely stating 5% fee as the max fee possible.     marketUnstakeFee_e18[marketIndex] = newMarketUnstakeFee_e18;   } /*   @notice Changes unstake fee for a market   @param marketIndex Identifies the market.   @param newMarketUnstakeFee_e18 The new unstake fee.   /   function changeUnstakeFee(uint32 marketIndex, uint256 newMarketUnstakeFee_e18) external onlyAdmin {     _changeUnstakeFee(marketIndex, newMarketUnstakeFee_e18);     emit StakeWithdrawalFeeUpdated(marketIndex, newMarketUnstakeFee_e18);   } /// @dev Logic for changeMarketLaunchIncentiveParameters   function _changeMarketLaunchIncentiveParameters(     uint32 marketIndex,     uint256 period,     uint256 initialMultiplier   ) internal virtual {     require(initialMultiplier &gt;= 1e18, "marketLaunchIncentiveMultiplier must be &gt;= 1e18"); marketLaunchIncentive_period[marketIndex] = period; marketLaunchIncentive_multipliers[marketIndex] = initialMultiplier;  } /*   @notice Changes the market launch incentive parameters for a market   @param marketIndex Identifies the market.   @param period The new period for which float token generation should be boosted.   @param initialMultiplier The new multiplier on Float generation.   /   function changeMarketLaunchIncentiveParameters(     uint32 marketIndex,     uint256 period,     uint256 initialMultiplier   ) external onlyAdmin {     _changeMarketLaunchIncentiveParameters(marketIndex, period, initialMultiplier); emit MarketLaunchIncentiveParametersChanges(marketIndex, period, initialMultiplier);  } /// @dev Logic for changeBalanceIncentiveExponent   function _changeBalanceIncentiveExponent(uint32 marketIndex, uint256 _balanceIncentiveCurve_exponent)     internal     virtual   {     require(       // The exponent has to be less than 5 in these versions of the contracts.       _balanceIncentiveCurve_exponent &gt; 0 &amp;&amp; _balanceIncentiveCurve_exponent &lt; 6,       "balanceIncentiveCurve_exponent out of bounds"     ); balanceIncentiveCurve_exponent[marketIndex] = _balanceIncentiveCurve_exponent;  } /*    @notice Changes the balance incentive exponent for a market   @param marketIndex Identifies the market.   @param _balanceIncentiveCurve_exponent The new exponent for the curve.   /   function changeBalanceIncentiveExponent(uint32 marketIndex, uint256 _balanceIncentiveCurve_exponent)     external     onlyAdmin   {     _changeBalanceIncentiveExponent(marketIndex, _balanceIncentiveCurve_exponent); emit BalanceIncentiveExponentUpdated(marketIndex, _balanceIncentiveCurve_exponent);  } /// @dev Logic for changeBalanceIncentiveEquilibriumOffset   function _changeBalanceIncentiveEquilibriumOffset(uint32 marketIndex, int256 _balanceIncentiveCurve_equilibriumOffset)     internal     virtual   {     // Unreasonable that we would ever shift this more than 90% either way     require(       _balanceIncentiveCurve_equilibriumOffset &gt; -9e17 &amp;&amp; _balanceIncentiveCurve_equilibriumOffset &lt; 9e17,       "balanceIncentiveCurve_equilibriumOffset out of bounds"     ); balanceIncentiveCurve_equilibriumOffset[marketIndex] = _balanceIncentiveCurve_equilibriumOffset;  } /*   @notice Changes the balance incentive curve equilibrium offset for a market   @param marketIndex Identifies the market.   @param _balanceIncentiveCurve_equilibriumOffset The new offset.   /   function changeBalanceIncentiveEquilibriumOffset(uint32 marketIndex, int256 _balanceIncentiveCurve_equilibriumOffset)     external     onlyAdmin   {     _changeBalanceIncentiveEquilibriumOffset(marketIndex, _balanceIncentiveCurve_equilibriumOffset); emit BalanceIncentiveEquilibriumOffsetUpdated(marketIndex, _balanceIncentiveCurve_equilibriumOffset);  } /╔═════════════════════════════╗     ║        STAKING SETUP        ║     ╚═════════════════════════════╝/ /*   @notice Sets this contract to track staking for a market in LongShort.sol   @param marketIndex Identifies the market.   @param longToken Address of the long token for the market.   @param shortToken Address of the short token for the market.   @param kInitialMultiplier Initial boost on float generation for the market.   @param kPeriod Period which the boost should last.   @param unstakeFee_e18 Percentage of tokens that are levied on unstaking in base 1e18.   @param _balanceIncentiveCurve_exponent Exponent for balance curve (see _calculateFloatPerSecond)   @param _balanceIncentiveCurve_equilibriumOffset Offset for balance curve (see _calculateFloatPerSecond)   /   function addNewStakingFund(     uint32 marketIndex,     address longToken,     address shortToken,     uint256 kInitialMultiplier,     uint256 kPeriod,     uint256 unstakeFee_e18,     uint256 _balanceIncentiveCurve_exponent,     int256 _balanceIncentiveCurve_equilibriumOffset   ) external override onlyLongShort {     marketIndexOfToken[longToken] = marketIndex;     marketIndexOfToken[shortToken] = marketIndex; accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].timestamp = block.timestamp; accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].accumulativeFloatPerSyntheticToken_long = 0; accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].accumulativeFloatPerSyntheticToken_short = 0;  syntheticTokens[marketIndex][true] = longToken; syntheticTokens[marketIndex][false] = shortToken;  _changeBalanceIncentiveExponent(marketIndex, _balanceIncentiveCurve_exponent); _changeBalanceIncentiveEquilibriumOffset(marketIndex, _balanceIncentiveCurve_equilibriumOffset); _changeMarketLaunchIncentiveParameters(marketIndex, kPeriod, kInitialMultiplier);  _changeUnstakeFee(marketIndex, unstakeFee_e18);  // Set this value to one initially - 0 is a null value and thus potentially bug prone. batched_stakerNextTokenShiftIndex[marketIndex] = 1;  emit MarketAddedToStaker(   marketIndex,   unstakeFee_e18,   kPeriod,   kInitialMultiplier,   _balanceIncentiveCurve_exponent,   _balanceIncentiveCurve_equilibriumOffset );  emit AccumulativeIssuancePerStakedSynthSnapshotCreated(marketIndex, 0, 0, 0);  } /╔═════════════════════════════════════════════════════════════════════════╗     ║    GLOBAL FLT REWARD ACCUMULATION CALCULATION AND TRACKING FUNCTIONS    ║     ╚═════════════════════════════════════════════════════════════════════════╝/ /*   @notice Returns the K factor parameters for the given market with sensible   defaults if they haven't been set yet.   @param marketIndex The market to change the parameters for.   @return period The period for which the k factor applies for in seconds.   @return multiplier The multiplier on Float generation in this period.   /   function _getMarketLaunchIncentiveParameters(uint32 marketIndex)     internal     view     virtual     returns (uint256 period, uint256 multiplier)   {     period = marketLaunchIncentive_period[marketIndex];     multiplier = marketLaunchIncentive_multipliers[marketIndex]; if (multiplier &lt; 1e18) {   multiplier = 1e18; // multiplier of 1 by default }  } /*    @notice Returns the extent to which a markets float generation should be adjusted   based on the market's launch incentive parameters. Should start at multiplier   then linearly change to 1e18 over time.   @param marketIndex Identifies the market.   @return k The calculated modifier for float generation.   /   function _getKValue(uint32 marketIndex) internal view virtual returns (uint256) {     // Parameters controlling the float issuance multiplier.     (uint256 kPeriod, uint256 kInitialMultiplier) = _getMarketLaunchIncentiveParameters(marketIndex); // Sanity check - under normal circumstances, the multipliers should // *never* be set to a value &lt; 1e18, as there are guards against this. assert(kInitialMultiplier &gt;= 1e18);  uint256 initialTimestamp = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].timestamp;  if (block.timestamp - initialTimestamp &lt;= kPeriod) {   return kInitialMultiplier - (((kInitialMultiplier - 1e18) * (block.timestamp - initialTimestamp)) / kPeriod); } else {   return 1e18; }  } /   @notice Computes the number of float tokens a user earns per second for   every long/short synthetic token they've staked. The returned value has   a fixed decimal scale of 1e42 (!!!) for numerical stability. The return   values are float per second per synthetic token (hence the requirement   to multiply by price)   @dev to see below math in latex form see TODO add link   to interact with the equations see https://www.desmos.com/calculator/optkaxyihr   @param marketIndex The market referred to.   @param longPrice Price of the synthetic long token in units of payment token   @param shortPrice Price of the synthetic short token in units of payment token   @param longValue Amount of payment token in the long side of the market   @param shortValue Amount of payment token in the short side of the market   @return longFloatPerSecond Float token per second per long synthetic token   @return shortFloatPerSecond Float token per second per short synthetic token    /   function _calculateFloatPerSecond(     uint32 marketIndex,     uint256 longPrice,     uint256 shortPrice,     uint256 longValue,     uint256 shortValue   ) internal view virtual returns (uint256 longFloatPerSecond, uint256 shortFloatPerSecond) {     // A float issuance multiplier that starts high and decreases linearly     // over time to a value of 1. This incentivises users to stake early.     uint256 k = _getKValue(marketIndex); uint256 totalLocked = (longValue + shortValue);  // we need to scale this number by the totalLocked so that the offset remains consistent accross market size  int256 equilibriumOffsetMarketScaled = (balanceIncentiveCurve_equilibriumOffset[marketIndex] *   int256(totalLocked)) / 2e18;  uint256 denominator = ((totalLocked &gt;&gt; safeExponentBitShifting)**balanceIncentiveCurve_exponent[marketIndex]);  // Float is scaled by the percentage of the total market value held in // the opposite position. This incentivises users to stake on the // weaker position. if (int256(shortValue) - equilibriumOffsetMarketScaled &lt; int256(longValue)) {   if (equilibriumOffsetMarketScaled &gt;= int256(shortValue)) {     // edge case: imbalanced far past the equilibrium offset - full rewards go to short token     //            extremeley unlikely to happen in practice     return (0, 1e18 * k * shortPrice);   }    uint256 numerator = (uint256(int256(shortValue) - equilibriumOffsetMarketScaled) &gt;&gt;     (safeExponentBitShifting - 1))**balanceIncentiveCurve_exponent[marketIndex];    // NOTE: `x * 5e17` == `(x * 10e18) / 2`   uint256 longRewardUnscaled = (numerator * 5e17) / denominator;   uint256 shortRewardUnscaled = 1e18 - longRewardUnscaled;    return ((longRewardUnscaled * k * longPrice) / 1e18, (shortRewardUnscaled * k * shortPrice) / 1e18); } else {   if (-equilibriumOffsetMarketScaled &gt;= int256(longValue)) {     // edge case: imbalanced far past the equilibrium offset - full rewards go to long token     //            extremeley unlikely to happen in practice     return (1e18 * k * longPrice, 0);   }    uint256 numerator = (uint256(int256(longValue) + equilibriumOffsetMarketScaled) &gt;&gt;     (safeExponentBitShifting - 1))**balanceIncentiveCurve_exponent[marketIndex];    // NOTE: `x * 5e17` == `(x * 10e18) / 2`   uint256 shortRewardUnscaled = (numerator * 5e17) / denominator;   uint256 longRewardUnscaled = 1e18 - shortRewardUnscaled;    return ((longRewardUnscaled * k * longPrice) / 1e18, (shortRewardUnscaled * k * shortPrice) / 1e18); }  } /*   @notice Computes the time since last accumulativeIssuancePerStakedSynthSnapshot for the given market in seconds.   @param marketIndex The market referred to.   @return The time difference in seconds   /   function _calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(uint32 marketIndex)     internal     view     virtual     returns (uint256)   {     return       block.timestamp -       accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]].timestamp;   } /*   @notice Computes new cumulative sum of 'r' value since last accumulativeIssuancePerStakedSynthSnapshot. We use   cumulative 'r' value to avoid looping during issuance. Note that the   cumulative sum is kept in 1e42 scale (!!!) to avoid numerical issues.   @param shortValue The value locked in the short side of the market.   @param longValue The value locked in the long side of the market.   @param shortPrice The price of the short token as defined in LongShort.sol   @param longPrice The price of the long token as defined in LongShort.sol   @param marketIndex An identifier for the market.   @return longCumulativeRates The long cumulative sum.   @return shortCumulativeRates The short cumulative sum.   /   function _calculateNewCumulativeIssuancePerStakedSynth(     uint32 marketIndex,     uint256 longPrice,     uint256 shortPrice,     uint256 longValue,     uint256 shortValue   ) internal view virtual returns (uint256 longCumulativeRates, uint256 shortCumulativeRates) {     // Compute the current 'r' value for float issuance per second.     (uint256 longFloatPerSecond, uint256 shortFloatPerSecond) = _calculateFloatPerSecond(       marketIndex,       longPrice,       shortPrice,       longValue,       shortValue     ); // Compute time since last accumulativeIssuancePerStakedSynthSnapshot for the given token. uint256 timeDelta = _calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(marketIndex);  // Compute new cumulative 'r' value total. return (   accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]]   .accumulativeFloatPerSyntheticToken_long + (timeDelta * longFloatPerSecond),   accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]]   .accumulativeFloatPerSyntheticToken_short + (timeDelta * shortFloatPerSecond) );  } /*   @notice Creates a new accumulativeIssuancePerStakedSynthSnapshot for the given token and updates indexes.   @param shortValue The value locked in the short side of the market.   @param longValue The value locked in the long side of the market.   @param shortPrice The price of the short token as defined in LongShort.sol   @param longPrice The price of the long token as defined in LongShort.sol   @param marketIndex An identifier for the market.   /   function _setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot(     uint32 marketIndex,     uint256 longPrice,     uint256 shortPrice,     uint256 longValue,     uint256 shortValue   ) internal virtual {     (       uint256 newLongAccumulativeValue,       uint256 newShortAccumulativeValue     ) = _calculateNewCumulativeIssuancePerStakedSynth(marketIndex, longPrice, shortPrice, longValue, shortValue); uint256 newIndex = latestRewardIndex[marketIndex] + 1;  // Set cumulative 'r' value on new accumulativeIssuancePerStakedSynthSnapshot. accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex] .accumulativeFloatPerSyntheticToken_long = newLongAccumulativeValue; accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex] .accumulativeFloatPerSyntheticToken_short = newShortAccumulativeValue;  // Set timestamp on new accumulativeIssuancePerStakedSynthSnapshot. accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex].timestamp = block.timestamp;  // Update latest index to point to new accumulativeIssuancePerStakedSynthSnapshot. latestRewardIndex[marketIndex] = newIndex;  emit AccumulativeIssuancePerStakedSynthSnapshotCreated(   marketIndex,   newIndex,   newLongAccumulativeValue,   newShortAccumulativeValue );  } /*   @notice Adds new accumulativeIssuancePerStakedSynthSnapshots for the given long/short tokens. Called by the   ILongShort contract whenever there is a state change for a market.   @param stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted Mapping from this contract's shifts to LongShort.sols next price snapshots.   @param shortValue The value locked in the short side of the market.   @param longValue The value locked in the long side of the market.   @param shortPrice The price of the short token as defined in LongShort.sol   @param longPrice The price of the long token as defined in LongShort.sol   @param marketIndex An identifier for the market.   /   function pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(     uint32 marketIndex,     uint256 longPrice,     uint256 shortPrice,     uint256 longValue,     uint256 shortValue,     uint256 stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted // This value should be ALWAYS be zero if no shift occured   ) external override onlyLongShort {     // Only add a new accumulativeIssuancePerStakedSynthSnapshot if some time has passed. // the `stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted` value will be 0 if there is no staker related action in an executed batch if (stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted &gt; 0) {   stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[     batched_stakerNextTokenShiftIndex[marketIndex]   ] = stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted;   stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[     batched_stakerNextTokenShiftIndex[marketIndex]   ] = latestRewardIndex[marketIndex] + 1;   batched_stakerNextTokenShiftIndex[marketIndex] += 1;    emit SyntheticTokensShifted(); }  // Time delta is fetched twice in below code, can pass through? Which is less gas? if (_calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(marketIndex) &gt; 0) {   _setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot(     marketIndex,     longPrice,     shortPrice,     longValue,     shortValue   ); }  } /╔═══════════════════════════════════╗     ║    USER REWARD STATE FUNCTIONS    ║     ╚═══════════════════════════════════╝/ /// @dev Calculates the accumulated float in a specific range of staker snapshots   function _calculateAccumulatedFloatInRange(     uint32 marketIndex,     uint256 amountStakedLong,     uint256 amountStakedShort,     uint256 rewardIndexFrom,     uint256 rewardIndexTo   ) internal view virtual returns (uint256 floatReward) {     if (amountStakedLong &gt; 0) {       uint256 accumDeltaLong = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexTo]       .accumulativeFloatPerSyntheticToken_long -         accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexFrom]         .accumulativeFloatPerSyntheticToken_long;       floatReward += (accumDeltaLong * amountStakedLong) / FLOAT_ISSUANCE_FIXED_DECIMAL;     } if (amountStakedShort &gt; 0) {   uint256 accumDeltaShort = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexTo]   .accumulativeFloatPerSyntheticToken_short -     accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexFrom]     .accumulativeFloatPerSyntheticToken_short;   floatReward += (accumDeltaShort * amountStakedShort) / FLOAT_ISSUANCE_FIXED_DECIMAL; }  } /*    @notice Calculates float owed to the user since the user last minted float for a market.   @param marketIndex Identifier for the market which the user staked in.   @param user The address of the user.   @return floatReward The amount of float owed.    /   function _calculateAccumulatedFloat(uint32 marketIndex, address user) internal virtual returns (uint256 floatReward) {     address longToken = syntheticTokens[marketIndex][true];     address shortToken = syntheticTokens[marketIndex][false]; uint256 amountStakedLong = userAmountStaked[longToken][user]; uint256 amountStakedShort = userAmountStaked[shortToken][user];  uint256 usersLastRewardIndex = userIndexOfLastClaimedReward[marketIndex][user];  // Don't do the calculation and return zero immediately if there is no change if (usersLastRewardIndex == latestRewardIndex[marketIndex]) {   return 0; }  uint256 usersShiftIndex = userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][user]; // if there is a change in the users tokens held due to a token shift (or possibly another action in the future) if (usersShiftIndex &gt; 0 &amp;&amp; usersShiftIndex &lt; batched_stakerNextTokenShiftIndex[marketIndex]) {   floatReward = _calculateAccumulatedFloatInRange(     marketIndex,     amountStakedLong,     amountStakedShort,     usersLastRewardIndex,     stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[usersShiftIndex]   );    // Update the users balances   if (userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user] &gt; 0) {     amountStakedShort += ILongShort(longShort).getAmountSyntheticTokenToMintOnTargetSide(       marketIndex,       userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user],       true,       stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[usersShiftIndex]     );      amountStakedLong -= userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user];     userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user] = 0;   }    if (userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user] &gt; 0) {     amountStakedLong += ILongShort(longShort).getAmountSyntheticTokenToMintOnTargetSide(       marketIndex,       userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user],       false,       stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[usersShiftIndex]     );      amountStakedShort -= userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user];     userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user] = 0;   }    // Save the users updated staked amounts   userAmountStaked[longToken][user] = amountStakedLong;   userAmountStaked[shortToken][user] = amountStakedShort;    floatReward += _calculateAccumulatedFloatInRange(     marketIndex,     amountStakedLong,     amountStakedShort,     stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[usersShiftIndex],     latestRewardIndex[marketIndex]   );    userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][user] = 0; } else {   floatReward = _calculateAccumulatedFloatInRange(     marketIndex,     amountStakedLong,     amountStakedShort,     usersLastRewardIndex,     latestRewardIndex[marketIndex]   ); }  } /*   @notice Mints float for a user.   @dev Mints a fixed percentage for Float capital.   @param user The address of the user.   @param floatToMint The amount of float to mint.    /   function _mintFloat(address user, uint256 floatToMint) internal virtual {     IFloatToken(floatToken).mint(user, floatToMint);     IFloatToken(floatToken).mint(floatCapital, (floatToMint * floatPercentage) / 1e18);   } /*   @notice Mints float owed to a user for a market since they last minted.   @param marketIndex An identifier for the market.   @param user The address of the user.    /   function _mintAccumulatedFloat(uint32 marketIndex, address user) internal virtual {     uint256 floatToMint = _calculateAccumulatedFloat(marketIndex, user); if (floatToMint &gt; 0) {   // Set the user has claimed up until now, stops them setting this forward   userIndexOfLastClaimedReward[marketIndex][user] = latestRewardIndex[marketIndex];    _mintFloat(user, floatToMint);   emit FloatMinted(user, marketIndex, floatToMint); }  } /*   @notice Mints float owed to a user for multiple markets, since they last minted for those markets.   @param marketIndexes Identifiers for the markets.   @param user The address of the user.    /   function _mintAccumulatedFloatMulti(uint32[] calldata marketIndexes, address user) internal virtual {     uint256 floatTotal = 0;     for (uint256 i = 0; i &lt; marketIndexes.length; i++) {       uint256 floatToMint = _calculateAccumulatedFloat(marketIndexes[i], user);   if (floatToMint &gt; 0) {     // Set the user has claimed up until now, stops them setting this forward     userIndexOfLastClaimedReward[marketIndexes[i]][user] = latestRewardIndex[marketIndexes[i]];      floatTotal += floatToMint;      emit FloatMinted(user, marketIndexes[i], floatToMint);   } } if (floatTotal &gt; 0) {   _mintFloat(user, floatTotal); }  } /*   @notice Mints outstanding float for msg.sender.   @param marketIndexes Identifiers for the markets for which to mint float.    /   function claimFloatCustom(uint32[] calldata marketIndexes) external {     ILongShort(longShort).updateSystemStateMulti(marketIndexes);     _mintAccumulatedFloatMulti(marketIndexes, msg.sender);   } /*   @notice Mints outstanding float on behalf of another user.   @param marketIndexes Identifiers for the markets for which to mint float.   @param user The address of the user.    /   function claimFloatCustomFor(uint32[] calldata marketIndexes, address user) external {     // Unbounded loop - users are responsible for paying their own gas costs on these and it doesn't effect the rest of the system.     // No need to impose limit.     ILongShort(longShort).updateSystemStateMulti(marketIndexes);     _mintAccumulatedFloatMulti(marketIndexes, user);   } /╔═══════════════════════╗     ║        STAKING        ║     ╚═══════════════════════╝/ /*   @notice A user with synthetic tokens stakes by calling stake on the token   contract which calls this function. We need to first update the   state of the LongShort contract for this market before staking to correctly calculate user rewards.   @param amount Amount to stake.   @param from Address to stake for.   /   function stakeFromUser(address from, uint256 amount) public virtual override onlyValidSynthetic((msg.sender)) {     ILongShort(longShort).updateSystemState(marketIndexOfToken[(msg.sender)]);     _stake((msg.sender), amount, from);   } /*   @dev Internal logic for staking.   @param token Address of the token for which to stake.   @param amount Amount to stake.   @param user Address to stake for.   /   function _stake(     address token,     uint256 amount,     address user   ) internal virtual {     uint32 marketIndex = marketIndexOfToken[token]; // If they already have staked and have rewards due, mint these. if (   userIndexOfLastClaimedReward[marketIndex][user] != 0 &amp;&amp;   userIndexOfLastClaimedReward[marketIndex][user] &lt; latestRewardIndex[marketIndex] ) {   _mintAccumulatedFloat(marketIndex, user); }  userAmountStaked[token][user] = userAmountStaked[token][user] + amount;  userIndexOfLastClaimedReward[marketIndex][user] = latestRewardIndex[marketIndex];  emit StakeAdded(user, address(token), amount, userIndexOfLastClaimedReward[marketIndex][user]);  } /*   @notice Allows users to shift their staked tokens from one side of the market to    the other at the next price.   @param amountSyntheticTokensToShift Amount of tokens to shift.   @param marketIndex Identifier for the market.   @param isShiftFromLong Whether the shift is from long to short or short to long.   /   function shiftTokens(     uint256 amountSyntheticTokensToShift,     uint32 marketIndex,     bool isShiftFromLong   ) external virtual {     address token = syntheticTokens[marketIndex][isShiftFromLong];     require(userAmountStaked[token][msg.sender] &gt;= amountSyntheticTokensToShift, "Not enough tokens to shift"); // If the user has outstanding token shift that have already been confirmed in the LongShort // contract, execute them first. if (   userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] != 0 &amp;&amp;   userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] &lt;   batched_stakerNextTokenShiftIndex[marketIndex] ) {   _mintAccumulatedFloat(marketIndex, msg.sender); }  if (isShiftFromLong) {   ILongShort(longShort).shiftPositionFromLongNextPrice(marketIndex, amountSyntheticTokensToShift);   userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][     msg.sender   ] += amountSyntheticTokensToShift; } else {   ILongShort(longShort).shiftPositionFromShortNextPrice(marketIndex, amountSyntheticTokensToShift);   userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][     msg.sender   ] += amountSyntheticTokensToShift; }  userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] = batched_stakerNextTokenShiftIndex[   marketIndex ];  } /╔════════════════════════════╗     ║    WITHDRAWAL &amp; MINTING    ║     ╚════════════════════════════╝/ /*   @notice Internal logic for withdrawing stakes.   @dev Mint user any outstanding float before withdrawing.   @param marketIndex Market index of token.   @param amount Amount to withdraw.   @param token Synthetic token that was staked.   /   function _withdraw(     uint32 marketIndex,     address token,     uint256 amount   ) internal virtual {     require(userAmountStaked[token][msg.sender] &gt; 0, "nothing to withdraw");     _mintAccumulatedFloat(marketIndex, msg.sender); userAmountStaked[token][msg.sender] = userAmountStaked[token][msg.sender] - amount;  uint256 amountFees = (amount * marketUnstakeFee_e18[marketIndex]) / 1e18;  IERC20(token).transfer(floatTreasury, amountFees); IERC20(token).transfer(msg.sender, amount - amountFees);  emit StakeWithdrawn(msg.sender, token, amount);  } /*   @notice Withdraw function. Allows users to unstake.   @param amount Amount to withdraw.   @param token Address of the token for which to withdraw.   /   function withdraw(address token, uint256 amount) external {     ILongShort(longShort).updateSystemState(marketIndexOfToken[token]); uint32 marketIndex = marketIndexOfToken[token];  _withdraw(marketIndex, token, amount);  if (userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] &gt; 0) {   // If they still have outstanding shifts after minting float, then check   // that they don't withdraw more than their shifts allow.   uint256 amountToShiftForThisToken = syntheticTokens[marketIndex][true] == token     ? userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][msg.sender]     : userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][msg.sender];    require(     userAmountStaked[token][msg.sender] &gt;= amountToShiftForThisToken,     "Outstanding next price stake shifts too great"   ); }  } /*   @notice Allows users to withdraw their entire stake for a token.   @param token Address of the token for which to withdraw.   /   function withdrawAll(address token) external {     ILongShort(longShort).updateSystemState(marketIndexOfToken[token]); uint32 marketIndex = marketIndexOfToken[token];  uint256 amountToShiftForThisToken = syntheticTokens[marketIndex][true] == token   ? userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][msg.sender]   : userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][msg.sender];  _withdraw(marketIndex, token, userAmountStaked[token][msg.sender] - amountToShiftForThisToken);  } } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-17-08 08:01:57 INFO] Security Analyst: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: BUSL-1.1

pragma solidity 0.8.3;

import "@openzeppelin/contracts-upgradeable/token/ERC20/presets/ERC20PresetMinterPauserUpgradeable.sol";

import "./interfaces/IFloatToken.sol";
import "./interfaces/ILongShort.sol";
import "./interfaces/IStaker.sol";
import "./interfaces/ISyntheticToken.sol";

contract Staker is IStaker, Initializable {
  /*╔═════════════════════════════╗
    ║          VARIABLES          ║
    ╚═════════════════════════════╝*/

  /* ══════ Fixed-precision constants ══════ */
  uint256 public constant FLOAT_ISSUANCE_FIXED_DECIMAL = 1e42;
  // 2^52 ~= 4.5e15
  // With an exponent of 5, the largest total liquidity possible in a market (to avoid integer overflow on exponentiation) is ~10^31 or 10 Trillion (10^13)
  // NOTE: this also means if the total market value is less than 2^52 there will be a division by zero error
  uint256 public constant safeExponentBitShifting = 52;

  /* ══════ Global state ══════ */
  address public admin;
  address public floatCapital;
  address public floatTreasury;
  uint256 public floatPercentage;

  address public longShort;
  address public floatToken;

  /* ══════ Market specific ══════ */
  mapping(uint32 => uint256) public marketLaunchIncentive_period; // seconds
  mapping(uint32 => uint256) public marketLaunchIncentive_multipliers; // e18 scale
  mapping(uint32 => uint256) public marketUnstakeFee_e18;
  mapping(uint32 => uint256) public balanceIncentiveCurve_exponent;
  mapping(uint32 => int256) public balanceIncentiveCurve_equilibriumOffset;

  mapping(uint32 => mapping(bool => address)) public syntheticTokens;

  mapping(address => uint32) public marketIndexOfToken;

  /* ══════ Reward specific ══════ */
  mapping(uint32 => uint256) public latestRewardIndex;
  mapping(uint32 => mapping(uint256 => AccumulativeIssuancePerStakedSynthSnapshot))
    public accumulativeFloatPerSyntheticTokenSnapshots;
  struct AccumulativeIssuancePerStakedSynthSnapshot {
    uint256 timestamp;
    uint256 accumulativeFloatPerSyntheticToken_long;
    uint256 accumulativeFloatPerSyntheticToken_short;
  }

  /* ══════ User specific ══════ */
  mapping(uint32 => mapping(address => uint256)) public userIndexOfLastClaimedReward;
  mapping(address => mapping(address => uint256)) public userAmountStaked;

  /* ══════ Token shift management specific ══════ */
  mapping(uint32 => uint256) public batched_stakerNextTokenShiftIndex;
  /**
  @notice Used to link a token shift to a staker state
  @dev tokenShiftIndex => accumulativeFloatIssuanceSnapshotIndex
    POSSIBLE OPTIMIZATION - could pack stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping and stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping into a struct of two uint128 for storage space optimization.
  */
  mapping(uint256 => uint256) public stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping;
  /// @notice Used to fetch the price from LongShort at that point in time
  /// @dev tokenShiftIndex => longShortMarketPriceSnapshotIndex
  mapping(uint256 => uint256) public stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping;
  /// @dev marketIndex => usersAddress => stakerTokenShiftIndex
  mapping(uint32 => mapping(address => uint256)) public userNextPrice_stakedSyntheticTokenShiftIndex;
  /// @dev marketIndex => usersAddress => amountUserRequestedToShiftAwayFromLongOnNextUpdate
  mapping(uint32 => mapping(address => uint256)) public userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long;
  /// @dev marketIndex => usersAddress => amountUserRequestedToShiftAwayFromShortOnNextUpdate
  mapping(uint32 => mapping(address => uint256)) public userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short;

  /*╔════════════════════════════╗
    ║           EVENTS           ║
    ╚════════════════════════════╝*/

  event StakerV1(
    address admin,
    address floatTreasury,
    address floatCapital,
    address floatToken,
    uint256 floatPercentage
  );

  event MarketAddedToStaker(
    uint32 marketIndex,
    uint256 exitFee_e18,
    uint256 period,
    uint256 multiplier,
    uint256 balanceIncentiveExponent,
    int256 balanceIncentiveEquilibriumOffset
  );

  event AccumulativeIssuancePerStakedSynthSnapshotCreated(
    uint32 marketIndex,
    uint256 accumulativeFloatIssuanceSnapshotIndex,
    uint256 accumulativeLong,
    uint256 accumulativeShort
  );

  event StakeAdded(address user, address token, uint256 amount, uint256 lastMintIndex);

  event StakeWithdrawn(address user, address token, uint256 amount);

  // Note: the `amountFloatMinted` isn't strictly needed by the graph, but it is good to add it to validate calculations are accurate.
  event FloatMinted(address user, uint32 marketIndex, uint256 amountFloatMinted);

  event MarketLaunchIncentiveParametersChanges(uint32 marketIndex, uint256 period, uint256 multiplier);

  event StakeWithdrawalFeeUpdated(uint32 marketIndex, uint256 stakeWithdralFee);

  event BalanceIncentiveExponentUpdated(uint32 marketIndex, uint256 balanceIncentiveExponent);

  event BalanceIncentiveEquilibriumOffsetUpdated(uint32 marketIndex, int256 balanceIncentiveEquilibriumOffset);

  event FloatPercentageUpdated(uint256 floatPercentage);

  event SyntheticTokensShifted();

  event ChangeAdmin(address newAdmin);

  /*╔═════════════════════════════╗
    ║          MODIFIERS          ║
    ╚═════════════════════════════╝*/

  function onlyAdminModifierLogic() internal virtual {
    require(msg.sender == admin, "not admin");
  }

  modifier onlyAdmin() {
    onlyAdminModifierLogic();
    _;
  }

  function onlyValidSyntheticModifierLogic(address _synth) internal virtual {
    require(marketIndexOfToken[_synth] != 0, "not valid synth");
  }

  modifier onlyValidSynthetic(address _synth) {
    onlyValidSyntheticModifierLogic(_synth);
    _;
  }

  function onlyValidMarketModifierLogic(uint32 marketIndex) internal virtual {
    require(address(syntheticTokens[marketIndex][true]) != address(0), "not valid market");
  }

  modifier onlyValidMarket(uint32 marketIndex) {
    onlyValidMarketModifierLogic(marketIndex);
    _;
  }

  function onlyLongShortModifierLogic() internal virtual {
    require(msg.sender == address(longShort), "not long short");
  }

  modifier onlyLongShort() {
    onlyLongShortModifierLogic();
    _;
  }

  /*╔═════════════════════════════╗
    ║       CONTRACT SET-UP       ║
    ╚═════════════════════════════╝*/

  /**
  @notice Initializes the contract.
  @dev Calls OpenZeppelin's initializer modifier.
  @param _admin Address of the admin role.
  @param _longShort Address of the LongShort contract, a deployed LongShort.sol
  @param _floatToken Address of the Float token earned by staking.
  @param _floatTreasury Address of the treasury contract for managing fees.
  @param _floatCapital Address of the contract which earns a fixed percentage of Float.
  @param _floatPercentage Determines the float percentage that gets minted for Float Capital, base 1e18.
  */
  function initialize(
    address _admin,
    address _longShort,
    address _floatToken,
    address _floatTreasury,
    address _floatCapital,
    uint256 _floatPercentage
  ) external virtual initializer {
    admin = _admin;
    floatCapital = _floatCapital;
    floatTreasury = _floatTreasury;
    longShort = _longShort;
    floatToken = _floatToken;

    _changeFloatPercentage(_floatPercentage);

    emit StakerV1(_admin, _floatTreasury, _floatCapital, _floatToken, _floatPercentage);
  }

  /*╔═══════════════════╗
    ║       ADMIN       ║
    ╚═══════════════════╝*/

  /** 
  @notice Changes admin for the contract
  @param _admin The address of the new admin.
  */
  function changeAdmin(address _admin) external onlyAdmin {
    admin = _admin;
    emit ChangeAdmin(_admin);
  }

  /// @dev Logic for changeFloatPercentage
  function _changeFloatPercentage(uint256 newFloatPercentage) internal virtual {
    require(newFloatPercentage <= 1e18 && newFloatPercentage > 0); // less than or equal to 100% and greater than 0%
    floatPercentage = newFloatPercentage;
  }

  /**
  @notice Changes percentage of float that is minted for float capital.
  @param newFloatPercentage The new float percentage in base 1e18.
  */
  function changeFloatPercentage(uint256 newFloatPercentage) external onlyAdmin {
    _changeFloatPercentage(newFloatPercentage);
    emit FloatPercentageUpdated(newFloatPercentage);
  }

  /// @dev Logic for changeUnstakeFee
  function _changeUnstakeFee(uint32 marketIndex, uint256 newMarketUnstakeFee_e18) internal virtual {
    require(newMarketUnstakeFee_e18 <= 5e16); // Explicitely stating 5% fee as the max fee possible.
    marketUnstakeFee_e18[marketIndex] = newMarketUnstakeFee_e18;
  }

  /**
  @notice Changes unstake fee for a market
  @param marketIndex Identifies the market.
  @param newMarketUnstakeFee_e18 The new unstake fee.
  */
  function changeUnstakeFee(uint32 marketIndex, uint256 newMarketUnstakeFee_e18) external onlyAdmin {
    _changeUnstakeFee(marketIndex, newMarketUnstakeFee_e18);
    emit StakeWithdrawalFeeUpdated(marketIndex, newMarketUnstakeFee_e18);
  }

  /// @dev Logic for changeMarketLaunchIncentiveParameters
  function _changeMarketLaunchIncentiveParameters(
    uint32 marketIndex,
    uint256 period,
    uint256 initialMultiplier
  ) internal virtual {
    require(initialMultiplier >= 1e18, "marketLaunchIncentiveMultiplier must be >= 1e18");

    marketLaunchIncentive_period[marketIndex] = period;
    marketLaunchIncentive_multipliers[marketIndex] = initialMultiplier;
  }

  /**
  @notice Changes the market launch incentive parameters for a market
  @param marketIndex Identifies the market.
  @param period The new period for which float token generation should be boosted.
  @param initialMultiplier The new multiplier on Float generation.
  */
  function changeMarketLaunchIncentiveParameters(
    uint32 marketIndex,
    uint256 period,
    uint256 initialMultiplier
  ) external onlyAdmin {
    _changeMarketLaunchIncentiveParameters(marketIndex, period, initialMultiplier);

    emit MarketLaunchIncentiveParametersChanges(marketIndex, period, initialMultiplier);
  }

  /// @dev Logic for changeBalanceIncentiveExponent
  function _changeBalanceIncentiveExponent(uint32 marketIndex, uint256 _balanceIncentiveCurve_exponent)
    internal
    virtual
  {
    require(
      // The exponent has to be less than 5 in these versions of the contracts.
      _balanceIncentiveCurve_exponent > 0 && _balanceIncentiveCurve_exponent < 6,
      "balanceIncentiveCurve_exponent out of bounds"
    );

    balanceIncentiveCurve_exponent[marketIndex] = _balanceIncentiveCurve_exponent;
  }

  /** 
  @notice Changes the balance incentive exponent for a market
  @param marketIndex Identifies the market.
  @param _balanceIncentiveCurve_exponent The new exponent for the curve.
  */
  function changeBalanceIncentiveExponent(uint32 marketIndex, uint256 _balanceIncentiveCurve_exponent)
    external
    onlyAdmin
  {
    _changeBalanceIncentiveExponent(marketIndex, _balanceIncentiveCurve_exponent);

    emit BalanceIncentiveExponentUpdated(marketIndex, _balanceIncentiveCurve_exponent);
  }

  /// @dev Logic for changeBalanceIncentiveEquilibriumOffset
  function _changeBalanceIncentiveEquilibriumOffset(uint32 marketIndex, int256 _balanceIncentiveCurve_equilibriumOffset)
    internal
    virtual
  {
    // Unreasonable that we would ever shift this more than 90% either way
    require(
      _balanceIncentiveCurve_equilibriumOffset > -9e17 && _balanceIncentiveCurve_equilibriumOffset < 9e17,
      "balanceIncentiveCurve_equilibriumOffset out of bounds"
    );

    balanceIncentiveCurve_equilibriumOffset[marketIndex] = _balanceIncentiveCurve_equilibriumOffset;
  }

  /**
  @notice Changes the balance incentive curve equilibrium offset for a market
  @param marketIndex Identifies the market.
  @param _balanceIncentiveCurve_equilibriumOffset The new offset.
  */
  function changeBalanceIncentiveEquilibriumOffset(uint32 marketIndex, int256 _balanceIncentiveCurve_equilibriumOffset)
    external
    onlyAdmin
  {
    _changeBalanceIncentiveEquilibriumOffset(marketIndex, _balanceIncentiveCurve_equilibriumOffset);

    emit BalanceIncentiveEquilibriumOffsetUpdated(marketIndex, _balanceIncentiveCurve_equilibriumOffset);
  }

  /*╔═════════════════════════════╗
    ║        STAKING SETUP        ║
    ╚═════════════════════════════╝*/

  /**
  @notice Sets this contract to track staking for a market in LongShort.sol
  @param marketIndex Identifies the market.
  @param longToken Address of the long token for the market.
  @param shortToken Address of the short token for the market.
  @param kInitialMultiplier Initial boost on float generation for the market.
  @param kPeriod Period which the boost should last.
  @param unstakeFee_e18 Percentage of tokens that are levied on unstaking in base 1e18.
  @param _balanceIncentiveCurve_exponent Exponent for balance curve (see _calculateFloatPerSecond)
  @param _balanceIncentiveCurve_equilibriumOffset Offset for balance curve (see _calculateFloatPerSecond)
  */
  function addNewStakingFund(
    uint32 marketIndex,
    address longToken,
    address shortToken,
    uint256 kInitialMultiplier,
    uint256 kPeriod,
    uint256 unstakeFee_e18,
    uint256 _balanceIncentiveCurve_exponent,
    int256 _balanceIncentiveCurve_equilibriumOffset
  ) external override onlyLongShort {
    marketIndexOfToken[longToken] = marketIndex;
    marketIndexOfToken[shortToken] = marketIndex;

    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].timestamp = block.timestamp;
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].accumulativeFloatPerSyntheticToken_long = 0;
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].accumulativeFloatPerSyntheticToken_short = 0;

    syntheticTokens[marketIndex][true] = longToken;
    syntheticTokens[marketIndex][false] = shortToken;

    _changeBalanceIncentiveExponent(marketIndex, _balanceIncentiveCurve_exponent);
    _changeBalanceIncentiveEquilibriumOffset(marketIndex, _balanceIncentiveCurve_equilibriumOffset);
    _changeMarketLaunchIncentiveParameters(marketIndex, kPeriod, kInitialMultiplier);

    _changeUnstakeFee(marketIndex, unstakeFee_e18);

    // Set this value to one initially - 0 is a null value and thus potentially bug prone.
    batched_stakerNextTokenShiftIndex[marketIndex] = 1;

    emit MarketAddedToStaker(
      marketIndex,
      unstakeFee_e18,
      kPeriod,
      kInitialMultiplier,
      _balanceIncentiveCurve_exponent,
      _balanceIncentiveCurve_equilibriumOffset
    );

    emit AccumulativeIssuancePerStakedSynthSnapshotCreated(marketIndex, 0, 0, 0);
  }

  /*╔═════════════════════════════════════════════════════════════════════════╗
    ║    GLOBAL FLT REWARD ACCUMULATION CALCULATION AND TRACKING FUNCTIONS    ║
    ╚═════════════════════════════════════════════════════════════════════════╝*/

  /**
  @notice Returns the K factor parameters for the given market with sensible
  defaults if they haven't been set yet.
  @param marketIndex The market to change the parameters for.
  @return period The period for which the k factor applies for in seconds.
  @return multiplier The multiplier on Float generation in this period.
  */
  function _getMarketLaunchIncentiveParameters(uint32 marketIndex)
    internal
    view
    virtual
    returns (uint256 period, uint256 multiplier)
  {
    period = marketLaunchIncentive_period[marketIndex];
    multiplier = marketLaunchIncentive_multipliers[marketIndex];

    if (multiplier < 1e18) {
      multiplier = 1e18; // multiplier of 1 by default
    }
  }

  /** 
  @notice Returns the extent to which a markets float generation should be adjusted
  based on the market's launch incentive parameters. Should start at multiplier
  then linearly change to 1e18 over time.
  @param marketIndex Identifies the market.
  @return k The calculated modifier for float generation.
  */
  function _getKValue(uint32 marketIndex) internal view virtual returns (uint256) {
    // Parameters controlling the float issuance multiplier.
    (uint256 kPeriod, uint256 kInitialMultiplier) = _getMarketLaunchIncentiveParameters(marketIndex);

    // Sanity check - under normal circumstances, the multipliers should
    // *never* be set to a value < 1e18, as there are guards against this.
    assert(kInitialMultiplier >= 1e18);

    uint256 initialTimestamp = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].timestamp;

    if (block.timestamp - initialTimestamp <= kPeriod) {
      return kInitialMultiplier - (((kInitialMultiplier - 1e18) * (block.timestamp - initialTimestamp)) / kPeriod);
    } else {
      return 1e18;
    }
  }

  /*
  @notice Computes the number of float tokens a user earns per second for
  every long/short synthetic token they've staked. The returned value has
  a fixed decimal scale of 1e42 (!!!) for numerical stability. The return
  values are float per second per synthetic token (hence the requirement
  to multiply by price)
  @dev to see below math in latex form see TODO add link
  to interact with the equations see https://www.desmos.com/calculator/optkaxyihr
  @param marketIndex The market referred to.
  @param longPrice Price of the synthetic long token in units of payment token
  @param shortPrice Price of the synthetic short token in units of payment token
  @param longValue Amount of payment token in the long side of the market
  @param shortValue Amount of payment token in the short side of the market
  @return longFloatPerSecond Float token per second per long synthetic token
  @return shortFloatPerSecond Float token per second per short synthetic token
   */
  function _calculateFloatPerSecond(
    uint32 marketIndex,
    uint256 longPrice,
    uint256 shortPrice,
    uint256 longValue,
    uint256 shortValue
  ) internal view virtual returns (uint256 longFloatPerSecond, uint256 shortFloatPerSecond) {
    // A float issuance multiplier that starts high and decreases linearly
    // over time to a value of 1. This incentivises users to stake early.
    uint256 k = _getKValue(marketIndex);

    uint256 totalLocked = (longValue + shortValue);

    // we need to scale this number by the totalLocked so that the offset remains consistent accross market size

    int256 equilibriumOffsetMarketScaled = (balanceIncentiveCurve_equilibriumOffset[marketIndex] *
      int256(totalLocked)) / 2e18;

    uint256 denominator = ((totalLocked >> safeExponentBitShifting)**balanceIncentiveCurve_exponent[marketIndex]);

    // Float is scaled by the percentage of the total market value held in
    // the opposite position. This incentivises users to stake on the
    // weaker position.
    if (int256(shortValue) - equilibriumOffsetMarketScaled < int256(longValue)) {
      if (equilibriumOffsetMarketScaled >= int256(shortValue)) {
        // edge case: imbalanced far past the equilibrium offset - full rewards go to short token
        //            extremeley unlikely to happen in practice
        return (0, 1e18 * k * shortPrice);
      }

      uint256 numerator = (uint256(int256(shortValue) - equilibriumOffsetMarketScaled) >>
        (safeExponentBitShifting - 1))**balanceIncentiveCurve_exponent[marketIndex];

      // NOTE: `x * 5e17` == `(x * 10e18) / 2`
      uint256 longRewardUnscaled = (numerator * 5e17) / denominator;
      uint256 shortRewardUnscaled = 1e18 - longRewardUnscaled;

      return ((longRewardUnscaled * k * longPrice) / 1e18, (shortRewardUnscaled * k * shortPrice) / 1e18);
    } else {
      if (-equilibriumOffsetMarketScaled >= int256(longValue)) {
        // edge case: imbalanced far past the equilibrium offset - full rewards go to long token
        //            extremeley unlikely to happen in practice
        return (1e18 * k * longPrice, 0);
      }

      uint256 numerator = (uint256(int256(longValue) + equilibriumOffsetMarketScaled) >>
        (safeExponentBitShifting - 1))**balanceIncentiveCurve_exponent[marketIndex];

      // NOTE: `x * 5e17` == `(x * 10e18) / 2`
      uint256 shortRewardUnscaled = (numerator * 5e17) / denominator;
      uint256 longRewardUnscaled = 1e18 - shortRewardUnscaled;

      return ((longRewardUnscaled * k * longPrice) / 1e18, (shortRewardUnscaled * k * shortPrice) / 1e18);
    }
  }

  /**
  @notice Computes the time since last accumulativeIssuancePerStakedSynthSnapshot for the given market in seconds.
  @param marketIndex The market referred to.
  @return The time difference in seconds
  */
  function _calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(uint32 marketIndex)
    internal
    view
    virtual
    returns (uint256)
  {
    return
      block.timestamp -
      accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]].timestamp;
  }

  /**
  @notice Computes new cumulative sum of 'r' value since last accumulativeIssuancePerStakedSynthSnapshot. We use
  cumulative 'r' value to avoid looping during issuance. Note that the
  cumulative sum is kept in 1e42 scale (!!!) to avoid numerical issues.
  @param shortValue The value locked in the short side of the market.
  @param longValue The value locked in the long side of the market.
  @param shortPrice The price of the short token as defined in LongShort.sol
  @param longPrice The price of the long token as defined in LongShort.sol
  @param marketIndex An identifier for the market.
  @return longCumulativeRates The long cumulative sum.
  @return shortCumulativeRates The short cumulative sum.
  */
  function _calculateNewCumulativeIssuancePerStakedSynth(
    uint32 marketIndex,
    uint256 longPrice,
    uint256 shortPrice,
    uint256 longValue,
    uint256 shortValue
  ) internal view virtual returns (uint256 longCumulativeRates, uint256 shortCumulativeRates) {
    // Compute the current 'r' value for float issuance per second.
    (uint256 longFloatPerSecond, uint256 shortFloatPerSecond) = _calculateFloatPerSecond(
      marketIndex,
      longPrice,
      shortPrice,
      longValue,
      shortValue
    );

    // Compute time since last accumulativeIssuancePerStakedSynthSnapshot for the given token.
    uint256 timeDelta = _calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(marketIndex);

    // Compute new cumulative 'r' value total.
    return (
      accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]]
      .accumulativeFloatPerSyntheticToken_long + (timeDelta * longFloatPerSecond),
      accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]]
      .accumulativeFloatPerSyntheticToken_short + (timeDelta * shortFloatPerSecond)
    );
  }

  /**
  @notice Creates a new accumulativeIssuancePerStakedSynthSnapshot for the given token and updates indexes.
  @param shortValue The value locked in the short side of the market.
  @param longValue The value locked in the long side of the market.
  @param shortPrice The price of the short token as defined in LongShort.sol
  @param longPrice The price of the long token as defined in LongShort.sol
  @param marketIndex An identifier for the market.
  */
  function _setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot(
    uint32 marketIndex,
    uint256 longPrice,
    uint256 shortPrice,
    uint256 longValue,
    uint256 shortValue
  ) internal virtual {
    (
      uint256 newLongAccumulativeValue,
      uint256 newShortAccumulativeValue
    ) = _calculateNewCumulativeIssuancePerStakedSynth(marketIndex, longPrice, shortPrice, longValue, shortValue);

    uint256 newIndex = latestRewardIndex[marketIndex] + 1;

    // Set cumulative 'r' value on new accumulativeIssuancePerStakedSynthSnapshot.
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex]
    .accumulativeFloatPerSyntheticToken_long = newLongAccumulativeValue;
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex]
    .accumulativeFloatPerSyntheticToken_short = newShortAccumulativeValue;

    // Set timestamp on new accumulativeIssuancePerStakedSynthSnapshot.
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex].timestamp = block.timestamp;

    // Update latest index to point to new accumulativeIssuancePerStakedSynthSnapshot.
    latestRewardIndex[marketIndex] = newIndex;

    emit AccumulativeIssuancePerStakedSynthSnapshotCreated(
      marketIndex,
      newIndex,
      newLongAccumulativeValue,
      newShortAccumulativeValue
    );
  }

  /**
  @notice Adds new accumulativeIssuancePerStakedSynthSnapshots for the given long/short tokens. Called by the
  ILongShort contract whenever there is a state change for a market.
  @param stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted Mapping from this contract's shifts to LongShort.sols next price snapshots.
  @param shortValue The value locked in the short side of the market.
  @param longValue The value locked in the long side of the market.
  @param shortPrice The price of the short token as defined in LongShort.sol
  @param longPrice The price of the long token as defined in LongShort.sol
  @param marketIndex An identifier for the market.
  */
  function pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(
    uint32 marketIndex,
    uint256 longPrice,
    uint256 shortPrice,
    uint256 longValue,
    uint256 shortValue,
    uint256 stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted // This value should be ALWAYS be zero if no shift occured
  ) external override onlyLongShort {
    // Only add a new accumulativeIssuancePerStakedSynthSnapshot if some time has passed.

    // the `stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted` value will be 0 if there is no staker related action in an executed batch
    if (stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted > 0) {
      stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[
        batched_stakerNextTokenShiftIndex[marketIndex]
      ] = stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted;
      stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[
        batched_stakerNextTokenShiftIndex[marketIndex]
      ] = latestRewardIndex[marketIndex] + 1;
      batched_stakerNextTokenShiftIndex[marketIndex] += 1;

      emit SyntheticTokensShifted();
    }

    // Time delta is fetched twice in below code, can pass through? Which is less gas?
    if (_calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(marketIndex) > 0) {
      _setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot(
        marketIndex,
        longPrice,
        shortPrice,
        longValue,
        shortValue
      );
    }
  }

  /*╔═══════════════════════════════════╗
    ║    USER REWARD STATE FUNCTIONS    ║
    ╚═══════════════════════════════════╝*/

  /// @dev Calculates the accumulated float in a specific range of staker snapshots
  function _calculateAccumulatedFloatInRange(
    uint32 marketIndex,
    uint256 amountStakedLong,
    uint256 amountStakedShort,
    uint256 rewardIndexFrom,
    uint256 rewardIndexTo
  ) internal view virtual returns (uint256 floatReward) {
    if (amountStakedLong > 0) {
      uint256 accumDeltaLong = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexTo]
      .accumulativeFloatPerSyntheticToken_long -
        accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexFrom]
        .accumulativeFloatPerSyntheticToken_long;
      floatReward += (accumDeltaLong * amountStakedLong) / FLOAT_ISSUANCE_FIXED_DECIMAL;
    }

    if (amountStakedShort > 0) {
      uint256 accumDeltaShort = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexTo]
      .accumulativeFloatPerSyntheticToken_short -
        accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexFrom]
        .accumulativeFloatPerSyntheticToken_short;
      floatReward += (accumDeltaShort * amountStakedShort) / FLOAT_ISSUANCE_FIXED_DECIMAL;
    }
  }

  /** 
  @notice Calculates float owed to the user since the user last minted float for a market.
  @param marketIndex Identifier for the market which the user staked in.
  @param user The address of the user.
  @return floatReward The amount of float owed.
   */
  function _calculateAccumulatedFloat(uint32 marketIndex, address user) internal virtual returns (uint256 floatReward) {
    address longToken = syntheticTokens[marketIndex][true];
    address shortToken = syntheticTokens[marketIndex][false];

    uint256 amountStakedLong = userAmountStaked[longToken][user];
    uint256 amountStakedShort = userAmountStaked[shortToken][user];

    uint256 usersLastRewardIndex = userIndexOfLastClaimedReward[marketIndex][user];

    // Don't do the calculation and return zero immediately if there is no change
    if (usersLastRewardIndex == latestRewardIndex[marketIndex]) {
      return 0;
    }

    uint256 usersShiftIndex = userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][user];
    // if there is a change in the users tokens held due to a token shift (or possibly another action in the future)
    if (usersShiftIndex > 0 && usersShiftIndex < batched_stakerNextTokenShiftIndex[marketIndex]) {
      floatReward = _calculateAccumulatedFloatInRange(
        marketIndex,
        amountStakedLong,
        amountStakedShort,
        usersLastRewardIndex,
        stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[usersShiftIndex]
      );

      // Update the users balances
      if (userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user] > 0) {
        amountStakedShort += ILongShort(longShort).getAmountSyntheticTokenToMintOnTargetSide(
          marketIndex,
          userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user],
          true,
          stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[usersShiftIndex]
        );

        amountStakedLong -= userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user];
        userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user] = 0;
      }

      if (userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user] > 0) {
        amountStakedLong += ILongShort(longShort).getAmountSyntheticTokenToMintOnTargetSide(
          marketIndex,
          userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user],
          false,
          stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[usersShiftIndex]
        );

        amountStakedShort -= userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user];
        userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user] = 0;
      }

      // Save the users updated staked amounts
      userAmountStaked[longToken][user] = amountStakedLong;
      userAmountStaked[shortToken][user] = amountStakedShort;

      floatReward += _calculateAccumulatedFloatInRange(
        marketIndex,
        amountStakedLong,
        amountStakedShort,
        stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[usersShiftIndex],
        latestRewardIndex[marketIndex]
      );

      userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][user] = 0;
    } else {
      floatReward = _calculateAccumulatedFloatInRange(
        marketIndex,
        amountStakedLong,
        amountStakedShort,
        usersLastRewardIndex,
        latestRewardIndex[marketIndex]
      );
    }
  }

  /**
  @notice Mints float for a user.
  @dev Mints a fixed percentage for Float capital.
  @param user The address of the user.
  @param floatToMint The amount of float to mint.
   */
  function _mintFloat(address user, uint256 floatToMint) internal virtual {
    IFloatToken(floatToken).mint(user, floatToMint);
    IFloatToken(floatToken).mint(floatCapital, (floatToMint * floatPercentage) / 1e18);
  }

  /**
  @notice Mints float owed to a user for a market since they last minted.
  @param marketIndex An identifier for the market.
  @param user The address of the user.
   */
  function _mintAccumulatedFloat(uint32 marketIndex, address user) internal virtual {
    uint256 floatToMint = _calculateAccumulatedFloat(marketIndex, user);

    if (floatToMint > 0) {
      // Set the user has claimed up until now, stops them setting this forward
      userIndexOfLastClaimedReward[marketIndex][user] = latestRewardIndex[marketIndex];

      _mintFloat(user, floatToMint);
      emit FloatMinted(user, marketIndex, floatToMint);
    }
  }

  /**
  @notice Mints float owed to a user for multiple markets, since they last minted for those markets.
  @param marketIndexes Identifiers for the markets.
  @param user The address of the user.
   */
  function _mintAccumulatedFloatMulti(uint32[] calldata marketIndexes, address user) internal virtual {
    uint256 floatTotal = 0;
    for (uint256 i = 0; i < marketIndexes.length; i++) {
      uint256 floatToMint = _calculateAccumulatedFloat(marketIndexes[i], user);

      if (floatToMint > 0) {
        // Set the user has claimed up until now, stops them setting this forward
        userIndexOfLastClaimedReward[marketIndexes[i]][user] = latestRewardIndex[marketIndexes[i]];

        floatTotal += floatToMint;

        emit FloatMinted(user, marketIndexes[i], floatToMint);
      }
    }
    if (floatTotal > 0) {
      _mintFloat(user, floatTotal);
    }
  }

  /**
  @notice Mints outstanding float for msg.sender.
  @param marketIndexes Identifiers for the markets for which to mint float.
   */
  function claimFloatCustom(uint32[] calldata marketIndexes) external {
    ILongShort(longShort).updateSystemStateMulti(marketIndexes);
    _mintAccumulatedFloatMulti(marketIndexes, msg.sender);
  }

  /**
  @notice Mints outstanding float on behalf of another user.
  @param marketIndexes Identifiers for the markets for which to mint float.
  @param user The address of the user.
   */
  function claimFloatCustomFor(uint32[] calldata marketIndexes, address user) external {
    // Unbounded loop - users are responsible for paying their own gas costs on these and it doesn't effect the rest of the system.
    // No need to impose limit.
    ILongShort(longShort).updateSystemStateMulti(marketIndexes);
    _mintAccumulatedFloatMulti(marketIndexes, user);
  }

  /*╔═══════════════════════╗
    ║        STAKING        ║
    ╚═══════════════════════╝*/

  /**
  @notice A user with synthetic tokens stakes by calling stake on the token
  contract which calls this function. We need to first update the
  state of the LongShort contract for this market before staking to correctly calculate user rewards.
  @param amount Amount to stake.
  @param from Address to stake for.
  */
  function stakeFromUser(address from, uint256 amount) public virtual override onlyValidSynthetic((msg.sender)) {
    ILongShort(longShort).updateSystemState(marketIndexOfToken[(msg.sender)]);
    _stake((msg.sender), amount, from);
  }

  /**
  @dev Internal logic for staking.
  @param token Address of the token for which to stake.
  @param amount Amount to stake.
  @param user Address to stake for.
  */
  function _stake(
    address token,
    uint256 amount,
    address user
  ) internal virtual {
    uint32 marketIndex = marketIndexOfToken[token];

    // If they already have staked and have rewards due, mint these.
    if (
      userIndexOfLastClaimedReward[marketIndex][user] != 0 &&
      userIndexOfLastClaimedReward[marketIndex][user] < latestRewardIndex[marketIndex]
    ) {
      _mintAccumulatedFloat(marketIndex, user);
    }

    userAmountStaked[token][user] = userAmountStaked[token][user] + amount;

    userIndexOfLastClaimedReward[marketIndex][user] = latestRewardIndex[marketIndex];

    emit StakeAdded(user, address(token), amount, userIndexOfLastClaimedReward[marketIndex][user]);
  }

  /**
  @notice Allows users to shift their staked tokens from one side of the market to 
  the other at the next price.
  @param amountSyntheticTokensToShift Amount of tokens to shift.
  @param marketIndex Identifier for the market.
  @param isShiftFromLong Whether the shift is from long to short or short to long.
  */
  function shiftTokens(
    uint256 amountSyntheticTokensToShift,
    uint32 marketIndex,
    bool isShiftFromLong
  ) external virtual {
    address token = syntheticTokens[marketIndex][isShiftFromLong];
    require(userAmountStaked[token][msg.sender] >= amountSyntheticTokensToShift, "Not enough tokens to shift");

    // If the user has outstanding token shift that have already been confirmed in the LongShort
    // contract, execute them first.
    if (
      userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] != 0 &&
      userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] <
      batched_stakerNextTokenShiftIndex[marketIndex]
    ) {
      _mintAccumulatedFloat(marketIndex, msg.sender);
    }

    if (isShiftFromLong) {
      ILongShort(longShort).shiftPositionFromLongNextPrice(marketIndex, amountSyntheticTokensToShift);
      userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][
        msg.sender
      ] += amountSyntheticTokensToShift;
    } else {
      ILongShort(longShort).shiftPositionFromShortNextPrice(marketIndex, amountSyntheticTokensToShift);
      userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][
        msg.sender
      ] += amountSyntheticTokensToShift;
    }

    userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] = batched_stakerNextTokenShiftIndex[
      marketIndex
    ];
  }

  /*╔════════════════════════════╗
    ║    WITHDRAWAL & MINTING    ║
    ╚════════════════════════════╝*/

  /**
  @notice Internal logic for withdrawing stakes.
  @dev Mint user any outstanding float before withdrawing.
  @param marketIndex Market index of token.
  @param amount Amount to withdraw.
  @param token Synthetic token that was staked.
  */
  function _withdraw(
    uint32 marketIndex,
    address token,
    uint256 amount
  ) internal virtual {
    require(userAmountStaked[token][msg.sender] > 0, "nothing to withdraw");
    _mintAccumulatedFloat(marketIndex, msg.sender);

    userAmountStaked[token][msg.sender] = userAmountStaked[token][msg.sender] - amount;

    uint256 amountFees = (amount * marketUnstakeFee_e18[marketIndex]) / 1e18;

    IERC20(token).transfer(floatTreasury, amountFees);
    IERC20(token).transfer(msg.sender, amount - amountFees);

    emit StakeWithdrawn(msg.sender, token, amount);
  }

  /**
  @notice Withdraw function. Allows users to unstake.
  @param amount Amount to withdraw.
  @param token Address of the token for which to withdraw.
  */
  function withdraw(address token, uint256 amount) external {
    ILongShort(longShort).updateSystemState(marketIndexOfToken[token]);

    uint32 marketIndex = marketIndexOfToken[token];

    _withdraw(marketIndex, token, amount);

    if (userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] > 0) {
      // If they still have outstanding shifts after minting float, then check
      // that they don't withdraw more than their shifts allow.
      uint256 amountToShiftForThisToken = syntheticTokens[marketIndex][true] == token
        ? userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][msg.sender]
        : userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][msg.sender];

      require(
        userAmountStaked[token][msg.sender] >= amountToShiftForThisToken,
        "Outstanding next price stake shifts too great"
      );
    }
  }

  /**
  @notice Allows users to withdraw their entire stake for a token.
  @param token Address of the token for which to withdraw.
  */
  function withdrawAll(address token) external {
    ILongShort(longShort).updateSystemState(marketIndexOfToken[token]);

    uint32 marketIndex = marketIndexOfToken[token];

    uint256 amountToShiftForThisToken = syntheticTokens[marketIndex][true] == token
      ? userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][msg.sender]
      : userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][msg.sender];

    _withdraw(marketIndex, token, userAmountStaked[token][msg.sender] - amountToShiftForThisToken);
  }
}
.]

Below are the details of our smart contract codes and their corresponding analysis reports:
Task: "".
As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report.

[2024-17-08 08:02:11 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-17-08 08:02:11 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 9868
completion_tokens: 834
total_tokens: 10702
cost: $-1.000000


[2024-17-08 08:02:11 INFO] Solidity Programming Expert: **Solidity Programming Expert<->Security Analyst on : BugsSummary, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: BUSL-1.1

pragma solidity 0.8.3;

import "@openzeppelin/contracts-upgradeable/token/ERC20/presets/ERC20PresetMinterPauserUpgradeable.sol";

import "./interfaces/IFloatToken.sol";
import "./interfaces/ILongShort.sol";
import "./interfaces/IStaker.sol";
import "./interfaces/ISyntheticToken.sol";

contract Staker is IStaker, Initializable {
  /*╔═════════════════════════════╗
    ║          VARIABLES          ║
    ╚═════════════════════════════╝*/

  /* ══════ Fixed-precision constants ══════ */
  uint256 public constant FLOAT_ISSUANCE_FIXED_DECIMAL = 1e42;
  // 2^52 ~= 4.5e15
  // With an exponent of 5, the largest total liquidity possible in a market (to avoid integer overflow on exponentiation) is ~10^31 or 10 Trillion (10^13)
  // NOTE: this also means if the total market value is less than 2^52 there will be a division by zero error
  uint256 public constant safeExponentBitShifting = 52;

  /* ══════ Global state ══════ */
  address public admin;
  address public floatCapital;
  address public floatTreasury;
  uint256 public floatPercentage;

  address public longShort;
  address public floatToken;

  /* ══════ Market specific ══════ */
  mapping(uint32 => uint256) public marketLaunchIncentive_period; // seconds
  mapping(uint32 => uint256) public marketLaunchIncentive_multipliers; // e18 scale
  mapping(uint32 => uint256) public marketUnstakeFee_e18;
  mapping(uint32 => uint256) public balanceIncentiveCurve_exponent;
  mapping(uint32 => int256) public balanceIncentiveCurve_equilibriumOffset;

  mapping(uint32 => mapping(bool => address)) public syntheticTokens;

  mapping(address => uint32) public marketIndexOfToken;

  /* ══════ Reward specific ══════ */
  mapping(uint32 => uint256) public latestRewardIndex;
  mapping(uint32 => mapping(uint256 => AccumulativeIssuancePerStakedSynthSnapshot))
    public accumulativeFloatPerSyntheticTokenSnapshots;
  struct AccumulativeIssuancePerStakedSynthSnapshot {
    uint256 timestamp;
    uint256 accumulativeFloatPerSyntheticToken_long;
    uint256 accumulativeFloatPerSyntheticToken_short;
  }

  /* ══════ User specific ══════ */
  mapping(uint32 => mapping(address => uint256)) public userIndexOfLastClaimedReward;
  mapping(address => mapping(address => uint256)) public userAmountStaked;

  /* ══════ Token shift management specific ══════ */
  mapping(uint32 => uint256) public batched_stakerNextTokenShiftIndex;
  /**
  @notice Used to link a token shift to a staker state
  @dev tokenShiftIndex => accumulativeFloatIssuanceSnapshotIndex
    POSSIBLE OPTIMIZATION - could pack stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping and stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping into a struct of two uint128 for storage space optimization.
  */
  mapping(uint256 => uint256) public stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping;
  /// @notice Used to fetch the price from LongShort at that point in time
  /// @dev tokenShiftIndex => longShortMarketPriceSnapshotIndex
  mapping(uint256 => uint256) public stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping;
  /// @dev marketIndex => usersAddress => stakerTokenShiftIndex
  mapping(uint32 => mapping(address => uint256)) public userNextPrice_stakedSyntheticTokenShiftIndex;
  /// @dev marketIndex => usersAddress => amountUserRequestedToShiftAwayFromLongOnNextUpdate
  mapping(uint32 => mapping(address => uint256)) public userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long;
  /// @dev marketIndex => usersAddress => amountUserRequestedToShiftAwayFromShortOnNextUpdate
  mapping(uint32 => mapping(address => uint256)) public userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short;

  /*╔════════════════════════════╗
    ║           EVENTS           ║
    ╚════════════════════════════╝*/

  event StakerV1(
    address admin,
    address floatTreasury,
    address floatCapital,
    address floatToken,
    uint256 floatPercentage
  );

  event MarketAddedToStaker(
    uint32 marketIndex,
    uint256 exitFee_e18,
    uint256 period,
    uint256 multiplier,
    uint256 balanceIncentiveExponent,
    int256 balanceIncentiveEquilibriumOffset
  );

  event AccumulativeIssuancePerStakedSynthSnapshotCreated(
    uint32 marketIndex,
    uint256 accumulativeFloatIssuanceSnapshotIndex,
    uint256 accumulativeLong,
    uint256 accumulativeShort
  );

  event StakeAdded(address user, address token, uint256 amount, uint256 lastMintIndex);

  event StakeWithdrawn(address user, address token, uint256 amount);

  // Note: the `amountFloatMinted` isn't strictly needed by the graph, but it is good to add it to validate calculations are accurate.
  event FloatMinted(address user, uint32 marketIndex, uint256 amountFloatMinted);

  event MarketLaunchIncentiveParametersChanges(uint32 marketIndex, uint256 period, uint256 multiplier);

  event StakeWithdrawalFeeUpdated(uint32 marketIndex, uint256 stakeWithdralFee);

  event BalanceIncentiveExponentUpdated(uint32 marketIndex, uint256 balanceIncentiveExponent);

  event BalanceIncentiveEquilibriumOffsetUpdated(uint32 marketIndex, int256 balanceIncentiveEquilibriumOffset);

  event FloatPercentageUpdated(uint256 floatPercentage);

  event SyntheticTokensShifted();

  event ChangeAdmin(address newAdmin);

  /*╔═════════════════════════════╗
    ║          MODIFIERS          ║
    ╚═════════════════════════════╝*/

  function onlyAdminModifierLogic() internal virtual {
    require(msg.sender == admin, "not admin");
  }

  modifier onlyAdmin() {
    onlyAdminModifierLogic();
    _;
  }

  function onlyValidSyntheticModifierLogic(address _synth) internal virtual {
    require(marketIndexOfToken[_synth] != 0, "not valid synth");
  }

  modifier onlyValidSynthetic(address _synth) {
    onlyValidSyntheticModifierLogic(_synth);
    _;
  }

  function onlyValidMarketModifierLogic(uint32 marketIndex) internal virtual {
    require(address(syntheticTokens[marketIndex][true]) != address(0), "not valid market");
  }

  modifier onlyValidMarket(uint32 marketIndex) {
    onlyValidMarketModifierLogic(marketIndex);
    _;
  }

  function onlyLongShortModifierLogic() internal virtual {
    require(msg.sender == address(longShort), "not long short");
  }

  modifier onlyLongShort() {
    onlyLongShortModifierLogic();
    _;
  }

  /*╔═════════════════════════════╗
    ║       CONTRACT SET-UP       ║
    ╚═════════════════════════════╝*/

  /**
  @notice Initializes the contract.
  @dev Calls OpenZeppelin's initializer modifier.
  @param _admin Address of the admin role.
  @param _longShort Address of the LongShort contract, a deployed LongShort.sol
  @param _floatToken Address of the Float token earned by staking.
  @param _floatTreasury Address of the treasury contract for managing fees.
  @param _floatCapital Address of the contract which earns a fixed percentage of Float.
  @param _floatPercentage Determines the float percentage that gets minted for Float Capital, base 1e18.
  */
  function initialize(
    address _admin,
    address _longShort,
    address _floatToken,
    address _floatTreasury,
    address _floatCapital,
    uint256 _floatPercentage
  ) external virtual initializer {
    admin = _admin;
    floatCapital = _floatCapital;
    floatTreasury = _floatTreasury;
    longShort = _longShort;
    floatToken = _floatToken;

    _changeFloatPercentage(_floatPercentage);

    emit StakerV1(_admin, _floatTreasury, _floatCapital, _floatToken, _floatPercentage);
  }

  /*╔═══════════════════╗
    ║       ADMIN       ║
    ╚═══════════════════╝*/

  /** 
  @notice Changes admin for the contract
  @param _admin The address of the new admin.
  */
  function changeAdmin(address _admin) external onlyAdmin {
    admin = _admin;
    emit ChangeAdmin(_admin);
  }

  /// @dev Logic for changeFloatPercentage
  function _changeFloatPercentage(uint256 newFloatPercentage) internal virtual {
    require(newFloatPercentage <= 1e18 && newFloatPercentage > 0); // less than or equal to 100% and greater than 0%
    floatPercentage = newFloatPercentage;
  }

  /**
  @notice Changes percentage of float that is minted for float capital.
  @param newFloatPercentage The new float percentage in base 1e18.
  */
  function changeFloatPercentage(uint256 newFloatPercentage) external onlyAdmin {
    _changeFloatPercentage(newFloatPercentage);
    emit FloatPercentageUpdated(newFloatPercentage);
  }

  /// @dev Logic for changeUnstakeFee
  function _changeUnstakeFee(uint32 marketIndex, uint256 newMarketUnstakeFee_e18) internal virtual {
    require(newMarketUnstakeFee_e18 <= 5e16); // Explicitely stating 5% fee as the max fee possible.
    marketUnstakeFee_e18[marketIndex] = newMarketUnstakeFee_e18;
  }

  /**
  @notice Changes unstake fee for a market
  @param marketIndex Identifies the market.
  @param newMarketUnstakeFee_e18 The new unstake fee.
  */
  function changeUnstakeFee(uint32 marketIndex, uint256 newMarketUnstakeFee_e18) external onlyAdmin {
    _changeUnstakeFee(marketIndex, newMarketUnstakeFee_e18);
    emit StakeWithdrawalFeeUpdated(marketIndex, newMarketUnstakeFee_e18);
  }

  /// @dev Logic for changeMarketLaunchIncentiveParameters
  function _changeMarketLaunchIncentiveParameters(
    uint32 marketIndex,
    uint256 period,
    uint256 initialMultiplier
  ) internal virtual {
    require(initialMultiplier >= 1e18, "marketLaunchIncentiveMultiplier must be >= 1e18");

    marketLaunchIncentive_period[marketIndex] = period;
    marketLaunchIncentive_multipliers[marketIndex] = initialMultiplier;
  }

  /**
  @notice Changes the market launch incentive parameters for a market
  @param marketIndex Identifies the market.
  @param period The new period for which float token generation should be boosted.
  @param initialMultiplier The new multiplier on Float generation.
  */
  function changeMarketLaunchIncentiveParameters(
    uint32 marketIndex,
    uint256 period,
    uint256 initialMultiplier
  ) external onlyAdmin {
    _changeMarketLaunchIncentiveParameters(marketIndex, period, initialMultiplier);

    emit MarketLaunchIncentiveParametersChanges(marketIndex, period, initialMultiplier);
  }

  /// @dev Logic for changeBalanceIncentiveExponent
  function _changeBalanceIncentiveExponent(uint32 marketIndex, uint256 _balanceIncentiveCurve_exponent)
    internal
    virtual
  {
    require(
      // The exponent has to be less than 5 in these versions of the contracts.
      _balanceIncentiveCurve_exponent > 0 && _balanceIncentiveCurve_exponent < 6,
      "balanceIncentiveCurve_exponent out of bounds"
    );

    balanceIncentiveCurve_exponent[marketIndex] = _balanceIncentiveCurve_exponent;
  }

  /** 
  @notice Changes the balance incentive exponent for a market
  @param marketIndex Identifies the market.
  @param _balanceIncentiveCurve_exponent The new exponent for the curve.
  */
  function changeBalanceIncentiveExponent(uint32 marketIndex, uint256 _balanceIncentiveCurve_exponent)
    external
    onlyAdmin
  {
    _changeBalanceIncentiveExponent(marketIndex, _balanceIncentiveCurve_exponent);

    emit BalanceIncentiveExponentUpdated(marketIndex, _balanceIncentiveCurve_exponent);
  }

  /// @dev Logic for changeBalanceIncentiveEquilibriumOffset
  function _changeBalanceIncentiveEquilibriumOffset(uint32 marketIndex, int256 _balanceIncentiveCurve_equilibriumOffset)
    internal
    virtual
  {
    // Unreasonable that we would ever shift this more than 90% either way
    require(
      _balanceIncentiveCurve_equilibriumOffset > -9e17 && _balanceIncentiveCurve_equilibriumOffset < 9e17,
      "balanceIncentiveCurve_equilibriumOffset out of bounds"
    );

    balanceIncentiveCurve_equilibriumOffset[marketIndex] = _balanceIncentiveCurve_equilibriumOffset;
  }

  /**
  @notice Changes the balance incentive curve equilibrium offset for a market
  @param marketIndex Identifies the market.
  @param _balanceIncentiveCurve_equilibriumOffset The new offset.
  */
  function changeBalanceIncentiveEquilibriumOffset(uint32 marketIndex, int256 _balanceIncentiveCurve_equilibriumOffset)
    external
    onlyAdmin
  {
    _changeBalanceIncentiveEquilibriumOffset(marketIndex, _balanceIncentiveCurve_equilibriumOffset);

    emit BalanceIncentiveEquilibriumOffsetUpdated(marketIndex, _balanceIncentiveCurve_equilibriumOffset);
  }

  /*╔═════════════════════════════╗
    ║        STAKING SETUP        ║
    ╚═════════════════════════════╝*/

  /**
  @notice Sets this contract to track staking for a market in LongShort.sol
  @param marketIndex Identifies the market.
  @param longToken Address of the long token for the market.
  @param shortToken Address of the short token for the market.
  @param kInitialMultiplier Initial boost on float generation for the market.
  @param kPeriod Period which the boost should last.
  @param unstakeFee_e18 Percentage of tokens that are levied on unstaking in base 1e18.
  @param _balanceIncentiveCurve_exponent Exponent for balance curve (see _calculateFloatPerSecond)
  @param _balanceIncentiveCurve_equilibriumOffset Offset for balance curve (see _calculateFloatPerSecond)
  */
  function addNewStakingFund(
    uint32 marketIndex,
    address longToken,
    address shortToken,
    uint256 kInitialMultiplier,
    uint256 kPeriod,
    uint256 unstakeFee_e18,
    uint256 _balanceIncentiveCurve_exponent,
    int256 _balanceIncentiveCurve_equilibriumOffset
  ) external override onlyLongShort {
    marketIndexOfToken[longToken] = marketIndex;
    marketIndexOfToken[shortToken] = marketIndex;

    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].timestamp = block.timestamp;
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].accumulativeFloatPerSyntheticToken_long = 0;
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].accumulativeFloatPerSyntheticToken_short = 0;

    syntheticTokens[marketIndex][true] = longToken;
    syntheticTokens[marketIndex][false] = shortToken;

    _changeBalanceIncentiveExponent(marketIndex, _balanceIncentiveCurve_exponent);
    _changeBalanceIncentiveEquilibriumOffset(marketIndex, _balanceIncentiveCurve_equilibriumOffset);
    _changeMarketLaunchIncentiveParameters(marketIndex, kPeriod, kInitialMultiplier);

    _changeUnstakeFee(marketIndex, unstakeFee_e18);

    // Set this value to one initially - 0 is a null value and thus potentially bug prone.
    batched_stakerNextTokenShiftIndex[marketIndex] = 1;

    emit MarketAddedToStaker(
      marketIndex,
      unstakeFee_e18,
      kPeriod,
      kInitialMultiplier,
      _balanceIncentiveCurve_exponent,
      _balanceIncentiveCurve_equilibriumOffset
    );

    emit AccumulativeIssuancePerStakedSynthSnapshotCreated(marketIndex, 0, 0, 0);
  }

  /*╔═════════════════════════════════════════════════════════════════════════╗
    ║    GLOBAL FLT REWARD ACCUMULATION CALCULATION AND TRACKING FUNCTIONS    ║
    ╚═════════════════════════════════════════════════════════════════════════╝*/

  /**
  @notice Returns the K factor parameters for the given market with sensible
  defaults if they haven't been set yet.
  @param marketIndex The market to change the parameters for.
  @return period The period for which the k factor applies for in seconds.
  @return multiplier The multiplier on Float generation in this period.
  */
  function _getMarketLaunchIncentiveParameters(uint32 marketIndex)
    internal
    view
    virtual
    returns (uint256 period, uint256 multiplier)
  {
    period = marketLaunchIncentive_period[marketIndex];
    multiplier = marketLaunchIncentive_multipliers[marketIndex];

    if (multiplier < 1e18) {
      multiplier = 1e18; // multiplier of 1 by default
    }
  }

  /** 
  @notice Returns the extent to which a markets float generation should be adjusted
  based on the market's launch incentive parameters. Should start at multiplier
  then linearly change to 1e18 over time.
  @param marketIndex Identifies the market.
  @return k The calculated modifier for float generation.
  */
  function _getKValue(uint32 marketIndex) internal view virtual returns (uint256) {
    // Parameters controlling the float issuance multiplier.
    (uint256 kPeriod, uint256 kInitialMultiplier) = _getMarketLaunchIncentiveParameters(marketIndex);

    // Sanity check - under normal circumstances, the multipliers should
    // *never* be set to a value < 1e18, as there are guards against this.
    assert(kInitialMultiplier >= 1e18);

    uint256 initialTimestamp = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].timestamp;

    if (block.timestamp - initialTimestamp <= kPeriod) {
      return kInitialMultiplier - (((kInitialMultiplier - 1e18) * (block.timestamp - initialTimestamp)) / kPeriod);
    } else {
      return 1e18;
    }
  }

  /*
  @notice Computes the number of float tokens a user earns per second for
  every long/short synthetic token they've staked. The returned value has
  a fixed decimal scale of 1e42 (!!!) for numerical stability. The return
  values are float per second per synthetic token (hence the requirement
  to multiply by price)
  @dev to see below math in latex form see TODO add link
  to interact with the equations see https://www.desmos.com/calculator/optkaxyihr
  @param marketIndex The market referred to.
  @param longPrice Price of the synthetic long token in units of payment token
  @param shortPrice Price of the synthetic short token in units of payment token
  @param longValue Amount of payment token in the long side of the market
  @param shortValue Amount of payment token in the short side of the market
  @return longFloatPerSecond Float token per second per long synthetic token
  @return shortFloatPerSecond Float token per second per short synthetic token
   */
  function _calculateFloatPerSecond(
    uint32 marketIndex,
    uint256 longPrice,
    uint256 shortPrice,
    uint256 longValue,
    uint256 shortValue
  ) internal view virtual returns (uint256 longFloatPerSecond, uint256 shortFloatPerSecond) {
    // A float issuance multiplier that starts high and decreases linearly
    // over time to a value of 1. This incentivises users to stake early.
    uint256 k = _getKValue(marketIndex);

    uint256 totalLocked = (longValue + shortValue);

    // we need to scale this number by the totalLocked so that the offset remains consistent accross market size

    int256 equilibriumOffsetMarketScaled = (balanceIncentiveCurve_equilibriumOffset[marketIndex] *
      int256(totalLocked)) / 2e18;

    uint256 denominator = ((totalLocked >> safeExponentBitShifting)**balanceIncentiveCurve_exponent[marketIndex]);

    // Float is scaled by the percentage of the total market value held in
    // the opposite position. This incentivises users to stake on the
    // weaker position.
    if (int256(shortValue) - equilibriumOffsetMarketScaled < int256(longValue)) {
      if (equilibriumOffsetMarketScaled >= int256(shortValue)) {
        // edge case: imbalanced far past the equilibrium offset - full rewards go to short token
        //            extremeley unlikely to happen in practice
        return (0, 1e18 * k * shortPrice);
      }

      uint256 numerator = (uint256(int256(shortValue) - equilibriumOffsetMarketScaled) >>
        (safeExponentBitShifting - 1))**balanceIncentiveCurve_exponent[marketIndex];

      // NOTE: `x * 5e17` == `(x * 10e18) / 2`
      uint256 longRewardUnscaled = (numerator * 5e17) / denominator;
      uint256 shortRewardUnscaled = 1e18 - longRewardUnscaled;

      return ((longRewardUnscaled * k * longPrice) / 1e18, (shortRewardUnscaled * k * shortPrice) / 1e18);
    } else {
      if (-equilibriumOffsetMarketScaled >= int256(longValue)) {
        // edge case: imbalanced far past the equilibrium offset - full rewards go to long token
        //            extremeley unlikely to happen in practice
        return (1e18 * k * longPrice, 0);
      }

      uint256 numerator = (uint256(int256(longValue) + equilibriumOffsetMarketScaled) >>
        (safeExponentBitShifting - 1))**balanceIncentiveCurve_exponent[marketIndex];

      // NOTE: `x * 5e17` == `(x * 10e18) / 2`
      uint256 shortRewardUnscaled = (numerator * 5e17) / denominator;
      uint256 longRewardUnscaled = 1e18 - shortRewardUnscaled;

      return ((longRewardUnscaled * k * longPrice) / 1e18, (shortRewardUnscaled * k * shortPrice) / 1e18);
    }
  }

  /**
  @notice Computes the time since last accumulativeIssuancePerStakedSynthSnapshot for the given market in seconds.
  @param marketIndex The market referred to.
  @return The time difference in seconds
  */
  function _calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(uint32 marketIndex)
    internal
    view
    virtual
    returns (uint256)
  {
    return
      block.timestamp -
      accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]].timestamp;
  }

  /**
  @notice Computes new cumulative sum of 'r' value since last accumulativeIssuancePerStakedSynthSnapshot. We use
  cumulative 'r' value to avoid looping during issuance. Note that the
  cumulative sum is kept in 1e42 scale (!!!) to avoid numerical issues.
  @param shortValue The value locked in the short side of the market.
  @param longValue The value locked in the long side of the market.
  @param shortPrice The price of the short token as defined in LongShort.sol
  @param longPrice The price of the long token as defined in LongShort.sol
  @param marketIndex An identifier for the market.
  @return longCumulativeRates The long cumulative sum.
  @return shortCumulativeRates The short cumulative sum.
  */
  function _calculateNewCumulativeIssuancePerStakedSynth(
    uint32 marketIndex,
    uint256 longPrice,
    uint256 shortPrice,
    uint256 longValue,
    uint256 shortValue
  ) internal view virtual returns (uint256 longCumulativeRates, uint256 shortCumulativeRates) {
    // Compute the current 'r' value for float issuance per second.
    (uint256 longFloatPerSecond, uint256 shortFloatPerSecond) = _calculateFloatPerSecond(
      marketIndex,
      longPrice,
      shortPrice,
      longValue,
      shortValue
    );

    // Compute time since last accumulativeIssuancePerStakedSynthSnapshot for the given token.
    uint256 timeDelta = _calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(marketIndex);

    // Compute new cumulative 'r' value total.
    return (
      accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]]
      .accumulativeFloatPerSyntheticToken_long + (timeDelta * longFloatPerSecond),
      accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]]
      .accumulativeFloatPerSyntheticToken_short + (timeDelta * shortFloatPerSecond)
    );
  }

  /**
  @notice Creates a new accumulativeIssuancePerStakedSynthSnapshot for the given token and updates indexes.
  @param shortValue The value locked in the short side of the market.
  @param longValue The value locked in the long side of the market.
  @param shortPrice The price of the short token as defined in LongShort.sol
  @param longPrice The price of the long token as defined in LongShort.sol
  @param marketIndex An identifier for the market.
  */
  function _setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot(
    uint32 marketIndex,
    uint256 longPrice,
    uint256 shortPrice,
    uint256 longValue,
    uint256 shortValue
  ) internal virtual {
    (
      uint256 newLongAccumulativeValue,
      uint256 newShortAccumulativeValue
    ) = _calculateNewCumulativeIssuancePerStakedSynth(marketIndex, longPrice, shortPrice, longValue, shortValue);

    uint256 newIndex = latestRewardIndex[marketIndex] + 1;

    // Set cumulative 'r' value on new accumulativeIssuancePerStakedSynthSnapshot.
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex]
    .accumulativeFloatPerSyntheticToken_long = newLongAccumulativeValue;
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex]
    .accumulativeFloatPerSyntheticToken_short = newShortAccumulativeValue;

    // Set timestamp on new accumulativeIssuancePerStakedSynthSnapshot.
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex].timestamp = block.timestamp;

    // Update latest index to point to new accumulativeIssuancePerStakedSynthSnapshot.
    latestRewardIndex[marketIndex] = newIndex;

    emit AccumulativeIssuancePerStakedSynthSnapshotCreated(
      marketIndex,
      newIndex,
      newLongAccumulativeValue,
      newShortAccumulativeValue
    );
  }

  /**
  @notice Adds new accumulativeIssuancePerStakedSynthSnapshots for the given long/short tokens. Called by the
  ILongShort contract whenever there is a state change for a market.
  @param stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted Mapping from this contract's shifts to LongShort.sols next price snapshots.
  @param shortValue The value locked in the short side of the market.
  @param longValue The value locked in the long side of the market.
  @param shortPrice The price of the short token as defined in LongShort.sol
  @param longPrice The price of the long token as defined in LongShort.sol
  @param marketIndex An identifier for the market.
  */
  function pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(
    uint32 marketIndex,
    uint256 longPrice,
    uint256 shortPrice,
    uint256 longValue,
    uint256 shortValue,
    uint256 stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted // This value should be ALWAYS be zero if no shift occured
  ) external override onlyLongShort {
    // Only add a new accumulativeIssuancePerStakedSynthSnapshot if some time has passed.

    // the `stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted` value will be 0 if there is no staker related action in an executed batch
    if (stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted > 0) {
      stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[
        batched_stakerNextTokenShiftIndex[marketIndex]
      ] = stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted;
      stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[
        batched_stakerNextTokenShiftIndex[marketIndex]
      ] = latestRewardIndex[marketIndex] + 1;
      batched_stakerNextTokenShiftIndex[marketIndex] += 1;

      emit SyntheticTokensShifted();
    }

    // Time delta is fetched twice in below code, can pass through? Which is less gas?
    if (_calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(marketIndex) > 0) {
      _setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot(
        marketIndex,
        longPrice,
        shortPrice,
        longValue,
        shortValue
      );
    }
  }

  /*╔═══════════════════════════════════╗
    ║    USER REWARD STATE FUNCTIONS    ║
    ╚═══════════════════════════════════╝*/

  /// @dev Calculates the accumulated float in a specific range of staker snapshots
  function _calculateAccumulatedFloatInRange(
    uint32 marketIndex,
    uint256 amountStakedLong,
    uint256 amountStakedShort,
    uint256 rewardIndexFrom,
    uint256 rewardIndexTo
  ) internal view virtual returns (uint256 floatReward) {
    if (amountStakedLong > 0) {
      uint256 accumDeltaLong = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexTo]
      .accumulativeFloatPerSyntheticToken_long -
        accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexFrom]
        .accumulativeFloatPerSyntheticToken_long;
      floatReward += (accumDeltaLong * amountStakedLong) / FLOAT_ISSUANCE_FIXED_DECIMAL;
    }

    if (amountStakedShort > 0) {
      uint256 accumDeltaShort = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexTo]
      .accumulativeFloatPerSyntheticToken_short -
        accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexFrom]
        .accumulativeFloatPerSyntheticToken_short;
      floatReward += (accumDeltaShort * amountStakedShort) / FLOAT_ISSUANCE_FIXED_DECIMAL;
    }
  }

  /** 
  @notice Calculates float owed to the user since the user last minted float for a market.
  @param marketIndex Identifier for the market which the user staked in.
  @param user The address of the user.
  @return floatReward The amount of float owed.
   */
  function _calculateAccumulatedFloat(uint32 marketIndex, address user) internal virtual returns (uint256 floatReward) {
    address longToken = syntheticTokens[marketIndex][true];
    address shortToken = syntheticTokens[marketIndex][false];

    uint256 amountStakedLong = userAmountStaked[longToken][user];
    uint256 amountStakedShort = userAmountStaked[shortToken][user];

    uint256 usersLastRewardIndex = userIndexOfLastClaimedReward[marketIndex][user];

    // Don't do the calculation and return zero immediately if there is no change
    if (usersLastRewardIndex == latestRewardIndex[marketIndex]) {
      return 0;
    }

    uint256 usersShiftIndex = userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][user];
    // if there is a change in the users tokens held due to a token shift (or possibly another action in the future)
    if (usersShiftIndex > 0 && usersShiftIndex < batched_stakerNextTokenShiftIndex[marketIndex]) {
      floatReward = _calculateAccumulatedFloatInRange(
        marketIndex,
        amountStakedLong,
        amountStakedShort,
        usersLastRewardIndex,
        stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[usersShiftIndex]
      );

      // Update the users balances
      if (userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user] > 0) {
        amountStakedShort += ILongShort(longShort).getAmountSyntheticTokenToMintOnTargetSide(
          marketIndex,
          userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user],
          true,
          stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[usersShiftIndex]
        );

        amountStakedLong -= userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user];
        userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user] = 0;
      }

      if (userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user] > 0) {
        amountStakedLong += ILongShort(longShort).getAmountSyntheticTokenToMintOnTargetSide(
          marketIndex,
          userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user],
          false,
          stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[usersShiftIndex]
        );

        amountStakedShort -= userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user];
        userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user] = 0;
      }

      // Save the users updated staked amounts
      userAmountStaked[longToken][user] = amountStakedLong;
      userAmountStaked[shortToken][user] = amountStakedShort;

      floatReward += _calculateAccumulatedFloatInRange(
        marketIndex,
        amountStakedLong,
        amountStakedShort,
        stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[usersShiftIndex],
        latestRewardIndex[marketIndex]
      );

      userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][user] = 0;
    } else {
      floatReward = _calculateAccumulatedFloatInRange(
        marketIndex,
        amountStakedLong,
        amountStakedShort,
        usersLastRewardIndex,
        latestRewardIndex[marketIndex]
      );
    }
  }

  /**
  @notice Mints float for a user.
  @dev Mints a fixed percentage for Float capital.
  @param user The address of the user.
  @param floatToMint The amount of float to mint.
   */
  function _mintFloat(address user, uint256 floatToMint) internal virtual {
    IFloatToken(floatToken).mint(user, floatToMint);
    IFloatToken(floatToken).mint(floatCapital, (floatToMint * floatPercentage) / 1e18);
  }

  /**
  @notice Mints float owed to a user for a market since they last minted.
  @param marketIndex An identifier for the market.
  @param user The address of the user.
   */
  function _mintAccumulatedFloat(uint32 marketIndex, address user) internal virtual {
    uint256 floatToMint = _calculateAccumulatedFloat(marketIndex, user);

    if (floatToMint > 0) {
      // Set the user has claimed up until now, stops them setting this forward
      userIndexOfLastClaimedReward[marketIndex][user] = latestRewardIndex[marketIndex];

      _mintFloat(user, floatToMint);
      emit FloatMinted(user, marketIndex, floatToMint);
    }
  }

  /**
  @notice Mints float owed to a user for multiple markets, since they last minted for those markets.
  @param marketIndexes Identifiers for the markets.
  @param user The address of the user.
   */
  function _mintAccumulatedFloatMulti(uint32[] calldata marketIndexes, address user) internal virtual {
    uint256 floatTotal = 0;
    for (uint256 i = 0; i < marketIndexes.length; i++) {
      uint256 floatToMint = _calculateAccumulatedFloat(marketIndexes[i], user);

      if (floatToMint > 0) {
        // Set the user has claimed up until now, stops them setting this forward
        userIndexOfLastClaimedReward[marketIndexes[i]][user] = latestRewardIndex[marketIndexes[i]];

        floatTotal += floatToMint;

        emit FloatMinted(user, marketIndexes[i], floatToMint);
      }
    }
    if (floatTotal > 0) {
      _mintFloat(user, floatTotal);
    }
  }

  /**
  @notice Mints outstanding float for msg.sender.
  @param marketIndexes Identifiers for the markets for which to mint float.
   */
  function claimFloatCustom(uint32[] calldata marketIndexes) external {
    ILongShort(longShort).updateSystemStateMulti(marketIndexes);
    _mintAccumulatedFloatMulti(marketIndexes, msg.sender);
  }

  /**
  @notice Mints outstanding float on behalf of another user.
  @param marketIndexes Identifiers for the markets for which to mint float.
  @param user The address of the user.
   */
  function claimFloatCustomFor(uint32[] calldata marketIndexes, address user) external {
    // Unbounded loop - users are responsible for paying their own gas costs on these and it doesn't effect the rest of the system.
    // No need to impose limit.
    ILongShort(longShort).updateSystemStateMulti(marketIndexes);
    _mintAccumulatedFloatMulti(marketIndexes, user);
  }

  /*╔═══════════════════════╗
    ║        STAKING        ║
    ╚═══════════════════════╝*/

  /**
  @notice A user with synthetic tokens stakes by calling stake on the token
  contract which calls this function. We need to first update the
  state of the LongShort contract for this market before staking to correctly calculate user rewards.
  @param amount Amount to stake.
  @param from Address to stake for.
  */
  function stakeFromUser(address from, uint256 amount) public virtual override onlyValidSynthetic((msg.sender)) {
    ILongShort(longShort).updateSystemState(marketIndexOfToken[(msg.sender)]);
    _stake((msg.sender), amount, from);
  }

  /**
  @dev Internal logic for staking.
  @param token Address of the token for which to stake.
  @param amount Amount to stake.
  @param user Address to stake for.
  */
  function _stake(
    address token,
    uint256 amount,
    address user
  ) internal virtual {
    uint32 marketIndex = marketIndexOfToken[token];

    // If they already have staked and have rewards due, mint these.
    if (
      userIndexOfLastClaimedReward[marketIndex][user] != 0 &&
      userIndexOfLastClaimedReward[marketIndex][user] < latestRewardIndex[marketIndex]
    ) {
      _mintAccumulatedFloat(marketIndex, user);
    }

    userAmountStaked[token][user] = userAmountStaked[token][user] + amount;

    userIndexOfLastClaimedReward[marketIndex][user] = latestRewardIndex[marketIndex];

    emit StakeAdded(user, address(token), amount, userIndexOfLastClaimedReward[marketIndex][user]);
  }

  /**
  @notice Allows users to shift their staked tokens from one side of the market to 
  the other at the next price.
  @param amountSyntheticTokensToShift Amount of tokens to shift.
  @param marketIndex Identifier for the market.
  @param isShiftFromLong Whether the shift is from long to short or short to long.
  */
  function shiftTokens(
    uint256 amountSyntheticTokensToShift,
    uint32 marketIndex,
    bool isShiftFromLong
  ) external virtual {
    address token = syntheticTokens[marketIndex][isShiftFromLong];
    require(userAmountStaked[token][msg.sender] >= amountSyntheticTokensToShift, "Not enough tokens to shift");

    // If the user has outstanding token shift that have already been confirmed in the LongShort
    // contract, execute them first.
    if (
      userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] != 0 &&
      userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] <
      batched_stakerNextTokenShiftIndex[marketIndex]
    ) {
      _mintAccumulatedFloat(marketIndex, msg.sender);
    }

    if (isShiftFromLong) {
      ILongShort(longShort).shiftPositionFromLongNextPrice(marketIndex, amountSyntheticTokensToShift);
      userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][
        msg.sender
      ] += amountSyntheticTokensToShift;
    } else {
      ILongShort(longShort).shiftPositionFromShortNextPrice(marketIndex, amountSyntheticTokensToShift);
      userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][
        msg.sender
      ] += amountSyntheticTokensToShift;
    }

    userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] = batched_stakerNextTokenShiftIndex[
      marketIndex
    ];
  }

  /*╔════════════════════════════╗
    ║    WITHDRAWAL & MINTING    ║
    ╚════════════════════════════╝*/

  /**
  @notice Internal logic for withdrawing stakes.
  @dev Mint user any outstanding float before withdrawing.
  @param marketIndex Market index of token.
  @param amount Amount to withdraw.
  @param token Synthetic token that was staked.
  */
  function _withdraw(
    uint32 marketIndex,
    address token,
    uint256 amount
  ) internal virtual {
    require(userAmountStaked[token][msg.sender] > 0, "nothing to withdraw");
    _mintAccumulatedFloat(marketIndex, msg.sender);

    userAmountStaked[token][msg.sender] = userAmountStaked[token][msg.sender] - amount;

    uint256 amountFees = (amount * marketUnstakeFee_e18[marketIndex]) / 1e18;

    IERC20(token).transfer(floatTreasury, amountFees);
    IERC20(token).transfer(msg.sender, amount - amountFees);

    emit StakeWithdrawn(msg.sender, token, amount);
  }

  /**
  @notice Withdraw function. Allows users to unstake.
  @param amount Amount to withdraw.
  @param token Address of the token for which to withdraw.
  */
  function withdraw(address token, uint256 amount) external {
    ILongShort(longShort).updateSystemState(marketIndexOfToken[token]);

    uint32 marketIndex = marketIndexOfToken[token];

    _withdraw(marketIndex, token, amount);

    if (userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] > 0) {
      // If they still have outstanding shifts after minting float, then check
      // that they don't withdraw more than their shifts allow.
      uint256 amountToShiftForThisToken = syntheticTokens[marketIndex][true] == token
        ? userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][msg.sender]
        : userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][msg.sender];

      require(
        userAmountStaked[token][msg.sender] >= amountToShiftForThisToken,
        "Outstanding next price stake shifts too great"
      );
    }
  }

  /**
  @notice Allows users to withdraw their entire stake for a token.
  @param token Address of the token for which to withdraw.
  */
  function withdrawAll(address token) external {
    ILongShort(longShort).updateSystemState(marketIndexOfToken[token]);

    uint32 marketIndex = marketIndexOfToken[token];

    uint256 amountToShiftForThisToken = syntheticTokens[marketIndex][true] == token
      ? userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][msg.sender]
      : userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][msg.sender];

    _withdraw(marketIndex, token, userAmountStaked[token][msg.sender] - amountToShiftForThisToken);
  }
}
.]

Based on the provided Solidity smart contract code for the `Staker` contract, here is a summary of potential security vulnerabilities identified within the code:

### Summary of Security Vulnerabilities:

1. **Reentrancy Attacks**:
   - The contract does not implement any reentrancy guards. Functions that transfer tokens or update user balances (e.g., `withdraw`, `_withdraw`, and `stakeFromUser`) could be susceptible to reentrancy attacks, where an attacker could exploit the contract's state before it is updated.

2. **Integer Overflow/Underflow**:
   - Although Solidity 0.8.x has built-in checks for overflow and underflow, it is essential to ensure that all arithmetic operations are correctly handled, especially when dealing with user balances and fees. Any future changes to the code or use of external libraries could introduce vulnerabilities if not carefully managed.

3. **Access Control**:
   - The contract relies on the `onlyAdmin` modifier for critical functions that change the state of the contract (e.g., changing fees, parameters). If the admin's address is compromised, an attacker could manipulate these settings. It is crucial to ensure that the admin address is secure and consider implementing a multi-signature wallet for administrative functions.

4. **Gas Limit and Loops**:
   - The `claimFloatCustomFor` function has an unbounded loop that iterates over `marketIndexes`. If the number of markets grows significantly, this could lead to exceeding the block gas limit, causing transactions to fail. It is advisable to impose a limit on the number of markets that can be processed in a single transaction.

5. **Lack of Input Validation**:
   - Some functions do not validate inputs thoroughly. For example, the `stakeFromUser` function does not check if the `amount` is greater than zero before proceeding. This could lead to unintended behavior or state changes.

6. **Potential for Denial of Service (DoS)**:
   - The contract could be vulnerable to DoS attacks if a malicious actor can manipulate the state of the contract, particularly in functions that depend on external calls (e.g., `ILongShort(longShort).updateSystemStateMulti(marketIndexes)`).

7. **Uncontrolled Token Shifts**:
   - The `shiftTokens` function allows users to shift their staked tokens without sufficient checks on the state of the market or the user's balance. This could lead to unexpected behavior if not properly managed.

8. **Event Emission**:
   - While events are emitted for significant state changes, some functions may benefit from additional event logging to provide better transparency and traceability of actions taken within the contract.

### Comprehensive Analysis Report:

The `Staker` contract is designed to manage staking for synthetic tokens, allowing users to earn rewards based on their participation in the market. However, several security vulnerabilities have been identified that could potentially expose the contract to various attacks or unintended behaviors.

To mitigate these risks, the following recommendations are proposed:

- **Implement Reentrancy Guards**: Use the `nonReentrant` modifier from OpenZeppelin to protect functions that modify state and transfer tokens.
  
- **Enhance Access Control**: Consider using a multi-signature wallet for administrative functions to reduce the risk associated with a single compromised admin address.

- **Input Validation**: Ensure all user inputs are validated to prevent unintended state changes and ensure that amounts are greater than zero where applicable.

- **Limit Loop Iterations**: Introduce a maximum limit on the number of markets that can be processed in functions with loops to prevent gas limit issues.

- **Thorough Testing**: Conduct extensive testing, including unit tests and integration tests, to ensure that all functions behave as expected under various scenarios.

- **Regular Audits**: Schedule regular audits of the contract code to identify and address any new vulnerabilities that may arise due to changes in the codebase or the Solidity language itself.

By addressing these vulnerabilities and following best practices in smart contract development, the security and reliability of the `Staker` contract can be significantly improved, ensuring a safer environment for users and their assets.

[2024-17-08 08:02:11 INFO] **[Seminar Conclusion]**:

 Based on the provided Solidity smart contract code for the `Staker` contract, here is a summary of potential security vulnerabilities identified within the code:

### Summary of Security Vulnerabilities:

1. **Reentrancy Attacks**:
   - The contract does not implement any reentrancy guards. Functions that transfer tokens or update user balances (e.g., `withdraw`, `_withdraw`, and `stakeFromUser`) could be susceptible to reentrancy attacks, where an attacker could exploit the contract's state before it is updated.

2. **Integer Overflow/Underflow**:
   - Although Solidity 0.8.x has built-in checks for overflow and underflow, it is essential to ensure that all arithmetic operations are correctly handled, especially when dealing with user balances and fees. Any future changes to the code or use of external libraries could introduce vulnerabilities if not carefully managed.

3. **Access Control**:
   - The contract relies on the `onlyAdmin` modifier for critical functions that change the state of the contract (e.g., changing fees, parameters). If the admin's address is compromised, an attacker could manipulate these settings. It is crucial to ensure that the admin address is secure and consider implementing a multi-signature wallet for administrative functions.

4. **Gas Limit and Loops**:
   - The `claimFloatCustomFor` function has an unbounded loop that iterates over `marketIndexes`. If the number of markets grows significantly, this could lead to exceeding the block gas limit, causing transactions to fail. It is advisable to impose a limit on the number of markets that can be processed in a single transaction.

5. **Lack of Input Validation**:
   - Some functions do not validate inputs thoroughly. For example, the `stakeFromUser` function does not check if the `amount` is greater than zero before proceeding. This could lead to unintended behavior or state changes.

6. **Potential for Denial of Service (DoS)**:
   - The contract could be vulnerable to DoS attacks if a malicious actor can manipulate the state of the contract, particularly in functions that depend on external calls (e.g., `ILongShort(longShort).updateSystemStateMulti(marketIndexes)`).

7. **Uncontrolled Token Shifts**:
   - The `shiftTokens` function allows users to shift their staked tokens without sufficient checks on the state of the market or the user's balance. This could lead to unexpected behavior if not properly managed.

8. **Event Emission**:
   - While events are emitted for significant state changes, some functions may benefit from additional event logging to provide better transparency and traceability of actions taken within the contract.

### Comprehensive Analysis Report:

The `Staker` contract is designed to manage staking for synthetic tokens, allowing users to earn rewards based on their participation in the market. However, several security vulnerabilities have been identified that could potentially expose the contract to various attacks or unintended behaviors.

To mitigate these risks, the following recommendations are proposed:

- **Implement Reentrancy Guards**: Use the `nonReentrant` modifier from OpenZeppelin to protect functions that modify state and transfer tokens.
  
- **Enhance Access Control**: Consider using a multi-signature wallet for administrative functions to reduce the risk associated with a single compromised admin address.

- **Input Validation**: Ensure all user inputs are validated to prevent unintended state changes and ensure that amounts are greater than zero where applicable.

- **Limit Loop Iterations**: Introduce a maximum limit on the number of markets that can be processed in functions with loops to prevent gas limit issues.

- **Thorough Testing**: Conduct extensive testing, including unit tests and integration tests, to ensure that all functions behave as expected under various scenarios.

- **Regular Audits**: Schedule regular audits of the contract code to identify and address any new vulnerabilities that may arise due to changes in the codebase or the Solidity language itself.

By addressing these vulnerabilities and following best practices in smart contract development, the security and reliability of the `Staker` contract can be significantly improved, ensuring a safer environment for users and their assets.

[2024-17-08 08:02:14 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: BUSL-1.1 pragma solidity 0.8.3; import "@openzeppelin/contracts-upgradeable/token/ERC20/presets/ERC20PresetMinterPauserUpgradeable.sol"; import "./interfaces/IFloatToken.sol"; import "./interfaces/ILongShort.sol"; import "./interfaces/IStaker.sol"; import "./interfaces/ISyntheticToken.sol"; contract Staker is IStaker, Initializable {   /╔═════════════════════════════╗     ║          VARIABLES          ║     ╚═════════════════════════════╝/ / ══════ Fixed-precision constants ══════ /   uint256 public constant FLOAT_ISSUANCE_FIXED_DECIMAL = 1e42;   // 2^52 ~= 4.5e15   // With an exponent of 5, the largest total liquidity possible in a market (to avoid integer overflow on exponentiation) is ~10^31 or 10 Trillion (10^13)   // NOTE: this also means if the total market value is less than 2^52 there will be a division by zero error   uint256 public constant safeExponentBitShifting = 52; / ══════ Global state ══════ /   address public admin;   address public floatCapital;   address public floatTreasury;   uint256 public floatPercentage; address public longShort;   address public floatToken; / ══════ Market specific ══════ /   mapping(uint32 =&gt; uint256) public marketLaunchIncentive_period; // seconds   mapping(uint32 =&gt; uint256) public marketLaunchIncentive_multipliers; // e18 scale   mapping(uint32 =&gt; uint256) public marketUnstakeFee_e18;   mapping(uint32 =&gt; uint256) public balanceIncentiveCurve_exponent;   mapping(uint32 =&gt; int256) public balanceIncentiveCurve_equilibriumOffset; mapping(uint32 =&gt; mapping(bool =&gt; address)) public syntheticTokens; mapping(address =&gt; uint32) public marketIndexOfToken; / ══════ Reward specific ══════ /   mapping(uint32 =&gt; uint256) public latestRewardIndex;   mapping(uint32 =&gt; mapping(uint256 =&gt; AccumulativeIssuancePerStakedSynthSnapshot))     public accumulativeFloatPerSyntheticTokenSnapshots;   struct AccumulativeIssuancePerStakedSynthSnapshot {     uint256 timestamp;     uint256 accumulativeFloatPerSyntheticToken_long;     uint256 accumulativeFloatPerSyntheticToken_short;   } / ══════ User specific ══════ /   mapping(uint32 =&gt; mapping(address =&gt; uint256)) public userIndexOfLastClaimedReward;   mapping(address =&gt; mapping(address =&gt; uint256)) public userAmountStaked; / ══════ Token shift management specific ══════ /   mapping(uint32 =&gt; uint256) public batched_stakerNextTokenShiftIndex;   /*   @notice Used to link a token shift to a staker state   @dev tokenShiftIndex =&gt; accumulativeFloatIssuanceSnapshotIndex     POSSIBLE OPTIMIZATION - could pack stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping and stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping into a struct of two uint128 for storage space optimization.   /   mapping(uint256 =&gt; uint256) public stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping;   /// @notice Used to fetch the price from LongShort at that point in time   /// @dev tokenShiftIndex =&gt; longShortMarketPriceSnapshotIndex   mapping(uint256 =&gt; uint256) public stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping;   /// @dev marketIndex =&gt; usersAddress =&gt; stakerTokenShiftIndex   mapping(uint32 =&gt; mapping(address =&gt; uint256)) public userNextPrice_stakedSyntheticTokenShiftIndex;   /// @dev marketIndex =&gt; usersAddress =&gt; amountUserRequestedToShiftAwayFromLongOnNextUpdate   mapping(uint32 =&gt; mapping(address =&gt; uint256)) public userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long;   /// @dev marketIndex =&gt; usersAddress =&gt; amountUserRequestedToShiftAwayFromShortOnNextUpdate   mapping(uint32 =&gt; mapping(address =&gt; uint256)) public userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short; /╔════════════════════════════╗     ║           EVENTS           ║     ╚════════════════════════════╝/ event StakerV1(     address admin,     address floatTreasury,     address floatCapital,     address floatToken,     uint256 floatPercentage   ); event MarketAddedToStaker(     uint32 marketIndex,     uint256 exitFee_e18,     uint256 period,     uint256 multiplier,     uint256 balanceIncentiveExponent,     int256 balanceIncentiveEquilibriumOffset   ); event AccumulativeIssuancePerStakedSynthSnapshotCreated(     uint32 marketIndex,     uint256 accumulativeFloatIssuanceSnapshotIndex,     uint256 accumulativeLong,     uint256 accumulativeShort   ); event StakeAdded(address user, address token, uint256 amount, uint256 lastMintIndex); event StakeWithdrawn(address user, address token, uint256 amount); // Note: the amountFloatMinted isn't strictly needed by the graph, but it is good to add it to validate calculations are accurate.   event FloatMinted(address user, uint32 marketIndex, uint256 amountFloatMinted); event MarketLaunchIncentiveParametersChanges(uint32 marketIndex, uint256 period, uint256 multiplier); event StakeWithdrawalFeeUpdated(uint32 marketIndex, uint256 stakeWithdralFee); event BalanceIncentiveExponentUpdated(uint32 marketIndex, uint256 balanceIncentiveExponent); event BalanceIncentiveEquilibriumOffsetUpdated(uint32 marketIndex, int256 balanceIncentiveEquilibriumOffset); event FloatPercentageUpdated(uint256 floatPercentage); event SyntheticTokensShifted(); event ChangeAdmin(address newAdmin); /╔═════════════════════════════╗     ║          MODIFIERS          ║     ╚═════════════════════════════╝/ function onlyAdminModifierLogic() internal virtual {     require(msg.sender == admin, "not admin");   } modifier onlyAdmin() {     onlyAdminModifierLogic();     _;   } function onlyValidSyntheticModifierLogic(address _synth) internal virtual {     require(marketIndexOfToken[_synth] != 0, "not valid synth");   } modifier onlyValidSynthetic(address synth) {     onlyValidSyntheticModifierLogic(_synth);     ;   } function onlyValidMarketModifierLogic(uint32 marketIndex) internal virtual {     require(address(syntheticTokens[marketIndex][true]) != address(0), "not valid market");   } modifier onlyValidMarket(uint32 marketIndex) {     onlyValidMarketModifierLogic(marketIndex);     _;   } function onlyLongShortModifierLogic() internal virtual {     require(msg.sender == address(longShort), "not long short");   } modifier onlyLongShort() {     onlyLongShortModifierLogic();     _;   } /╔═════════════════════════════╗     ║       CONTRACT SET-UP       ║     ╚═════════════════════════════╝/ /*   @notice Initializes the contract.   @dev Calls OpenZeppelin's initializer modifier.   @param _admin Address of the admin role.   @param _longShort Address of the LongShort contract, a deployed LongShort.sol   @param _floatToken Address of the Float token earned by staking.   @param _floatTreasury Address of the treasury contract for managing fees.   @param _floatCapital Address of the contract which earns a fixed percentage of Float.   @param _floatPercentage Determines the float percentage that gets minted for Float Capital, base 1e18.   /   function initialize(     address _admin,     address _longShort,     address _floatToken,     address _floatTreasury,     address _floatCapital,     uint256 _floatPercentage   ) external virtual initializer {     admin = _admin;     floatCapital = _floatCapital;     floatTreasury = _floatTreasury;     longShort = _longShort;     floatToken = _floatToken; _changeFloatPercentage(_floatPercentage);  emit StakerV1(_admin, _floatTreasury, _floatCapital, _floatToken, _floatPercentage);  } /╔═══════════════════╗     ║       ADMIN       ║     ╚═══════════════════╝/ /*    @notice Changes admin for the contract   @param _admin The address of the new admin.   /   function changeAdmin(address _admin) external onlyAdmin {     admin = _admin;     emit ChangeAdmin(_admin);   } /// @dev Logic for changeFloatPercentage   function _changeFloatPercentage(uint256 newFloatPercentage) internal virtual {     require(newFloatPercentage &lt;= 1e18 &amp;&amp; newFloatPercentage &gt; 0); // less than or equal to 100% and greater than 0%     floatPercentage = newFloatPercentage;   } /*   @notice Changes percentage of float that is minted for float capital.   @param newFloatPercentage The new float percentage in base 1e18.   /   function changeFloatPercentage(uint256 newFloatPercentage) external onlyAdmin {     _changeFloatPercentage(newFloatPercentage);     emit FloatPercentageUpdated(newFloatPercentage);   } /// @dev Logic for changeUnstakeFee   function _changeUnstakeFee(uint32 marketIndex, uint256 newMarketUnstakeFee_e18) internal virtual {     require(newMarketUnstakeFee_e18 &lt;= 5e16); // Explicitely stating 5% fee as the max fee possible.     marketUnstakeFee_e18[marketIndex] = newMarketUnstakeFee_e18;   } /*   @notice Changes unstake fee for a market   @param marketIndex Identifies the market.   @param newMarketUnstakeFee_e18 The new unstake fee.   /   function changeUnstakeFee(uint32 marketIndex, uint256 newMarketUnstakeFee_e18) external onlyAdmin {     _changeUnstakeFee(marketIndex, newMarketUnstakeFee_e18);     emit StakeWithdrawalFeeUpdated(marketIndex, newMarketUnstakeFee_e18);   } /// @dev Logic for changeMarketLaunchIncentiveParameters   function _changeMarketLaunchIncentiveParameters(     uint32 marketIndex,     uint256 period,     uint256 initialMultiplier   ) internal virtual {     require(initialMultiplier &gt;= 1e18, "marketLaunchIncentiveMultiplier must be &gt;= 1e18"); marketLaunchIncentive_period[marketIndex] = period; marketLaunchIncentive_multipliers[marketIndex] = initialMultiplier;  } /*   @notice Changes the market launch incentive parameters for a market   @param marketIndex Identifies the market.   @param period The new period for which float token generation should be boosted.   @param initialMultiplier The new multiplier on Float generation.   /   function changeMarketLaunchIncentiveParameters(     uint32 marketIndex,     uint256 period,     uint256 initialMultiplier   ) external onlyAdmin {     _changeMarketLaunchIncentiveParameters(marketIndex, period, initialMultiplier); emit MarketLaunchIncentiveParametersChanges(marketIndex, period, initialMultiplier);  } /// @dev Logic for changeBalanceIncentiveExponent   function _changeBalanceIncentiveExponent(uint32 marketIndex, uint256 _balanceIncentiveCurve_exponent)     internal     virtual   {     require(       // The exponent has to be less than 5 in these versions of the contracts.       _balanceIncentiveCurve_exponent &gt; 0 &amp;&amp; _balanceIncentiveCurve_exponent &lt; 6,       "balanceIncentiveCurve_exponent out of bounds"     ); balanceIncentiveCurve_exponent[marketIndex] = _balanceIncentiveCurve_exponent;  } /*    @notice Changes the balance incentive exponent for a market   @param marketIndex Identifies the market.   @param _balanceIncentiveCurve_exponent The new exponent for the curve.   /   function changeBalanceIncentiveExponent(uint32 marketIndex, uint256 _balanceIncentiveCurve_exponent)     external     onlyAdmin   {     _changeBalanceIncentiveExponent(marketIndex, _balanceIncentiveCurve_exponent); emit BalanceIncentiveExponentUpdated(marketIndex, _balanceIncentiveCurve_exponent);  } /// @dev Logic for changeBalanceIncentiveEquilibriumOffset   function _changeBalanceIncentiveEquilibriumOffset(uint32 marketIndex, int256 _balanceIncentiveCurve_equilibriumOffset)     internal     virtual   {     // Unreasonable that we would ever shift this more than 90% either way     require(       _balanceIncentiveCurve_equilibriumOffset &gt; -9e17 &amp;&amp; _balanceIncentiveCurve_equilibriumOffset &lt; 9e17,       "balanceIncentiveCurve_equilibriumOffset out of bounds"     ); balanceIncentiveCurve_equilibriumOffset[marketIndex] = _balanceIncentiveCurve_equilibriumOffset;  } /*   @notice Changes the balance incentive curve equilibrium offset for a market   @param marketIndex Identifies the market.   @param _balanceIncentiveCurve_equilibriumOffset The new offset.   /   function changeBalanceIncentiveEquilibriumOffset(uint32 marketIndex, int256 _balanceIncentiveCurve_equilibriumOffset)     external     onlyAdmin   {     _changeBalanceIncentiveEquilibriumOffset(marketIndex, _balanceIncentiveCurve_equilibriumOffset); emit BalanceIncentiveEquilibriumOffsetUpdated(marketIndex, _balanceIncentiveCurve_equilibriumOffset);  } /╔═════════════════════════════╗     ║        STAKING SETUP        ║     ╚═════════════════════════════╝/ /*   @notice Sets this contract to track staking for a market in LongShort.sol   @param marketIndex Identifies the market.   @param longToken Address of the long token for the market.   @param shortToken Address of the short token for the market.   @param kInitialMultiplier Initial boost on float generation for the market.   @param kPeriod Period which the boost should last.   @param unstakeFee_e18 Percentage of tokens that are levied on unstaking in base 1e18.   @param _balanceIncentiveCurve_exponent Exponent for balance curve (see _calculateFloatPerSecond)   @param _balanceIncentiveCurve_equilibriumOffset Offset for balance curve (see _calculateFloatPerSecond)   /   function addNewStakingFund(     uint32 marketIndex,     address longToken,     address shortToken,     uint256 kInitialMultiplier,     uint256 kPeriod,     uint256 unstakeFee_e18,     uint256 _balanceIncentiveCurve_exponent,     int256 _balanceIncentiveCurve_equilibriumOffset   ) external override onlyLongShort {     marketIndexOfToken[longToken] = marketIndex;     marketIndexOfToken[shortToken] = marketIndex; accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].timestamp = block.timestamp; accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].accumulativeFloatPerSyntheticToken_long = 0; accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].accumulativeFloatPerSyntheticToken_short = 0;  syntheticTokens[marketIndex][true] = longToken; syntheticTokens[marketIndex][false] = shortToken;  _changeBalanceIncentiveExponent(marketIndex, _balanceIncentiveCurve_exponent); _changeBalanceIncentiveEquilibriumOffset(marketIndex, _balanceIncentiveCurve_equilibriumOffset); _changeMarketLaunchIncentiveParameters(marketIndex, kPeriod, kInitialMultiplier);  _changeUnstakeFee(marketIndex, unstakeFee_e18);  // Set this value to one initially - 0 is a null value and thus potentially bug prone. batched_stakerNextTokenShiftIndex[marketIndex] = 1;  emit MarketAddedToStaker(   marketIndex,   unstakeFee_e18,   kPeriod,   kInitialMultiplier,   _balanceIncentiveCurve_exponent,   _balanceIncentiveCurve_equilibriumOffset );  emit AccumulativeIssuancePerStakedSynthSnapshotCreated(marketIndex, 0, 0, 0);  } /╔═════════════════════════════════════════════════════════════════════════╗     ║    GLOBAL FLT REWARD ACCUMULATION CALCULATION AND TRACKING FUNCTIONS    ║     ╚═════════════════════════════════════════════════════════════════════════╝/ /*   @notice Returns the K factor parameters for the given market with sensible   defaults if they haven't been set yet.   @param marketIndex The market to change the parameters for.   @return period The period for which the k factor applies for in seconds.   @return multiplier The multiplier on Float generation in this period.   /   function _getMarketLaunchIncentiveParameters(uint32 marketIndex)     internal     view     virtual     returns (uint256 period, uint256 multiplier)   {     period = marketLaunchIncentive_period[marketIndex];     multiplier = marketLaunchIncentive_multipliers[marketIndex]; if (multiplier &lt; 1e18) {   multiplier = 1e18; // multiplier of 1 by default }  } /*    @notice Returns the extent to which a markets float generation should be adjusted   based on the market's launch incentive parameters. Should start at multiplier   then linearly change to 1e18 over time.   @param marketIndex Identifies the market.   @return k The calculated modifier for float generation.   /   function _getKValue(uint32 marketIndex) internal view virtual returns (uint256) {     // Parameters controlling the float issuance multiplier.     (uint256 kPeriod, uint256 kInitialMultiplier) = _getMarketLaunchIncentiveParameters(marketIndex); // Sanity check - under normal circumstances, the multipliers should // *never* be set to a value &lt; 1e18, as there are guards against this. assert(kInitialMultiplier &gt;= 1e18);  uint256 initialTimestamp = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].timestamp;  if (block.timestamp - initialTimestamp &lt;= kPeriod) {   return kInitialMultiplier - (((kInitialMultiplier - 1e18) * (block.timestamp - initialTimestamp)) / kPeriod); } else {   return 1e18; }  } /   @notice Computes the number of float tokens a user earns per second for   every long/short synthetic token they've staked. The returned value has   a fixed decimal scale of 1e42 (!!!) for numerical stability. The return   values are float per second per synthetic token (hence the requirement   to multiply by price)   @dev to see below math in latex form see TODO add link   to interact with the equations see https://www.desmos.com/calculator/optkaxyihr   @param marketIndex The market referred to.   @param longPrice Price of the synthetic long token in units of payment token   @param shortPrice Price of the synthetic short token in units of payment token   @param longValue Amount of payment token in the long side of the market   @param shortValue Amount of payment token in the short side of the market   @return longFloatPerSecond Float token per second per long synthetic token   @return shortFloatPerSecond Float token per second per short synthetic token    /   function _calculateFloatPerSecond(     uint32 marketIndex,     uint256 longPrice,     uint256 shortPrice,     uint256 longValue,     uint256 shortValue   ) internal view virtual returns (uint256 longFloatPerSecond, uint256 shortFloatPerSecond) {     // A float issuance multiplier that starts high and decreases linearly     // over time to a value of 1. This incentivises users to stake early.     uint256 k = _getKValue(marketIndex); uint256 totalLocked = (longValue + shortValue);  // we need to scale this number by the totalLocked so that the offset remains consistent accross market size  int256 equilibriumOffsetMarketScaled = (balanceIncentiveCurve_equilibriumOffset[marketIndex] *   int256(totalLocked)) / 2e18;  uint256 denominator = ((totalLocked &gt;&gt; safeExponentBitShifting)**balanceIncentiveCurve_exponent[marketIndex]);  // Float is scaled by the percentage of the total market value held in // the opposite position. This incentivises users to stake on the // weaker position. if (int256(shortValue) - equilibriumOffsetMarketScaled &lt; int256(longValue)) {   if (equilibriumOffsetMarketScaled &gt;= int256(shortValue)) {     // edge case: imbalanced far past the equilibrium offset - full rewards go to short token     //            extremeley unlikely to happen in practice     return (0, 1e18 * k * shortPrice);   }    uint256 numerator = (uint256(int256(shortValue) - equilibriumOffsetMarketScaled) &gt;&gt;     (safeExponentBitShifting - 1))**balanceIncentiveCurve_exponent[marketIndex];    // NOTE: `x * 5e17` == `(x * 10e18) / 2`   uint256 longRewardUnscaled = (numerator * 5e17) / denominator;   uint256 shortRewardUnscaled = 1e18 - longRewardUnscaled;    return ((longRewardUnscaled * k * longPrice) / 1e18, (shortRewardUnscaled * k * shortPrice) / 1e18); } else {   if (-equilibriumOffsetMarketScaled &gt;= int256(longValue)) {     // edge case: imbalanced far past the equilibrium offset - full rewards go to long token     //            extremeley unlikely to happen in practice     return (1e18 * k * longPrice, 0);   }    uint256 numerator = (uint256(int256(longValue) + equilibriumOffsetMarketScaled) &gt;&gt;     (safeExponentBitShifting - 1))**balanceIncentiveCurve_exponent[marketIndex];    // NOTE: `x * 5e17` == `(x * 10e18) / 2`   uint256 shortRewardUnscaled = (numerator * 5e17) / denominator;   uint256 longRewardUnscaled = 1e18 - shortRewardUnscaled;    return ((longRewardUnscaled * k * longPrice) / 1e18, (shortRewardUnscaled * k * shortPrice) / 1e18); }  } /*   @notice Computes the time since last accumulativeIssuancePerStakedSynthSnapshot for the given market in seconds.   @param marketIndex The market referred to.   @return The time difference in seconds   /   function _calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(uint32 marketIndex)     internal     view     virtual     returns (uint256)   {     return       block.timestamp -       accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]].timestamp;   } /*   @notice Computes new cumulative sum of 'r' value since last accumulativeIssuancePerStakedSynthSnapshot. We use   cumulative 'r' value to avoid looping during issuance. Note that the   cumulative sum is kept in 1e42 scale (!!!) to avoid numerical issues.   @param shortValue The value locked in the short side of the market.   @param longValue The value locked in the long side of the market.   @param shortPrice The price of the short token as defined in LongShort.sol   @param longPrice The price of the long token as defined in LongShort.sol   @param marketIndex An identifier for the market.   @return longCumulativeRates The long cumulative sum.   @return shortCumulativeRates The short cumulative sum.   /   function _calculateNewCumulativeIssuancePerStakedSynth(     uint32 marketIndex,     uint256 longPrice,     uint256 shortPrice,     uint256 longValue,     uint256 shortValue   ) internal view virtual returns (uint256 longCumulativeRates, uint256 shortCumulativeRates) {     // Compute the current 'r' value for float issuance per second.     (uint256 longFloatPerSecond, uint256 shortFloatPerSecond) = _calculateFloatPerSecond(       marketIndex,       longPrice,       shortPrice,       longValue,       shortValue     ); // Compute time since last accumulativeIssuancePerStakedSynthSnapshot for the given token. uint256 timeDelta = _calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(marketIndex);  // Compute new cumulative 'r' value total. return (   accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]]   .accumulativeFloatPerSyntheticToken_long + (timeDelta * longFloatPerSecond),   accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]]   .accumulativeFloatPerSyntheticToken_short + (timeDelta * shortFloatPerSecond) );  } /*   @notice Creates a new accumulativeIssuancePerStakedSynthSnapshot for the given token and updates indexes.   @param shortValue The value locked in the short side of the market.   @param longValue The value locked in the long side of the market.   @param shortPrice The price of the short token as defined in LongShort.sol   @param longPrice The price of the long token as defined in LongShort.sol   @param marketIndex An identifier for the market.   /   function _setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot(     uint32 marketIndex,     uint256 longPrice,     uint256 shortPrice,     uint256 longValue,     uint256 shortValue   ) internal virtual {     (       uint256 newLongAccumulativeValue,       uint256 newShortAccumulativeValue     ) = _calculateNewCumulativeIssuancePerStakedSynth(marketIndex, longPrice, shortPrice, longValue, shortValue); uint256 newIndex = latestRewardIndex[marketIndex] + 1;  // Set cumulative 'r' value on new accumulativeIssuancePerStakedSynthSnapshot. accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex] .accumulativeFloatPerSyntheticToken_long = newLongAccumulativeValue; accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex] .accumulativeFloatPerSyntheticToken_short = newShortAccumulativeValue;  // Set timestamp on new accumulativeIssuancePerStakedSynthSnapshot. accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex].timestamp = block.timestamp;  // Update latest index to point to new accumulativeIssuancePerStakedSynthSnapshot. latestRewardIndex[marketIndex] = newIndex;  emit AccumulativeIssuancePerStakedSynthSnapshotCreated(   marketIndex,   newIndex,   newLongAccumulativeValue,   newShortAccumulativeValue );  } /*   @notice Adds new accumulativeIssuancePerStakedSynthSnapshots for the given long/short tokens. Called by the   ILongShort contract whenever there is a state change for a market.   @param stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted Mapping from this contract's shifts to LongShort.sols next price snapshots.   @param shortValue The value locked in the short side of the market.   @param longValue The value locked in the long side of the market.   @param shortPrice The price of the short token as defined in LongShort.sol   @param longPrice The price of the long token as defined in LongShort.sol   @param marketIndex An identifier for the market.   /   function pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(     uint32 marketIndex,     uint256 longPrice,     uint256 shortPrice,     uint256 longValue,     uint256 shortValue,     uint256 stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted // This value should be ALWAYS be zero if no shift occured   ) external override onlyLongShort {     // Only add a new accumulativeIssuancePerStakedSynthSnapshot if some time has passed. // the `stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted` value will be 0 if there is no staker related action in an executed batch if (stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted &gt; 0) {   stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[     batched_stakerNextTokenShiftIndex[marketIndex]   ] = stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted;   stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[     batched_stakerNextTokenShiftIndex[marketIndex]   ] = latestRewardIndex[marketIndex] + 1;   batched_stakerNextTokenShiftIndex[marketIndex] += 1;    emit SyntheticTokensShifted(); }  // Time delta is fetched twice in below code, can pass through? Which is less gas? if (_calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(marketIndex) &gt; 0) {   _setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot(     marketIndex,     longPrice,     shortPrice,     longValue,     shortValue   ); }  } /╔═══════════════════════════════════╗     ║    USER REWARD STATE FUNCTIONS    ║     ╚═══════════════════════════════════╝/ /// @dev Calculates the accumulated float in a specific range of staker snapshots   function _calculateAccumulatedFloatInRange(     uint32 marketIndex,     uint256 amountStakedLong,     uint256 amountStakedShort,     uint256 rewardIndexFrom,     uint256 rewardIndexTo   ) internal view virtual returns (uint256 floatReward) {     if (amountStakedLong &gt; 0) {       uint256 accumDeltaLong = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexTo]       .accumulativeFloatPerSyntheticToken_long -         accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexFrom]         .accumulativeFloatPerSyntheticToken_long;       floatReward += (accumDeltaLong * amountStakedLong) / FLOAT_ISSUANCE_FIXED_DECIMAL;     } if (amountStakedShort &gt; 0) {   uint256 accumDeltaShort = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexTo]   .accumulativeFloatPerSyntheticToken_short -     accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexFrom]     .accumulativeFloatPerSyntheticToken_short;   floatReward += (accumDeltaShort * amountStakedShort) / FLOAT_ISSUANCE_FIXED_DECIMAL; }  } /*    @notice Calculates float owed to the user since the user last minted float for a market.   @param marketIndex Identifier for the market which the user staked in.   @param user The address of the user.   @return floatReward The amount of float owed.    /   function _calculateAccumulatedFloat(uint32 marketIndex, address user) internal virtual returns (uint256 floatReward) {     address longToken = syntheticTokens[marketIndex][true];     address shortToken = syntheticTokens[marketIndex][false]; uint256 amountStakedLong = userAmountStaked[longToken][user]; uint256 amountStakedShort = userAmountStaked[shortToken][user];  uint256 usersLastRewardIndex = userIndexOfLastClaimedReward[marketIndex][user];  // Don't do the calculation and return zero immediately if there is no change if (usersLastRewardIndex == latestRewardIndex[marketIndex]) {   return 0; }  uint256 usersShiftIndex = userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][user]; // if there is a change in the users tokens held due to a token shift (or possibly another action in the future) if (usersShiftIndex &gt; 0 &amp;&amp; usersShiftIndex &lt; batched_stakerNextTokenShiftIndex[marketIndex]) {   floatReward = _calculateAccumulatedFloatInRange(     marketIndex,     amountStakedLong,     amountStakedShort,     usersLastRewardIndex,     stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[usersShiftIndex]   );    // Update the users balances   if (userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user] &gt; 0) {     amountStakedShort += ILongShort(longShort).getAmountSyntheticTokenToMintOnTargetSide(       marketIndex,       userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user],       true,       stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[usersShiftIndex]     );      amountStakedLong -= userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user];     userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user] = 0;   }    if (userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user] &gt; 0) {     amountStakedLong += ILongShort(longShort).getAmountSyntheticTokenToMintOnTargetSide(       marketIndex,       userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user],       false,       stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[usersShiftIndex]     );      amountStakedShort -= userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user];     userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user] = 0;   }    // Save the users updated staked amounts   userAmountStaked[longToken][user] = amountStakedLong;   userAmountStaked[shortToken][user] = amountStakedShort;    floatReward += _calculateAccumulatedFloatInRange(     marketIndex,     amountStakedLong,     amountStakedShort,     stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[usersShiftIndex],     latestRewardIndex[marketIndex]   );    userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][user] = 0; } else {   floatReward = _calculateAccumulatedFloatInRange(     marketIndex,     amountStakedLong,     amountStakedShort,     usersLastRewardIndex,     latestRewardIndex[marketIndex]   ); }  } /*   @notice Mints float for a user.   @dev Mints a fixed percentage for Float capital.   @param user The address of the user.   @param floatToMint The amount of float to mint.    /   function _mintFloat(address user, uint256 floatToMint) internal virtual {     IFloatToken(floatToken).mint(user, floatToMint);     IFloatToken(floatToken).mint(floatCapital, (floatToMint * floatPercentage) / 1e18);   } /*   @notice Mints float owed to a user for a market since they last minted.   @param marketIndex An identifier for the market.   @param user The address of the user.    /   function _mintAccumulatedFloat(uint32 marketIndex, address user) internal virtual {     uint256 floatToMint = _calculateAccumulatedFloat(marketIndex, user); if (floatToMint &gt; 0) {   // Set the user has claimed up until now, stops them setting this forward   userIndexOfLastClaimedReward[marketIndex][user] = latestRewardIndex[marketIndex];    _mintFloat(user, floatToMint);   emit FloatMinted(user, marketIndex, floatToMint); }  } /*   @notice Mints float owed to a user for multiple markets, since they last minted for those markets.   @param marketIndexes Identifiers for the markets.   @param user The address of the user.    /   function _mintAccumulatedFloatMulti(uint32[] calldata marketIndexes, address user) internal virtual {     uint256 floatTotal = 0;     for (uint256 i = 0; i &lt; marketIndexes.length; i++) {       uint256 floatToMint = _calculateAccumulatedFloat(marketIndexes[i], user);   if (floatToMint &gt; 0) {     // Set the user has claimed up until now, stops them setting this forward     userIndexOfLastClaimedReward[marketIndexes[i]][user] = latestRewardIndex[marketIndexes[i]];      floatTotal += floatToMint;      emit FloatMinted(user, marketIndexes[i], floatToMint);   } } if (floatTotal &gt; 0) {   _mintFloat(user, floatTotal); }  } /*   @notice Mints outstanding float for msg.sender.   @param marketIndexes Identifiers for the markets for which to mint float.    /   function claimFloatCustom(uint32[] calldata marketIndexes) external {     ILongShort(longShort).updateSystemStateMulti(marketIndexes);     _mintAccumulatedFloatMulti(marketIndexes, msg.sender);   } /*   @notice Mints outstanding float on behalf of another user.   @param marketIndexes Identifiers for the markets for which to mint float.   @param user The address of the user.    /   function claimFloatCustomFor(uint32[] calldata marketIndexes, address user) external {     // Unbounded loop - users are responsible for paying their own gas costs on these and it doesn't effect the rest of the system.     // No need to impose limit.     ILongShort(longShort).updateSystemStateMulti(marketIndexes);     _mintAccumulatedFloatMulti(marketIndexes, user);   } /╔═══════════════════════╗     ║        STAKING        ║     ╚═══════════════════════╝/ /*   @notice A user with synthetic tokens stakes by calling stake on the token   contract which calls this function. We need to first update the   state of the LongShort contract for this market before staking to correctly calculate user rewards.   @param amount Amount to stake.   @param from Address to stake for.   /   function stakeFromUser(address from, uint256 amount) public virtual override onlyValidSynthetic((msg.sender)) {     ILongShort(longShort).updateSystemState(marketIndexOfToken[(msg.sender)]);     _stake((msg.sender), amount, from);   } /*   @dev Internal logic for staking.   @param token Address of the token for which to stake.   @param amount Amount to stake.   @param user Address to stake for.   /   function _stake(     address token,     uint256 amount,     address user   ) internal virtual {     uint32 marketIndex = marketIndexOfToken[token]; // If they already have staked and have rewards due, mint these. if (   userIndexOfLastClaimedReward[marketIndex][user] != 0 &amp;&amp;   userIndexOfLastClaimedReward[marketIndex][user] &lt; latestRewardIndex[marketIndex] ) {   _mintAccumulatedFloat(marketIndex, user); }  userAmountStaked[token][user] = userAmountStaked[token][user] + amount;  userIndexOfLastClaimedReward[marketIndex][user] = latestRewardIndex[marketIndex];  emit StakeAdded(user, address(token), amount, userIndexOfLastClaimedReward[marketIndex][user]);  } /*   @notice Allows users to shift their staked tokens from one side of the market to    the other at the next price.   @param amountSyntheticTokensToShift Amount of tokens to shift.   @param marketIndex Identifier for the market.   @param isShiftFromLong Whether the shift is from long to short or short to long.   /   function shiftTokens(     uint256 amountSyntheticTokensToShift,     uint32 marketIndex,     bool isShiftFromLong   ) external virtual {     address token = syntheticTokens[marketIndex][isShiftFromLong];     require(userAmountStaked[token][msg.sender] &gt;= amountSyntheticTokensToShift, "Not enough tokens to shift"); // If the user has outstanding token shift that have already been confirmed in the LongShort // contract, execute them first. if (   userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] != 0 &amp;&amp;   userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] &lt;   batched_stakerNextTokenShiftIndex[marketIndex] ) {   _mintAccumulatedFloat(marketIndex, msg.sender); }  if (isShiftFromLong) {   ILongShort(longShort).shiftPositionFromLongNextPrice(marketIndex, amountSyntheticTokensToShift);   userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][     msg.sender   ] += amountSyntheticTokensToShift; } else {   ILongShort(longShort).shiftPositionFromShortNextPrice(marketIndex, amountSyntheticTokensToShift);   userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][     msg.sender   ] += amountSyntheticTokensToShift; }  userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] = batched_stakerNextTokenShiftIndex[   marketIndex ];  } /╔════════════════════════════╗     ║    WITHDRAWAL &amp; MINTING    ║     ╚════════════════════════════╝/ /*   @notice Internal logic for withdrawing stakes.   @dev Mint user any outstanding float before withdrawing.   @param marketIndex Market index of token.   @param amount Amount to withdraw.   @param token Synthetic token that was staked.   /   function _withdraw(     uint32 marketIndex,     address token,     uint256 amount   ) internal virtual {     require(userAmountStaked[token][msg.sender] &gt; 0, "nothing to withdraw");     _mintAccumulatedFloat(marketIndex, msg.sender); userAmountStaked[token][msg.sender] = userAmountStaked[token][msg.sender] - amount;  uint256 amountFees = (amount * marketUnstakeFee_e18[marketIndex]) / 1e18;  IERC20(token).transfer(floatTreasury, amountFees); IERC20(token).transfer(msg.sender, amount - amountFees);  emit StakeWithdrawn(msg.sender, token, amount);  } /*   @notice Withdraw function. Allows users to unstake.   @param amount Amount to withdraw.   @param token Address of the token for which to withdraw.   /   function withdraw(address token, uint256 amount) external {     ILongShort(longShort).updateSystemState(marketIndexOfToken[token]); uint32 marketIndex = marketIndexOfToken[token];  _withdraw(marketIndex, token, amount);  if (userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] &gt; 0) {   // If they still have outstanding shifts after minting float, then check   // that they don't withdraw more than their shifts allow.   uint256 amountToShiftForThisToken = syntheticTokens[marketIndex][true] == token     ? userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][msg.sender]     : userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][msg.sender];    require(     userAmountStaked[token][msg.sender] &gt;= amountToShiftForThisToken,     "Outstanding next price stake shifts too great"   ); }  } /*   @notice Allows users to withdraw their entire stake for a token.   @param token Address of the token for which to withdraw.   /   function withdrawAll(address token) external {     ILongShort(longShort).updateSystemState(marketIndexOfToken[token]); uint32 marketIndex = marketIndexOfToken[token];  uint256 amountToShiftForThisToken = syntheticTokens[marketIndex][true] == token   ? userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][msg.sender]   : userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][msg.sender];  _withdraw(marketIndex, token, userAmountStaked[token][msg.sender] - amountToShiftForThisToken);  } } |
| **need_reflect** | False |
| **assistant_role_name** | Security Testing Engineer |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Below are the details of our target smart contract codes and their associated test reports: Task: "{task}". Existing Test Reports: "{test_reports}" Based on the given test reports, please identify and succinctly summarize all bugs causing issues within the contract codes. The objective is to obtain a clear and consolidated overview of all identified bugs. Conclude with a comprehensive test report summarizing the findings. |
| **phase_name** | TestBugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Testing Engineer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. Your can simulate various attack scenarios, conduct security testing, and perform code audits to identify vulnerablities and weaknesses in the smart contracts. This inculde analyzing potential exploit paths, assessing the resilience of the contract to common attack vectorsm and suggesting remediation measures Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'task': '// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.3;\n\nimport "@openzeppelin/contracts-upgradeable/token/ERC20/presets/ERC20PresetMinterPauserUpgradeable.sol";\n\nimport "./interfaces/IFloatToken.sol";\nimport "./interfaces/ILongShort.sol";\nimport "./interfaces/IStaker.sol";\nimport "./interfaces/ISyntheticToken.sol";\n\ncontract Staker is IStaker, Initializable {\n  /╔═════════════════════════════╗\n    ║          VARIABLES          ║\n    ╚═════════════════════════════╝/\n\n  / ══════ Fixed-precision constants ══════ /\n  uint256 public constant FLOAT_ISSUANCE_FIXED_DECIMAL = 1e42;\n  // 2^52 ~= 4.5e15\n  // With an exponent of 5, the largest total liquidity possible in a market (to avoid integer overflow on exponentiation) is ~10^31 or 10 Trillion (10^13)\n  // NOTE: this also means if the total market value is less than 2^52 there will be a division by zero error\n  uint256 public constant safeExponentBitShifting = 52;\n\n  / ══════ Global state ══════ /\n  address public admin;\n  address public floatCapital;\n  address public floatTreasury;\n  uint256 public floatPercentage;\n\n  address public longShort;\n  address public floatToken;\n\n  / ══════ Market specific ══════ /\n  mapping(uint32 =&gt; uint256) public marketLaunchIncentive_period; // seconds\n  mapping(uint32 =&gt; uint256) public marketLaunchIncentive_multipliers; // e18 scale\n  mapping(uint32 =&gt; uint256) public marketUnstakeFee_e18;\n  mapping(uint32 =&gt; uint256) public balanceIncentiveCurve_exponent;\n  mapping(uint32 =&gt; int256) public balanceIncentiveCurve_equilibriumOffset;\n\n  mapping(uint32 =&gt; mapping(bool =&gt; address)) public syntheticTokens;\n\n  mapping(address =&gt; uint32) public marketIndexOfToken;\n\n  / ══════ Reward specific ══════ /\n  mapping(uint32 =&gt; uint256) public latestRewardIndex;\n  mapping(uint32 =&gt; mapping(uint256 =&gt; AccumulativeIssuancePerStakedSynthSnapshot))\n    public accumulativeFloatPerSyntheticTokenSnapshots;\n  struct AccumulativeIssuancePerStakedSynthSnapshot {\n    uint256 timestamp;\n    uint256 accumulativeFloatPerSyntheticToken_long;\n    uint256 accumulativeFloatPerSyntheticToken_short;\n  }\n\n  / ══════ User specific ══════ /\n  mapping(uint32 =&gt; mapping(address =&gt; uint256)) public userIndexOfLastClaimedReward;\n  mapping(address =&gt; mapping(address =&gt; uint256)) public userAmountStaked;\n\n  / ══════ Token shift management specific ══════ /\n  mapping(uint32 =&gt; uint256) public batched_stakerNextTokenShiftIndex;\n  /\n  @notice Used to link a token shift to a staker state\n  @dev tokenShiftIndex =&gt; accumulativeFloatIssuanceSnapshotIndex\n    POSSIBLE OPTIMIZATION - could pack stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping and stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping into a struct of two uint128 for storage space optimization.\n  /\n  mapping(uint256 =&gt; uint256) public stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping;\n  /// @notice Used to fetch the price from LongShort at that point in time\n  /// @dev tokenShiftIndex =&gt; longShortMarketPriceSnapshotIndex\n  mapping(uint256 =&gt; uint256) public stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping;\n  /// @dev marketIndex =&gt; usersAddress =&gt; stakerTokenShiftIndex\n  mapping(uint32 =&gt; mapping(address =&gt; uint256)) public userNextPrice_stakedSyntheticTokenShiftIndex;\n  /// @dev marketIndex =&gt; usersAddress =&gt; amountUserRequestedToShiftAwayFromLongOnNextUpdate\n  mapping(uint32 =&gt; mapping(address =&gt; uint256)) public userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long;\n  /// @dev marketIndex =&gt; usersAddress =&gt; amountUserRequestedToShiftAwayFromShortOnNextUpdate\n  mapping(uint32 =&gt; mapping(address =&gt; uint256)) public userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short;\n\n  /╔════════════════════════════╗\n    ║           EVENTS           ║\n    ╚════════════════════════════╝/\n\n  event StakerV1(\n    address admin,\n    address floatTreasury,\n    address floatCapital,\n    address floatToken,\n    uint256 floatPercentage\n  );\n\n  event MarketAddedToStaker(\n    uint32 marketIndex,\n    uint256 exitFee_e18,\n    uint256 period,\n    uint256 multiplier,\n    uint256 balanceIncentiveExponent,\n    int256 balanceIncentiveEquilibriumOffset\n  );\n\n  event AccumulativeIssuancePerStakedSynthSnapshotCreated(\n    uint32 marketIndex,\n    uint256 accumulativeFloatIssuanceSnapshotIndex,\n    uint256 accumulativeLong,\n    uint256 accumulativeShort\n  );\n\n  event StakeAdded(address user, address token, uint256 amount, uint256 lastMintIndex);\n\n  event StakeWithdrawn(address user, address token, uint256 amount);\n\n  // Note: the amountFloatMinted isn\'t strictly needed by the graph, but it is good to add it to validate calculations are accurate.\n  event FloatMinted(address user, uint32 marketIndex, uint256 amountFloatMinted);\n\n  event MarketLaunchIncentiveParametersChanges(uint32 marketIndex, uint256 period, uint256 multiplier);\n\n  event StakeWithdrawalFeeUpdated(uint32 marketIndex, uint256 stakeWithdralFee);\n\n  event BalanceIncentiveExponentUpdated(uint32 marketIndex, uint256 balanceIncentiveExponent);\n\n  event BalanceIncentiveEquilibriumOffsetUpdated(uint32 marketIndex, int256 balanceIncentiveEquilibriumOffset);\n\n  event FloatPercentageUpdated(uint256 floatPercentage);\n\n  event SyntheticTokensShifted();\n\n  event ChangeAdmin(address newAdmin);\n\n  /╔═════════════════════════════╗\n    ║          MODIFIERS          ║\n    ╚═════════════════════════════╝/\n\n  function onlyAdminModifierLogic() internal virtual {\n    require(msg.sender == admin, "not admin");\n  }\n\n  modifier onlyAdmin() {\n    onlyAdminModifierLogic();\n    ;\n  }\n\n  function onlyValidSyntheticModifierLogic(address _synth) internal virtual {\n    require(marketIndexOfToken[_synth] != 0, "not valid synth");\n  }\n\n  modifier onlyValidSynthetic(address _synth) {\n    onlyValidSyntheticModifierLogic(_synth);\n    ;\n  }\n\n  function onlyValidMarketModifierLogic(uint32 marketIndex) internal virtual {\n    require(address(syntheticTokens[marketIndex][true]) != address(0), "not valid market");\n  }\n\n  modifier onlyValidMarket(uint32 marketIndex) {\n    onlyValidMarketModifierLogic(marketIndex);\n    ;\n  }\n\n  function onlyLongShortModifierLogic() internal virtual {\n    require(msg.sender == address(longShort), "not long short");\n  }\n\n  modifier onlyLongShort() {\n    onlyLongShortModifierLogic();\n    ;\n  }\n\n  /╔═════════════════════════════╗\n    ║       CONTRACT SET-UP       ║\n    ╚═════════════════════════════╝*/\n\n  /\n  @notice Initializes the contract.\n  @dev Calls OpenZeppelin\'s initializer modifier.\n  @param _admin Address of the admin role.\n  @param _longShort Address of the LongShort contract, a deployed LongShort.sol\n  @param _floatToken Address of the Float token earned by staking.\n  @param _floatTreasury Address of the treasury contract for managing fees.\n  @param _floatCapital Address of the contract which earns a fixed percentage of Float.\n  @param _floatPercentage Determines the float percentage that gets minted for Float Capital, base 1e18.\n  /\n  function initialize(\n    address _admin,\n    address _longShort,\n    address _floatToken,\n    address _floatTreasury,\n    address _floatCapital,\n    uint256 _floatPercentage\n  ) external virtual initializer {\n    admin = _admin;\n    floatCapital = _floatCapital;\n    floatTreasury = _floatTreasury;\n    longShort = _longShort;\n    floatToken = _floatToken;\n\n    _changeFloatPercentage(_floatPercentage);\n\n    emit StakerV1(_admin, _floatTreasury, _floatCapital, _floatToken, _floatPercentage);\n  }\n\n  /╔═══════════════════╗\n    ║       ADMIN       ║\n    ╚═══════════════════╝/\n\n  / \n  @notice Changes admin for the contract\n  @param _admin The address of the new admin.\n  /\n  function changeAdmin(address _admin) external onlyAdmin {\n    admin = _admin;\n    emit ChangeAdmin(_admin);\n  }\n\n  /// @dev Logic for changeFloatPercentage\n  function _changeFloatPercentage(uint256 newFloatPercentage) internal virtual {\n    require(newFloatPercentage &lt;= 1e18 &amp;&amp; newFloatPercentage &gt; 0); // less than or equal to 100% and greater than 0%\n    floatPercentage = newFloatPercentage;\n  }\n\n  /\n  @notice Changes percentage of float that is minted for float capital.\n  @param newFloatPercentage The new float percentage in base 1e18.\n  */\n  function changeFloatPercentage(uint256 newFloatPercentage) external onlyAdmin {\n    _changeFloatPercentage(newFloatPercentage);\n    emit FloatPercentageUpdated(newFloatPercentage);\n  }\n\n  /// @dev Logic for changeUnstakeFee\n  function _changeUnstakeFee(uint32 marketIndex, uint256 newMarketUnstakeFee_e18) internal virtual {\n    require(newMarketUnstakeFee_e18 &lt;= 5e16); // Explicitely stating 5% fee as the max fee possible.\n    marketUnstakeFee_e18[marketIndex] = newMarketUnstakeFee_e18;\n  }\n\n  /\n  @notice Changes unstake fee for a market\n  @param marketIndex Identifies the market.\n  @param newMarketUnstakeFee_e18 The new unstake fee.\n  /\n  function changeUnstakeFee(uint32 marketIndex, uint256 newMarketUnstakeFee_e18) external onlyAdmin {\n    _changeUnstakeFee(marketIndex, newMarketUnstakeFee_e18);\n    emit StakeWithdrawalFeeUpdated(marketIndex, newMarketUnstakeFee_e18);\n  }\n\n  /// @dev Logic for changeMarketLaunchIncentiveParameters\n  function _changeMarketLaunchIncentiveParameters(\n    uint32 marketIndex,\n    uint256 period,\n    uint256 initialMultiplier\n  ) internal virtual {\n    require(initialMultiplier &gt;= 1e18, "marketLaunchIncentiveMultiplier must be &gt;= 1e18");\n\n    marketLaunchIncentive_period[marketIndex] = period;\n    marketLaunchIncentive_multipliers[marketIndex] = initialMultiplier;\n  }\n\n  /\n  @notice Changes the market launch incentive parameters for a market\n  @param marketIndex Identifies the market.\n  @param period The new period for which float token generation should be boosted.\n  @param initialMultiplier The new multiplier on Float generation.\n  /\n  function changeMarketLaunchIncentiveParameters(\n    uint32 marketIndex,\n    uint256 period,\n    uint256 initialMultiplier\n  ) external onlyAdmin {\n    _changeMarketLaunchIncentiveParameters(marketIndex, period, initialMultiplier);\n\n    emit MarketLaunchIncentiveParametersChanges(marketIndex, period, initialMultiplier);\n  }\n\n  /// @dev Logic for changeBalanceIncentiveExponent\n  function _changeBalanceIncentiveExponent(uint32 marketIndex, uint256 _balanceIncentiveCurve_exponent)\n    internal\n    virtual\n  {\n    require(\n      // The exponent has to be less than 5 in these versions of the contracts.\n      _balanceIncentiveCurve_exponent &gt; 0 &amp;&amp; _balanceIncentiveCurve_exponent &lt; 6,\n      "balanceIncentiveCurve_exponent out of bounds"\n    );\n\n    balanceIncentiveCurve_exponent[marketIndex] = _balanceIncentiveCurve_exponent;\n  }\n\n  / \n  @notice Changes the balance incentive exponent for a market\n  @param marketIndex Identifies the market.\n  @param _balanceIncentiveCurve_exponent The new exponent for the curve.\n  */\n  function changeBalanceIncentiveExponent(uint32 marketIndex, uint256 _balanceIncentiveCurve_exponent)\n    external\n    onlyAdmin\n  {\n    _changeBalanceIncentiveExponent(marketIndex, _balanceIncentiveCurve_exponent);\n\n    emit BalanceIncentiveExponentUpdated(marketIndex, _balanceIncentiveCurve_exponent);\n  }\n\n  /// @dev Logic for changeBalanceIncentiveEquilibriumOffset\n  function _changeBalanceIncentiveEquilibriumOffset(uint32 marketIndex, int256 _balanceIncentiveCurve_equilibriumOffset)\n    internal\n    virtual\n  {\n    // Unreasonable that we would ever shift this more than 90% either way\n    require(\n      _balanceIncentiveCurve_equilibriumOffset &gt; -9e17 &amp;&amp; _balanceIncentiveCurve_equilibriumOffset &lt; 9e17,\n      "balanceIncentiveCurve_equilibriumOffset out of bounds"\n    );\n\n    balanceIncentiveCurve_equilibriumOffset[marketIndex] = _balanceIncentiveCurve_equilibriumOffset;\n  }\n\n  /\n  @notice Changes the balance incentive curve equilibrium offset for a market\n  @param marketIndex Identifies the market.\n  @param _balanceIncentiveCurve_equilibriumOffset The new offset.\n  /\n  function changeBalanceIncentiveEquilibriumOffset(uint32 marketIndex, int256 _balanceIncentiveCurve_equilibriumOffset)\n    external\n    onlyAdmin\n  {\n    _changeBalanceIncentiveEquilibriumOffset(marketIndex, _balanceIncentiveCurve_equilibriumOffset);\n\n    emit BalanceIncentiveEquilibriumOffsetUpdated(marketIndex, _balanceIncentiveCurve_equilibriumOffset);\n  }\n\n  /╔═════════════════════════════╗\n    ║        STAKING SETUP        ║\n    ╚═════════════════════════════╝/\n\n  /\n  @notice Sets this contract to track staking for a market in LongShort.sol\n  @param marketIndex Identifies the market.\n  @param longToken Address of the long token for the market.\n  @param shortToken Address of the short token for the market.\n  @param kInitialMultiplier Initial boost on float generation for the market.\n  @param kPeriod Period which the boost should last.\n  @param unstakeFee_e18 Percentage of tokens that are levied on unstaking in base 1e18.\n  @param _balanceIncentiveCurve_exponent Exponent for balance curve (see _calculateFloatPerSecond)\n  @param _balanceIncentiveCurve_equilibriumOffset Offset for balance curve (see _calculateFloatPerSecond)\n  /\n  function addNewStakingFund(\n    uint32 marketIndex,\n    address longToken,\n    address shortToken,\n    uint256 kInitialMultiplier,\n    uint256 kPeriod,\n    uint256 unstakeFee_e18,\n    uint256 _balanceIncentiveCurve_exponent,\n    int256 _balanceIncentiveCurve_equilibriumOffset\n  ) external override onlyLongShort {\n    marketIndexOfToken[longToken] = marketIndex;\n    marketIndexOfToken[shortToken] = marketIndex;\n\n    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].timestamp = block.timestamp;\n    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].accumulativeFloatPerSyntheticToken_long = 0;\n    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].accumulativeFloatPerSyntheticToken_short = 0;\n\n    syntheticTokens[marketIndex][true] = longToken;\n    syntheticTokens[marketIndex][false] = shortToken;\n\n    _changeBalanceIncentiveExponent(marketIndex, _balanceIncentiveCurve_exponent);\n    _changeBalanceIncentiveEquilibriumOffset(marketIndex, _balanceIncentiveCurve_equilibriumOffset);\n    _changeMarketLaunchIncentiveParameters(marketIndex, kPeriod, kInitialMultiplier);\n\n    _changeUnstakeFee(marketIndex, unstakeFee_e18);\n\n    // Set this value to one initially - 0 is a null value and thus potentially bug prone.\n    batched_stakerNextTokenShiftIndex[marketIndex] = 1;\n\n    emit MarketAddedToStaker(\n      marketIndex,\n      unstakeFee_e18,\n      kPeriod,\n      kInitialMultiplier,\n      _balanceIncentiveCurve_exponent,\n      _balanceIncentiveCurve_equilibriumOffset\n    );\n\n    emit AccumulativeIssuancePerStakedSynthSnapshotCreated(marketIndex, 0, 0, 0);\n  }\n\n  /╔═════════════════════════════════════════════════════════════════════════╗\n    ║    GLOBAL FLT REWARD ACCUMULATION CALCULATION AND TRACKING FUNCTIONS    ║\n    ╚═════════════════════════════════════════════════════════════════════════╝/\n\n  /\n  @notice Returns the K factor parameters for the given market with sensible\n  defaults if they haven\'t been set yet.\n  @param marketIndex The market to change the parameters for.\n  @return period The period for which the k factor applies for in seconds.\n  @return multiplier The multiplier on Float generation in this period.\n  */\n  function _getMarketLaunchIncentiveParameters(uint32 marketIndex)\n    internal\n    view\n    virtual\n    returns (uint256 period, uint256 multiplier)\n  {\n    period = marketLaunchIncentive_period[marketIndex];\n    multiplier = marketLaunchIncentive_multipliers[marketIndex];\n\n    if (multiplier &lt; 1e18) {\n      multiplier = 1e18; // multiplier of 1 by default\n    }\n  }\n\n  / \n  @notice Returns the extent to which a markets float generation should be adjusted\n  based on the market\'s launch incentive parameters. Should start at multiplier\n  then linearly change to 1e18 over time.\n  @param marketIndex Identifies the market.\n  @return k The calculated modifier for float generation.\n  /\n  function _getKValue(uint32 marketIndex) internal view virtual returns (uint256) {\n    // Parameters controlling the float issuance multiplier.\n    (uint256 kPeriod, uint256 kInitialMultiplier) = _getMarketLaunchIncentiveParameters(marketIndex);\n\n    // Sanity check - under normal circumstances, the multipliers should\n    // never be set to a value &lt; 1e18, as there are guards against this.\n    assert(kInitialMultiplier &gt;= 1e18);\n\n    uint256 initialTimestamp = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].timestamp;\n\n    if (block.timestamp - initialTimestamp &lt;= kPeriod) {\n      return kInitialMultiplier - (((kInitialMultiplier - 1e18) * (block.timestamp - initialTimestamp)) / kPeriod);\n    } else {\n      return 1e18;\n    }\n  }\n\n  /\n  @notice Computes the number of float tokens a user earns per second for\n  every long/short synthetic token they\'ve staked. The returned value has\n  a fixed decimal scale of 1e42 (!!!) for numerical stability. The return\n  values are float per second per synthetic token (hence the requirement\n  to multiply by price)\n  @dev to see below math in latex form see TODO add link\n  to interact with the equations see https://www.desmos.com/calculator/optkaxyihr\n  @param marketIndex The market referred to.\n  @param longPrice Price of the synthetic long token in units of payment token\n  @param shortPrice Price of the synthetic short token in units of payment token\n  @param longValue Amount of payment token in the long side of the market\n  @param shortValue Amount of payment token in the short side of the market\n  @return longFloatPerSecond Float token per second per long synthetic token\n  @return shortFloatPerSecond Float token per second per short synthetic token\n   /\n  function _calculateFloatPerSecond(\n    uint32 marketIndex,\n    uint256 longPrice,\n    uint256 shortPrice,\n    uint256 longValue,\n    uint256 shortValue\n  ) internal view virtual returns (uint256 longFloatPerSecond, uint256 shortFloatPerSecond) {\n    // A float issuance multiplier that starts high and decreases linearly\n    // over time to a value of 1. This incentivises users to stake early.\n    uint256 k = _getKValue(marketIndex);\n\n    uint256 totalLocked = (longValue + shortValue);\n\n    // we need to scale this number by the totalLocked so that the offset remains consistent accross market size\n\n    int256 equilibriumOffsetMarketScaled = (balanceIncentiveCurve_equilibriumOffset[marketIndex] \n      int256(totalLocked)) / 2e18;\n\n    uint256 denominator = ((totalLocked &gt;&gt; safeExponentBitShifting)balanceIncentiveCurve_exponent[marketIndex]);\n\n    // Float is scaled by the percentage of the total market value held in\n    // the opposite position. This incentivises users to stake on the\n    // weaker position.\n    if (int256(shortValue) - equilibriumOffsetMarketScaled &lt; int256(longValue)) {\n      if (equilibriumOffsetMarketScaled &gt;= int256(shortValue)) {\n        // edge case: imbalanced far past the equilibrium offset - full rewards go to short token\n        //            extremeley unlikely to happen in practice\n        return (0, 1e18 * k * shortPrice);\n      }\n\n      uint256 numerator = (uint256(int256(shortValue) - equilibriumOffsetMarketScaled) &gt;&gt;\n        (safeExponentBitShifting - 1))balanceIncentiveCurve_exponent[marketIndex];\n\n      // NOTE: x * 5e17 == (x * 10e18) / 2\n      uint256 longRewardUnscaled = (numerator * 5e17) / denominator;\n      uint256 shortRewardUnscaled = 1e18 - longRewardUnscaled;\n\n      return ((longRewardUnscaled * k * longPrice) / 1e18, (shortRewardUnscaled * k * shortPrice) / 1e18);\n    } else {\n      if (-equilibriumOffsetMarketScaled &gt;= int256(longValue)) {\n        // edge case: imbalanced far past the equilibrium offset - full rewards go to long token\n        //            extremeley unlikely to happen in practice\n        return (1e18 * k * longPrice, 0);\n      }\n\n      uint256 numerator = (uint256(int256(longValue) + equilibriumOffsetMarketScaled) &gt;&gt;\n        (safeExponentBitShifting - 1))balanceIncentiveCurve_exponent[marketIndex];\n\n      // NOTE: x * 5e17 == (x * 10e18) / 2\n      uint256 shortRewardUnscaled = (numerator * 5e17) / denominator;\n      uint256 longRewardUnscaled = 1e18 - shortRewardUnscaled;\n\n      return ((longRewardUnscaled * k * longPrice) / 1e18, (shortRewardUnscaled * k * shortPrice) / 1e18);\n    }\n  }\n\n  /\n  @notice Computes the time since last accumulativeIssuancePerStakedSynthSnapshot for the given market in seconds.\n  @param marketIndex The market referred to.\n  @return The time difference in seconds\n  /\n  function _calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(uint32 marketIndex)\n    internal\n    view\n    virtual\n    returns (uint256)\n  {\n    return\n      block.timestamp -\n      accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]].timestamp;\n  }\n\n  /\n  @notice Computes new cumulative sum of \'r\' value since last accumulativeIssuancePerStakedSynthSnapshot. We use\n  cumulative \'r\' value to avoid looping during issuance. Note that the\n  cumulative sum is kept in 1e42 scale (!!!) to avoid numerical issues.\n  @param shortValue The value locked in the short side of the market.\n  @param longValue The value locked in the long side of the market.\n  @param shortPrice The price of the short token as defined in LongShort.sol\n  @param longPrice The price of the long token as defined in LongShort.sol\n  @param marketIndex An identifier for the market.\n  @return longCumulativeRates The long cumulative sum.\n  @return shortCumulativeRates The short cumulative sum.\n  /\n  function _calculateNewCumulativeIssuancePerStakedSynth(\n    uint32 marketIndex,\n    uint256 longPrice,\n    uint256 shortPrice,\n    uint256 longValue,\n    uint256 shortValue\n  ) internal view virtual returns (uint256 longCumulativeRates, uint256 shortCumulativeRates) {\n    // Compute the current \'r\' value for float issuance per second.\n    (uint256 longFloatPerSecond, uint256 shortFloatPerSecond) = _calculateFloatPerSecond(\n      marketIndex,\n      longPrice,\n      shortPrice,\n      longValue,\n      shortValue\n    );\n\n    // Compute time since last accumulativeIssuancePerStakedSynthSnapshot for the given token.\n    uint256 timeDelta = _calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(marketIndex);\n\n    // Compute new cumulative \'r\' value total.\n    return (\n      accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]]\n      .accumulativeFloatPerSyntheticToken_long + (timeDelta * longFloatPerSecond),\n      accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]]\n      .accumulativeFloatPerSyntheticToken_short + (timeDelta * shortFloatPerSecond)\n    );\n  }\n\n  /\n  @notice Creates a new accumulativeIssuancePerStakedSynthSnapshot for the given token and updates indexes.\n  @param shortValue The value locked in the short side of the market.\n  @param longValue The value locked in the long side of the market.\n  @param shortPrice The price of the short token as defined in LongShort.sol\n  @param longPrice The price of the long token as defined in LongShort.sol\n  @param marketIndex An identifier for the market.\n  */\n  function _setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot(\n    uint32 marketIndex,\n    uint256 longPrice,\n    uint256 shortPrice,\n    uint256 longValue,\n    uint256 shortValue\n  ) internal virtual {\n    (\n      uint256 newLongAccumulativeValue,\n      uint256 newShortAccumulativeValue\n    ) = _calculateNewCumulativeIssuancePerStakedSynth(marketIndex, longPrice, shortPrice, longValue, shortValue);\n\n    uint256 newIndex = latestRewardIndex[marketIndex] + 1;\n\n    // Set cumulative \'r\' value on new accumulativeIssuancePerStakedSynthSnapshot.\n    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex]\n    .accumulativeFloatPerSyntheticToken_long = newLongAccumulativeValue;\n    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex]\n    .accumulativeFloatPerSyntheticToken_short = newShortAccumulativeValue;\n\n    // Set timestamp on new accumulativeIssuancePerStakedSynthSnapshot.\n    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex].timestamp = block.timestamp;\n\n    // Update latest index to point to new accumulativeIssuancePerStakedSynthSnapshot.\n    latestRewardIndex[marketIndex] = newIndex;\n\n    emit AccumulativeIssuancePerStakedSynthSnapshotCreated(\n      marketIndex,\n      newIndex,\n      newLongAccumulativeValue,\n      newShortAccumulativeValue\n    );\n  }\n\n  /\n  @notice Adds new accumulativeIssuancePerStakedSynthSnapshots for the given long/short tokens. Called by the\n  ILongShort contract whenever there is a state change for a market.\n  @param stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted Mapping from this contract\'s shifts to LongShort.sols next price snapshots.\n  @param shortValue The value locked in the short side of the market.\n  @param longValue The value locked in the long side of the market.\n  @param shortPrice The price of the short token as defined in LongShort.sol\n  @param longPrice The price of the long token as defined in LongShort.sol\n  @param marketIndex An identifier for the market.\n  /\n  function pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(\n    uint32 marketIndex,\n    uint256 longPrice,\n    uint256 shortPrice,\n    uint256 longValue,\n    uint256 shortValue,\n    uint256 stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted // This value should be ALWAYS be zero if no shift occured\n  ) external override onlyLongShort {\n    // Only add a new accumulativeIssuancePerStakedSynthSnapshot if some time has passed.\n\n    // the stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted value will be 0 if there is no staker related action in an executed batch\n    if (stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted &gt; 0) {\n      stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[\n        batched_stakerNextTokenShiftIndex[marketIndex]\n      ] = stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted;\n      stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[\n        batched_stakerNextTokenShiftIndex[marketIndex]\n      ] = latestRewardIndex[marketIndex] + 1;\n      batched_stakerNextTokenShiftIndex[marketIndex] += 1;\n\n      emit SyntheticTokensShifted();\n    }\n\n    // Time delta is fetched twice in below code, can pass through? Which is less gas?\n    if (_calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(marketIndex) &gt; 0) {\n      _setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot(\n        marketIndex,\n        longPrice,\n        shortPrice,\n        longValue,\n        shortValue\n      );\n    }\n  }\n\n  /╔═══════════════════════════════════╗\n    ║    USER REWARD STATE FUNCTIONS    ║\n    ╚═══════════════════════════════════╝/\n\n  /// @dev Calculates the accumulated float in a specific range of staker snapshots\n  function _calculateAccumulatedFloatInRange(\n    uint32 marketIndex,\n    uint256 amountStakedLong,\n    uint256 amountStakedShort,\n    uint256 rewardIndexFrom,\n    uint256 rewardIndexTo\n  ) internal view virtual returns (uint256 floatReward) {\n    if (amountStakedLong &gt; 0) {\n      uint256 accumDeltaLong = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexTo]\n      .accumulativeFloatPerSyntheticToken_long -\n        accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexFrom]\n        .accumulativeFloatPerSyntheticToken_long;\n      floatReward += (accumDeltaLong * amountStakedLong) / FLOAT_ISSUANCE_FIXED_DECIMAL;\n    }\n\n    if (amountStakedShort &gt; 0) {\n      uint256 accumDeltaShort = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexTo]\n      .accumulativeFloatPerSyntheticToken_short -\n        accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexFrom]\n        .accumulativeFloatPerSyntheticToken_short;\n      floatReward += (accumDeltaShort * amountStakedShort) / FLOAT_ISSUANCE_FIXED_DECIMAL;\n    }\n  }\n\n  / \n  @notice Calculates float owed to the user since the user last minted float for a market.\n  @param marketIndex Identifier for the market which the user staked in.\n  @param user The address of the user.\n  @return floatReward The amount of float owed.\n   /\n  function _calculateAccumulatedFloat(uint32 marketIndex, address user) internal virtual returns (uint256 floatReward) {\n    address longToken = syntheticTokens[marketIndex][true];\n    address shortToken = syntheticTokens[marketIndex][false];\n\n    uint256 amountStakedLong = userAmountStaked[longToken][user];\n    uint256 amountStakedShort = userAmountStaked[shortToken][user];\n\n    uint256 usersLastRewardIndex = userIndexOfLastClaimedReward[marketIndex][user];\n\n    // Don\'t do the calculation and return zero immediately if there is no change\n    if (usersLastRewardIndex == latestRewardIndex[marketIndex]) {\n      return 0;\n    }\n\n    uint256 usersShiftIndex = userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][user];\n    // if there is a change in the users tokens held due to a token shift (or possibly another action in the future)\n    if (usersShiftIndex &gt; 0 &amp;&amp; usersShiftIndex &lt; batched_stakerNextTokenShiftIndex[marketIndex]) {\n      floatReward = _calculateAccumulatedFloatInRange(\n        marketIndex,\n        amountStakedLong,\n        amountStakedShort,\n        usersLastRewardIndex,\n        stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[usersShiftIndex]\n      );\n\n      // Update the users balances\n      if (userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user] &gt; 0) {\n        amountStakedShort += ILongShort(longShort).getAmountSyntheticTokenToMintOnTargetSide(\n          marketIndex,\n          userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user],\n          true,\n          stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[usersShiftIndex]\n        );\n\n        amountStakedLong -= userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user];\n        userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user] = 0;\n      }\n\n      if (userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user] &gt; 0) {\n        amountStakedLong += ILongShort(longShort).getAmountSyntheticTokenToMintOnTargetSide(\n          marketIndex,\n          userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user],\n          false,\n          stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[usersShiftIndex]\n        );\n\n        amountStakedShort -= userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user];\n        userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user] = 0;\n      }\n\n      // Save the users updated staked amounts\n      userAmountStaked[longToken][user] = amountStakedLong;\n      userAmountStaked[shortToken][user] = amountStakedShort;\n\n      floatReward += _calculateAccumulatedFloatInRange(\n        marketIndex,\n        amountStakedLong,\n        amountStakedShort,\n        stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[usersShiftIndex],\n        latestRewardIndex[marketIndex]\n      );\n\n      userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][user] = 0;\n    } else {\n      floatReward = _calculateAccumulatedFloatInRange(\n        marketIndex,\n        amountStakedLong,\n        amountStakedShort,\n        usersLastRewardIndex,\n        latestRewardIndex[marketIndex]\n      );\n    }\n  }\n\n  /\n  @notice Mints float for a user.\n  @dev Mints a fixed percentage for Float capital.\n  @param user The address of the user.\n  @param floatToMint The amount of float to mint.\n   */\n  function _mintFloat(address user, uint256 floatToMint) internal virtual {\n    IFloatToken(floatToken).mint(user, floatToMint);\n    IFloatToken(floatToken).mint(floatCapital, (floatToMint * floatPercentage) / 1e18);\n  }\n\n  /\n  @notice Mints float owed to a user for a market since they last minted.\n  @param marketIndex An identifier for the market.\n  @param user The address of the user.\n   /\n  function _mintAccumulatedFloat(uint32 marketIndex, address user) internal virtual {\n    uint256 floatToMint = _calculateAccumulatedFloat(marketIndex, user);\n\n    if (floatToMint &gt; 0) {\n      // Set the user has claimed up until now, stops them setting this forward\n      userIndexOfLastClaimedReward[marketIndex][user] = latestRewardIndex[marketIndex];\n\n      _mintFloat(user, floatToMint);\n      emit FloatMinted(user, marketIndex, floatToMint);\n    }\n  }\n\n  /\n  @notice Mints float owed to a user for multiple markets, since they last minted for those markets.\n  @param marketIndexes Identifiers for the markets.\n  @param user The address of the user.\n   /\n  function _mintAccumulatedFloatMulti(uint32[] calldata marketIndexes, address user) internal virtual {\n    uint256 floatTotal = 0;\n    for (uint256 i = 0; i &lt; marketIndexes.length; i++) {\n      uint256 floatToMint = _calculateAccumulatedFloat(marketIndexes[i], user);\n\n      if (floatToMint &gt; 0) {\n        // Set the user has claimed up until now, stops them setting this forward\n        userIndexOfLastClaimedReward[marketIndexes[i]][user] = latestRewardIndex[marketIndexes[i]];\n\n        floatTotal += floatToMint;\n\n        emit FloatMinted(user, marketIndexes[i], floatToMint);\n      }\n    }\n    if (floatTotal &gt; 0) {\n      _mintFloat(user, floatTotal);\n    }\n  }\n\n  /\n  @notice Mints outstanding float for msg.sender.\n  @param marketIndexes Identifiers for the markets for which to mint float.\n   */\n  function claimFloatCustom(uint32[] calldata marketIndexes) external {\n    ILongShort(longShort).updateSystemStateMulti(marketIndexes);\n    _mintAccumulatedFloatMulti(marketIndexes, msg.sender);\n  }\n\n  /\n  @notice Mints outstanding float on behalf of another user.\n  @param marketIndexes Identifiers for the markets for which to mint float.\n  @param user The address of the user.\n   /\n  function claimFloatCustomFor(uint32[] calldata marketIndexes, address user) external {\n    // Unbounded loop - users are responsible for paying their own gas costs on these and it doesn\'t effect the rest of the system.\n    // No need to impose limit.\n    ILongShort(longShort).updateSystemStateMulti(marketIndexes);\n    _mintAccumulatedFloatMulti(marketIndexes, user);\n  }\n\n  /╔═══════════════════════╗\n    ║        STAKING        ║\n    ╚═══════════════════════╝/\n\n  /\n  @notice A user with synthetic tokens stakes by calling stake on the token\n  contract which calls this function. We need to first update the\n  state of the LongShort contract for this market before staking to correctly calculate user rewards.\n  @param amount Amount to stake.\n  @param from Address to stake for.\n  /\n  function stakeFromUser(address from, uint256 amount) public virtual override onlyValidSynthetic((msg.sender)) {\n    ILongShort(longShort).updateSystemState(marketIndexOfToken[(msg.sender)]);\n    _stake((msg.sender), amount, from);\n  }\n\n  /\n  @dev Internal logic for staking.\n  @param token Address of the token for which to stake.\n  @param amount Amount to stake.\n  @param user Address to stake for.\n  */\n  function _stake(\n    address token,\n    uint256 amount,\n    address user\n  ) internal virtual {\n    uint32 marketIndex = marketIndexOfToken[token];\n\n    // If they already have staked and have rewards due, mint these.\n    if (\n      userIndexOfLastClaimedReward[marketIndex][user] != 0 &amp;&amp;\n      userIndexOfLastClaimedReward[marketIndex][user] &lt; latestRewardIndex[marketIndex]\n    ) {\n      _mintAccumulatedFloat(marketIndex, user);\n    }\n\n    userAmountStaked[token][user] = userAmountStaked[token][user] + amount;\n\n    userIndexOfLastClaimedReward[marketIndex][user] = latestRewardIndex[marketIndex];\n\n    emit StakeAdded(user, address(token), amount, userIndexOfLastClaimedReward[marketIndex][user]);\n  }\n\n  /\n  @notice Allows users to shift their staked tokens from one side of the market to \n  the other at the next price.\n  @param amountSyntheticTokensToShift Amount of tokens to shift.\n  @param marketIndex Identifier for the market.\n  @param isShiftFromLong Whether the shift is from long to short or short to long.\n  /\n  function shiftTokens(\n    uint256 amountSyntheticTokensToShift,\n    uint32 marketIndex,\n    bool isShiftFromLong\n  ) external virtual {\n    address token = syntheticTokens[marketIndex][isShiftFromLong];\n    require(userAmountStaked[token][msg.sender] &gt;= amountSyntheticTokensToShift, "Not enough tokens to shift");\n\n    // If the user has outstanding token shift that have already been confirmed in the LongShort\n    // contract, execute them first.\n    if (\n      userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] != 0 &amp;&amp;\n      userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] &lt;\n      batched_stakerNextTokenShiftIndex[marketIndex]\n    ) {\n      _mintAccumulatedFloat(marketIndex, msg.sender);\n    }\n\n    if (isShiftFromLong) {\n      ILongShort(longShort).shiftPositionFromLongNextPrice(marketIndex, amountSyntheticTokensToShift);\n      userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][\n        msg.sender\n      ] += amountSyntheticTokensToShift;\n    } else {\n      ILongShort(longShort).shiftPositionFromShortNextPrice(marketIndex, amountSyntheticTokensToShift);\n      userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][\n        msg.sender\n      ] += amountSyntheticTokensToShift;\n    }\n\n    userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] = batched_stakerNextTokenShiftIndex[\n      marketIndex\n    ];\n  }\n\n  /╔════════════════════════════╗\n    ║    WITHDRAWAL &amp; MINTING    ║\n    ╚════════════════════════════╝/\n\n  /\n  @notice Internal logic for withdrawing stakes.\n  @dev Mint user any outstanding float before withdrawing.\n  @param marketIndex Market index of token.\n  @param amount Amount to withdraw.\n  @param token Synthetic token that was staked.\n  /\n  function _withdraw(\n    uint32 marketIndex,\n    address token,\n    uint256 amount\n  ) internal virtual {\n    require(userAmountStaked[token][msg.sender] &gt; 0, "nothing to withdraw");\n    _mintAccumulatedFloat(marketIndex, msg.sender);\n\n    userAmountStaked[token][msg.sender] = userAmountStaked[token][msg.sender] - amount;\n\n    uint256 amountFees = (amount * marketUnstakeFee_e18[marketIndex]) / 1e18;\n\n    IERC20(token).transfer(floatTreasury, amountFees);\n    IERC20(token).transfer(msg.sender, amount - amountFees);\n\n    emit StakeWithdrawn(msg.sender, token, amount);\n  }\n\n  /\n  @notice Withdraw function. Allows users to unstake.\n  @param amount Amount to withdraw.\n  @param token Address of the token for which to withdraw.\n  */\n  function withdraw(address token, uint256 amount) external {\n    ILongShort(longShort).updateSystemState(marketIndexOfToken[token]);\n\n    uint32 marketIndex = marketIndexOfToken[token];\n\n    _withdraw(marketIndex, token, amount);\n\n    if (userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] &gt; 0) {\n      // If they still have outstanding shifts after minting float, then check\n      // that they don\'t withdraw more than their shifts allow.\n      uint256 amountToShiftForThisToken = syntheticTokens[marketIndex][true] == token\n        ? userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][msg.sender]\n        : userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][msg.sender];\n\n      require(\n        userAmountStaked[token][msg.sender] &gt;= amountToShiftForThisToken,\n        "Outstanding next price stake shifts too great"\n      );\n    }\n  }\n\n  /\n  @notice Allows users to withdraw their entire stake for a token.\n  @param token Address of the token for which to withdraw.\n  */\n  function withdrawAll(address token) external {\n    ILongShort(longShort).updateSystemState(marketIndexOfToken[token]);\n\n    uint32 marketIndex = marketIndexOfToken[token];\n\n    uint256 amountToShiftForThisToken = syntheticTokens[marketIndex][true] == token\n      ? userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][msg.sender]\n      : userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][msg.sender];\n\n    _withdraw(marketIndex, token, userAmountStaked[token][msg.sender] - amountToShiftForThisToken);\n  }\n}\n', 'ideas': ' Security', 'test_reports': 'The software run successfully without errors.', 'exist_bugs_flag': False} |

[2024-17-08 08:02:14 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Testing Engineer |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Testing Engineer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. Your can simulate various attack scenarios, conduct security testing, and perform code audits to identify vulnerablities and weaknesses in the smart contracts. This inculde analyzing potential exploit paths, assessing the resilience of the contract to common attack vectorsm and suggesting remediation measures Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: BUSL-1.1 pragma solidity 0.8.3; import "@openzeppelin/contracts-upgradeable/token/ERC20/presets/ERC20PresetMinterPauserUpgradeable.sol"; import "./interfaces/IFloatToken.sol"; import "./interfaces/ILongShort.sol"; import "./interfaces/IStaker.sol"; import "./interfaces/ISyntheticToken.sol"; contract Staker is IStaker, Initializable {   /╔═════════════════════════════╗     ║          VARIABLES          ║     ╚═════════════════════════════╝/ / ══════ Fixed-precision constants ══════ /   uint256 public constant FLOAT_ISSUANCE_FIXED_DECIMAL = 1e42;   // 2^52 ~= 4.5e15   // With an exponent of 5, the largest total liquidity possible in a market (to avoid integer overflow on exponentiation) is ~10^31 or 10 Trillion (10^13)   // NOTE: this also means if the total market value is less than 2^52 there will be a division by zero error   uint256 public constant safeExponentBitShifting = 52; / ══════ Global state ══════ /   address public admin;   address public floatCapital;   address public floatTreasury;   uint256 public floatPercentage; address public longShort;   address public floatToken; / ══════ Market specific ══════ /   mapping(uint32 =&gt; uint256) public marketLaunchIncentive_period; // seconds   mapping(uint32 =&gt; uint256) public marketLaunchIncentive_multipliers; // e18 scale   mapping(uint32 =&gt; uint256) public marketUnstakeFee_e18;   mapping(uint32 =&gt; uint256) public balanceIncentiveCurve_exponent;   mapping(uint32 =&gt; int256) public balanceIncentiveCurve_equilibriumOffset; mapping(uint32 =&gt; mapping(bool =&gt; address)) public syntheticTokens; mapping(address =&gt; uint32) public marketIndexOfToken; / ══════ Reward specific ══════ /   mapping(uint32 =&gt; uint256) public latestRewardIndex;   mapping(uint32 =&gt; mapping(uint256 =&gt; AccumulativeIssuancePerStakedSynthSnapshot))     public accumulativeFloatPerSyntheticTokenSnapshots;   struct AccumulativeIssuancePerStakedSynthSnapshot {     uint256 timestamp;     uint256 accumulativeFloatPerSyntheticToken_long;     uint256 accumulativeFloatPerSyntheticToken_short;   } / ══════ User specific ══════ /   mapping(uint32 =&gt; mapping(address =&gt; uint256)) public userIndexOfLastClaimedReward;   mapping(address =&gt; mapping(address =&gt; uint256)) public userAmountStaked; / ══════ Token shift management specific ══════ /   mapping(uint32 =&gt; uint256) public batched_stakerNextTokenShiftIndex;   /*   @notice Used to link a token shift to a staker state   @dev tokenShiftIndex =&gt; accumulativeFloatIssuanceSnapshotIndex     POSSIBLE OPTIMIZATION - could pack stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping and stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping into a struct of two uint128 for storage space optimization.   /   mapping(uint256 =&gt; uint256) public stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping;   /// @notice Used to fetch the price from LongShort at that point in time   /// @dev tokenShiftIndex =&gt; longShortMarketPriceSnapshotIndex   mapping(uint256 =&gt; uint256) public stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping;   /// @dev marketIndex =&gt; usersAddress =&gt; stakerTokenShiftIndex   mapping(uint32 =&gt; mapping(address =&gt; uint256)) public userNextPrice_stakedSyntheticTokenShiftIndex;   /// @dev marketIndex =&gt; usersAddress =&gt; amountUserRequestedToShiftAwayFromLongOnNextUpdate   mapping(uint32 =&gt; mapping(address =&gt; uint256)) public userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long;   /// @dev marketIndex =&gt; usersAddress =&gt; amountUserRequestedToShiftAwayFromShortOnNextUpdate   mapping(uint32 =&gt; mapping(address =&gt; uint256)) public userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short; /╔════════════════════════════╗     ║           EVENTS           ║     ╚════════════════════════════╝/ event StakerV1(     address admin,     address floatTreasury,     address floatCapital,     address floatToken,     uint256 floatPercentage   ); event MarketAddedToStaker(     uint32 marketIndex,     uint256 exitFee_e18,     uint256 period,     uint256 multiplier,     uint256 balanceIncentiveExponent,     int256 balanceIncentiveEquilibriumOffset   ); event AccumulativeIssuancePerStakedSynthSnapshotCreated(     uint32 marketIndex,     uint256 accumulativeFloatIssuanceSnapshotIndex,     uint256 accumulativeLong,     uint256 accumulativeShort   ); event StakeAdded(address user, address token, uint256 amount, uint256 lastMintIndex); event StakeWithdrawn(address user, address token, uint256 amount); // Note: the amountFloatMinted isn't strictly needed by the graph, but it is good to add it to validate calculations are accurate.   event FloatMinted(address user, uint32 marketIndex, uint256 amountFloatMinted); event MarketLaunchIncentiveParametersChanges(uint32 marketIndex, uint256 period, uint256 multiplier); event StakeWithdrawalFeeUpdated(uint32 marketIndex, uint256 stakeWithdralFee); event BalanceIncentiveExponentUpdated(uint32 marketIndex, uint256 balanceIncentiveExponent); event BalanceIncentiveEquilibriumOffsetUpdated(uint32 marketIndex, int256 balanceIncentiveEquilibriumOffset); event FloatPercentageUpdated(uint256 floatPercentage); event SyntheticTokensShifted(); event ChangeAdmin(address newAdmin); /╔═════════════════════════════╗     ║          MODIFIERS          ║     ╚═════════════════════════════╝/ function onlyAdminModifierLogic() internal virtual {     require(msg.sender == admin, "not admin");   } modifier onlyAdmin() {     onlyAdminModifierLogic();     _;   } function onlyValidSyntheticModifierLogic(address _synth) internal virtual {     require(marketIndexOfToken[_synth] != 0, "not valid synth");   } modifier onlyValidSynthetic(address synth) {     onlyValidSyntheticModifierLogic(_synth);     ;   } function onlyValidMarketModifierLogic(uint32 marketIndex) internal virtual {     require(address(syntheticTokens[marketIndex][true]) != address(0), "not valid market");   } modifier onlyValidMarket(uint32 marketIndex) {     onlyValidMarketModifierLogic(marketIndex);     _;   } function onlyLongShortModifierLogic() internal virtual {     require(msg.sender == address(longShort), "not long short");   } modifier onlyLongShort() {     onlyLongShortModifierLogic();     _;   } /╔═════════════════════════════╗     ║       CONTRACT SET-UP       ║     ╚═════════════════════════════╝/ /*   @notice Initializes the contract.   @dev Calls OpenZeppelin's initializer modifier.   @param _admin Address of the admin role.   @param _longShort Address of the LongShort contract, a deployed LongShort.sol   @param _floatToken Address of the Float token earned by staking.   @param _floatTreasury Address of the treasury contract for managing fees.   @param _floatCapital Address of the contract which earns a fixed percentage of Float.   @param _floatPercentage Determines the float percentage that gets minted for Float Capital, base 1e18.   /   function initialize(     address _admin,     address _longShort,     address _floatToken,     address _floatTreasury,     address _floatCapital,     uint256 _floatPercentage   ) external virtual initializer {     admin = _admin;     floatCapital = _floatCapital;     floatTreasury = _floatTreasury;     longShort = _longShort;     floatToken = _floatToken; _changeFloatPercentage(_floatPercentage);  emit StakerV1(_admin, _floatTreasury, _floatCapital, _floatToken, _floatPercentage);  } /╔═══════════════════╗     ║       ADMIN       ║     ╚═══════════════════╝/ /*    @notice Changes admin for the contract   @param _admin The address of the new admin.   /   function changeAdmin(address _admin) external onlyAdmin {     admin = _admin;     emit ChangeAdmin(_admin);   } /// @dev Logic for changeFloatPercentage   function _changeFloatPercentage(uint256 newFloatPercentage) internal virtual {     require(newFloatPercentage &lt;= 1e18 &amp;&amp; newFloatPercentage &gt; 0); // less than or equal to 100% and greater than 0%     floatPercentage = newFloatPercentage;   } /*   @notice Changes percentage of float that is minted for float capital.   @param newFloatPercentage The new float percentage in base 1e18.   /   function changeFloatPercentage(uint256 newFloatPercentage) external onlyAdmin {     _changeFloatPercentage(newFloatPercentage);     emit FloatPercentageUpdated(newFloatPercentage);   } /// @dev Logic for changeUnstakeFee   function _changeUnstakeFee(uint32 marketIndex, uint256 newMarketUnstakeFee_e18) internal virtual {     require(newMarketUnstakeFee_e18 &lt;= 5e16); // Explicitely stating 5% fee as the max fee possible.     marketUnstakeFee_e18[marketIndex] = newMarketUnstakeFee_e18;   } /*   @notice Changes unstake fee for a market   @param marketIndex Identifies the market.   @param newMarketUnstakeFee_e18 The new unstake fee.   /   function changeUnstakeFee(uint32 marketIndex, uint256 newMarketUnstakeFee_e18) external onlyAdmin {     _changeUnstakeFee(marketIndex, newMarketUnstakeFee_e18);     emit StakeWithdrawalFeeUpdated(marketIndex, newMarketUnstakeFee_e18);   } /// @dev Logic for changeMarketLaunchIncentiveParameters   function _changeMarketLaunchIncentiveParameters(     uint32 marketIndex,     uint256 period,     uint256 initialMultiplier   ) internal virtual {     require(initialMultiplier &gt;= 1e18, "marketLaunchIncentiveMultiplier must be &gt;= 1e18"); marketLaunchIncentive_period[marketIndex] = period; marketLaunchIncentive_multipliers[marketIndex] = initialMultiplier;  } /*   @notice Changes the market launch incentive parameters for a market   @param marketIndex Identifies the market.   @param period The new period for which float token generation should be boosted.   @param initialMultiplier The new multiplier on Float generation.   /   function changeMarketLaunchIncentiveParameters(     uint32 marketIndex,     uint256 period,     uint256 initialMultiplier   ) external onlyAdmin {     _changeMarketLaunchIncentiveParameters(marketIndex, period, initialMultiplier); emit MarketLaunchIncentiveParametersChanges(marketIndex, period, initialMultiplier);  } /// @dev Logic for changeBalanceIncentiveExponent   function _changeBalanceIncentiveExponent(uint32 marketIndex, uint256 _balanceIncentiveCurve_exponent)     internal     virtual   {     require(       // The exponent has to be less than 5 in these versions of the contracts.       _balanceIncentiveCurve_exponent &gt; 0 &amp;&amp; _balanceIncentiveCurve_exponent &lt; 6,       "balanceIncentiveCurve_exponent out of bounds"     ); balanceIncentiveCurve_exponent[marketIndex] = _balanceIncentiveCurve_exponent;  } /*    @notice Changes the balance incentive exponent for a market   @param marketIndex Identifies the market.   @param _balanceIncentiveCurve_exponent The new exponent for the curve.   /   function changeBalanceIncentiveExponent(uint32 marketIndex, uint256 _balanceIncentiveCurve_exponent)     external     onlyAdmin   {     _changeBalanceIncentiveExponent(marketIndex, _balanceIncentiveCurve_exponent); emit BalanceIncentiveExponentUpdated(marketIndex, _balanceIncentiveCurve_exponent);  } /// @dev Logic for changeBalanceIncentiveEquilibriumOffset   function _changeBalanceIncentiveEquilibriumOffset(uint32 marketIndex, int256 _balanceIncentiveCurve_equilibriumOffset)     internal     virtual   {     // Unreasonable that we would ever shift this more than 90% either way     require(       _balanceIncentiveCurve_equilibriumOffset &gt; -9e17 &amp;&amp; _balanceIncentiveCurve_equilibriumOffset &lt; 9e17,       "balanceIncentiveCurve_equilibriumOffset out of bounds"     ); balanceIncentiveCurve_equilibriumOffset[marketIndex] = _balanceIncentiveCurve_equilibriumOffset;  } /*   @notice Changes the balance incentive curve equilibrium offset for a market   @param marketIndex Identifies the market.   @param _balanceIncentiveCurve_equilibriumOffset The new offset.   /   function changeBalanceIncentiveEquilibriumOffset(uint32 marketIndex, int256 _balanceIncentiveCurve_equilibriumOffset)     external     onlyAdmin   {     _changeBalanceIncentiveEquilibriumOffset(marketIndex, _balanceIncentiveCurve_equilibriumOffset); emit BalanceIncentiveEquilibriumOffsetUpdated(marketIndex, _balanceIncentiveCurve_equilibriumOffset);  } /╔═════════════════════════════╗     ║        STAKING SETUP        ║     ╚═════════════════════════════╝/ /*   @notice Sets this contract to track staking for a market in LongShort.sol   @param marketIndex Identifies the market.   @param longToken Address of the long token for the market.   @param shortToken Address of the short token for the market.   @param kInitialMultiplier Initial boost on float generation for the market.   @param kPeriod Period which the boost should last.   @param unstakeFee_e18 Percentage of tokens that are levied on unstaking in base 1e18.   @param _balanceIncentiveCurve_exponent Exponent for balance curve (see _calculateFloatPerSecond)   @param _balanceIncentiveCurve_equilibriumOffset Offset for balance curve (see _calculateFloatPerSecond)   /   function addNewStakingFund(     uint32 marketIndex,     address longToken,     address shortToken,     uint256 kInitialMultiplier,     uint256 kPeriod,     uint256 unstakeFee_e18,     uint256 _balanceIncentiveCurve_exponent,     int256 _balanceIncentiveCurve_equilibriumOffset   ) external override onlyLongShort {     marketIndexOfToken[longToken] = marketIndex;     marketIndexOfToken[shortToken] = marketIndex; accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].timestamp = block.timestamp; accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].accumulativeFloatPerSyntheticToken_long = 0; accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].accumulativeFloatPerSyntheticToken_short = 0;  syntheticTokens[marketIndex][true] = longToken; syntheticTokens[marketIndex][false] = shortToken;  _changeBalanceIncentiveExponent(marketIndex, _balanceIncentiveCurve_exponent); _changeBalanceIncentiveEquilibriumOffset(marketIndex, _balanceIncentiveCurve_equilibriumOffset); _changeMarketLaunchIncentiveParameters(marketIndex, kPeriod, kInitialMultiplier);  _changeUnstakeFee(marketIndex, unstakeFee_e18);  // Set this value to one initially - 0 is a null value and thus potentially bug prone. batched_stakerNextTokenShiftIndex[marketIndex] = 1;  emit MarketAddedToStaker(   marketIndex,   unstakeFee_e18,   kPeriod,   kInitialMultiplier,   _balanceIncentiveCurve_exponent,   _balanceIncentiveCurve_equilibriumOffset );  emit AccumulativeIssuancePerStakedSynthSnapshotCreated(marketIndex, 0, 0, 0);  } /╔═════════════════════════════════════════════════════════════════════════╗     ║    GLOBAL FLT REWARD ACCUMULATION CALCULATION AND TRACKING FUNCTIONS    ║     ╚═════════════════════════════════════════════════════════════════════════╝/ /*   @notice Returns the K factor parameters for the given market with sensible   defaults if they haven't been set yet.   @param marketIndex The market to change the parameters for.   @return period The period for which the k factor applies for in seconds.   @return multiplier The multiplier on Float generation in this period.   /   function _getMarketLaunchIncentiveParameters(uint32 marketIndex)     internal     view     virtual     returns (uint256 period, uint256 multiplier)   {     period = marketLaunchIncentive_period[marketIndex];     multiplier = marketLaunchIncentive_multipliers[marketIndex]; if (multiplier &lt; 1e18) {   multiplier = 1e18; // multiplier of 1 by default }  } /*    @notice Returns the extent to which a markets float generation should be adjusted   based on the market's launch incentive parameters. Should start at multiplier   then linearly change to 1e18 over time.   @param marketIndex Identifies the market.   @return k The calculated modifier for float generation.   /   function _getKValue(uint32 marketIndex) internal view virtual returns (uint256) {     // Parameters controlling the float issuance multiplier.     (uint256 kPeriod, uint256 kInitialMultiplier) = _getMarketLaunchIncentiveParameters(marketIndex); // Sanity check - under normal circumstances, the multipliers should // *never* be set to a value &lt; 1e18, as there are guards against this. assert(kInitialMultiplier &gt;= 1e18);  uint256 initialTimestamp = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].timestamp;  if (block.timestamp - initialTimestamp &lt;= kPeriod) {   return kInitialMultiplier - (((kInitialMultiplier - 1e18) * (block.timestamp - initialTimestamp)) / kPeriod); } else {   return 1e18; }  } /   @notice Computes the number of float tokens a user earns per second for   every long/short synthetic token they've staked. The returned value has   a fixed decimal scale of 1e42 (!!!) for numerical stability. The return   values are float per second per synthetic token (hence the requirement   to multiply by price)   @dev to see below math in latex form see TODO add link   to interact with the equations see https://www.desmos.com/calculator/optkaxyihr   @param marketIndex The market referred to.   @param longPrice Price of the synthetic long token in units of payment token   @param shortPrice Price of the synthetic short token in units of payment token   @param longValue Amount of payment token in the long side of the market   @param shortValue Amount of payment token in the short side of the market   @return longFloatPerSecond Float token per second per long synthetic token   @return shortFloatPerSecond Float token per second per short synthetic token    /   function _calculateFloatPerSecond(     uint32 marketIndex,     uint256 longPrice,     uint256 shortPrice,     uint256 longValue,     uint256 shortValue   ) internal view virtual returns (uint256 longFloatPerSecond, uint256 shortFloatPerSecond) {     // A float issuance multiplier that starts high and decreases linearly     // over time to a value of 1. This incentivises users to stake early.     uint256 k = _getKValue(marketIndex); uint256 totalLocked = (longValue + shortValue);  // we need to scale this number by the totalLocked so that the offset remains consistent accross market size  int256 equilibriumOffsetMarketScaled = (balanceIncentiveCurve_equilibriumOffset[marketIndex] *   int256(totalLocked)) / 2e18;  uint256 denominator = ((totalLocked &gt;&gt; safeExponentBitShifting)**balanceIncentiveCurve_exponent[marketIndex]);  // Float is scaled by the percentage of the total market value held in // the opposite position. This incentivises users to stake on the // weaker position. if (int256(shortValue) - equilibriumOffsetMarketScaled &lt; int256(longValue)) {   if (equilibriumOffsetMarketScaled &gt;= int256(shortValue)) {     // edge case: imbalanced far past the equilibrium offset - full rewards go to short token     //            extremeley unlikely to happen in practice     return (0, 1e18 * k * shortPrice);   }    uint256 numerator = (uint256(int256(shortValue) - equilibriumOffsetMarketScaled) &gt;&gt;     (safeExponentBitShifting - 1))**balanceIncentiveCurve_exponent[marketIndex];    // NOTE: `x * 5e17` == `(x * 10e18) / 2`   uint256 longRewardUnscaled = (numerator * 5e17) / denominator;   uint256 shortRewardUnscaled = 1e18 - longRewardUnscaled;    return ((longRewardUnscaled * k * longPrice) / 1e18, (shortRewardUnscaled * k * shortPrice) / 1e18); } else {   if (-equilibriumOffsetMarketScaled &gt;= int256(longValue)) {     // edge case: imbalanced far past the equilibrium offset - full rewards go to long token     //            extremeley unlikely to happen in practice     return (1e18 * k * longPrice, 0);   }    uint256 numerator = (uint256(int256(longValue) + equilibriumOffsetMarketScaled) &gt;&gt;     (safeExponentBitShifting - 1))**balanceIncentiveCurve_exponent[marketIndex];    // NOTE: `x * 5e17` == `(x * 10e18) / 2`   uint256 shortRewardUnscaled = (numerator * 5e17) / denominator;   uint256 longRewardUnscaled = 1e18 - shortRewardUnscaled;    return ((longRewardUnscaled * k * longPrice) / 1e18, (shortRewardUnscaled * k * shortPrice) / 1e18); }  } /*   @notice Computes the time since last accumulativeIssuancePerStakedSynthSnapshot for the given market in seconds.   @param marketIndex The market referred to.   @return The time difference in seconds   /   function _calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(uint32 marketIndex)     internal     view     virtual     returns (uint256)   {     return       block.timestamp -       accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]].timestamp;   } /*   @notice Computes new cumulative sum of 'r' value since last accumulativeIssuancePerStakedSynthSnapshot. We use   cumulative 'r' value to avoid looping during issuance. Note that the   cumulative sum is kept in 1e42 scale (!!!) to avoid numerical issues.   @param shortValue The value locked in the short side of the market.   @param longValue The value locked in the long side of the market.   @param shortPrice The price of the short token as defined in LongShort.sol   @param longPrice The price of the long token as defined in LongShort.sol   @param marketIndex An identifier for the market.   @return longCumulativeRates The long cumulative sum.   @return shortCumulativeRates The short cumulative sum.   /   function _calculateNewCumulativeIssuancePerStakedSynth(     uint32 marketIndex,     uint256 longPrice,     uint256 shortPrice,     uint256 longValue,     uint256 shortValue   ) internal view virtual returns (uint256 longCumulativeRates, uint256 shortCumulativeRates) {     // Compute the current 'r' value for float issuance per second.     (uint256 longFloatPerSecond, uint256 shortFloatPerSecond) = _calculateFloatPerSecond(       marketIndex,       longPrice,       shortPrice,       longValue,       shortValue     ); // Compute time since last accumulativeIssuancePerStakedSynthSnapshot for the given token. uint256 timeDelta = _calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(marketIndex);  // Compute new cumulative 'r' value total. return (   accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]]   .accumulativeFloatPerSyntheticToken_long + (timeDelta * longFloatPerSecond),   accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]]   .accumulativeFloatPerSyntheticToken_short + (timeDelta * shortFloatPerSecond) );  } /*   @notice Creates a new accumulativeIssuancePerStakedSynthSnapshot for the given token and updates indexes.   @param shortValue The value locked in the short side of the market.   @param longValue The value locked in the long side of the market.   @param shortPrice The price of the short token as defined in LongShort.sol   @param longPrice The price of the long token as defined in LongShort.sol   @param marketIndex An identifier for the market.   /   function _setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot(     uint32 marketIndex,     uint256 longPrice,     uint256 shortPrice,     uint256 longValue,     uint256 shortValue   ) internal virtual {     (       uint256 newLongAccumulativeValue,       uint256 newShortAccumulativeValue     ) = _calculateNewCumulativeIssuancePerStakedSynth(marketIndex, longPrice, shortPrice, longValue, shortValue); uint256 newIndex = latestRewardIndex[marketIndex] + 1;  // Set cumulative 'r' value on new accumulativeIssuancePerStakedSynthSnapshot. accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex] .accumulativeFloatPerSyntheticToken_long = newLongAccumulativeValue; accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex] .accumulativeFloatPerSyntheticToken_short = newShortAccumulativeValue;  // Set timestamp on new accumulativeIssuancePerStakedSynthSnapshot. accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex].timestamp = block.timestamp;  // Update latest index to point to new accumulativeIssuancePerStakedSynthSnapshot. latestRewardIndex[marketIndex] = newIndex;  emit AccumulativeIssuancePerStakedSynthSnapshotCreated(   marketIndex,   newIndex,   newLongAccumulativeValue,   newShortAccumulativeValue );  } /*   @notice Adds new accumulativeIssuancePerStakedSynthSnapshots for the given long/short tokens. Called by the   ILongShort contract whenever there is a state change for a market.   @param stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted Mapping from this contract's shifts to LongShort.sols next price snapshots.   @param shortValue The value locked in the short side of the market.   @param longValue The value locked in the long side of the market.   @param shortPrice The price of the short token as defined in LongShort.sol   @param longPrice The price of the long token as defined in LongShort.sol   @param marketIndex An identifier for the market.   /   function pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(     uint32 marketIndex,     uint256 longPrice,     uint256 shortPrice,     uint256 longValue,     uint256 shortValue,     uint256 stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted // This value should be ALWAYS be zero if no shift occured   ) external override onlyLongShort {     // Only add a new accumulativeIssuancePerStakedSynthSnapshot if some time has passed. // the `stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted` value will be 0 if there is no staker related action in an executed batch if (stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted &gt; 0) {   stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[     batched_stakerNextTokenShiftIndex[marketIndex]   ] = stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted;   stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[     batched_stakerNextTokenShiftIndex[marketIndex]   ] = latestRewardIndex[marketIndex] + 1;   batched_stakerNextTokenShiftIndex[marketIndex] += 1;    emit SyntheticTokensShifted(); }  // Time delta is fetched twice in below code, can pass through? Which is less gas? if (_calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(marketIndex) &gt; 0) {   _setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot(     marketIndex,     longPrice,     shortPrice,     longValue,     shortValue   ); }  } /╔═══════════════════════════════════╗     ║    USER REWARD STATE FUNCTIONS    ║     ╚═══════════════════════════════════╝/ /// @dev Calculates the accumulated float in a specific range of staker snapshots   function _calculateAccumulatedFloatInRange(     uint32 marketIndex,     uint256 amountStakedLong,     uint256 amountStakedShort,     uint256 rewardIndexFrom,     uint256 rewardIndexTo   ) internal view virtual returns (uint256 floatReward) {     if (amountStakedLong &gt; 0) {       uint256 accumDeltaLong = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexTo]       .accumulativeFloatPerSyntheticToken_long -         accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexFrom]         .accumulativeFloatPerSyntheticToken_long;       floatReward += (accumDeltaLong * amountStakedLong) / FLOAT_ISSUANCE_FIXED_DECIMAL;     } if (amountStakedShort &gt; 0) {   uint256 accumDeltaShort = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexTo]   .accumulativeFloatPerSyntheticToken_short -     accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexFrom]     .accumulativeFloatPerSyntheticToken_short;   floatReward += (accumDeltaShort * amountStakedShort) / FLOAT_ISSUANCE_FIXED_DECIMAL; }  } /*    @notice Calculates float owed to the user since the user last minted float for a market.   @param marketIndex Identifier for the market which the user staked in.   @param user The address of the user.   @return floatReward The amount of float owed.    /   function _calculateAccumulatedFloat(uint32 marketIndex, address user) internal virtual returns (uint256 floatReward) {     address longToken = syntheticTokens[marketIndex][true];     address shortToken = syntheticTokens[marketIndex][false]; uint256 amountStakedLong = userAmountStaked[longToken][user]; uint256 amountStakedShort = userAmountStaked[shortToken][user];  uint256 usersLastRewardIndex = userIndexOfLastClaimedReward[marketIndex][user];  // Don't do the calculation and return zero immediately if there is no change if (usersLastRewardIndex == latestRewardIndex[marketIndex]) {   return 0; }  uint256 usersShiftIndex = userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][user]; // if there is a change in the users tokens held due to a token shift (or possibly another action in the future) if (usersShiftIndex &gt; 0 &amp;&amp; usersShiftIndex &lt; batched_stakerNextTokenShiftIndex[marketIndex]) {   floatReward = _calculateAccumulatedFloatInRange(     marketIndex,     amountStakedLong,     amountStakedShort,     usersLastRewardIndex,     stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[usersShiftIndex]   );    // Update the users balances   if (userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user] &gt; 0) {     amountStakedShort += ILongShort(longShort).getAmountSyntheticTokenToMintOnTargetSide(       marketIndex,       userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user],       true,       stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[usersShiftIndex]     );      amountStakedLong -= userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user];     userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user] = 0;   }    if (userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user] &gt; 0) {     amountStakedLong += ILongShort(longShort).getAmountSyntheticTokenToMintOnTargetSide(       marketIndex,       userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user],       false,       stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[usersShiftIndex]     );      amountStakedShort -= userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user];     userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user] = 0;   }    // Save the users updated staked amounts   userAmountStaked[longToken][user] = amountStakedLong;   userAmountStaked[shortToken][user] = amountStakedShort;    floatReward += _calculateAccumulatedFloatInRange(     marketIndex,     amountStakedLong,     amountStakedShort,     stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[usersShiftIndex],     latestRewardIndex[marketIndex]   );    userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][user] = 0; } else {   floatReward = _calculateAccumulatedFloatInRange(     marketIndex,     amountStakedLong,     amountStakedShort,     usersLastRewardIndex,     latestRewardIndex[marketIndex]   ); }  } /*   @notice Mints float for a user.   @dev Mints a fixed percentage for Float capital.   @param user The address of the user.   @param floatToMint The amount of float to mint.    /   function _mintFloat(address user, uint256 floatToMint) internal virtual {     IFloatToken(floatToken).mint(user, floatToMint);     IFloatToken(floatToken).mint(floatCapital, (floatToMint * floatPercentage) / 1e18);   } /*   @notice Mints float owed to a user for a market since they last minted.   @param marketIndex An identifier for the market.   @param user The address of the user.    /   function _mintAccumulatedFloat(uint32 marketIndex, address user) internal virtual {     uint256 floatToMint = _calculateAccumulatedFloat(marketIndex, user); if (floatToMint &gt; 0) {   // Set the user has claimed up until now, stops them setting this forward   userIndexOfLastClaimedReward[marketIndex][user] = latestRewardIndex[marketIndex];    _mintFloat(user, floatToMint);   emit FloatMinted(user, marketIndex, floatToMint); }  } /*   @notice Mints float owed to a user for multiple markets, since they last minted for those markets.   @param marketIndexes Identifiers for the markets.   @param user The address of the user.    /   function _mintAccumulatedFloatMulti(uint32[] calldata marketIndexes, address user) internal virtual {     uint256 floatTotal = 0;     for (uint256 i = 0; i &lt; marketIndexes.length; i++) {       uint256 floatToMint = _calculateAccumulatedFloat(marketIndexes[i], user);   if (floatToMint &gt; 0) {     // Set the user has claimed up until now, stops them setting this forward     userIndexOfLastClaimedReward[marketIndexes[i]][user] = latestRewardIndex[marketIndexes[i]];      floatTotal += floatToMint;      emit FloatMinted(user, marketIndexes[i], floatToMint);   } } if (floatTotal &gt; 0) {   _mintFloat(user, floatTotal); }  } /*   @notice Mints outstanding float for msg.sender.   @param marketIndexes Identifiers for the markets for which to mint float.    /   function claimFloatCustom(uint32[] calldata marketIndexes) external {     ILongShort(longShort).updateSystemStateMulti(marketIndexes);     _mintAccumulatedFloatMulti(marketIndexes, msg.sender);   } /*   @notice Mints outstanding float on behalf of another user.   @param marketIndexes Identifiers for the markets for which to mint float.   @param user The address of the user.    /   function claimFloatCustomFor(uint32[] calldata marketIndexes, address user) external {     // Unbounded loop - users are responsible for paying their own gas costs on these and it doesn't effect the rest of the system.     // No need to impose limit.     ILongShort(longShort).updateSystemStateMulti(marketIndexes);     _mintAccumulatedFloatMulti(marketIndexes, user);   } /╔═══════════════════════╗     ║        STAKING        ║     ╚═══════════════════════╝/ /*   @notice A user with synthetic tokens stakes by calling stake on the token   contract which calls this function. We need to first update the   state of the LongShort contract for this market before staking to correctly calculate user rewards.   @param amount Amount to stake.   @param from Address to stake for.   /   function stakeFromUser(address from, uint256 amount) public virtual override onlyValidSynthetic((msg.sender)) {     ILongShort(longShort).updateSystemState(marketIndexOfToken[(msg.sender)]);     _stake((msg.sender), amount, from);   } /*   @dev Internal logic for staking.   @param token Address of the token for which to stake.   @param amount Amount to stake.   @param user Address to stake for.   /   function _stake(     address token,     uint256 amount,     address user   ) internal virtual {     uint32 marketIndex = marketIndexOfToken[token]; // If they already have staked and have rewards due, mint these. if (   userIndexOfLastClaimedReward[marketIndex][user] != 0 &amp;&amp;   userIndexOfLastClaimedReward[marketIndex][user] &lt; latestRewardIndex[marketIndex] ) {   _mintAccumulatedFloat(marketIndex, user); }  userAmountStaked[token][user] = userAmountStaked[token][user] + amount;  userIndexOfLastClaimedReward[marketIndex][user] = latestRewardIndex[marketIndex];  emit StakeAdded(user, address(token), amount, userIndexOfLastClaimedReward[marketIndex][user]);  } /*   @notice Allows users to shift their staked tokens from one side of the market to    the other at the next price.   @param amountSyntheticTokensToShift Amount of tokens to shift.   @param marketIndex Identifier for the market.   @param isShiftFromLong Whether the shift is from long to short or short to long.   /   function shiftTokens(     uint256 amountSyntheticTokensToShift,     uint32 marketIndex,     bool isShiftFromLong   ) external virtual {     address token = syntheticTokens[marketIndex][isShiftFromLong];     require(userAmountStaked[token][msg.sender] &gt;= amountSyntheticTokensToShift, "Not enough tokens to shift"); // If the user has outstanding token shift that have already been confirmed in the LongShort // contract, execute them first. if (   userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] != 0 &amp;&amp;   userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] &lt;   batched_stakerNextTokenShiftIndex[marketIndex] ) {   _mintAccumulatedFloat(marketIndex, msg.sender); }  if (isShiftFromLong) {   ILongShort(longShort).shiftPositionFromLongNextPrice(marketIndex, amountSyntheticTokensToShift);   userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][     msg.sender   ] += amountSyntheticTokensToShift; } else {   ILongShort(longShort).shiftPositionFromShortNextPrice(marketIndex, amountSyntheticTokensToShift);   userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][     msg.sender   ] += amountSyntheticTokensToShift; }  userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] = batched_stakerNextTokenShiftIndex[   marketIndex ];  } /╔════════════════════════════╗     ║    WITHDRAWAL &amp; MINTING    ║     ╚════════════════════════════╝/ /*   @notice Internal logic for withdrawing stakes.   @dev Mint user any outstanding float before withdrawing.   @param marketIndex Market index of token.   @param amount Amount to withdraw.   @param token Synthetic token that was staked.   /   function _withdraw(     uint32 marketIndex,     address token,     uint256 amount   ) internal virtual {     require(userAmountStaked[token][msg.sender] &gt; 0, "nothing to withdraw");     _mintAccumulatedFloat(marketIndex, msg.sender); userAmountStaked[token][msg.sender] = userAmountStaked[token][msg.sender] - amount;  uint256 amountFees = (amount * marketUnstakeFee_e18[marketIndex]) / 1e18;  IERC20(token).transfer(floatTreasury, amountFees); IERC20(token).transfer(msg.sender, amount - amountFees);  emit StakeWithdrawn(msg.sender, token, amount);  } /*   @notice Withdraw function. Allows users to unstake.   @param amount Amount to withdraw.   @param token Address of the token for which to withdraw.   /   function withdraw(address token, uint256 amount) external {     ILongShort(longShort).updateSystemState(marketIndexOfToken[token]); uint32 marketIndex = marketIndexOfToken[token];  _withdraw(marketIndex, token, amount);  if (userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] &gt; 0) {   // If they still have outstanding shifts after minting float, then check   // that they don't withdraw more than their shifts allow.   uint256 amountToShiftForThisToken = syntheticTokens[marketIndex][true] == token     ? userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][msg.sender]     : userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][msg.sender];    require(     userAmountStaked[token][msg.sender] &gt;= amountToShiftForThisToken,     "Outstanding next price stake shifts too great"   ); }  } /*   @notice Allows users to withdraw their entire stake for a token.   @param token Address of the token for which to withdraw.   /   function withdrawAll(address token) external {     ILongShort(longShort).updateSystemState(marketIndexOfToken[token]); uint32 marketIndex = marketIndexOfToken[token];  uint256 amountToShiftForThisToken = syntheticTokens[marketIndex][true] == token   ? userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][msg.sender]   : userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][msg.sender];  _withdraw(marketIndex, token, userAmountStaked[token][msg.sender] - amountToShiftForThisToken);  } } |
| **with_task_specify** | False |
| **memory** | None |
| **model_type** | ModelType.GPT_3_5_TURBO |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-17-08 08:02:14 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Testing Engineer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer.
Your can simulate various attack scenarios, conduct security testing, and perform code audits to identify vulnerablities and weaknesses in the smart contracts. This inculde analyzing potential exploit paths, assessing the resilience of the contract to common attack vectorsm and suggesting remediation measures
Here is a new customer's task: // SPDX-License-Identifier: BUSL-1.1

pragma solidity 0.8.3;

import "@openzeppelin/contracts-upgradeable/token/ERC20/presets/ERC20PresetMinterPauserUpgradeable.sol";

import "./interfaces/IFloatToken.sol";
import "./interfaces/ILongShort.sol";
import "./interfaces/IStaker.sol";
import "./interfaces/ISyntheticToken.sol";

contract Staker is IStaker, Initializable {
  /*╔═════════════════════════════╗
    ║          VARIABLES          ║
    ╚═════════════════════════════╝*/

  /* ══════ Fixed-precision constants ══════ */
  uint256 public constant FLOAT_ISSUANCE_FIXED_DECIMAL = 1e42;
  // 2^52 ~= 4.5e15
  // With an exponent of 5, the largest total liquidity possible in a market (to avoid integer overflow on exponentiation) is ~10^31 or 10 Trillion (10^13)
  // NOTE: this also means if the total market value is less than 2^52 there will be a division by zero error
  uint256 public constant safeExponentBitShifting = 52;

  /* ══════ Global state ══════ */
  address public admin;
  address public floatCapital;
  address public floatTreasury;
  uint256 public floatPercentage;

  address public longShort;
  address public floatToken;

  /* ══════ Market specific ══════ */
  mapping(uint32 => uint256) public marketLaunchIncentive_period; // seconds
  mapping(uint32 => uint256) public marketLaunchIncentive_multipliers; // e18 scale
  mapping(uint32 => uint256) public marketUnstakeFee_e18;
  mapping(uint32 => uint256) public balanceIncentiveCurve_exponent;
  mapping(uint32 => int256) public balanceIncentiveCurve_equilibriumOffset;

  mapping(uint32 => mapping(bool => address)) public syntheticTokens;

  mapping(address => uint32) public marketIndexOfToken;

  /* ══════ Reward specific ══════ */
  mapping(uint32 => uint256) public latestRewardIndex;
  mapping(uint32 => mapping(uint256 => AccumulativeIssuancePerStakedSynthSnapshot))
    public accumulativeFloatPerSyntheticTokenSnapshots;
  struct AccumulativeIssuancePerStakedSynthSnapshot {
    uint256 timestamp;
    uint256 accumulativeFloatPerSyntheticToken_long;
    uint256 accumulativeFloatPerSyntheticToken_short;
  }

  /* ══════ User specific ══════ */
  mapping(uint32 => mapping(address => uint256)) public userIndexOfLastClaimedReward;
  mapping(address => mapping(address => uint256)) public userAmountStaked;

  /* ══════ Token shift management specific ══════ */
  mapping(uint32 => uint256) public batched_stakerNextTokenShiftIndex;
  /**
  @notice Used to link a token shift to a staker state
  @dev tokenShiftIndex => accumulativeFloatIssuanceSnapshotIndex
    POSSIBLE OPTIMIZATION - could pack stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping and stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping into a struct of two uint128 for storage space optimization.
  */
  mapping(uint256 => uint256) public stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping;
  /// @notice Used to fetch the price from LongShort at that point in time
  /// @dev tokenShiftIndex => longShortMarketPriceSnapshotIndex
  mapping(uint256 => uint256) public stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping;
  /// @dev marketIndex => usersAddress => stakerTokenShiftIndex
  mapping(uint32 => mapping(address => uint256)) public userNextPrice_stakedSyntheticTokenShiftIndex;
  /// @dev marketIndex => usersAddress => amountUserRequestedToShiftAwayFromLongOnNextUpdate
  mapping(uint32 => mapping(address => uint256)) public userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long;
  /// @dev marketIndex => usersAddress => amountUserRequestedToShiftAwayFromShortOnNextUpdate
  mapping(uint32 => mapping(address => uint256)) public userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short;

  /*╔════════════════════════════╗
    ║           EVENTS           ║
    ╚════════════════════════════╝*/

  event StakerV1(
    address admin,
    address floatTreasury,
    address floatCapital,
    address floatToken,
    uint256 floatPercentage
  );

  event MarketAddedToStaker(
    uint32 marketIndex,
    uint256 exitFee_e18,
    uint256 period,
    uint256 multiplier,
    uint256 balanceIncentiveExponent,
    int256 balanceIncentiveEquilibriumOffset
  );

  event AccumulativeIssuancePerStakedSynthSnapshotCreated(
    uint32 marketIndex,
    uint256 accumulativeFloatIssuanceSnapshotIndex,
    uint256 accumulativeLong,
    uint256 accumulativeShort
  );

  event StakeAdded(address user, address token, uint256 amount, uint256 lastMintIndex);

  event StakeWithdrawn(address user, address token, uint256 amount);

  // Note: the `amountFloatMinted` isn't strictly needed by the graph, but it is good to add it to validate calculations are accurate.
  event FloatMinted(address user, uint32 marketIndex, uint256 amountFloatMinted);

  event MarketLaunchIncentiveParametersChanges(uint32 marketIndex, uint256 period, uint256 multiplier);

  event StakeWithdrawalFeeUpdated(uint32 marketIndex, uint256 stakeWithdralFee);

  event BalanceIncentiveExponentUpdated(uint32 marketIndex, uint256 balanceIncentiveExponent);

  event BalanceIncentiveEquilibriumOffsetUpdated(uint32 marketIndex, int256 balanceIncentiveEquilibriumOffset);

  event FloatPercentageUpdated(uint256 floatPercentage);

  event SyntheticTokensShifted();

  event ChangeAdmin(address newAdmin);

  /*╔═════════════════════════════╗
    ║          MODIFIERS          ║
    ╚═════════════════════════════╝*/

  function onlyAdminModifierLogic() internal virtual {
    require(msg.sender == admin, "not admin");
  }

  modifier onlyAdmin() {
    onlyAdminModifierLogic();
    _;
  }

  function onlyValidSyntheticModifierLogic(address _synth) internal virtual {
    require(marketIndexOfToken[_synth] != 0, "not valid synth");
  }

  modifier onlyValidSynthetic(address _synth) {
    onlyValidSyntheticModifierLogic(_synth);
    _;
  }

  function onlyValidMarketModifierLogic(uint32 marketIndex) internal virtual {
    require(address(syntheticTokens[marketIndex][true]) != address(0), "not valid market");
  }

  modifier onlyValidMarket(uint32 marketIndex) {
    onlyValidMarketModifierLogic(marketIndex);
    _;
  }

  function onlyLongShortModifierLogic() internal virtual {
    require(msg.sender == address(longShort), "not long short");
  }

  modifier onlyLongShort() {
    onlyLongShortModifierLogic();
    _;
  }

  /*╔═════════════════════════════╗
    ║       CONTRACT SET-UP       ║
    ╚═════════════════════════════╝*/

  /**
  @notice Initializes the contract.
  @dev Calls OpenZeppelin's initializer modifier.
  @param _admin Address of the admin role.
  @param _longShort Address of the LongShort contract, a deployed LongShort.sol
  @param _floatToken Address of the Float token earned by staking.
  @param _floatTreasury Address of the treasury contract for managing fees.
  @param _floatCapital Address of the contract which earns a fixed percentage of Float.
  @param _floatPercentage Determines the float percentage that gets minted for Float Capital, base 1e18.
  */
  function initialize(
    address _admin,
    address _longShort,
    address _floatToken,
    address _floatTreasury,
    address _floatCapital,
    uint256 _floatPercentage
  ) external virtual initializer {
    admin = _admin;
    floatCapital = _floatCapital;
    floatTreasury = _floatTreasury;
    longShort = _longShort;
    floatToken = _floatToken;

    _changeFloatPercentage(_floatPercentage);

    emit StakerV1(_admin, _floatTreasury, _floatCapital, _floatToken, _floatPercentage);
  }

  /*╔═══════════════════╗
    ║       ADMIN       ║
    ╚═══════════════════╝*/

  /** 
  @notice Changes admin for the contract
  @param _admin The address of the new admin.
  */
  function changeAdmin(address _admin) external onlyAdmin {
    admin = _admin;
    emit ChangeAdmin(_admin);
  }

  /// @dev Logic for changeFloatPercentage
  function _changeFloatPercentage(uint256 newFloatPercentage) internal virtual {
    require(newFloatPercentage <= 1e18 && newFloatPercentage > 0); // less than or equal to 100% and greater than 0%
    floatPercentage = newFloatPercentage;
  }

  /**
  @notice Changes percentage of float that is minted for float capital.
  @param newFloatPercentage The new float percentage in base 1e18.
  */
  function changeFloatPercentage(uint256 newFloatPercentage) external onlyAdmin {
    _changeFloatPercentage(newFloatPercentage);
    emit FloatPercentageUpdated(newFloatPercentage);
  }

  /// @dev Logic for changeUnstakeFee
  function _changeUnstakeFee(uint32 marketIndex, uint256 newMarketUnstakeFee_e18) internal virtual {
    require(newMarketUnstakeFee_e18 <= 5e16); // Explicitely stating 5% fee as the max fee possible.
    marketUnstakeFee_e18[marketIndex] = newMarketUnstakeFee_e18;
  }

  /**
  @notice Changes unstake fee for a market
  @param marketIndex Identifies the market.
  @param newMarketUnstakeFee_e18 The new unstake fee.
  */
  function changeUnstakeFee(uint32 marketIndex, uint256 newMarketUnstakeFee_e18) external onlyAdmin {
    _changeUnstakeFee(marketIndex, newMarketUnstakeFee_e18);
    emit StakeWithdrawalFeeUpdated(marketIndex, newMarketUnstakeFee_e18);
  }

  /// @dev Logic for changeMarketLaunchIncentiveParameters
  function _changeMarketLaunchIncentiveParameters(
    uint32 marketIndex,
    uint256 period,
    uint256 initialMultiplier
  ) internal virtual {
    require(initialMultiplier >= 1e18, "marketLaunchIncentiveMultiplier must be >= 1e18");

    marketLaunchIncentive_period[marketIndex] = period;
    marketLaunchIncentive_multipliers[marketIndex] = initialMultiplier;
  }

  /**
  @notice Changes the market launch incentive parameters for a market
  @param marketIndex Identifies the market.
  @param period The new period for which float token generation should be boosted.
  @param initialMultiplier The new multiplier on Float generation.
  */
  function changeMarketLaunchIncentiveParameters(
    uint32 marketIndex,
    uint256 period,
    uint256 initialMultiplier
  ) external onlyAdmin {
    _changeMarketLaunchIncentiveParameters(marketIndex, period, initialMultiplier);

    emit MarketLaunchIncentiveParametersChanges(marketIndex, period, initialMultiplier);
  }

  /// @dev Logic for changeBalanceIncentiveExponent
  function _changeBalanceIncentiveExponent(uint32 marketIndex, uint256 _balanceIncentiveCurve_exponent)
    internal
    virtual
  {
    require(
      // The exponent has to be less than 5 in these versions of the contracts.
      _balanceIncentiveCurve_exponent > 0 && _balanceIncentiveCurve_exponent < 6,
      "balanceIncentiveCurve_exponent out of bounds"
    );

    balanceIncentiveCurve_exponent[marketIndex] = _balanceIncentiveCurve_exponent;
  }

  /** 
  @notice Changes the balance incentive exponent for a market
  @param marketIndex Identifies the market.
  @param _balanceIncentiveCurve_exponent The new exponent for the curve.
  */
  function changeBalanceIncentiveExponent(uint32 marketIndex, uint256 _balanceIncentiveCurve_exponent)
    external
    onlyAdmin
  {
    _changeBalanceIncentiveExponent(marketIndex, _balanceIncentiveCurve_exponent);

    emit BalanceIncentiveExponentUpdated(marketIndex, _balanceIncentiveCurve_exponent);
  }

  /// @dev Logic for changeBalanceIncentiveEquilibriumOffset
  function _changeBalanceIncentiveEquilibriumOffset(uint32 marketIndex, int256 _balanceIncentiveCurve_equilibriumOffset)
    internal
    virtual
  {
    // Unreasonable that we would ever shift this more than 90% either way
    require(
      _balanceIncentiveCurve_equilibriumOffset > -9e17 && _balanceIncentiveCurve_equilibriumOffset < 9e17,
      "balanceIncentiveCurve_equilibriumOffset out of bounds"
    );

    balanceIncentiveCurve_equilibriumOffset[marketIndex] = _balanceIncentiveCurve_equilibriumOffset;
  }

  /**
  @notice Changes the balance incentive curve equilibrium offset for a market
  @param marketIndex Identifies the market.
  @param _balanceIncentiveCurve_equilibriumOffset The new offset.
  */
  function changeBalanceIncentiveEquilibriumOffset(uint32 marketIndex, int256 _balanceIncentiveCurve_equilibriumOffset)
    external
    onlyAdmin
  {
    _changeBalanceIncentiveEquilibriumOffset(marketIndex, _balanceIncentiveCurve_equilibriumOffset);

    emit BalanceIncentiveEquilibriumOffsetUpdated(marketIndex, _balanceIncentiveCurve_equilibriumOffset);
  }

  /*╔═════════════════════════════╗
    ║        STAKING SETUP        ║
    ╚═════════════════════════════╝*/

  /**
  @notice Sets this contract to track staking for a market in LongShort.sol
  @param marketIndex Identifies the market.
  @param longToken Address of the long token for the market.
  @param shortToken Address of the short token for the market.
  @param kInitialMultiplier Initial boost on float generation for the market.
  @param kPeriod Period which the boost should last.
  @param unstakeFee_e18 Percentage of tokens that are levied on unstaking in base 1e18.
  @param _balanceIncentiveCurve_exponent Exponent for balance curve (see _calculateFloatPerSecond)
  @param _balanceIncentiveCurve_equilibriumOffset Offset for balance curve (see _calculateFloatPerSecond)
  */
  function addNewStakingFund(
    uint32 marketIndex,
    address longToken,
    address shortToken,
    uint256 kInitialMultiplier,
    uint256 kPeriod,
    uint256 unstakeFee_e18,
    uint256 _balanceIncentiveCurve_exponent,
    int256 _balanceIncentiveCurve_equilibriumOffset
  ) external override onlyLongShort {
    marketIndexOfToken[longToken] = marketIndex;
    marketIndexOfToken[shortToken] = marketIndex;

    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].timestamp = block.timestamp;
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].accumulativeFloatPerSyntheticToken_long = 0;
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].accumulativeFloatPerSyntheticToken_short = 0;

    syntheticTokens[marketIndex][true] = longToken;
    syntheticTokens[marketIndex][false] = shortToken;

    _changeBalanceIncentiveExponent(marketIndex, _balanceIncentiveCurve_exponent);
    _changeBalanceIncentiveEquilibriumOffset(marketIndex, _balanceIncentiveCurve_equilibriumOffset);
    _changeMarketLaunchIncentiveParameters(marketIndex, kPeriod, kInitialMultiplier);

    _changeUnstakeFee(marketIndex, unstakeFee_e18);

    // Set this value to one initially - 0 is a null value and thus potentially bug prone.
    batched_stakerNextTokenShiftIndex[marketIndex] = 1;

    emit MarketAddedToStaker(
      marketIndex,
      unstakeFee_e18,
      kPeriod,
      kInitialMultiplier,
      _balanceIncentiveCurve_exponent,
      _balanceIncentiveCurve_equilibriumOffset
    );

    emit AccumulativeIssuancePerStakedSynthSnapshotCreated(marketIndex, 0, 0, 0);
  }

  /*╔═════════════════════════════════════════════════════════════════════════╗
    ║    GLOBAL FLT REWARD ACCUMULATION CALCULATION AND TRACKING FUNCTIONS    ║
    ╚═════════════════════════════════════════════════════════════════════════╝*/

  /**
  @notice Returns the K factor parameters for the given market with sensible
  defaults if they haven't been set yet.
  @param marketIndex The market to change the parameters for.
  @return period The period for which the k factor applies for in seconds.
  @return multiplier The multiplier on Float generation in this period.
  */
  function _getMarketLaunchIncentiveParameters(uint32 marketIndex)
    internal
    view
    virtual
    returns (uint256 period, uint256 multiplier)
  {
    period = marketLaunchIncentive_period[marketIndex];
    multiplier = marketLaunchIncentive_multipliers[marketIndex];

    if (multiplier < 1e18) {
      multiplier = 1e18; // multiplier of 1 by default
    }
  }

  /** 
  @notice Returns the extent to which a markets float generation should be adjusted
  based on the market's launch incentive parameters. Should start at multiplier
  then linearly change to 1e18 over time.
  @param marketIndex Identifies the market.
  @return k The calculated modifier for float generation.
  */
  function _getKValue(uint32 marketIndex) internal view virtual returns (uint256) {
    // Parameters controlling the float issuance multiplier.
    (uint256 kPeriod, uint256 kInitialMultiplier) = _getMarketLaunchIncentiveParameters(marketIndex);

    // Sanity check - under normal circumstances, the multipliers should
    // *never* be set to a value < 1e18, as there are guards against this.
    assert(kInitialMultiplier >= 1e18);

    uint256 initialTimestamp = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].timestamp;

    if (block.timestamp - initialTimestamp <= kPeriod) {
      return kInitialMultiplier - (((kInitialMultiplier - 1e18) * (block.timestamp - initialTimestamp)) / kPeriod);
    } else {
      return 1e18;
    }
  }

  /*
  @notice Computes the number of float tokens a user earns per second for
  every long/short synthetic token they've staked. The returned value has
  a fixed decimal scale of 1e42 (!!!) for numerical stability. The return
  values are float per second per synthetic token (hence the requirement
  to multiply by price)
  @dev to see below math in latex form see TODO add link
  to interact with the equations see https://www.desmos.com/calculator/optkaxyihr
  @param marketIndex The market referred to.
  @param longPrice Price of the synthetic long token in units of payment token
  @param shortPrice Price of the synthetic short token in units of payment token
  @param longValue Amount of payment token in the long side of the market
  @param shortValue Amount of payment token in the short side of the market
  @return longFloatPerSecond Float token per second per long synthetic token
  @return shortFloatPerSecond Float token per second per short synthetic token
   */
  function _calculateFloatPerSecond(
    uint32 marketIndex,
    uint256 longPrice,
    uint256 shortPrice,
    uint256 longValue,
    uint256 shortValue
  ) internal view virtual returns (uint256 longFloatPerSecond, uint256 shortFloatPerSecond) {
    // A float issuance multiplier that starts high and decreases linearly
    // over time to a value of 1. This incentivises users to stake early.
    uint256 k = _getKValue(marketIndex);

    uint256 totalLocked = (longValue + shortValue);

    // we need to scale this number by the totalLocked so that the offset remains consistent accross market size

    int256 equilibriumOffsetMarketScaled = (balanceIncentiveCurve_equilibriumOffset[marketIndex] *
      int256(totalLocked)) / 2e18;

    uint256 denominator = ((totalLocked >> safeExponentBitShifting)**balanceIncentiveCurve_exponent[marketIndex]);

    // Float is scaled by the percentage of the total market value held in
    // the opposite position. This incentivises users to stake on the
    // weaker position.
    if (int256(shortValue) - equilibriumOffsetMarketScaled < int256(longValue)) {
      if (equilibriumOffsetMarketScaled >= int256(shortValue)) {
        // edge case: imbalanced far past the equilibrium offset - full rewards go to short token
        //            extremeley unlikely to happen in practice
        return (0, 1e18 * k * shortPrice);
      }

      uint256 numerator = (uint256(int256(shortValue) - equilibriumOffsetMarketScaled) >>
        (safeExponentBitShifting - 1))**balanceIncentiveCurve_exponent[marketIndex];

      // NOTE: `x * 5e17` == `(x * 10e18) / 2`
      uint256 longRewardUnscaled = (numerator * 5e17) / denominator;
      uint256 shortRewardUnscaled = 1e18 - longRewardUnscaled;

      return ((longRewardUnscaled * k * longPrice) / 1e18, (shortRewardUnscaled * k * shortPrice) / 1e18);
    } else {
      if (-equilibriumOffsetMarketScaled >= int256(longValue)) {
        // edge case: imbalanced far past the equilibrium offset - full rewards go to long token
        //            extremeley unlikely to happen in practice
        return (1e18 * k * longPrice, 0);
      }

      uint256 numerator = (uint256(int256(longValue) + equilibriumOffsetMarketScaled) >>
        (safeExponentBitShifting - 1))**balanceIncentiveCurve_exponent[marketIndex];

      // NOTE: `x * 5e17` == `(x * 10e18) / 2`
      uint256 shortRewardUnscaled = (numerator * 5e17) / denominator;
      uint256 longRewardUnscaled = 1e18 - shortRewardUnscaled;

      return ((longRewardUnscaled * k * longPrice) / 1e18, (shortRewardUnscaled * k * shortPrice) / 1e18);
    }
  }

  /**
  @notice Computes the time since last accumulativeIssuancePerStakedSynthSnapshot for the given market in seconds.
  @param marketIndex The market referred to.
  @return The time difference in seconds
  */
  function _calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(uint32 marketIndex)
    internal
    view
    virtual
    returns (uint256)
  {
    return
      block.timestamp -
      accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]].timestamp;
  }

  /**
  @notice Computes new cumulative sum of 'r' value since last accumulativeIssuancePerStakedSynthSnapshot. We use
  cumulative 'r' value to avoid looping during issuance. Note that the
  cumulative sum is kept in 1e42 scale (!!!) to avoid numerical issues.
  @param shortValue The value locked in the short side of the market.
  @param longValue The value locked in the long side of the market.
  @param shortPrice The price of the short token as defined in LongShort.sol
  @param longPrice The price of the long token as defined in LongShort.sol
  @param marketIndex An identifier for the market.
  @return longCumulativeRates The long cumulative sum.
  @return shortCumulativeRates The short cumulative sum.
  */
  function _calculateNewCumulativeIssuancePerStakedSynth(
    uint32 marketIndex,
    uint256 longPrice,
    uint256 shortPrice,
    uint256 longValue,
    uint256 shortValue
  ) internal view virtual returns (uint256 longCumulativeRates, uint256 shortCumulativeRates) {
    // Compute the current 'r' value for float issuance per second.
    (uint256 longFloatPerSecond, uint256 shortFloatPerSecond) = _calculateFloatPerSecond(
      marketIndex,
      longPrice,
      shortPrice,
      longValue,
      shortValue
    );

    // Compute time since last accumulativeIssuancePerStakedSynthSnapshot for the given token.
    uint256 timeDelta = _calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(marketIndex);

    // Compute new cumulative 'r' value total.
    return (
      accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]]
      .accumulativeFloatPerSyntheticToken_long + (timeDelta * longFloatPerSecond),
      accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]]
      .accumulativeFloatPerSyntheticToken_short + (timeDelta * shortFloatPerSecond)
    );
  }

  /**
  @notice Creates a new accumulativeIssuancePerStakedSynthSnapshot for the given token and updates indexes.
  @param shortValue The value locked in the short side of the market.
  @param longValue The value locked in the long side of the market.
  @param shortPrice The price of the short token as defined in LongShort.sol
  @param longPrice The price of the long token as defined in LongShort.sol
  @param marketIndex An identifier for the market.
  */
  function _setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot(
    uint32 marketIndex,
    uint256 longPrice,
    uint256 shortPrice,
    uint256 longValue,
    uint256 shortValue
  ) internal virtual {
    (
      uint256 newLongAccumulativeValue,
      uint256 newShortAccumulativeValue
    ) = _calculateNewCumulativeIssuancePerStakedSynth(marketIndex, longPrice, shortPrice, longValue, shortValue);

    uint256 newIndex = latestRewardIndex[marketIndex] + 1;

    // Set cumulative 'r' value on new accumulativeIssuancePerStakedSynthSnapshot.
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex]
    .accumulativeFloatPerSyntheticToken_long = newLongAccumulativeValue;
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex]
    .accumulativeFloatPerSyntheticToken_short = newShortAccumulativeValue;

    // Set timestamp on new accumulativeIssuancePerStakedSynthSnapshot.
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex].timestamp = block.timestamp;

    // Update latest index to point to new accumulativeIssuancePerStakedSynthSnapshot.
    latestRewardIndex[marketIndex] = newIndex;

    emit AccumulativeIssuancePerStakedSynthSnapshotCreated(
      marketIndex,
      newIndex,
      newLongAccumulativeValue,
      newShortAccumulativeValue
    );
  }

  /**
  @notice Adds new accumulativeIssuancePerStakedSynthSnapshots for the given long/short tokens. Called by the
  ILongShort contract whenever there is a state change for a market.
  @param stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted Mapping from this contract's shifts to LongShort.sols next price snapshots.
  @param shortValue The value locked in the short side of the market.
  @param longValue The value locked in the long side of the market.
  @param shortPrice The price of the short token as defined in LongShort.sol
  @param longPrice The price of the long token as defined in LongShort.sol
  @param marketIndex An identifier for the market.
  */
  function pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(
    uint32 marketIndex,
    uint256 longPrice,
    uint256 shortPrice,
    uint256 longValue,
    uint256 shortValue,
    uint256 stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted // This value should be ALWAYS be zero if no shift occured
  ) external override onlyLongShort {
    // Only add a new accumulativeIssuancePerStakedSynthSnapshot if some time has passed.

    // the `stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted` value will be 0 if there is no staker related action in an executed batch
    if (stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted > 0) {
      stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[
        batched_stakerNextTokenShiftIndex[marketIndex]
      ] = stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted;
      stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[
        batched_stakerNextTokenShiftIndex[marketIndex]
      ] = latestRewardIndex[marketIndex] + 1;
      batched_stakerNextTokenShiftIndex[marketIndex] += 1;

      emit SyntheticTokensShifted();
    }

    // Time delta is fetched twice in below code, can pass through? Which is less gas?
    if (_calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(marketIndex) > 0) {
      _setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot(
        marketIndex,
        longPrice,
        shortPrice,
        longValue,
        shortValue
      );
    }
  }

  /*╔═══════════════════════════════════╗
    ║    USER REWARD STATE FUNCTIONS    ║
    ╚═══════════════════════════════════╝*/

  /// @dev Calculates the accumulated float in a specific range of staker snapshots
  function _calculateAccumulatedFloatInRange(
    uint32 marketIndex,
    uint256 amountStakedLong,
    uint256 amountStakedShort,
    uint256 rewardIndexFrom,
    uint256 rewardIndexTo
  ) internal view virtual returns (uint256 floatReward) {
    if (amountStakedLong > 0) {
      uint256 accumDeltaLong = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexTo]
      .accumulativeFloatPerSyntheticToken_long -
        accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexFrom]
        .accumulativeFloatPerSyntheticToken_long;
      floatReward += (accumDeltaLong * amountStakedLong) / FLOAT_ISSUANCE_FIXED_DECIMAL;
    }

    if (amountStakedShort > 0) {
      uint256 accumDeltaShort = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexTo]
      .accumulativeFloatPerSyntheticToken_short -
        accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexFrom]
        .accumulativeFloatPerSyntheticToken_short;
      floatReward += (accumDeltaShort * amountStakedShort) / FLOAT_ISSUANCE_FIXED_DECIMAL;
    }
  }

  /** 
  @notice Calculates float owed to the user since the user last minted float for a market.
  @param marketIndex Identifier for the market which the user staked in.
  @param user The address of the user.
  @return floatReward The amount of float owed.
   */
  function _calculateAccumulatedFloat(uint32 marketIndex, address user) internal virtual returns (uint256 floatReward) {
    address longToken = syntheticTokens[marketIndex][true];
    address shortToken = syntheticTokens[marketIndex][false];

    uint256 amountStakedLong = userAmountStaked[longToken][user];
    uint256 amountStakedShort = userAmountStaked[shortToken][user];

    uint256 usersLastRewardIndex = userIndexOfLastClaimedReward[marketIndex][user];

    // Don't do the calculation and return zero immediately if there is no change
    if (usersLastRewardIndex == latestRewardIndex[marketIndex]) {
      return 0;
    }

    uint256 usersShiftIndex = userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][user];
    // if there is a change in the users tokens held due to a token shift (or possibly another action in the future)
    if (usersShiftIndex > 0 && usersShiftIndex < batched_stakerNextTokenShiftIndex[marketIndex]) {
      floatReward = _calculateAccumulatedFloatInRange(
        marketIndex,
        amountStakedLong,
        amountStakedShort,
        usersLastRewardIndex,
        stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[usersShiftIndex]
      );

      // Update the users balances
      if (userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user] > 0) {
        amountStakedShort += ILongShort(longShort).getAmountSyntheticTokenToMintOnTargetSide(
          marketIndex,
          userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user],
          true,
          stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[usersShiftIndex]
        );

        amountStakedLong -= userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user];
        userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user] = 0;
      }

      if (userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user] > 0) {
        amountStakedLong += ILongShort(longShort).getAmountSyntheticTokenToMintOnTargetSide(
          marketIndex,
          userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user],
          false,
          stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[usersShiftIndex]
        );

        amountStakedShort -= userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user];
        userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user] = 0;
      }

      // Save the users updated staked amounts
      userAmountStaked[longToken][user] = amountStakedLong;
      userAmountStaked[shortToken][user] = amountStakedShort;

      floatReward += _calculateAccumulatedFloatInRange(
        marketIndex,
        amountStakedLong,
        amountStakedShort,
        stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[usersShiftIndex],
        latestRewardIndex[marketIndex]
      );

      userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][user] = 0;
    } else {
      floatReward = _calculateAccumulatedFloatInRange(
        marketIndex,
        amountStakedLong,
        amountStakedShort,
        usersLastRewardIndex,
        latestRewardIndex[marketIndex]
      );
    }
  }

  /**
  @notice Mints float for a user.
  @dev Mints a fixed percentage for Float capital.
  @param user The address of the user.
  @param floatToMint The amount of float to mint.
   */
  function _mintFloat(address user, uint256 floatToMint) internal virtual {
    IFloatToken(floatToken).mint(user, floatToMint);
    IFloatToken(floatToken).mint(floatCapital, (floatToMint * floatPercentage) / 1e18);
  }

  /**
  @notice Mints float owed to a user for a market since they last minted.
  @param marketIndex An identifier for the market.
  @param user The address of the user.
   */
  function _mintAccumulatedFloat(uint32 marketIndex, address user) internal virtual {
    uint256 floatToMint = _calculateAccumulatedFloat(marketIndex, user);

    if (floatToMint > 0) {
      // Set the user has claimed up until now, stops them setting this forward
      userIndexOfLastClaimedReward[marketIndex][user] = latestRewardIndex[marketIndex];

      _mintFloat(user, floatToMint);
      emit FloatMinted(user, marketIndex, floatToMint);
    }
  }

  /**
  @notice Mints float owed to a user for multiple markets, since they last minted for those markets.
  @param marketIndexes Identifiers for the markets.
  @param user The address of the user.
   */
  function _mintAccumulatedFloatMulti(uint32[] calldata marketIndexes, address user) internal virtual {
    uint256 floatTotal = 0;
    for (uint256 i = 0; i < marketIndexes.length; i++) {
      uint256 floatToMint = _calculateAccumulatedFloat(marketIndexes[i], user);

      if (floatToMint > 0) {
        // Set the user has claimed up until now, stops them setting this forward
        userIndexOfLastClaimedReward[marketIndexes[i]][user] = latestRewardIndex[marketIndexes[i]];

        floatTotal += floatToMint;

        emit FloatMinted(user, marketIndexes[i], floatToMint);
      }
    }
    if (floatTotal > 0) {
      _mintFloat(user, floatTotal);
    }
  }

  /**
  @notice Mints outstanding float for msg.sender.
  @param marketIndexes Identifiers for the markets for which to mint float.
   */
  function claimFloatCustom(uint32[] calldata marketIndexes) external {
    ILongShort(longShort).updateSystemStateMulti(marketIndexes);
    _mintAccumulatedFloatMulti(marketIndexes, msg.sender);
  }

  /**
  @notice Mints outstanding float on behalf of another user.
  @param marketIndexes Identifiers for the markets for which to mint float.
  @param user The address of the user.
   */
  function claimFloatCustomFor(uint32[] calldata marketIndexes, address user) external {
    // Unbounded loop - users are responsible for paying their own gas costs on these and it doesn't effect the rest of the system.
    // No need to impose limit.
    ILongShort(longShort).updateSystemStateMulti(marketIndexes);
    _mintAccumulatedFloatMulti(marketIndexes, user);
  }

  /*╔═══════════════════════╗
    ║        STAKING        ║
    ╚═══════════════════════╝*/

  /**
  @notice A user with synthetic tokens stakes by calling stake on the token
  contract which calls this function. We need to first update the
  state of the LongShort contract for this market before staking to correctly calculate user rewards.
  @param amount Amount to stake.
  @param from Address to stake for.
  */
  function stakeFromUser(address from, uint256 amount) public virtual override onlyValidSynthetic((msg.sender)) {
    ILongShort(longShort).updateSystemState(marketIndexOfToken[(msg.sender)]);
    _stake((msg.sender), amount, from);
  }

  /**
  @dev Internal logic for staking.
  @param token Address of the token for which to stake.
  @param amount Amount to stake.
  @param user Address to stake for.
  */
  function _stake(
    address token,
    uint256 amount,
    address user
  ) internal virtual {
    uint32 marketIndex = marketIndexOfToken[token];

    // If they already have staked and have rewards due, mint these.
    if (
      userIndexOfLastClaimedReward[marketIndex][user] != 0 &&
      userIndexOfLastClaimedReward[marketIndex][user] < latestRewardIndex[marketIndex]
    ) {
      _mintAccumulatedFloat(marketIndex, user);
    }

    userAmountStaked[token][user] = userAmountStaked[token][user] + amount;

    userIndexOfLastClaimedReward[marketIndex][user] = latestRewardIndex[marketIndex];

    emit StakeAdded(user, address(token), amount, userIndexOfLastClaimedReward[marketIndex][user]);
  }

  /**
  @notice Allows users to shift their staked tokens from one side of the market to 
  the other at the next price.
  @param amountSyntheticTokensToShift Amount of tokens to shift.
  @param marketIndex Identifier for the market.
  @param isShiftFromLong Whether the shift is from long to short or short to long.
  */
  function shiftTokens(
    uint256 amountSyntheticTokensToShift,
    uint32 marketIndex,
    bool isShiftFromLong
  ) external virtual {
    address token = syntheticTokens[marketIndex][isShiftFromLong];
    require(userAmountStaked[token][msg.sender] >= amountSyntheticTokensToShift, "Not enough tokens to shift");

    // If the user has outstanding token shift that have already been confirmed in the LongShort
    // contract, execute them first.
    if (
      userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] != 0 &&
      userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] <
      batched_stakerNextTokenShiftIndex[marketIndex]
    ) {
      _mintAccumulatedFloat(marketIndex, msg.sender);
    }

    if (isShiftFromLong) {
      ILongShort(longShort).shiftPositionFromLongNextPrice(marketIndex, amountSyntheticTokensToShift);
      userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][
        msg.sender
      ] += amountSyntheticTokensToShift;
    } else {
      ILongShort(longShort).shiftPositionFromShortNextPrice(marketIndex, amountSyntheticTokensToShift);
      userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][
        msg.sender
      ] += amountSyntheticTokensToShift;
    }

    userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] = batched_stakerNextTokenShiftIndex[
      marketIndex
    ];
  }

  /*╔════════════════════════════╗
    ║    WITHDRAWAL & MINTING    ║
    ╚════════════════════════════╝*/

  /**
  @notice Internal logic for withdrawing stakes.
  @dev Mint user any outstanding float before withdrawing.
  @param marketIndex Market index of token.
  @param amount Amount to withdraw.
  @param token Synthetic token that was staked.
  */
  function _withdraw(
    uint32 marketIndex,
    address token,
    uint256 amount
  ) internal virtual {
    require(userAmountStaked[token][msg.sender] > 0, "nothing to withdraw");
    _mintAccumulatedFloat(marketIndex, msg.sender);

    userAmountStaked[token][msg.sender] = userAmountStaked[token][msg.sender] - amount;

    uint256 amountFees = (amount * marketUnstakeFee_e18[marketIndex]) / 1e18;

    IERC20(token).transfer(floatTreasury, amountFees);
    IERC20(token).transfer(msg.sender, amount - amountFees);

    emit StakeWithdrawn(msg.sender, token, amount);
  }

  /**
  @notice Withdraw function. Allows users to unstake.
  @param amount Amount to withdraw.
  @param token Address of the token for which to withdraw.
  */
  function withdraw(address token, uint256 amount) external {
    ILongShort(longShort).updateSystemState(marketIndexOfToken[token]);

    uint32 marketIndex = marketIndexOfToken[token];

    _withdraw(marketIndex, token, amount);

    if (userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] > 0) {
      // If they still have outstanding shifts after minting float, then check
      // that they don't withdraw more than their shifts allow.
      uint256 amountToShiftForThisToken = syntheticTokens[marketIndex][true] == token
        ? userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][msg.sender]
        : userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][msg.sender];

      require(
        userAmountStaked[token][msg.sender] >= amountToShiftForThisToken,
        "Outstanding next price stake shifts too great"
      );
    }
  }

  /**
  @notice Allows users to withdraw their entire stake for a token.
  @param token Address of the token for which to withdraw.
  */
  function withdrawAll(address token) external {
    ILongShort(longShort).updateSystemState(marketIndexOfToken[token]);

    uint32 marketIndex = marketIndexOfToken[token];

    uint256 amountToShiftForThisToken = syntheticTokens[marketIndex][true] == token
      ? userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][msg.sender]
      : userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][msg.sender];

    _withdraw(marketIndex, token, userAmountStaked[token][msg.sender] - amountToShiftForThisToken);
  }
}
.]

Below are the details of our target smart contract codes and their associated test reports:

Task: "// SPDX-License-Identifier: BUSL-1.1

pragma solidity 0.8.3;

import "@openzeppelin/contracts-upgradeable/token/ERC20/presets/ERC20PresetMinterPauserUpgradeable.sol";

import "./interfaces/IFloatToken.sol";
import "./interfaces/ILongShort.sol";
import "./interfaces/IStaker.sol";
import "./interfaces/ISyntheticToken.sol";

contract Staker is IStaker, Initializable {
  /*╔═════════════════════════════╗
    ║          VARIABLES          ║
    ╚═════════════════════════════╝*/

  /* ══════ Fixed-precision constants ══════ */
  uint256 public constant FLOAT_ISSUANCE_FIXED_DECIMAL = 1e42;
  // 2^52 ~= 4.5e15
  // With an exponent of 5, the largest total liquidity possible in a market (to avoid integer overflow on exponentiation) is ~10^31 or 10 Trillion (10^13)
  // NOTE: this also means if the total market value is less than 2^52 there will be a division by zero error
  uint256 public constant safeExponentBitShifting = 52;

  /* ══════ Global state ══════ */
  address public admin;
  address public floatCapital;
  address public floatTreasury;
  uint256 public floatPercentage;

  address public longShort;
  address public floatToken;

  /* ══════ Market specific ══════ */
  mapping(uint32 => uint256) public marketLaunchIncentive_period; // seconds
  mapping(uint32 => uint256) public marketLaunchIncentive_multipliers; // e18 scale
  mapping(uint32 => uint256) public marketUnstakeFee_e18;
  mapping(uint32 => uint256) public balanceIncentiveCurve_exponent;
  mapping(uint32 => int256) public balanceIncentiveCurve_equilibriumOffset;

  mapping(uint32 => mapping(bool => address)) public syntheticTokens;

  mapping(address => uint32) public marketIndexOfToken;

  /* ══════ Reward specific ══════ */
  mapping(uint32 => uint256) public latestRewardIndex;
  mapping(uint32 => mapping(uint256 => AccumulativeIssuancePerStakedSynthSnapshot))
    public accumulativeFloatPerSyntheticTokenSnapshots;
  struct AccumulativeIssuancePerStakedSynthSnapshot {
    uint256 timestamp;
    uint256 accumulativeFloatPerSyntheticToken_long;
    uint256 accumulativeFloatPerSyntheticToken_short;
  }

  /* ══════ User specific ══════ */
  mapping(uint32 => mapping(address => uint256)) public userIndexOfLastClaimedReward;
  mapping(address => mapping(address => uint256)) public userAmountStaked;

  /* ══════ Token shift management specific ══════ */
  mapping(uint32 => uint256) public batched_stakerNextTokenShiftIndex;
  /**
  @notice Used to link a token shift to a staker state
  @dev tokenShiftIndex => accumulativeFloatIssuanceSnapshotIndex
    POSSIBLE OPTIMIZATION - could pack stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping and stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping into a struct of two uint128 for storage space optimization.
  */
  mapping(uint256 => uint256) public stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping;
  /// @notice Used to fetch the price from LongShort at that point in time
  /// @dev tokenShiftIndex => longShortMarketPriceSnapshotIndex
  mapping(uint256 => uint256) public stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping;
  /// @dev marketIndex => usersAddress => stakerTokenShiftIndex
  mapping(uint32 => mapping(address => uint256)) public userNextPrice_stakedSyntheticTokenShiftIndex;
  /// @dev marketIndex => usersAddress => amountUserRequestedToShiftAwayFromLongOnNextUpdate
  mapping(uint32 => mapping(address => uint256)) public userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long;
  /// @dev marketIndex => usersAddress => amountUserRequestedToShiftAwayFromShortOnNextUpdate
  mapping(uint32 => mapping(address => uint256)) public userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short;

  /*╔════════════════════════════╗
    ║           EVENTS           ║
    ╚════════════════════════════╝*/

  event StakerV1(
    address admin,
    address floatTreasury,
    address floatCapital,
    address floatToken,
    uint256 floatPercentage
  );

  event MarketAddedToStaker(
    uint32 marketIndex,
    uint256 exitFee_e18,
    uint256 period,
    uint256 multiplier,
    uint256 balanceIncentiveExponent,
    int256 balanceIncentiveEquilibriumOffset
  );

  event AccumulativeIssuancePerStakedSynthSnapshotCreated(
    uint32 marketIndex,
    uint256 accumulativeFloatIssuanceSnapshotIndex,
    uint256 accumulativeLong,
    uint256 accumulativeShort
  );

  event StakeAdded(address user, address token, uint256 amount, uint256 lastMintIndex);

  event StakeWithdrawn(address user, address token, uint256 amount);

  // Note: the `amountFloatMinted` isn't strictly needed by the graph, but it is good to add it to validate calculations are accurate.
  event FloatMinted(address user, uint32 marketIndex, uint256 amountFloatMinted);

  event MarketLaunchIncentiveParametersChanges(uint32 marketIndex, uint256 period, uint256 multiplier);

  event StakeWithdrawalFeeUpdated(uint32 marketIndex, uint256 stakeWithdralFee);

  event BalanceIncentiveExponentUpdated(uint32 marketIndex, uint256 balanceIncentiveExponent);

  event BalanceIncentiveEquilibriumOffsetUpdated(uint32 marketIndex, int256 balanceIncentiveEquilibriumOffset);

  event FloatPercentageUpdated(uint256 floatPercentage);

  event SyntheticTokensShifted();

  event ChangeAdmin(address newAdmin);

  /*╔═════════════════════════════╗
    ║          MODIFIERS          ║
    ╚═════════════════════════════╝*/

  function onlyAdminModifierLogic() internal virtual {
    require(msg.sender == admin, "not admin");
  }

  modifier onlyAdmin() {
    onlyAdminModifierLogic();
    _;
  }

  function onlyValidSyntheticModifierLogic(address _synth) internal virtual {
    require(marketIndexOfToken[_synth] != 0, "not valid synth");
  }

  modifier onlyValidSynthetic(address _synth) {
    onlyValidSyntheticModifierLogic(_synth);
    _;
  }

  function onlyValidMarketModifierLogic(uint32 marketIndex) internal virtual {
    require(address(syntheticTokens[marketIndex][true]) != address(0), "not valid market");
  }

  modifier onlyValidMarket(uint32 marketIndex) {
    onlyValidMarketModifierLogic(marketIndex);
    _;
  }

  function onlyLongShortModifierLogic() internal virtual {
    require(msg.sender == address(longShort), "not long short");
  }

  modifier onlyLongShort() {
    onlyLongShortModifierLogic();
    _;
  }

  /*╔═════════════════════════════╗
    ║       CONTRACT SET-UP       ║
    ╚═════════════════════════════╝*/

  /**
  @notice Initializes the contract.
  @dev Calls OpenZeppelin's initializer modifier.
  @param _admin Address of the admin role.
  @param _longShort Address of the LongShort contract, a deployed LongShort.sol
  @param _floatToken Address of the Float token earned by staking.
  @param _floatTreasury Address of the treasury contract for managing fees.
  @param _floatCapital Address of the contract which earns a fixed percentage of Float.
  @param _floatPercentage Determines the float percentage that gets minted for Float Capital, base 1e18.
  */
  function initialize(
    address _admin,
    address _longShort,
    address _floatToken,
    address _floatTreasury,
    address _floatCapital,
    uint256 _floatPercentage
  ) external virtual initializer {
    admin = _admin;
    floatCapital = _floatCapital;
    floatTreasury = _floatTreasury;
    longShort = _longShort;
    floatToken = _floatToken;

    _changeFloatPercentage(_floatPercentage);

    emit StakerV1(_admin, _floatTreasury, _floatCapital, _floatToken, _floatPercentage);
  }

  /*╔═══════════════════╗
    ║       ADMIN       ║
    ╚═══════════════════╝*/

  /** 
  @notice Changes admin for the contract
  @param _admin The address of the new admin.
  */
  function changeAdmin(address _admin) external onlyAdmin {
    admin = _admin;
    emit ChangeAdmin(_admin);
  }

  /// @dev Logic for changeFloatPercentage
  function _changeFloatPercentage(uint256 newFloatPercentage) internal virtual {
    require(newFloatPercentage <= 1e18 && newFloatPercentage > 0); // less than or equal to 100% and greater than 0%
    floatPercentage = newFloatPercentage;
  }

  /**
  @notice Changes percentage of float that is minted for float capital.
  @param newFloatPercentage The new float percentage in base 1e18.
  */
  function changeFloatPercentage(uint256 newFloatPercentage) external onlyAdmin {
    _changeFloatPercentage(newFloatPercentage);
    emit FloatPercentageUpdated(newFloatPercentage);
  }

  /// @dev Logic for changeUnstakeFee
  function _changeUnstakeFee(uint32 marketIndex, uint256 newMarketUnstakeFee_e18) internal virtual {
    require(newMarketUnstakeFee_e18 <= 5e16); // Explicitely stating 5% fee as the max fee possible.
    marketUnstakeFee_e18[marketIndex] = newMarketUnstakeFee_e18;
  }

  /**
  @notice Changes unstake fee for a market
  @param marketIndex Identifies the market.
  @param newMarketUnstakeFee_e18 The new unstake fee.
  */
  function changeUnstakeFee(uint32 marketIndex, uint256 newMarketUnstakeFee_e18) external onlyAdmin {
    _changeUnstakeFee(marketIndex, newMarketUnstakeFee_e18);
    emit StakeWithdrawalFeeUpdated(marketIndex, newMarketUnstakeFee_e18);
  }

  /// @dev Logic for changeMarketLaunchIncentiveParameters
  function _changeMarketLaunchIncentiveParameters(
    uint32 marketIndex,
    uint256 period,
    uint256 initialMultiplier
  ) internal virtual {
    require(initialMultiplier >= 1e18, "marketLaunchIncentiveMultiplier must be >= 1e18");

    marketLaunchIncentive_period[marketIndex] = period;
    marketLaunchIncentive_multipliers[marketIndex] = initialMultiplier;
  }

  /**
  @notice Changes the market launch incentive parameters for a market
  @param marketIndex Identifies the market.
  @param period The new period for which float token generation should be boosted.
  @param initialMultiplier The new multiplier on Float generation.
  */
  function changeMarketLaunchIncentiveParameters(
    uint32 marketIndex,
    uint256 period,
    uint256 initialMultiplier
  ) external onlyAdmin {
    _changeMarketLaunchIncentiveParameters(marketIndex, period, initialMultiplier);

    emit MarketLaunchIncentiveParametersChanges(marketIndex, period, initialMultiplier);
  }

  /// @dev Logic for changeBalanceIncentiveExponent
  function _changeBalanceIncentiveExponent(uint32 marketIndex, uint256 _balanceIncentiveCurve_exponent)
    internal
    virtual
  {
    require(
      // The exponent has to be less than 5 in these versions of the contracts.
      _balanceIncentiveCurve_exponent > 0 && _balanceIncentiveCurve_exponent < 6,
      "balanceIncentiveCurve_exponent out of bounds"
    );

    balanceIncentiveCurve_exponent[marketIndex] = _balanceIncentiveCurve_exponent;
  }

  /** 
  @notice Changes the balance incentive exponent for a market
  @param marketIndex Identifies the market.
  @param _balanceIncentiveCurve_exponent The new exponent for the curve.
  */
  function changeBalanceIncentiveExponent(uint32 marketIndex, uint256 _balanceIncentiveCurve_exponent)
    external
    onlyAdmin
  {
    _changeBalanceIncentiveExponent(marketIndex, _balanceIncentiveCurve_exponent);

    emit BalanceIncentiveExponentUpdated(marketIndex, _balanceIncentiveCurve_exponent);
  }

  /// @dev Logic for changeBalanceIncentiveEquilibriumOffset
  function _changeBalanceIncentiveEquilibriumOffset(uint32 marketIndex, int256 _balanceIncentiveCurve_equilibriumOffset)
    internal
    virtual
  {
    // Unreasonable that we would ever shift this more than 90% either way
    require(
      _balanceIncentiveCurve_equilibriumOffset > -9e17 && _balanceIncentiveCurve_equilibriumOffset < 9e17,
      "balanceIncentiveCurve_equilibriumOffset out of bounds"
    );

    balanceIncentiveCurve_equilibriumOffset[marketIndex] = _balanceIncentiveCurve_equilibriumOffset;
  }

  /**
  @notice Changes the balance incentive curve equilibrium offset for a market
  @param marketIndex Identifies the market.
  @param _balanceIncentiveCurve_equilibriumOffset The new offset.
  */
  function changeBalanceIncentiveEquilibriumOffset(uint32 marketIndex, int256 _balanceIncentiveCurve_equilibriumOffset)
    external
    onlyAdmin
  {
    _changeBalanceIncentiveEquilibriumOffset(marketIndex, _balanceIncentiveCurve_equilibriumOffset);

    emit BalanceIncentiveEquilibriumOffsetUpdated(marketIndex, _balanceIncentiveCurve_equilibriumOffset);
  }

  /*╔═════════════════════════════╗
    ║        STAKING SETUP        ║
    ╚═════════════════════════════╝*/

  /**
  @notice Sets this contract to track staking for a market in LongShort.sol
  @param marketIndex Identifies the market.
  @param longToken Address of the long token for the market.
  @param shortToken Address of the short token for the market.
  @param kInitialMultiplier Initial boost on float generation for the market.
  @param kPeriod Period which the boost should last.
  @param unstakeFee_e18 Percentage of tokens that are levied on unstaking in base 1e18.
  @param _balanceIncentiveCurve_exponent Exponent for balance curve (see _calculateFloatPerSecond)
  @param _balanceIncentiveCurve_equilibriumOffset Offset for balance curve (see _calculateFloatPerSecond)
  */
  function addNewStakingFund(
    uint32 marketIndex,
    address longToken,
    address shortToken,
    uint256 kInitialMultiplier,
    uint256 kPeriod,
    uint256 unstakeFee_e18,
    uint256 _balanceIncentiveCurve_exponent,
    int256 _balanceIncentiveCurve_equilibriumOffset
  ) external override onlyLongShort {
    marketIndexOfToken[longToken] = marketIndex;
    marketIndexOfToken[shortToken] = marketIndex;

    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].timestamp = block.timestamp;
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].accumulativeFloatPerSyntheticToken_long = 0;
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].accumulativeFloatPerSyntheticToken_short = 0;

    syntheticTokens[marketIndex][true] = longToken;
    syntheticTokens[marketIndex][false] = shortToken;

    _changeBalanceIncentiveExponent(marketIndex, _balanceIncentiveCurve_exponent);
    _changeBalanceIncentiveEquilibriumOffset(marketIndex, _balanceIncentiveCurve_equilibriumOffset);
    _changeMarketLaunchIncentiveParameters(marketIndex, kPeriod, kInitialMultiplier);

    _changeUnstakeFee(marketIndex, unstakeFee_e18);

    // Set this value to one initially - 0 is a null value and thus potentially bug prone.
    batched_stakerNextTokenShiftIndex[marketIndex] = 1;

    emit MarketAddedToStaker(
      marketIndex,
      unstakeFee_e18,
      kPeriod,
      kInitialMultiplier,
      _balanceIncentiveCurve_exponent,
      _balanceIncentiveCurve_equilibriumOffset
    );

    emit AccumulativeIssuancePerStakedSynthSnapshotCreated(marketIndex, 0, 0, 0);
  }

  /*╔═════════════════════════════════════════════════════════════════════════╗
    ║    GLOBAL FLT REWARD ACCUMULATION CALCULATION AND TRACKING FUNCTIONS    ║
    ╚═════════════════════════════════════════════════════════════════════════╝*/

  /**
  @notice Returns the K factor parameters for the given market with sensible
  defaults if they haven't been set yet.
  @param marketIndex The market to change the parameters for.
  @return period The period for which the k factor applies for in seconds.
  @return multiplier The multiplier on Float generation in this period.
  */
  function _getMarketLaunchIncentiveParameters(uint32 marketIndex)
    internal
    view
    virtual
    returns (uint256 period, uint256 multiplier)
  {
    period = marketLaunchIncentive_period[marketIndex];
    multiplier = marketLaunchIncentive_multipliers[marketIndex];

    if (multiplier < 1e18) {
      multiplier = 1e18; // multiplier of 1 by default
    }
  }

  /** 
  @notice Returns the extent to which a markets float generation should be adjusted
  based on the market's launch incentive parameters. Should start at multiplier
  then linearly change to 1e18 over time.
  @param marketIndex Identifies the market.
  @return k The calculated modifier for float generation.
  */
  function _getKValue(uint32 marketIndex) internal view virtual returns (uint256) {
    // Parameters controlling the float issuance multiplier.
    (uint256 kPeriod, uint256 kInitialMultiplier) = _getMarketLaunchIncentiveParameters(marketIndex);

    // Sanity check - under normal circumstances, the multipliers should
    // *never* be set to a value < 1e18, as there are guards against this.
    assert(kInitialMultiplier >= 1e18);

    uint256 initialTimestamp = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].timestamp;

    if (block.timestamp - initialTimestamp <= kPeriod) {
      return kInitialMultiplier - (((kInitialMultiplier - 1e18) * (block.timestamp - initialTimestamp)) / kPeriod);
    } else {
      return 1e18;
    }
  }

  /*
  @notice Computes the number of float tokens a user earns per second for
  every long/short synthetic token they've staked. The returned value has
  a fixed decimal scale of 1e42 (!!!) for numerical stability. The return
  values are float per second per synthetic token (hence the requirement
  to multiply by price)
  @dev to see below math in latex form see TODO add link
  to interact with the equations see https://www.desmos.com/calculator/optkaxyihr
  @param marketIndex The market referred to.
  @param longPrice Price of the synthetic long token in units of payment token
  @param shortPrice Price of the synthetic short token in units of payment token
  @param longValue Amount of payment token in the long side of the market
  @param shortValue Amount of payment token in the short side of the market
  @return longFloatPerSecond Float token per second per long synthetic token
  @return shortFloatPerSecond Float token per second per short synthetic token
   */
  function _calculateFloatPerSecond(
    uint32 marketIndex,
    uint256 longPrice,
    uint256 shortPrice,
    uint256 longValue,
    uint256 shortValue
  ) internal view virtual returns (uint256 longFloatPerSecond, uint256 shortFloatPerSecond) {
    // A float issuance multiplier that starts high and decreases linearly
    // over time to a value of 1. This incentivises users to stake early.
    uint256 k = _getKValue(marketIndex);

    uint256 totalLocked = (longValue + shortValue);

    // we need to scale this number by the totalLocked so that the offset remains consistent accross market size

    int256 equilibriumOffsetMarketScaled = (balanceIncentiveCurve_equilibriumOffset[marketIndex] *
      int256(totalLocked)) / 2e18;

    uint256 denominator = ((totalLocked >> safeExponentBitShifting)**balanceIncentiveCurve_exponent[marketIndex]);

    // Float is scaled by the percentage of the total market value held in
    // the opposite position. This incentivises users to stake on the
    // weaker position.
    if (int256(shortValue) - equilibriumOffsetMarketScaled < int256(longValue)) {
      if (equilibriumOffsetMarketScaled >= int256(shortValue)) {
        // edge case: imbalanced far past the equilibrium offset - full rewards go to short token
        //            extremeley unlikely to happen in practice
        return (0, 1e18 * k * shortPrice);
      }

      uint256 numerator = (uint256(int256(shortValue) - equilibriumOffsetMarketScaled) >>
        (safeExponentBitShifting - 1))**balanceIncentiveCurve_exponent[marketIndex];

      // NOTE: `x * 5e17` == `(x * 10e18) / 2`
      uint256 longRewardUnscaled = (numerator * 5e17) / denominator;
      uint256 shortRewardUnscaled = 1e18 - longRewardUnscaled;

      return ((longRewardUnscaled * k * longPrice) / 1e18, (shortRewardUnscaled * k * shortPrice) / 1e18);
    } else {
      if (-equilibriumOffsetMarketScaled >= int256(longValue)) {
        // edge case: imbalanced far past the equilibrium offset - full rewards go to long token
        //            extremeley unlikely to happen in practice
        return (1e18 * k * longPrice, 0);
      }

      uint256 numerator = (uint256(int256(longValue) + equilibriumOffsetMarketScaled) >>
        (safeExponentBitShifting - 1))**balanceIncentiveCurve_exponent[marketIndex];

      // NOTE: `x * 5e17` == `(x * 10e18) / 2`
      uint256 shortRewardUnscaled = (numerator * 5e17) / denominator;
      uint256 longRewardUnscaled = 1e18 - shortRewardUnscaled;

      return ((longRewardUnscaled * k * longPrice) / 1e18, (shortRewardUnscaled * k * shortPrice) / 1e18);
    }
  }

  /**
  @notice Computes the time since last accumulativeIssuancePerStakedSynthSnapshot for the given market in seconds.
  @param marketIndex The market referred to.
  @return The time difference in seconds
  */
  function _calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(uint32 marketIndex)
    internal
    view
    virtual
    returns (uint256)
  {
    return
      block.timestamp -
      accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]].timestamp;
  }

  /**
  @notice Computes new cumulative sum of 'r' value since last accumulativeIssuancePerStakedSynthSnapshot. We use
  cumulative 'r' value to avoid looping during issuance. Note that the
  cumulative sum is kept in 1e42 scale (!!!) to avoid numerical issues.
  @param shortValue The value locked in the short side of the market.
  @param longValue The value locked in the long side of the market.
  @param shortPrice The price of the short token as defined in LongShort.sol
  @param longPrice The price of the long token as defined in LongShort.sol
  @param marketIndex An identifier for the market.
  @return longCumulativeRates The long cumulative sum.
  @return shortCumulativeRates The short cumulative sum.
  */
  function _calculateNewCumulativeIssuancePerStakedSynth(
    uint32 marketIndex,
    uint256 longPrice,
    uint256 shortPrice,
    uint256 longValue,
    uint256 shortValue
  ) internal view virtual returns (uint256 longCumulativeRates, uint256 shortCumulativeRates) {
    // Compute the current 'r' value for float issuance per second.
    (uint256 longFloatPerSecond, uint256 shortFloatPerSecond) = _calculateFloatPerSecond(
      marketIndex,
      longPrice,
      shortPrice,
      longValue,
      shortValue
    );

    // Compute time since last accumulativeIssuancePerStakedSynthSnapshot for the given token.
    uint256 timeDelta = _calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(marketIndex);

    // Compute new cumulative 'r' value total.
    return (
      accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]]
      .accumulativeFloatPerSyntheticToken_long + (timeDelta * longFloatPerSecond),
      accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]]
      .accumulativeFloatPerSyntheticToken_short + (timeDelta * shortFloatPerSecond)
    );
  }

  /**
  @notice Creates a new accumulativeIssuancePerStakedSynthSnapshot for the given token and updates indexes.
  @param shortValue The value locked in the short side of the market.
  @param longValue The value locked in the long side of the market.
  @param shortPrice The price of the short token as defined in LongShort.sol
  @param longPrice The price of the long token as defined in LongShort.sol
  @param marketIndex An identifier for the market.
  */
  function _setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot(
    uint32 marketIndex,
    uint256 longPrice,
    uint256 shortPrice,
    uint256 longValue,
    uint256 shortValue
  ) internal virtual {
    (
      uint256 newLongAccumulativeValue,
      uint256 newShortAccumulativeValue
    ) = _calculateNewCumulativeIssuancePerStakedSynth(marketIndex, longPrice, shortPrice, longValue, shortValue);

    uint256 newIndex = latestRewardIndex[marketIndex] + 1;

    // Set cumulative 'r' value on new accumulativeIssuancePerStakedSynthSnapshot.
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex]
    .accumulativeFloatPerSyntheticToken_long = newLongAccumulativeValue;
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex]
    .accumulativeFloatPerSyntheticToken_short = newShortAccumulativeValue;

    // Set timestamp on new accumulativeIssuancePerStakedSynthSnapshot.
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex].timestamp = block.timestamp;

    // Update latest index to point to new accumulativeIssuancePerStakedSynthSnapshot.
    latestRewardIndex[marketIndex] = newIndex;

    emit AccumulativeIssuancePerStakedSynthSnapshotCreated(
      marketIndex,
      newIndex,
      newLongAccumulativeValue,
      newShortAccumulativeValue
    );
  }

  /**
  @notice Adds new accumulativeIssuancePerStakedSynthSnapshots for the given long/short tokens. Called by the
  ILongShort contract whenever there is a state change for a market.
  @param stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted Mapping from this contract's shifts to LongShort.sols next price snapshots.
  @param shortValue The value locked in the short side of the market.
  @param longValue The value locked in the long side of the market.
  @param shortPrice The price of the short token as defined in LongShort.sol
  @param longPrice The price of the long token as defined in LongShort.sol
  @param marketIndex An identifier for the market.
  */
  function pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(
    uint32 marketIndex,
    uint256 longPrice,
    uint256 shortPrice,
    uint256 longValue,
    uint256 shortValue,
    uint256 stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted // This value should be ALWAYS be zero if no shift occured
  ) external override onlyLongShort {
    // Only add a new accumulativeIssuancePerStakedSynthSnapshot if some time has passed.

    // the `stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted` value will be 0 if there is no staker related action in an executed batch
    if (stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted > 0) {
      stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[
        batched_stakerNextTokenShiftIndex[marketIndex]
      ] = stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted;
      stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[
        batched_stakerNextTokenShiftIndex[marketIndex]
      ] = latestRewardIndex[marketIndex] + 1;
      batched_stakerNextTokenShiftIndex[marketIndex] += 1;

      emit SyntheticTokensShifted();
    }

    // Time delta is fetched twice in below code, can pass through? Which is less gas?
    if (_calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(marketIndex) > 0) {
      _setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot(
        marketIndex,
        longPrice,
        shortPrice,
        longValue,
        shortValue
      );
    }
  }

  /*╔═══════════════════════════════════╗
    ║    USER REWARD STATE FUNCTIONS    ║
    ╚═══════════════════════════════════╝*/

  /// @dev Calculates the accumulated float in a specific range of staker snapshots
  function _calculateAccumulatedFloatInRange(
    uint32 marketIndex,
    uint256 amountStakedLong,
    uint256 amountStakedShort,
    uint256 rewardIndexFrom,
    uint256 rewardIndexTo
  ) internal view virtual returns (uint256 floatReward) {
    if (amountStakedLong > 0) {
      uint256 accumDeltaLong = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexTo]
      .accumulativeFloatPerSyntheticToken_long -
        accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexFrom]
        .accumulativeFloatPerSyntheticToken_long;
      floatReward += (accumDeltaLong * amountStakedLong) / FLOAT_ISSUANCE_FIXED_DECIMAL;
    }

    if (amountStakedShort > 0) {
      uint256 accumDeltaShort = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexTo]
      .accumulativeFloatPerSyntheticToken_short -
        accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexFrom]
        .accumulativeFloatPerSyntheticToken_short;
      floatReward += (accumDeltaShort * amountStakedShort) / FLOAT_ISSUANCE_FIXED_DECIMAL;
    }
  }

  /** 
  @notice Calculates float owed to the user since the user last minted float for a market.
  @param marketIndex Identifier for the market which the user staked in.
  @param user The address of the user.
  @return floatReward The amount of float owed.
   */
  function _calculateAccumulatedFloat(uint32 marketIndex, address user) internal virtual returns (uint256 floatReward) {
    address longToken = syntheticTokens[marketIndex][true];
    address shortToken = syntheticTokens[marketIndex][false];

    uint256 amountStakedLong = userAmountStaked[longToken][user];
    uint256 amountStakedShort = userAmountStaked[shortToken][user];

    uint256 usersLastRewardIndex = userIndexOfLastClaimedReward[marketIndex][user];

    // Don't do the calculation and return zero immediately if there is no change
    if (usersLastRewardIndex == latestRewardIndex[marketIndex]) {
      return 0;
    }

    uint256 usersShiftIndex = userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][user];
    // if there is a change in the users tokens held due to a token shift (or possibly another action in the future)
    if (usersShiftIndex > 0 && usersShiftIndex < batched_stakerNextTokenShiftIndex[marketIndex]) {
      floatReward = _calculateAccumulatedFloatInRange(
        marketIndex,
        amountStakedLong,
        amountStakedShort,
        usersLastRewardIndex,
        stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[usersShiftIndex]
      );

      // Update the users balances
      if (userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user] > 0) {
        amountStakedShort += ILongShort(longShort).getAmountSyntheticTokenToMintOnTargetSide(
          marketIndex,
          userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user],
          true,
          stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[usersShiftIndex]
        );

        amountStakedLong -= userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user];
        userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user] = 0;
      }

      if (userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user] > 0) {
        amountStakedLong += ILongShort(longShort).getAmountSyntheticTokenToMintOnTargetSide(
          marketIndex,
          userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user],
          false,
          stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[usersShiftIndex]
        );

        amountStakedShort -= userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user];
        userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user] = 0;
      }

      // Save the users updated staked amounts
      userAmountStaked[longToken][user] = amountStakedLong;
      userAmountStaked[shortToken][user] = amountStakedShort;

      floatReward += _calculateAccumulatedFloatInRange(
        marketIndex,
        amountStakedLong,
        amountStakedShort,
        stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[usersShiftIndex],
        latestRewardIndex[marketIndex]
      );

      userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][user] = 0;
    } else {
      floatReward = _calculateAccumulatedFloatInRange(
        marketIndex,
        amountStakedLong,
        amountStakedShort,
        usersLastRewardIndex,
        latestRewardIndex[marketIndex]
      );
    }
  }

  /**
  @notice Mints float for a user.
  @dev Mints a fixed percentage for Float capital.
  @param user The address of the user.
  @param floatToMint The amount of float to mint.
   */
  function _mintFloat(address user, uint256 floatToMint) internal virtual {
    IFloatToken(floatToken).mint(user, floatToMint);
    IFloatToken(floatToken).mint(floatCapital, (floatToMint * floatPercentage) / 1e18);
  }

  /**
  @notice Mints float owed to a user for a market since they last minted.
  @param marketIndex An identifier for the market.
  @param user The address of the user.
   */
  function _mintAccumulatedFloat(uint32 marketIndex, address user) internal virtual {
    uint256 floatToMint = _calculateAccumulatedFloat(marketIndex, user);

    if (floatToMint > 0) {
      // Set the user has claimed up until now, stops them setting this forward
      userIndexOfLastClaimedReward[marketIndex][user] = latestRewardIndex[marketIndex];

      _mintFloat(user, floatToMint);
      emit FloatMinted(user, marketIndex, floatToMint);
    }
  }

  /**
  @notice Mints float owed to a user for multiple markets, since they last minted for those markets.
  @param marketIndexes Identifiers for the markets.
  @param user The address of the user.
   */
  function _mintAccumulatedFloatMulti(uint32[] calldata marketIndexes, address user) internal virtual {
    uint256 floatTotal = 0;
    for (uint256 i = 0; i < marketIndexes.length; i++) {
      uint256 floatToMint = _calculateAccumulatedFloat(marketIndexes[i], user);

      if (floatToMint > 0) {
        // Set the user has claimed up until now, stops them setting this forward
        userIndexOfLastClaimedReward[marketIndexes[i]][user] = latestRewardIndex[marketIndexes[i]];

        floatTotal += floatToMint;

        emit FloatMinted(user, marketIndexes[i], floatToMint);
      }
    }
    if (floatTotal > 0) {
      _mintFloat(user, floatTotal);
    }
  }

  /**
  @notice Mints outstanding float for msg.sender.
  @param marketIndexes Identifiers for the markets for which to mint float.
   */
  function claimFloatCustom(uint32[] calldata marketIndexes) external {
    ILongShort(longShort).updateSystemStateMulti(marketIndexes);
    _mintAccumulatedFloatMulti(marketIndexes, msg.sender);
  }

  /**
  @notice Mints outstanding float on behalf of another user.
  @param marketIndexes Identifiers for the markets for which to mint float.
  @param user The address of the user.
   */
  function claimFloatCustomFor(uint32[] calldata marketIndexes, address user) external {
    // Unbounded loop - users are responsible for paying their own gas costs on these and it doesn't effect the rest of the system.
    // No need to impose limit.
    ILongShort(longShort).updateSystemStateMulti(marketIndexes);
    _mintAccumulatedFloatMulti(marketIndexes, user);
  }

  /*╔═══════════════════════╗
    ║        STAKING        ║
    ╚═══════════════════════╝*/

  /**
  @notice A user with synthetic tokens stakes by calling stake on the token
  contract which calls this function. We need to first update the
  state of the LongShort contract for this market before staking to correctly calculate user rewards.
  @param amount Amount to stake.
  @param from Address to stake for.
  */
  function stakeFromUser(address from, uint256 amount) public virtual override onlyValidSynthetic((msg.sender)) {
    ILongShort(longShort).updateSystemState(marketIndexOfToken[(msg.sender)]);
    _stake((msg.sender), amount, from);
  }

  /**
  @dev Internal logic for staking.
  @param token Address of the token for which to stake.
  @param amount Amount to stake.
  @param user Address to stake for.
  */
  function _stake(
    address token,
    uint256 amount,
    address user
  ) internal virtual {
    uint32 marketIndex = marketIndexOfToken[token];

    // If they already have staked and have rewards due, mint these.
    if (
      userIndexOfLastClaimedReward[marketIndex][user] != 0 &&
      userIndexOfLastClaimedReward[marketIndex][user] < latestRewardIndex[marketIndex]
    ) {
      _mintAccumulatedFloat(marketIndex, user);
    }

    userAmountStaked[token][user] = userAmountStaked[token][user] + amount;

    userIndexOfLastClaimedReward[marketIndex][user] = latestRewardIndex[marketIndex];

    emit StakeAdded(user, address(token), amount, userIndexOfLastClaimedReward[marketIndex][user]);
  }

  /**
  @notice Allows users to shift their staked tokens from one side of the market to 
  the other at the next price.
  @param amountSyntheticTokensToShift Amount of tokens to shift.
  @param marketIndex Identifier for the market.
  @param isShiftFromLong Whether the shift is from long to short or short to long.
  */
  function shiftTokens(
    uint256 amountSyntheticTokensToShift,
    uint32 marketIndex,
    bool isShiftFromLong
  ) external virtual {
    address token = syntheticTokens[marketIndex][isShiftFromLong];
    require(userAmountStaked[token][msg.sender] >= amountSyntheticTokensToShift, "Not enough tokens to shift");

    // If the user has outstanding token shift that have already been confirmed in the LongShort
    // contract, execute them first.
    if (
      userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] != 0 &&
      userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] <
      batched_stakerNextTokenShiftIndex[marketIndex]
    ) {
      _mintAccumulatedFloat(marketIndex, msg.sender);
    }

    if (isShiftFromLong) {
      ILongShort(longShort).shiftPositionFromLongNextPrice(marketIndex, amountSyntheticTokensToShift);
      userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][
        msg.sender
      ] += amountSyntheticTokensToShift;
    } else {
      ILongShort(longShort).shiftPositionFromShortNextPrice(marketIndex, amountSyntheticTokensToShift);
      userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][
        msg.sender
      ] += amountSyntheticTokensToShift;
    }

    userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] = batched_stakerNextTokenShiftIndex[
      marketIndex
    ];
  }

  /*╔════════════════════════════╗
    ║    WITHDRAWAL & MINTING    ║
    ╚════════════════════════════╝*/

  /**
  @notice Internal logic for withdrawing stakes.
  @dev Mint user any outstanding float before withdrawing.
  @param marketIndex Market index of token.
  @param amount Amount to withdraw.
  @param token Synthetic token that was staked.
  */
  function _withdraw(
    uint32 marketIndex,
    address token,
    uint256 amount
  ) internal virtual {
    require(userAmountStaked[token][msg.sender] > 0, "nothing to withdraw");
    _mintAccumulatedFloat(marketIndex, msg.sender);

    userAmountStaked[token][msg.sender] = userAmountStaked[token][msg.sender] - amount;

    uint256 amountFees = (amount * marketUnstakeFee_e18[marketIndex]) / 1e18;

    IERC20(token).transfer(floatTreasury, amountFees);
    IERC20(token).transfer(msg.sender, amount - amountFees);

    emit StakeWithdrawn(msg.sender, token, amount);
  }

  /**
  @notice Withdraw function. Allows users to unstake.
  @param amount Amount to withdraw.
  @param token Address of the token for which to withdraw.
  */
  function withdraw(address token, uint256 amount) external {
    ILongShort(longShort).updateSystemState(marketIndexOfToken[token]);

    uint32 marketIndex = marketIndexOfToken[token];

    _withdraw(marketIndex, token, amount);

    if (userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] > 0) {
      // If they still have outstanding shifts after minting float, then check
      // that they don't withdraw more than their shifts allow.
      uint256 amountToShiftForThisToken = syntheticTokens[marketIndex][true] == token
        ? userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][msg.sender]
        : userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][msg.sender];

      require(
        userAmountStaked[token][msg.sender] >= amountToShiftForThisToken,
        "Outstanding next price stake shifts too great"
      );
    }
  }

  /**
  @notice Allows users to withdraw their entire stake for a token.
  @param token Address of the token for which to withdraw.
  */
  function withdrawAll(address token) external {
    ILongShort(longShort).updateSystemState(marketIndexOfToken[token]);

    uint32 marketIndex = marketIndexOfToken[token];

    uint256 amountToShiftForThisToken = syntheticTokens[marketIndex][true] == token
      ? userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][msg.sender]
      : userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][msg.sender];

    _withdraw(marketIndex, token, userAmountStaked[token][msg.sender] - amountToShiftForThisToken);
  }
}
".

Existing Test Reports:

"The software run successfully without errors."

Based on the given test reports, please identify and succinctly summarize all bugs causing issues within the contract codes. The objective is to obtain a clear and consolidated overview of all identified bugs. Conclude with a comprehensive test report summarizing the findings.

